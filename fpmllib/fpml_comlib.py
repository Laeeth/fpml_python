#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Tue Feb 23 09:01:05 2016 by generateDS.py version 2.19b.
#
# Command line options:
#   ('-f', '')
#   ('-o', 'fpml01/fpml_comlib.py')
#   ('-s', 'fpml01/fpml_comapp.py')
#   ('--super', 'fpml01/fpml_comlib')
#   ('--member-specs', 'dict')
#   ('--export', 'write')
#
# Command line arguments:
#   fpml-master-schema-and-key-gen-scripts/src/schema/fpml-com.xsd
#
# Command line:
#   ./generateDS.py -f -o "fpml01/fpml_comlib.py" -s "fpml01/fpml_comapp.py" --super="fpml01/fpml_comlib" --member-specs="dict" --export="write" fpml-master-schema-and-key-gen-scripts/src/schema/fpml-com.xsd
#
# Current working directory (os.getcwd()):
#   Test02
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
from lxml import etree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        parser = etree_.ETCompatXMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                return instring.encode(ExternalEncoding)
            else:
                return instring

    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class AbsoluteTolerance(GeneratedsSuper):
    """The acceptable tolerance in the delivered quantity of a physical
    commodity product in terms of a number of units of that product."""
    member_data_items_ = {
        'positive': MemberSpec_('positive', 'xsd:decimal', 0),
        'negative': MemberSpec_('negative', 'xsd:decimal', 0),
        'unit': MemberSpec_('unit', 'QuantityUnit', 0),
        'optionOwnerPartyReference': MemberSpec_('optionOwnerPartyReference', 'PartyReference', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, positive=None, negative=None, unit=None, optionOwnerPartyReference=None):
        self.original_tagname_ = None
        self.positive = positive
        self.negative = negative
        self.unit = unit
        self.optionOwnerPartyReference = optionOwnerPartyReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbsoluteTolerance)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbsoluteTolerance.subclass:
            return AbsoluteTolerance.subclass(*args_, **kwargs_)
        else:
            return AbsoluteTolerance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_positive(self): return self.positive
    def set_positive(self, positive): self.positive = positive
    def get_negative(self): return self.negative
    def set_negative(self, negative): self.negative = negative
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def get_optionOwnerPartyReference(self): return self.optionOwnerPartyReference
    def set_optionOwnerPartyReference(self, optionOwnerPartyReference): self.optionOwnerPartyReference = optionOwnerPartyReference
    def hasContent_(self):
        if (
            self.positive is not None or
            self.negative is not None or
            self.unit is not None or
            self.optionOwnerPartyReference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AbsoluteTolerance', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbsoluteTolerance')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AbsoluteTolerance', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbsoluteTolerance'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AbsoluteTolerance', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.positive is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spositive>%s</%spositive>%s' % (namespace_, self.gds_format_float(self.positive, input_name='positive'), namespace_, eol_))
        if self.negative is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snegative>%s</%snegative>%s' % (namespace_, self.gds_format_float(self.negative, input_name='negative'), namespace_, eol_))
        if self.unit is not None:
            self.unit.export(outfile, level, namespace_, name_='unit', pretty_print=pretty_print)
        if self.optionOwnerPartyReference is not None:
            self.optionOwnerPartyReference.export(outfile, level, namespace_, name_='optionOwnerPartyReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'positive':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'positive')
            self.positive = fval_
        elif nodeName_ == 'negative':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'negative')
            self.negative = fval_
        elif nodeName_ == 'unit':
            obj_ = QuantityUnit.factory()
            obj_.build(child_)
            self.unit = obj_
            obj_.original_tagname_ = 'unit'
        elif nodeName_ == 'optionOwnerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.optionOwnerPartyReference = obj_
            obj_.original_tagname_ = 'optionOwnerPartyReference'
# end class AbsoluteTolerance


class BullionDeliveryLocation(GeneratedsSuper):
    """A scheme defining where bullion is to be delivered for a Bullion
    Transaction."""
    member_data_items_ = {
        'bullionDeliveryLocationScheme': MemberSpec_('bullionDeliveryLocationScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, bullionDeliveryLocationScheme='http://www.fpml.org/coding-scheme/bullion-delivery-location', valueOf_=None):
        self.original_tagname_ = None
        self.bullionDeliveryLocationScheme = _cast(None, bullionDeliveryLocationScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BullionDeliveryLocation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BullionDeliveryLocation.subclass:
            return BullionDeliveryLocation.subclass(*args_, **kwargs_)
        else:
            return BullionDeliveryLocation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_bullionDeliveryLocationScheme(self): return self.bullionDeliveryLocationScheme
    def set_bullionDeliveryLocationScheme(self, bullionDeliveryLocationScheme): self.bullionDeliveryLocationScheme = bullionDeliveryLocationScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BullionDeliveryLocation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BullionDeliveryLocation')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BullionDeliveryLocation', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BullionDeliveryLocation'):
        if self.bullionDeliveryLocationScheme != "http://www.fpml.org/coding-scheme/bullion-delivery-location" and 'bullionDeliveryLocationScheme' not in already_processed:
            already_processed.add('bullionDeliveryLocationScheme')
            outfile.write(' bullionDeliveryLocationScheme=%s' % (quote_attrib(self.bullionDeliveryLocationScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BullionDeliveryLocation', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('bullionDeliveryLocationScheme', node)
        if value is not None and 'bullionDeliveryLocationScheme' not in already_processed:
            already_processed.add('bullionDeliveryLocationScheme')
            self.bullionDeliveryLocationScheme = value
            self.validate_NonEmptyURI(self.bullionDeliveryLocationScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BullionDeliveryLocation


class CoalAttributeDecimal(GeneratedsSuper):
    """The different options for specifying the attributes of a coal
    quality measure as a decimal value."""
    member_data_items_ = {
        'standardContent': MemberSpec_('standardContent', 'xsd:decimal', 0),
        'rejectionLimit': MemberSpec_('rejectionLimit', 'xsd:decimal', 0),
        'rejectionLimit': MemberSpec_('rejectionLimit', 'xsd:decimal', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, standardContent=None, rejectionLimit=None):
        self.original_tagname_ = None
        self.standardContent = standardContent
        self.rejectionLimit = rejectionLimit
        self.rejectionLimit = rejectionLimit
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CoalAttributeDecimal)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoalAttributeDecimal.subclass:
            return CoalAttributeDecimal.subclass(*args_, **kwargs_)
        else:
            return CoalAttributeDecimal(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_standardContent(self): return self.standardContent
    def set_standardContent(self, standardContent): self.standardContent = standardContent
    def get_rejectionLimit(self): return self.rejectionLimit
    def set_rejectionLimit(self, rejectionLimit): self.rejectionLimit = rejectionLimit
    def get_rejectionLimit(self): return self.rejectionLimit
    def set_rejectionLimit(self, rejectionLimit): self.rejectionLimit = rejectionLimit
    def hasContent_(self):
        if (
            self.standardContent is not None or
            self.rejectionLimit is not None or
            self.rejectionLimit is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CoalAttributeDecimal', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CoalAttributeDecimal')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CoalAttributeDecimal', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CoalAttributeDecimal'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CoalAttributeDecimal', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.standardContent is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstandardContent>%s</%sstandardContent>%s' % (namespace_, self.gds_format_float(self.standardContent, input_name='standardContent'), namespace_, eol_))
        if self.rejectionLimit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srejectionLimit>%s</%srejectionLimit>%s' % (namespace_, self.gds_format_float(self.rejectionLimit, input_name='rejectionLimit'), namespace_, eol_))
        if self.rejectionLimit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srejectionLimit>%s</%srejectionLimit>%s' % (namespace_, self.gds_format_float(self.rejectionLimit, input_name='rejectionLimit'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'standardContent':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'standardContent')
            self.standardContent = fval_
        elif nodeName_ == 'rejectionLimit':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'rejectionLimit')
            self.rejectionLimit = fval_
        elif nodeName_ == 'rejectionLimit':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'rejectionLimit')
            self.rejectionLimit = fval_
# end class CoalAttributeDecimal


class CoalAttributePercentage(GeneratedsSuper):
    """The different options for specifying the attributes of a coal
    quality measure as a percentage of the measured value."""
    member_data_items_ = {
        'standardContent': MemberSpec_('standardContent', ['RestrictedPercentage', 'xsd:decimal'], 0),
        'rejectionLimit': MemberSpec_('rejectionLimit', ['RestrictedPercentage', 'xsd:decimal'], 0),
        'rejectionLimit': MemberSpec_('rejectionLimit', ['RestrictedPercentage', 'xsd:decimal'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, standardContent=None, rejectionLimit=None):
        self.original_tagname_ = None
        self.standardContent = standardContent
        self.validate_RestrictedPercentage(self.standardContent)
        self.rejectionLimit = rejectionLimit
        self.validate_RestrictedPercentage(self.rejectionLimit)
        self.rejectionLimit = rejectionLimit
        self.validate_RestrictedPercentage(self.rejectionLimit)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CoalAttributePercentage)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoalAttributePercentage.subclass:
            return CoalAttributePercentage.subclass(*args_, **kwargs_)
        else:
            return CoalAttributePercentage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_standardContent(self): return self.standardContent
    def set_standardContent(self, standardContent): self.standardContent = standardContent
    def get_rejectionLimit(self): return self.rejectionLimit
    def set_rejectionLimit(self, rejectionLimit): self.rejectionLimit = rejectionLimit
    def get_rejectionLimit(self): return self.rejectionLimit
    def set_rejectionLimit(self, rejectionLimit): self.rejectionLimit = rejectionLimit
    def validate_RestrictedPercentage(self, value):
        # Validate type RestrictedPercentage, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on RestrictedPercentage' % {"value" : value} )
            if value > 1:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on RestrictedPercentage' % {"value" : value} )
    def hasContent_(self):
        if (
            self.standardContent is not None or
            self.rejectionLimit is not None or
            self.rejectionLimit is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CoalAttributePercentage', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CoalAttributePercentage')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CoalAttributePercentage', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CoalAttributePercentage'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CoalAttributePercentage', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.standardContent is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstandardContent>%s</%sstandardContent>%s' % (namespace_, self.gds_format_float(self.standardContent, input_name='standardContent'), namespace_, eol_))
        if self.rejectionLimit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srejectionLimit>%s</%srejectionLimit>%s' % (namespace_, self.gds_format_float(self.rejectionLimit, input_name='rejectionLimit'), namespace_, eol_))
        if self.rejectionLimit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srejectionLimit>%s</%srejectionLimit>%s' % (namespace_, self.gds_format_float(self.rejectionLimit, input_name='rejectionLimit'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'standardContent':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'standardContent')
            self.standardContent = fval_
            # validate type RestrictedPercentage
            self.validate_RestrictedPercentage(self.standardContent)
        elif nodeName_ == 'rejectionLimit':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'rejectionLimit')
            self.rejectionLimit = fval_
            # validate type RestrictedPercentage
            self.validate_RestrictedPercentage(self.rejectionLimit)
        elif nodeName_ == 'rejectionLimit':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'rejectionLimit')
            self.rejectionLimit = fval_
            # validate type RestrictedPercentage
            self.validate_RestrictedPercentage(self.rejectionLimit)
# end class CoalAttributePercentage


class CoalDelivery(GeneratedsSuper):
    """The physical delivery conditions for coal."""
    member_data_items_ = {
        'deliveryPoint': MemberSpec_('deliveryPoint', 'CoalDeliveryPoint', 0),
        'deliveryAtSource': MemberSpec_('deliveryAtSource', 'xsd:boolean', 0),
        'quantityVariationAdjustment': MemberSpec_('quantityVariationAdjustment', 'xsd:boolean', 0),
        'transportationEquipment': MemberSpec_('transportationEquipment', 'CoalTransportationEquipment', 0),
        'risk': MemberSpec_('risk', 'CommodityDeliveryRisk', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, deliveryPoint=None, deliveryAtSource=None, quantityVariationAdjustment=None, transportationEquipment=None, risk=None):
        self.original_tagname_ = None
        self.deliveryPoint = deliveryPoint
        self.deliveryAtSource = deliveryAtSource
        self.quantityVariationAdjustment = quantityVariationAdjustment
        self.transportationEquipment = transportationEquipment
        self.risk = risk
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CoalDelivery)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoalDelivery.subclass:
            return CoalDelivery.subclass(*args_, **kwargs_)
        else:
            return CoalDelivery(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_deliveryPoint(self): return self.deliveryPoint
    def set_deliveryPoint(self, deliveryPoint): self.deliveryPoint = deliveryPoint
    def get_deliveryAtSource(self): return self.deliveryAtSource
    def set_deliveryAtSource(self, deliveryAtSource): self.deliveryAtSource = deliveryAtSource
    def get_quantityVariationAdjustment(self): return self.quantityVariationAdjustment
    def set_quantityVariationAdjustment(self, quantityVariationAdjustment): self.quantityVariationAdjustment = quantityVariationAdjustment
    def get_transportationEquipment(self): return self.transportationEquipment
    def set_transportationEquipment(self, transportationEquipment): self.transportationEquipment = transportationEquipment
    def get_risk(self): return self.risk
    def set_risk(self, risk): self.risk = risk
    def hasContent_(self):
        if (
            self.deliveryPoint is not None or
            self.deliveryAtSource is not None or
            self.quantityVariationAdjustment is not None or
            self.transportationEquipment is not None or
            self.risk is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CoalDelivery', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CoalDelivery')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CoalDelivery', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CoalDelivery'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CoalDelivery', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.deliveryPoint is not None:
            self.deliveryPoint.export(outfile, level, namespace_, name_='deliveryPoint', pretty_print=pretty_print)
        if self.deliveryAtSource is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdeliveryAtSource>%s</%sdeliveryAtSource>%s' % (namespace_, self.gds_format_boolean(self.deliveryAtSource, input_name='deliveryAtSource'), namespace_, eol_))
        if self.quantityVariationAdjustment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%squantityVariationAdjustment>%s</%squantityVariationAdjustment>%s' % (namespace_, self.gds_format_boolean(self.quantityVariationAdjustment, input_name='quantityVariationAdjustment'), namespace_, eol_))
        if self.transportationEquipment is not None:
            self.transportationEquipment.export(outfile, level, namespace_, name_='transportationEquipment', pretty_print=pretty_print)
        if self.risk is not None:
            self.risk.export(outfile, level, namespace_, name_='risk', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'deliveryPoint':
            obj_ = CoalDeliveryPoint.factory()
            obj_.build(child_)
            self.deliveryPoint = obj_
            obj_.original_tagname_ = 'deliveryPoint'
        elif nodeName_ == 'deliveryAtSource':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'deliveryAtSource')
            self.deliveryAtSource = ival_
        elif nodeName_ == 'quantityVariationAdjustment':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'quantityVariationAdjustment')
            self.quantityVariationAdjustment = ival_
        elif nodeName_ == 'transportationEquipment':
            obj_ = CoalTransportationEquipment.factory()
            obj_.build(child_)
            self.transportationEquipment = obj_
            obj_.original_tagname_ = 'transportationEquipment'
        elif nodeName_ == 'risk':
            obj_ = CommodityDeliveryRisk.factory()
            obj_.build(child_)
            self.risk = obj_
            obj_.original_tagname_ = 'risk'
# end class CoalDelivery


class CoalDeliveryPoint(GeneratedsSuper):
    """A scheme identifying the types of the Delivery Point for a
    physically settled coal trade."""
    member_data_items_ = {
        'deliveryPointScheme': MemberSpec_('deliveryPointScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, deliveryPointScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.deliveryPointScheme = _cast(None, deliveryPointScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CoalDeliveryPoint)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoalDeliveryPoint.subclass:
            return CoalDeliveryPoint.subclass(*args_, **kwargs_)
        else:
            return CoalDeliveryPoint(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_deliveryPointScheme(self): return self.deliveryPointScheme
    def set_deliveryPointScheme(self, deliveryPointScheme): self.deliveryPointScheme = deliveryPointScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CoalDeliveryPoint', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CoalDeliveryPoint')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CoalDeliveryPoint', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CoalDeliveryPoint'):
        if self.deliveryPointScheme is not None and 'deliveryPointScheme' not in already_processed:
            already_processed.add('deliveryPointScheme')
            outfile.write(' deliveryPointScheme=%s' % (quote_attrib(self.deliveryPointScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CoalDeliveryPoint', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('deliveryPointScheme', node)
        if value is not None and 'deliveryPointScheme' not in already_processed:
            already_processed.add('deliveryPointScheme')
            self.deliveryPointScheme = value
            self.validate_NonEmptyURI(self.deliveryPointScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CoalDeliveryPoint


class CoalProduct(GeneratedsSuper):
    """A type defining the characteristics of the coal being traded in a
    physically settled gas transaction."""
    member_data_items_ = {
        'type_': MemberSpec_('type_', 'CoalProductType', 0),
        'coalProductSpecifications': MemberSpec_('coalProductSpecifications', 'CoalProductSpecifications', 0),
        'source': MemberSpec_('source', 'CoalProductSource', 1),
        'sCoTASpecifications': MemberSpec_('sCoTASpecifications', 'xsd:boolean', 0),
        'btuQualityAdjustment': MemberSpec_('btuQualityAdjustment', 'CoalQualityAdjustments', 0),
        'so2QualityAdjustment': MemberSpec_('so2QualityAdjustment', 'CoalQualityAdjustments', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, type_=None, coalProductSpecifications=None, source=None, sCoTASpecifications=None, btuQualityAdjustment=None, so2QualityAdjustment=None):
        self.original_tagname_ = None
        self.type_ = type_
        self.coalProductSpecifications = coalProductSpecifications
        if source is None:
            self.source = []
        else:
            self.source = source
        self.sCoTASpecifications = sCoTASpecifications
        self.btuQualityAdjustment = btuQualityAdjustment
        self.so2QualityAdjustment = so2QualityAdjustment
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CoalProduct)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoalProduct.subclass:
            return CoalProduct.subclass(*args_, **kwargs_)
        else:
            return CoalProduct(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_coalProductSpecifications(self): return self.coalProductSpecifications
    def set_coalProductSpecifications(self, coalProductSpecifications): self.coalProductSpecifications = coalProductSpecifications
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def add_source(self, value): self.source.append(value)
    def insert_source_at(self, index, value): self.source.insert(index, value)
    def replace_source_at(self, index, value): self.source[index] = value
    def get_sCoTASpecifications(self): return self.sCoTASpecifications
    def set_sCoTASpecifications(self, sCoTASpecifications): self.sCoTASpecifications = sCoTASpecifications
    def get_btuQualityAdjustment(self): return self.btuQualityAdjustment
    def set_btuQualityAdjustment(self, btuQualityAdjustment): self.btuQualityAdjustment = btuQualityAdjustment
    def get_so2QualityAdjustment(self): return self.so2QualityAdjustment
    def set_so2QualityAdjustment(self, so2QualityAdjustment): self.so2QualityAdjustment = so2QualityAdjustment
    def hasContent_(self):
        if (
            self.type_ is not None or
            self.coalProductSpecifications is not None or
            self.source or
            self.sCoTASpecifications is not None or
            self.btuQualityAdjustment is not None or
            self.so2QualityAdjustment is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CoalProduct', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CoalProduct')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CoalProduct', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CoalProduct'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CoalProduct', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            self.type_.export(outfile, level, namespace_, name_='type', pretty_print=pretty_print)
        if self.coalProductSpecifications is not None:
            self.coalProductSpecifications.export(outfile, level, namespace_, name_='coalProductSpecifications', pretty_print=pretty_print)
        for source_ in self.source:
            source_.export(outfile, level, namespace_, name_='source', pretty_print=pretty_print)
        if self.sCoTASpecifications is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssCoTASpecifications>%s</%ssCoTASpecifications>%s' % (namespace_, self.gds_format_boolean(self.sCoTASpecifications, input_name='sCoTASpecifications'), namespace_, eol_))
        if self.btuQualityAdjustment is not None:
            self.btuQualityAdjustment.export(outfile, level, namespace_, name_='btuQualityAdjustment', pretty_print=pretty_print)
        if self.so2QualityAdjustment is not None:
            self.so2QualityAdjustment.export(outfile, level, namespace_, name_='so2QualityAdjustment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            obj_ = CoalProductType.factory()
            obj_.build(child_)
            self.type_ = obj_
            obj_.original_tagname_ = 'type'
        elif nodeName_ == 'coalProductSpecifications':
            obj_ = CoalProductSpecifications.factory()
            obj_.build(child_)
            self.coalProductSpecifications = obj_
            obj_.original_tagname_ = 'coalProductSpecifications'
        elif nodeName_ == 'source':
            obj_ = CoalProductSource.factory()
            obj_.build(child_)
            self.source.append(obj_)
            obj_.original_tagname_ = 'source'
        elif nodeName_ == 'sCoTASpecifications':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'sCoTASpecifications')
            self.sCoTASpecifications = ival_
        elif nodeName_ == 'btuQualityAdjustment':
            obj_ = CoalQualityAdjustments.factory()
            obj_.build(child_)
            self.btuQualityAdjustment = obj_
            obj_.original_tagname_ = 'btuQualityAdjustment'
        elif nodeName_ == 'so2QualityAdjustment':
            obj_ = CoalQualityAdjustments.factory()
            obj_.build(child_)
            self.so2QualityAdjustment = obj_
            obj_.original_tagname_ = 'so2QualityAdjustment'
# end class CoalProduct


class CoalProductSource(GeneratedsSuper):
    """A scheme identifying the sources of coal for a physically settled
    coal trade."""
    member_data_items_ = {
        'commodityCoalProductSourceScheme': MemberSpec_('commodityCoalProductSourceScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, commodityCoalProductSourceScheme='http://www.fpml.org/coding-scheme/commodity-coal-product-source', valueOf_=None):
        self.original_tagname_ = None
        self.commodityCoalProductSourceScheme = _cast(None, commodityCoalProductSourceScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CoalProductSource)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoalProductSource.subclass:
            return CoalProductSource.subclass(*args_, **kwargs_)
        else:
            return CoalProductSource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commodityCoalProductSourceScheme(self): return self.commodityCoalProductSourceScheme
    def set_commodityCoalProductSourceScheme(self, commodityCoalProductSourceScheme): self.commodityCoalProductSourceScheme = commodityCoalProductSourceScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CoalProductSource', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CoalProductSource')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CoalProductSource', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CoalProductSource'):
        if self.commodityCoalProductSourceScheme != "http://www.fpml.org/coding-scheme/commodity-coal-product-source" and 'commodityCoalProductSourceScheme' not in already_processed:
            already_processed.add('commodityCoalProductSourceScheme')
            outfile.write(' commodityCoalProductSourceScheme=%s' % (quote_attrib(self.commodityCoalProductSourceScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CoalProductSource', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('commodityCoalProductSourceScheme', node)
        if value is not None and 'commodityCoalProductSourceScheme' not in already_processed:
            already_processed.add('commodityCoalProductSourceScheme')
            self.commodityCoalProductSourceScheme = value
            self.validate_NonEmptyURI(self.commodityCoalProductSourceScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CoalProductSource


class CoalProductSpecifications(GeneratedsSuper):
    """The different options for specifying the quality attributes of the
    coal to be delivered."""
    member_data_items_ = {
        'standardQuality': MemberSpec_('standardQuality', 'CoalStandardQuality', 0),
        'standardQualitySchedule': MemberSpec_('standardQualitySchedule', 'CoalStandardQualitySchedule', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, standardQuality=None, standardQualitySchedule=None):
        self.original_tagname_ = None
        self.standardQuality = standardQuality
        self.standardQualitySchedule = standardQualitySchedule
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CoalProductSpecifications)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoalProductSpecifications.subclass:
            return CoalProductSpecifications.subclass(*args_, **kwargs_)
        else:
            return CoalProductSpecifications(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_standardQuality(self): return self.standardQuality
    def set_standardQuality(self, standardQuality): self.standardQuality = standardQuality
    def get_standardQualitySchedule(self): return self.standardQualitySchedule
    def set_standardQualitySchedule(self, standardQualitySchedule): self.standardQualitySchedule = standardQualitySchedule
    def hasContent_(self):
        if (
            self.standardQuality is not None or
            self.standardQualitySchedule is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CoalProductSpecifications', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CoalProductSpecifications')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CoalProductSpecifications', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CoalProductSpecifications'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CoalProductSpecifications', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.standardQuality is not None:
            self.standardQuality.export(outfile, level, namespace_, name_='standardQuality', pretty_print=pretty_print)
        if self.standardQualitySchedule is not None:
            self.standardQualitySchedule.export(outfile, level, namespace_, name_='standardQualitySchedule', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'standardQuality':
            obj_ = CoalStandardQuality.factory()
            obj_.build(child_)
            self.standardQuality = obj_
            obj_.original_tagname_ = 'standardQuality'
        elif nodeName_ == 'standardQualitySchedule':
            obj_ = CoalStandardQualitySchedule.factory()
            obj_.build(child_)
            self.standardQualitySchedule = obj_
            obj_.original_tagname_ = 'standardQualitySchedule'
# end class CoalProductSpecifications


class CoalProductType(GeneratedsSuper):
    """A scheme identifying the types of coal for a physically settled coal
    trade."""
    member_data_items_ = {
        'commodityCoalProductTypeScheme': MemberSpec_('commodityCoalProductTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, commodityCoalProductTypeScheme='http://www.fpml.org/coding-scheme/commodity-coal-product-type', valueOf_=None):
        self.original_tagname_ = None
        self.commodityCoalProductTypeScheme = _cast(None, commodityCoalProductTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CoalProductType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoalProductType.subclass:
            return CoalProductType.subclass(*args_, **kwargs_)
        else:
            return CoalProductType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commodityCoalProductTypeScheme(self): return self.commodityCoalProductTypeScheme
    def set_commodityCoalProductTypeScheme(self, commodityCoalProductTypeScheme): self.commodityCoalProductTypeScheme = commodityCoalProductTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CoalProductType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CoalProductType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CoalProductType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CoalProductType'):
        if self.commodityCoalProductTypeScheme != "http://www.fpml.org/coding-scheme/commodity-coal-product-type" and 'commodityCoalProductTypeScheme' not in already_processed:
            already_processed.add('commodityCoalProductTypeScheme')
            outfile.write(' commodityCoalProductTypeScheme=%s' % (quote_attrib(self.commodityCoalProductTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CoalProductType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('commodityCoalProductTypeScheme', node)
        if value is not None and 'commodityCoalProductTypeScheme' not in already_processed:
            already_processed.add('commodityCoalProductTypeScheme')
            self.commodityCoalProductTypeScheme = value
            self.validate_NonEmptyURI(self.commodityCoalProductTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CoalProductType


class CoalQualityAdjustments(GeneratedsSuper):
    """A scheme identifying the quality adjustment formulae for a
    physically settled coal trade."""
    member_data_items_ = {
        'commodityCoalQualityAdjustmentsScheme': MemberSpec_('commodityCoalQualityAdjustmentsScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, commodityCoalQualityAdjustmentsScheme='http://www.fpml.org/coding-scheme/commodity-coal-quality-adjustments', valueOf_=None):
        self.original_tagname_ = None
        self.commodityCoalQualityAdjustmentsScheme = _cast(None, commodityCoalQualityAdjustmentsScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CoalQualityAdjustments)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoalQualityAdjustments.subclass:
            return CoalQualityAdjustments.subclass(*args_, **kwargs_)
        else:
            return CoalQualityAdjustments(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commodityCoalQualityAdjustmentsScheme(self): return self.commodityCoalQualityAdjustmentsScheme
    def set_commodityCoalQualityAdjustmentsScheme(self, commodityCoalQualityAdjustmentsScheme): self.commodityCoalQualityAdjustmentsScheme = commodityCoalQualityAdjustmentsScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CoalQualityAdjustments', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CoalQualityAdjustments')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CoalQualityAdjustments', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CoalQualityAdjustments'):
        if self.commodityCoalQualityAdjustmentsScheme != "http://www.fpml.org/coding-scheme/commodity-coal-quality-adjustments" and 'commodityCoalQualityAdjustmentsScheme' not in already_processed:
            already_processed.add('commodityCoalQualityAdjustmentsScheme')
            outfile.write(' commodityCoalQualityAdjustmentsScheme=%s' % (quote_attrib(self.commodityCoalQualityAdjustmentsScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CoalQualityAdjustments', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('commodityCoalQualityAdjustmentsScheme', node)
        if value is not None and 'commodityCoalQualityAdjustmentsScheme' not in already_processed:
            already_processed.add('commodityCoalQualityAdjustmentsScheme')
            self.commodityCoalQualityAdjustmentsScheme = value
            self.validate_NonEmptyURI(self.commodityCoalQualityAdjustmentsScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CoalQualityAdjustments


class CoalStandardQuality(GeneratedsSuper):
    """The quality attributes of the coal to be delivered."""
    member_data_items_ = {
        'moisture': MemberSpec_('moisture', 'CoalAttributePercentage', 0),
        'ash': MemberSpec_('ash', 'CoalAttributePercentage', 0),
        'sulfur': MemberSpec_('sulfur', 'CoalAttributePercentage', 0),
        'SO2': MemberSpec_('SO2', 'CoalAttributePercentage', 0),
        'volatile': MemberSpec_('volatile', 'CoalAttributePercentage', 0),
        'BTUperLB': MemberSpec_('BTUperLB', 'CoalAttributeDecimal', 0),
        'topSize': MemberSpec_('topSize', 'CoalAttributeDecimal', 0),
        'finesPassingScreen': MemberSpec_('finesPassingScreen', 'CoalAttributeDecimal', 0),
        'grindability': MemberSpec_('grindability', 'CoalAttributeDecimal', 0),
        'ashFusionTemperature': MemberSpec_('ashFusionTemperature', 'CoalAttributeDecimal', 0),
        'initialDeformation': MemberSpec_('initialDeformation', 'CoalAttributeDecimal', 0),
        'softeningHeightWidth': MemberSpec_('softeningHeightWidth', 'CoalAttributeDecimal', 0),
        'softeningHeightHalfWidth': MemberSpec_('softeningHeightHalfWidth', 'CoalAttributeDecimal', 0),
        'fluid': MemberSpec_('fluid', 'CoalAttributeDecimal', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, moisture=None, ash=None, sulfur=None, SO2=None, volatile=None, BTUperLB=None, topSize=None, finesPassingScreen=None, grindability=None, ashFusionTemperature=None, initialDeformation=None, softeningHeightWidth=None, softeningHeightHalfWidth=None, fluid=None):
        self.original_tagname_ = None
        self.moisture = moisture
        self.ash = ash
        self.sulfur = sulfur
        self.SO2 = SO2
        self.volatile = volatile
        self.BTUperLB = BTUperLB
        self.topSize = topSize
        self.finesPassingScreen = finesPassingScreen
        self.grindability = grindability
        self.ashFusionTemperature = ashFusionTemperature
        self.initialDeformation = initialDeformation
        self.softeningHeightWidth = softeningHeightWidth
        self.softeningHeightHalfWidth = softeningHeightHalfWidth
        self.fluid = fluid
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CoalStandardQuality)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoalStandardQuality.subclass:
            return CoalStandardQuality.subclass(*args_, **kwargs_)
        else:
            return CoalStandardQuality(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_moisture(self): return self.moisture
    def set_moisture(self, moisture): self.moisture = moisture
    def get_ash(self): return self.ash
    def set_ash(self, ash): self.ash = ash
    def get_sulfur(self): return self.sulfur
    def set_sulfur(self, sulfur): self.sulfur = sulfur
    def get_SO2(self): return self.SO2
    def set_SO2(self, SO2): self.SO2 = SO2
    def get_volatile(self): return self.volatile
    def set_volatile(self, volatile): self.volatile = volatile
    def get_BTUperLB(self): return self.BTUperLB
    def set_BTUperLB(self, BTUperLB): self.BTUperLB = BTUperLB
    def get_topSize(self): return self.topSize
    def set_topSize(self, topSize): self.topSize = topSize
    def get_finesPassingScreen(self): return self.finesPassingScreen
    def set_finesPassingScreen(self, finesPassingScreen): self.finesPassingScreen = finesPassingScreen
    def get_grindability(self): return self.grindability
    def set_grindability(self, grindability): self.grindability = grindability
    def get_ashFusionTemperature(self): return self.ashFusionTemperature
    def set_ashFusionTemperature(self, ashFusionTemperature): self.ashFusionTemperature = ashFusionTemperature
    def get_initialDeformation(self): return self.initialDeformation
    def set_initialDeformation(self, initialDeformation): self.initialDeformation = initialDeformation
    def get_softeningHeightWidth(self): return self.softeningHeightWidth
    def set_softeningHeightWidth(self, softeningHeightWidth): self.softeningHeightWidth = softeningHeightWidth
    def get_softeningHeightHalfWidth(self): return self.softeningHeightHalfWidth
    def set_softeningHeightHalfWidth(self, softeningHeightHalfWidth): self.softeningHeightHalfWidth = softeningHeightHalfWidth
    def get_fluid(self): return self.fluid
    def set_fluid(self, fluid): self.fluid = fluid
    def hasContent_(self):
        if (
            self.moisture is not None or
            self.ash is not None or
            self.sulfur is not None or
            self.SO2 is not None or
            self.volatile is not None or
            self.BTUperLB is not None or
            self.topSize is not None or
            self.finesPassingScreen is not None or
            self.grindability is not None or
            self.ashFusionTemperature is not None or
            self.initialDeformation is not None or
            self.softeningHeightWidth is not None or
            self.softeningHeightHalfWidth is not None or
            self.fluid is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CoalStandardQuality', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CoalStandardQuality')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CoalStandardQuality', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CoalStandardQuality'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CoalStandardQuality', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.moisture is not None:
            self.moisture.export(outfile, level, namespace_, name_='moisture', pretty_print=pretty_print)
        if self.ash is not None:
            self.ash.export(outfile, level, namespace_, name_='ash', pretty_print=pretty_print)
        if self.sulfur is not None:
            self.sulfur.export(outfile, level, namespace_, name_='sulfur', pretty_print=pretty_print)
        if self.SO2 is not None:
            self.SO2.export(outfile, level, namespace_, name_='SO2', pretty_print=pretty_print)
        if self.volatile is not None:
            self.volatile.export(outfile, level, namespace_, name_='volatile', pretty_print=pretty_print)
        if self.BTUperLB is not None:
            self.BTUperLB.export(outfile, level, namespace_, name_='BTUperLB', pretty_print=pretty_print)
        if self.topSize is not None:
            self.topSize.export(outfile, level, namespace_, name_='topSize', pretty_print=pretty_print)
        if self.finesPassingScreen is not None:
            self.finesPassingScreen.export(outfile, level, namespace_, name_='finesPassingScreen', pretty_print=pretty_print)
        if self.grindability is not None:
            self.grindability.export(outfile, level, namespace_, name_='grindability', pretty_print=pretty_print)
        if self.ashFusionTemperature is not None:
            self.ashFusionTemperature.export(outfile, level, namespace_, name_='ashFusionTemperature', pretty_print=pretty_print)
        if self.initialDeformation is not None:
            self.initialDeformation.export(outfile, level, namespace_, name_='initialDeformation', pretty_print=pretty_print)
        if self.softeningHeightWidth is not None:
            self.softeningHeightWidth.export(outfile, level, namespace_, name_='softeningHeightWidth', pretty_print=pretty_print)
        if self.softeningHeightHalfWidth is not None:
            self.softeningHeightHalfWidth.export(outfile, level, namespace_, name_='softeningHeightHalfWidth', pretty_print=pretty_print)
        if self.fluid is not None:
            self.fluid.export(outfile, level, namespace_, name_='fluid', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'moisture':
            obj_ = CoalAttributePercentage.factory()
            obj_.build(child_)
            self.moisture = obj_
            obj_.original_tagname_ = 'moisture'
        elif nodeName_ == 'ash':
            obj_ = CoalAttributePercentage.factory()
            obj_.build(child_)
            self.ash = obj_
            obj_.original_tagname_ = 'ash'
        elif nodeName_ == 'sulfur':
            obj_ = CoalAttributePercentage.factory()
            obj_.build(child_)
            self.sulfur = obj_
            obj_.original_tagname_ = 'sulfur'
        elif nodeName_ == 'SO2':
            obj_ = CoalAttributePercentage.factory()
            obj_.build(child_)
            self.SO2 = obj_
            obj_.original_tagname_ = 'SO2'
        elif nodeName_ == 'volatile':
            obj_ = CoalAttributePercentage.factory()
            obj_.build(child_)
            self.volatile = obj_
            obj_.original_tagname_ = 'volatile'
        elif nodeName_ == 'BTUperLB':
            obj_ = CoalAttributeDecimal.factory()
            obj_.build(child_)
            self.BTUperLB = obj_
            obj_.original_tagname_ = 'BTUperLB'
        elif nodeName_ == 'topSize':
            obj_ = CoalAttributeDecimal.factory()
            obj_.build(child_)
            self.topSize = obj_
            obj_.original_tagname_ = 'topSize'
        elif nodeName_ == 'finesPassingScreen':
            obj_ = CoalAttributeDecimal.factory()
            obj_.build(child_)
            self.finesPassingScreen = obj_
            obj_.original_tagname_ = 'finesPassingScreen'
        elif nodeName_ == 'grindability':
            obj_ = CoalAttributeDecimal.factory()
            obj_.build(child_)
            self.grindability = obj_
            obj_.original_tagname_ = 'grindability'
        elif nodeName_ == 'ashFusionTemperature':
            obj_ = CoalAttributeDecimal.factory()
            obj_.build(child_)
            self.ashFusionTemperature = obj_
            obj_.original_tagname_ = 'ashFusionTemperature'
        elif nodeName_ == 'initialDeformation':
            obj_ = CoalAttributeDecimal.factory()
            obj_.build(child_)
            self.initialDeformation = obj_
            obj_.original_tagname_ = 'initialDeformation'
        elif nodeName_ == 'softeningHeightWidth':
            obj_ = CoalAttributeDecimal.factory()
            obj_.build(child_)
            self.softeningHeightWidth = obj_
            obj_.original_tagname_ = 'softeningHeightWidth'
        elif nodeName_ == 'softeningHeightHalfWidth':
            obj_ = CoalAttributeDecimal.factory()
            obj_.build(child_)
            self.softeningHeightHalfWidth = obj_
            obj_.original_tagname_ = 'softeningHeightHalfWidth'
        elif nodeName_ == 'fluid':
            obj_ = CoalAttributeDecimal.factory()
            obj_.build(child_)
            self.fluid = obj_
            obj_.original_tagname_ = 'fluid'
# end class CoalStandardQuality


class CoalStandardQualitySchedule(GeneratedsSuper):
    """The quality attributes of the coal to be delivered, specified on a
    periodic basis."""
    member_data_items_ = {
        'StandardQualityStep': MemberSpec_('StandardQualityStep', 'CoalStandardQuality', 1),
        'deliveryPeriodsReference': MemberSpec_('deliveryPeriodsReference', 'CalculationPeriodsReference', 0),
        'deliveryPeriodsScheduleReference': MemberSpec_('deliveryPeriodsScheduleReference', 'CalculationPeriodsScheduleReference', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, StandardQualityStep=None, deliveryPeriodsReference=None, deliveryPeriodsScheduleReference=None):
        self.original_tagname_ = None
        if StandardQualityStep is None:
            self.StandardQualityStep = []
        else:
            self.StandardQualityStep = StandardQualityStep
        self.deliveryPeriodsReference = deliveryPeriodsReference
        self.deliveryPeriodsScheduleReference = deliveryPeriodsScheduleReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CoalStandardQualitySchedule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoalStandardQualitySchedule.subclass:
            return CoalStandardQualitySchedule.subclass(*args_, **kwargs_)
        else:
            return CoalStandardQualitySchedule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StandardQualityStep(self): return self.StandardQualityStep
    def set_StandardQualityStep(self, StandardQualityStep): self.StandardQualityStep = StandardQualityStep
    def add_StandardQualityStep(self, value): self.StandardQualityStep.append(value)
    def insert_StandardQualityStep_at(self, index, value): self.StandardQualityStep.insert(index, value)
    def replace_StandardQualityStep_at(self, index, value): self.StandardQualityStep[index] = value
    def get_deliveryPeriodsReference(self): return self.deliveryPeriodsReference
    def set_deliveryPeriodsReference(self, deliveryPeriodsReference): self.deliveryPeriodsReference = deliveryPeriodsReference
    def get_deliveryPeriodsScheduleReference(self): return self.deliveryPeriodsScheduleReference
    def set_deliveryPeriodsScheduleReference(self, deliveryPeriodsScheduleReference): self.deliveryPeriodsScheduleReference = deliveryPeriodsScheduleReference
    def hasContent_(self):
        if (
            self.StandardQualityStep or
            self.deliveryPeriodsReference is not None or
            self.deliveryPeriodsScheduleReference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CoalStandardQualitySchedule', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CoalStandardQualitySchedule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CoalStandardQualitySchedule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CoalStandardQualitySchedule'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CoalStandardQualitySchedule', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for StandardQualityStep_ in self.StandardQualityStep:
            StandardQualityStep_.export(outfile, level, namespace_, name_='StandardQualityStep', pretty_print=pretty_print)
        if self.deliveryPeriodsReference is not None:
            self.deliveryPeriodsReference.export(outfile, level, namespace_, name_='deliveryPeriodsReference', pretty_print=pretty_print)
        if self.deliveryPeriodsScheduleReference is not None:
            self.deliveryPeriodsScheduleReference.export(outfile, level, namespace_, name_='deliveryPeriodsScheduleReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StandardQualityStep':
            obj_ = CoalStandardQuality.factory()
            obj_.build(child_)
            self.StandardQualityStep.append(obj_)
            obj_.original_tagname_ = 'StandardQualityStep'
        elif nodeName_ == 'deliveryPeriodsReference':
            obj_ = CalculationPeriodsReference.factory()
            obj_.build(child_)
            self.deliveryPeriodsReference = obj_
            obj_.original_tagname_ = 'deliveryPeriodsReference'
        elif nodeName_ == 'deliveryPeriodsScheduleReference':
            obj_ = CalculationPeriodsScheduleReference.factory()
            obj_.build(child_)
            self.deliveryPeriodsScheduleReference = obj_
            obj_.original_tagname_ = 'deliveryPeriodsScheduleReference'
# end class CoalStandardQualitySchedule


class CoalTransportationEquipment(GeneratedsSuper):
    """A scheme identifying the methods by which coal may be transported."""
    member_data_items_ = {
        'commodityCoalTransportationEquipmentScheme': MemberSpec_('commodityCoalTransportationEquipmentScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, commodityCoalTransportationEquipmentScheme='http://www.fpml.org/coding-scheme/commodity-coal-transportation-equipment', valueOf_=None):
        self.original_tagname_ = None
        self.commodityCoalTransportationEquipmentScheme = _cast(None, commodityCoalTransportationEquipmentScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CoalTransportationEquipment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoalTransportationEquipment.subclass:
            return CoalTransportationEquipment.subclass(*args_, **kwargs_)
        else:
            return CoalTransportationEquipment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commodityCoalTransportationEquipmentScheme(self): return self.commodityCoalTransportationEquipmentScheme
    def set_commodityCoalTransportationEquipmentScheme(self, commodityCoalTransportationEquipmentScheme): self.commodityCoalTransportationEquipmentScheme = commodityCoalTransportationEquipmentScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CoalTransportationEquipment', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CoalTransportationEquipment')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CoalTransportationEquipment', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CoalTransportationEquipment'):
        if self.commodityCoalTransportationEquipmentScheme != "http://www.fpml.org/coding-scheme/commodity-coal-transportation-equipment" and 'commodityCoalTransportationEquipmentScheme' not in already_processed:
            already_processed.add('commodityCoalTransportationEquipmentScheme')
            outfile.write(' commodityCoalTransportationEquipmentScheme=%s' % (quote_attrib(self.commodityCoalTransportationEquipmentScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CoalTransportationEquipment', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('commodityCoalTransportationEquipmentScheme', node)
        if value is not None and 'commodityCoalTransportationEquipmentScheme' not in already_processed:
            already_processed.add('commodityCoalTransportationEquipmentScheme')
            self.commodityCoalTransportationEquipmentScheme = value
            self.validate_NonEmptyURI(self.commodityCoalTransportationEquipmentScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CoalTransportationEquipment


class CommodityBarrier(GeneratedsSuper):
    """The specification of how a barrier option will trigger (that is,
    knock-in or knock-out) or expire based on the position of the
    spot rate relative to trigger level."""
    member_data_items_ = {
        'knock': MemberSpec_('knock', ['CommodityKnockEnum', 'Token', 'xsd:token'], 0),
        'featurePaymentAmount': MemberSpec_('featurePaymentAmount', 'PositiveMoney', 0),
        'trigger': MemberSpec_('trigger', 'CommodityTrigger', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, knock=None, featurePaymentAmount=None, trigger=None):
        self.original_tagname_ = None
        self.knock = knock
        self.validate_CommodityKnockEnum(self.knock)
        self.featurePaymentAmount = featurePaymentAmount
        self.trigger = trigger
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityBarrier)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityBarrier.subclass:
            return CommodityBarrier.subclass(*args_, **kwargs_)
        else:
            return CommodityBarrier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_knock(self): return self.knock
    def set_knock(self, knock): self.knock = knock
    def get_featurePaymentAmount(self): return self.featurePaymentAmount
    def set_featurePaymentAmount(self, featurePaymentAmount): self.featurePaymentAmount = featurePaymentAmount
    def get_trigger(self): return self.trigger
    def set_trigger(self, trigger): self.trigger = trigger
    def validate_CommodityKnockEnum(self, value):
        # Validate type CommodityKnockEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['In', 'Out']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CommodityKnockEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on CommodityKnockEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.knock is not None or
            self.featurePaymentAmount is not None or
            self.trigger is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityBarrier', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityBarrier')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityBarrier', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityBarrier'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityBarrier', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.knock is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sknock>%s</%sknock>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.knock), input_name='knock')), namespace_, eol_))
        if self.featurePaymentAmount is not None:
            self.featurePaymentAmount.export(outfile, level, namespace_, name_='featurePaymentAmount', pretty_print=pretty_print)
        if self.trigger is not None:
            self.trigger.export(outfile, level, namespace_, name_='trigger', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'knock':
            knock_ = child_.text
            knock_ = re_.sub(String_cleanup_pat_, " ", knock_).strip()
            knock_ = self.gds_validate_string(knock_, node, 'knock')
            self.knock = knock_
            # validate type CommodityKnockEnum
            self.validate_CommodityKnockEnum(self.knock)
        elif nodeName_ == 'featurePaymentAmount':
            obj_ = PositiveMoney.factory()
            obj_.build(child_)
            self.featurePaymentAmount = obj_
            obj_.original_tagname_ = 'featurePaymentAmount'
        elif nodeName_ == 'trigger':
            obj_ = CommodityTrigger.factory()
            obj_.build(child_)
            self.trigger = obj_
            obj_.original_tagname_ = 'trigger'
# end class CommodityBarrier


class CommodityBasket(GeneratedsSuper):
    """Describes the swap's underlyer when it has multiple asset
    components."""
    member_data_items_ = {
        'basketName': MemberSpec_('basketName', 'BasketName', 0),
        'basketId': MemberSpec_('basketId', 'BasketId', 1),
        'basketId': MemberSpec_('basketId', 'BasketId', 1),
        'notionalQuantityBasket': MemberSpec_('notionalQuantityBasket', 'CommodityBasketByNotional', 0),
        'notionalAmountBasket': MemberSpec_('notionalAmountBasket', 'CommodityBasketByPercentage', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, basketName=None, basketId=None, notionalQuantityBasket=None, notionalAmountBasket=None):
        self.original_tagname_ = None
        self.basketName = basketName
        if basketId is None:
            self.basketId = []
        else:
            self.basketId = basketId
        if basketId is None:
            self.basketId = []
        else:
            self.basketId = basketId
        self.notionalQuantityBasket = notionalQuantityBasket
        self.notionalAmountBasket = notionalAmountBasket
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityBasket)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityBasket.subclass:
            return CommodityBasket.subclass(*args_, **kwargs_)
        else:
            return CommodityBasket(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_basketName(self): return self.basketName
    def set_basketName(self, basketName): self.basketName = basketName
    def get_basketId(self): return self.basketId
    def set_basketId(self, basketId): self.basketId = basketId
    def add_basketId(self, value): self.basketId.append(value)
    def insert_basketId_at(self, index, value): self.basketId.insert(index, value)
    def replace_basketId_at(self, index, value): self.basketId[index] = value
    def get_basketId(self): return self.basketId
    def set_basketId(self, basketId): self.basketId = basketId
    def add_basketId(self, value): self.basketId.append(value)
    def insert_basketId_at(self, index, value): self.basketId.insert(index, value)
    def replace_basketId_at(self, index, value): self.basketId[index] = value
    def get_notionalQuantityBasket(self): return self.notionalQuantityBasket
    def set_notionalQuantityBasket(self, notionalQuantityBasket): self.notionalQuantityBasket = notionalQuantityBasket
    def get_notionalAmountBasket(self): return self.notionalAmountBasket
    def set_notionalAmountBasket(self, notionalAmountBasket): self.notionalAmountBasket = notionalAmountBasket
    def hasContent_(self):
        if (
            self.basketName is not None or
            self.basketId or
            self.basketId or
            self.notionalQuantityBasket is not None or
            self.notionalAmountBasket is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityBasket', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityBasket')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityBasket', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityBasket'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityBasket', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.basketName is not None:
            self.basketName.export(outfile, level, namespace_, name_='basketName', pretty_print=pretty_print)
        for basketId_ in self.basketId:
            basketId_.export(outfile, level, namespace_, name_='basketId', pretty_print=pretty_print)
        for basketId_ in self.basketId:
            basketId_.export(outfile, level, namespace_, name_='basketId', pretty_print=pretty_print)
        if self.notionalQuantityBasket is not None:
            self.notionalQuantityBasket.export(outfile, level, namespace_, name_='notionalQuantityBasket', pretty_print=pretty_print)
        if self.notionalAmountBasket is not None:
            self.notionalAmountBasket.export(outfile, level, namespace_, name_='notionalAmountBasket', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'basketName':
            obj_ = BasketName.factory()
            obj_.build(child_)
            self.basketName = obj_
            obj_.original_tagname_ = 'basketName'
        elif nodeName_ == 'basketId':
            obj_ = BasketId.factory()
            obj_.build(child_)
            self.basketId.append(obj_)
            obj_.original_tagname_ = 'basketId'
        elif nodeName_ == 'basketId':
            obj_ = BasketId.factory()
            obj_.build(child_)
            self.basketId.append(obj_)
            obj_.original_tagname_ = 'basketId'
        elif nodeName_ == 'notionalQuantityBasket':
            obj_ = CommodityBasketByNotional.factory()
            obj_.build(child_)
            self.notionalQuantityBasket = obj_
            obj_.original_tagname_ = 'notionalQuantityBasket'
        elif nodeName_ == 'notionalAmountBasket':
            obj_ = CommodityBasketByPercentage.factory()
            obj_.build(child_)
            self.notionalAmountBasket = obj_
            obj_.original_tagname_ = 'notionalAmountBasket'
# end class CommodityBasket


class CommodityBasketBase(GeneratedsSuper):
    """Abstract base class for all underlying assets."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityBasketBase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityBasketBase.subclass:
            return CommodityBasketBase.subclass(*args_, **kwargs_)
        else:
            return CommodityBasketBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityBasketBase', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityBasketBase')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityBasketBase', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityBasketBase'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityBasketBase', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CommodityBasketBase


class CommodityBasketByNotional(CommodityBasketBase):
    member_data_items_ = {
        'underlying': MemberSpec_('underlying', 'CommodityBasketUnderlyingByNotional', 1),
    }
    subclass = None
    superclass = CommodityBasketBase
    def __init__(self, id=None, underlying=None):
        self.original_tagname_ = None
        super(CommodityBasketByNotional, self).__init__(id, )
        if underlying is None:
            self.underlying = []
        else:
            self.underlying = underlying
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityBasketByNotional)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityBasketByNotional.subclass:
            return CommodityBasketByNotional.subclass(*args_, **kwargs_)
        else:
            return CommodityBasketByNotional(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_underlying(self): return self.underlying
    def set_underlying(self, underlying): self.underlying = underlying
    def add_underlying(self, value): self.underlying.append(value)
    def insert_underlying_at(self, index, value): self.underlying.insert(index, value)
    def replace_underlying_at(self, index, value): self.underlying[index] = value
    def hasContent_(self):
        if (
            self.underlying or
            super(CommodityBasketByNotional, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityBasketByNotional', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityBasketByNotional')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityBasketByNotional', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityBasketByNotional'):
        super(CommodityBasketByNotional, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityBasketByNotional')
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityBasketByNotional', fromsubclass_=False, pretty_print=True):
        super(CommodityBasketByNotional, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for underlying_ in self.underlying:
            underlying_.export(outfile, level, namespace_, name_='underlying', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CommodityBasketByNotional, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'underlying':
            obj_ = CommodityBasketUnderlyingByNotional.factory()
            obj_.build(child_)
            self.underlying.append(obj_)
            obj_.original_tagname_ = 'underlying'
        super(CommodityBasketByNotional, self).buildChildren(child_, node, nodeName_, True)
# end class CommodityBasketByNotional


class CommodityBasketByPercentage(CommodityBasketBase):
    member_data_items_ = {
        'underlying': MemberSpec_('underlying', 'CommodityBasketUnderlyingByPercentage', 1),
        'notionalAmount': MemberSpec_('notionalAmount', 'NotionalAmount', 0),
    }
    subclass = None
    superclass = CommodityBasketBase
    def __init__(self, id=None, underlying=None, notionalAmount=None):
        self.original_tagname_ = None
        super(CommodityBasketByPercentage, self).__init__(id, )
        if underlying is None:
            self.underlying = []
        else:
            self.underlying = underlying
        self.notionalAmount = notionalAmount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityBasketByPercentage)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityBasketByPercentage.subclass:
            return CommodityBasketByPercentage.subclass(*args_, **kwargs_)
        else:
            return CommodityBasketByPercentage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_underlying(self): return self.underlying
    def set_underlying(self, underlying): self.underlying = underlying
    def add_underlying(self, value): self.underlying.append(value)
    def insert_underlying_at(self, index, value): self.underlying.insert(index, value)
    def replace_underlying_at(self, index, value): self.underlying[index] = value
    def get_notionalAmount(self): return self.notionalAmount
    def set_notionalAmount(self, notionalAmount): self.notionalAmount = notionalAmount
    def hasContent_(self):
        if (
            self.underlying or
            self.notionalAmount is not None or
            super(CommodityBasketByPercentage, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityBasketByPercentage', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityBasketByPercentage')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityBasketByPercentage', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityBasketByPercentage'):
        super(CommodityBasketByPercentage, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityBasketByPercentage')
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityBasketByPercentage', fromsubclass_=False, pretty_print=True):
        super(CommodityBasketByPercentage, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for underlying_ in self.underlying:
            underlying_.export(outfile, level, namespace_, name_='underlying', pretty_print=pretty_print)
        if self.notionalAmount is not None:
            self.notionalAmount.export(outfile, level, namespace_, name_='notionalAmount', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CommodityBasketByPercentage, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'underlying':
            obj_ = CommodityBasketUnderlyingByPercentage.factory()
            obj_.build(child_)
            self.underlying.append(obj_)
            obj_.original_tagname_ = 'underlying'
        elif nodeName_ == 'notionalAmount':
            obj_ = NotionalAmount.factory()
            obj_.build(child_)
            self.notionalAmount = obj_
            obj_.original_tagname_ = 'notionalAmount'
        super(CommodityBasketByPercentage, self).buildChildren(child_, node, nodeName_, True)
# end class CommodityBasketByPercentage


class CommodityBasketUnderlyingBase(GeneratedsSuper):
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'direction': MemberSpec_('direction', ['PayerReceiverEnum', 'Token', 'xsd:token'], 0),
        'commodity': MemberSpec_('commodity', 'Commodity', 0),
        'pricingDates': MemberSpec_('pricingDates', 'CommodityPricingDates', 0),
        'averagingMethod': MemberSpec_('averagingMethod', ['AveragingMethodEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, direction=None, commodity=None, pricingDates=None, averagingMethod=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.direction = direction
        self.validate_PayerReceiverEnum(self.direction)
        self.commodity = commodity
        self.pricingDates = pricingDates
        self.averagingMethod = averagingMethod
        self.validate_AveragingMethodEnum(self.averagingMethod)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityBasketUnderlyingBase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityBasketUnderlyingBase.subclass:
            return CommodityBasketUnderlyingBase.subclass(*args_, **kwargs_)
        else:
            return CommodityBasketUnderlyingBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_direction(self): return self.direction
    def set_direction(self, direction): self.direction = direction
    def get_commodity(self): return self.commodity
    def set_commodity(self, commodity): self.commodity = commodity
    def get_pricingDates(self): return self.pricingDates
    def set_pricingDates(self, pricingDates): self.pricingDates = pricingDates
    def get_averagingMethod(self): return self.averagingMethod
    def set_averagingMethod(self, averagingMethod): self.averagingMethod = averagingMethod
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_PayerReceiverEnum(self, value):
        # Validate type PayerReceiverEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Payer', 'Receiver']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PayerReceiverEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on PayerReceiverEnum' % {"value" : value} )
    def validate_AveragingMethodEnum(self, value):
        # Validate type AveragingMethodEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Unweighted', 'Weighted']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AveragingMethodEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on AveragingMethodEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.direction is not None or
            self.commodity is not None or
            self.pricingDates is not None or
            self.averagingMethod is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityBasketUnderlyingBase', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityBasketUnderlyingBase')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityBasketUnderlyingBase', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityBasketUnderlyingBase'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityBasketUnderlyingBase', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.direction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdirection>%s</%sdirection>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.direction), input_name='direction')), namespace_, eol_))
        if self.commodity is not None:
            self.commodity.export(outfile, level, namespace_, name_='commodity', pretty_print=pretty_print)
        if self.pricingDates is not None:
            self.pricingDates.export(outfile, level, namespace_, name_='pricingDates', pretty_print=pretty_print)
        if self.averagingMethod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saveragingMethod>%s</%saveragingMethod>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.averagingMethod), input_name='averagingMethod')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'direction':
            direction_ = child_.text
            direction_ = re_.sub(String_cleanup_pat_, " ", direction_).strip()
            direction_ = self.gds_validate_string(direction_, node, 'direction')
            self.direction = direction_
            # validate type PayerReceiverEnum
            self.validate_PayerReceiverEnum(self.direction)
        elif nodeName_ == 'commodity':
            obj_ = Commodity.factory()
            obj_.build(child_)
            self.commodity = obj_
            obj_.original_tagname_ = 'commodity'
        elif nodeName_ == 'pricingDates':
            obj_ = CommodityPricingDates.factory()
            obj_.build(child_)
            self.pricingDates = obj_
            obj_.original_tagname_ = 'pricingDates'
        elif nodeName_ == 'averagingMethod':
            averagingMethod_ = child_.text
            averagingMethod_ = re_.sub(String_cleanup_pat_, " ", averagingMethod_).strip()
            averagingMethod_ = self.gds_validate_string(averagingMethod_, node, 'averagingMethod')
            self.averagingMethod = averagingMethod_
            # validate type AveragingMethodEnum
            self.validate_AveragingMethodEnum(self.averagingMethod)
# end class CommodityBasketUnderlyingBase


class CommodityBasketUnderlyingByNotional(CommodityBasketUnderlyingBase):
    member_data_items_ = {
        'fx': MemberSpec_('fx', 'FxRateAsset', 0),
        'conversionFactor': MemberSpec_('conversionFactor', 'xsd:decimal', 0),
        'notionalQuantitySchedule': MemberSpec_('notionalQuantitySchedule', 'CommodityNotionalQuantitySchedule', 0),
        'notionalQuantity': MemberSpec_('notionalQuantity', 'CommodityNotionalQuantity', 0),
        'settlementPeriodsNotionalQuantity': MemberSpec_('settlementPeriodsNotionalQuantity', 'CommoditySettlementPeriodsNotionalQuantity', 1),
        'totalNotionalQuantity': MemberSpec_('totalNotionalQuantity', 'xsd:decimal', 0),
        'quantityReference': MemberSpec_('quantityReference', 'QuantityReference', 0),
    }
    subclass = None
    superclass = CommodityBasketUnderlyingBase
    def __init__(self, id=None, direction=None, commodity=None, pricingDates=None, averagingMethod=None, fx=None, conversionFactor=None, notionalQuantitySchedule=None, notionalQuantity=None, settlementPeriodsNotionalQuantity=None, totalNotionalQuantity=None, quantityReference=None):
        self.original_tagname_ = None
        super(CommodityBasketUnderlyingByNotional, self).__init__(id, direction, commodity, pricingDates, averagingMethod, )
        self.fx = fx
        self.conversionFactor = conversionFactor
        self.notionalQuantitySchedule = notionalQuantitySchedule
        self.notionalQuantity = notionalQuantity
        if settlementPeriodsNotionalQuantity is None:
            self.settlementPeriodsNotionalQuantity = []
        else:
            self.settlementPeriodsNotionalQuantity = settlementPeriodsNotionalQuantity
        self.totalNotionalQuantity = totalNotionalQuantity
        self.quantityReference = quantityReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityBasketUnderlyingByNotional)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityBasketUnderlyingByNotional.subclass:
            return CommodityBasketUnderlyingByNotional.subclass(*args_, **kwargs_)
        else:
            return CommodityBasketUnderlyingByNotional(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fx(self): return self.fx
    def set_fx(self, fx): self.fx = fx
    def get_conversionFactor(self): return self.conversionFactor
    def set_conversionFactor(self, conversionFactor): self.conversionFactor = conversionFactor
    def get_notionalQuantitySchedule(self): return self.notionalQuantitySchedule
    def set_notionalQuantitySchedule(self, notionalQuantitySchedule): self.notionalQuantitySchedule = notionalQuantitySchedule
    def get_notionalQuantity(self): return self.notionalQuantity
    def set_notionalQuantity(self, notionalQuantity): self.notionalQuantity = notionalQuantity
    def get_settlementPeriodsNotionalQuantity(self): return self.settlementPeriodsNotionalQuantity
    def set_settlementPeriodsNotionalQuantity(self, settlementPeriodsNotionalQuantity): self.settlementPeriodsNotionalQuantity = settlementPeriodsNotionalQuantity
    def add_settlementPeriodsNotionalQuantity(self, value): self.settlementPeriodsNotionalQuantity.append(value)
    def insert_settlementPeriodsNotionalQuantity_at(self, index, value): self.settlementPeriodsNotionalQuantity.insert(index, value)
    def replace_settlementPeriodsNotionalQuantity_at(self, index, value): self.settlementPeriodsNotionalQuantity[index] = value
    def get_totalNotionalQuantity(self): return self.totalNotionalQuantity
    def set_totalNotionalQuantity(self, totalNotionalQuantity): self.totalNotionalQuantity = totalNotionalQuantity
    def get_quantityReference(self): return self.quantityReference
    def set_quantityReference(self, quantityReference): self.quantityReference = quantityReference
    def hasContent_(self):
        if (
            self.fx is not None or
            self.conversionFactor is not None or
            self.notionalQuantitySchedule is not None or
            self.notionalQuantity is not None or
            self.settlementPeriodsNotionalQuantity or
            self.totalNotionalQuantity is not None or
            self.quantityReference is not None or
            super(CommodityBasketUnderlyingByNotional, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityBasketUnderlyingByNotional', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityBasketUnderlyingByNotional')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityBasketUnderlyingByNotional', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityBasketUnderlyingByNotional'):
        super(CommodityBasketUnderlyingByNotional, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityBasketUnderlyingByNotional')
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityBasketUnderlyingByNotional', fromsubclass_=False, pretty_print=True):
        super(CommodityBasketUnderlyingByNotional, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.fx is not None:
            self.fx.export(outfile, level, namespace_, name_='fx', pretty_print=pretty_print)
        if self.conversionFactor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sconversionFactor>%s</%sconversionFactor>%s' % (namespace_, self.gds_format_float(self.conversionFactor, input_name='conversionFactor'), namespace_, eol_))
        if self.notionalQuantitySchedule is not None:
            self.notionalQuantitySchedule.export(outfile, level, namespace_, name_='notionalQuantitySchedule', pretty_print=pretty_print)
        if self.notionalQuantity is not None:
            self.notionalQuantity.export(outfile, level, namespace_, name_='notionalQuantity', pretty_print=pretty_print)
        for settlementPeriodsNotionalQuantity_ in self.settlementPeriodsNotionalQuantity:
            settlementPeriodsNotionalQuantity_.export(outfile, level, namespace_, name_='settlementPeriodsNotionalQuantity', pretty_print=pretty_print)
        if self.totalNotionalQuantity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalNotionalQuantity>%s</%stotalNotionalQuantity>%s' % (namespace_, self.gds_format_float(self.totalNotionalQuantity, input_name='totalNotionalQuantity'), namespace_, eol_))
        if self.quantityReference is not None:
            self.quantityReference.export(outfile, level, namespace_, name_='quantityReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CommodityBasketUnderlyingByNotional, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fx':
            obj_ = CommodityFx.factory()
            obj_.build(child_)
            self.fx = obj_
            obj_.original_tagname_ = 'fx'
        elif nodeName_ == 'conversionFactor':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'conversionFactor')
            self.conversionFactor = fval_
        elif nodeName_ == 'notionalQuantitySchedule':
            obj_ = CommodityNotionalQuantitySchedule.factory()
            obj_.build(child_)
            self.notionalQuantitySchedule = obj_
            obj_.original_tagname_ = 'notionalQuantitySchedule'
        elif nodeName_ == 'notionalQuantity':
            class_obj_ = self.get_class_obj_(child_, CommodityNotionalQuantity)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.notionalQuantity = obj_
            obj_.original_tagname_ = 'notionalQuantity'
        elif nodeName_ == 'settlementPeriodsNotionalQuantity':
            obj_ = CommoditySettlementPeriodsNotionalQuantity.factory()
            obj_.build(child_)
            self.settlementPeriodsNotionalQuantity.append(obj_)
            obj_.original_tagname_ = 'settlementPeriodsNotionalQuantity'
        elif nodeName_ == 'totalNotionalQuantity':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'totalNotionalQuantity')
            self.totalNotionalQuantity = fval_
        elif nodeName_ == 'quantityReference':
            obj_ = QuantityReference.factory()
            obj_.build(child_)
            self.quantityReference = obj_
            obj_.original_tagname_ = 'quantityReference'
        super(CommodityBasketUnderlyingByNotional, self).buildChildren(child_, node, nodeName_, True)
# end class CommodityBasketUnderlyingByNotional


class CommodityBasketUnderlyingByPercentage(CommodityBasketUnderlyingBase):
    member_data_items_ = {
        'constituentWeight': MemberSpec_('constituentWeight', ['NonNegativeDecimal', 'xsd:decimal'], 0),
    }
    subclass = None
    superclass = CommodityBasketUnderlyingBase
    def __init__(self, id=None, direction=None, commodity=None, pricingDates=None, averagingMethod=None, constituentWeight=None):
        self.original_tagname_ = None
        super(CommodityBasketUnderlyingByPercentage, self).__init__(id, direction, commodity, pricingDates, averagingMethod, )
        self.constituentWeight = constituentWeight
        self.validate_NonNegativeDecimal(self.constituentWeight)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityBasketUnderlyingByPercentage)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityBasketUnderlyingByPercentage.subclass:
            return CommodityBasketUnderlyingByPercentage.subclass(*args_, **kwargs_)
        else:
            return CommodityBasketUnderlyingByPercentage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_constituentWeight(self): return self.constituentWeight
    def set_constituentWeight(self, constituentWeight): self.constituentWeight = constituentWeight
    def validate_NonNegativeDecimal(self, value):
        # Validate type NonNegativeDecimal, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on NonNegativeDecimal' % {"value" : value} )
    def hasContent_(self):
        if (
            self.constituentWeight is not None or
            super(CommodityBasketUnderlyingByPercentage, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityBasketUnderlyingByPercentage', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityBasketUnderlyingByPercentage')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityBasketUnderlyingByPercentage', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityBasketUnderlyingByPercentage'):
        super(CommodityBasketUnderlyingByPercentage, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityBasketUnderlyingByPercentage')
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityBasketUnderlyingByPercentage', fromsubclass_=False, pretty_print=True):
        super(CommodityBasketUnderlyingByPercentage, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.constituentWeight is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sconstituentWeight>%s</%sconstituentWeight>%s' % (namespace_, self.gds_format_float(self.constituentWeight, input_name='constituentWeight'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CommodityBasketUnderlyingByPercentage, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'constituentWeight':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'constituentWeight')
            self.constituentWeight = fval_
            # validate type NonNegativeDecimal
            self.validate_NonNegativeDecimal(self.constituentWeight)
        super(CommodityBasketUnderlyingByPercentage, self).buildChildren(child_, node, nodeName_, True)
# end class CommodityBasketUnderlyingByPercentage


class CommodityDeliveryPeriods(GeneratedsSuper):
    """The different options for specifying the Delivery Periods of a
    physical leg."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'periods': MemberSpec_('periods', 'AdjustableDates', 0),
        'periodsSchedule': MemberSpec_('periodsSchedule', 'CommodityCalculationPeriodsSchedule', 0),
        'calculationPeriodsReference': MemberSpec_('calculationPeriodsReference', 'CalculationPeriodsReference', 0),
        'calculationPeriodsScheduleReference': MemberSpec_('calculationPeriodsScheduleReference', 'CalculationPeriodsScheduleReference', 0),
        'calculationPeriodsDatesReference': MemberSpec_('calculationPeriodsDatesReference', 'CalculationPeriodsDatesReference', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, periods=None, periodsSchedule=None, calculationPeriodsReference=None, calculationPeriodsScheduleReference=None, calculationPeriodsDatesReference=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.periods = periods
        self.periodsSchedule = periodsSchedule
        self.calculationPeriodsReference = calculationPeriodsReference
        self.calculationPeriodsScheduleReference = calculationPeriodsScheduleReference
        self.calculationPeriodsDatesReference = calculationPeriodsDatesReference
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityDeliveryPeriods)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityDeliveryPeriods.subclass:
            return CommodityDeliveryPeriods.subclass(*args_, **kwargs_)
        else:
            return CommodityDeliveryPeriods(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_periods(self): return self.periods
    def set_periods(self, periods): self.periods = periods
    def get_periodsSchedule(self): return self.periodsSchedule
    def set_periodsSchedule(self, periodsSchedule): self.periodsSchedule = periodsSchedule
    def get_calculationPeriodsReference(self): return self.calculationPeriodsReference
    def set_calculationPeriodsReference(self, calculationPeriodsReference): self.calculationPeriodsReference = calculationPeriodsReference
    def get_calculationPeriodsScheduleReference(self): return self.calculationPeriodsScheduleReference
    def set_calculationPeriodsScheduleReference(self, calculationPeriodsScheduleReference): self.calculationPeriodsScheduleReference = calculationPeriodsScheduleReference
    def get_calculationPeriodsDatesReference(self): return self.calculationPeriodsDatesReference
    def set_calculationPeriodsDatesReference(self, calculationPeriodsDatesReference): self.calculationPeriodsDatesReference = calculationPeriodsDatesReference
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.periods is not None or
            self.periodsSchedule is not None or
            self.calculationPeriodsReference is not None or
            self.calculationPeriodsScheduleReference is not None or
            self.calculationPeriodsDatesReference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityDeliveryPeriods', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityDeliveryPeriods')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityDeliveryPeriods', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityDeliveryPeriods'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityDeliveryPeriods', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.periods is not None:
            self.periods.export(outfile, level, namespace_, name_='periods', pretty_print=pretty_print)
        if self.periodsSchedule is not None:
            self.periodsSchedule.export(outfile, level, namespace_, name_='periodsSchedule', pretty_print=pretty_print)
        if self.calculationPeriodsReference is not None:
            self.calculationPeriodsReference.export(outfile, level, namespace_, name_='calculationPeriodsReference', pretty_print=pretty_print)
        if self.calculationPeriodsScheduleReference is not None:
            self.calculationPeriodsScheduleReference.export(outfile, level, namespace_, name_='calculationPeriodsScheduleReference', pretty_print=pretty_print)
        if self.calculationPeriodsDatesReference is not None:
            self.calculationPeriodsDatesReference.export(outfile, level, namespace_, name_='calculationPeriodsDatesReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'periods':
            obj_ = AdjustableDates.factory()
            obj_.build(child_)
            self.periods = obj_
            obj_.original_tagname_ = 'periods'
        elif nodeName_ == 'periodsSchedule':
            obj_ = CommodityCalculationPeriodsSchedule.factory()
            obj_.build(child_)
            self.periodsSchedule = obj_
            obj_.original_tagname_ = 'periodsSchedule'
        elif nodeName_ == 'calculationPeriodsReference':
            obj_ = CalculationPeriodsReference.factory()
            obj_.build(child_)
            self.calculationPeriodsReference = obj_
            obj_.original_tagname_ = 'calculationPeriodsReference'
        elif nodeName_ == 'calculationPeriodsScheduleReference':
            obj_ = CalculationPeriodsScheduleReference.factory()
            obj_.build(child_)
            self.calculationPeriodsScheduleReference = obj_
            obj_.original_tagname_ = 'calculationPeriodsScheduleReference'
        elif nodeName_ == 'calculationPeriodsDatesReference':
            obj_ = CalculationPeriodsDatesReference.factory()
            obj_.build(child_)
            self.calculationPeriodsDatesReference = obj_
            obj_.original_tagname_ = 'calculationPeriodsDatesReference'
# end class CommodityDeliveryPeriods


class CommodityDeliveryPoint(GeneratedsSuper):
    """A scheme identifying the types of the Delivery Point for a
    physically settled commodity trade."""
    member_data_items_ = {
        'deliveryPointScheme': MemberSpec_('deliveryPointScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, deliveryPointScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.deliveryPointScheme = _cast(None, deliveryPointScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityDeliveryPoint)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityDeliveryPoint.subclass:
            return CommodityDeliveryPoint.subclass(*args_, **kwargs_)
        else:
            return CommodityDeliveryPoint(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_deliveryPointScheme(self): return self.deliveryPointScheme
    def set_deliveryPointScheme(self, deliveryPointScheme): self.deliveryPointScheme = deliveryPointScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityDeliveryPoint', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityDeliveryPoint')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityDeliveryPoint', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityDeliveryPoint'):
        if self.deliveryPointScheme is not None and 'deliveryPointScheme' not in already_processed:
            already_processed.add('deliveryPointScheme')
            outfile.write(' deliveryPointScheme=%s' % (quote_attrib(self.deliveryPointScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityDeliveryPoint', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('deliveryPointScheme', node)
        if value is not None and 'deliveryPointScheme' not in already_processed:
            already_processed.add('deliveryPointScheme')
            self.deliveryPointScheme = value
            self.validate_NonEmptyURI(self.deliveryPointScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CommodityDeliveryPoint


class CommodityDeliveryRisk(GeneratedsSuper):
    """A scheme identifying how the parties to the trade aportion
    responsibility for the delivery of the commodity product (for
    example Free On Board, Cost, Insurance, Freight)"""
    member_data_items_ = {
        'deliveryRiskScheme': MemberSpec_('deliveryRiskScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, deliveryRiskScheme='http://www.fpml.org/coding-scheme/commodity-delivery-risk', valueOf_=None):
        self.original_tagname_ = None
        self.deliveryRiskScheme = _cast(None, deliveryRiskScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityDeliveryRisk)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityDeliveryRisk.subclass:
            return CommodityDeliveryRisk.subclass(*args_, **kwargs_)
        else:
            return CommodityDeliveryRisk(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_deliveryRiskScheme(self): return self.deliveryRiskScheme
    def set_deliveryRiskScheme(self, deliveryRiskScheme): self.deliveryRiskScheme = deliveryRiskScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityDeliveryRisk', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityDeliveryRisk')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityDeliveryRisk', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityDeliveryRisk'):
        if self.deliveryRiskScheme != "http://www.fpml.org/coding-scheme/commodity-delivery-risk" and 'deliveryRiskScheme' not in already_processed:
            already_processed.add('deliveryRiskScheme')
            outfile.write(' deliveryRiskScheme=%s' % (quote_attrib(self.deliveryRiskScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityDeliveryRisk', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('deliveryRiskScheme', node)
        if value is not None and 'deliveryRiskScheme' not in already_processed:
            already_processed.add('deliveryRiskScheme')
            self.deliveryRiskScheme = value
            self.validate_NonEmptyURI(self.deliveryRiskScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CommodityDeliveryRisk


class CommodityDigital(GeneratedsSuper):
    """Defined the conditions under which the digital option can triggers
    and, if triggered, what payment results."""
    member_data_items_ = {
        'trigger': MemberSpec_('trigger', 'CommodityTrigger', 0),
        'featurePaymentAmount': MemberSpec_('featurePaymentAmount', 'PositiveMoney', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, trigger=None, featurePaymentAmount=None):
        self.original_tagname_ = None
        self.trigger = trigger
        self.featurePaymentAmount = featurePaymentAmount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityDigital)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityDigital.subclass:
            return CommodityDigital.subclass(*args_, **kwargs_)
        else:
            return CommodityDigital(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_trigger(self): return self.trigger
    def set_trigger(self, trigger): self.trigger = trigger
    def get_featurePaymentAmount(self): return self.featurePaymentAmount
    def set_featurePaymentAmount(self, featurePaymentAmount): self.featurePaymentAmount = featurePaymentAmount
    def hasContent_(self):
        if (
            self.trigger is not None or
            self.featurePaymentAmount is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityDigital', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityDigital')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityDigital', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityDigital'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityDigital', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.trigger is not None:
            self.trigger.export(outfile, level, namespace_, name_='trigger', pretty_print=pretty_print)
        if self.featurePaymentAmount is not None:
            self.featurePaymentAmount.export(outfile, level, namespace_, name_='featurePaymentAmount', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'trigger':
            obj_ = CommodityTrigger.factory()
            obj_.build(child_)
            self.trigger = obj_
            obj_.original_tagname_ = 'trigger'
        elif nodeName_ == 'featurePaymentAmount':
            obj_ = PositiveMoney.factory()
            obj_.build(child_)
            self.featurePaymentAmount = obj_
            obj_.original_tagname_ = 'featurePaymentAmount'
# end class CommodityDigital


class CommodityDigitalExercise(GeneratedsSuper):
    """The parameters for defining how the commodity digital option can be
    exercised. I differs from the CommodityExercise type in that it
    lacks a specification of Settlement Currency. The Settlement
    Currency is specified in the 'featurePayment' element."""
    member_data_items_ = {
        'americanExercise': MemberSpec_('americanExercise', 'AmericanExercise', 0),
        'europeanExercise': MemberSpec_('europeanExercise', 'EuropeanExercise', 0),
        'automaticExercise': MemberSpec_('automaticExercise', 'xsd:boolean', 0),
        'writtenConfirmation': MemberSpec_('writtenConfirmation', 'xsd:boolean', 0),
        'relativePaymentDates': MemberSpec_('relativePaymentDates', 'CommodityRelativePaymentDates', 0),
        'paymentDates': MemberSpec_('paymentDates', 'AdjustableDatesOrRelativeDateOffset', 0),
        'masterAgreementPaymentDates': MemberSpec_('masterAgreementPaymentDates', 'xsd:boolean', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, americanExercise=None, europeanExercise=None, automaticExercise=None, writtenConfirmation=None, relativePaymentDates=None, paymentDates=None, masterAgreementPaymentDates=None):
        self.original_tagname_ = None
        self.americanExercise = americanExercise
        self.europeanExercise = europeanExercise
        self.automaticExercise = automaticExercise
        self.writtenConfirmation = writtenConfirmation
        self.relativePaymentDates = relativePaymentDates
        self.paymentDates = paymentDates
        self.masterAgreementPaymentDates = masterAgreementPaymentDates
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityDigitalExercise)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityDigitalExercise.subclass:
            return CommodityDigitalExercise.subclass(*args_, **kwargs_)
        else:
            return CommodityDigitalExercise(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_americanExercise(self): return self.americanExercise
    def set_americanExercise(self, americanExercise): self.americanExercise = americanExercise
    def get_europeanExercise(self): return self.europeanExercise
    def set_europeanExercise(self, europeanExercise): self.europeanExercise = europeanExercise
    def get_automaticExercise(self): return self.automaticExercise
    def set_automaticExercise(self, automaticExercise): self.automaticExercise = automaticExercise
    def get_writtenConfirmation(self): return self.writtenConfirmation
    def set_writtenConfirmation(self, writtenConfirmation): self.writtenConfirmation = writtenConfirmation
    def get_relativePaymentDates(self): return self.relativePaymentDates
    def set_relativePaymentDates(self, relativePaymentDates): self.relativePaymentDates = relativePaymentDates
    def get_paymentDates(self): return self.paymentDates
    def set_paymentDates(self, paymentDates): self.paymentDates = paymentDates
    def get_masterAgreementPaymentDates(self): return self.masterAgreementPaymentDates
    def set_masterAgreementPaymentDates(self, masterAgreementPaymentDates): self.masterAgreementPaymentDates = masterAgreementPaymentDates
    def hasContent_(self):
        if (
            self.americanExercise is not None or
            self.europeanExercise is not None or
            self.automaticExercise is not None or
            self.writtenConfirmation is not None or
            self.relativePaymentDates is not None or
            self.paymentDates is not None or
            self.masterAgreementPaymentDates is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityDigitalExercise', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityDigitalExercise')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityDigitalExercise', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityDigitalExercise'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityDigitalExercise', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.americanExercise is not None:
            self.americanExercise.export(outfile, level, namespace_, name_='americanExercise', pretty_print=pretty_print)
        if self.europeanExercise is not None:
            self.europeanExercise.export(outfile, level, namespace_, name_='europeanExercise', pretty_print=pretty_print)
        if self.automaticExercise is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sautomaticExercise>%s</%sautomaticExercise>%s' % (namespace_, self.gds_format_boolean(self.automaticExercise, input_name='automaticExercise'), namespace_, eol_))
        if self.writtenConfirmation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%swrittenConfirmation>%s</%swrittenConfirmation>%s' % (namespace_, self.gds_format_boolean(self.writtenConfirmation, input_name='writtenConfirmation'), namespace_, eol_))
        if self.relativePaymentDates is not None:
            self.relativePaymentDates.export(outfile, level, namespace_, name_='relativePaymentDates', pretty_print=pretty_print)
        if self.paymentDates is not None:
            self.paymentDates.export(outfile, level, namespace_, name_='paymentDates', pretty_print=pretty_print)
        if self.masterAgreementPaymentDates is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smasterAgreementPaymentDates>%s</%smasterAgreementPaymentDates>%s' % (namespace_, self.gds_format_boolean(self.masterAgreementPaymentDates, input_name='masterAgreementPaymentDates'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'americanExercise':
            obj_ = CommodityAmericanExercise.factory()
            obj_.build(child_)
            self.americanExercise = obj_
            obj_.original_tagname_ = 'americanExercise'
        elif nodeName_ == 'europeanExercise':
            obj_ = CommodityEuropeanExercise.factory()
            obj_.build(child_)
            self.europeanExercise = obj_
            obj_.original_tagname_ = 'europeanExercise'
        elif nodeName_ == 'automaticExercise':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'automaticExercise')
            self.automaticExercise = ival_
        elif nodeName_ == 'writtenConfirmation':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'writtenConfirmation')
            self.writtenConfirmation = ival_
        elif nodeName_ == 'relativePaymentDates':
            obj_ = CommodityRelativePaymentDates.factory()
            obj_.build(child_)
            self.relativePaymentDates = obj_
            obj_.original_tagname_ = 'relativePaymentDates'
        elif nodeName_ == 'paymentDates':
            obj_ = AdjustableDatesOrRelativeDateOffset.factory()
            obj_.build(child_)
            self.paymentDates = obj_
            obj_.original_tagname_ = 'paymentDates'
        elif nodeName_ == 'masterAgreementPaymentDates':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'masterAgreementPaymentDates')
            self.masterAgreementPaymentDates = ival_
# end class CommodityDigitalExercise


class CommodityExercise(GeneratedsSuper):
    """The parameters for defining how the commodity option can be
    exercised, how it is priced and how it is settled."""
    member_data_items_ = {
        'americanExercise': MemberSpec_('americanExercise', 'AmericanExercise', 0),
        'europeanExercise': MemberSpec_('europeanExercise', 'EuropeanExercise', 0),
        'automaticExercise': MemberSpec_('automaticExercise', 'xsd:boolean', 0),
        'writtenConfirmation': MemberSpec_('writtenConfirmation', 'xsd:boolean', 0),
        'settlementCurrency': MemberSpec_('settlementCurrency', 'IdentifiedCurrency', 0),
        'fx': MemberSpec_('fx', 'FxRateAsset', 0),
        'conversionFactor': MemberSpec_('conversionFactor', 'xsd:decimal', 0),
        'relativePaymentDates': MemberSpec_('relativePaymentDates', 'CommodityRelativePaymentDates', 0),
        'paymentDates': MemberSpec_('paymentDates', 'AdjustableDatesOrRelativeDateOffset', 0),
        'masterAgreementPaymentDates': MemberSpec_('masterAgreementPaymentDates', 'xsd:boolean', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, americanExercise=None, europeanExercise=None, automaticExercise=None, writtenConfirmation=None, settlementCurrency=None, fx=None, conversionFactor=None, relativePaymentDates=None, paymentDates=None, masterAgreementPaymentDates=None):
        self.original_tagname_ = None
        self.americanExercise = americanExercise
        self.europeanExercise = europeanExercise
        self.automaticExercise = automaticExercise
        self.writtenConfirmation = writtenConfirmation
        self.settlementCurrency = settlementCurrency
        self.fx = fx
        self.conversionFactor = conversionFactor
        self.relativePaymentDates = relativePaymentDates
        self.paymentDates = paymentDates
        self.masterAgreementPaymentDates = masterAgreementPaymentDates
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityExercise)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityExercise.subclass:
            return CommodityExercise.subclass(*args_, **kwargs_)
        else:
            return CommodityExercise(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_americanExercise(self): return self.americanExercise
    def set_americanExercise(self, americanExercise): self.americanExercise = americanExercise
    def get_europeanExercise(self): return self.europeanExercise
    def set_europeanExercise(self, europeanExercise): self.europeanExercise = europeanExercise
    def get_automaticExercise(self): return self.automaticExercise
    def set_automaticExercise(self, automaticExercise): self.automaticExercise = automaticExercise
    def get_writtenConfirmation(self): return self.writtenConfirmation
    def set_writtenConfirmation(self, writtenConfirmation): self.writtenConfirmation = writtenConfirmation
    def get_settlementCurrency(self): return self.settlementCurrency
    def set_settlementCurrency(self, settlementCurrency): self.settlementCurrency = settlementCurrency
    def get_fx(self): return self.fx
    def set_fx(self, fx): self.fx = fx
    def get_conversionFactor(self): return self.conversionFactor
    def set_conversionFactor(self, conversionFactor): self.conversionFactor = conversionFactor
    def get_relativePaymentDates(self): return self.relativePaymentDates
    def set_relativePaymentDates(self, relativePaymentDates): self.relativePaymentDates = relativePaymentDates
    def get_paymentDates(self): return self.paymentDates
    def set_paymentDates(self, paymentDates): self.paymentDates = paymentDates
    def get_masterAgreementPaymentDates(self): return self.masterAgreementPaymentDates
    def set_masterAgreementPaymentDates(self, masterAgreementPaymentDates): self.masterAgreementPaymentDates = masterAgreementPaymentDates
    def hasContent_(self):
        if (
            self.americanExercise is not None or
            self.europeanExercise is not None or
            self.automaticExercise is not None or
            self.writtenConfirmation is not None or
            self.settlementCurrency is not None or
            self.fx is not None or
            self.conversionFactor is not None or
            self.relativePaymentDates is not None or
            self.paymentDates is not None or
            self.masterAgreementPaymentDates is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityExercise', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityExercise')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityExercise', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityExercise'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityExercise', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.americanExercise is not None:
            self.americanExercise.export(outfile, level, namespace_, name_='americanExercise', pretty_print=pretty_print)
        if self.europeanExercise is not None:
            self.europeanExercise.export(outfile, level, namespace_, name_='europeanExercise', pretty_print=pretty_print)
        if self.automaticExercise is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sautomaticExercise>%s</%sautomaticExercise>%s' % (namespace_, self.gds_format_boolean(self.automaticExercise, input_name='automaticExercise'), namespace_, eol_))
        if self.writtenConfirmation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%swrittenConfirmation>%s</%swrittenConfirmation>%s' % (namespace_, self.gds_format_boolean(self.writtenConfirmation, input_name='writtenConfirmation'), namespace_, eol_))
        if self.settlementCurrency is not None:
            self.settlementCurrency.export(outfile, level, namespace_, name_='settlementCurrency', pretty_print=pretty_print)
        if self.fx is not None:
            self.fx.export(outfile, level, namespace_, name_='fx', pretty_print=pretty_print)
        if self.conversionFactor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sconversionFactor>%s</%sconversionFactor>%s' % (namespace_, self.gds_format_float(self.conversionFactor, input_name='conversionFactor'), namespace_, eol_))
        if self.relativePaymentDates is not None:
            self.relativePaymentDates.export(outfile, level, namespace_, name_='relativePaymentDates', pretty_print=pretty_print)
        if self.paymentDates is not None:
            self.paymentDates.export(outfile, level, namespace_, name_='paymentDates', pretty_print=pretty_print)
        if self.masterAgreementPaymentDates is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smasterAgreementPaymentDates>%s</%smasterAgreementPaymentDates>%s' % (namespace_, self.gds_format_boolean(self.masterAgreementPaymentDates, input_name='masterAgreementPaymentDates'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'americanExercise':
            obj_ = CommodityAmericanExercise.factory()
            obj_.build(child_)
            self.americanExercise = obj_
            obj_.original_tagname_ = 'americanExercise'
        elif nodeName_ == 'europeanExercise':
            obj_ = CommodityEuropeanExercise.factory()
            obj_.build(child_)
            self.europeanExercise = obj_
            obj_.original_tagname_ = 'europeanExercise'
        elif nodeName_ == 'automaticExercise':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'automaticExercise')
            self.automaticExercise = ival_
        elif nodeName_ == 'writtenConfirmation':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'writtenConfirmation')
            self.writtenConfirmation = ival_
        elif nodeName_ == 'settlementCurrency':
            obj_ = IdentifiedCurrency.factory()
            obj_.build(child_)
            self.settlementCurrency = obj_
            obj_.original_tagname_ = 'settlementCurrency'
        elif nodeName_ == 'fx':
            obj_ = CommodityFx.factory()
            obj_.build(child_)
            self.fx = obj_
            obj_.original_tagname_ = 'fx'
        elif nodeName_ == 'conversionFactor':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'conversionFactor')
            self.conversionFactor = fval_
        elif nodeName_ == 'relativePaymentDates':
            obj_ = CommodityRelativePaymentDates.factory()
            obj_.build(child_)
            self.relativePaymentDates = obj_
            obj_.original_tagname_ = 'relativePaymentDates'
        elif nodeName_ == 'paymentDates':
            obj_ = AdjustableDatesOrRelativeDateOffset.factory()
            obj_.build(child_)
            self.paymentDates = obj_
            obj_.original_tagname_ = 'paymentDates'
        elif nodeName_ == 'masterAgreementPaymentDates':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'masterAgreementPaymentDates')
            self.masterAgreementPaymentDates = ival_
# end class CommodityExercise


class CommodityExerciseBasket(GeneratedsSuper):
    """The parameters for defining how the commodity option can be
    exercised, how it is priced and how it is settled."""
    member_data_items_ = {
        'americanExercise': MemberSpec_('americanExercise', 'AmericanExercise', 0),
        'europeanExercise': MemberSpec_('europeanExercise', 'EuropeanExercise', 0),
        'automaticExercise': MemberSpec_('automaticExercise', 'xsd:boolean', 0),
        'writtenConfirmation': MemberSpec_('writtenConfirmation', 'xsd:boolean', 0),
        'settlementCurrency': MemberSpec_('settlementCurrency', 'IdentifiedCurrency', 0),
        'relativePaymentDates': MemberSpec_('relativePaymentDates', 'CommodityRelativePaymentDates', 0),
        'paymentDates': MemberSpec_('paymentDates', 'AdjustableDatesOrRelativeDateOffset', 0),
        'masterAgreementPaymentDates': MemberSpec_('masterAgreementPaymentDates', 'xsd:boolean', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, americanExercise=None, europeanExercise=None, automaticExercise=None, writtenConfirmation=None, settlementCurrency=None, relativePaymentDates=None, paymentDates=None, masterAgreementPaymentDates=None):
        self.original_tagname_ = None
        self.americanExercise = americanExercise
        self.europeanExercise = europeanExercise
        self.automaticExercise = automaticExercise
        self.writtenConfirmation = writtenConfirmation
        self.settlementCurrency = settlementCurrency
        self.relativePaymentDates = relativePaymentDates
        self.paymentDates = paymentDates
        self.masterAgreementPaymentDates = masterAgreementPaymentDates
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityExerciseBasket)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityExerciseBasket.subclass:
            return CommodityExerciseBasket.subclass(*args_, **kwargs_)
        else:
            return CommodityExerciseBasket(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_americanExercise(self): return self.americanExercise
    def set_americanExercise(self, americanExercise): self.americanExercise = americanExercise
    def get_europeanExercise(self): return self.europeanExercise
    def set_europeanExercise(self, europeanExercise): self.europeanExercise = europeanExercise
    def get_automaticExercise(self): return self.automaticExercise
    def set_automaticExercise(self, automaticExercise): self.automaticExercise = automaticExercise
    def get_writtenConfirmation(self): return self.writtenConfirmation
    def set_writtenConfirmation(self, writtenConfirmation): self.writtenConfirmation = writtenConfirmation
    def get_settlementCurrency(self): return self.settlementCurrency
    def set_settlementCurrency(self, settlementCurrency): self.settlementCurrency = settlementCurrency
    def get_relativePaymentDates(self): return self.relativePaymentDates
    def set_relativePaymentDates(self, relativePaymentDates): self.relativePaymentDates = relativePaymentDates
    def get_paymentDates(self): return self.paymentDates
    def set_paymentDates(self, paymentDates): self.paymentDates = paymentDates
    def get_masterAgreementPaymentDates(self): return self.masterAgreementPaymentDates
    def set_masterAgreementPaymentDates(self, masterAgreementPaymentDates): self.masterAgreementPaymentDates = masterAgreementPaymentDates
    def hasContent_(self):
        if (
            self.americanExercise is not None or
            self.europeanExercise is not None or
            self.automaticExercise is not None or
            self.writtenConfirmation is not None or
            self.settlementCurrency is not None or
            self.relativePaymentDates is not None or
            self.paymentDates is not None or
            self.masterAgreementPaymentDates is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityExerciseBasket', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityExerciseBasket')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityExerciseBasket', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityExerciseBasket'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityExerciseBasket', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.americanExercise is not None:
            self.americanExercise.export(outfile, level, namespace_, name_='americanExercise', pretty_print=pretty_print)
        if self.europeanExercise is not None:
            self.europeanExercise.export(outfile, level, namespace_, name_='europeanExercise', pretty_print=pretty_print)
        if self.automaticExercise is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sautomaticExercise>%s</%sautomaticExercise>%s' % (namespace_, self.gds_format_boolean(self.automaticExercise, input_name='automaticExercise'), namespace_, eol_))
        if self.writtenConfirmation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%swrittenConfirmation>%s</%swrittenConfirmation>%s' % (namespace_, self.gds_format_boolean(self.writtenConfirmation, input_name='writtenConfirmation'), namespace_, eol_))
        if self.settlementCurrency is not None:
            self.settlementCurrency.export(outfile, level, namespace_, name_='settlementCurrency', pretty_print=pretty_print)
        if self.relativePaymentDates is not None:
            self.relativePaymentDates.export(outfile, level, namespace_, name_='relativePaymentDates', pretty_print=pretty_print)
        if self.paymentDates is not None:
            self.paymentDates.export(outfile, level, namespace_, name_='paymentDates', pretty_print=pretty_print)
        if self.masterAgreementPaymentDates is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smasterAgreementPaymentDates>%s</%smasterAgreementPaymentDates>%s' % (namespace_, self.gds_format_boolean(self.masterAgreementPaymentDates, input_name='masterAgreementPaymentDates'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'americanExercise':
            obj_ = CommodityAmericanExercise.factory()
            obj_.build(child_)
            self.americanExercise = obj_
            obj_.original_tagname_ = 'americanExercise'
        elif nodeName_ == 'europeanExercise':
            obj_ = CommodityEuropeanExercise.factory()
            obj_.build(child_)
            self.europeanExercise = obj_
            obj_.original_tagname_ = 'europeanExercise'
        elif nodeName_ == 'automaticExercise':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'automaticExercise')
            self.automaticExercise = ival_
        elif nodeName_ == 'writtenConfirmation':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'writtenConfirmation')
            self.writtenConfirmation = ival_
        elif nodeName_ == 'settlementCurrency':
            obj_ = IdentifiedCurrency.factory()
            obj_.build(child_)
            self.settlementCurrency = obj_
            obj_.original_tagname_ = 'settlementCurrency'
        elif nodeName_ == 'relativePaymentDates':
            obj_ = CommodityRelativePaymentDates.factory()
            obj_.build(child_)
            self.relativePaymentDates = obj_
            obj_.original_tagname_ = 'relativePaymentDates'
        elif nodeName_ == 'paymentDates':
            obj_ = AdjustableDatesOrRelativeDateOffset.factory()
            obj_.build(child_)
            self.paymentDates = obj_
            obj_.original_tagname_ = 'paymentDates'
        elif nodeName_ == 'masterAgreementPaymentDates':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'masterAgreementPaymentDates')
            self.masterAgreementPaymentDates = ival_
# end class CommodityExerciseBasket


class CommodityExercisePeriods(GeneratedsSuper):
    member_data_items_ = {
        'commencementDate': MemberSpec_('commencementDate', 'AdjustableOrRelativeDate', 0),
        'expirationDate': MemberSpec_('expirationDate', 'AdjustableOrRelativeDate', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, commencementDate=None, expirationDate=None):
        self.original_tagname_ = None
        self.commencementDate = commencementDate
        self.expirationDate = expirationDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityExercisePeriods)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityExercisePeriods.subclass:
            return CommodityExercisePeriods.subclass(*args_, **kwargs_)
        else:
            return CommodityExercisePeriods(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commencementDate(self): return self.commencementDate
    def set_commencementDate(self, commencementDate): self.commencementDate = commencementDate
    def get_expirationDate(self): return self.expirationDate
    def set_expirationDate(self, expirationDate): self.expirationDate = expirationDate
    def hasContent_(self):
        if (
            self.commencementDate is not None or
            self.expirationDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityExercisePeriods', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityExercisePeriods')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityExercisePeriods', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityExercisePeriods'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityExercisePeriods', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.commencementDate is not None:
            self.commencementDate.export(outfile, level, namespace_, name_='commencementDate', pretty_print=pretty_print)
        if self.expirationDate is not None:
            self.expirationDate.export(outfile, level, namespace_, name_='expirationDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'commencementDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.commencementDate = obj_
            obj_.original_tagname_ = 'commencementDate'
        elif nodeName_ == 'expirationDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.expirationDate = obj_
            obj_.original_tagname_ = 'expirationDate'
# end class CommodityExercisePeriods


class CommodityExpireRelativeToEvent(GeneratedsSuper):
    """A scheme identifying the physical event relative to which option
    expiration occurs."""
    member_data_items_ = {
        'commodityExpireRelativeToEventScheme': MemberSpec_('commodityExpireRelativeToEventScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, commodityExpireRelativeToEventScheme='http://www.fpml.org/coding-scheme/commodity-expire-relative-to-event', valueOf_=None):
        self.original_tagname_ = None
        self.commodityExpireRelativeToEventScheme = _cast(None, commodityExpireRelativeToEventScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityExpireRelativeToEvent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityExpireRelativeToEvent.subclass:
            return CommodityExpireRelativeToEvent.subclass(*args_, **kwargs_)
        else:
            return CommodityExpireRelativeToEvent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commodityExpireRelativeToEventScheme(self): return self.commodityExpireRelativeToEventScheme
    def set_commodityExpireRelativeToEventScheme(self, commodityExpireRelativeToEventScheme): self.commodityExpireRelativeToEventScheme = commodityExpireRelativeToEventScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityExpireRelativeToEvent', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityExpireRelativeToEvent')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityExpireRelativeToEvent', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityExpireRelativeToEvent'):
        if self.commodityExpireRelativeToEventScheme != "http://www.fpml.org/coding-scheme/commodity-expire-relative-to-event" and 'commodityExpireRelativeToEventScheme' not in already_processed:
            already_processed.add('commodityExpireRelativeToEventScheme')
            outfile.write(' commodityExpireRelativeToEventScheme=%s' % (quote_attrib(self.commodityExpireRelativeToEventScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityExpireRelativeToEvent', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('commodityExpireRelativeToEventScheme', node)
        if value is not None and 'commodityExpireRelativeToEventScheme' not in already_processed:
            already_processed.add('commodityExpireRelativeToEventScheme')
            self.commodityExpireRelativeToEventScheme = value
            self.validate_NonEmptyURI(self.commodityExpireRelativeToEventScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CommodityExpireRelativeToEvent


class CommodityFixedInterestCalculation(GeneratedsSuper):
    member_data_items_ = {
        'fixedRate': MemberSpec_('fixedRate', 'IdentifiedRate', 0),
        'dayCountFraction': MemberSpec_('dayCountFraction', 'DayCountFraction', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, fixedRate=None, dayCountFraction=None):
        self.original_tagname_ = None
        self.fixedRate = fixedRate
        self.dayCountFraction = dayCountFraction
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityFixedInterestCalculation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityFixedInterestCalculation.subclass:
            return CommodityFixedInterestCalculation.subclass(*args_, **kwargs_)
        else:
            return CommodityFixedInterestCalculation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fixedRate(self): return self.fixedRate
    def set_fixedRate(self, fixedRate): self.fixedRate = fixedRate
    def get_dayCountFraction(self): return self.dayCountFraction
    def set_dayCountFraction(self, dayCountFraction): self.dayCountFraction = dayCountFraction
    def hasContent_(self):
        if (
            self.fixedRate is not None or
            self.dayCountFraction is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityFixedInterestCalculation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityFixedInterestCalculation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityFixedInterestCalculation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityFixedInterestCalculation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityFixedInterestCalculation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.fixedRate is not None:
            self.fixedRate.export(outfile, level, namespace_, name_='fixedRate', pretty_print=pretty_print)
        if self.dayCountFraction is not None:
            self.dayCountFraction.export(outfile, level, namespace_, name_='dayCountFraction', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fixedRate':
            obj_ = IdentifiedRate.factory()
            obj_.build(child_)
            self.fixedRate = obj_
            obj_.original_tagname_ = 'fixedRate'
        elif nodeName_ == 'dayCountFraction':
            obj_ = DayCountFraction.factory()
            obj_.build(child_)
            self.dayCountFraction = obj_
            obj_.original_tagname_ = 'dayCountFraction'
# end class CommodityFixedInterestCalculation


class CommodityFixedPriceSchedule(GeneratedsSuper):
    """The Fixed Price for a given Calculation Period during the life of
    the trade. There must be a Fixed Price step specified for each
    Calculation Period, regardless of whether the Fixed Price
    changes or remains the same between periods."""
    member_data_items_ = {
        'fixedPriceStep': MemberSpec_('fixedPriceStep', 'FixedPrice', 1),
        'worldscaleRateStep': MemberSpec_('worldscaleRateStep', 'xsd:decimal', 1),
        'contractRateStep': MemberSpec_('contractRateStep', 'NonNegativeMoney', 1),
        'settlementPeriodsPriceSchedule': MemberSpec_('settlementPeriodsPriceSchedule', 'CommoditySettlementPeriodsPriceSchedule', 1),
        'calculationPeriodsReference': MemberSpec_('calculationPeriodsReference', 'CalculationPeriodsReference', 0),
        'calculationPeriodsScheduleReference': MemberSpec_('calculationPeriodsScheduleReference', 'CalculationPeriodsScheduleReference', 0),
        'calculationPeriodsDatesReference': MemberSpec_('calculationPeriodsDatesReference', 'CalculationPeriodsDatesReference', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, fixedPriceStep=None, worldscaleRateStep=None, contractRateStep=None, settlementPeriodsPriceSchedule=None, calculationPeriodsReference=None, calculationPeriodsScheduleReference=None, calculationPeriodsDatesReference=None):
        self.original_tagname_ = None
        if fixedPriceStep is None:
            self.fixedPriceStep = []
        else:
            self.fixedPriceStep = fixedPriceStep
        if worldscaleRateStep is None:
            self.worldscaleRateStep = []
        else:
            self.worldscaleRateStep = worldscaleRateStep
        if contractRateStep is None:
            self.contractRateStep = []
        else:
            self.contractRateStep = contractRateStep
        if settlementPeriodsPriceSchedule is None:
            self.settlementPeriodsPriceSchedule = []
        else:
            self.settlementPeriodsPriceSchedule = settlementPeriodsPriceSchedule
        self.calculationPeriodsReference = calculationPeriodsReference
        self.calculationPeriodsScheduleReference = calculationPeriodsScheduleReference
        self.calculationPeriodsDatesReference = calculationPeriodsDatesReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityFixedPriceSchedule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityFixedPriceSchedule.subclass:
            return CommodityFixedPriceSchedule.subclass(*args_, **kwargs_)
        else:
            return CommodityFixedPriceSchedule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fixedPriceStep(self): return self.fixedPriceStep
    def set_fixedPriceStep(self, fixedPriceStep): self.fixedPriceStep = fixedPriceStep
    def add_fixedPriceStep(self, value): self.fixedPriceStep.append(value)
    def insert_fixedPriceStep_at(self, index, value): self.fixedPriceStep.insert(index, value)
    def replace_fixedPriceStep_at(self, index, value): self.fixedPriceStep[index] = value
    def get_worldscaleRateStep(self): return self.worldscaleRateStep
    def set_worldscaleRateStep(self, worldscaleRateStep): self.worldscaleRateStep = worldscaleRateStep
    def add_worldscaleRateStep(self, value): self.worldscaleRateStep.append(value)
    def insert_worldscaleRateStep_at(self, index, value): self.worldscaleRateStep.insert(index, value)
    def replace_worldscaleRateStep_at(self, index, value): self.worldscaleRateStep[index] = value
    def get_contractRateStep(self): return self.contractRateStep
    def set_contractRateStep(self, contractRateStep): self.contractRateStep = contractRateStep
    def add_contractRateStep(self, value): self.contractRateStep.append(value)
    def insert_contractRateStep_at(self, index, value): self.contractRateStep.insert(index, value)
    def replace_contractRateStep_at(self, index, value): self.contractRateStep[index] = value
    def get_settlementPeriodsPriceSchedule(self): return self.settlementPeriodsPriceSchedule
    def set_settlementPeriodsPriceSchedule(self, settlementPeriodsPriceSchedule): self.settlementPeriodsPriceSchedule = settlementPeriodsPriceSchedule
    def add_settlementPeriodsPriceSchedule(self, value): self.settlementPeriodsPriceSchedule.append(value)
    def insert_settlementPeriodsPriceSchedule_at(self, index, value): self.settlementPeriodsPriceSchedule.insert(index, value)
    def replace_settlementPeriodsPriceSchedule_at(self, index, value): self.settlementPeriodsPriceSchedule[index] = value
    def get_calculationPeriodsReference(self): return self.calculationPeriodsReference
    def set_calculationPeriodsReference(self, calculationPeriodsReference): self.calculationPeriodsReference = calculationPeriodsReference
    def get_calculationPeriodsScheduleReference(self): return self.calculationPeriodsScheduleReference
    def set_calculationPeriodsScheduleReference(self, calculationPeriodsScheduleReference): self.calculationPeriodsScheduleReference = calculationPeriodsScheduleReference
    def get_calculationPeriodsDatesReference(self): return self.calculationPeriodsDatesReference
    def set_calculationPeriodsDatesReference(self, calculationPeriodsDatesReference): self.calculationPeriodsDatesReference = calculationPeriodsDatesReference
    def hasContent_(self):
        if (
            self.fixedPriceStep or
            self.worldscaleRateStep or
            self.contractRateStep or
            self.settlementPeriodsPriceSchedule or
            self.calculationPeriodsReference is not None or
            self.calculationPeriodsScheduleReference is not None or
            self.calculationPeriodsDatesReference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityFixedPriceSchedule', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityFixedPriceSchedule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityFixedPriceSchedule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityFixedPriceSchedule'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityFixedPriceSchedule', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for fixedPriceStep_ in self.fixedPriceStep:
            fixedPriceStep_.export(outfile, level, namespace_, name_='fixedPriceStep', pretty_print=pretty_print)
        for worldscaleRateStep_ in self.worldscaleRateStep:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sworldscaleRateStep>%s</%sworldscaleRateStep>%s' % (namespace_, self.gds_format_float(worldscaleRateStep_, input_name='worldscaleRateStep'), namespace_, eol_))
        for contractRateStep_ in self.contractRateStep:
            contractRateStep_.export(outfile, level, namespace_, name_='contractRateStep', pretty_print=pretty_print)
        for settlementPeriodsPriceSchedule_ in self.settlementPeriodsPriceSchedule:
            settlementPeriodsPriceSchedule_.export(outfile, level, namespace_, name_='settlementPeriodsPriceSchedule', pretty_print=pretty_print)
        if self.calculationPeriodsReference is not None:
            self.calculationPeriodsReference.export(outfile, level, namespace_, name_='calculationPeriodsReference', pretty_print=pretty_print)
        if self.calculationPeriodsScheduleReference is not None:
            self.calculationPeriodsScheduleReference.export(outfile, level, namespace_, name_='calculationPeriodsScheduleReference', pretty_print=pretty_print)
        if self.calculationPeriodsDatesReference is not None:
            self.calculationPeriodsDatesReference.export(outfile, level, namespace_, name_='calculationPeriodsDatesReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fixedPriceStep':
            class_obj_ = self.get_class_obj_(child_, FixedPrice)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.fixedPriceStep.append(obj_)
            obj_.original_tagname_ = 'fixedPriceStep'
        elif nodeName_ == 'worldscaleRateStep':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'worldscaleRateStep')
            self.worldscaleRateStep.append(fval_)
        elif nodeName_ == 'contractRateStep':
            class_obj_ = self.get_class_obj_(child_, NonNegativeMoney)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.contractRateStep.append(obj_)
            obj_.original_tagname_ = 'contractRateStep'
        elif nodeName_ == 'settlementPeriodsPriceSchedule':
            obj_ = CommoditySettlementPeriodsPriceSchedule.factory()
            obj_.build(child_)
            self.settlementPeriodsPriceSchedule.append(obj_)
            obj_.original_tagname_ = 'settlementPeriodsPriceSchedule'
        elif nodeName_ == 'calculationPeriodsReference':
            obj_ = CalculationPeriodsReference.factory()
            obj_.build(child_)
            self.calculationPeriodsReference = obj_
            obj_.original_tagname_ = 'calculationPeriodsReference'
        elif nodeName_ == 'calculationPeriodsScheduleReference':
            obj_ = CalculationPeriodsScheduleReference.factory()
            obj_.build(child_)
            self.calculationPeriodsScheduleReference = obj_
            obj_.original_tagname_ = 'calculationPeriodsScheduleReference'
        elif nodeName_ == 'calculationPeriodsDatesReference':
            obj_ = CalculationPeriodsDatesReference.factory()
            obj_.build(child_)
            self.calculationPeriodsDatesReference = obj_
            obj_.original_tagname_ = 'calculationPeriodsDatesReference'
# end class CommodityFixedPriceSchedule


class CommodityFrequencyType(GeneratedsSuper):
    """Frequency Type for use in Pricing Date specifications."""
    member_data_items_ = {
        'commodityFrequencyTypeScheme': MemberSpec_('commodityFrequencyTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, commodityFrequencyTypeScheme='http://www.fpml.org/coding-scheme/commodity-frequency-type', valueOf_=None):
        self.original_tagname_ = None
        self.commodityFrequencyTypeScheme = _cast(None, commodityFrequencyTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityFrequencyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityFrequencyType.subclass:
            return CommodityFrequencyType.subclass(*args_, **kwargs_)
        else:
            return CommodityFrequencyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commodityFrequencyTypeScheme(self): return self.commodityFrequencyTypeScheme
    def set_commodityFrequencyTypeScheme(self, commodityFrequencyTypeScheme): self.commodityFrequencyTypeScheme = commodityFrequencyTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityFrequencyType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityFrequencyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityFrequencyType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityFrequencyType'):
        if self.commodityFrequencyTypeScheme != "http://www.fpml.org/coding-scheme/commodity-frequency-type" and 'commodityFrequencyTypeScheme' not in already_processed:
            already_processed.add('commodityFrequencyTypeScheme')
            outfile.write(' commodityFrequencyTypeScheme=%s' % (quote_attrib(self.commodityFrequencyTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityFrequencyType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('commodityFrequencyTypeScheme', node)
        if value is not None and 'commodityFrequencyTypeScheme' not in already_processed:
            already_processed.add('commodityFrequencyTypeScheme')
            self.commodityFrequencyTypeScheme = value
            self.validate_NonEmptyURI(self.commodityFrequencyTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CommodityFrequencyType


class CommodityFx(GeneratedsSuper):
    """A type defining the FX observations to be used to convert the
    observed Commodity Reference Price to the Settlement Currency.
    The rate source must be specified. Additionally, a time for the
    spot price to be observed on that source may be specified, or
    else an averaging schedule for trades priced using an average FX
    rate."""
    member_data_items_ = {
        'primaryRateSource': MemberSpec_('primaryRateSource', 'InformationSource', 0),
        'secondaryRateSource': MemberSpec_('secondaryRateSource', 'InformationSource', 0),
        'fxType': MemberSpec_('fxType', 'CommodityFxType', 0),
        'averagingMethod': MemberSpec_('averagingMethod', ['AveragingMethodEnum', 'Token', 'xsd:token'], 0),
        'fixingTime': MemberSpec_('fixingTime', 'BusinessCenterTime', 0),
        'fxObservationDates': MemberSpec_('fxObservationDates', 'AdjustableDates', 1),
        'dayType': MemberSpec_('dayType', ['CommodityDayTypeEnum', 'Token', 'xsd:token'], 0),
        'dayDistribution': MemberSpec_('dayDistribution', 'CommodityFrequencyType', 0),
        'dayCount': MemberSpec_('dayCount', 'xsd:positiveInteger', 0),
        'dayOfWeek': MemberSpec_('dayOfWeek', ['DayOfWeekEnum', 'Token', 'xsd:token'], 1),
        'dayNumber': MemberSpec_('dayNumber', 'xsd:integer', 0),
        'businessDayConvention': MemberSpec_('businessDayConvention', ['BusinessDayConventionEnum', 'Token', 'xsd:token'], 0),
        'lag': MemberSpec_('lag', 'Lag', 0),
        'lagReference': MemberSpec_('lagReference', 'LagReference', 0),
        'calculationPeriodsReference': MemberSpec_('calculationPeriodsReference', 'CalculationPeriodsReference', 0),
        'calculationPeriodsScheduleReference': MemberSpec_('calculationPeriodsScheduleReference', 'CalculationPeriodsScheduleReference', 0),
        'calculationPeriodsDatesReference': MemberSpec_('calculationPeriodsDatesReference', 'CalculationPeriodsDatesReference', 0),
        'fixingTime': MemberSpec_('fixingTime', 'BusinessCenterTime', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, primaryRateSource=None, secondaryRateSource=None, fxType=None, averagingMethod=None, fixingTime=None, fxObservationDates=None, dayType=None, dayDistribution=None, dayCount=None, dayOfWeek=None, dayNumber=None, businessDayConvention=None, lag=None, lagReference=None, calculationPeriodsReference=None, calculationPeriodsScheduleReference=None, calculationPeriodsDatesReference=None):
        self.original_tagname_ = None
        self.primaryRateSource = primaryRateSource
        self.secondaryRateSource = secondaryRateSource
        self.fxType = fxType
        self.averagingMethod = averagingMethod
        self.validate_AveragingMethodEnum(self.averagingMethod)
        self.fixingTime = fixingTime
        if fxObservationDates is None:
            self.fxObservationDates = []
        else:
            self.fxObservationDates = fxObservationDates
        self.dayType = dayType
        self.validate_CommodityDayTypeEnum(self.dayType)
        self.dayDistribution = dayDistribution
        self.dayCount = dayCount
        if dayOfWeek is None:
            self.dayOfWeek = []
        else:
            self.dayOfWeek = dayOfWeek
        self.dayNumber = dayNumber
        self.businessDayConvention = businessDayConvention
        self.validate_BusinessDayConventionEnum(self.businessDayConvention)
        self.lag = lag
        self.lagReference = lagReference
        self.calculationPeriodsReference = calculationPeriodsReference
        self.calculationPeriodsScheduleReference = calculationPeriodsScheduleReference
        self.calculationPeriodsDatesReference = calculationPeriodsDatesReference
        self.fixingTime = fixingTime
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityFx)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityFx.subclass:
            return CommodityFx.subclass(*args_, **kwargs_)
        else:
            return CommodityFx(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_primaryRateSource(self): return self.primaryRateSource
    def set_primaryRateSource(self, primaryRateSource): self.primaryRateSource = primaryRateSource
    def get_secondaryRateSource(self): return self.secondaryRateSource
    def set_secondaryRateSource(self, secondaryRateSource): self.secondaryRateSource = secondaryRateSource
    def get_fxType(self): return self.fxType
    def set_fxType(self, fxType): self.fxType = fxType
    def get_averagingMethod(self): return self.averagingMethod
    def set_averagingMethod(self, averagingMethod): self.averagingMethod = averagingMethod
    def get_fixingTime(self): return self.fixingTime
    def set_fixingTime(self, fixingTime): self.fixingTime = fixingTime
    def get_fxObservationDates(self): return self.fxObservationDates
    def set_fxObservationDates(self, fxObservationDates): self.fxObservationDates = fxObservationDates
    def add_fxObservationDates(self, value): self.fxObservationDates.append(value)
    def insert_fxObservationDates_at(self, index, value): self.fxObservationDates.insert(index, value)
    def replace_fxObservationDates_at(self, index, value): self.fxObservationDates[index] = value
    def get_dayType(self): return self.dayType
    def set_dayType(self, dayType): self.dayType = dayType
    def get_dayDistribution(self): return self.dayDistribution
    def set_dayDistribution(self, dayDistribution): self.dayDistribution = dayDistribution
    def get_dayCount(self): return self.dayCount
    def set_dayCount(self, dayCount): self.dayCount = dayCount
    def get_dayOfWeek(self): return self.dayOfWeek
    def set_dayOfWeek(self, dayOfWeek): self.dayOfWeek = dayOfWeek
    def add_dayOfWeek(self, value): self.dayOfWeek.append(value)
    def insert_dayOfWeek_at(self, index, value): self.dayOfWeek.insert(index, value)
    def replace_dayOfWeek_at(self, index, value): self.dayOfWeek[index] = value
    def get_dayNumber(self): return self.dayNumber
    def set_dayNumber(self, dayNumber): self.dayNumber = dayNumber
    def get_businessDayConvention(self): return self.businessDayConvention
    def set_businessDayConvention(self, businessDayConvention): self.businessDayConvention = businessDayConvention
    def get_lag(self): return self.lag
    def set_lag(self, lag): self.lag = lag
    def get_lagReference(self): return self.lagReference
    def set_lagReference(self, lagReference): self.lagReference = lagReference
    def get_calculationPeriodsReference(self): return self.calculationPeriodsReference
    def set_calculationPeriodsReference(self, calculationPeriodsReference): self.calculationPeriodsReference = calculationPeriodsReference
    def get_calculationPeriodsScheduleReference(self): return self.calculationPeriodsScheduleReference
    def set_calculationPeriodsScheduleReference(self, calculationPeriodsScheduleReference): self.calculationPeriodsScheduleReference = calculationPeriodsScheduleReference
    def get_calculationPeriodsDatesReference(self): return self.calculationPeriodsDatesReference
    def set_calculationPeriodsDatesReference(self, calculationPeriodsDatesReference): self.calculationPeriodsDatesReference = calculationPeriodsDatesReference
    def get_fixingTime(self): return self.fixingTime
    def set_fixingTime(self, fixingTime): self.fixingTime = fixingTime
    def validate_AveragingMethodEnum(self, value):
        # Validate type AveragingMethodEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Unweighted', 'Weighted']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AveragingMethodEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on AveragingMethodEnum' % {"value" : value} )
    def validate_CommodityDayTypeEnum(self, value):
        # Validate type CommodityDayTypeEnum, a restriction on Token.
        pass
    def validate_DayOfWeekEnum(self, value):
        # Validate type DayOfWeekEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT', 'SUN']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DayOfWeekEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on DayOfWeekEnum' % {"value" : value} )
    def validate_BusinessDayConventionEnum(self, value):
        # Validate type BusinessDayConventionEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FOLLOWING', 'FRN', 'MODFOLLOWING', 'PRECEDING', 'MODPRECEDING', 'NEAREST', 'NONE', 'NotApplicable']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on BusinessDayConventionEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on BusinessDayConventionEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.primaryRateSource is not None or
            self.secondaryRateSource is not None or
            self.fxType is not None or
            self.averagingMethod is not None or
            self.fixingTime is not None or
            self.fxObservationDates or
            self.dayType is not None or
            self.dayDistribution is not None or
            self.dayCount is not None or
            self.dayOfWeek or
            self.dayNumber is not None or
            self.businessDayConvention is not None or
            self.lag is not None or
            self.lagReference is not None or
            self.calculationPeriodsReference is not None or
            self.calculationPeriodsScheduleReference is not None or
            self.calculationPeriodsDatesReference is not None or
            self.fixingTime is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityFx', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityFx')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityFx', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityFx'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityFx', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.primaryRateSource is not None:
            self.primaryRateSource.export(outfile, level, namespace_, name_='primaryRateSource', pretty_print=pretty_print)
        if self.secondaryRateSource is not None:
            self.secondaryRateSource.export(outfile, level, namespace_, name_='secondaryRateSource', pretty_print=pretty_print)
        if self.fxType is not None:
            self.fxType.export(outfile, level, namespace_, name_='fxType', pretty_print=pretty_print)
        if self.averagingMethod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saveragingMethod>%s</%saveragingMethod>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.averagingMethod), input_name='averagingMethod')), namespace_, eol_))
        if self.fixingTime is not None:
            self.fixingTime.export(outfile, level, namespace_, name_='fixingTime', pretty_print=pretty_print)
        for fxObservationDates_ in self.fxObservationDates:
            fxObservationDates_.export(outfile, level, namespace_, name_='fxObservationDates', pretty_print=pretty_print)
        if self.dayType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdayType>%s</%sdayType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.dayType), input_name='dayType')), namespace_, eol_))
        if self.dayDistribution is not None:
            self.dayDistribution.export(outfile, level, namespace_, name_='dayDistribution', pretty_print=pretty_print)
        if self.dayCount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdayCount>%s</%sdayCount>%s' % (namespace_, self.gds_format_integer(self.dayCount, input_name='dayCount'), namespace_, eol_))
        for dayOfWeek_ in self.dayOfWeek:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdayOfWeek>%s</%sdayOfWeek>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(dayOfWeek_), input_name='dayOfWeek')), namespace_, eol_))
        if self.dayNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdayNumber>%s</%sdayNumber>%s' % (namespace_, self.gds_format_integer(self.dayNumber, input_name='dayNumber'), namespace_, eol_))
        if self.businessDayConvention is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbusinessDayConvention>%s</%sbusinessDayConvention>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.businessDayConvention), input_name='businessDayConvention')), namespace_, eol_))
        if self.lag is not None:
            self.lag.export(outfile, level, namespace_, name_='lag', pretty_print=pretty_print)
        if self.lagReference is not None:
            self.lagReference.export(outfile, level, namespace_, name_='lagReference', pretty_print=pretty_print)
        if self.calculationPeriodsReference is not None:
            self.calculationPeriodsReference.export(outfile, level, namespace_, name_='calculationPeriodsReference', pretty_print=pretty_print)
        if self.calculationPeriodsScheduleReference is not None:
            self.calculationPeriodsScheduleReference.export(outfile, level, namespace_, name_='calculationPeriodsScheduleReference', pretty_print=pretty_print)
        if self.calculationPeriodsDatesReference is not None:
            self.calculationPeriodsDatesReference.export(outfile, level, namespace_, name_='calculationPeriodsDatesReference', pretty_print=pretty_print)
        if self.fixingTime is not None:
            self.fixingTime.export(outfile, level, namespace_, name_='fixingTime', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'primaryRateSource':
            class_obj_ = self.get_class_obj_(child_, InformationSource)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.primaryRateSource = obj_
            obj_.original_tagname_ = 'primaryRateSource'
        elif nodeName_ == 'secondaryRateSource':
            class_obj_ = self.get_class_obj_(child_, InformationSource)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.secondaryRateSource = obj_
            obj_.original_tagname_ = 'secondaryRateSource'
        elif nodeName_ == 'fxType':
            obj_ = CommodityFxType.factory()
            obj_.build(child_)
            self.fxType = obj_
            obj_.original_tagname_ = 'fxType'
        elif nodeName_ == 'averagingMethod':
            averagingMethod_ = child_.text
            averagingMethod_ = re_.sub(String_cleanup_pat_, " ", averagingMethod_).strip()
            averagingMethod_ = self.gds_validate_string(averagingMethod_, node, 'averagingMethod')
            self.averagingMethod = averagingMethod_
            # validate type AveragingMethodEnum
            self.validate_AveragingMethodEnum(self.averagingMethod)
        elif nodeName_ == 'fixingTime':
            obj_ = BusinessCenterTime.factory()
            obj_.build(child_)
            self.fixingTime = obj_
            obj_.original_tagname_ = 'fixingTime'
        elif nodeName_ == 'fxObservationDates':
            obj_ = AdjustableDates.factory()
            obj_.build(child_)
            self.fxObservationDates.append(obj_)
            obj_.original_tagname_ = 'fxObservationDates'
        elif nodeName_ == 'dayType':
            dayType_ = child_.text
            dayType_ = re_.sub(String_cleanup_pat_, " ", dayType_).strip()
            dayType_ = self.gds_validate_string(dayType_, node, 'dayType')
            self.dayType = dayType_
            # validate type CommodityDayTypeEnum
            self.validate_CommodityDayTypeEnum(self.dayType)
        elif nodeName_ == 'dayDistribution':
            obj_ = CommodityFrequencyType.factory()
            obj_.build(child_)
            self.dayDistribution = obj_
            obj_.original_tagname_ = 'dayDistribution'
        elif nodeName_ == 'dayCount':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'dayCount')
            self.dayCount = ival_
        elif nodeName_ == 'dayOfWeek':
            dayOfWeek_ = child_.text
            dayOfWeek_ = re_.sub(String_cleanup_pat_, " ", dayOfWeek_).strip()
            dayOfWeek_ = self.gds_validate_string(dayOfWeek_, node, 'dayOfWeek')
            self.dayOfWeek.append(dayOfWeek_)
            # validate type DayOfWeekEnum
            self.validate_DayOfWeekEnum(self.dayOfWeek[-1])
        elif nodeName_ == 'dayNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'dayNumber')
            self.dayNumber = ival_
        elif nodeName_ == 'businessDayConvention':
            businessDayConvention_ = child_.text
            businessDayConvention_ = re_.sub(String_cleanup_pat_, " ", businessDayConvention_).strip()
            businessDayConvention_ = self.gds_validate_string(businessDayConvention_, node, 'businessDayConvention')
            self.businessDayConvention = businessDayConvention_
            # validate type BusinessDayConventionEnum
            self.validate_BusinessDayConventionEnum(self.businessDayConvention)
        elif nodeName_ == 'lag':
            obj_ = Lag.factory()
            obj_.build(child_)
            self.lag = obj_
            obj_.original_tagname_ = 'lag'
        elif nodeName_ == 'lagReference':
            obj_ = LagReference.factory()
            obj_.build(child_)
            self.lagReference = obj_
            obj_.original_tagname_ = 'lagReference'
        elif nodeName_ == 'calculationPeriodsReference':
            obj_ = CalculationPeriodsReference.factory()
            obj_.build(child_)
            self.calculationPeriodsReference = obj_
            obj_.original_tagname_ = 'calculationPeriodsReference'
        elif nodeName_ == 'calculationPeriodsScheduleReference':
            obj_ = CalculationPeriodsScheduleReference.factory()
            obj_.build(child_)
            self.calculationPeriodsScheduleReference = obj_
            obj_.original_tagname_ = 'calculationPeriodsScheduleReference'
        elif nodeName_ == 'calculationPeriodsDatesReference':
            obj_ = CalculationPeriodsDatesReference.factory()
            obj_.build(child_)
            self.calculationPeriodsDatesReference = obj_
            obj_.original_tagname_ = 'calculationPeriodsDatesReference'
        elif nodeName_ == 'fixingTime':
            obj_ = BusinessCenterTime.factory()
            obj_.build(child_)
            self.fixingTime = obj_
            obj_.original_tagname_ = 'fixingTime'
# end class CommodityFx


class CommodityFxType(GeneratedsSuper):
    """Identifes how the FX rate will be applied. This is intended to
    differentiate between the various methods for applying FX to the
    floating price such as a daily calculation, or averaging the FX
    and applying the average at the end of each CalculationPeriod."""
    member_data_items_ = {
        'commodityFxTypeScheme': MemberSpec_('commodityFxTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, commodityFxTypeScheme='http://www.fpml.org/coding-scheme/commodity-fx-type', valueOf_=None):
        self.original_tagname_ = None
        self.commodityFxTypeScheme = _cast(None, commodityFxTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityFxType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityFxType.subclass:
            return CommodityFxType.subclass(*args_, **kwargs_)
        else:
            return CommodityFxType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commodityFxTypeScheme(self): return self.commodityFxTypeScheme
    def set_commodityFxTypeScheme(self, commodityFxTypeScheme): self.commodityFxTypeScheme = commodityFxTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityFxType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityFxType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityFxType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityFxType'):
        if self.commodityFxTypeScheme != "http://www.fpml.org/coding-scheme/commodity-fx-type" and 'commodityFxTypeScheme' not in already_processed:
            already_processed.add('commodityFxTypeScheme')
            outfile.write(' commodityFxTypeScheme=%s' % (quote_attrib(self.commodityFxTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityFxType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('commodityFxTypeScheme', node)
        if value is not None and 'commodityFxTypeScheme' not in already_processed:
            already_processed.add('commodityFxTypeScheme')
            self.commodityFxTypeScheme = value
            self.validate_NonEmptyURI(self.commodityFxTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CommodityFxType


class CommodityHub(GeneratedsSuper):
    """A type defining a hub or other reference for a physically settled
    commodity trade."""
    member_data_items_ = {
        'partyReference': MemberSpec_('partyReference', 'PartyReference', 0),
        'accountReference': MemberSpec_('accountReference', 'AccountReference', 0),
        'hubCode': MemberSpec_('hubCode', 'CommodityHubCode', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, partyReference=None, accountReference=None, hubCode=None):
        self.original_tagname_ = None
        self.partyReference = partyReference
        self.accountReference = accountReference
        self.hubCode = hubCode
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityHub)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityHub.subclass:
            return CommodityHub.subclass(*args_, **kwargs_)
        else:
            return CommodityHub(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyReference(self): return self.partyReference
    def set_partyReference(self, partyReference): self.partyReference = partyReference
    def get_accountReference(self): return self.accountReference
    def set_accountReference(self, accountReference): self.accountReference = accountReference
    def get_hubCode(self): return self.hubCode
    def set_hubCode(self, hubCode): self.hubCode = hubCode
    def hasContent_(self):
        if (
            self.partyReference is not None or
            self.accountReference is not None or
            self.hubCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityHub', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityHub')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityHub', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityHub'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityHub', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.partyReference is not None:
            self.partyReference.export(outfile, level, namespace_, name_='partyReference', pretty_print=pretty_print)
        if self.accountReference is not None:
            self.accountReference.export(outfile, level, namespace_, name_='accountReference', pretty_print=pretty_print)
        if self.hubCode is not None:
            self.hubCode.export(outfile, level, namespace_, name_='hubCode', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'partyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.partyReference = obj_
            obj_.original_tagname_ = 'partyReference'
        elif nodeName_ == 'accountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.accountReference = obj_
            obj_.original_tagname_ = 'accountReference'
        elif nodeName_ == 'hubCode':
            obj_ = CommodityHubCode.factory()
            obj_.build(child_)
            self.hubCode = obj_
            obj_.original_tagname_ = 'hubCode'
# end class CommodityHub


class CommodityHubCode(GeneratedsSuper):
    """A scheme identifying the code for a hub or other reference for a
    physically settled commodity trade."""
    member_data_items_ = {
        'hubCodeScheme': MemberSpec_('hubCodeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, hubCodeScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.hubCodeScheme = _cast(None, hubCodeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityHubCode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityHubCode.subclass:
            return CommodityHubCode.subclass(*args_, **kwargs_)
        else:
            return CommodityHubCode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_hubCodeScheme(self): return self.hubCodeScheme
    def set_hubCodeScheme(self, hubCodeScheme): self.hubCodeScheme = hubCodeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityHubCode', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityHubCode')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityHubCode', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityHubCode'):
        if self.hubCodeScheme is not None and 'hubCodeScheme' not in already_processed:
            already_processed.add('hubCodeScheme')
            outfile.write(' hubCodeScheme=%s' % (quote_attrib(self.hubCodeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityHubCode', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('hubCodeScheme', node)
        if value is not None and 'hubCodeScheme' not in already_processed:
            already_processed.add('hubCodeScheme')
            self.hubCodeScheme = value
            self.validate_NonEmptyURI(self.hubCodeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CommodityHubCode


class CommodityMarketDisruption(GeneratedsSuper):
    """ISDA 1993 or 2005 commodity market disruption elements.If omitted
    then the standard disruption fallbacks of Section 7.5(d)(i) of
    the ISDA Commodity Definitions shall apply."""
    member_data_items_ = {
        'marketDisruptionEvents': MemberSpec_('marketDisruptionEvents', ['MarketDisruptionEventsEnum', 'Token', 'xsd:token'], 0),
        'additionalMarketDisruptionEvent': MemberSpec_('additionalMarketDisruptionEvent', 'MarketDisruptionEvent', 1),
        'marketDisruptionEvent': MemberSpec_('marketDisruptionEvent', 'MarketDisruptionEvent', 1),
        'disruptionFallbacks': MemberSpec_('disruptionFallbacks', ['DisruptionFallbacksEnum', 'Token', 'xsd:token'], 0),
        'disruptionFallback': MemberSpec_('disruptionFallback', 'SequencedDisruptionFallback', 1),
        'fallbackReferencePrice': MemberSpec_('fallbackReferencePrice', 'Underlyer', 0),
        'maximumNumberOfDaysOfDisruption': MemberSpec_('maximumNumberOfDaysOfDisruption', 'xsd:nonNegativeInteger', 0),
        'priceMaterialityPercentage': MemberSpec_('priceMaterialityPercentage', 'xsd:decimal', 0),
        'minimumFuturesContracts': MemberSpec_('minimumFuturesContracts', 'xsd:positiveInteger', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, marketDisruptionEvents=None, additionalMarketDisruptionEvent=None, marketDisruptionEvent=None, disruptionFallbacks=None, disruptionFallback=None, fallbackReferencePrice=None, maximumNumberOfDaysOfDisruption=None, priceMaterialityPercentage=None, minimumFuturesContracts=None):
        self.original_tagname_ = None
        self.marketDisruptionEvents = marketDisruptionEvents
        self.validate_MarketDisruptionEventsEnum(self.marketDisruptionEvents)
        if additionalMarketDisruptionEvent is None:
            self.additionalMarketDisruptionEvent = []
        else:
            self.additionalMarketDisruptionEvent = additionalMarketDisruptionEvent
        if marketDisruptionEvent is None:
            self.marketDisruptionEvent = []
        else:
            self.marketDisruptionEvent = marketDisruptionEvent
        self.disruptionFallbacks = disruptionFallbacks
        self.validate_DisruptionFallbacksEnum(self.disruptionFallbacks)
        if disruptionFallback is None:
            self.disruptionFallback = []
        else:
            self.disruptionFallback = disruptionFallback
        self.fallbackReferencePrice = fallbackReferencePrice
        self.maximumNumberOfDaysOfDisruption = maximumNumberOfDaysOfDisruption
        self.priceMaterialityPercentage = priceMaterialityPercentage
        self.minimumFuturesContracts = minimumFuturesContracts
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityMarketDisruption)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityMarketDisruption.subclass:
            return CommodityMarketDisruption.subclass(*args_, **kwargs_)
        else:
            return CommodityMarketDisruption(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_marketDisruptionEvents(self): return self.marketDisruptionEvents
    def set_marketDisruptionEvents(self, marketDisruptionEvents): self.marketDisruptionEvents = marketDisruptionEvents
    def get_additionalMarketDisruptionEvent(self): return self.additionalMarketDisruptionEvent
    def set_additionalMarketDisruptionEvent(self, additionalMarketDisruptionEvent): self.additionalMarketDisruptionEvent = additionalMarketDisruptionEvent
    def add_additionalMarketDisruptionEvent(self, value): self.additionalMarketDisruptionEvent.append(value)
    def insert_additionalMarketDisruptionEvent_at(self, index, value): self.additionalMarketDisruptionEvent.insert(index, value)
    def replace_additionalMarketDisruptionEvent_at(self, index, value): self.additionalMarketDisruptionEvent[index] = value
    def get_marketDisruptionEvent(self): return self.marketDisruptionEvent
    def set_marketDisruptionEvent(self, marketDisruptionEvent): self.marketDisruptionEvent = marketDisruptionEvent
    def add_marketDisruptionEvent(self, value): self.marketDisruptionEvent.append(value)
    def insert_marketDisruptionEvent_at(self, index, value): self.marketDisruptionEvent.insert(index, value)
    def replace_marketDisruptionEvent_at(self, index, value): self.marketDisruptionEvent[index] = value
    def get_disruptionFallbacks(self): return self.disruptionFallbacks
    def set_disruptionFallbacks(self, disruptionFallbacks): self.disruptionFallbacks = disruptionFallbacks
    def get_disruptionFallback(self): return self.disruptionFallback
    def set_disruptionFallback(self, disruptionFallback): self.disruptionFallback = disruptionFallback
    def add_disruptionFallback(self, value): self.disruptionFallback.append(value)
    def insert_disruptionFallback_at(self, index, value): self.disruptionFallback.insert(index, value)
    def replace_disruptionFallback_at(self, index, value): self.disruptionFallback[index] = value
    def get_fallbackReferencePrice(self): return self.fallbackReferencePrice
    def set_fallbackReferencePrice(self, fallbackReferencePrice): self.fallbackReferencePrice = fallbackReferencePrice
    def get_maximumNumberOfDaysOfDisruption(self): return self.maximumNumberOfDaysOfDisruption
    def set_maximumNumberOfDaysOfDisruption(self, maximumNumberOfDaysOfDisruption): self.maximumNumberOfDaysOfDisruption = maximumNumberOfDaysOfDisruption
    def get_priceMaterialityPercentage(self): return self.priceMaterialityPercentage
    def set_priceMaterialityPercentage(self, priceMaterialityPercentage): self.priceMaterialityPercentage = priceMaterialityPercentage
    def get_minimumFuturesContracts(self): return self.minimumFuturesContracts
    def set_minimumFuturesContracts(self, minimumFuturesContracts): self.minimumFuturesContracts = minimumFuturesContracts
    def validate_MarketDisruptionEventsEnum(self, value):
        # Validate type MarketDisruptionEventsEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Applicable', 'NotApplicable', 'AsSpecifiedInMasterAgreement', 'AsSpecifiedInConfirmation']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MarketDisruptionEventsEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on MarketDisruptionEventsEnum' % {"value" : value} )
    def validate_DisruptionFallbacksEnum(self, value):
        # Validate type DisruptionFallbacksEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AsSpecifiedInMasterAgreement', 'AsSpecifiedInConfirmation']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DisruptionFallbacksEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on DisruptionFallbacksEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.marketDisruptionEvents is not None or
            self.additionalMarketDisruptionEvent or
            self.marketDisruptionEvent or
            self.disruptionFallbacks is not None or
            self.disruptionFallback or
            self.fallbackReferencePrice is not None or
            self.maximumNumberOfDaysOfDisruption is not None or
            self.priceMaterialityPercentage is not None or
            self.minimumFuturesContracts is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityMarketDisruption', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityMarketDisruption')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityMarketDisruption', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityMarketDisruption'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityMarketDisruption', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.marketDisruptionEvents is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smarketDisruptionEvents>%s</%smarketDisruptionEvents>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.marketDisruptionEvents), input_name='marketDisruptionEvents')), namespace_, eol_))
        for additionalMarketDisruptionEvent_ in self.additionalMarketDisruptionEvent:
            additionalMarketDisruptionEvent_.export(outfile, level, namespace_, name_='additionalMarketDisruptionEvent', pretty_print=pretty_print)
        for marketDisruptionEvent_ in self.marketDisruptionEvent:
            marketDisruptionEvent_.export(outfile, level, namespace_, name_='marketDisruptionEvent', pretty_print=pretty_print)
        if self.disruptionFallbacks is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisruptionFallbacks>%s</%sdisruptionFallbacks>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.disruptionFallbacks), input_name='disruptionFallbacks')), namespace_, eol_))
        for disruptionFallback_ in self.disruptionFallback:
            disruptionFallback_.export(outfile, level, namespace_, name_='disruptionFallback', pretty_print=pretty_print)
        if self.fallbackReferencePrice is not None:
            self.fallbackReferencePrice.export(outfile, level, namespace_, name_='fallbackReferencePrice', pretty_print=pretty_print)
        if self.maximumNumberOfDaysOfDisruption is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaximumNumberOfDaysOfDisruption>%s</%smaximumNumberOfDaysOfDisruption>%s' % (namespace_, self.gds_format_integer(self.maximumNumberOfDaysOfDisruption, input_name='maximumNumberOfDaysOfDisruption'), namespace_, eol_))
        if self.priceMaterialityPercentage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spriceMaterialityPercentage>%s</%spriceMaterialityPercentage>%s' % (namespace_, self.gds_format_float(self.priceMaterialityPercentage, input_name='priceMaterialityPercentage'), namespace_, eol_))
        if self.minimumFuturesContracts is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sminimumFuturesContracts>%s</%sminimumFuturesContracts>%s' % (namespace_, self.gds_format_integer(self.minimumFuturesContracts, input_name='minimumFuturesContracts'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'marketDisruptionEvents':
            marketDisruptionEvents_ = child_.text
            marketDisruptionEvents_ = re_.sub(String_cleanup_pat_, " ", marketDisruptionEvents_).strip()
            marketDisruptionEvents_ = self.gds_validate_string(marketDisruptionEvents_, node, 'marketDisruptionEvents')
            self.marketDisruptionEvents = marketDisruptionEvents_
            # validate type MarketDisruptionEventsEnum
            self.validate_MarketDisruptionEventsEnum(self.marketDisruptionEvents)
        elif nodeName_ == 'additionalMarketDisruptionEvent':
            obj_ = MarketDisruptionEvent.factory()
            obj_.build(child_)
            self.additionalMarketDisruptionEvent.append(obj_)
            obj_.original_tagname_ = 'additionalMarketDisruptionEvent'
        elif nodeName_ == 'marketDisruptionEvent':
            obj_ = MarketDisruptionEvent.factory()
            obj_.build(child_)
            self.marketDisruptionEvent.append(obj_)
            obj_.original_tagname_ = 'marketDisruptionEvent'
        elif nodeName_ == 'disruptionFallbacks':
            disruptionFallbacks_ = child_.text
            disruptionFallbacks_ = re_.sub(String_cleanup_pat_, " ", disruptionFallbacks_).strip()
            disruptionFallbacks_ = self.gds_validate_string(disruptionFallbacks_, node, 'disruptionFallbacks')
            self.disruptionFallbacks = disruptionFallbacks_
            # validate type DisruptionFallbacksEnum
            self.validate_DisruptionFallbacksEnum(self.disruptionFallbacks)
        elif nodeName_ == 'disruptionFallback':
            obj_ = SequencedDisruptionFallback.factory()
            obj_.build(child_)
            self.disruptionFallback.append(obj_)
            obj_.original_tagname_ = 'disruptionFallback'
        elif nodeName_ == 'fallbackReferencePrice':
            obj_ = Underlyer.factory()
            obj_.build(child_)
            self.fallbackReferencePrice = obj_
            obj_.original_tagname_ = 'fallbackReferencePrice'
        elif nodeName_ == 'maximumNumberOfDaysOfDisruption':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'maximumNumberOfDaysOfDisruption')
            self.maximumNumberOfDaysOfDisruption = ival_
        elif nodeName_ == 'priceMaterialityPercentage':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'priceMaterialityPercentage')
            self.priceMaterialityPercentage = fval_
        elif nodeName_ == 'minimumFuturesContracts':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'minimumFuturesContracts')
            self.minimumFuturesContracts = ival_
# end class CommodityMarketDisruption


class CommodityMetalBrand(GeneratedsSuper):
    member_data_items_ = {
        'name': MemberSpec_('name', 'CommodityMetalBrandName', 0),
        'brandManager': MemberSpec_('brandManager', 'CommodityMetalBrandManager', 0),
        'country': MemberSpec_('country', 'CountryCode', 0),
        'producer': MemberSpec_('producer', 'CommodityMetalProducer', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, name=None, brandManager=None, country=None, producer=None):
        self.original_tagname_ = None
        self.name = name
        self.brandManager = brandManager
        self.country = country
        self.producer = producer
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityMetalBrand)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityMetalBrand.subclass:
            return CommodityMetalBrand.subclass(*args_, **kwargs_)
        else:
            return CommodityMetalBrand(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_brandManager(self): return self.brandManager
    def set_brandManager(self, brandManager): self.brandManager = brandManager
    def get_country(self): return self.country
    def set_country(self, country): self.country = country
    def get_producer(self): return self.producer
    def set_producer(self, producer): self.producer = producer
    def hasContent_(self):
        if (
            self.name is not None or
            self.brandManager is not None or
            self.country is not None or
            self.producer is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityMetalBrand', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityMetalBrand')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityMetalBrand', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityMetalBrand'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityMetalBrand', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            self.name.export(outfile, level, namespace_, name_='name', pretty_print=pretty_print)
        if self.brandManager is not None:
            self.brandManager.export(outfile, level, namespace_, name_='brandManager', pretty_print=pretty_print)
        if self.country is not None:
            self.country.export(outfile, level, namespace_, name_='country', pretty_print=pretty_print)
        if self.producer is not None:
            self.producer.export(outfile, level, namespace_, name_='producer', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            obj_ = CommodityMetalBrandName.factory()
            obj_.build(child_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'brandManager':
            obj_ = CommodityMetalBrandManager.factory()
            obj_.build(child_)
            self.brandManager = obj_
            obj_.original_tagname_ = 'brandManager'
        elif nodeName_ == 'country':
            obj_ = CountryCode.factory()
            obj_.build(child_)
            self.country = obj_
            obj_.original_tagname_ = 'country'
        elif nodeName_ == 'producer':
            obj_ = CommodityMetalProducer.factory()
            obj_.build(child_)
            self.producer = obj_
            obj_.original_tagname_ = 'producer'
# end class CommodityMetalBrand


class CommodityMetalBrandManager(GeneratedsSuper):
    member_data_items_ = {
        'commodityMetalBrandManagerScheme': MemberSpec_('commodityMetalBrandManagerScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, commodityMetalBrandManagerScheme='http://www.fpml.org/coding-scheme/commodity-metal-brand-manager', valueOf_=None):
        self.original_tagname_ = None
        self.commodityMetalBrandManagerScheme = _cast(None, commodityMetalBrandManagerScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityMetalBrandManager)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityMetalBrandManager.subclass:
            return CommodityMetalBrandManager.subclass(*args_, **kwargs_)
        else:
            return CommodityMetalBrandManager(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commodityMetalBrandManagerScheme(self): return self.commodityMetalBrandManagerScheme
    def set_commodityMetalBrandManagerScheme(self, commodityMetalBrandManagerScheme): self.commodityMetalBrandManagerScheme = commodityMetalBrandManagerScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityMetalBrandManager', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityMetalBrandManager')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityMetalBrandManager', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityMetalBrandManager'):
        if self.commodityMetalBrandManagerScheme != "http://www.fpml.org/coding-scheme/commodity-metal-brand-manager" and 'commodityMetalBrandManagerScheme' not in already_processed:
            already_processed.add('commodityMetalBrandManagerScheme')
            outfile.write(' commodityMetalBrandManagerScheme=%s' % (quote_attrib(self.commodityMetalBrandManagerScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityMetalBrandManager', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('commodityMetalBrandManagerScheme', node)
        if value is not None and 'commodityMetalBrandManagerScheme' not in already_processed:
            already_processed.add('commodityMetalBrandManagerScheme')
            self.commodityMetalBrandManagerScheme = value
            self.validate_NonEmptyURI(self.commodityMetalBrandManagerScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CommodityMetalBrandManager


class CommodityMetalBrandName(GeneratedsSuper):
    """The name of the entity that issues the brand"""
    member_data_items_ = {
        'commodityMetalBrandNameScheme': MemberSpec_('commodityMetalBrandNameScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, commodityMetalBrandNameScheme='http://www.fpml.org/coding-scheme/commodity-metal-brand-name', valueOf_=None):
        self.original_tagname_ = None
        self.commodityMetalBrandNameScheme = _cast(None, commodityMetalBrandNameScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityMetalBrandName)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityMetalBrandName.subclass:
            return CommodityMetalBrandName.subclass(*args_, **kwargs_)
        else:
            return CommodityMetalBrandName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commodityMetalBrandNameScheme(self): return self.commodityMetalBrandNameScheme
    def set_commodityMetalBrandNameScheme(self, commodityMetalBrandNameScheme): self.commodityMetalBrandNameScheme = commodityMetalBrandNameScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityMetalBrandName', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityMetalBrandName')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityMetalBrandName', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityMetalBrandName'):
        if self.commodityMetalBrandNameScheme != "http://www.fpml.org/coding-scheme/commodity-metal-brand-name" and 'commodityMetalBrandNameScheme' not in already_processed:
            already_processed.add('commodityMetalBrandNameScheme')
            outfile.write(' commodityMetalBrandNameScheme=%s' % (quote_attrib(self.commodityMetalBrandNameScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityMetalBrandName', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('commodityMetalBrandNameScheme', node)
        if value is not None and 'commodityMetalBrandNameScheme' not in already_processed:
            already_processed.add('commodityMetalBrandNameScheme')
            self.commodityMetalBrandNameScheme = value
            self.validate_NonEmptyURI(self.commodityMetalBrandNameScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CommodityMetalBrandName


class CommodityMetalGrade(GeneratedsSuper):
    member_data_items_ = {
        'commodityMetalGradeScheme': MemberSpec_('commodityMetalGradeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, commodityMetalGradeScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.commodityMetalGradeScheme = _cast(None, commodityMetalGradeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityMetalGrade)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityMetalGrade.subclass:
            return CommodityMetalGrade.subclass(*args_, **kwargs_)
        else:
            return CommodityMetalGrade(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commodityMetalGradeScheme(self): return self.commodityMetalGradeScheme
    def set_commodityMetalGradeScheme(self, commodityMetalGradeScheme): self.commodityMetalGradeScheme = commodityMetalGradeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityMetalGrade', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityMetalGrade')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityMetalGrade', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityMetalGrade'):
        if self.commodityMetalGradeScheme is not None and 'commodityMetalGradeScheme' not in already_processed:
            already_processed.add('commodityMetalGradeScheme')
            outfile.write(' commodityMetalGradeScheme=%s' % (quote_attrib(self.commodityMetalGradeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityMetalGrade', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('commodityMetalGradeScheme', node)
        if value is not None and 'commodityMetalGradeScheme' not in already_processed:
            already_processed.add('commodityMetalGradeScheme')
            self.commodityMetalGradeScheme = value
            self.validate_NonEmptyURI(self.commodityMetalGradeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CommodityMetalGrade


class CommodityMetalProducer(GeneratedsSuper):
    member_data_items_ = {
        'commodityMetalProducerScheme': MemberSpec_('commodityMetalProducerScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, commodityMetalProducerScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.commodityMetalProducerScheme = _cast(None, commodityMetalProducerScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityMetalProducer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityMetalProducer.subclass:
            return CommodityMetalProducer.subclass(*args_, **kwargs_)
        else:
            return CommodityMetalProducer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commodityMetalProducerScheme(self): return self.commodityMetalProducerScheme
    def set_commodityMetalProducerScheme(self, commodityMetalProducerScheme): self.commodityMetalProducerScheme = commodityMetalProducerScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityMetalProducer', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityMetalProducer')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityMetalProducer', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityMetalProducer'):
        if self.commodityMetalProducerScheme is not None and 'commodityMetalProducerScheme' not in already_processed:
            already_processed.add('commodityMetalProducerScheme')
            outfile.write(' commodityMetalProducerScheme=%s' % (quote_attrib(self.commodityMetalProducerScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityMetalProducer', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('commodityMetalProducerScheme', node)
        if value is not None and 'commodityMetalProducerScheme' not in already_processed:
            already_processed.add('commodityMetalProducerScheme')
            self.commodityMetalProducerScheme = value
            self.validate_NonEmptyURI(self.commodityMetalProducerScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CommodityMetalProducer


class CommodityMetalShape(GeneratedsSuper):
    member_data_items_ = {
        'commodityMetalShapeScheme': MemberSpec_('commodityMetalShapeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, commodityMetalShapeScheme='http://www.fpml.org/coding-scheme/commodity-metal-shape', valueOf_=None):
        self.original_tagname_ = None
        self.commodityMetalShapeScheme = _cast(None, commodityMetalShapeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityMetalShape)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityMetalShape.subclass:
            return CommodityMetalShape.subclass(*args_, **kwargs_)
        else:
            return CommodityMetalShape(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commodityMetalShapeScheme(self): return self.commodityMetalShapeScheme
    def set_commodityMetalShapeScheme(self, commodityMetalShapeScheme): self.commodityMetalShapeScheme = commodityMetalShapeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityMetalShape', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityMetalShape')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityMetalShape', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityMetalShape'):
        if self.commodityMetalShapeScheme != "http://www.fpml.org/coding-scheme/commodity-metal-shape" and 'commodityMetalShapeScheme' not in already_processed:
            already_processed.add('commodityMetalShapeScheme')
            outfile.write(' commodityMetalShapeScheme=%s' % (quote_attrib(self.commodityMetalShapeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityMetalShape', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('commodityMetalShapeScheme', node)
        if value is not None and 'commodityMetalShapeScheme' not in already_processed:
            already_processed.add('commodityMetalShapeScheme')
            self.commodityMetalShapeScheme = value
            self.validate_NonEmptyURI(self.commodityMetalShapeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CommodityMetalShape


class CommodityMultipleExercise(GeneratedsSuper):
    """A type for defining the multiple exercise provisions of an American
    style commodity option."""
    member_data_items_ = {
        'integralMultipleQuantity': MemberSpec_('integralMultipleQuantity', 'CommodityNotionalQuantity', 0),
        'minimumNotionalQuantity': MemberSpec_('minimumNotionalQuantity', 'CommodityNotionalQuantity', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, integralMultipleQuantity=None, minimumNotionalQuantity=None):
        self.original_tagname_ = None
        self.integralMultipleQuantity = integralMultipleQuantity
        self.minimumNotionalQuantity = minimumNotionalQuantity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityMultipleExercise)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityMultipleExercise.subclass:
            return CommodityMultipleExercise.subclass(*args_, **kwargs_)
        else:
            return CommodityMultipleExercise(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_integralMultipleQuantity(self): return self.integralMultipleQuantity
    def set_integralMultipleQuantity(self, integralMultipleQuantity): self.integralMultipleQuantity = integralMultipleQuantity
    def get_minimumNotionalQuantity(self): return self.minimumNotionalQuantity
    def set_minimumNotionalQuantity(self, minimumNotionalQuantity): self.minimumNotionalQuantity = minimumNotionalQuantity
    def hasContent_(self):
        if (
            self.integralMultipleQuantity is not None or
            self.minimumNotionalQuantity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityMultipleExercise', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityMultipleExercise')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityMultipleExercise', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityMultipleExercise'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityMultipleExercise', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.integralMultipleQuantity is not None:
            self.integralMultipleQuantity.export(outfile, level, namespace_, name_='integralMultipleQuantity', pretty_print=pretty_print)
        if self.minimumNotionalQuantity is not None:
            self.minimumNotionalQuantity.export(outfile, level, namespace_, name_='minimumNotionalQuantity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'integralMultipleQuantity':
            class_obj_ = self.get_class_obj_(child_, CommodityNotionalQuantity)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.integralMultipleQuantity = obj_
            obj_.original_tagname_ = 'integralMultipleQuantity'
        elif nodeName_ == 'minimumNotionalQuantity':
            class_obj_ = self.get_class_obj_(child_, CommodityNotionalQuantity)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.minimumNotionalQuantity = obj_
            obj_.original_tagname_ = 'minimumNotionalQuantity'
# end class CommodityMultipleExercise


class CommodityNotionalQuantity(GeneratedsSuper):
    """Commodity Notional."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'quantityUnit': MemberSpec_('quantityUnit', 'QuantityUnit', 0),
        'quantityFrequency': MemberSpec_('quantityFrequency', 'CommodityQuantityFrequency', 0),
        'quantity': MemberSpec_('quantity', 'xsd:decimal', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, quantityUnit=None, quantityFrequency=None, quantity=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.quantityUnit = quantityUnit
        self.quantityFrequency = quantityFrequency
        self.quantity = quantity
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityNotionalQuantity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityNotionalQuantity.subclass:
            return CommodityNotionalQuantity.subclass(*args_, **kwargs_)
        else:
            return CommodityNotionalQuantity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_quantityUnit(self): return self.quantityUnit
    def set_quantityUnit(self, quantityUnit): self.quantityUnit = quantityUnit
    def get_quantityFrequency(self): return self.quantityFrequency
    def set_quantityFrequency(self, quantityFrequency): self.quantityFrequency = quantityFrequency
    def get_quantity(self): return self.quantity
    def set_quantity(self, quantity): self.quantity = quantity
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.quantityUnit is not None or
            self.quantityFrequency is not None or
            self.quantity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityNotionalQuantity', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityNotionalQuantity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityNotionalQuantity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityNotionalQuantity'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityNotionalQuantity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.quantityUnit is not None:
            self.quantityUnit.export(outfile, level, namespace_, name_='quantityUnit', pretty_print=pretty_print)
        if self.quantityFrequency is not None:
            self.quantityFrequency.export(outfile, level, namespace_, name_='quantityFrequency', pretty_print=pretty_print)
        if self.quantity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%squantity>%s</%squantity>%s' % (namespace_, self.gds_format_float(self.quantity, input_name='quantity'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'quantityUnit':
            obj_ = QuantityUnit.factory()
            obj_.build(child_)
            self.quantityUnit = obj_
            obj_.original_tagname_ = 'quantityUnit'
        elif nodeName_ == 'quantityFrequency':
            obj_ = CommodityQuantityFrequency.factory()
            obj_.build(child_)
            self.quantityFrequency = obj_
            obj_.original_tagname_ = 'quantityFrequency'
        elif nodeName_ == 'quantity':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'quantity')
            self.quantity = fval_
# end class CommodityNotionalQuantity


class CommodityNotionalQuantitySchedule(GeneratedsSuper):
    """The Notional Quantity per Calculation Period. There must be a
    Notional Quantity step specified for each Calculation Period,
    regardless of whether the Notional Quantity changes or remains
    the same between periods."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'notionalStep': MemberSpec_('notionalStep', 'CommodityNotionalQuantity', 1),
        'settlementPeriodsNotionalQuantitySchedule': MemberSpec_('settlementPeriodsNotionalQuantitySchedule', 'CommoditySettlementPeriodsNotionalQuantitySchedule', 1),
        'calculationPeriodsReference': MemberSpec_('calculationPeriodsReference', 'CalculationPeriodsReference', 0),
        'calculationPeriodsScheduleReference': MemberSpec_('calculationPeriodsScheduleReference', 'CalculationPeriodsScheduleReference', 0),
        'calculationPeriodsDatesReference': MemberSpec_('calculationPeriodsDatesReference', 'CalculationPeriodsDatesReference', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, notionalStep=None, settlementPeriodsNotionalQuantitySchedule=None, calculationPeriodsReference=None, calculationPeriodsScheduleReference=None, calculationPeriodsDatesReference=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if notionalStep is None:
            self.notionalStep = []
        else:
            self.notionalStep = notionalStep
        if settlementPeriodsNotionalQuantitySchedule is None:
            self.settlementPeriodsNotionalQuantitySchedule = []
        else:
            self.settlementPeriodsNotionalQuantitySchedule = settlementPeriodsNotionalQuantitySchedule
        self.calculationPeriodsReference = calculationPeriodsReference
        self.calculationPeriodsScheduleReference = calculationPeriodsScheduleReference
        self.calculationPeriodsDatesReference = calculationPeriodsDatesReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityNotionalQuantitySchedule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityNotionalQuantitySchedule.subclass:
            return CommodityNotionalQuantitySchedule.subclass(*args_, **kwargs_)
        else:
            return CommodityNotionalQuantitySchedule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_notionalStep(self): return self.notionalStep
    def set_notionalStep(self, notionalStep): self.notionalStep = notionalStep
    def add_notionalStep(self, value): self.notionalStep.append(value)
    def insert_notionalStep_at(self, index, value): self.notionalStep.insert(index, value)
    def replace_notionalStep_at(self, index, value): self.notionalStep[index] = value
    def get_settlementPeriodsNotionalQuantitySchedule(self): return self.settlementPeriodsNotionalQuantitySchedule
    def set_settlementPeriodsNotionalQuantitySchedule(self, settlementPeriodsNotionalQuantitySchedule): self.settlementPeriodsNotionalQuantitySchedule = settlementPeriodsNotionalQuantitySchedule
    def add_settlementPeriodsNotionalQuantitySchedule(self, value): self.settlementPeriodsNotionalQuantitySchedule.append(value)
    def insert_settlementPeriodsNotionalQuantitySchedule_at(self, index, value): self.settlementPeriodsNotionalQuantitySchedule.insert(index, value)
    def replace_settlementPeriodsNotionalQuantitySchedule_at(self, index, value): self.settlementPeriodsNotionalQuantitySchedule[index] = value
    def get_calculationPeriodsReference(self): return self.calculationPeriodsReference
    def set_calculationPeriodsReference(self, calculationPeriodsReference): self.calculationPeriodsReference = calculationPeriodsReference
    def get_calculationPeriodsScheduleReference(self): return self.calculationPeriodsScheduleReference
    def set_calculationPeriodsScheduleReference(self, calculationPeriodsScheduleReference): self.calculationPeriodsScheduleReference = calculationPeriodsScheduleReference
    def get_calculationPeriodsDatesReference(self): return self.calculationPeriodsDatesReference
    def set_calculationPeriodsDatesReference(self, calculationPeriodsDatesReference): self.calculationPeriodsDatesReference = calculationPeriodsDatesReference
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.notionalStep or
            self.settlementPeriodsNotionalQuantitySchedule or
            self.calculationPeriodsReference is not None or
            self.calculationPeriodsScheduleReference is not None or
            self.calculationPeriodsDatesReference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityNotionalQuantitySchedule', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityNotionalQuantitySchedule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityNotionalQuantitySchedule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityNotionalQuantitySchedule'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityNotionalQuantitySchedule', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for notionalStep_ in self.notionalStep:
            notionalStep_.export(outfile, level, namespace_, name_='notionalStep', pretty_print=pretty_print)
        for settlementPeriodsNotionalQuantitySchedule_ in self.settlementPeriodsNotionalQuantitySchedule:
            settlementPeriodsNotionalQuantitySchedule_.export(outfile, level, namespace_, name_='settlementPeriodsNotionalQuantitySchedule', pretty_print=pretty_print)
        if self.calculationPeriodsReference is not None:
            self.calculationPeriodsReference.export(outfile, level, namespace_, name_='calculationPeriodsReference', pretty_print=pretty_print)
        if self.calculationPeriodsScheduleReference is not None:
            self.calculationPeriodsScheduleReference.export(outfile, level, namespace_, name_='calculationPeriodsScheduleReference', pretty_print=pretty_print)
        if self.calculationPeriodsDatesReference is not None:
            self.calculationPeriodsDatesReference.export(outfile, level, namespace_, name_='calculationPeriodsDatesReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'notionalStep':
            class_obj_ = self.get_class_obj_(child_, CommodityNotionalQuantity)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.notionalStep.append(obj_)
            obj_.original_tagname_ = 'notionalStep'
        elif nodeName_ == 'settlementPeriodsNotionalQuantitySchedule':
            obj_ = CommoditySettlementPeriodsNotionalQuantitySchedule.factory()
            obj_.build(child_)
            self.settlementPeriodsNotionalQuantitySchedule.append(obj_)
            obj_.original_tagname_ = 'settlementPeriodsNotionalQuantitySchedule'
        elif nodeName_ == 'calculationPeriodsReference':
            obj_ = CalculationPeriodsReference.factory()
            obj_.build(child_)
            self.calculationPeriodsReference = obj_
            obj_.original_tagname_ = 'calculationPeriodsReference'
        elif nodeName_ == 'calculationPeriodsScheduleReference':
            obj_ = CalculationPeriodsScheduleReference.factory()
            obj_.build(child_)
            self.calculationPeriodsScheduleReference = obj_
            obj_.original_tagname_ = 'calculationPeriodsScheduleReference'
        elif nodeName_ == 'calculationPeriodsDatesReference':
            obj_ = CalculationPeriodsDatesReference.factory()
            obj_.build(child_)
            self.calculationPeriodsDatesReference = obj_
            obj_.original_tagname_ = 'calculationPeriodsDatesReference'
# end class CommodityNotionalQuantitySchedule


class CommodityPayRelativeToEvent(GeneratedsSuper):
    """A scheme identifying the physical event relative to which payment
    occurs."""
    member_data_items_ = {
        'commodityPayRelativeToEventScheme': MemberSpec_('commodityPayRelativeToEventScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, commodityPayRelativeToEventScheme='http://www.fpml.org/coding-scheme/commodity-pay-relative-to-event', valueOf_=None):
        self.original_tagname_ = None
        self.commodityPayRelativeToEventScheme = _cast(None, commodityPayRelativeToEventScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityPayRelativeToEvent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityPayRelativeToEvent.subclass:
            return CommodityPayRelativeToEvent.subclass(*args_, **kwargs_)
        else:
            return CommodityPayRelativeToEvent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commodityPayRelativeToEventScheme(self): return self.commodityPayRelativeToEventScheme
    def set_commodityPayRelativeToEventScheme(self, commodityPayRelativeToEventScheme): self.commodityPayRelativeToEventScheme = commodityPayRelativeToEventScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityPayRelativeToEvent', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityPayRelativeToEvent')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityPayRelativeToEvent', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityPayRelativeToEvent'):
        if self.commodityPayRelativeToEventScheme != "http://www.fpml.org/coding-scheme/commodity-pay-relative-to-event" and 'commodityPayRelativeToEventScheme' not in already_processed:
            already_processed.add('commodityPayRelativeToEventScheme')
            outfile.write(' commodityPayRelativeToEventScheme=%s' % (quote_attrib(self.commodityPayRelativeToEventScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityPayRelativeToEvent', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('commodityPayRelativeToEventScheme', node)
        if value is not None and 'commodityPayRelativeToEventScheme' not in already_processed:
            already_processed.add('commodityPayRelativeToEventScheme')
            self.commodityPayRelativeToEventScheme = value
            self.validate_NonEmptyURI(self.commodityPayRelativeToEventScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CommodityPayRelativeToEvent


class CommodityPerformanceSwapEarlyTermination(GeneratedsSuper):
    member_data_items_ = {
        'partyReference': MemberSpec_('partyReference', 'PartyReference', 0),
        'startingDate': MemberSpec_('startingDate', 'CommodityStartingDate', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, partyReference=None, startingDate=None):
        self.original_tagname_ = None
        self.partyReference = partyReference
        self.startingDate = startingDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityPerformanceSwapEarlyTermination)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityPerformanceSwapEarlyTermination.subclass:
            return CommodityPerformanceSwapEarlyTermination.subclass(*args_, **kwargs_)
        else:
            return CommodityPerformanceSwapEarlyTermination(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyReference(self): return self.partyReference
    def set_partyReference(self, partyReference): self.partyReference = partyReference
    def get_startingDate(self): return self.startingDate
    def set_startingDate(self, startingDate): self.startingDate = startingDate
    def hasContent_(self):
        if (
            self.partyReference is not None or
            self.startingDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityPerformanceSwapEarlyTermination', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityPerformanceSwapEarlyTermination')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityPerformanceSwapEarlyTermination', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityPerformanceSwapEarlyTermination'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityPerformanceSwapEarlyTermination', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.partyReference is not None:
            self.partyReference.export(outfile, level, namespace_, name_='partyReference', pretty_print=pretty_print)
        if self.startingDate is not None:
            self.startingDate.export(outfile, level, namespace_, name_='startingDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'partyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.partyReference = obj_
            obj_.original_tagname_ = 'partyReference'
        elif nodeName_ == 'startingDate':
            obj_ = CommodityStartingDate.factory()
            obj_.build(child_)
            self.startingDate = obj_
            obj_.original_tagname_ = 'startingDate'
# end class CommodityPerformanceSwapEarlyTermination


class CommodityPhysicalExercise(GeneratedsSuper):
    """The parameters for defining how the physically-settled commodity
    option can be exercised and how it is settled."""
    member_data_items_ = {
        'americanExercise': MemberSpec_('americanExercise', 'AmericanExercise', 0),
        'europeanExercise': MemberSpec_('europeanExercise', 'EuropeanExercise', 0),
        'automaticExercise': MemberSpec_('automaticExercise', 'xsd:boolean', 0),
        'writtenConfirmation': MemberSpec_('writtenConfirmation', 'xsd:boolean', 0),
        'clearingInstructions': MemberSpec_('clearingInstructions', 'SwaptionPhysicalSettlement', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, americanExercise=None, europeanExercise=None, automaticExercise=None, writtenConfirmation=None, clearingInstructions=None):
        self.original_tagname_ = None
        self.americanExercise = americanExercise
        self.europeanExercise = europeanExercise
        self.automaticExercise = automaticExercise
        self.writtenConfirmation = writtenConfirmation
        self.clearingInstructions = clearingInstructions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityPhysicalExercise)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityPhysicalExercise.subclass:
            return CommodityPhysicalExercise.subclass(*args_, **kwargs_)
        else:
            return CommodityPhysicalExercise(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_americanExercise(self): return self.americanExercise
    def set_americanExercise(self, americanExercise): self.americanExercise = americanExercise
    def get_europeanExercise(self): return self.europeanExercise
    def set_europeanExercise(self, europeanExercise): self.europeanExercise = europeanExercise
    def get_automaticExercise(self): return self.automaticExercise
    def set_automaticExercise(self, automaticExercise): self.automaticExercise = automaticExercise
    def get_writtenConfirmation(self): return self.writtenConfirmation
    def set_writtenConfirmation(self, writtenConfirmation): self.writtenConfirmation = writtenConfirmation
    def get_clearingInstructions(self): return self.clearingInstructions
    def set_clearingInstructions(self, clearingInstructions): self.clearingInstructions = clearingInstructions
    def hasContent_(self):
        if (
            self.americanExercise is not None or
            self.europeanExercise is not None or
            self.automaticExercise is not None or
            self.writtenConfirmation is not None or
            self.clearingInstructions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityPhysicalExercise', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityPhysicalExercise')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityPhysicalExercise', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityPhysicalExercise'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityPhysicalExercise', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.americanExercise is not None:
            self.americanExercise.export(outfile, level, namespace_, name_='americanExercise', pretty_print=pretty_print)
        if self.europeanExercise is not None:
            self.europeanExercise.export(outfile, level, namespace_, name_='europeanExercise', pretty_print=pretty_print)
        if self.automaticExercise is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sautomaticExercise>%s</%sautomaticExercise>%s' % (namespace_, self.gds_format_boolean(self.automaticExercise, input_name='automaticExercise'), namespace_, eol_))
        if self.writtenConfirmation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%swrittenConfirmation>%s</%swrittenConfirmation>%s' % (namespace_, self.gds_format_boolean(self.writtenConfirmation, input_name='writtenConfirmation'), namespace_, eol_))
        if self.clearingInstructions is not None:
            self.clearingInstructions.export(outfile, level, namespace_, name_='clearingInstructions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'americanExercise':
            obj_ = CommodityPhysicalAmericanExercise.factory()
            obj_.build(child_)
            self.americanExercise = obj_
            obj_.original_tagname_ = 'americanExercise'
        elif nodeName_ == 'europeanExercise':
            obj_ = CommodityPhysicalEuropeanExercise.factory()
            obj_.build(child_)
            self.europeanExercise = obj_
            obj_.original_tagname_ = 'europeanExercise'
        elif nodeName_ == 'automaticExercise':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'automaticExercise')
            self.automaticExercise = ival_
        elif nodeName_ == 'writtenConfirmation':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'writtenConfirmation')
            self.writtenConfirmation = ival_
        elif nodeName_ == 'clearingInstructions':
            obj_ = SwaptionPhysicalSettlement.factory()
            obj_.build(child_)
            self.clearingInstructions = obj_
            obj_.original_tagname_ = 'clearingInstructions'
# end class CommodityPhysicalExercise


class CommodityPhysicalQuantityBase(GeneratedsSuper):
    """An abstract base class for physical quantity types."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityPhysicalQuantityBase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityPhysicalQuantityBase.subclass:
            return CommodityPhysicalQuantityBase.subclass(*args_, **kwargs_)
        else:
            return CommodityPhysicalQuantityBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityPhysicalQuantityBase', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityPhysicalQuantityBase')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityPhysicalQuantityBase', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityPhysicalQuantityBase'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityPhysicalQuantityBase', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CommodityPhysicalQuantityBase


class CommodityPhysicalQuantitySchedule(GeneratedsSuper):
    """The Quantity per Delivery Period. There must be a Quantity step
    specified for each Delivery Period, regardless of whether the
    Quantity changes or remains the same between periods."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'quantityStep': MemberSpec_('quantityStep', 'CommodityNotionalQuantity', 1),
        'deliveryPeriodsReference': MemberSpec_('deliveryPeriodsReference', 'CalculationPeriodsReference', 0),
        'deliveryPeriodsScheduleReference': MemberSpec_('deliveryPeriodsScheduleReference', 'CalculationPeriodsScheduleReference', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, quantityStep=None, deliveryPeriodsReference=None, deliveryPeriodsScheduleReference=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if quantityStep is None:
            self.quantityStep = []
        else:
            self.quantityStep = quantityStep
        self.deliveryPeriodsReference = deliveryPeriodsReference
        self.deliveryPeriodsScheduleReference = deliveryPeriodsScheduleReference
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityPhysicalQuantitySchedule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityPhysicalQuantitySchedule.subclass:
            return CommodityPhysicalQuantitySchedule.subclass(*args_, **kwargs_)
        else:
            return CommodityPhysicalQuantitySchedule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_quantityStep(self): return self.quantityStep
    def set_quantityStep(self, quantityStep): self.quantityStep = quantityStep
    def add_quantityStep(self, value): self.quantityStep.append(value)
    def insert_quantityStep_at(self, index, value): self.quantityStep.insert(index, value)
    def replace_quantityStep_at(self, index, value): self.quantityStep[index] = value
    def get_deliveryPeriodsReference(self): return self.deliveryPeriodsReference
    def set_deliveryPeriodsReference(self, deliveryPeriodsReference): self.deliveryPeriodsReference = deliveryPeriodsReference
    def get_deliveryPeriodsScheduleReference(self): return self.deliveryPeriodsScheduleReference
    def set_deliveryPeriodsScheduleReference(self, deliveryPeriodsScheduleReference): self.deliveryPeriodsScheduleReference = deliveryPeriodsScheduleReference
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.quantityStep or
            self.deliveryPeriodsReference is not None or
            self.deliveryPeriodsScheduleReference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityPhysicalQuantitySchedule', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityPhysicalQuantitySchedule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityPhysicalQuantitySchedule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityPhysicalQuantitySchedule'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityPhysicalQuantitySchedule', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for quantityStep_ in self.quantityStep:
            quantityStep_.export(outfile, level, namespace_, name_='quantityStep', pretty_print=pretty_print)
        if self.deliveryPeriodsReference is not None:
            self.deliveryPeriodsReference.export(outfile, level, namespace_, name_='deliveryPeriodsReference', pretty_print=pretty_print)
        if self.deliveryPeriodsScheduleReference is not None:
            self.deliveryPeriodsScheduleReference.export(outfile, level, namespace_, name_='deliveryPeriodsScheduleReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'quantityStep':
            class_obj_ = self.get_class_obj_(child_, CommodityNotionalQuantity)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.quantityStep.append(obj_)
            obj_.original_tagname_ = 'quantityStep'
        elif nodeName_ == 'deliveryPeriodsReference':
            obj_ = CalculationPeriodsReference.factory()
            obj_.build(child_)
            self.deliveryPeriodsReference = obj_
            obj_.original_tagname_ = 'deliveryPeriodsReference'
        elif nodeName_ == 'deliveryPeriodsScheduleReference':
            obj_ = CalculationPeriodsScheduleReference.factory()
            obj_.build(child_)
            self.deliveryPeriodsScheduleReference = obj_
            obj_.original_tagname_ = 'deliveryPeriodsScheduleReference'
# end class CommodityPhysicalQuantitySchedule


class CommodityPipeline(GeneratedsSuper):
    """The pipeline through which the physical commodity will be delivered."""
    member_data_items_ = {
        'pipelineScheme': MemberSpec_('pipelineScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, pipelineScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.pipelineScheme = _cast(None, pipelineScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityPipeline)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityPipeline.subclass:
            return CommodityPipeline.subclass(*args_, **kwargs_)
        else:
            return CommodityPipeline(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pipelineScheme(self): return self.pipelineScheme
    def set_pipelineScheme(self, pipelineScheme): self.pipelineScheme = pipelineScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityPipeline', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityPipeline')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityPipeline', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityPipeline'):
        if self.pipelineScheme is not None and 'pipelineScheme' not in already_processed:
            already_processed.add('pipelineScheme')
            outfile.write(' pipelineScheme=%s' % (quote_attrib(self.pipelineScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityPipeline', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pipelineScheme', node)
        if value is not None and 'pipelineScheme' not in already_processed:
            already_processed.add('pipelineScheme')
            self.pipelineScheme = value
            self.validate_NonEmptyURI(self.pipelineScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CommodityPipeline


class CommodityPipelineCycle(GeneratedsSuper):
    """The pipeline cycle during which the physical commodity will be
    delivered."""
    member_data_items_ = {
        'pipelineCycleScheme': MemberSpec_('pipelineCycleScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, pipelineCycleScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.pipelineCycleScheme = _cast(None, pipelineCycleScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityPipelineCycle)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityPipelineCycle.subclass:
            return CommodityPipelineCycle.subclass(*args_, **kwargs_)
        else:
            return CommodityPipelineCycle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pipelineCycleScheme(self): return self.pipelineCycleScheme
    def set_pipelineCycleScheme(self, pipelineCycleScheme): self.pipelineCycleScheme = pipelineCycleScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityPipelineCycle', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityPipelineCycle')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityPipelineCycle', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityPipelineCycle'):
        if self.pipelineCycleScheme is not None and 'pipelineCycleScheme' not in already_processed:
            already_processed.add('pipelineCycleScheme')
            outfile.write(' pipelineCycleScheme=%s' % (quote_attrib(self.pipelineCycleScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityPipelineCycle', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pipelineCycleScheme', node)
        if value is not None and 'pipelineCycleScheme' not in already_processed:
            already_processed.add('pipelineCycleScheme')
            self.pipelineCycleScheme = value
            self.validate_NonEmptyURI(self.pipelineCycleScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CommodityPipelineCycle


class CommodityPricingDates(GeneratedsSuper):
    """The dates on which prices are observed for the underlyer."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'calculationPeriodsReference': MemberSpec_('calculationPeriodsReference', 'CalculationPeriodsReference', 0),
        'calculationPeriodsScheduleReference': MemberSpec_('calculationPeriodsScheduleReference', 'CalculationPeriodsScheduleReference', 0),
        'calculationPeriodsDatesReference': MemberSpec_('calculationPeriodsDatesReference', 'CalculationPeriodsDatesReference', 0),
        'lag': MemberSpec_('lag', 'Lag', 0),
        'dayType': MemberSpec_('dayType', ['CommodityDayTypeEnum', 'Token', 'xsd:token'], 0),
        'dayDistribution': MemberSpec_('dayDistribution', 'CommodityFrequencyType', 0),
        'dayCount': MemberSpec_('dayCount', 'xsd:positiveInteger', 0),
        'dayOfWeek': MemberSpec_('dayOfWeek', ['DayOfWeekEnum', 'Token', 'xsd:token'], 1),
        'dayNumber': MemberSpec_('dayNumber', 'xsd:integer', 0),
        'businessDayConvention': MemberSpec_('businessDayConvention', ['BusinessDayConventionEnum', 'Token', 'xsd:token'], 0),
        'businessCalendar': MemberSpec_('businessCalendar', 'CommodityBusinessCalendar', 0),
        'calendarSource': MemberSpec_('calendarSource', ['CalendarSourceEnum', 'Token', 'xsd:token'], 0),
        'settlementPeriods': MemberSpec_('settlementPeriods', 'SettlementPeriods', 1),
        'settlementPeriodsReference': MemberSpec_('settlementPeriodsReference', 'SettlementPeriodsReference', 1),
        'pricingDates': MemberSpec_('pricingDates', 'AdjustableDates', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, calculationPeriodsReference=None, calculationPeriodsScheduleReference=None, calculationPeriodsDatesReference=None, lag=None, dayType=None, dayDistribution=None, dayCount=None, dayOfWeek=None, dayNumber=None, businessDayConvention=None, businessCalendar=None, calendarSource=None, settlementPeriods=None, settlementPeriodsReference=None, pricingDates=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.calculationPeriodsReference = calculationPeriodsReference
        self.calculationPeriodsScheduleReference = calculationPeriodsScheduleReference
        self.calculationPeriodsDatesReference = calculationPeriodsDatesReference
        self.lag = lag
        self.dayType = dayType
        self.validate_CommodityDayTypeEnum(self.dayType)
        self.dayDistribution = dayDistribution
        self.dayCount = dayCount
        if dayOfWeek is None:
            self.dayOfWeek = []
        else:
            self.dayOfWeek = dayOfWeek
        self.dayNumber = dayNumber
        self.businessDayConvention = businessDayConvention
        self.validate_BusinessDayConventionEnum(self.businessDayConvention)
        self.businessCalendar = businessCalendar
        self.calendarSource = calendarSource
        self.validate_CalendarSourceEnum(self.calendarSource)
        if settlementPeriods is None:
            self.settlementPeriods = []
        else:
            self.settlementPeriods = settlementPeriods
        if settlementPeriodsReference is None:
            self.settlementPeriodsReference = []
        else:
            self.settlementPeriodsReference = settlementPeriodsReference
        if pricingDates is None:
            self.pricingDates = []
        else:
            self.pricingDates = pricingDates
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityPricingDates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityPricingDates.subclass:
            return CommodityPricingDates.subclass(*args_, **kwargs_)
        else:
            return CommodityPricingDates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_calculationPeriodsReference(self): return self.calculationPeriodsReference
    def set_calculationPeriodsReference(self, calculationPeriodsReference): self.calculationPeriodsReference = calculationPeriodsReference
    def get_calculationPeriodsScheduleReference(self): return self.calculationPeriodsScheduleReference
    def set_calculationPeriodsScheduleReference(self, calculationPeriodsScheduleReference): self.calculationPeriodsScheduleReference = calculationPeriodsScheduleReference
    def get_calculationPeriodsDatesReference(self): return self.calculationPeriodsDatesReference
    def set_calculationPeriodsDatesReference(self, calculationPeriodsDatesReference): self.calculationPeriodsDatesReference = calculationPeriodsDatesReference
    def get_lag(self): return self.lag
    def set_lag(self, lag): self.lag = lag
    def get_dayType(self): return self.dayType
    def set_dayType(self, dayType): self.dayType = dayType
    def get_dayDistribution(self): return self.dayDistribution
    def set_dayDistribution(self, dayDistribution): self.dayDistribution = dayDistribution
    def get_dayCount(self): return self.dayCount
    def set_dayCount(self, dayCount): self.dayCount = dayCount
    def get_dayOfWeek(self): return self.dayOfWeek
    def set_dayOfWeek(self, dayOfWeek): self.dayOfWeek = dayOfWeek
    def add_dayOfWeek(self, value): self.dayOfWeek.append(value)
    def insert_dayOfWeek_at(self, index, value): self.dayOfWeek.insert(index, value)
    def replace_dayOfWeek_at(self, index, value): self.dayOfWeek[index] = value
    def get_dayNumber(self): return self.dayNumber
    def set_dayNumber(self, dayNumber): self.dayNumber = dayNumber
    def get_businessDayConvention(self): return self.businessDayConvention
    def set_businessDayConvention(self, businessDayConvention): self.businessDayConvention = businessDayConvention
    def get_businessCalendar(self): return self.businessCalendar
    def set_businessCalendar(self, businessCalendar): self.businessCalendar = businessCalendar
    def get_calendarSource(self): return self.calendarSource
    def set_calendarSource(self, calendarSource): self.calendarSource = calendarSource
    def get_settlementPeriods(self): return self.settlementPeriods
    def set_settlementPeriods(self, settlementPeriods): self.settlementPeriods = settlementPeriods
    def add_settlementPeriods(self, value): self.settlementPeriods.append(value)
    def insert_settlementPeriods_at(self, index, value): self.settlementPeriods.insert(index, value)
    def replace_settlementPeriods_at(self, index, value): self.settlementPeriods[index] = value
    def get_settlementPeriodsReference(self): return self.settlementPeriodsReference
    def set_settlementPeriodsReference(self, settlementPeriodsReference): self.settlementPeriodsReference = settlementPeriodsReference
    def add_settlementPeriodsReference(self, value): self.settlementPeriodsReference.append(value)
    def insert_settlementPeriodsReference_at(self, index, value): self.settlementPeriodsReference.insert(index, value)
    def replace_settlementPeriodsReference_at(self, index, value): self.settlementPeriodsReference[index] = value
    def get_pricingDates(self): return self.pricingDates
    def set_pricingDates(self, pricingDates): self.pricingDates = pricingDates
    def add_pricingDates(self, value): self.pricingDates.append(value)
    def insert_pricingDates_at(self, index, value): self.pricingDates.insert(index, value)
    def replace_pricingDates_at(self, index, value): self.pricingDates[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_CommodityDayTypeEnum(self, value):
        # Validate type CommodityDayTypeEnum, a restriction on Token.
        pass
    def validate_DayOfWeekEnum(self, value):
        # Validate type DayOfWeekEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT', 'SUN']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DayOfWeekEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on DayOfWeekEnum' % {"value" : value} )
    def validate_BusinessDayConventionEnum(self, value):
        # Validate type BusinessDayConventionEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FOLLOWING', 'FRN', 'MODFOLLOWING', 'PRECEDING', 'MODPRECEDING', 'NEAREST', 'NONE', 'NotApplicable']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on BusinessDayConventionEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on BusinessDayConventionEnum' % {"value" : value} )
    def validate_CalendarSourceEnum(self, value):
        # Validate type CalendarSourceEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ListedOption', 'Future']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CalendarSourceEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on CalendarSourceEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.calculationPeriodsReference is not None or
            self.calculationPeriodsScheduleReference is not None or
            self.calculationPeriodsDatesReference is not None or
            self.lag is not None or
            self.dayType is not None or
            self.dayDistribution is not None or
            self.dayCount is not None or
            self.dayOfWeek or
            self.dayNumber is not None or
            self.businessDayConvention is not None or
            self.businessCalendar is not None or
            self.calendarSource is not None or
            self.settlementPeriods or
            self.settlementPeriodsReference or
            self.pricingDates
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityPricingDates', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityPricingDates')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityPricingDates', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityPricingDates'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityPricingDates', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.calculationPeriodsReference is not None:
            self.calculationPeriodsReference.export(outfile, level, namespace_, name_='calculationPeriodsReference', pretty_print=pretty_print)
        if self.calculationPeriodsScheduleReference is not None:
            self.calculationPeriodsScheduleReference.export(outfile, level, namespace_, name_='calculationPeriodsScheduleReference', pretty_print=pretty_print)
        if self.calculationPeriodsDatesReference is not None:
            self.calculationPeriodsDatesReference.export(outfile, level, namespace_, name_='calculationPeriodsDatesReference', pretty_print=pretty_print)
        if self.lag is not None:
            self.lag.export(outfile, level, namespace_, name_='lag', pretty_print=pretty_print)
        if self.dayType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdayType>%s</%sdayType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.dayType), input_name='dayType')), namespace_, eol_))
        if self.dayDistribution is not None:
            self.dayDistribution.export(outfile, level, namespace_, name_='dayDistribution', pretty_print=pretty_print)
        if self.dayCount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdayCount>%s</%sdayCount>%s' % (namespace_, self.gds_format_integer(self.dayCount, input_name='dayCount'), namespace_, eol_))
        for dayOfWeek_ in self.dayOfWeek:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdayOfWeek>%s</%sdayOfWeek>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(dayOfWeek_), input_name='dayOfWeek')), namespace_, eol_))
        if self.dayNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdayNumber>%s</%sdayNumber>%s' % (namespace_, self.gds_format_integer(self.dayNumber, input_name='dayNumber'), namespace_, eol_))
        if self.businessDayConvention is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbusinessDayConvention>%s</%sbusinessDayConvention>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.businessDayConvention), input_name='businessDayConvention')), namespace_, eol_))
        if self.businessCalendar is not None:
            self.businessCalendar.export(outfile, level, namespace_, name_='businessCalendar', pretty_print=pretty_print)
        if self.calendarSource is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scalendarSource>%s</%scalendarSource>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.calendarSource), input_name='calendarSource')), namespace_, eol_))
        for settlementPeriods_ in self.settlementPeriods:
            settlementPeriods_.export(outfile, level, namespace_, name_='settlementPeriods', pretty_print=pretty_print)
        for settlementPeriodsReference_ in self.settlementPeriodsReference:
            settlementPeriodsReference_.export(outfile, level, namespace_, name_='settlementPeriodsReference', pretty_print=pretty_print)
        for pricingDates_ in self.pricingDates:
            pricingDates_.export(outfile, level, namespace_, name_='pricingDates', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'calculationPeriodsReference':
            obj_ = CalculationPeriodsReference.factory()
            obj_.build(child_)
            self.calculationPeriodsReference = obj_
            obj_.original_tagname_ = 'calculationPeriodsReference'
        elif nodeName_ == 'calculationPeriodsScheduleReference':
            obj_ = CalculationPeriodsScheduleReference.factory()
            obj_.build(child_)
            self.calculationPeriodsScheduleReference = obj_
            obj_.original_tagname_ = 'calculationPeriodsScheduleReference'
        elif nodeName_ == 'calculationPeriodsDatesReference':
            obj_ = CalculationPeriodsDatesReference.factory()
            obj_.build(child_)
            self.calculationPeriodsDatesReference = obj_
            obj_.original_tagname_ = 'calculationPeriodsDatesReference'
        elif nodeName_ == 'lag':
            obj_ = Lag.factory()
            obj_.build(child_)
            self.lag = obj_
            obj_.original_tagname_ = 'lag'
        elif nodeName_ == 'dayType':
            dayType_ = child_.text
            dayType_ = re_.sub(String_cleanup_pat_, " ", dayType_).strip()
            dayType_ = self.gds_validate_string(dayType_, node, 'dayType')
            self.dayType = dayType_
            # validate type CommodityDayTypeEnum
            self.validate_CommodityDayTypeEnum(self.dayType)
        elif nodeName_ == 'dayDistribution':
            obj_ = CommodityFrequencyType.factory()
            obj_.build(child_)
            self.dayDistribution = obj_
            obj_.original_tagname_ = 'dayDistribution'
        elif nodeName_ == 'dayCount':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'dayCount')
            self.dayCount = ival_
        elif nodeName_ == 'dayOfWeek':
            dayOfWeek_ = child_.text
            dayOfWeek_ = re_.sub(String_cleanup_pat_, " ", dayOfWeek_).strip()
            dayOfWeek_ = self.gds_validate_string(dayOfWeek_, node, 'dayOfWeek')
            self.dayOfWeek.append(dayOfWeek_)
            # validate type DayOfWeekEnum
            self.validate_DayOfWeekEnum(self.dayOfWeek[-1])
        elif nodeName_ == 'dayNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'dayNumber')
            self.dayNumber = ival_
        elif nodeName_ == 'businessDayConvention':
            businessDayConvention_ = child_.text
            businessDayConvention_ = re_.sub(String_cleanup_pat_, " ", businessDayConvention_).strip()
            businessDayConvention_ = self.gds_validate_string(businessDayConvention_, node, 'businessDayConvention')
            self.businessDayConvention = businessDayConvention_
            # validate type BusinessDayConventionEnum
            self.validate_BusinessDayConventionEnum(self.businessDayConvention)
        elif nodeName_ == 'businessCalendar':
            obj_ = CommodityBusinessCalendar.factory()
            obj_.build(child_)
            self.businessCalendar = obj_
            obj_.original_tagname_ = 'businessCalendar'
        elif nodeName_ == 'calendarSource':
            calendarSource_ = child_.text
            calendarSource_ = re_.sub(String_cleanup_pat_, " ", calendarSource_).strip()
            calendarSource_ = self.gds_validate_string(calendarSource_, node, 'calendarSource')
            self.calendarSource = calendarSource_
            # validate type CalendarSourceEnum
            self.validate_CalendarSourceEnum(self.calendarSource)
        elif nodeName_ == 'settlementPeriods':
            obj_ = SettlementPeriods.factory()
            obj_.build(child_)
            self.settlementPeriods.append(obj_)
            obj_.original_tagname_ = 'settlementPeriods'
        elif nodeName_ == 'settlementPeriodsReference':
            obj_ = SettlementPeriodsReference.factory()
            obj_.build(child_)
            self.settlementPeriodsReference.append(obj_)
            obj_.original_tagname_ = 'settlementPeriodsReference'
        elif nodeName_ == 'pricingDates':
            obj_ = AdjustableDates.factory()
            obj_.build(child_)
            self.pricingDates.append(obj_)
            obj_.original_tagname_ = 'pricingDates'
# end class CommodityPricingDates


class CommodityProductGrade(GeneratedsSuper):
    """A scheme identifying the grade of physical commodity product to be
    delivered."""
    member_data_items_ = {
        'productGradeScheme': MemberSpec_('productGradeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, productGradeScheme='http://www.fpml.org/coding-scheme/commodity-oil-product-grade', valueOf_=None):
        self.original_tagname_ = None
        self.productGradeScheme = _cast(None, productGradeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityProductGrade)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityProductGrade.subclass:
            return CommodityProductGrade.subclass(*args_, **kwargs_)
        else:
            return CommodityProductGrade(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_productGradeScheme(self): return self.productGradeScheme
    def set_productGradeScheme(self, productGradeScheme): self.productGradeScheme = productGradeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityProductGrade', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityProductGrade')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityProductGrade', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityProductGrade'):
        if self.productGradeScheme != "http://www.fpml.org/coding-scheme/commodity-oil-product-grade" and 'productGradeScheme' not in already_processed:
            already_processed.add('productGradeScheme')
            outfile.write(' productGradeScheme=%s' % (quote_attrib(self.productGradeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityProductGrade', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('productGradeScheme', node)
        if value is not None and 'productGradeScheme' not in already_processed:
            already_processed.add('productGradeScheme')
            self.productGradeScheme = value
            self.validate_NonEmptyURI(self.productGradeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CommodityProductGrade


class CommodityQuantityFrequency(GeneratedsSuper):
    """A type for defining the frequency at which the Notional Quantity is
    deemed to apply for purposes of calculating the Total Notional
    Quantity."""
    member_data_items_ = {
        'quantityFrequencyScheme': MemberSpec_('quantityFrequencyScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, quantityFrequencyScheme='http://www.fpml.org/coding-scheme/commodity-quantity-frequency', valueOf_=None):
        self.original_tagname_ = None
        self.quantityFrequencyScheme = _cast(None, quantityFrequencyScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityQuantityFrequency)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityQuantityFrequency.subclass:
            return CommodityQuantityFrequency.subclass(*args_, **kwargs_)
        else:
            return CommodityQuantityFrequency(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_quantityFrequencyScheme(self): return self.quantityFrequencyScheme
    def set_quantityFrequencyScheme(self, quantityFrequencyScheme): self.quantityFrequencyScheme = quantityFrequencyScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityQuantityFrequency', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityQuantityFrequency')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityQuantityFrequency', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityQuantityFrequency'):
        if self.quantityFrequencyScheme != "http://www.fpml.org/coding-scheme/commodity-quantity-frequency" and 'quantityFrequencyScheme' not in already_processed:
            already_processed.add('quantityFrequencyScheme')
            outfile.write(' quantityFrequencyScheme=%s' % (quote_attrib(self.quantityFrequencyScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityQuantityFrequency', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('quantityFrequencyScheme', node)
        if value is not None and 'quantityFrequencyScheme' not in already_processed:
            already_processed.add('quantityFrequencyScheme')
            self.quantityFrequencyScheme = value
            self.validate_NonEmptyURI(self.quantityFrequencyScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CommodityQuantityFrequency


class CommodityRelativeExpirationDates(GeneratedsSuper):
    """The Expiration Dates of the trade relative to the Calculation
    Periods."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'expireRelativeToEvent': MemberSpec_('expireRelativeToEvent', 'CommodityExpireRelativeToEvent', 0),
        'expirationDateOffset': MemberSpec_('expirationDateOffset', 'DateOffset', 0),
        'businessCentersReference': MemberSpec_('businessCentersReference', 'BusinessCentersReference', 0),
        'businessCenters': MemberSpec_('businessCenters', 'BusinessCenters', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, expireRelativeToEvent=None, expirationDateOffset=None, businessCentersReference=None, businessCenters=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.expireRelativeToEvent = expireRelativeToEvent
        self.expirationDateOffset = expirationDateOffset
        self.businessCentersReference = businessCentersReference
        self.businessCenters = businessCenters
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityRelativeExpirationDates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityRelativeExpirationDates.subclass:
            return CommodityRelativeExpirationDates.subclass(*args_, **kwargs_)
        else:
            return CommodityRelativeExpirationDates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_expireRelativeToEvent(self): return self.expireRelativeToEvent
    def set_expireRelativeToEvent(self, expireRelativeToEvent): self.expireRelativeToEvent = expireRelativeToEvent
    def get_expirationDateOffset(self): return self.expirationDateOffset
    def set_expirationDateOffset(self, expirationDateOffset): self.expirationDateOffset = expirationDateOffset
    def get_businessCentersReference(self): return self.businessCentersReference
    def set_businessCentersReference(self, businessCentersReference): self.businessCentersReference = businessCentersReference
    def get_businessCenters(self): return self.businessCenters
    def set_businessCenters(self, businessCenters): self.businessCenters = businessCenters
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.expireRelativeToEvent is not None or
            self.expirationDateOffset is not None or
            self.businessCentersReference is not None or
            self.businessCenters is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityRelativeExpirationDates', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityRelativeExpirationDates')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityRelativeExpirationDates', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityRelativeExpirationDates'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityRelativeExpirationDates', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.expireRelativeToEvent is not None:
            self.expireRelativeToEvent.export(outfile, level, namespace_, name_='expireRelativeToEvent', pretty_print=pretty_print)
        if self.expirationDateOffset is not None:
            self.expirationDateOffset.export(outfile, level, namespace_, name_='expirationDateOffset', pretty_print=pretty_print)
        if self.businessCentersReference is not None:
            self.businessCentersReference.export(outfile, level, namespace_, name_='businessCentersReference', pretty_print=pretty_print)
        if self.businessCenters is not None:
            self.businessCenters.export(outfile, level, namespace_, name_='businessCenters', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'expireRelativeToEvent':
            obj_ = CommodityExpireRelativeToEvent.factory()
            obj_.build(child_)
            self.expireRelativeToEvent = obj_
            obj_.original_tagname_ = 'expireRelativeToEvent'
        elif nodeName_ == 'expirationDateOffset':
            obj_ = DateOffset.factory()
            obj_.build(child_)
            self.expirationDateOffset = obj_
            obj_.original_tagname_ = 'expirationDateOffset'
        elif nodeName_ == 'businessCentersReference':
            obj_ = BusinessCentersReference.factory()
            obj_.build(child_)
            self.businessCentersReference = obj_
            obj_.original_tagname_ = 'businessCentersReference'
        elif nodeName_ == 'businessCenters':
            obj_ = BusinessCenters.factory()
            obj_.build(child_)
            self.businessCenters = obj_
            obj_.original_tagname_ = 'businessCenters'
# end class CommodityRelativeExpirationDates


class CommodityRelativePaymentDates(GeneratedsSuper):
    """The Payment Dates of the trade relative to the Calculation Periods."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'payRelativeTo': MemberSpec_('payRelativeTo', ['CommodityPayRelativeToEnum', 'Token', 'xsd:token'], 0),
        'payRelativeToEvent': MemberSpec_('payRelativeToEvent', 'CommodityPayRelativeToEvent', 0),
        'calculationPeriodsReference': MemberSpec_('calculationPeriodsReference', 'CalculationPeriodsReference', 0),
        'calculationPeriodsScheduleReference': MemberSpec_('calculationPeriodsScheduleReference', 'CalculationPeriodsScheduleReference', 0),
        'calculationPeriodsDatesReference': MemberSpec_('calculationPeriodsDatesReference', 'CalculationPeriodsDatesReference', 0),
        'paymentDaysOffset': MemberSpec_('paymentDaysOffset', 'DateOffset', 0),
        'businessCentersReference': MemberSpec_('businessCentersReference', 'BusinessCentersReference', 0),
        'businessCenters': MemberSpec_('businessCenters', 'BusinessCenters', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, payRelativeTo=None, payRelativeToEvent=None, calculationPeriodsReference=None, calculationPeriodsScheduleReference=None, calculationPeriodsDatesReference=None, paymentDaysOffset=None, businessCentersReference=None, businessCenters=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.payRelativeTo = payRelativeTo
        self.validate_CommodityPayRelativeToEnum(self.payRelativeTo)
        self.payRelativeToEvent = payRelativeToEvent
        self.calculationPeriodsReference = calculationPeriodsReference
        self.calculationPeriodsScheduleReference = calculationPeriodsScheduleReference
        self.calculationPeriodsDatesReference = calculationPeriodsDatesReference
        self.paymentDaysOffset = paymentDaysOffset
        self.businessCentersReference = businessCentersReference
        self.businessCenters = businessCenters
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityRelativePaymentDates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityRelativePaymentDates.subclass:
            return CommodityRelativePaymentDates.subclass(*args_, **kwargs_)
        else:
            return CommodityRelativePaymentDates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_payRelativeTo(self): return self.payRelativeTo
    def set_payRelativeTo(self, payRelativeTo): self.payRelativeTo = payRelativeTo
    def get_payRelativeToEvent(self): return self.payRelativeToEvent
    def set_payRelativeToEvent(self, payRelativeToEvent): self.payRelativeToEvent = payRelativeToEvent
    def get_calculationPeriodsReference(self): return self.calculationPeriodsReference
    def set_calculationPeriodsReference(self, calculationPeriodsReference): self.calculationPeriodsReference = calculationPeriodsReference
    def get_calculationPeriodsScheduleReference(self): return self.calculationPeriodsScheduleReference
    def set_calculationPeriodsScheduleReference(self, calculationPeriodsScheduleReference): self.calculationPeriodsScheduleReference = calculationPeriodsScheduleReference
    def get_calculationPeriodsDatesReference(self): return self.calculationPeriodsDatesReference
    def set_calculationPeriodsDatesReference(self, calculationPeriodsDatesReference): self.calculationPeriodsDatesReference = calculationPeriodsDatesReference
    def get_paymentDaysOffset(self): return self.paymentDaysOffset
    def set_paymentDaysOffset(self, paymentDaysOffset): self.paymentDaysOffset = paymentDaysOffset
    def get_businessCentersReference(self): return self.businessCentersReference
    def set_businessCentersReference(self, businessCentersReference): self.businessCentersReference = businessCentersReference
    def get_businessCenters(self): return self.businessCenters
    def set_businessCenters(self, businessCenters): self.businessCenters = businessCenters
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_CommodityPayRelativeToEnum(self, value):
        # Validate type CommodityPayRelativeToEnum, a restriction on Token.
        pass
    def hasContent_(self):
        if (
            self.payRelativeTo is not None or
            self.payRelativeToEvent is not None or
            self.calculationPeriodsReference is not None or
            self.calculationPeriodsScheduleReference is not None or
            self.calculationPeriodsDatesReference is not None or
            self.paymentDaysOffset is not None or
            self.businessCentersReference is not None or
            self.businessCenters is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityRelativePaymentDates', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityRelativePaymentDates')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityRelativePaymentDates', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityRelativePaymentDates'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityRelativePaymentDates', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.payRelativeTo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spayRelativeTo>%s</%spayRelativeTo>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.payRelativeTo), input_name='payRelativeTo')), namespace_, eol_))
        if self.payRelativeToEvent is not None:
            self.payRelativeToEvent.export(outfile, level, namespace_, name_='payRelativeToEvent', pretty_print=pretty_print)
        if self.calculationPeriodsReference is not None:
            self.calculationPeriodsReference.export(outfile, level, namespace_, name_='calculationPeriodsReference', pretty_print=pretty_print)
        if self.calculationPeriodsScheduleReference is not None:
            self.calculationPeriodsScheduleReference.export(outfile, level, namespace_, name_='calculationPeriodsScheduleReference', pretty_print=pretty_print)
        if self.calculationPeriodsDatesReference is not None:
            self.calculationPeriodsDatesReference.export(outfile, level, namespace_, name_='calculationPeriodsDatesReference', pretty_print=pretty_print)
        if self.paymentDaysOffset is not None:
            self.paymentDaysOffset.export(outfile, level, namespace_, name_='paymentDaysOffset', pretty_print=pretty_print)
        if self.businessCentersReference is not None:
            self.businessCentersReference.export(outfile, level, namespace_, name_='businessCentersReference', pretty_print=pretty_print)
        if self.businessCenters is not None:
            self.businessCenters.export(outfile, level, namespace_, name_='businessCenters', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'payRelativeTo':
            payRelativeTo_ = child_.text
            payRelativeTo_ = re_.sub(String_cleanup_pat_, " ", payRelativeTo_).strip()
            payRelativeTo_ = self.gds_validate_string(payRelativeTo_, node, 'payRelativeTo')
            self.payRelativeTo = payRelativeTo_
            # validate type CommodityPayRelativeToEnum
            self.validate_CommodityPayRelativeToEnum(self.payRelativeTo)
        elif nodeName_ == 'payRelativeToEvent':
            obj_ = CommodityPayRelativeToEvent.factory()
            obj_.build(child_)
            self.payRelativeToEvent = obj_
            obj_.original_tagname_ = 'payRelativeToEvent'
        elif nodeName_ == 'calculationPeriodsReference':
            obj_ = CalculationPeriodsReference.factory()
            obj_.build(child_)
            self.calculationPeriodsReference = obj_
            obj_.original_tagname_ = 'calculationPeriodsReference'
        elif nodeName_ == 'calculationPeriodsScheduleReference':
            obj_ = CalculationPeriodsScheduleReference.factory()
            obj_.build(child_)
            self.calculationPeriodsScheduleReference = obj_
            obj_.original_tagname_ = 'calculationPeriodsScheduleReference'
        elif nodeName_ == 'calculationPeriodsDatesReference':
            obj_ = CalculationPeriodsDatesReference.factory()
            obj_.build(child_)
            self.calculationPeriodsDatesReference = obj_
            obj_.original_tagname_ = 'calculationPeriodsDatesReference'
        elif nodeName_ == 'paymentDaysOffset':
            obj_ = DateOffset.factory()
            obj_.build(child_)
            self.paymentDaysOffset = obj_
            obj_.original_tagname_ = 'paymentDaysOffset'
        elif nodeName_ == 'businessCentersReference':
            obj_ = BusinessCentersReference.factory()
            obj_.build(child_)
            self.businessCentersReference = obj_
            obj_.original_tagname_ = 'businessCentersReference'
        elif nodeName_ == 'businessCenters':
            obj_ = BusinessCenters.factory()
            obj_.build(child_)
            self.businessCenters = obj_
            obj_.original_tagname_ = 'businessCenters'
# end class CommodityRelativePaymentDates


class CommodityReturnCalculation(GeneratedsSuper):
    member_data_items_ = {
        'formula': MemberSpec_('formula', ['CommodityReturnCalculationFormulaEnum', 'Token', 'xsd:token'], 0),
        'pricingDates': MemberSpec_('pricingDates', 'CommodityPricingDates', 0),
        'valuationDates': MemberSpec_('valuationDates', 'CommodityValuationDates', 0),
        'initialPrice': MemberSpec_('initialPrice', 'xsd:decimal', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, formula=None, pricingDates=None, valuationDates=None, initialPrice=None):
        self.original_tagname_ = None
        self.formula = formula
        self.validate_CommodityReturnCalculationFormulaEnum(self.formula)
        self.pricingDates = pricingDates
        self.valuationDates = valuationDates
        self.initialPrice = initialPrice
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityReturnCalculation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityReturnCalculation.subclass:
            return CommodityReturnCalculation.subclass(*args_, **kwargs_)
        else:
            return CommodityReturnCalculation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_formula(self): return self.formula
    def set_formula(self, formula): self.formula = formula
    def get_pricingDates(self): return self.pricingDates
    def set_pricingDates(self, pricingDates): self.pricingDates = pricingDates
    def get_valuationDates(self): return self.valuationDates
    def set_valuationDates(self, valuationDates): self.valuationDates = valuationDates
    def get_initialPrice(self): return self.initialPrice
    def set_initialPrice(self, initialPrice): self.initialPrice = initialPrice
    def validate_CommodityReturnCalculationFormulaEnum(self, value):
        # Validate type CommodityReturnCalculationFormulaEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['SimpleFormula', 'CompoundFormula']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CommodityReturnCalculationFormulaEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on CommodityReturnCalculationFormulaEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.formula is not None or
            self.pricingDates is not None or
            self.valuationDates is not None or
            self.initialPrice is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityReturnCalculation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityReturnCalculation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityReturnCalculation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityReturnCalculation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityReturnCalculation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.formula is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sformula>%s</%sformula>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.formula), input_name='formula')), namespace_, eol_))
        if self.pricingDates is not None:
            self.pricingDates.export(outfile, level, namespace_, name_='pricingDates', pretty_print=pretty_print)
        if self.valuationDates is not None:
            self.valuationDates.export(outfile, level, namespace_, name_='valuationDates', pretty_print=pretty_print)
        if self.initialPrice is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinitialPrice>%s</%sinitialPrice>%s' % (namespace_, self.gds_format_float(self.initialPrice, input_name='initialPrice'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'formula':
            formula_ = child_.text
            formula_ = re_.sub(String_cleanup_pat_, " ", formula_).strip()
            formula_ = self.gds_validate_string(formula_, node, 'formula')
            self.formula = formula_
            # validate type CommodityReturnCalculationFormulaEnum
            self.validate_CommodityReturnCalculationFormulaEnum(self.formula)
        elif nodeName_ == 'pricingDates':
            obj_ = CommodityPricingDates.factory()
            obj_.build(child_)
            self.pricingDates = obj_
            obj_.original_tagname_ = 'pricingDates'
        elif nodeName_ == 'valuationDates':
            obj_ = CommodityValuationDates.factory()
            obj_.build(child_)
            self.valuationDates = obj_
            obj_.original_tagname_ = 'valuationDates'
        elif nodeName_ == 'initialPrice':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'initialPrice')
            self.initialPrice = fval_
# end class CommodityReturnCalculation


class CommoditySettlementPeriodsNotionalQuantity(CommodityNotionalQuantity):
    """The notional quantity of electricity that applies to one or more
    groups of Settlement Periods."""
    member_data_items_ = {
        'settlementPeriodsReference': MemberSpec_('settlementPeriodsReference', 'SettlementPeriodsReference', 1),
    }
    subclass = None
    superclass = CommodityNotionalQuantity
    def __init__(self, id=None, quantityUnit=None, quantityFrequency=None, quantity=None, settlementPeriodsReference=None):
        self.original_tagname_ = None
        super(CommoditySettlementPeriodsNotionalQuantity, self).__init__(id, quantityUnit, quantityFrequency, quantity, )
        if settlementPeriodsReference is None:
            self.settlementPeriodsReference = []
        else:
            self.settlementPeriodsReference = settlementPeriodsReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommoditySettlementPeriodsNotionalQuantity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommoditySettlementPeriodsNotionalQuantity.subclass:
            return CommoditySettlementPeriodsNotionalQuantity.subclass(*args_, **kwargs_)
        else:
            return CommoditySettlementPeriodsNotionalQuantity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_settlementPeriodsReference(self): return self.settlementPeriodsReference
    def set_settlementPeriodsReference(self, settlementPeriodsReference): self.settlementPeriodsReference = settlementPeriodsReference
    def add_settlementPeriodsReference(self, value): self.settlementPeriodsReference.append(value)
    def insert_settlementPeriodsReference_at(self, index, value): self.settlementPeriodsReference.insert(index, value)
    def replace_settlementPeriodsReference_at(self, index, value): self.settlementPeriodsReference[index] = value
    def hasContent_(self):
        if (
            self.settlementPeriodsReference or
            super(CommoditySettlementPeriodsNotionalQuantity, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommoditySettlementPeriodsNotionalQuantity', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommoditySettlementPeriodsNotionalQuantity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommoditySettlementPeriodsNotionalQuantity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommoditySettlementPeriodsNotionalQuantity'):
        super(CommoditySettlementPeriodsNotionalQuantity, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CommoditySettlementPeriodsNotionalQuantity')
    def exportChildren(self, outfile, level, namespace_='', name_='CommoditySettlementPeriodsNotionalQuantity', fromsubclass_=False, pretty_print=True):
        super(CommoditySettlementPeriodsNotionalQuantity, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for settlementPeriodsReference_ in self.settlementPeriodsReference:
            settlementPeriodsReference_.export(outfile, level, namespace_, name_='settlementPeriodsReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CommoditySettlementPeriodsNotionalQuantity, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'settlementPeriodsReference':
            obj_ = SettlementPeriodsReference.factory()
            obj_.build(child_)
            self.settlementPeriodsReference.append(obj_)
            obj_.original_tagname_ = 'settlementPeriodsReference'
        super(CommoditySettlementPeriodsNotionalQuantity, self).buildChildren(child_, node, nodeName_, True)
# end class CommoditySettlementPeriodsNotionalQuantity


class CommoditySettlementPeriodsNotionalQuantitySchedule(GeneratedsSuper):
    """The notional quantity schedule of electricity that applies to one or
    more groups of Settlement Periods."""
    member_data_items_ = {
        'settlementPeriodsNotionalQuantityStep': MemberSpec_('settlementPeriodsNotionalQuantityStep', 'CommodityNotionalQuantity', 1),
        'settlementPeriodsReference': MemberSpec_('settlementPeriodsReference', 'SettlementPeriodsReference', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, settlementPeriodsNotionalQuantityStep=None, settlementPeriodsReference=None):
        self.original_tagname_ = None
        if settlementPeriodsNotionalQuantityStep is None:
            self.settlementPeriodsNotionalQuantityStep = []
        else:
            self.settlementPeriodsNotionalQuantityStep = settlementPeriodsNotionalQuantityStep
        if settlementPeriodsReference is None:
            self.settlementPeriodsReference = []
        else:
            self.settlementPeriodsReference = settlementPeriodsReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommoditySettlementPeriodsNotionalQuantitySchedule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommoditySettlementPeriodsNotionalQuantitySchedule.subclass:
            return CommoditySettlementPeriodsNotionalQuantitySchedule.subclass(*args_, **kwargs_)
        else:
            return CommoditySettlementPeriodsNotionalQuantitySchedule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_settlementPeriodsNotionalQuantityStep(self): return self.settlementPeriodsNotionalQuantityStep
    def set_settlementPeriodsNotionalQuantityStep(self, settlementPeriodsNotionalQuantityStep): self.settlementPeriodsNotionalQuantityStep = settlementPeriodsNotionalQuantityStep
    def add_settlementPeriodsNotionalQuantityStep(self, value): self.settlementPeriodsNotionalQuantityStep.append(value)
    def insert_settlementPeriodsNotionalQuantityStep_at(self, index, value): self.settlementPeriodsNotionalQuantityStep.insert(index, value)
    def replace_settlementPeriodsNotionalQuantityStep_at(self, index, value): self.settlementPeriodsNotionalQuantityStep[index] = value
    def get_settlementPeriodsReference(self): return self.settlementPeriodsReference
    def set_settlementPeriodsReference(self, settlementPeriodsReference): self.settlementPeriodsReference = settlementPeriodsReference
    def add_settlementPeriodsReference(self, value): self.settlementPeriodsReference.append(value)
    def insert_settlementPeriodsReference_at(self, index, value): self.settlementPeriodsReference.insert(index, value)
    def replace_settlementPeriodsReference_at(self, index, value): self.settlementPeriodsReference[index] = value
    def hasContent_(self):
        if (
            self.settlementPeriodsNotionalQuantityStep or
            self.settlementPeriodsReference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommoditySettlementPeriodsNotionalQuantitySchedule', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommoditySettlementPeriodsNotionalQuantitySchedule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommoditySettlementPeriodsNotionalQuantitySchedule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommoditySettlementPeriodsNotionalQuantitySchedule'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CommoditySettlementPeriodsNotionalQuantitySchedule', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for settlementPeriodsNotionalQuantityStep_ in self.settlementPeriodsNotionalQuantityStep:
            settlementPeriodsNotionalQuantityStep_.export(outfile, level, namespace_, name_='settlementPeriodsNotionalQuantityStep', pretty_print=pretty_print)
        for settlementPeriodsReference_ in self.settlementPeriodsReference:
            settlementPeriodsReference_.export(outfile, level, namespace_, name_='settlementPeriodsReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'settlementPeriodsNotionalQuantityStep':
            class_obj_ = self.get_class_obj_(child_, CommodityNotionalQuantity)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.settlementPeriodsNotionalQuantityStep.append(obj_)
            obj_.original_tagname_ = 'settlementPeriodsNotionalQuantityStep'
        elif nodeName_ == 'settlementPeriodsReference':
            obj_ = SettlementPeriodsReference.factory()
            obj_.build(child_)
            self.settlementPeriodsReference.append(obj_)
            obj_.original_tagname_ = 'settlementPeriodsReference'
# end class CommoditySettlementPeriodsNotionalQuantitySchedule


class CommoditySettlementPeriodsPriceSchedule(GeneratedsSuper):
    """The fixed price schedule for electricity that applies to one or more
    groups of Settlement Periods."""
    member_data_items_ = {
        'settlementPeriodsPriceStep': MemberSpec_('settlementPeriodsPriceStep', 'FixedPrice', 1),
        'settlementPeriodsReference': MemberSpec_('settlementPeriodsReference', 'SettlementPeriodsReference', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, settlementPeriodsPriceStep=None, settlementPeriodsReference=None):
        self.original_tagname_ = None
        if settlementPeriodsPriceStep is None:
            self.settlementPeriodsPriceStep = []
        else:
            self.settlementPeriodsPriceStep = settlementPeriodsPriceStep
        if settlementPeriodsReference is None:
            self.settlementPeriodsReference = []
        else:
            self.settlementPeriodsReference = settlementPeriodsReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommoditySettlementPeriodsPriceSchedule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommoditySettlementPeriodsPriceSchedule.subclass:
            return CommoditySettlementPeriodsPriceSchedule.subclass(*args_, **kwargs_)
        else:
            return CommoditySettlementPeriodsPriceSchedule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_settlementPeriodsPriceStep(self): return self.settlementPeriodsPriceStep
    def set_settlementPeriodsPriceStep(self, settlementPeriodsPriceStep): self.settlementPeriodsPriceStep = settlementPeriodsPriceStep
    def add_settlementPeriodsPriceStep(self, value): self.settlementPeriodsPriceStep.append(value)
    def insert_settlementPeriodsPriceStep_at(self, index, value): self.settlementPeriodsPriceStep.insert(index, value)
    def replace_settlementPeriodsPriceStep_at(self, index, value): self.settlementPeriodsPriceStep[index] = value
    def get_settlementPeriodsReference(self): return self.settlementPeriodsReference
    def set_settlementPeriodsReference(self, settlementPeriodsReference): self.settlementPeriodsReference = settlementPeriodsReference
    def add_settlementPeriodsReference(self, value): self.settlementPeriodsReference.append(value)
    def insert_settlementPeriodsReference_at(self, index, value): self.settlementPeriodsReference.insert(index, value)
    def replace_settlementPeriodsReference_at(self, index, value): self.settlementPeriodsReference[index] = value
    def hasContent_(self):
        if (
            self.settlementPeriodsPriceStep or
            self.settlementPeriodsReference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommoditySettlementPeriodsPriceSchedule', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommoditySettlementPeriodsPriceSchedule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommoditySettlementPeriodsPriceSchedule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommoditySettlementPeriodsPriceSchedule'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CommoditySettlementPeriodsPriceSchedule', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for settlementPeriodsPriceStep_ in self.settlementPeriodsPriceStep:
            settlementPeriodsPriceStep_.export(outfile, level, namespace_, name_='settlementPeriodsPriceStep', pretty_print=pretty_print)
        for settlementPeriodsReference_ in self.settlementPeriodsReference:
            settlementPeriodsReference_.export(outfile, level, namespace_, name_='settlementPeriodsReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'settlementPeriodsPriceStep':
            class_obj_ = self.get_class_obj_(child_, FixedPrice)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.settlementPeriodsPriceStep.append(obj_)
            obj_.original_tagname_ = 'settlementPeriodsPriceStep'
        elif nodeName_ == 'settlementPeriodsReference':
            obj_ = SettlementPeriodsReference.factory()
            obj_.build(child_)
            self.settlementPeriodsReference.append(obj_)
            obj_.original_tagname_ = 'settlementPeriodsReference'
# end class CommoditySettlementPeriodsPriceSchedule


class CommoditySpreadSchedule(GeneratedsSuper):
    """The Spread per Calculation Period. There must be a Spread specified
    for each Calculation Period, regardless of whether the Spread
    changes or remains the same between periods."""
    member_data_items_ = {
        'spreadStep': MemberSpec_('spreadStep', 'CommoditySpread', 1),
        'calculationPeriodsReference': MemberSpec_('calculationPeriodsReference', 'CalculationPeriodsReference', 0),
        'calculationPeriodsScheduleReference': MemberSpec_('calculationPeriodsScheduleReference', 'CalculationPeriodsScheduleReference', 0),
        'calculationPeriodsDatesReference': MemberSpec_('calculationPeriodsDatesReference', 'CalculationPeriodsDatesReference', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, spreadStep=None, calculationPeriodsReference=None, calculationPeriodsScheduleReference=None, calculationPeriodsDatesReference=None):
        self.original_tagname_ = None
        if spreadStep is None:
            self.spreadStep = []
        else:
            self.spreadStep = spreadStep
        self.calculationPeriodsReference = calculationPeriodsReference
        self.calculationPeriodsScheduleReference = calculationPeriodsScheduleReference
        self.calculationPeriodsDatesReference = calculationPeriodsDatesReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommoditySpreadSchedule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommoditySpreadSchedule.subclass:
            return CommoditySpreadSchedule.subclass(*args_, **kwargs_)
        else:
            return CommoditySpreadSchedule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_spreadStep(self): return self.spreadStep
    def set_spreadStep(self, spreadStep): self.spreadStep = spreadStep
    def add_spreadStep(self, value): self.spreadStep.append(value)
    def insert_spreadStep_at(self, index, value): self.spreadStep.insert(index, value)
    def replace_spreadStep_at(self, index, value): self.spreadStep[index] = value
    def get_calculationPeriodsReference(self): return self.calculationPeriodsReference
    def set_calculationPeriodsReference(self, calculationPeriodsReference): self.calculationPeriodsReference = calculationPeriodsReference
    def get_calculationPeriodsScheduleReference(self): return self.calculationPeriodsScheduleReference
    def set_calculationPeriodsScheduleReference(self, calculationPeriodsScheduleReference): self.calculationPeriodsScheduleReference = calculationPeriodsScheduleReference
    def get_calculationPeriodsDatesReference(self): return self.calculationPeriodsDatesReference
    def set_calculationPeriodsDatesReference(self, calculationPeriodsDatesReference): self.calculationPeriodsDatesReference = calculationPeriodsDatesReference
    def hasContent_(self):
        if (
            self.spreadStep or
            self.calculationPeriodsReference is not None or
            self.calculationPeriodsScheduleReference is not None or
            self.calculationPeriodsDatesReference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommoditySpreadSchedule', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommoditySpreadSchedule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommoditySpreadSchedule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommoditySpreadSchedule'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CommoditySpreadSchedule', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for spreadStep_ in self.spreadStep:
            spreadStep_.export(outfile, level, namespace_, name_='spreadStep', pretty_print=pretty_print)
        if self.calculationPeriodsReference is not None:
            self.calculationPeriodsReference.export(outfile, level, namespace_, name_='calculationPeriodsReference', pretty_print=pretty_print)
        if self.calculationPeriodsScheduleReference is not None:
            self.calculationPeriodsScheduleReference.export(outfile, level, namespace_, name_='calculationPeriodsScheduleReference', pretty_print=pretty_print)
        if self.calculationPeriodsDatesReference is not None:
            self.calculationPeriodsDatesReference.export(outfile, level, namespace_, name_='calculationPeriodsDatesReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'spreadStep':
            obj_ = CommoditySpread.factory()
            obj_.build(child_)
            self.spreadStep.append(obj_)
            obj_.original_tagname_ = 'spreadStep'
        elif nodeName_ == 'calculationPeriodsReference':
            obj_ = CalculationPeriodsReference.factory()
            obj_.build(child_)
            self.calculationPeriodsReference = obj_
            obj_.original_tagname_ = 'calculationPeriodsReference'
        elif nodeName_ == 'calculationPeriodsScheduleReference':
            obj_ = CalculationPeriodsScheduleReference.factory()
            obj_.build(child_)
            self.calculationPeriodsScheduleReference = obj_
            obj_.original_tagname_ = 'calculationPeriodsScheduleReference'
        elif nodeName_ == 'calculationPeriodsDatesReference':
            obj_ = CalculationPeriodsDatesReference.factory()
            obj_.build(child_)
            self.calculationPeriodsDatesReference = obj_
            obj_.original_tagname_ = 'calculationPeriodsDatesReference'
# end class CommoditySpreadSchedule


class CommodityStartingDate(GeneratedsSuper):
    """A type specifying the date from which the early termination clause
    can be exercised."""
    member_data_items_ = {
        'dateRelativeTo': MemberSpec_('dateRelativeTo', 'PartyReference', 0),
        'adjustableDate': MemberSpec_('adjustableDate', 'AdjustableDate', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, dateRelativeTo=None, adjustableDate=None):
        self.original_tagname_ = None
        self.dateRelativeTo = dateRelativeTo
        self.adjustableDate = adjustableDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityStartingDate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityStartingDate.subclass:
            return CommodityStartingDate.subclass(*args_, **kwargs_)
        else:
            return CommodityStartingDate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dateRelativeTo(self): return self.dateRelativeTo
    def set_dateRelativeTo(self, dateRelativeTo): self.dateRelativeTo = dateRelativeTo
    def get_adjustableDate(self): return self.adjustableDate
    def set_adjustableDate(self, adjustableDate): self.adjustableDate = adjustableDate
    def hasContent_(self):
        if (
            self.dateRelativeTo is not None or
            self.adjustableDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityStartingDate', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityStartingDate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityStartingDate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityStartingDate'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityStartingDate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dateRelativeTo is not None:
            self.dateRelativeTo.export(outfile, level, namespace_, name_='dateRelativeTo', pretty_print=pretty_print)
        if self.adjustableDate is not None:
            self.adjustableDate.export(outfile, level, namespace_, name_='adjustableDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dateRelativeTo':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.dateRelativeTo = obj_
            obj_.original_tagname_ = 'dateRelativeTo'
        elif nodeName_ == 'adjustableDate':
            obj_ = AdjustableDate.factory()
            obj_.build(child_)
            self.adjustableDate = obj_
            obj_.original_tagname_ = 'adjustableDate'
# end class CommodityStartingDate


class CommodityStrikeSchedule(GeneratedsSuper):
    """The Strike Price per Unit per Calculation Period. There must be a
    Strike Price per Unit step specified for each Calculation
    Period, regardless of whether the Strike changes or remains the
    same between periods."""
    member_data_items_ = {
        'strikePricePerUnitStep': MemberSpec_('strikePricePerUnitStep', 'NonNegativeMoney', 1),
        'calculationPeriodsReference': MemberSpec_('calculationPeriodsReference', 'CalculationPeriodsReference', 0),
        'calculationPeriodsScheduleReference': MemberSpec_('calculationPeriodsScheduleReference', 'CalculationPeriodsScheduleReference', 0),
        'calculationPeriodsDatesReference': MemberSpec_('calculationPeriodsDatesReference', 'CalculationPeriodsDatesReference', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, strikePricePerUnitStep=None, calculationPeriodsReference=None, calculationPeriodsScheduleReference=None, calculationPeriodsDatesReference=None):
        self.original_tagname_ = None
        if strikePricePerUnitStep is None:
            self.strikePricePerUnitStep = []
        else:
            self.strikePricePerUnitStep = strikePricePerUnitStep
        self.calculationPeriodsReference = calculationPeriodsReference
        self.calculationPeriodsScheduleReference = calculationPeriodsScheduleReference
        self.calculationPeriodsDatesReference = calculationPeriodsDatesReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityStrikeSchedule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityStrikeSchedule.subclass:
            return CommodityStrikeSchedule.subclass(*args_, **kwargs_)
        else:
            return CommodityStrikeSchedule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_strikePricePerUnitStep(self): return self.strikePricePerUnitStep
    def set_strikePricePerUnitStep(self, strikePricePerUnitStep): self.strikePricePerUnitStep = strikePricePerUnitStep
    def add_strikePricePerUnitStep(self, value): self.strikePricePerUnitStep.append(value)
    def insert_strikePricePerUnitStep_at(self, index, value): self.strikePricePerUnitStep.insert(index, value)
    def replace_strikePricePerUnitStep_at(self, index, value): self.strikePricePerUnitStep[index] = value
    def get_calculationPeriodsReference(self): return self.calculationPeriodsReference
    def set_calculationPeriodsReference(self, calculationPeriodsReference): self.calculationPeriodsReference = calculationPeriodsReference
    def get_calculationPeriodsScheduleReference(self): return self.calculationPeriodsScheduleReference
    def set_calculationPeriodsScheduleReference(self, calculationPeriodsScheduleReference): self.calculationPeriodsScheduleReference = calculationPeriodsScheduleReference
    def get_calculationPeriodsDatesReference(self): return self.calculationPeriodsDatesReference
    def set_calculationPeriodsDatesReference(self, calculationPeriodsDatesReference): self.calculationPeriodsDatesReference = calculationPeriodsDatesReference
    def hasContent_(self):
        if (
            self.strikePricePerUnitStep or
            self.calculationPeriodsReference is not None or
            self.calculationPeriodsScheduleReference is not None or
            self.calculationPeriodsDatesReference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityStrikeSchedule', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityStrikeSchedule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityStrikeSchedule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityStrikeSchedule'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityStrikeSchedule', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for strikePricePerUnitStep_ in self.strikePricePerUnitStep:
            strikePricePerUnitStep_.export(outfile, level, namespace_, name_='strikePricePerUnitStep', pretty_print=pretty_print)
        if self.calculationPeriodsReference is not None:
            self.calculationPeriodsReference.export(outfile, level, namespace_, name_='calculationPeriodsReference', pretty_print=pretty_print)
        if self.calculationPeriodsScheduleReference is not None:
            self.calculationPeriodsScheduleReference.export(outfile, level, namespace_, name_='calculationPeriodsScheduleReference', pretty_print=pretty_print)
        if self.calculationPeriodsDatesReference is not None:
            self.calculationPeriodsDatesReference.export(outfile, level, namespace_, name_='calculationPeriodsDatesReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'strikePricePerUnitStep':
            class_obj_ = self.get_class_obj_(child_, NonNegativeMoney)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.strikePricePerUnitStep.append(obj_)
            obj_.original_tagname_ = 'strikePricePerUnitStep'
        elif nodeName_ == 'calculationPeriodsReference':
            obj_ = CalculationPeriodsReference.factory()
            obj_.build(child_)
            self.calculationPeriodsReference = obj_
            obj_.original_tagname_ = 'calculationPeriodsReference'
        elif nodeName_ == 'calculationPeriodsScheduleReference':
            obj_ = CalculationPeriodsScheduleReference.factory()
            obj_.build(child_)
            self.calculationPeriodsScheduleReference = obj_
            obj_.original_tagname_ = 'calculationPeriodsScheduleReference'
        elif nodeName_ == 'calculationPeriodsDatesReference':
            obj_ = CalculationPeriodsDatesReference.factory()
            obj_.build(child_)
            self.calculationPeriodsDatesReference = obj_
            obj_.original_tagname_ = 'calculationPeriodsDatesReference'
# end class CommodityStrikeSchedule


class CommoditySwaptionUnderlying(GeneratedsSuper):
    member_data_items_ = {
        'effectiveDate': MemberSpec_('effectiveDate', 'AdjustableOrRelativeDate', 0),
        'terminationDate': MemberSpec_('terminationDate', 'AdjustableOrRelativeDate', 0),
        'settlementCurrency': MemberSpec_('settlementCurrency', 'IdentifiedCurrency', 0),
        'commoditySwapLeg': MemberSpec_('commoditySwapLeg', 'CommoditySwapLeg', 1),
        'weatherLeg': MemberSpec_('weatherLeg', 'WeatherLeg', 1),
        'commonPricing': MemberSpec_('commonPricing', 'xsd:boolean', 0),
        'marketDisruption': MemberSpec_('marketDisruption', 'CommodityMarketDisruption', 0),
        'settlementDisruption': MemberSpec_('settlementDisruption', ['CommodityBullionSettlementDisruptionEnum', 'Token', 'xsd:token', 'Token', 'xsd:token'], 0),
        'rounding': MemberSpec_('rounding', 'Rounding', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, effectiveDate=None, terminationDate=None, settlementCurrency=None, commoditySwapLeg=None, weatherLeg=None, commonPricing=None, marketDisruption=None, settlementDisruption=None, rounding=None):
        self.original_tagname_ = None
        self.effectiveDate = effectiveDate
        self.terminationDate = terminationDate
        self.settlementCurrency = settlementCurrency
        if commoditySwapLeg is None:
            self.commoditySwapLeg = []
        else:
            self.commoditySwapLeg = commoditySwapLeg
        if weatherLeg is None:
            self.weatherLeg = []
        else:
            self.weatherLeg = weatherLeg
        self.commonPricing = commonPricing
        self.marketDisruption = marketDisruption
        self.settlementDisruption = settlementDisruption
        self.validate_CommodityBullionSettlementDisruptionEnum(self.settlementDisruption)
        self.rounding = rounding
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommoditySwaptionUnderlying)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommoditySwaptionUnderlying.subclass:
            return CommoditySwaptionUnderlying.subclass(*args_, **kwargs_)
        else:
            return CommoditySwaptionUnderlying(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_effectiveDate(self): return self.effectiveDate
    def set_effectiveDate(self, effectiveDate): self.effectiveDate = effectiveDate
    def get_terminationDate(self): return self.terminationDate
    def set_terminationDate(self, terminationDate): self.terminationDate = terminationDate
    def get_settlementCurrency(self): return self.settlementCurrency
    def set_settlementCurrency(self, settlementCurrency): self.settlementCurrency = settlementCurrency
    def get_commoditySwapLeg(self): return self.commoditySwapLeg
    def set_commoditySwapLeg(self, commoditySwapLeg): self.commoditySwapLeg = commoditySwapLeg
    def add_commoditySwapLeg(self, value): self.commoditySwapLeg.append(value)
    def insert_commoditySwapLeg_at(self, index, value): self.commoditySwapLeg.insert(index, value)
    def replace_commoditySwapLeg_at(self, index, value): self.commoditySwapLeg[index] = value
    def get_weatherLeg(self): return self.weatherLeg
    def set_weatherLeg(self, weatherLeg): self.weatherLeg = weatherLeg
    def add_weatherLeg(self, value): self.weatherLeg.append(value)
    def insert_weatherLeg_at(self, index, value): self.weatherLeg.insert(index, value)
    def replace_weatherLeg_at(self, index, value): self.weatherLeg[index] = value
    def get_commonPricing(self): return self.commonPricing
    def set_commonPricing(self, commonPricing): self.commonPricing = commonPricing
    def get_marketDisruption(self): return self.marketDisruption
    def set_marketDisruption(self, marketDisruption): self.marketDisruption = marketDisruption
    def get_settlementDisruption(self): return self.settlementDisruption
    def set_settlementDisruption(self, settlementDisruption): self.settlementDisruption = settlementDisruption
    def get_rounding(self): return self.rounding
    def set_rounding(self, rounding): self.rounding = rounding
    def validate_CommodityBullionSettlementDisruptionEnum(self, value):
        # Validate type CommodityBullionSettlementDisruptionEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Negotiation', 'Cancellation and Payment']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CommodityBullionSettlementDisruptionEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on CommodityBullionSettlementDisruptionEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.effectiveDate is not None or
            self.terminationDate is not None or
            self.settlementCurrency is not None or
            self.commoditySwapLeg or
            self.weatherLeg or
            self.commonPricing is not None or
            self.marketDisruption is not None or
            self.settlementDisruption is not None or
            self.rounding is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommoditySwaptionUnderlying', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommoditySwaptionUnderlying')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommoditySwaptionUnderlying', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommoditySwaptionUnderlying'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CommoditySwaptionUnderlying', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.effectiveDate is not None:
            self.effectiveDate.export(outfile, level, namespace_, name_='effectiveDate', pretty_print=pretty_print)
        if self.terminationDate is not None:
            self.terminationDate.export(outfile, level, namespace_, name_='terminationDate', pretty_print=pretty_print)
        if self.settlementCurrency is not None:
            self.settlementCurrency.export(outfile, level, namespace_, name_='settlementCurrency', pretty_print=pretty_print)
        for commoditySwapLeg_ in self.commoditySwapLeg:
            commoditySwapLeg_.export(outfile, level, namespace_, name_='commoditySwapLeg', pretty_print=pretty_print)
        for weatherLeg_ in self.weatherLeg:
            weatherLeg_.export(outfile, level, namespace_, name_='weatherLeg', pretty_print=pretty_print)
        if self.commonPricing is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scommonPricing>%s</%scommonPricing>%s' % (namespace_, self.gds_format_boolean(self.commonPricing, input_name='commonPricing'), namespace_, eol_))
        if self.marketDisruption is not None:
            self.marketDisruption.export(outfile, level, namespace_, name_='marketDisruption', pretty_print=pretty_print)
        if self.settlementDisruption is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssettlementDisruption>%s</%ssettlementDisruption>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.settlementDisruption), input_name='settlementDisruption')), namespace_, eol_))
        if self.rounding is not None:
            self.rounding.export(outfile, level, namespace_, name_='rounding', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'effectiveDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.effectiveDate = obj_
            obj_.original_tagname_ = 'effectiveDate'
        elif nodeName_ == 'terminationDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.terminationDate = obj_
            obj_.original_tagname_ = 'terminationDate'
        elif nodeName_ == 'settlementCurrency':
            obj_ = IdentifiedCurrency.factory()
            obj_.build(child_)
            self.settlementCurrency = obj_
            obj_.original_tagname_ = 'settlementCurrency'
        elif nodeName_ == 'commoditySwapLeg':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <commoditySwapLeg> element')
            self.commoditySwapLeg.append(obj_)
            obj_.original_tagname_ = 'commoditySwapLeg'
        elif nodeName_ == 'coalPhysicalLeg':
            obj_ = CoalPhysicalLeg.factory()
            obj_.build(child_)
            self.commoditySwapLeg.append(obj_)
            obj_.original_tagname_ = 'coalPhysicalLeg'
        elif nodeName_ == 'electricityPhysicalLeg':
            obj_ = ElectricityPhysicalLeg.factory()
            obj_.build(child_)
            self.commoditySwapLeg.append(obj_)
            obj_.original_tagname_ = 'electricityPhysicalLeg'
        elif nodeName_ == 'environmentalPhysicalLeg':
            obj_ = EnvironmentalPhysicalLeg.factory()
            obj_.build(child_)
            self.commoditySwapLeg.append(obj_)
            obj_.original_tagname_ = 'environmentalPhysicalLeg'
        elif nodeName_ == 'fixedLeg':
            obj_ = FixedPriceLeg.factory()
            obj_.build(child_)
            self.commoditySwapLeg.append(obj_)
            obj_.original_tagname_ = 'fixedLeg'
        elif nodeName_ == 'floatingLeg':
            obj_ = FloatingPriceLeg.factory()
            obj_.build(child_)
            self.commoditySwapLeg.append(obj_)
            obj_.original_tagname_ = 'floatingLeg'
        elif nodeName_ == 'gasPhysicalLeg':
            obj_ = GasPhysicalLeg.factory()
            obj_.build(child_)
            self.commoditySwapLeg.append(obj_)
            obj_.original_tagname_ = 'gasPhysicalLeg'
        elif nodeName_ == 'oilPhysicalLeg':
            obj_ = OilPhysicalLeg.factory()
            obj_.build(child_)
            self.commoditySwapLeg.append(obj_)
            obj_.original_tagname_ = 'oilPhysicalLeg'
        elif nodeName_ == 'weatherLeg':
            obj_ = WeatherLeg.factory()
            obj_.build(child_)
            self.weatherLeg.append(obj_)
            obj_.original_tagname_ = 'weatherLeg'
        elif nodeName_ == 'commonPricing':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'commonPricing')
            self.commonPricing = ival_
        elif nodeName_ == 'marketDisruption':
            obj_ = CommodityMarketDisruption.factory()
            obj_.build(child_)
            self.marketDisruption = obj_
            obj_.original_tagname_ = 'marketDisruption'
        elif nodeName_ == 'settlementDisruption':
            settlementDisruption_ = child_.text
            settlementDisruption_ = re_.sub(String_cleanup_pat_, " ", settlementDisruption_).strip()
            settlementDisruption_ = self.gds_validate_string(settlementDisruption_, node, 'settlementDisruption')
            self.settlementDisruption = settlementDisruption_
            # validate type CommodityBullionSettlementDisruptionEnum
            self.validate_CommodityBullionSettlementDisruptionEnum(self.settlementDisruption)
        elif nodeName_ == 'rounding':
            obj_ = Rounding.factory()
            obj_.build(child_)
            self.rounding = obj_
            obj_.original_tagname_ = 'rounding'
# end class CommoditySwaptionUnderlying


class CommodityTrigger(GeneratedsSuper):
    """The barrier which, when breached, triggers the knock-in or knock-out
    of the barrier option."""
    member_data_items_ = {
        'levelQuantity': MemberSpec_('levelQuantity', 'xsd:decimal', 0),
        'levelUnit': MemberSpec_('levelUnit', 'QuantityUnit', 0),
        'levelPercentage': MemberSpec_('levelPercentage', 'xsd:decimal', 0),
        'levelPrice': MemberSpec_('levelPrice', 'FixedPrice', 0),
        'triggerType': MemberSpec_('triggerType', ['TriggerTypeEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, levelQuantity=None, levelUnit=None, levelPercentage=None, levelPrice=None, triggerType=None):
        self.original_tagname_ = None
        self.levelQuantity = levelQuantity
        self.levelUnit = levelUnit
        self.levelPercentage = levelPercentage
        self.levelPrice = levelPrice
        self.triggerType = triggerType
        self.validate_TriggerTypeEnum(self.triggerType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityTrigger)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityTrigger.subclass:
            return CommodityTrigger.subclass(*args_, **kwargs_)
        else:
            return CommodityTrigger(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_levelQuantity(self): return self.levelQuantity
    def set_levelQuantity(self, levelQuantity): self.levelQuantity = levelQuantity
    def get_levelUnit(self): return self.levelUnit
    def set_levelUnit(self, levelUnit): self.levelUnit = levelUnit
    def get_levelPercentage(self): return self.levelPercentage
    def set_levelPercentage(self, levelPercentage): self.levelPercentage = levelPercentage
    def get_levelPrice(self): return self.levelPrice
    def set_levelPrice(self, levelPrice): self.levelPrice = levelPrice
    def get_triggerType(self): return self.triggerType
    def set_triggerType(self, triggerType): self.triggerType = triggerType
    def validate_TriggerTypeEnum(self, value):
        # Validate type TriggerTypeEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['EqualOrLess', 'EqualOrGreater', 'Equal', 'Less', 'Greater']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TriggerTypeEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on TriggerTypeEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.levelQuantity is not None or
            self.levelUnit is not None or
            self.levelPercentage is not None or
            self.levelPrice is not None or
            self.triggerType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityTrigger', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityTrigger')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityTrigger', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityTrigger'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityTrigger', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.levelQuantity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slevelQuantity>%s</%slevelQuantity>%s' % (namespace_, self.gds_format_float(self.levelQuantity, input_name='levelQuantity'), namespace_, eol_))
        if self.levelUnit is not None:
            self.levelUnit.export(outfile, level, namespace_, name_='levelUnit', pretty_print=pretty_print)
        if self.levelPercentage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slevelPercentage>%s</%slevelPercentage>%s' % (namespace_, self.gds_format_float(self.levelPercentage, input_name='levelPercentage'), namespace_, eol_))
        if self.levelPrice is not None:
            self.levelPrice.export(outfile, level, namespace_, name_='levelPrice', pretty_print=pretty_print)
        if self.triggerType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%striggerType>%s</%striggerType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.triggerType), input_name='triggerType')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'levelQuantity':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'levelQuantity')
            self.levelQuantity = fval_
        elif nodeName_ == 'levelUnit':
            obj_ = QuantityUnit.factory()
            obj_.build(child_)
            self.levelUnit = obj_
            obj_.original_tagname_ = 'levelUnit'
        elif nodeName_ == 'levelPercentage':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'levelPercentage')
            self.levelPercentage = fval_
        elif nodeName_ == 'levelPrice':
            class_obj_ = self.get_class_obj_(child_, FixedPrice)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.levelPrice = obj_
            obj_.original_tagname_ = 'levelPrice'
        elif nodeName_ == 'triggerType':
            triggerType_ = child_.text
            triggerType_ = re_.sub(String_cleanup_pat_, " ", triggerType_).strip()
            triggerType_ = self.gds_validate_string(triggerType_, node, 'triggerType')
            self.triggerType = triggerType_
            # validate type TriggerTypeEnum
            self.validate_TriggerTypeEnum(self.triggerType)
# end class CommodityTrigger


class CommodityValuationDates(GeneratedsSuper):
    """The dates on which prices are observed for the underlyer."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'calculationPeriodsReference': MemberSpec_('calculationPeriodsReference', 'CalculationPeriodsReference', 0),
        'calculationPeriodsScheduleReference': MemberSpec_('calculationPeriodsScheduleReference', 'CalculationPeriodsScheduleReference', 0),
        'calculationPeriodsDatesReference': MemberSpec_('calculationPeriodsDatesReference', 'CalculationPeriodsDatesReference', 0),
        'lag': MemberSpec_('lag', 'Lag', 0),
        'dayType': MemberSpec_('dayType', ['CommodityDayTypeEnum', 'Token', 'xsd:token'], 0),
        'dayDistribution': MemberSpec_('dayDistribution', 'CommodityFrequencyType', 0),
        'dayCount': MemberSpec_('dayCount', 'xsd:positiveInteger', 0),
        'dayOfWeek': MemberSpec_('dayOfWeek', ['DayOfWeekEnum', 'Token', 'xsd:token'], 1),
        'dayNumber': MemberSpec_('dayNumber', 'xsd:integer', 0),
        'businessDayConvention': MemberSpec_('businessDayConvention', ['BusinessDayConventionEnum', 'Token', 'xsd:token'], 0),
        'businessCalendar': MemberSpec_('businessCalendar', 'CommodityBusinessCalendar', 0),
        'calendarSource': MemberSpec_('calendarSource', ['CalendarSourceEnum', 'Token', 'xsd:token'], 0),
        'settlementPeriods': MemberSpec_('settlementPeriods', 'SettlementPeriods', 1),
        'settlementPeriodsReference': MemberSpec_('settlementPeriodsReference', 'SettlementPeriodsReference', 1),
        'valuationDates': MemberSpec_('valuationDates', 'AdjustableDates', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, calculationPeriodsReference=None, calculationPeriodsScheduleReference=None, calculationPeriodsDatesReference=None, lag=None, dayType=None, dayDistribution=None, dayCount=None, dayOfWeek=None, dayNumber=None, businessDayConvention=None, businessCalendar=None, calendarSource=None, settlementPeriods=None, settlementPeriodsReference=None, valuationDates=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.calculationPeriodsReference = calculationPeriodsReference
        self.calculationPeriodsScheduleReference = calculationPeriodsScheduleReference
        self.calculationPeriodsDatesReference = calculationPeriodsDatesReference
        self.lag = lag
        self.dayType = dayType
        self.validate_CommodityDayTypeEnum(self.dayType)
        self.dayDistribution = dayDistribution
        self.dayCount = dayCount
        if dayOfWeek is None:
            self.dayOfWeek = []
        else:
            self.dayOfWeek = dayOfWeek
        self.dayNumber = dayNumber
        self.businessDayConvention = businessDayConvention
        self.validate_BusinessDayConventionEnum(self.businessDayConvention)
        self.businessCalendar = businessCalendar
        self.calendarSource = calendarSource
        self.validate_CalendarSourceEnum(self.calendarSource)
        if settlementPeriods is None:
            self.settlementPeriods = []
        else:
            self.settlementPeriods = settlementPeriods
        if settlementPeriodsReference is None:
            self.settlementPeriodsReference = []
        else:
            self.settlementPeriodsReference = settlementPeriodsReference
        if valuationDates is None:
            self.valuationDates = []
        else:
            self.valuationDates = valuationDates
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityValuationDates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityValuationDates.subclass:
            return CommodityValuationDates.subclass(*args_, **kwargs_)
        else:
            return CommodityValuationDates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_calculationPeriodsReference(self): return self.calculationPeriodsReference
    def set_calculationPeriodsReference(self, calculationPeriodsReference): self.calculationPeriodsReference = calculationPeriodsReference
    def get_calculationPeriodsScheduleReference(self): return self.calculationPeriodsScheduleReference
    def set_calculationPeriodsScheduleReference(self, calculationPeriodsScheduleReference): self.calculationPeriodsScheduleReference = calculationPeriodsScheduleReference
    def get_calculationPeriodsDatesReference(self): return self.calculationPeriodsDatesReference
    def set_calculationPeriodsDatesReference(self, calculationPeriodsDatesReference): self.calculationPeriodsDatesReference = calculationPeriodsDatesReference
    def get_lag(self): return self.lag
    def set_lag(self, lag): self.lag = lag
    def get_dayType(self): return self.dayType
    def set_dayType(self, dayType): self.dayType = dayType
    def get_dayDistribution(self): return self.dayDistribution
    def set_dayDistribution(self, dayDistribution): self.dayDistribution = dayDistribution
    def get_dayCount(self): return self.dayCount
    def set_dayCount(self, dayCount): self.dayCount = dayCount
    def get_dayOfWeek(self): return self.dayOfWeek
    def set_dayOfWeek(self, dayOfWeek): self.dayOfWeek = dayOfWeek
    def add_dayOfWeek(self, value): self.dayOfWeek.append(value)
    def insert_dayOfWeek_at(self, index, value): self.dayOfWeek.insert(index, value)
    def replace_dayOfWeek_at(self, index, value): self.dayOfWeek[index] = value
    def get_dayNumber(self): return self.dayNumber
    def set_dayNumber(self, dayNumber): self.dayNumber = dayNumber
    def get_businessDayConvention(self): return self.businessDayConvention
    def set_businessDayConvention(self, businessDayConvention): self.businessDayConvention = businessDayConvention
    def get_businessCalendar(self): return self.businessCalendar
    def set_businessCalendar(self, businessCalendar): self.businessCalendar = businessCalendar
    def get_calendarSource(self): return self.calendarSource
    def set_calendarSource(self, calendarSource): self.calendarSource = calendarSource
    def get_settlementPeriods(self): return self.settlementPeriods
    def set_settlementPeriods(self, settlementPeriods): self.settlementPeriods = settlementPeriods
    def add_settlementPeriods(self, value): self.settlementPeriods.append(value)
    def insert_settlementPeriods_at(self, index, value): self.settlementPeriods.insert(index, value)
    def replace_settlementPeriods_at(self, index, value): self.settlementPeriods[index] = value
    def get_settlementPeriodsReference(self): return self.settlementPeriodsReference
    def set_settlementPeriodsReference(self, settlementPeriodsReference): self.settlementPeriodsReference = settlementPeriodsReference
    def add_settlementPeriodsReference(self, value): self.settlementPeriodsReference.append(value)
    def insert_settlementPeriodsReference_at(self, index, value): self.settlementPeriodsReference.insert(index, value)
    def replace_settlementPeriodsReference_at(self, index, value): self.settlementPeriodsReference[index] = value
    def get_valuationDates(self): return self.valuationDates
    def set_valuationDates(self, valuationDates): self.valuationDates = valuationDates
    def add_valuationDates(self, value): self.valuationDates.append(value)
    def insert_valuationDates_at(self, index, value): self.valuationDates.insert(index, value)
    def replace_valuationDates_at(self, index, value): self.valuationDates[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_CommodityDayTypeEnum(self, value):
        # Validate type CommodityDayTypeEnum, a restriction on Token.
        pass
    def validate_DayOfWeekEnum(self, value):
        # Validate type DayOfWeekEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT', 'SUN']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DayOfWeekEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on DayOfWeekEnum' % {"value" : value} )
    def validate_BusinessDayConventionEnum(self, value):
        # Validate type BusinessDayConventionEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FOLLOWING', 'FRN', 'MODFOLLOWING', 'PRECEDING', 'MODPRECEDING', 'NEAREST', 'NONE', 'NotApplicable']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on BusinessDayConventionEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on BusinessDayConventionEnum' % {"value" : value} )
    def validate_CalendarSourceEnum(self, value):
        # Validate type CalendarSourceEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ListedOption', 'Future']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CalendarSourceEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on CalendarSourceEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.calculationPeriodsReference is not None or
            self.calculationPeriodsScheduleReference is not None or
            self.calculationPeriodsDatesReference is not None or
            self.lag is not None or
            self.dayType is not None or
            self.dayDistribution is not None or
            self.dayCount is not None or
            self.dayOfWeek or
            self.dayNumber is not None or
            self.businessDayConvention is not None or
            self.businessCalendar is not None or
            self.calendarSource is not None or
            self.settlementPeriods or
            self.settlementPeriodsReference or
            self.valuationDates
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityValuationDates', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityValuationDates')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityValuationDates', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityValuationDates'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityValuationDates', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.calculationPeriodsReference is not None:
            self.calculationPeriodsReference.export(outfile, level, namespace_, name_='calculationPeriodsReference', pretty_print=pretty_print)
        if self.calculationPeriodsScheduleReference is not None:
            self.calculationPeriodsScheduleReference.export(outfile, level, namespace_, name_='calculationPeriodsScheduleReference', pretty_print=pretty_print)
        if self.calculationPeriodsDatesReference is not None:
            self.calculationPeriodsDatesReference.export(outfile, level, namespace_, name_='calculationPeriodsDatesReference', pretty_print=pretty_print)
        if self.lag is not None:
            self.lag.export(outfile, level, namespace_, name_='lag', pretty_print=pretty_print)
        if self.dayType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdayType>%s</%sdayType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.dayType), input_name='dayType')), namespace_, eol_))
        if self.dayDistribution is not None:
            self.dayDistribution.export(outfile, level, namespace_, name_='dayDistribution', pretty_print=pretty_print)
        if self.dayCount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdayCount>%s</%sdayCount>%s' % (namespace_, self.gds_format_integer(self.dayCount, input_name='dayCount'), namespace_, eol_))
        for dayOfWeek_ in self.dayOfWeek:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdayOfWeek>%s</%sdayOfWeek>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(dayOfWeek_), input_name='dayOfWeek')), namespace_, eol_))
        if self.dayNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdayNumber>%s</%sdayNumber>%s' % (namespace_, self.gds_format_integer(self.dayNumber, input_name='dayNumber'), namespace_, eol_))
        if self.businessDayConvention is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbusinessDayConvention>%s</%sbusinessDayConvention>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.businessDayConvention), input_name='businessDayConvention')), namespace_, eol_))
        if self.businessCalendar is not None:
            self.businessCalendar.export(outfile, level, namespace_, name_='businessCalendar', pretty_print=pretty_print)
        if self.calendarSource is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scalendarSource>%s</%scalendarSource>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.calendarSource), input_name='calendarSource')), namespace_, eol_))
        for settlementPeriods_ in self.settlementPeriods:
            settlementPeriods_.export(outfile, level, namespace_, name_='settlementPeriods', pretty_print=pretty_print)
        for settlementPeriodsReference_ in self.settlementPeriodsReference:
            settlementPeriodsReference_.export(outfile, level, namespace_, name_='settlementPeriodsReference', pretty_print=pretty_print)
        for valuationDates_ in self.valuationDates:
            valuationDates_.export(outfile, level, namespace_, name_='valuationDates', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'calculationPeriodsReference':
            obj_ = CalculationPeriodsReference.factory()
            obj_.build(child_)
            self.calculationPeriodsReference = obj_
            obj_.original_tagname_ = 'calculationPeriodsReference'
        elif nodeName_ == 'calculationPeriodsScheduleReference':
            obj_ = CalculationPeriodsScheduleReference.factory()
            obj_.build(child_)
            self.calculationPeriodsScheduleReference = obj_
            obj_.original_tagname_ = 'calculationPeriodsScheduleReference'
        elif nodeName_ == 'calculationPeriodsDatesReference':
            obj_ = CalculationPeriodsDatesReference.factory()
            obj_.build(child_)
            self.calculationPeriodsDatesReference = obj_
            obj_.original_tagname_ = 'calculationPeriodsDatesReference'
        elif nodeName_ == 'lag':
            obj_ = Lag.factory()
            obj_.build(child_)
            self.lag = obj_
            obj_.original_tagname_ = 'lag'
        elif nodeName_ == 'dayType':
            dayType_ = child_.text
            dayType_ = re_.sub(String_cleanup_pat_, " ", dayType_).strip()
            dayType_ = self.gds_validate_string(dayType_, node, 'dayType')
            self.dayType = dayType_
            # validate type CommodityDayTypeEnum
            self.validate_CommodityDayTypeEnum(self.dayType)
        elif nodeName_ == 'dayDistribution':
            obj_ = CommodityFrequencyType.factory()
            obj_.build(child_)
            self.dayDistribution = obj_
            obj_.original_tagname_ = 'dayDistribution'
        elif nodeName_ == 'dayCount':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'dayCount')
            self.dayCount = ival_
        elif nodeName_ == 'dayOfWeek':
            dayOfWeek_ = child_.text
            dayOfWeek_ = re_.sub(String_cleanup_pat_, " ", dayOfWeek_).strip()
            dayOfWeek_ = self.gds_validate_string(dayOfWeek_, node, 'dayOfWeek')
            self.dayOfWeek.append(dayOfWeek_)
            # validate type DayOfWeekEnum
            self.validate_DayOfWeekEnum(self.dayOfWeek[-1])
        elif nodeName_ == 'dayNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'dayNumber')
            self.dayNumber = ival_
        elif nodeName_ == 'businessDayConvention':
            businessDayConvention_ = child_.text
            businessDayConvention_ = re_.sub(String_cleanup_pat_, " ", businessDayConvention_).strip()
            businessDayConvention_ = self.gds_validate_string(businessDayConvention_, node, 'businessDayConvention')
            self.businessDayConvention = businessDayConvention_
            # validate type BusinessDayConventionEnum
            self.validate_BusinessDayConventionEnum(self.businessDayConvention)
        elif nodeName_ == 'businessCalendar':
            obj_ = CommodityBusinessCalendar.factory()
            obj_.build(child_)
            self.businessCalendar = obj_
            obj_.original_tagname_ = 'businessCalendar'
        elif nodeName_ == 'calendarSource':
            calendarSource_ = child_.text
            calendarSource_ = re_.sub(String_cleanup_pat_, " ", calendarSource_).strip()
            calendarSource_ = self.gds_validate_string(calendarSource_, node, 'calendarSource')
            self.calendarSource = calendarSource_
            # validate type CalendarSourceEnum
            self.validate_CalendarSourceEnum(self.calendarSource)
        elif nodeName_ == 'settlementPeriods':
            obj_ = SettlementPeriods.factory()
            obj_.build(child_)
            self.settlementPeriods.append(obj_)
            obj_.original_tagname_ = 'settlementPeriods'
        elif nodeName_ == 'settlementPeriodsReference':
            obj_ = SettlementPeriodsReference.factory()
            obj_.build(child_)
            self.settlementPeriodsReference.append(obj_)
            obj_.original_tagname_ = 'settlementPeriodsReference'
        elif nodeName_ == 'valuationDates':
            obj_ = AdjustableDates.factory()
            obj_.build(child_)
            self.valuationDates.append(obj_)
            obj_.original_tagname_ = 'valuationDates'
# end class CommodityValuationDates


class CommodityVarianceCalculation(GeneratedsSuper):
    member_data_items_ = {
        'pricingDates': MemberSpec_('pricingDates', 'CommodityPricingDates', 0),
        'valuationDates': MemberSpec_('valuationDates', 'CommodityValuationDates', 0),
        'annualizationFactor': MemberSpec_('annualizationFactor', 'xsd:decimal', 0),
        'nAdjustment': MemberSpec_('nAdjustment', 'xsd:boolean', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, pricingDates=None, valuationDates=None, annualizationFactor=None, nAdjustment=None):
        self.original_tagname_ = None
        self.pricingDates = pricingDates
        self.valuationDates = valuationDates
        self.annualizationFactor = annualizationFactor
        self.nAdjustment = nAdjustment
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityVarianceCalculation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityVarianceCalculation.subclass:
            return CommodityVarianceCalculation.subclass(*args_, **kwargs_)
        else:
            return CommodityVarianceCalculation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pricingDates(self): return self.pricingDates
    def set_pricingDates(self, pricingDates): self.pricingDates = pricingDates
    def get_valuationDates(self): return self.valuationDates
    def set_valuationDates(self, valuationDates): self.valuationDates = valuationDates
    def get_annualizationFactor(self): return self.annualizationFactor
    def set_annualizationFactor(self, annualizationFactor): self.annualizationFactor = annualizationFactor
    def get_nAdjustment(self): return self.nAdjustment
    def set_nAdjustment(self, nAdjustment): self.nAdjustment = nAdjustment
    def hasContent_(self):
        if (
            self.pricingDates is not None or
            self.valuationDates is not None or
            self.annualizationFactor is not None or
            self.nAdjustment is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityVarianceCalculation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityVarianceCalculation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityVarianceCalculation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityVarianceCalculation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityVarianceCalculation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.pricingDates is not None:
            self.pricingDates.export(outfile, level, namespace_, name_='pricingDates', pretty_print=pretty_print)
        if self.valuationDates is not None:
            self.valuationDates.export(outfile, level, namespace_, name_='valuationDates', pretty_print=pretty_print)
        if self.annualizationFactor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sannualizationFactor>%s</%sannualizationFactor>%s' % (namespace_, self.gds_format_float(self.annualizationFactor, input_name='annualizationFactor'), namespace_, eol_))
        if self.nAdjustment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snAdjustment>%s</%snAdjustment>%s' % (namespace_, self.gds_format_boolean(self.nAdjustment, input_name='nAdjustment'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pricingDates':
            obj_ = CommodityPricingDates.factory()
            obj_.build(child_)
            self.pricingDates = obj_
            obj_.original_tagname_ = 'pricingDates'
        elif nodeName_ == 'valuationDates':
            obj_ = CommodityValuationDates.factory()
            obj_.build(child_)
            self.valuationDates = obj_
            obj_.original_tagname_ = 'valuationDates'
        elif nodeName_ == 'annualizationFactor':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'annualizationFactor')
            self.annualizationFactor = fval_
        elif nodeName_ == 'nAdjustment':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'nAdjustment')
            self.nAdjustment = ival_
# end class CommodityVarianceCalculation


class DataProvider(GeneratedsSuper):
    """Specify as applicable. Parties may wish to refer to the state
    meteorological authority in a particular location or to an
    exchange or other third party data provider. Parties may find
    the definitions in the Commodity Definitions useful as a means
    of identifying potential Data Providers."""
    member_data_items_ = {
        'weatherDataProviderScheme': MemberSpec_('weatherDataProviderScheme', 'NonEmptyURI', 0),
        'id': MemberSpec_('id', 'xsd:string', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, weatherDataProviderScheme='http://www.fpml.org/coding-scheme/weather-data-provider', id=None, valueOf_=None):
        self.original_tagname_ = None
        self.weatherDataProviderScheme = _cast(None, weatherDataProviderScheme)
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataProvider)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataProvider.subclass:
            return DataProvider.subclass(*args_, **kwargs_)
        else:
            return DataProvider(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_weatherDataProviderScheme(self): return self.weatherDataProviderScheme
    def set_weatherDataProviderScheme(self, weatherDataProviderScheme): self.weatherDataProviderScheme = weatherDataProviderScheme
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DataProvider', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataProvider')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DataProvider', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DataProvider'):
        if self.weatherDataProviderScheme != "http://www.fpml.org/coding-scheme/weather-data-provider" and 'weatherDataProviderScheme' not in already_processed:
            already_processed.add('weatherDataProviderScheme')
            outfile.write(' weatherDataProviderScheme=%s' % (quote_attrib(self.weatherDataProviderScheme), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DataProvider', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('weatherDataProviderScheme', node)
        if value is not None and 'weatherDataProviderScheme' not in already_processed:
            already_processed.add('weatherDataProviderScheme')
            self.weatherDataProviderScheme = value
            self.validate_NonEmptyURI(self.weatherDataProviderScheme)    # validate type NonEmptyURI
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DataProvider


class DisruptionFallback(GeneratedsSuper):
    """A Disruption Fallback."""
    member_data_items_ = {
        'commodityMarketDisruptionFallbackScheme': MemberSpec_('commodityMarketDisruptionFallbackScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, commodityMarketDisruptionFallbackScheme='http://www.fpml.org/coding-scheme/commodity-market-disruption-fallback', valueOf_=None):
        self.original_tagname_ = None
        self.commodityMarketDisruptionFallbackScheme = _cast(None, commodityMarketDisruptionFallbackScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DisruptionFallback)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DisruptionFallback.subclass:
            return DisruptionFallback.subclass(*args_, **kwargs_)
        else:
            return DisruptionFallback(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commodityMarketDisruptionFallbackScheme(self): return self.commodityMarketDisruptionFallbackScheme
    def set_commodityMarketDisruptionFallbackScheme(self, commodityMarketDisruptionFallbackScheme): self.commodityMarketDisruptionFallbackScheme = commodityMarketDisruptionFallbackScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DisruptionFallback', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DisruptionFallback')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DisruptionFallback', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DisruptionFallback'):
        if self.commodityMarketDisruptionFallbackScheme != "http://www.fpml.org/coding-scheme/commodity-market-disruption-fallback" and 'commodityMarketDisruptionFallbackScheme' not in already_processed:
            already_processed.add('commodityMarketDisruptionFallbackScheme')
            outfile.write(' commodityMarketDisruptionFallbackScheme=%s' % (quote_attrib(self.commodityMarketDisruptionFallbackScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DisruptionFallback', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('commodityMarketDisruptionFallbackScheme', node)
        if value is not None and 'commodityMarketDisruptionFallbackScheme' not in already_processed:
            already_processed.add('commodityMarketDisruptionFallbackScheme')
            self.commodityMarketDisruptionFallbackScheme = value
            self.validate_NonEmptyURI(self.commodityMarketDisruptionFallbackScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DisruptionFallback


class EEPParameters(GeneratedsSuper):
    """Excess Emission Penalty related parameters."""
    member_data_items_ = {
        'eEPApplicable': MemberSpec_('eEPApplicable', 'xsd:boolean', 0),
        'riskPeriod': MemberSpec_('riskPeriod', 'EEPRiskPeriod', 0),
        'equivalentApplicable': MemberSpec_('equivalentApplicable', 'xsd:boolean', 0),
        'penaltyApplicable': MemberSpec_('penaltyApplicable', 'xsd:boolean', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, eEPApplicable=None, riskPeriod=None, equivalentApplicable=None, penaltyApplicable=None):
        self.original_tagname_ = None
        self.eEPApplicable = eEPApplicable
        self.riskPeriod = riskPeriod
        self.equivalentApplicable = equivalentApplicable
        self.penaltyApplicable = penaltyApplicable
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EEPParameters)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EEPParameters.subclass:
            return EEPParameters.subclass(*args_, **kwargs_)
        else:
            return EEPParameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_eEPApplicable(self): return self.eEPApplicable
    def set_eEPApplicable(self, eEPApplicable): self.eEPApplicable = eEPApplicable
    def get_riskPeriod(self): return self.riskPeriod
    def set_riskPeriod(self, riskPeriod): self.riskPeriod = riskPeriod
    def get_equivalentApplicable(self): return self.equivalentApplicable
    def set_equivalentApplicable(self, equivalentApplicable): self.equivalentApplicable = equivalentApplicable
    def get_penaltyApplicable(self): return self.penaltyApplicable
    def set_penaltyApplicable(self, penaltyApplicable): self.penaltyApplicable = penaltyApplicable
    def hasContent_(self):
        if (
            self.eEPApplicable is not None or
            self.riskPeriod is not None or
            self.equivalentApplicable is not None or
            self.penaltyApplicable is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EEPParameters', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EEPParameters')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EEPParameters', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EEPParameters'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EEPParameters', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.eEPApplicable is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%seEPApplicable>%s</%seEPApplicable>%s' % (namespace_, self.gds_format_boolean(self.eEPApplicable, input_name='eEPApplicable'), namespace_, eol_))
        if self.riskPeriod is not None:
            self.riskPeriod.export(outfile, level, namespace_, name_='riskPeriod', pretty_print=pretty_print)
        if self.equivalentApplicable is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sequivalentApplicable>%s</%sequivalentApplicable>%s' % (namespace_, self.gds_format_boolean(self.equivalentApplicable, input_name='equivalentApplicable'), namespace_, eol_))
        if self.penaltyApplicable is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spenaltyApplicable>%s</%spenaltyApplicable>%s' % (namespace_, self.gds_format_boolean(self.penaltyApplicable, input_name='penaltyApplicable'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'eEPApplicable':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'eEPApplicable')
            self.eEPApplicable = ival_
        elif nodeName_ == 'riskPeriod':
            obj_ = EEPRiskPeriod.factory()
            obj_.build(child_)
            self.riskPeriod = obj_
            obj_.original_tagname_ = 'riskPeriod'
        elif nodeName_ == 'equivalentApplicable':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'equivalentApplicable')
            self.equivalentApplicable = ival_
        elif nodeName_ == 'penaltyApplicable':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'penaltyApplicable')
            self.penaltyApplicable = ival_
# end class EEPParameters


class EEPRiskPeriod(GeneratedsSuper):
    """TBD."""
    member_data_items_ = {
        'startDate': MemberSpec_('startDate', 'xsd:date', 0),
        'endDate': MemberSpec_('endDate', 'xsd:date', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, startDate=None, endDate=None):
        self.original_tagname_ = None
        if isinstance(startDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(startDate, '%Y-%m-%d').date()
        else:
            initvalue_ = startDate
        self.startDate = initvalue_
        if isinstance(endDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(endDate, '%Y-%m-%d').date()
        else:
            initvalue_ = endDate
        self.endDate = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EEPRiskPeriod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EEPRiskPeriod.subclass:
            return EEPRiskPeriod.subclass(*args_, **kwargs_)
        else:
            return EEPRiskPeriod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_startDate(self): return self.startDate
    def set_startDate(self, startDate): self.startDate = startDate
    def get_endDate(self): return self.endDate
    def set_endDate(self, endDate): self.endDate = endDate
    def hasContent_(self):
        if (
            self.startDate is not None or
            self.endDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EEPRiskPeriod', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EEPRiskPeriod')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EEPRiskPeriod', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EEPRiskPeriod'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EEPRiskPeriod', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.startDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstartDate>%s</%sstartDate>%s' % (namespace_, self.gds_format_date(self.startDate, input_name='startDate'), namespace_, eol_))
        if self.endDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sendDate>%s</%sendDate>%s' % (namespace_, self.gds_format_date(self.endDate, input_name='endDate'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'startDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.startDate = dval_
        elif nodeName_ == 'endDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.endDate = dval_
# end class EEPRiskPeriod


class ElectricityDelivery(GeneratedsSuper):
    """The physical delivery conditions for electricity.For EEI
    transactions, indicates that this transaction is for an "into"
    product."""
    member_data_items_ = {
        'deliveryPoint': MemberSpec_('deliveryPoint', 'ElectricityDeliveryPoint', 0),
        'deliveryType': MemberSpec_('deliveryType', 'ElectricityDeliveryType', 0),
        'transmissionContingency': MemberSpec_('transmissionContingency', 'ElectricityTransmissionContingency', 0),
        'interconnectionPoint': MemberSpec_('interconnectionPoint', 'InterconnectionPoint', 0),
        'deliveryZone': MemberSpec_('deliveryZone', 'CommodityDeliveryPoint', 0),
        'electingPartyReference': MemberSpec_('electingPartyReference', 'PartyReference', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, deliveryPoint=None, deliveryType=None, transmissionContingency=None, interconnectionPoint=None, deliveryZone=None, electingPartyReference=None):
        self.original_tagname_ = None
        self.deliveryPoint = deliveryPoint
        self.deliveryType = deliveryType
        self.transmissionContingency = transmissionContingency
        self.interconnectionPoint = interconnectionPoint
        self.deliveryZone = deliveryZone
        self.electingPartyReference = electingPartyReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricityDelivery)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricityDelivery.subclass:
            return ElectricityDelivery.subclass(*args_, **kwargs_)
        else:
            return ElectricityDelivery(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_deliveryPoint(self): return self.deliveryPoint
    def set_deliveryPoint(self, deliveryPoint): self.deliveryPoint = deliveryPoint
    def get_deliveryType(self): return self.deliveryType
    def set_deliveryType(self, deliveryType): self.deliveryType = deliveryType
    def get_transmissionContingency(self): return self.transmissionContingency
    def set_transmissionContingency(self, transmissionContingency): self.transmissionContingency = transmissionContingency
    def get_interconnectionPoint(self): return self.interconnectionPoint
    def set_interconnectionPoint(self, interconnectionPoint): self.interconnectionPoint = interconnectionPoint
    def get_deliveryZone(self): return self.deliveryZone
    def set_deliveryZone(self, deliveryZone): self.deliveryZone = deliveryZone
    def get_electingPartyReference(self): return self.electingPartyReference
    def set_electingPartyReference(self, electingPartyReference): self.electingPartyReference = electingPartyReference
    def hasContent_(self):
        if (
            self.deliveryPoint is not None or
            self.deliveryType is not None or
            self.transmissionContingency is not None or
            self.interconnectionPoint is not None or
            self.deliveryZone is not None or
            self.electingPartyReference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ElectricityDelivery', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricityDelivery')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ElectricityDelivery', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ElectricityDelivery'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ElectricityDelivery', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.deliveryPoint is not None:
            self.deliveryPoint.export(outfile, level, namespace_, name_='deliveryPoint', pretty_print=pretty_print)
        if self.deliveryType is not None:
            self.deliveryType.export(outfile, level, namespace_, name_='deliveryType', pretty_print=pretty_print)
        if self.transmissionContingency is not None:
            self.transmissionContingency.export(outfile, level, namespace_, name_='transmissionContingency', pretty_print=pretty_print)
        if self.interconnectionPoint is not None:
            self.interconnectionPoint.export(outfile, level, namespace_, name_='interconnectionPoint', pretty_print=pretty_print)
        if self.deliveryZone is not None:
            self.deliveryZone.export(outfile, level, namespace_, name_='deliveryZone', pretty_print=pretty_print)
        if self.electingPartyReference is not None:
            self.electingPartyReference.export(outfile, level, namespace_, name_='electingPartyReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'deliveryPoint':
            obj_ = ElectricityDeliveryPoint.factory()
            obj_.build(child_)
            self.deliveryPoint = obj_
            obj_.original_tagname_ = 'deliveryPoint'
        elif nodeName_ == 'deliveryType':
            obj_ = ElectricityDeliveryType.factory()
            obj_.build(child_)
            self.deliveryType = obj_
            obj_.original_tagname_ = 'deliveryType'
        elif nodeName_ == 'transmissionContingency':
            obj_ = ElectricityTransmissionContingency.factory()
            obj_.build(child_)
            self.transmissionContingency = obj_
            obj_.original_tagname_ = 'transmissionContingency'
        elif nodeName_ == 'interconnectionPoint':
            obj_ = InterconnectionPoint.factory()
            obj_.build(child_)
            self.interconnectionPoint = obj_
            obj_.original_tagname_ = 'interconnectionPoint'
        elif nodeName_ == 'deliveryZone':
            obj_ = CommodityDeliveryPoint.factory()
            obj_.build(child_)
            self.deliveryZone = obj_
            obj_.original_tagname_ = 'deliveryZone'
        elif nodeName_ == 'electingPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.electingPartyReference = obj_
            obj_.original_tagname_ = 'electingPartyReference'
# end class ElectricityDelivery


class ElectricityDeliveryFirm(GeneratedsSuper):
    """The physical delivery obligation options specific to a firm
    transaction."""
    member_data_items_ = {
        'forceMajeure': MemberSpec_('forceMajeure', 'xsd:boolean', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, forceMajeure=None):
        self.original_tagname_ = None
        self.forceMajeure = forceMajeure
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricityDeliveryFirm)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricityDeliveryFirm.subclass:
            return ElectricityDeliveryFirm.subclass(*args_, **kwargs_)
        else:
            return ElectricityDeliveryFirm(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_forceMajeure(self): return self.forceMajeure
    def set_forceMajeure(self, forceMajeure): self.forceMajeure = forceMajeure
    def hasContent_(self):
        if (
            self.forceMajeure is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ElectricityDeliveryFirm', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricityDeliveryFirm')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ElectricityDeliveryFirm', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ElectricityDeliveryFirm'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ElectricityDeliveryFirm', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.forceMajeure is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sforceMajeure>%s</%sforceMajeure>%s' % (namespace_, self.gds_format_boolean(self.forceMajeure, input_name='forceMajeure'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'forceMajeure':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'forceMajeure')
            self.forceMajeure = ival_
# end class ElectricityDeliveryFirm


class ElectricityDeliveryPoint(GeneratedsSuper):
    """A scheme identifying the types of the Delivery Point for a
    physically settled electricity trade."""
    member_data_items_ = {
        'deliveryPointScheme': MemberSpec_('deliveryPointScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, deliveryPointScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.deliveryPointScheme = _cast(None, deliveryPointScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricityDeliveryPoint)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricityDeliveryPoint.subclass:
            return ElectricityDeliveryPoint.subclass(*args_, **kwargs_)
        else:
            return ElectricityDeliveryPoint(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_deliveryPointScheme(self): return self.deliveryPointScheme
    def set_deliveryPointScheme(self, deliveryPointScheme): self.deliveryPointScheme = deliveryPointScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ElectricityDeliveryPoint', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricityDeliveryPoint')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ElectricityDeliveryPoint', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ElectricityDeliveryPoint'):
        if self.deliveryPointScheme is not None and 'deliveryPointScheme' not in already_processed:
            already_processed.add('deliveryPointScheme')
            outfile.write(' deliveryPointScheme=%s' % (quote_attrib(self.deliveryPointScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ElectricityDeliveryPoint', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('deliveryPointScheme', node)
        if value is not None and 'deliveryPointScheme' not in already_processed:
            already_processed.add('deliveryPointScheme')
            self.deliveryPointScheme = value
            self.validate_NonEmptyURI(self.deliveryPointScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ElectricityDeliveryPoint


class ElectricityDeliverySystemFirm(GeneratedsSuper):
    """The physical delivery obligation options specific to a system firm
    transaction."""
    member_data_items_ = {
        'applicable': MemberSpec_('applicable', 'xsd:boolean', 0),
        'system': MemberSpec_('system', 'CommodityDeliveryPoint', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, applicable=None, system=None):
        self.original_tagname_ = None
        self.applicable = applicable
        self.system = system
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricityDeliverySystemFirm)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricityDeliverySystemFirm.subclass:
            return ElectricityDeliverySystemFirm.subclass(*args_, **kwargs_)
        else:
            return ElectricityDeliverySystemFirm(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_applicable(self): return self.applicable
    def set_applicable(self, applicable): self.applicable = applicable
    def get_system(self): return self.system
    def set_system(self, system): self.system = system
    def hasContent_(self):
        if (
            self.applicable is not None or
            self.system is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ElectricityDeliverySystemFirm', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricityDeliverySystemFirm')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ElectricityDeliverySystemFirm', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ElectricityDeliverySystemFirm'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ElectricityDeliverySystemFirm', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.applicable is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sapplicable>%s</%sapplicable>%s' % (namespace_, self.gds_format_boolean(self.applicable, input_name='applicable'), namespace_, eol_))
        if self.system is not None:
            self.system.export(outfile, level, namespace_, name_='system', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'applicable':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'applicable')
            self.applicable = ival_
        elif nodeName_ == 'system':
            obj_ = CommodityDeliveryPoint.factory()
            obj_.build(child_)
            self.system = obj_
            obj_.original_tagname_ = 'system'
# end class ElectricityDeliverySystemFirm


class ElectricityDeliveryType(GeneratedsSuper):
    member_data_items_ = {
        'firm': MemberSpec_('firm', 'ElectricityDeliveryFirm', 0),
        'nonFirm': MemberSpec_('nonFirm', 'xsd:boolean', 0),
        'systemFirm': MemberSpec_('systemFirm', 'ElectricityDeliverySystemFirm', 0),
        'unitFirm': MemberSpec_('unitFirm', 'ElectricityDeliveryUnitFirm', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, firm=None, nonFirm=None, systemFirm=None, unitFirm=None):
        self.original_tagname_ = None
        self.firm = firm
        self.nonFirm = nonFirm
        self.systemFirm = systemFirm
        self.unitFirm = unitFirm
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricityDeliveryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricityDeliveryType.subclass:
            return ElectricityDeliveryType.subclass(*args_, **kwargs_)
        else:
            return ElectricityDeliveryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_firm(self): return self.firm
    def set_firm(self, firm): self.firm = firm
    def get_nonFirm(self): return self.nonFirm
    def set_nonFirm(self, nonFirm): self.nonFirm = nonFirm
    def get_systemFirm(self): return self.systemFirm
    def set_systemFirm(self, systemFirm): self.systemFirm = systemFirm
    def get_unitFirm(self): return self.unitFirm
    def set_unitFirm(self, unitFirm): self.unitFirm = unitFirm
    def hasContent_(self):
        if (
            self.firm is not None or
            self.nonFirm is not None or
            self.systemFirm is not None or
            self.unitFirm is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ElectricityDeliveryType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricityDeliveryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ElectricityDeliveryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ElectricityDeliveryType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ElectricityDeliveryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.firm is not None:
            self.firm.export(outfile, level, namespace_, name_='firm', pretty_print=pretty_print)
        if self.nonFirm is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snonFirm>%s</%snonFirm>%s' % (namespace_, self.gds_format_boolean(self.nonFirm, input_name='nonFirm'), namespace_, eol_))
        if self.systemFirm is not None:
            self.systemFirm.export(outfile, level, namespace_, name_='systemFirm', pretty_print=pretty_print)
        if self.unitFirm is not None:
            self.unitFirm.export(outfile, level, namespace_, name_='unitFirm', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'firm':
            obj_ = ElectricityDeliveryFirm.factory()
            obj_.build(child_)
            self.firm = obj_
            obj_.original_tagname_ = 'firm'
        elif nodeName_ == 'nonFirm':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'nonFirm')
            self.nonFirm = ival_
        elif nodeName_ == 'systemFirm':
            obj_ = ElectricityDeliverySystemFirm.factory()
            obj_.build(child_)
            self.systemFirm = obj_
            obj_.original_tagname_ = 'systemFirm'
        elif nodeName_ == 'unitFirm':
            obj_ = ElectricityDeliveryUnitFirm.factory()
            obj_.build(child_)
            self.unitFirm = obj_
            obj_.original_tagname_ = 'unitFirm'
# end class ElectricityDeliveryType


class ElectricityDeliveryUnitFirm(GeneratedsSuper):
    """The physical delivery obligation options specific to a unit firm
    transaction."""
    member_data_items_ = {
        'applicable': MemberSpec_('applicable', 'xsd:boolean', 0),
        'generationAsset': MemberSpec_('generationAsset', 'CommodityDeliveryPoint', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, applicable=None, generationAsset=None):
        self.original_tagname_ = None
        self.applicable = applicable
        self.generationAsset = generationAsset
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricityDeliveryUnitFirm)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricityDeliveryUnitFirm.subclass:
            return ElectricityDeliveryUnitFirm.subclass(*args_, **kwargs_)
        else:
            return ElectricityDeliveryUnitFirm(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_applicable(self): return self.applicable
    def set_applicable(self, applicable): self.applicable = applicable
    def get_generationAsset(self): return self.generationAsset
    def set_generationAsset(self, generationAsset): self.generationAsset = generationAsset
    def hasContent_(self):
        if (
            self.applicable is not None or
            self.generationAsset is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ElectricityDeliveryUnitFirm', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricityDeliveryUnitFirm')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ElectricityDeliveryUnitFirm', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ElectricityDeliveryUnitFirm'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ElectricityDeliveryUnitFirm', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.applicable is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sapplicable>%s</%sapplicable>%s' % (namespace_, self.gds_format_boolean(self.applicable, input_name='applicable'), namespace_, eol_))
        if self.generationAsset is not None:
            self.generationAsset.export(outfile, level, namespace_, name_='generationAsset', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'applicable':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'applicable')
            self.applicable = ival_
        elif nodeName_ == 'generationAsset':
            obj_ = CommodityDeliveryPoint.factory()
            obj_.build(child_)
            self.generationAsset = obj_
            obj_.original_tagname_ = 'generationAsset'
# end class ElectricityDeliveryUnitFirm


class ElectricityPhysicalDeliveryQuantity(CommodityNotionalQuantity):
    """A type defining the physical quantity of the electricity to be
    delivered."""
    member_data_items_ = {
        'settlementPeriodsReference': MemberSpec_('settlementPeriodsReference', 'SettlementPeriodsReference', 1),
    }
    subclass = None
    superclass = CommodityNotionalQuantity
    def __init__(self, id=None, quantityUnit=None, quantityFrequency=None, quantity=None, settlementPeriodsReference=None):
        self.original_tagname_ = None
        super(ElectricityPhysicalDeliveryQuantity, self).__init__(id, quantityUnit, quantityFrequency, quantity, )
        if settlementPeriodsReference is None:
            self.settlementPeriodsReference = []
        else:
            self.settlementPeriodsReference = settlementPeriodsReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricityPhysicalDeliveryQuantity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricityPhysicalDeliveryQuantity.subclass:
            return ElectricityPhysicalDeliveryQuantity.subclass(*args_, **kwargs_)
        else:
            return ElectricityPhysicalDeliveryQuantity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_settlementPeriodsReference(self): return self.settlementPeriodsReference
    def set_settlementPeriodsReference(self, settlementPeriodsReference): self.settlementPeriodsReference = settlementPeriodsReference
    def add_settlementPeriodsReference(self, value): self.settlementPeriodsReference.append(value)
    def insert_settlementPeriodsReference_at(self, index, value): self.settlementPeriodsReference.insert(index, value)
    def replace_settlementPeriodsReference_at(self, index, value): self.settlementPeriodsReference[index] = value
    def hasContent_(self):
        if (
            self.settlementPeriodsReference or
            super(ElectricityPhysicalDeliveryQuantity, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ElectricityPhysicalDeliveryQuantity', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricityPhysicalDeliveryQuantity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ElectricityPhysicalDeliveryQuantity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ElectricityPhysicalDeliveryQuantity'):
        super(ElectricityPhysicalDeliveryQuantity, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricityPhysicalDeliveryQuantity')
    def exportChildren(self, outfile, level, namespace_='', name_='ElectricityPhysicalDeliveryQuantity', fromsubclass_=False, pretty_print=True):
        super(ElectricityPhysicalDeliveryQuantity, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for settlementPeriodsReference_ in self.settlementPeriodsReference:
            settlementPeriodsReference_.export(outfile, level, namespace_, name_='settlementPeriodsReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ElectricityPhysicalDeliveryQuantity, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'settlementPeriodsReference':
            obj_ = SettlementPeriodsReference.factory()
            obj_.build(child_)
            self.settlementPeriodsReference.append(obj_)
            obj_.original_tagname_ = 'settlementPeriodsReference'
        super(ElectricityPhysicalDeliveryQuantity, self).buildChildren(child_, node, nodeName_, True)
# end class ElectricityPhysicalDeliveryQuantity


class ElectricityPhysicalDeliveryQuantitySchedule(CommodityPhysicalQuantitySchedule):
    """Allows the documentation of a shaped quantity trade where the
    quantity changes over the life of the transaction."""
    member_data_items_ = {
        'settlementPeriodsReference': MemberSpec_('settlementPeriodsReference', 'SettlementPeriodsReference', 1),
    }
    subclass = None
    superclass = CommodityPhysicalQuantitySchedule
    def __init__(self, id=None, quantityStep=None, deliveryPeriodsReference=None, deliveryPeriodsScheduleReference=None, settlementPeriodsReference=None):
        self.original_tagname_ = None
        super(ElectricityPhysicalDeliveryQuantitySchedule, self).__init__(id, quantityStep, deliveryPeriodsReference, deliveryPeriodsScheduleReference, )
        if settlementPeriodsReference is None:
            self.settlementPeriodsReference = []
        else:
            self.settlementPeriodsReference = settlementPeriodsReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricityPhysicalDeliveryQuantitySchedule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricityPhysicalDeliveryQuantitySchedule.subclass:
            return ElectricityPhysicalDeliveryQuantitySchedule.subclass(*args_, **kwargs_)
        else:
            return ElectricityPhysicalDeliveryQuantitySchedule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_settlementPeriodsReference(self): return self.settlementPeriodsReference
    def set_settlementPeriodsReference(self, settlementPeriodsReference): self.settlementPeriodsReference = settlementPeriodsReference
    def add_settlementPeriodsReference(self, value): self.settlementPeriodsReference.append(value)
    def insert_settlementPeriodsReference_at(self, index, value): self.settlementPeriodsReference.insert(index, value)
    def replace_settlementPeriodsReference_at(self, index, value): self.settlementPeriodsReference[index] = value
    def hasContent_(self):
        if (
            self.settlementPeriodsReference or
            super(ElectricityPhysicalDeliveryQuantitySchedule, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ElectricityPhysicalDeliveryQuantitySchedule', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricityPhysicalDeliveryQuantitySchedule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ElectricityPhysicalDeliveryQuantitySchedule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ElectricityPhysicalDeliveryQuantitySchedule'):
        super(ElectricityPhysicalDeliveryQuantitySchedule, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricityPhysicalDeliveryQuantitySchedule')
    def exportChildren(self, outfile, level, namespace_='', name_='ElectricityPhysicalDeliveryQuantitySchedule', fromsubclass_=False, pretty_print=True):
        super(ElectricityPhysicalDeliveryQuantitySchedule, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for settlementPeriodsReference_ in self.settlementPeriodsReference:
            settlementPeriodsReference_.export(outfile, level, namespace_, name_='settlementPeriodsReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ElectricityPhysicalDeliveryQuantitySchedule, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'settlementPeriodsReference':
            obj_ = SettlementPeriodsReference.factory()
            obj_.build(child_)
            self.settlementPeriodsReference.append(obj_)
            obj_.original_tagname_ = 'settlementPeriodsReference'
        super(ElectricityPhysicalDeliveryQuantitySchedule, self).buildChildren(child_, node, nodeName_, True)
# end class ElectricityPhysicalDeliveryQuantitySchedule


class ElectricityPhysicalQuantity(CommodityPhysicalQuantityBase):
    """The quantity of gas to be delivered."""
    member_data_items_ = {
        'physicalQuantity': MemberSpec_('physicalQuantity', 'ElectricityPhysicalDeliveryQuantity', 1),
        'physicalQuantitySchedule': MemberSpec_('physicalQuantitySchedule', 'ElectricityPhysicalDeliveryQuantitySchedule', 1),
        'totalPhysicalQuantity': MemberSpec_('totalPhysicalQuantity', 'UnitQuantity', 0),
    }
    subclass = None
    superclass = CommodityPhysicalQuantityBase
    def __init__(self, id=None, physicalQuantity=None, physicalQuantitySchedule=None, totalPhysicalQuantity=None):
        self.original_tagname_ = None
        super(ElectricityPhysicalQuantity, self).__init__(id, )
        if physicalQuantity is None:
            self.physicalQuantity = []
        else:
            self.physicalQuantity = physicalQuantity
        if physicalQuantitySchedule is None:
            self.physicalQuantitySchedule = []
        else:
            self.physicalQuantitySchedule = physicalQuantitySchedule
        self.totalPhysicalQuantity = totalPhysicalQuantity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricityPhysicalQuantity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricityPhysicalQuantity.subclass:
            return ElectricityPhysicalQuantity.subclass(*args_, **kwargs_)
        else:
            return ElectricityPhysicalQuantity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_physicalQuantity(self): return self.physicalQuantity
    def set_physicalQuantity(self, physicalQuantity): self.physicalQuantity = physicalQuantity
    def add_physicalQuantity(self, value): self.physicalQuantity.append(value)
    def insert_physicalQuantity_at(self, index, value): self.physicalQuantity.insert(index, value)
    def replace_physicalQuantity_at(self, index, value): self.physicalQuantity[index] = value
    def get_physicalQuantitySchedule(self): return self.physicalQuantitySchedule
    def set_physicalQuantitySchedule(self, physicalQuantitySchedule): self.physicalQuantitySchedule = physicalQuantitySchedule
    def add_physicalQuantitySchedule(self, value): self.physicalQuantitySchedule.append(value)
    def insert_physicalQuantitySchedule_at(self, index, value): self.physicalQuantitySchedule.insert(index, value)
    def replace_physicalQuantitySchedule_at(self, index, value): self.physicalQuantitySchedule[index] = value
    def get_totalPhysicalQuantity(self): return self.totalPhysicalQuantity
    def set_totalPhysicalQuantity(self, totalPhysicalQuantity): self.totalPhysicalQuantity = totalPhysicalQuantity
    def hasContent_(self):
        if (
            self.physicalQuantity or
            self.physicalQuantitySchedule or
            self.totalPhysicalQuantity is not None or
            super(ElectricityPhysicalQuantity, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ElectricityPhysicalQuantity', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricityPhysicalQuantity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ElectricityPhysicalQuantity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ElectricityPhysicalQuantity'):
        super(ElectricityPhysicalQuantity, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricityPhysicalQuantity')
    def exportChildren(self, outfile, level, namespace_='', name_='ElectricityPhysicalQuantity', fromsubclass_=False, pretty_print=True):
        super(ElectricityPhysicalQuantity, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for physicalQuantity_ in self.physicalQuantity:
            physicalQuantity_.export(outfile, level, namespace_, name_='physicalQuantity', pretty_print=pretty_print)
        for physicalQuantitySchedule_ in self.physicalQuantitySchedule:
            physicalQuantitySchedule_.export(outfile, level, namespace_, name_='physicalQuantitySchedule', pretty_print=pretty_print)
        if self.totalPhysicalQuantity is not None:
            self.totalPhysicalQuantity.export(outfile, level, namespace_, name_='totalPhysicalQuantity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ElectricityPhysicalQuantity, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'physicalQuantity':
            obj_ = ElectricityPhysicalDeliveryQuantity.factory()
            obj_.build(child_)
            self.physicalQuantity.append(obj_)
            obj_.original_tagname_ = 'physicalQuantity'
        elif nodeName_ == 'physicalQuantitySchedule':
            obj_ = ElectricityPhysicalDeliveryQuantitySchedule.factory()
            obj_.build(child_)
            self.physicalQuantitySchedule.append(obj_)
            obj_.original_tagname_ = 'physicalQuantitySchedule'
        elif nodeName_ == 'totalPhysicalQuantity':
            obj_ = UnitQuantity.factory()
            obj_.build(child_)
            self.totalPhysicalQuantity = obj_
            obj_.original_tagname_ = 'totalPhysicalQuantity'
        super(ElectricityPhysicalQuantity, self).buildChildren(child_, node, nodeName_, True)
# end class ElectricityPhysicalQuantity


class ElectricityProduct(GeneratedsSuper):
    """The specification of the electricity to be delivered."""
    member_data_items_ = {
        'type_': MemberSpec_('type_', ['ElectricityProductTypeEnum', 'Token', 'xsd:token'], 0),
        'voltage': MemberSpec_('voltage', ['PositiveDecimal', 'xsd:decimal'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, type_=None, voltage=None):
        self.original_tagname_ = None
        self.type_ = type_
        self.validate_ElectricityProductTypeEnum(self.type_)
        self.voltage = voltage
        self.validate_PositiveDecimal(self.voltage)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricityProduct)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricityProduct.subclass:
            return ElectricityProduct.subclass(*args_, **kwargs_)
        else:
            return ElectricityProduct(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_voltage(self): return self.voltage
    def set_voltage(self, voltage): self.voltage = voltage
    def validate_ElectricityProductTypeEnum(self, value):
        # Validate type ElectricityProductTypeEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Electricity']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ElectricityProductTypeEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on ElectricityProductTypeEnum' % {"value" : value} )
    def validate_PositiveDecimal(self, value):
        # Validate type PositiveDecimal, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value <= 0:
                warnings_.warn('Value "%(value)s" does not match xsd minExclusive restriction on PositiveDecimal' % {"value" : value} )
    def hasContent_(self):
        if (
            self.type_ is not None or
            self.voltage is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ElectricityProduct', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricityProduct')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ElectricityProduct', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ElectricityProduct'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ElectricityProduct', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stype>%s</%stype>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.type_), input_name='type')), namespace_, eol_))
        if self.voltage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svoltage>%s</%svoltage>%s' % (namespace_, self.gds_format_float(self.voltage, input_name='voltage'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            type_ = child_.text
            type_ = re_.sub(String_cleanup_pat_, " ", type_).strip()
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
            # validate type ElectricityProductTypeEnum
            self.validate_ElectricityProductTypeEnum(self.type_)
        elif nodeName_ == 'voltage':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'voltage')
            self.voltage = fval_
            # validate type PositiveDecimal
            self.validate_PositiveDecimal(self.voltage)
# end class ElectricityProduct


class ElectricityTransmissionContingency(GeneratedsSuper):
    """A structure to specify the tranmission contingency and the party
    that bears the obligation."""
    member_data_items_ = {
        'contingency': MemberSpec_('contingency', 'ElectricityTransmissionContingencyType', 0),
        'contingentParty': MemberSpec_('contingentParty', 'PartyReference', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, contingency=None, contingentParty=None):
        self.original_tagname_ = None
        self.contingency = contingency
        if contingentParty is None:
            self.contingentParty = []
        else:
            self.contingentParty = contingentParty
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricityTransmissionContingency)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricityTransmissionContingency.subclass:
            return ElectricityTransmissionContingency.subclass(*args_, **kwargs_)
        else:
            return ElectricityTransmissionContingency(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_contingency(self): return self.contingency
    def set_contingency(self, contingency): self.contingency = contingency
    def get_contingentParty(self): return self.contingentParty
    def set_contingentParty(self, contingentParty): self.contingentParty = contingentParty
    def add_contingentParty(self, value): self.contingentParty.append(value)
    def insert_contingentParty_at(self, index, value): self.contingentParty.insert(index, value)
    def replace_contingentParty_at(self, index, value): self.contingentParty[index] = value
    def hasContent_(self):
        if (
            self.contingency is not None or
            self.contingentParty
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ElectricityTransmissionContingency', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricityTransmissionContingency')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ElectricityTransmissionContingency', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ElectricityTransmissionContingency'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ElectricityTransmissionContingency', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.contingency is not None:
            self.contingency.export(outfile, level, namespace_, name_='contingency', pretty_print=pretty_print)
        for contingentParty_ in self.contingentParty:
            contingentParty_.export(outfile, level, namespace_, name_='contingentParty', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'contingency':
            obj_ = ElectricityTransmissionContingencyType.factory()
            obj_.build(child_)
            self.contingency = obj_
            obj_.original_tagname_ = 'contingency'
        elif nodeName_ == 'contingentParty':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.contingentParty.append(obj_)
            obj_.original_tagname_ = 'contingentParty'
# end class ElectricityTransmissionContingency


class ElectricityTransmissionContingencyType(GeneratedsSuper):
    """The type of transmission contingency, i.e. what portion of the
    transmission the delivery obligations are applicable."""
    member_data_items_ = {
        'electricityTransmissionContingencyScheme': MemberSpec_('electricityTransmissionContingencyScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, electricityTransmissionContingencyScheme='http://www.fpml.org/coding-scheme/electricity-transmission-contingency', valueOf_=None):
        self.original_tagname_ = None
        self.electricityTransmissionContingencyScheme = _cast(None, electricityTransmissionContingencyScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricityTransmissionContingencyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricityTransmissionContingencyType.subclass:
            return ElectricityTransmissionContingencyType.subclass(*args_, **kwargs_)
        else:
            return ElectricityTransmissionContingencyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_electricityTransmissionContingencyScheme(self): return self.electricityTransmissionContingencyScheme
    def set_electricityTransmissionContingencyScheme(self, electricityTransmissionContingencyScheme): self.electricityTransmissionContingencyScheme = electricityTransmissionContingencyScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ElectricityTransmissionContingencyType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricityTransmissionContingencyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ElectricityTransmissionContingencyType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ElectricityTransmissionContingencyType'):
        if self.electricityTransmissionContingencyScheme != "http://www.fpml.org/coding-scheme/electricity-transmission-contingency" and 'electricityTransmissionContingencyScheme' not in already_processed:
            already_processed.add('electricityTransmissionContingencyScheme')
            outfile.write(' electricityTransmissionContingencyScheme=%s' % (quote_attrib(self.electricityTransmissionContingencyScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ElectricityTransmissionContingencyType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('electricityTransmissionContingencyScheme', node)
        if value is not None and 'electricityTransmissionContingencyScheme' not in already_processed:
            already_processed.add('electricityTransmissionContingencyScheme')
            self.electricityTransmissionContingencyScheme = value
            self.validate_NonEmptyURI(self.electricityTransmissionContingencyScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ElectricityTransmissionContingencyType


class EnvironmentalProduct(GeneratedsSuper):
    """A type defining the characteristics of the environmental allowance
    or credit being traded. Settlement of environmental transactions
    is classified as physical because settlement is accomplished
    through the exchange of one or more certificates (despite the
    fact that this exchange is almost always executed through
    electronic book entry transfer between the parties allowance
    accounts)."""
    member_data_items_ = {
        'productType': MemberSpec_('productType', ['EnvironmentalProductTypeEnum', 'Token', 'xsd:token'], 0),
        'compliancePeriod': MemberSpec_('compliancePeriod', 'EnvironmentalProductComplaincePeriod', 0),
        'vintage': MemberSpec_('vintage', 'xsd:gYear', 1),
        'applicableLaw': MemberSpec_('applicableLaw', 'EnvironmentalProductApplicableLaw', 0),
        'trackingSystem': MemberSpec_('trackingSystem', 'EnvironmentalTrackingSystem', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, productType=None, compliancePeriod=None, vintage=None, applicableLaw=None, trackingSystem=None):
        self.original_tagname_ = None
        self.productType = productType
        self.validate_EnvironmentalProductTypeEnum(self.productType)
        self.compliancePeriod = compliancePeriod
        if vintage is None:
            self.vintage = []
        else:
            self.vintage = vintage
        self.applicableLaw = applicableLaw
        self.trackingSystem = trackingSystem
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnvironmentalProduct)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnvironmentalProduct.subclass:
            return EnvironmentalProduct.subclass(*args_, **kwargs_)
        else:
            return EnvironmentalProduct(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_productType(self): return self.productType
    def set_productType(self, productType): self.productType = productType
    def get_compliancePeriod(self): return self.compliancePeriod
    def set_compliancePeriod(self, compliancePeriod): self.compliancePeriod = compliancePeriod
    def get_vintage(self): return self.vintage
    def set_vintage(self, vintage): self.vintage = vintage
    def add_vintage(self, value): self.vintage.append(value)
    def insert_vintage_at(self, index, value): self.vintage.insert(index, value)
    def replace_vintage_at(self, index, value): self.vintage[index] = value
    def get_applicableLaw(self): return self.applicableLaw
    def set_applicableLaw(self, applicableLaw): self.applicableLaw = applicableLaw
    def get_trackingSystem(self): return self.trackingSystem
    def set_trackingSystem(self, trackingSystem): self.trackingSystem = trackingSystem
    def validate_EnvironmentalProductTypeEnum(self, value):
        # Validate type EnvironmentalProductTypeEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['EUAllowance', 'EUCredit', 'AlternativeAllowance', 'NOXEmissionsProduct', 'RegionalEmissionsProduct', 'RGGIEmissionsProduct', 'SO2EmissionsProduct', 'StateEmissionProduct', 'VoluntaryEmissionProduct', 'RenewableEnergyCertificate', 'AUSCarbonCreditUnit', 'AUSCarbonUnit', 'AUSEnergySavingCertificate', 'AUSLargeScaleGenerationCertificate', 'AUSSmallScaleTechnologyCertificate', 'AUSVictorianEnergyEfficiencyCertificate', 'MXCCFECRTINTLODS', 'NZEmissionsUnits', 'UKRenewableObligationCertificate']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on EnvironmentalProductTypeEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on EnvironmentalProductTypeEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.productType is not None or
            self.compliancePeriod is not None or
            self.vintage or
            self.applicableLaw is not None or
            self.trackingSystem is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EnvironmentalProduct', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnvironmentalProduct')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EnvironmentalProduct', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EnvironmentalProduct'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EnvironmentalProduct', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.productType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sproductType>%s</%sproductType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.productType), input_name='productType')), namespace_, eol_))
        if self.compliancePeriod is not None:
            self.compliancePeriod.export(outfile, level, namespace_, name_='compliancePeriod', pretty_print=pretty_print)
        for vintage_ in self.vintage:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svintage>%s</%svintage>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(vintage_), input_name='vintage')), namespace_, eol_))
        if self.applicableLaw is not None:
            self.applicableLaw.export(outfile, level, namespace_, name_='applicableLaw', pretty_print=pretty_print)
        if self.trackingSystem is not None:
            self.trackingSystem.export(outfile, level, namespace_, name_='trackingSystem', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'productType':
            productType_ = child_.text
            productType_ = re_.sub(String_cleanup_pat_, " ", productType_).strip()
            productType_ = self.gds_validate_string(productType_, node, 'productType')
            self.productType = productType_
            # validate type EnvironmentalProductTypeEnum
            self.validate_EnvironmentalProductTypeEnum(self.productType)
        elif nodeName_ == 'compliancePeriod':
            obj_ = EnvironmentalProductComplaincePeriod.factory()
            obj_.build(child_)
            self.compliancePeriod = obj_
            obj_.original_tagname_ = 'compliancePeriod'
        elif nodeName_ == 'vintage':
            vintage_ = child_.text
            vintage_ = self.gds_validate_string(vintage_, node, 'vintage')
            self.vintage.append(vintage_)
        elif nodeName_ == 'applicableLaw':
            obj_ = EnvironmentalProductApplicableLaw.factory()
            obj_.build(child_)
            self.applicableLaw = obj_
            obj_.original_tagname_ = 'applicableLaw'
        elif nodeName_ == 'trackingSystem':
            obj_ = EnvironmentalTrackingSystem.factory()
            obj_.build(child_)
            self.trackingSystem = obj_
            obj_.original_tagname_ = 'trackingSystem'
# end class EnvironmentalProduct


class EnvironmentalProductApplicableLaw(GeneratedsSuper):
    """TBD."""
    member_data_items_ = {
        'environmentalProductApplicableLawScheme': MemberSpec_('environmentalProductApplicableLawScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, environmentalProductApplicableLawScheme='http://www.fpml.org/coding-scheme/governing-law', valueOf_=None):
        self.original_tagname_ = None
        self.environmentalProductApplicableLawScheme = _cast(None, environmentalProductApplicableLawScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnvironmentalProductApplicableLaw)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnvironmentalProductApplicableLaw.subclass:
            return EnvironmentalProductApplicableLaw.subclass(*args_, **kwargs_)
        else:
            return EnvironmentalProductApplicableLaw(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_environmentalProductApplicableLawScheme(self): return self.environmentalProductApplicableLawScheme
    def set_environmentalProductApplicableLawScheme(self, environmentalProductApplicableLawScheme): self.environmentalProductApplicableLawScheme = environmentalProductApplicableLawScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EnvironmentalProductApplicableLaw', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnvironmentalProductApplicableLaw')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EnvironmentalProductApplicableLaw', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EnvironmentalProductApplicableLaw'):
        if self.environmentalProductApplicableLawScheme != "http://www.fpml.org/coding-scheme/governing-law" and 'environmentalProductApplicableLawScheme' not in already_processed:
            already_processed.add('environmentalProductApplicableLawScheme')
            outfile.write(' environmentalProductApplicableLawScheme=%s' % (quote_attrib(self.environmentalProductApplicableLawScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EnvironmentalProductApplicableLaw', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('environmentalProductApplicableLawScheme', node)
        if value is not None and 'environmentalProductApplicableLawScheme' not in already_processed:
            already_processed.add('environmentalProductApplicableLawScheme')
            self.environmentalProductApplicableLawScheme = value
            self.validate_NonEmptyURI(self.environmentalProductApplicableLawScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EnvironmentalProductApplicableLaw


class EnvironmentalProductComplaincePeriod(GeneratedsSuper):
    member_data_items_ = {
        'startYear': MemberSpec_('startYear', 'xsd:gYear', 0),
        'endYear': MemberSpec_('endYear', 'xsd:gYear', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, startYear=None, endYear=None):
        self.original_tagname_ = None
        self.startYear = startYear
        self.endYear = endYear
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnvironmentalProductComplaincePeriod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnvironmentalProductComplaincePeriod.subclass:
            return EnvironmentalProductComplaincePeriod.subclass(*args_, **kwargs_)
        else:
            return EnvironmentalProductComplaincePeriod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_startYear(self): return self.startYear
    def set_startYear(self, startYear): self.startYear = startYear
    def get_endYear(self): return self.endYear
    def set_endYear(self, endYear): self.endYear = endYear
    def hasContent_(self):
        if (
            self.startYear is not None or
            self.endYear is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EnvironmentalProductComplaincePeriod', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnvironmentalProductComplaincePeriod')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EnvironmentalProductComplaincePeriod', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EnvironmentalProductComplaincePeriod'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EnvironmentalProductComplaincePeriod', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.startYear is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstartYear>%s</%sstartYear>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.startYear), input_name='startYear')), namespace_, eol_))
        if self.endYear is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sendYear>%s</%sendYear>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.endYear), input_name='endYear')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'startYear':
            startYear_ = child_.text
            startYear_ = self.gds_validate_string(startYear_, node, 'startYear')
            self.startYear = startYear_
        elif nodeName_ == 'endYear':
            endYear_ = child_.text
            endYear_ = self.gds_validate_string(endYear_, node, 'endYear')
            self.endYear = endYear_
# end class EnvironmentalProductComplaincePeriod


class EnvironmentalTrackingSystem(GeneratedsSuper):
    """For US Emissions Allowance Transactions. A system where all
    electronic certificates are stored and emissions are tracked."""
    member_data_items_ = {
        'commodityEnvironmentalTrackingSystemScheme': MemberSpec_('commodityEnvironmentalTrackingSystemScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, commodityEnvironmentalTrackingSystemScheme='http://www.fpml.org/coding-scheme/commodity-environmental-tracking-system', valueOf_=None):
        self.original_tagname_ = None
        self.commodityEnvironmentalTrackingSystemScheme = _cast(None, commodityEnvironmentalTrackingSystemScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnvironmentalTrackingSystem)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnvironmentalTrackingSystem.subclass:
            return EnvironmentalTrackingSystem.subclass(*args_, **kwargs_)
        else:
            return EnvironmentalTrackingSystem(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commodityEnvironmentalTrackingSystemScheme(self): return self.commodityEnvironmentalTrackingSystemScheme
    def set_commodityEnvironmentalTrackingSystemScheme(self, commodityEnvironmentalTrackingSystemScheme): self.commodityEnvironmentalTrackingSystemScheme = commodityEnvironmentalTrackingSystemScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EnvironmentalTrackingSystem', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnvironmentalTrackingSystem')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EnvironmentalTrackingSystem', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EnvironmentalTrackingSystem'):
        if self.commodityEnvironmentalTrackingSystemScheme != "http://www.fpml.org/coding-scheme/commodity-environmental-tracking-system" and 'commodityEnvironmentalTrackingSystemScheme' not in already_processed:
            already_processed.add('commodityEnvironmentalTrackingSystemScheme')
            outfile.write(' commodityEnvironmentalTrackingSystemScheme=%s' % (quote_attrib(self.commodityEnvironmentalTrackingSystemScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EnvironmentalTrackingSystem', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('commodityEnvironmentalTrackingSystemScheme', node)
        if value is not None and 'commodityEnvironmentalTrackingSystemScheme' not in already_processed:
            already_processed.add('commodityEnvironmentalTrackingSystemScheme')
            self.commodityEnvironmentalTrackingSystemScheme = value
            self.validate_NonEmptyURI(self.commodityEnvironmentalTrackingSystemScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EnvironmentalTrackingSystem


class FixedPrice(GeneratedsSuper):
    """A type defining the Fixed Price."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'price': MemberSpec_('price', 'xsd:decimal', 0),
        'priceCurrency': MemberSpec_('priceCurrency', 'Currency', 0),
        'priceUnit': MemberSpec_('priceUnit', 'QuantityUnit', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, price=None, priceCurrency=None, priceUnit=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.price = price
        self.priceCurrency = priceCurrency
        self.priceUnit = priceUnit
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FixedPrice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FixedPrice.subclass:
            return FixedPrice.subclass(*args_, **kwargs_)
        else:
            return FixedPrice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_price(self): return self.price
    def set_price(self, price): self.price = price
    def get_priceCurrency(self): return self.priceCurrency
    def set_priceCurrency(self, priceCurrency): self.priceCurrency = priceCurrency
    def get_priceUnit(self): return self.priceUnit
    def set_priceUnit(self, priceUnit): self.priceUnit = priceUnit
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.price is not None or
            self.priceCurrency is not None or
            self.priceUnit is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FixedPrice', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FixedPrice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FixedPrice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FixedPrice'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='FixedPrice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.price is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprice>%s</%sprice>%s' % (namespace_, self.gds_format_float(self.price, input_name='price'), namespace_, eol_))
        if self.priceCurrency is not None:
            self.priceCurrency.export(outfile, level, namespace_, name_='priceCurrency', pretty_print=pretty_print)
        if self.priceUnit is not None:
            self.priceUnit.export(outfile, level, namespace_, name_='priceUnit', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'price':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'price')
            self.price = fval_
        elif nodeName_ == 'priceCurrency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.priceCurrency = obj_
            obj_.original_tagname_ = 'priceCurrency'
        elif nodeName_ == 'priceUnit':
            obj_ = QuantityUnit.factory()
            obj_.build(child_)
            self.priceUnit = obj_
            obj_.original_tagname_ = 'priceUnit'
# end class FixedPrice


class FloatingLegCalculation(GeneratedsSuper):
    """A type to capture details relevant to the calculation of the
    floating price."""
    member_data_items_ = {
        'pricingDates': MemberSpec_('pricingDates', 'CommodityPricingDates', 0),
        'averagingMethod': MemberSpec_('averagingMethod', ['AveragingMethodEnum', 'Token', 'xsd:token'], 0),
        'conversionFactor': MemberSpec_('conversionFactor', 'xsd:decimal', 0),
        'rounding': MemberSpec_('rounding', 'Rounding', 0),
        'spread': MemberSpec_('spread', 'CommoditySpread', 0),
        'spreadSchedule': MemberSpec_('spreadSchedule', 'CommoditySpreadSchedule', 1),
        'spreadPercentage': MemberSpec_('spreadPercentage', 'xsd:decimal', 0),
        'fx': MemberSpec_('fx', 'FxRateAsset', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, pricingDates=None, averagingMethod=None, conversionFactor=None, rounding=None, spread=None, spreadSchedule=None, spreadPercentage=None, fx=None, extensiontype_=None):
        self.original_tagname_ = None
        self.pricingDates = pricingDates
        self.averagingMethod = averagingMethod
        self.validate_AveragingMethodEnum(self.averagingMethod)
        self.conversionFactor = conversionFactor
        self.rounding = rounding
        self.spread = spread
        if spreadSchedule is None:
            self.spreadSchedule = []
        else:
            self.spreadSchedule = spreadSchedule
        self.spreadPercentage = spreadPercentage
        self.fx = fx
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FloatingLegCalculation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FloatingLegCalculation.subclass:
            return FloatingLegCalculation.subclass(*args_, **kwargs_)
        else:
            return FloatingLegCalculation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pricingDates(self): return self.pricingDates
    def set_pricingDates(self, pricingDates): self.pricingDates = pricingDates
    def get_averagingMethod(self): return self.averagingMethod
    def set_averagingMethod(self, averagingMethod): self.averagingMethod = averagingMethod
    def get_conversionFactor(self): return self.conversionFactor
    def set_conversionFactor(self, conversionFactor): self.conversionFactor = conversionFactor
    def get_rounding(self): return self.rounding
    def set_rounding(self, rounding): self.rounding = rounding
    def get_spread(self): return self.spread
    def set_spread(self, spread): self.spread = spread
    def get_spreadSchedule(self): return self.spreadSchedule
    def set_spreadSchedule(self, spreadSchedule): self.spreadSchedule = spreadSchedule
    def add_spreadSchedule(self, value): self.spreadSchedule.append(value)
    def insert_spreadSchedule_at(self, index, value): self.spreadSchedule.insert(index, value)
    def replace_spreadSchedule_at(self, index, value): self.spreadSchedule[index] = value
    def get_spreadPercentage(self): return self.spreadPercentage
    def set_spreadPercentage(self, spreadPercentage): self.spreadPercentage = spreadPercentage
    def get_fx(self): return self.fx
    def set_fx(self, fx): self.fx = fx
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_AveragingMethodEnum(self, value):
        # Validate type AveragingMethodEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Unweighted', 'Weighted']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AveragingMethodEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on AveragingMethodEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.pricingDates is not None or
            self.averagingMethod is not None or
            self.conversionFactor is not None or
            self.rounding is not None or
            self.spread is not None or
            self.spreadSchedule or
            self.spreadPercentage is not None or
            self.fx is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FloatingLegCalculation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FloatingLegCalculation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FloatingLegCalculation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FloatingLegCalculation'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FloatingLegCalculation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.pricingDates is not None:
            self.pricingDates.export(outfile, level, namespace_, name_='pricingDates', pretty_print=pretty_print)
        if self.averagingMethod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saveragingMethod>%s</%saveragingMethod>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.averagingMethod), input_name='averagingMethod')), namespace_, eol_))
        if self.conversionFactor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sconversionFactor>%s</%sconversionFactor>%s' % (namespace_, self.gds_format_float(self.conversionFactor, input_name='conversionFactor'), namespace_, eol_))
        if self.rounding is not None:
            self.rounding.export(outfile, level, namespace_, name_='rounding', pretty_print=pretty_print)
        if self.spread is not None:
            self.spread.export(outfile, level, namespace_, name_='spread', pretty_print=pretty_print)
        for spreadSchedule_ in self.spreadSchedule:
            spreadSchedule_.export(outfile, level, namespace_, name_='spreadSchedule', pretty_print=pretty_print)
        if self.spreadPercentage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sspreadPercentage>%s</%sspreadPercentage>%s' % (namespace_, self.gds_format_float(self.spreadPercentage, input_name='spreadPercentage'), namespace_, eol_))
        if self.fx is not None:
            self.fx.export(outfile, level, namespace_, name_='fx', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pricingDates':
            obj_ = CommodityPricingDates.factory()
            obj_.build(child_)
            self.pricingDates = obj_
            obj_.original_tagname_ = 'pricingDates'
        elif nodeName_ == 'averagingMethod':
            averagingMethod_ = child_.text
            averagingMethod_ = re_.sub(String_cleanup_pat_, " ", averagingMethod_).strip()
            averagingMethod_ = self.gds_validate_string(averagingMethod_, node, 'averagingMethod')
            self.averagingMethod = averagingMethod_
            # validate type AveragingMethodEnum
            self.validate_AveragingMethodEnum(self.averagingMethod)
        elif nodeName_ == 'conversionFactor':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'conversionFactor')
            self.conversionFactor = fval_
        elif nodeName_ == 'rounding':
            obj_ = Rounding.factory()
            obj_.build(child_)
            self.rounding = obj_
            obj_.original_tagname_ = 'rounding'
        elif nodeName_ == 'spread':
            obj_ = CommoditySpread.factory()
            obj_.build(child_)
            self.spread = obj_
            obj_.original_tagname_ = 'spread'
        elif nodeName_ == 'spreadSchedule':
            obj_ = CommoditySpreadSchedule.factory()
            obj_.build(child_)
            self.spreadSchedule.append(obj_)
            obj_.original_tagname_ = 'spreadSchedule'
        elif nodeName_ == 'spreadPercentage':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'spreadPercentage')
            self.spreadPercentage = fval_
        elif nodeName_ == 'fx':
            obj_ = CommodityFx.factory()
            obj_.build(child_)
            self.fx = obj_
            obj_.original_tagname_ = 'fx'
# end class FloatingLegCalculation


class FloatingStrikePrice(FloatingLegCalculation):
    member_data_items_ = {
        'commodity': MemberSpec_('commodity', 'Commodity', 0),
    }
    subclass = None
    superclass = FloatingLegCalculation
    def __init__(self, pricingDates=None, averagingMethod=None, conversionFactor=None, rounding=None, spread=None, spreadSchedule=None, spreadPercentage=None, fx=None, commodity=None):
        self.original_tagname_ = None
        super(FloatingStrikePrice, self).__init__(pricingDates, averagingMethod, conversionFactor, rounding, spread, spreadSchedule, spreadPercentage, fx, )
        self.commodity = commodity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FloatingStrikePrice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FloatingStrikePrice.subclass:
            return FloatingStrikePrice.subclass(*args_, **kwargs_)
        else:
            return FloatingStrikePrice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commodity(self): return self.commodity
    def set_commodity(self, commodity): self.commodity = commodity
    def hasContent_(self):
        if (
            self.commodity is not None or
            super(FloatingStrikePrice, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FloatingStrikePrice', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FloatingStrikePrice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FloatingStrikePrice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FloatingStrikePrice'):
        super(FloatingStrikePrice, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FloatingStrikePrice')
    def exportChildren(self, outfile, level, namespace_='', name_='FloatingStrikePrice', fromsubclass_=False, pretty_print=True):
        super(FloatingStrikePrice, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.commodity is not None:
            self.commodity.export(outfile, level, namespace_, name_='commodity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FloatingStrikePrice, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'commodity':
            obj_ = Commodity.factory()
            obj_.build(child_)
            self.commodity = obj_
            obj_.original_tagname_ = 'commodity'
        super(FloatingStrikePrice, self).buildChildren(child_, node, nodeName_, True)
# end class FloatingStrikePrice


class GasDelivery(GeneratedsSuper):
    """The specification of the gas to be delivered."""
    member_data_items_ = {
        'deliveryPoint': MemberSpec_('deliveryPoint', 'GasDeliveryPoint', 0),
        'entryPoint': MemberSpec_('entryPoint', 'CommodityDeliveryPoint', 0),
        'withdrawalPoint': MemberSpec_('withdrawalPoint', 'CommodityDeliveryPoint', 0),
        'deliveryType': MemberSpec_('deliveryType', ['DeliveryTypeEnum', 'Token', 'xsd:token'], 0),
        'interconnectionPoint': MemberSpec_('interconnectionPoint', 'InterconnectionPoint', 0),
        'buyerHub': MemberSpec_('buyerHub', 'CommodityHub', 0),
        'sellerHub': MemberSpec_('sellerHub', 'CommodityHub', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, deliveryPoint=None, entryPoint=None, withdrawalPoint=None, deliveryType=None, interconnectionPoint=None, buyerHub=None, sellerHub=None):
        self.original_tagname_ = None
        self.deliveryPoint = deliveryPoint
        self.entryPoint = entryPoint
        self.withdrawalPoint = withdrawalPoint
        self.deliveryType = deliveryType
        self.validate_DeliveryTypeEnum(self.deliveryType)
        self.interconnectionPoint = interconnectionPoint
        self.buyerHub = buyerHub
        self.sellerHub = sellerHub
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GasDelivery)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GasDelivery.subclass:
            return GasDelivery.subclass(*args_, **kwargs_)
        else:
            return GasDelivery(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_deliveryPoint(self): return self.deliveryPoint
    def set_deliveryPoint(self, deliveryPoint): self.deliveryPoint = deliveryPoint
    def get_entryPoint(self): return self.entryPoint
    def set_entryPoint(self, entryPoint): self.entryPoint = entryPoint
    def get_withdrawalPoint(self): return self.withdrawalPoint
    def set_withdrawalPoint(self, withdrawalPoint): self.withdrawalPoint = withdrawalPoint
    def get_deliveryType(self): return self.deliveryType
    def set_deliveryType(self, deliveryType): self.deliveryType = deliveryType
    def get_interconnectionPoint(self): return self.interconnectionPoint
    def set_interconnectionPoint(self, interconnectionPoint): self.interconnectionPoint = interconnectionPoint
    def get_buyerHub(self): return self.buyerHub
    def set_buyerHub(self, buyerHub): self.buyerHub = buyerHub
    def get_sellerHub(self): return self.sellerHub
    def set_sellerHub(self, sellerHub): self.sellerHub = sellerHub
    def validate_DeliveryTypeEnum(self, value):
        # Validate type DeliveryTypeEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Firm', 'Interruptible']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeliveryTypeEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on DeliveryTypeEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.deliveryPoint is not None or
            self.entryPoint is not None or
            self.withdrawalPoint is not None or
            self.deliveryType is not None or
            self.interconnectionPoint is not None or
            self.buyerHub is not None or
            self.sellerHub is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GasDelivery', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GasDelivery')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GasDelivery', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GasDelivery'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GasDelivery', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.deliveryPoint is not None:
            self.deliveryPoint.export(outfile, level, namespace_, name_='deliveryPoint', pretty_print=pretty_print)
        if self.entryPoint is not None:
            self.entryPoint.export(outfile, level, namespace_, name_='entryPoint', pretty_print=pretty_print)
        if self.withdrawalPoint is not None:
            self.withdrawalPoint.export(outfile, level, namespace_, name_='withdrawalPoint', pretty_print=pretty_print)
        if self.deliveryType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdeliveryType>%s</%sdeliveryType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.deliveryType), input_name='deliveryType')), namespace_, eol_))
        if self.interconnectionPoint is not None:
            self.interconnectionPoint.export(outfile, level, namespace_, name_='interconnectionPoint', pretty_print=pretty_print)
        if self.buyerHub is not None:
            self.buyerHub.export(outfile, level, namespace_, name_='buyerHub', pretty_print=pretty_print)
        if self.sellerHub is not None:
            self.sellerHub.export(outfile, level, namespace_, name_='sellerHub', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'deliveryPoint':
            obj_ = GasDeliveryPoint.factory()
            obj_.build(child_)
            self.deliveryPoint = obj_
            obj_.original_tagname_ = 'deliveryPoint'
        elif nodeName_ == 'entryPoint':
            obj_ = CommodityDeliveryPoint.factory()
            obj_.build(child_)
            self.entryPoint = obj_
            obj_.original_tagname_ = 'entryPoint'
        elif nodeName_ == 'withdrawalPoint':
            obj_ = CommodityDeliveryPoint.factory()
            obj_.build(child_)
            self.withdrawalPoint = obj_
            obj_.original_tagname_ = 'withdrawalPoint'
        elif nodeName_ == 'deliveryType':
            deliveryType_ = child_.text
            deliveryType_ = re_.sub(String_cleanup_pat_, " ", deliveryType_).strip()
            deliveryType_ = self.gds_validate_string(deliveryType_, node, 'deliveryType')
            self.deliveryType = deliveryType_
            # validate type DeliveryTypeEnum
            self.validate_DeliveryTypeEnum(self.deliveryType)
        elif nodeName_ == 'interconnectionPoint':
            obj_ = InterconnectionPoint.factory()
            obj_.build(child_)
            self.interconnectionPoint = obj_
            obj_.original_tagname_ = 'interconnectionPoint'
        elif nodeName_ == 'buyerHub':
            obj_ = CommodityHub.factory()
            obj_.build(child_)
            self.buyerHub = obj_
            obj_.original_tagname_ = 'buyerHub'
        elif nodeName_ == 'sellerHub':
            obj_ = CommodityHub.factory()
            obj_.build(child_)
            self.sellerHub = obj_
            obj_.original_tagname_ = 'sellerHub'
# end class GasDelivery


class GasDeliveryPeriods(CommodityDeliveryPeriods):
    """The different options for specifying the Delivery Periods for a
    physically settled gas trade."""
    member_data_items_ = {
        'supplyStartTime': MemberSpec_('supplyStartTime', 'PrevailingTime', 0),
        'supplyEndTime': MemberSpec_('supplyEndTime', 'PrevailingTime', 0),
    }
    subclass = None
    superclass = CommodityDeliveryPeriods
    def __init__(self, id=None, periods=None, periodsSchedule=None, calculationPeriodsReference=None, calculationPeriodsScheduleReference=None, calculationPeriodsDatesReference=None, supplyStartTime=None, supplyEndTime=None):
        self.original_tagname_ = None
        super(GasDeliveryPeriods, self).__init__(id, periods, periodsSchedule, calculationPeriodsReference, calculationPeriodsScheduleReference, calculationPeriodsDatesReference, )
        self.supplyStartTime = supplyStartTime
        self.supplyEndTime = supplyEndTime
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GasDeliveryPeriods)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GasDeliveryPeriods.subclass:
            return GasDeliveryPeriods.subclass(*args_, **kwargs_)
        else:
            return GasDeliveryPeriods(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_supplyStartTime(self): return self.supplyStartTime
    def set_supplyStartTime(self, supplyStartTime): self.supplyStartTime = supplyStartTime
    def get_supplyEndTime(self): return self.supplyEndTime
    def set_supplyEndTime(self, supplyEndTime): self.supplyEndTime = supplyEndTime
    def hasContent_(self):
        if (
            self.supplyStartTime is not None or
            self.supplyEndTime is not None or
            super(GasDeliveryPeriods, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GasDeliveryPeriods', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GasDeliveryPeriods')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GasDeliveryPeriods', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GasDeliveryPeriods'):
        super(GasDeliveryPeriods, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GasDeliveryPeriods')
    def exportChildren(self, outfile, level, namespace_='', name_='GasDeliveryPeriods', fromsubclass_=False, pretty_print=True):
        super(GasDeliveryPeriods, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.supplyStartTime is not None:
            self.supplyStartTime.export(outfile, level, namespace_, name_='supplyStartTime', pretty_print=pretty_print)
        if self.supplyEndTime is not None:
            self.supplyEndTime.export(outfile, level, namespace_, name_='supplyEndTime', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GasDeliveryPeriods, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'supplyStartTime':
            obj_ = PrevailingTime.factory()
            obj_.build(child_)
            self.supplyStartTime = obj_
            obj_.original_tagname_ = 'supplyStartTime'
        elif nodeName_ == 'supplyEndTime':
            obj_ = PrevailingTime.factory()
            obj_.build(child_)
            self.supplyEndTime = obj_
            obj_.original_tagname_ = 'supplyEndTime'
        super(GasDeliveryPeriods, self).buildChildren(child_, node, nodeName_, True)
# end class GasDeliveryPeriods


class GasDeliveryPoint(GeneratedsSuper):
    """A scheme identifying the types of the Delivery Point for a
    physically settled gas trade."""
    member_data_items_ = {
        'deliveryPointScheme': MemberSpec_('deliveryPointScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, deliveryPointScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.deliveryPointScheme = _cast(None, deliveryPointScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GasDeliveryPoint)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GasDeliveryPoint.subclass:
            return GasDeliveryPoint.subclass(*args_, **kwargs_)
        else:
            return GasDeliveryPoint(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_deliveryPointScheme(self): return self.deliveryPointScheme
    def set_deliveryPointScheme(self, deliveryPointScheme): self.deliveryPointScheme = deliveryPointScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GasDeliveryPoint', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GasDeliveryPoint')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GasDeliveryPoint', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GasDeliveryPoint'):
        if self.deliveryPointScheme is not None and 'deliveryPointScheme' not in already_processed:
            already_processed.add('deliveryPointScheme')
            outfile.write(' deliveryPointScheme=%s' % (quote_attrib(self.deliveryPointScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='GasDeliveryPoint', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('deliveryPointScheme', node)
        if value is not None and 'deliveryPointScheme' not in already_processed:
            already_processed.add('deliveryPointScheme')
            self.deliveryPointScheme = value
            self.validate_NonEmptyURI(self.deliveryPointScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class GasDeliveryPoint


class GasPhysicalQuantity(CommodityPhysicalQuantityBase):
    """The quantity of gas to be delivered.A quantity that can vary within
    set limits at the instruction of the specified party."""
    member_data_items_ = {
        'physicalQuantity': MemberSpec_('physicalQuantity', 'CommodityNotionalQuantity', 0),
        'physicalQuantitySchedule': MemberSpec_('physicalQuantitySchedule', 'CommodityPhysicalQuantitySchedule', 0),
        'totalPhysicalQuantity': MemberSpec_('totalPhysicalQuantity', 'UnitQuantity', 0),
        'minPhysicalQuantity': MemberSpec_('minPhysicalQuantity', 'CommodityNotionalQuantity', 1),
        'maxPhysicalQuantity': MemberSpec_('maxPhysicalQuantity', 'CommodityNotionalQuantity', 1),
        'electingParty': MemberSpec_('electingParty', 'PartyReference', 0),
    }
    subclass = None
    superclass = CommodityPhysicalQuantityBase
    def __init__(self, id=None, physicalQuantity=None, physicalQuantitySchedule=None, totalPhysicalQuantity=None, minPhysicalQuantity=None, maxPhysicalQuantity=None, electingParty=None):
        self.original_tagname_ = None
        super(GasPhysicalQuantity, self).__init__(id, )
        self.physicalQuantity = physicalQuantity
        self.physicalQuantitySchedule = physicalQuantitySchedule
        self.totalPhysicalQuantity = totalPhysicalQuantity
        if minPhysicalQuantity is None:
            self.minPhysicalQuantity = []
        else:
            self.minPhysicalQuantity = minPhysicalQuantity
        if maxPhysicalQuantity is None:
            self.maxPhysicalQuantity = []
        else:
            self.maxPhysicalQuantity = maxPhysicalQuantity
        self.electingParty = electingParty
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GasPhysicalQuantity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GasPhysicalQuantity.subclass:
            return GasPhysicalQuantity.subclass(*args_, **kwargs_)
        else:
            return GasPhysicalQuantity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_physicalQuantity(self): return self.physicalQuantity
    def set_physicalQuantity(self, physicalQuantity): self.physicalQuantity = physicalQuantity
    def get_physicalQuantitySchedule(self): return self.physicalQuantitySchedule
    def set_physicalQuantitySchedule(self, physicalQuantitySchedule): self.physicalQuantitySchedule = physicalQuantitySchedule
    def get_totalPhysicalQuantity(self): return self.totalPhysicalQuantity
    def set_totalPhysicalQuantity(self, totalPhysicalQuantity): self.totalPhysicalQuantity = totalPhysicalQuantity
    def get_minPhysicalQuantity(self): return self.minPhysicalQuantity
    def set_minPhysicalQuantity(self, minPhysicalQuantity): self.minPhysicalQuantity = minPhysicalQuantity
    def add_minPhysicalQuantity(self, value): self.minPhysicalQuantity.append(value)
    def insert_minPhysicalQuantity_at(self, index, value): self.minPhysicalQuantity.insert(index, value)
    def replace_minPhysicalQuantity_at(self, index, value): self.minPhysicalQuantity[index] = value
    def get_maxPhysicalQuantity(self): return self.maxPhysicalQuantity
    def set_maxPhysicalQuantity(self, maxPhysicalQuantity): self.maxPhysicalQuantity = maxPhysicalQuantity
    def add_maxPhysicalQuantity(self, value): self.maxPhysicalQuantity.append(value)
    def insert_maxPhysicalQuantity_at(self, index, value): self.maxPhysicalQuantity.insert(index, value)
    def replace_maxPhysicalQuantity_at(self, index, value): self.maxPhysicalQuantity[index] = value
    def get_electingParty(self): return self.electingParty
    def set_electingParty(self, electingParty): self.electingParty = electingParty
    def hasContent_(self):
        if (
            self.physicalQuantity is not None or
            self.physicalQuantitySchedule is not None or
            self.totalPhysicalQuantity is not None or
            self.minPhysicalQuantity or
            self.maxPhysicalQuantity or
            self.electingParty is not None or
            super(GasPhysicalQuantity, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GasPhysicalQuantity', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GasPhysicalQuantity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GasPhysicalQuantity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GasPhysicalQuantity'):
        super(GasPhysicalQuantity, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GasPhysicalQuantity')
    def exportChildren(self, outfile, level, namespace_='', name_='GasPhysicalQuantity', fromsubclass_=False, pretty_print=True):
        super(GasPhysicalQuantity, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.physicalQuantity is not None:
            self.physicalQuantity.export(outfile, level, namespace_, name_='physicalQuantity', pretty_print=pretty_print)
        if self.physicalQuantitySchedule is not None:
            self.physicalQuantitySchedule.export(outfile, level, namespace_, name_='physicalQuantitySchedule', pretty_print=pretty_print)
        if self.totalPhysicalQuantity is not None:
            self.totalPhysicalQuantity.export(outfile, level, namespace_, name_='totalPhysicalQuantity', pretty_print=pretty_print)
        for minPhysicalQuantity_ in self.minPhysicalQuantity:
            minPhysicalQuantity_.export(outfile, level, namespace_, name_='minPhysicalQuantity', pretty_print=pretty_print)
        for maxPhysicalQuantity_ in self.maxPhysicalQuantity:
            maxPhysicalQuantity_.export(outfile, level, namespace_, name_='maxPhysicalQuantity', pretty_print=pretty_print)
        if self.electingParty is not None:
            self.electingParty.export(outfile, level, namespace_, name_='electingParty', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GasPhysicalQuantity, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'physicalQuantity':
            class_obj_ = self.get_class_obj_(child_, CommodityNotionalQuantity)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.physicalQuantity = obj_
            obj_.original_tagname_ = 'physicalQuantity'
        elif nodeName_ == 'physicalQuantitySchedule':
            class_obj_ = self.get_class_obj_(child_, CommodityPhysicalQuantitySchedule)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.physicalQuantitySchedule = obj_
            obj_.original_tagname_ = 'physicalQuantitySchedule'
        elif nodeName_ == 'totalPhysicalQuantity':
            obj_ = UnitQuantity.factory()
            obj_.build(child_)
            self.totalPhysicalQuantity = obj_
            obj_.original_tagname_ = 'totalPhysicalQuantity'
        elif nodeName_ == 'minPhysicalQuantity':
            class_obj_ = self.get_class_obj_(child_, CommodityNotionalQuantity)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.minPhysicalQuantity.append(obj_)
            obj_.original_tagname_ = 'minPhysicalQuantity'
        elif nodeName_ == 'maxPhysicalQuantity':
            class_obj_ = self.get_class_obj_(child_, CommodityNotionalQuantity)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.maxPhysicalQuantity.append(obj_)
            obj_.original_tagname_ = 'maxPhysicalQuantity'
        elif nodeName_ == 'electingParty':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.electingParty = obj_
            obj_.original_tagname_ = 'electingParty'
        super(GasPhysicalQuantity, self).buildChildren(child_, node, nodeName_, True)
# end class GasPhysicalQuantity


class GasProduct(GeneratedsSuper):
    """A type defining the characteristics of the gas being traded in a
    physically settled gas transaction."""
    member_data_items_ = {
        'type_': MemberSpec_('type_', ['GasProductTypeEnum', 'Token', 'xsd:token'], 0),
        'calorificValue': MemberSpec_('calorificValue', ['NonNegativeDecimal', 'xsd:decimal'], 0),
        'quality': MemberSpec_('quality', 'GasQuality', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, type_=None, calorificValue=None, quality=None):
        self.original_tagname_ = None
        self.type_ = type_
        self.validate_GasProductTypeEnum(self.type_)
        self.calorificValue = calorificValue
        self.validate_NonNegativeDecimal(self.calorificValue)
        self.quality = quality
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GasProduct)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GasProduct.subclass:
            return GasProduct.subclass(*args_, **kwargs_)
        else:
            return GasProduct(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_calorificValue(self): return self.calorificValue
    def set_calorificValue(self, calorificValue): self.calorificValue = calorificValue
    def get_quality(self): return self.quality
    def set_quality(self, quality): self.quality = quality
    def validate_GasProductTypeEnum(self, value):
        # Validate type GasProductTypeEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Butane', 'CarbonDioxide', 'EPMix', 'Ethane', 'Gasoline', 'Helium', 'HydrogenSulfide', 'Isobutane', 'Methane', 'Naphtha', 'NaturalGas', 'Nitrogen', 'Pentane', 'Propane', 'Propylene', 'Water']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on GasProductTypeEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on GasProductTypeEnum' % {"value" : value} )
    def validate_NonNegativeDecimal(self, value):
        # Validate type NonNegativeDecimal, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on NonNegativeDecimal' % {"value" : value} )
    def hasContent_(self):
        if (
            self.type_ is not None or
            self.calorificValue is not None or
            self.quality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GasProduct', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GasProduct')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GasProduct', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GasProduct'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GasProduct', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stype>%s</%stype>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.type_), input_name='type')), namespace_, eol_))
        if self.calorificValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scalorificValue>%s</%scalorificValue>%s' % (namespace_, self.gds_format_float(self.calorificValue, input_name='calorificValue'), namespace_, eol_))
        if self.quality is not None:
            self.quality.export(outfile, level, namespace_, name_='quality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            type_ = child_.text
            type_ = re_.sub(String_cleanup_pat_, " ", type_).strip()
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
            # validate type GasProductTypeEnum
            self.validate_GasProductTypeEnum(self.type_)
        elif nodeName_ == 'calorificValue':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'calorificValue')
            self.calorificValue = fval_
            # validate type NonNegativeDecimal
            self.validate_NonNegativeDecimal(self.calorificValue)
        elif nodeName_ == 'quality':
            obj_ = GasQuality.factory()
            obj_.build(child_)
            self.quality = obj_
            obj_.original_tagname_ = 'quality'
# end class GasProduct


class GasQuality(GeneratedsSuper):
    """The quantity of gas to be delivered."""
    member_data_items_ = {
        'gasQualityScheme': MemberSpec_('gasQualityScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, gasQualityScheme='http://www.fpml.org/coding-scheme/commodity-gas-quality', valueOf_=None):
        self.original_tagname_ = None
        self.gasQualityScheme = _cast(None, gasQualityScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GasQuality)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GasQuality.subclass:
            return GasQuality.subclass(*args_, **kwargs_)
        else:
            return GasQuality(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_gasQualityScheme(self): return self.gasQualityScheme
    def set_gasQualityScheme(self, gasQualityScheme): self.gasQualityScheme = gasQualityScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GasQuality', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GasQuality')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GasQuality', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GasQuality'):
        if self.gasQualityScheme != "http://www.fpml.org/coding-scheme/commodity-gas-quality" and 'gasQualityScheme' not in already_processed:
            already_processed.add('gasQualityScheme')
            outfile.write(' gasQualityScheme=%s' % (quote_attrib(self.gasQualityScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='GasQuality', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('gasQualityScheme', node)
        if value is not None and 'gasQualityScheme' not in already_processed:
            already_processed.add('gasQualityScheme')
            self.gasQualityScheme = value
            self.validate_NonEmptyURI(self.gasQualityScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class GasQuality


class InterconnectionPoint(GeneratedsSuper):
    """Identification of the border(s) or border point(s) of a
    transportation contract. Use the list of EIC codes for timelines
    for electricity (T Codes) or the list of EIC codes for
    measurement points for gas (Z Codes)."""
    member_data_items_ = {
        'interconnectionPointScheme': MemberSpec_('interconnectionPointScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, interconnectionPointScheme='http://www.fpml.org/coding-scheme/external/eic-codes', valueOf_=None):
        self.original_tagname_ = None
        self.interconnectionPointScheme = _cast(None, interconnectionPointScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InterconnectionPoint)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InterconnectionPoint.subclass:
            return InterconnectionPoint.subclass(*args_, **kwargs_)
        else:
            return InterconnectionPoint(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_interconnectionPointScheme(self): return self.interconnectionPointScheme
    def set_interconnectionPointScheme(self, interconnectionPointScheme): self.interconnectionPointScheme = interconnectionPointScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InterconnectionPoint', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InterconnectionPoint')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InterconnectionPoint', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InterconnectionPoint'):
        if self.interconnectionPointScheme != "http://www.fpml.org/coding-scheme/external/eic-codes" and 'interconnectionPointScheme' not in already_processed:
            already_processed.add('interconnectionPointScheme')
            outfile.write(' interconnectionPointScheme=%s' % (quote_attrib(self.interconnectionPointScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='InterconnectionPoint', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('interconnectionPointScheme', node)
        if value is not None and 'interconnectionPointScheme' not in already_processed:
            already_processed.add('interconnectionPointScheme')
            self.interconnectionPointScheme = value
            self.validate_NonEmptyURI(self.interconnectionPointScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class InterconnectionPoint


class Lag(GeneratedsSuper):
    """An observation period that is offset from a Calculation Period."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'lagDuration': MemberSpec_('lagDuration', 'Period', 0),
        'firstObservationDateOffset': MemberSpec_('firstObservationDateOffset', 'Period', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, lagDuration=None, firstObservationDateOffset=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.lagDuration = lagDuration
        self.firstObservationDateOffset = firstObservationDateOffset
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Lag)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Lag.subclass:
            return Lag.subclass(*args_, **kwargs_)
        else:
            return Lag(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lagDuration(self): return self.lagDuration
    def set_lagDuration(self, lagDuration): self.lagDuration = lagDuration
    def get_firstObservationDateOffset(self): return self.firstObservationDateOffset
    def set_firstObservationDateOffset(self, firstObservationDateOffset): self.firstObservationDateOffset = firstObservationDateOffset
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.lagDuration is not None or
            self.firstObservationDateOffset is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Lag', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Lag')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Lag', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Lag'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Lag', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.lagDuration is not None:
            self.lagDuration.export(outfile, level, namespace_, name_='lagDuration', pretty_print=pretty_print)
        if self.firstObservationDateOffset is not None:
            self.firstObservationDateOffset.export(outfile, level, namespace_, name_='firstObservationDateOffset', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'lagDuration':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.lagDuration = obj_
            obj_.original_tagname_ = 'lagDuration'
        elif nodeName_ == 'firstObservationDateOffset':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.firstObservationDateOffset = obj_
            obj_.original_tagname_ = 'firstObservationDateOffset'
# end class Lag


class MarketDisruptionEvent(GeneratedsSuper):
    """A Market Disruption Event."""
    member_data_items_ = {
        'commodityMarketDisruptionScheme': MemberSpec_('commodityMarketDisruptionScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, commodityMarketDisruptionScheme='http://www.fpml.org/coding-scheme/commodity-market-disruption', valueOf_=None):
        self.original_tagname_ = None
        self.commodityMarketDisruptionScheme = _cast(None, commodityMarketDisruptionScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MarketDisruptionEvent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MarketDisruptionEvent.subclass:
            return MarketDisruptionEvent.subclass(*args_, **kwargs_)
        else:
            return MarketDisruptionEvent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commodityMarketDisruptionScheme(self): return self.commodityMarketDisruptionScheme
    def set_commodityMarketDisruptionScheme(self, commodityMarketDisruptionScheme): self.commodityMarketDisruptionScheme = commodityMarketDisruptionScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MarketDisruptionEvent', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MarketDisruptionEvent')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MarketDisruptionEvent', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MarketDisruptionEvent'):
        if self.commodityMarketDisruptionScheme != "http://www.fpml.org/coding-scheme/commodity-market-disruption" and 'commodityMarketDisruptionScheme' not in already_processed:
            already_processed.add('commodityMarketDisruptionScheme')
            outfile.write(' commodityMarketDisruptionScheme=%s' % (quote_attrib(self.commodityMarketDisruptionScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MarketDisruptionEvent', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('commodityMarketDisruptionScheme', node)
        if value is not None and 'commodityMarketDisruptionScheme' not in already_processed:
            already_processed.add('commodityMarketDisruptionScheme')
            self.commodityMarketDisruptionScheme = value
            self.validate_NonEmptyURI(self.commodityMarketDisruptionScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MarketDisruptionEvent


class Material(GeneratedsSuper):
    """A scheme identifying the types of metal product for a physically
    settled metal trade."""
    member_data_items_ = {
        'commodityMetalProductTypeScheme': MemberSpec_('commodityMetalProductTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, commodityMetalProductTypeScheme='http://www.fpml.org/coding-scheme/commodity-metal-product-type', valueOf_=None):
        self.original_tagname_ = None
        self.commodityMetalProductTypeScheme = _cast(None, commodityMetalProductTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Material)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Material.subclass:
            return Material.subclass(*args_, **kwargs_)
        else:
            return Material(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commodityMetalProductTypeScheme(self): return self.commodityMetalProductTypeScheme
    def set_commodityMetalProductTypeScheme(self, commodityMetalProductTypeScheme): self.commodityMetalProductTypeScheme = commodityMetalProductTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Material', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Material')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Material', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Material'):
        if self.commodityMetalProductTypeScheme != "http://www.fpml.org/coding-scheme/commodity-metal-product-type" and 'commodityMetalProductTypeScheme' not in already_processed:
            already_processed.add('commodityMetalProductTypeScheme')
            outfile.write(' commodityMetalProductTypeScheme=%s' % (quote_attrib(self.commodityMetalProductTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Material', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('commodityMetalProductTypeScheme', node)
        if value is not None and 'commodityMetalProductTypeScheme' not in already_processed:
            already_processed.add('commodityMetalProductTypeScheme')
            self.commodityMetalProductTypeScheme = value
            self.validate_NonEmptyURI(self.commodityMetalProductTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Material


class Metal(GeneratedsSuper):
    """A type defining the characteristics of the metal product being
    traded in a physically settled metal transaction."""
    member_data_items_ = {
        'material': MemberSpec_('material', 'Material', 0),
        'shape': MemberSpec_('shape', 'CommodityMetalShape', 1),
        'brand': MemberSpec_('brand', 'CommodityMetalBrand', 1),
        'grade': MemberSpec_('grade', 'CommodityMetalGrade', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, material=None, shape=None, brand=None, grade=None):
        self.original_tagname_ = None
        self.material = material
        if shape is None:
            self.shape = []
        else:
            self.shape = shape
        if brand is None:
            self.brand = []
        else:
            self.brand = brand
        if grade is None:
            self.grade = []
        else:
            self.grade = grade
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Metal)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Metal.subclass:
            return Metal.subclass(*args_, **kwargs_)
        else:
            return Metal(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_material(self): return self.material
    def set_material(self, material): self.material = material
    def get_shape(self): return self.shape
    def set_shape(self, shape): self.shape = shape
    def add_shape(self, value): self.shape.append(value)
    def insert_shape_at(self, index, value): self.shape.insert(index, value)
    def replace_shape_at(self, index, value): self.shape[index] = value
    def get_brand(self): return self.brand
    def set_brand(self, brand): self.brand = brand
    def add_brand(self, value): self.brand.append(value)
    def insert_brand_at(self, index, value): self.brand.insert(index, value)
    def replace_brand_at(self, index, value): self.brand[index] = value
    def get_grade(self): return self.grade
    def set_grade(self, grade): self.grade = grade
    def add_grade(self, value): self.grade.append(value)
    def insert_grade_at(self, index, value): self.grade.insert(index, value)
    def replace_grade_at(self, index, value): self.grade[index] = value
    def hasContent_(self):
        if (
            self.material is not None or
            self.shape or
            self.brand or
            self.grade
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Metal', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Metal')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Metal', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Metal'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Metal', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.material is not None:
            self.material.export(outfile, level, namespace_, name_='material', pretty_print=pretty_print)
        for shape_ in self.shape:
            shape_.export(outfile, level, namespace_, name_='shape', pretty_print=pretty_print)
        for brand_ in self.brand:
            brand_.export(outfile, level, namespace_, name_='brand', pretty_print=pretty_print)
        for grade_ in self.grade:
            grade_.export(outfile, level, namespace_, name_='grade', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'material':
            obj_ = Material.factory()
            obj_.build(child_)
            self.material = obj_
            obj_.original_tagname_ = 'material'
        elif nodeName_ == 'shape':
            obj_ = CommodityMetalShape.factory()
            obj_.build(child_)
            self.shape.append(obj_)
            obj_.original_tagname_ = 'shape'
        elif nodeName_ == 'brand':
            obj_ = CommodityMetalBrand.factory()
            obj_.build(child_)
            self.brand.append(obj_)
            obj_.original_tagname_ = 'brand'
        elif nodeName_ == 'grade':
            obj_ = CommodityMetalGrade.factory()
            obj_.build(child_)
            self.grade.append(obj_)
            obj_.original_tagname_ = 'grade'
# end class Metal


class MetalDelivery(GeneratedsSuper):
    """The physical delivery conditions for the transaction."""
    member_data_items_ = {
        'deliveryLocation': MemberSpec_('deliveryLocation', 'CommodityDeliveryPoint', 0),
        'risk': MemberSpec_('risk', 'CommodityDeliveryRisk', 0),
        'totalQuantityTolerance': MemberSpec_('totalQuantityTolerance', 'xsd:decimal', 0),
        'periodQuantityTolerance': MemberSpec_('periodQuantityTolerance', 'xsd:decimal', 0),
        'title': MemberSpec_('title', ['MetalTitleEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, deliveryLocation=None, risk=None, totalQuantityTolerance=None, periodQuantityTolerance=None, title=None):
        self.original_tagname_ = None
        self.deliveryLocation = deliveryLocation
        self.risk = risk
        self.totalQuantityTolerance = totalQuantityTolerance
        self.periodQuantityTolerance = periodQuantityTolerance
        self.title = title
        self.validate_MetalTitleEnum(self.title)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MetalDelivery)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MetalDelivery.subclass:
            return MetalDelivery.subclass(*args_, **kwargs_)
        else:
            return MetalDelivery(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_deliveryLocation(self): return self.deliveryLocation
    def set_deliveryLocation(self, deliveryLocation): self.deliveryLocation = deliveryLocation
    def get_risk(self): return self.risk
    def set_risk(self, risk): self.risk = risk
    def get_totalQuantityTolerance(self): return self.totalQuantityTolerance
    def set_totalQuantityTolerance(self, totalQuantityTolerance): self.totalQuantityTolerance = totalQuantityTolerance
    def get_periodQuantityTolerance(self): return self.periodQuantityTolerance
    def set_periodQuantityTolerance(self, periodQuantityTolerance): self.periodQuantityTolerance = periodQuantityTolerance
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def validate_MetalTitleEnum(self, value):
        # Validate type MetalTitleEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['TransfersWithRiskOfLoss', 'DoesNotTransferWithRiskOfLoss']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MetalTitleEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on MetalTitleEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.deliveryLocation is not None or
            self.risk is not None or
            self.totalQuantityTolerance is not None or
            self.periodQuantityTolerance is not None or
            self.title is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MetalDelivery', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MetalDelivery')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MetalDelivery', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MetalDelivery'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MetalDelivery', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.deliveryLocation is not None:
            self.deliveryLocation.export(outfile, level, namespace_, name_='deliveryLocation', pretty_print=pretty_print)
        if self.risk is not None:
            self.risk.export(outfile, level, namespace_, name_='risk', pretty_print=pretty_print)
        if self.totalQuantityTolerance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalQuantityTolerance>%s</%stotalQuantityTolerance>%s' % (namespace_, self.gds_format_float(self.totalQuantityTolerance, input_name='totalQuantityTolerance'), namespace_, eol_))
        if self.periodQuantityTolerance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%speriodQuantityTolerance>%s</%speriodQuantityTolerance>%s' % (namespace_, self.gds_format_float(self.periodQuantityTolerance, input_name='periodQuantityTolerance'), namespace_, eol_))
        if self.title is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stitle>%s</%stitle>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.title), input_name='title')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'deliveryLocation':
            obj_ = CommodityDeliveryPoint.factory()
            obj_.build(child_)
            self.deliveryLocation = obj_
            obj_.original_tagname_ = 'deliveryLocation'
        elif nodeName_ == 'risk':
            obj_ = CommodityDeliveryRisk.factory()
            obj_.build(child_)
            self.risk = obj_
            obj_.original_tagname_ = 'risk'
        elif nodeName_ == 'totalQuantityTolerance':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'totalQuantityTolerance')
            self.totalQuantityTolerance = fval_
        elif nodeName_ == 'periodQuantityTolerance':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'periodQuantityTolerance')
            self.periodQuantityTolerance = fval_
        elif nodeName_ == 'title':
            title_ = child_.text
            title_ = re_.sub(String_cleanup_pat_, " ", title_).strip()
            title_ = self.gds_validate_string(title_, node, 'title')
            self.title = title_
            # validate type MetalTitleEnum
            self.validate_MetalTitleEnum(self.title)
# end class MetalDelivery


class OilDelivery(GeneratedsSuper):
    """The physical delivery conditions for an oil product."""
    member_data_items_ = {
        'pipeline': MemberSpec_('pipeline', 'OilPipelineDelivery', 0),
        'transfer': MemberSpec_('transfer', 'OilTransferDelivery', 0),
        'importerOfRecord': MemberSpec_('importerOfRecord', 'PartyReference', 0),
        'absoluteTolerance': MemberSpec_('absoluteTolerance', 'AbsoluteTolerance', 0),
        'percentageTolerance': MemberSpec_('percentageTolerance', 'PercentageTolerance', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, pipeline=None, transfer=None, importerOfRecord=None, absoluteTolerance=None, percentageTolerance=None):
        self.original_tagname_ = None
        self.pipeline = pipeline
        self.transfer = transfer
        self.importerOfRecord = importerOfRecord
        self.absoluteTolerance = absoluteTolerance
        self.percentageTolerance = percentageTolerance
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OilDelivery)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OilDelivery.subclass:
            return OilDelivery.subclass(*args_, **kwargs_)
        else:
            return OilDelivery(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pipeline(self): return self.pipeline
    def set_pipeline(self, pipeline): self.pipeline = pipeline
    def get_transfer(self): return self.transfer
    def set_transfer(self, transfer): self.transfer = transfer
    def get_importerOfRecord(self): return self.importerOfRecord
    def set_importerOfRecord(self, importerOfRecord): self.importerOfRecord = importerOfRecord
    def get_absoluteTolerance(self): return self.absoluteTolerance
    def set_absoluteTolerance(self, absoluteTolerance): self.absoluteTolerance = absoluteTolerance
    def get_percentageTolerance(self): return self.percentageTolerance
    def set_percentageTolerance(self, percentageTolerance): self.percentageTolerance = percentageTolerance
    def hasContent_(self):
        if (
            self.pipeline is not None or
            self.transfer is not None or
            self.importerOfRecord is not None or
            self.absoluteTolerance is not None or
            self.percentageTolerance is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OilDelivery', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OilDelivery')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OilDelivery', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OilDelivery'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OilDelivery', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.pipeline is not None:
            self.pipeline.export(outfile, level, namespace_, name_='pipeline', pretty_print=pretty_print)
        if self.transfer is not None:
            self.transfer.export(outfile, level, namespace_, name_='transfer', pretty_print=pretty_print)
        if self.importerOfRecord is not None:
            self.importerOfRecord.export(outfile, level, namespace_, name_='importerOfRecord', pretty_print=pretty_print)
        if self.absoluteTolerance is not None:
            self.absoluteTolerance.export(outfile, level, namespace_, name_='absoluteTolerance', pretty_print=pretty_print)
        if self.percentageTolerance is not None:
            self.percentageTolerance.export(outfile, level, namespace_, name_='percentageTolerance', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pipeline':
            obj_ = OilPipelineDelivery.factory()
            obj_.build(child_)
            self.pipeline = obj_
            obj_.original_tagname_ = 'pipeline'
        elif nodeName_ == 'transfer':
            obj_ = OilTransferDelivery.factory()
            obj_.build(child_)
            self.transfer = obj_
            obj_.original_tagname_ = 'transfer'
        elif nodeName_ == 'importerOfRecord':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.importerOfRecord = obj_
            obj_.original_tagname_ = 'importerOfRecord'
        elif nodeName_ == 'absoluteTolerance':
            obj_ = AbsoluteTolerance.factory()
            obj_.build(child_)
            self.absoluteTolerance = obj_
            obj_.original_tagname_ = 'absoluteTolerance'
        elif nodeName_ == 'percentageTolerance':
            obj_ = PercentageTolerance.factory()
            obj_.build(child_)
            self.percentageTolerance = obj_
            obj_.original_tagname_ = 'percentageTolerance'
# end class OilDelivery


class OilPipelineDelivery(GeneratedsSuper):
    """The physical delivery conditions specific to an oil product
    delivered by pipeline."""
    member_data_items_ = {
        'pipelineName': MemberSpec_('pipelineName', 'CommodityPipeline', 0),
        'withdrawalPoint': MemberSpec_('withdrawalPoint', 'CommodityDeliveryPoint', 0),
        'entryPoint': MemberSpec_('entryPoint', 'CommodityDeliveryPoint', 0),
        'deliverableByBarge': MemberSpec_('deliverableByBarge', 'xsd:boolean', 0),
        'risk': MemberSpec_('risk', 'CommodityDeliveryRisk', 0),
        'cycle': MemberSpec_('cycle', 'CommodityPipelineCycle', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, pipelineName=None, withdrawalPoint=None, entryPoint=None, deliverableByBarge=None, risk=None, cycle=None):
        self.original_tagname_ = None
        self.pipelineName = pipelineName
        self.withdrawalPoint = withdrawalPoint
        self.entryPoint = entryPoint
        self.deliverableByBarge = deliverableByBarge
        self.risk = risk
        if cycle is None:
            self.cycle = []
        else:
            self.cycle = cycle
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OilPipelineDelivery)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OilPipelineDelivery.subclass:
            return OilPipelineDelivery.subclass(*args_, **kwargs_)
        else:
            return OilPipelineDelivery(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pipelineName(self): return self.pipelineName
    def set_pipelineName(self, pipelineName): self.pipelineName = pipelineName
    def get_withdrawalPoint(self): return self.withdrawalPoint
    def set_withdrawalPoint(self, withdrawalPoint): self.withdrawalPoint = withdrawalPoint
    def get_entryPoint(self): return self.entryPoint
    def set_entryPoint(self, entryPoint): self.entryPoint = entryPoint
    def get_deliverableByBarge(self): return self.deliverableByBarge
    def set_deliverableByBarge(self, deliverableByBarge): self.deliverableByBarge = deliverableByBarge
    def get_risk(self): return self.risk
    def set_risk(self, risk): self.risk = risk
    def get_cycle(self): return self.cycle
    def set_cycle(self, cycle): self.cycle = cycle
    def add_cycle(self, value): self.cycle.append(value)
    def insert_cycle_at(self, index, value): self.cycle.insert(index, value)
    def replace_cycle_at(self, index, value): self.cycle[index] = value
    def hasContent_(self):
        if (
            self.pipelineName is not None or
            self.withdrawalPoint is not None or
            self.entryPoint is not None or
            self.deliverableByBarge is not None or
            self.risk is not None or
            self.cycle
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OilPipelineDelivery', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OilPipelineDelivery')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OilPipelineDelivery', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OilPipelineDelivery'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OilPipelineDelivery', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.pipelineName is not None:
            self.pipelineName.export(outfile, level, namespace_, name_='pipelineName', pretty_print=pretty_print)
        if self.withdrawalPoint is not None:
            self.withdrawalPoint.export(outfile, level, namespace_, name_='withdrawalPoint', pretty_print=pretty_print)
        if self.entryPoint is not None:
            self.entryPoint.export(outfile, level, namespace_, name_='entryPoint', pretty_print=pretty_print)
        if self.deliverableByBarge is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdeliverableByBarge>%s</%sdeliverableByBarge>%s' % (namespace_, self.gds_format_boolean(self.deliverableByBarge, input_name='deliverableByBarge'), namespace_, eol_))
        if self.risk is not None:
            self.risk.export(outfile, level, namespace_, name_='risk', pretty_print=pretty_print)
        for cycle_ in self.cycle:
            cycle_.export(outfile, level, namespace_, name_='cycle', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pipelineName':
            obj_ = CommodityPipeline.factory()
            obj_.build(child_)
            self.pipelineName = obj_
            obj_.original_tagname_ = 'pipelineName'
        elif nodeName_ == 'withdrawalPoint':
            obj_ = CommodityDeliveryPoint.factory()
            obj_.build(child_)
            self.withdrawalPoint = obj_
            obj_.original_tagname_ = 'withdrawalPoint'
        elif nodeName_ == 'entryPoint':
            obj_ = CommodityDeliveryPoint.factory()
            obj_.build(child_)
            self.entryPoint = obj_
            obj_.original_tagname_ = 'entryPoint'
        elif nodeName_ == 'deliverableByBarge':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'deliverableByBarge')
            self.deliverableByBarge = ival_
        elif nodeName_ == 'risk':
            obj_ = CommodityDeliveryRisk.factory()
            obj_.build(child_)
            self.risk = obj_
            obj_.original_tagname_ = 'risk'
        elif nodeName_ == 'cycle':
            obj_ = CommodityPipelineCycle.factory()
            obj_.build(child_)
            self.cycle.append(obj_)
            obj_.original_tagname_ = 'cycle'
# end class OilPipelineDelivery


class OilProduct(GeneratedsSuper):
    """The specification of the oil product to be delivered."""
    member_data_items_ = {
        'type_': MemberSpec_('type_', 'OilProductType', 0),
        'grade': MemberSpec_('grade', 'CommodityProductGrade', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, type_=None, grade=None):
        self.original_tagname_ = None
        self.type_ = type_
        self.grade = grade
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OilProduct)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OilProduct.subclass:
            return OilProduct.subclass(*args_, **kwargs_)
        else:
            return OilProduct(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_grade(self): return self.grade
    def set_grade(self, grade): self.grade = grade
    def hasContent_(self):
        if (
            self.type_ is not None or
            self.grade is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OilProduct', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OilProduct')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OilProduct', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OilProduct'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OilProduct', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            self.type_.export(outfile, level, namespace_, name_='type', pretty_print=pretty_print)
        if self.grade is not None:
            self.grade.export(outfile, level, namespace_, name_='grade', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            obj_ = OilProductType.factory()
            obj_.build(child_)
            self.type_ = obj_
            obj_.original_tagname_ = 'type'
        elif nodeName_ == 'grade':
            obj_ = CommodityProductGrade.factory()
            obj_.build(child_)
            self.grade = obj_
            obj_.original_tagname_ = 'grade'
# end class OilProduct


class OilProductType(GeneratedsSuper):
    """The type of physical commodity product to be delivered."""
    member_data_items_ = {
        'commodityOilProductTypeScheme': MemberSpec_('commodityOilProductTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, commodityOilProductTypeScheme='http://www.fpml.org/coding-scheme/commodity-oil-product-type', valueOf_=None):
        self.original_tagname_ = None
        self.commodityOilProductTypeScheme = _cast(None, commodityOilProductTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OilProductType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OilProductType.subclass:
            return OilProductType.subclass(*args_, **kwargs_)
        else:
            return OilProductType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commodityOilProductTypeScheme(self): return self.commodityOilProductTypeScheme
    def set_commodityOilProductTypeScheme(self, commodityOilProductTypeScheme): self.commodityOilProductTypeScheme = commodityOilProductTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OilProductType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OilProductType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OilProductType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OilProductType'):
        if self.commodityOilProductTypeScheme != "http://www.fpml.org/coding-scheme/commodity-oil-product-type" and 'commodityOilProductTypeScheme' not in already_processed:
            already_processed.add('commodityOilProductTypeScheme')
            outfile.write(' commodityOilProductTypeScheme=%s' % (quote_attrib(self.commodityOilProductTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OilProductType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('commodityOilProductTypeScheme', node)
        if value is not None and 'commodityOilProductTypeScheme' not in already_processed:
            already_processed.add('commodityOilProductTypeScheme')
            self.commodityOilProductTypeScheme = value
            self.validate_NonEmptyURI(self.commodityOilProductTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OilProductType


class OilTransferDelivery(GeneratedsSuper):
    """The physical delivery conditions specific to an oil product
    delivered by title transfer."""
    member_data_items_ = {
        'applicable': MemberSpec_('applicable', 'xsd:boolean', 0),
        'deliveryLocation': MemberSpec_('deliveryLocation', 'CommodityDeliveryPoint', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, applicable=None, deliveryLocation=None):
        self.original_tagname_ = None
        self.applicable = applicable
        self.deliveryLocation = deliveryLocation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OilTransferDelivery)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OilTransferDelivery.subclass:
            return OilTransferDelivery.subclass(*args_, **kwargs_)
        else:
            return OilTransferDelivery(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_applicable(self): return self.applicable
    def set_applicable(self, applicable): self.applicable = applicable
    def get_deliveryLocation(self): return self.deliveryLocation
    def set_deliveryLocation(self, deliveryLocation): self.deliveryLocation = deliveryLocation
    def hasContent_(self):
        if (
            self.applicable is not None or
            self.deliveryLocation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OilTransferDelivery', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OilTransferDelivery')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OilTransferDelivery', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OilTransferDelivery'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OilTransferDelivery', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.applicable is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sapplicable>%s</%sapplicable>%s' % (namespace_, self.gds_format_boolean(self.applicable, input_name='applicable'), namespace_, eol_))
        if self.deliveryLocation is not None:
            self.deliveryLocation.export(outfile, level, namespace_, name_='deliveryLocation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'applicable':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'applicable')
            self.applicable = ival_
        elif nodeName_ == 'deliveryLocation':
            obj_ = CommodityDeliveryPoint.factory()
            obj_.build(child_)
            self.deliveryLocation = obj_
            obj_.original_tagname_ = 'deliveryLocation'
# end class OilTransferDelivery


class PercentageTolerance(GeneratedsSuper):
    """The acceptable tolerance in the delivered quantity of a physical
    commodity product in terms of a percentage of the agreed
    delivery quantity."""
    member_data_items_ = {
        'postitive': MemberSpec_('postitive', ['RestrictedPercentage', 'xsd:decimal'], 0),
        'negative': MemberSpec_('negative', ['RestrictedPercentage', 'xsd:decimal'], 0),
        'option': MemberSpec_('option', 'ExchangeTradedOption', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, postitive=None, negative=None, option=None):
        self.original_tagname_ = None
        self.postitive = postitive
        self.validate_RestrictedPercentage(self.postitive)
        self.negative = negative
        self.validate_RestrictedPercentage(self.negative)
        self.option = option
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PercentageTolerance)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PercentageTolerance.subclass:
            return PercentageTolerance.subclass(*args_, **kwargs_)
        else:
            return PercentageTolerance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_postitive(self): return self.postitive
    def set_postitive(self, postitive): self.postitive = postitive
    def get_negative(self): return self.negative
    def set_negative(self, negative): self.negative = negative
    def get_option(self): return self.option
    def set_option(self, option): self.option = option
    def validate_RestrictedPercentage(self, value):
        # Validate type RestrictedPercentage, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on RestrictedPercentage' % {"value" : value} )
            if value > 1:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on RestrictedPercentage' % {"value" : value} )
    def hasContent_(self):
        if (
            self.postitive is not None or
            self.negative is not None or
            self.option is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PercentageTolerance', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PercentageTolerance')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PercentageTolerance', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PercentageTolerance'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PercentageTolerance', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.postitive is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spostitive>%s</%spostitive>%s' % (namespace_, self.gds_format_float(self.postitive, input_name='postitive'), namespace_, eol_))
        if self.negative is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snegative>%s</%snegative>%s' % (namespace_, self.gds_format_float(self.negative, input_name='negative'), namespace_, eol_))
        if self.option is not None:
            self.option.export(outfile, level, namespace_, name_='option', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'postitive':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'postitive')
            self.postitive = fval_
            # validate type RestrictedPercentage
            self.validate_RestrictedPercentage(self.postitive)
        elif nodeName_ == 'negative':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'negative')
            self.negative = fval_
            # validate type RestrictedPercentage
            self.validate_RestrictedPercentage(self.negative)
        elif nodeName_ == 'option':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.option = obj_
            obj_.original_tagname_ = 'option'
# end class PercentageTolerance


class ReferenceLevel(GeneratedsSuper):
    member_data_items_ = {
        'amount': MemberSpec_('amount', 'xsd:decimal', 0),
        'referenceLevelUnit': MemberSpec_('referenceLevelUnit', 'ReferenceLevelUnit', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, amount=None, referenceLevelUnit=None):
        self.original_tagname_ = None
        self.amount = amount
        self.referenceLevelUnit = referenceLevelUnit
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferenceLevel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferenceLevel.subclass:
            return ReferenceLevel.subclass(*args_, **kwargs_)
        else:
            return ReferenceLevel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_amount(self): return self.amount
    def set_amount(self, amount): self.amount = amount
    def get_referenceLevelUnit(self): return self.referenceLevelUnit
    def set_referenceLevelUnit(self, referenceLevelUnit): self.referenceLevelUnit = referenceLevelUnit
    def hasContent_(self):
        if (
            self.amount is not None or
            self.referenceLevelUnit is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReferenceLevel', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceLevel')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReferenceLevel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReferenceLevel'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ReferenceLevel', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.amount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%samount>%s</%samount>%s' % (namespace_, self.gds_format_float(self.amount, input_name='amount'), namespace_, eol_))
        if self.referenceLevelUnit is not None:
            self.referenceLevelUnit.export(outfile, level, namespace_, name_='referenceLevelUnit', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'amount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'amount')
            self.amount = fval_
        elif nodeName_ == 'referenceLevelUnit':
            obj_ = ReferenceLevelUnit.factory()
            obj_.build(child_)
            self.referenceLevelUnit = obj_
            obj_.original_tagname_ = 'referenceLevelUnit'
# end class ReferenceLevel


class ReferenceLevelUnit(GeneratedsSuper):
    """CPD Reference Level: millimeters or inches of daily precipitation
    HDD Reference Level: degree-days CDD Reference Level: degree-
    days."""
    member_data_items_ = {
        'weatherIndexReferenceLevelScheme': MemberSpec_('weatherIndexReferenceLevelScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, weatherIndexReferenceLevelScheme='http://www.fpml.org/coding-scheme/weather-index-reference-level', valueOf_=None):
        self.original_tagname_ = None
        self.weatherIndexReferenceLevelScheme = _cast(None, weatherIndexReferenceLevelScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferenceLevelUnit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferenceLevelUnit.subclass:
            return ReferenceLevelUnit.subclass(*args_, **kwargs_)
        else:
            return ReferenceLevelUnit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_weatherIndexReferenceLevelScheme(self): return self.weatherIndexReferenceLevelScheme
    def set_weatherIndexReferenceLevelScheme(self, weatherIndexReferenceLevelScheme): self.weatherIndexReferenceLevelScheme = weatherIndexReferenceLevelScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReferenceLevelUnit', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceLevelUnit')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReferenceLevelUnit', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReferenceLevelUnit'):
        if self.weatherIndexReferenceLevelScheme != "http://www.fpml.org/coding-scheme/weather-index-reference-level" and 'weatherIndexReferenceLevelScheme' not in already_processed:
            already_processed.add('weatherIndexReferenceLevelScheme')
            outfile.write(' weatherIndexReferenceLevelScheme=%s' % (quote_attrib(self.weatherIndexReferenceLevelScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ReferenceLevelUnit', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('weatherIndexReferenceLevelScheme', node)
        if value is not None and 'weatherIndexReferenceLevelScheme' not in already_processed:
            already_processed.add('weatherIndexReferenceLevelScheme')
            self.weatherIndexReferenceLevelScheme = value
            self.validate_NonEmptyURI(self.weatherIndexReferenceLevelScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReferenceLevelUnit


class SequencedDisruptionFallback(GeneratedsSuper):
    """A Disruption Fallback with the sequence in which it should be
    applied relative to other Disruption Fallbacks."""
    member_data_items_ = {
        'fallback': MemberSpec_('fallback', 'DisruptionFallback', 0),
        'sequence': MemberSpec_('sequence', 'xsd:positiveInteger', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, fallback=None, sequence=None):
        self.original_tagname_ = None
        self.fallback = fallback
        self.sequence = sequence
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SequencedDisruptionFallback)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SequencedDisruptionFallback.subclass:
            return SequencedDisruptionFallback.subclass(*args_, **kwargs_)
        else:
            return SequencedDisruptionFallback(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fallback(self): return self.fallback
    def set_fallback(self, fallback): self.fallback = fallback
    def get_sequence(self): return self.sequence
    def set_sequence(self, sequence): self.sequence = sequence
    def hasContent_(self):
        if (
            self.fallback is not None or
            self.sequence is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SequencedDisruptionFallback', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SequencedDisruptionFallback')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SequencedDisruptionFallback', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SequencedDisruptionFallback'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SequencedDisruptionFallback', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.fallback is not None:
            self.fallback.export(outfile, level, namespace_, name_='fallback', pretty_print=pretty_print)
        if self.sequence is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssequence>%s</%ssequence>%s' % (namespace_, self.gds_format_integer(self.sequence, input_name='sequence'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fallback':
            obj_ = DisruptionFallback.factory()
            obj_.build(child_)
            self.fallback = obj_
            obj_.original_tagname_ = 'fallback'
        elif nodeName_ == 'sequence':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'sequence')
            self.sequence = ival_
# end class SequencedDisruptionFallback


class SettlementPeriods(GeneratedsSuper):
    """Specifies a set of Settlement Periods associated with an Electricity
    Transaction for delivery on an Applicable Day or for a series of
    Applicable Days."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'duration': MemberSpec_('duration', ['SettlementPeriodDurationEnum', 'Token', 'xsd:token'], 0),
        'applicableDay': MemberSpec_('applicableDay', ['DayOfWeekEnum', 'Token', 'xsd:token'], 1),
        'startTime': MemberSpec_('startTime', 'OffsetPrevailingTime', 0),
        'endTime': MemberSpec_('endTime', 'OffsetPrevailingTime', 0),
        'excludeHolidays': MemberSpec_('excludeHolidays', 'CommodityBusinessCalendar', 0),
        'includeHolidays': MemberSpec_('includeHolidays', 'CommodityBusinessCalendar', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, duration=None, applicableDay=None, startTime=None, endTime=None, excludeHolidays=None, includeHolidays=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.duration = duration
        self.validate_SettlementPeriodDurationEnum(self.duration)
        if applicableDay is None:
            self.applicableDay = []
        else:
            self.applicableDay = applicableDay
        self.startTime = startTime
        self.endTime = endTime
        self.excludeHolidays = excludeHolidays
        self.includeHolidays = includeHolidays
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SettlementPeriods)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SettlementPeriods.subclass:
            return SettlementPeriods.subclass(*args_, **kwargs_)
        else:
            return SettlementPeriods(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_duration(self): return self.duration
    def set_duration(self, duration): self.duration = duration
    def get_applicableDay(self): return self.applicableDay
    def set_applicableDay(self, applicableDay): self.applicableDay = applicableDay
    def add_applicableDay(self, value): self.applicableDay.append(value)
    def insert_applicableDay_at(self, index, value): self.applicableDay.insert(index, value)
    def replace_applicableDay_at(self, index, value): self.applicableDay[index] = value
    def get_startTime(self): return self.startTime
    def set_startTime(self, startTime): self.startTime = startTime
    def get_endTime(self): return self.endTime
    def set_endTime(self, endTime): self.endTime = endTime
    def get_excludeHolidays(self): return self.excludeHolidays
    def set_excludeHolidays(self, excludeHolidays): self.excludeHolidays = excludeHolidays
    def get_includeHolidays(self): return self.includeHolidays
    def set_includeHolidays(self, includeHolidays): self.includeHolidays = includeHolidays
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_SettlementPeriodDurationEnum(self, value):
        # Validate type SettlementPeriodDurationEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['2Hours', '1Hour', '30Minutes', '15Minutes']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SettlementPeriodDurationEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on SettlementPeriodDurationEnum' % {"value" : value} )
    def validate_DayOfWeekEnum(self, value):
        # Validate type DayOfWeekEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT', 'SUN']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DayOfWeekEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on DayOfWeekEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.duration is not None or
            self.applicableDay or
            self.startTime is not None or
            self.endTime is not None or
            self.excludeHolidays is not None or
            self.includeHolidays is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SettlementPeriods', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SettlementPeriods')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SettlementPeriods', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SettlementPeriods'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SettlementPeriods', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.duration is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sduration>%s</%sduration>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.duration), input_name='duration')), namespace_, eol_))
        for applicableDay_ in self.applicableDay:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sapplicableDay>%s</%sapplicableDay>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(applicableDay_), input_name='applicableDay')), namespace_, eol_))
        if self.startTime is not None:
            self.startTime.export(outfile, level, namespace_, name_='startTime', pretty_print=pretty_print)
        if self.endTime is not None:
            self.endTime.export(outfile, level, namespace_, name_='endTime', pretty_print=pretty_print)
        if self.excludeHolidays is not None:
            self.excludeHolidays.export(outfile, level, namespace_, name_='excludeHolidays', pretty_print=pretty_print)
        if self.includeHolidays is not None:
            self.includeHolidays.export(outfile, level, namespace_, name_='includeHolidays', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'duration':
            duration_ = child_.text
            duration_ = re_.sub(String_cleanup_pat_, " ", duration_).strip()
            duration_ = self.gds_validate_string(duration_, node, 'duration')
            self.duration = duration_
            # validate type SettlementPeriodDurationEnum
            self.validate_SettlementPeriodDurationEnum(self.duration)
        elif nodeName_ == 'applicableDay':
            applicableDay_ = child_.text
            applicableDay_ = re_.sub(String_cleanup_pat_, " ", applicableDay_).strip()
            applicableDay_ = self.gds_validate_string(applicableDay_, node, 'applicableDay')
            self.applicableDay.append(applicableDay_)
            # validate type DayOfWeekEnum
            self.validate_DayOfWeekEnum(self.applicableDay[-1])
        elif nodeName_ == 'startTime':
            obj_ = OffsetPrevailingTime.factory()
            obj_.build(child_)
            self.startTime = obj_
            obj_.original_tagname_ = 'startTime'
        elif nodeName_ == 'endTime':
            obj_ = OffsetPrevailingTime.factory()
            obj_.build(child_)
            self.endTime = obj_
            obj_.original_tagname_ = 'endTime'
        elif nodeName_ == 'excludeHolidays':
            obj_ = CommodityBusinessCalendar.factory()
            obj_.build(child_)
            self.excludeHolidays = obj_
            obj_.original_tagname_ = 'excludeHolidays'
        elif nodeName_ == 'includeHolidays':
            obj_ = CommodityBusinessCalendar.factory()
            obj_.build(child_)
            self.includeHolidays = obj_
            obj_.original_tagname_ = 'includeHolidays'
# end class SettlementPeriods


class SettlementPeriodsFixedPrice(FixedPrice):
    """A type defining the Fixed Price applicable to a range or ranges of
    Settlement Periods."""
    member_data_items_ = {
        'settlementPeriodsReference': MemberSpec_('settlementPeriodsReference', 'SettlementPeriodsReference', 1),
    }
    subclass = None
    superclass = FixedPrice
    def __init__(self, id=None, price=None, priceCurrency=None, priceUnit=None, settlementPeriodsReference=None):
        self.original_tagname_ = None
        super(SettlementPeriodsFixedPrice, self).__init__(id, price, priceCurrency, priceUnit, )
        if settlementPeriodsReference is None:
            self.settlementPeriodsReference = []
        else:
            self.settlementPeriodsReference = settlementPeriodsReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SettlementPeriodsFixedPrice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SettlementPeriodsFixedPrice.subclass:
            return SettlementPeriodsFixedPrice.subclass(*args_, **kwargs_)
        else:
            return SettlementPeriodsFixedPrice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_settlementPeriodsReference(self): return self.settlementPeriodsReference
    def set_settlementPeriodsReference(self, settlementPeriodsReference): self.settlementPeriodsReference = settlementPeriodsReference
    def add_settlementPeriodsReference(self, value): self.settlementPeriodsReference.append(value)
    def insert_settlementPeriodsReference_at(self, index, value): self.settlementPeriodsReference.insert(index, value)
    def replace_settlementPeriodsReference_at(self, index, value): self.settlementPeriodsReference[index] = value
    def hasContent_(self):
        if (
            self.settlementPeriodsReference or
            super(SettlementPeriodsFixedPrice, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SettlementPeriodsFixedPrice', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SettlementPeriodsFixedPrice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SettlementPeriodsFixedPrice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SettlementPeriodsFixedPrice'):
        super(SettlementPeriodsFixedPrice, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SettlementPeriodsFixedPrice')
    def exportChildren(self, outfile, level, namespace_='', name_='SettlementPeriodsFixedPrice', fromsubclass_=False, pretty_print=True):
        super(SettlementPeriodsFixedPrice, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for settlementPeriodsReference_ in self.settlementPeriodsReference:
            settlementPeriodsReference_.export(outfile, level, namespace_, name_='settlementPeriodsReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SettlementPeriodsFixedPrice, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'settlementPeriodsReference':
            obj_ = SettlementPeriodsReference.factory()
            obj_.build(child_)
            self.settlementPeriodsReference.append(obj_)
            obj_.original_tagname_ = 'settlementPeriodsReference'
        super(SettlementPeriodsFixedPrice, self).buildChildren(child_, node, nodeName_, True)
# end class SettlementPeriodsFixedPrice


class SettlementPeriodsSchedule(GeneratedsSuper):
    """The specification of the Settlement Periods in which the electricity
    will be delivered for a "shaped" trade i.e. where different
    Settlement Period ranges will apply to different periods of the
    trade."""
    member_data_items_ = {
        'settlementPeriodsStep': MemberSpec_('settlementPeriodsStep', 'SettlementPeriodsStep', 1),
        'deliveryPeriodsReference': MemberSpec_('deliveryPeriodsReference', 'CalculationPeriodsReference', 0),
        'deliveryPeriodsScheduleReference': MemberSpec_('deliveryPeriodsScheduleReference', 'CalculationPeriodsScheduleReference', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, settlementPeriodsStep=None, deliveryPeriodsReference=None, deliveryPeriodsScheduleReference=None):
        self.original_tagname_ = None
        if settlementPeriodsStep is None:
            self.settlementPeriodsStep = []
        else:
            self.settlementPeriodsStep = settlementPeriodsStep
        self.deliveryPeriodsReference = deliveryPeriodsReference
        self.deliveryPeriodsScheduleReference = deliveryPeriodsScheduleReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SettlementPeriodsSchedule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SettlementPeriodsSchedule.subclass:
            return SettlementPeriodsSchedule.subclass(*args_, **kwargs_)
        else:
            return SettlementPeriodsSchedule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_settlementPeriodsStep(self): return self.settlementPeriodsStep
    def set_settlementPeriodsStep(self, settlementPeriodsStep): self.settlementPeriodsStep = settlementPeriodsStep
    def add_settlementPeriodsStep(self, value): self.settlementPeriodsStep.append(value)
    def insert_settlementPeriodsStep_at(self, index, value): self.settlementPeriodsStep.insert(index, value)
    def replace_settlementPeriodsStep_at(self, index, value): self.settlementPeriodsStep[index] = value
    def get_deliveryPeriodsReference(self): return self.deliveryPeriodsReference
    def set_deliveryPeriodsReference(self, deliveryPeriodsReference): self.deliveryPeriodsReference = deliveryPeriodsReference
    def get_deliveryPeriodsScheduleReference(self): return self.deliveryPeriodsScheduleReference
    def set_deliveryPeriodsScheduleReference(self, deliveryPeriodsScheduleReference): self.deliveryPeriodsScheduleReference = deliveryPeriodsScheduleReference
    def hasContent_(self):
        if (
            self.settlementPeriodsStep or
            self.deliveryPeriodsReference is not None or
            self.deliveryPeriodsScheduleReference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SettlementPeriodsSchedule', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SettlementPeriodsSchedule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SettlementPeriodsSchedule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SettlementPeriodsSchedule'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SettlementPeriodsSchedule', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for settlementPeriodsStep_ in self.settlementPeriodsStep:
            settlementPeriodsStep_.export(outfile, level, namespace_, name_='settlementPeriodsStep', pretty_print=pretty_print)
        if self.deliveryPeriodsReference is not None:
            self.deliveryPeriodsReference.export(outfile, level, namespace_, name_='deliveryPeriodsReference', pretty_print=pretty_print)
        if self.deliveryPeriodsScheduleReference is not None:
            self.deliveryPeriodsScheduleReference.export(outfile, level, namespace_, name_='deliveryPeriodsScheduleReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'settlementPeriodsStep':
            obj_ = SettlementPeriodsStep.factory()
            obj_.build(child_)
            self.settlementPeriodsStep.append(obj_)
            obj_.original_tagname_ = 'settlementPeriodsStep'
        elif nodeName_ == 'deliveryPeriodsReference':
            obj_ = CalculationPeriodsReference.factory()
            obj_.build(child_)
            self.deliveryPeriodsReference = obj_
            obj_.original_tagname_ = 'deliveryPeriodsReference'
        elif nodeName_ == 'deliveryPeriodsScheduleReference':
            obj_ = CalculationPeriodsScheduleReference.factory()
            obj_.build(child_)
            self.deliveryPeriodsScheduleReference = obj_
            obj_.original_tagname_ = 'deliveryPeriodsScheduleReference'
# end class SettlementPeriodsSchedule


class SettlementPeriodsStep(GeneratedsSuper):
    """A reference to the range of Settlement Periods that applies to a
    given period of a transaction."""
    member_data_items_ = {
        'settlementPeriodsReference': MemberSpec_('settlementPeriodsReference', 'SettlementPeriodsReference', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, settlementPeriodsReference=None):
        self.original_tagname_ = None
        if settlementPeriodsReference is None:
            self.settlementPeriodsReference = []
        else:
            self.settlementPeriodsReference = settlementPeriodsReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SettlementPeriodsStep)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SettlementPeriodsStep.subclass:
            return SettlementPeriodsStep.subclass(*args_, **kwargs_)
        else:
            return SettlementPeriodsStep(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_settlementPeriodsReference(self): return self.settlementPeriodsReference
    def set_settlementPeriodsReference(self, settlementPeriodsReference): self.settlementPeriodsReference = settlementPeriodsReference
    def add_settlementPeriodsReference(self, value): self.settlementPeriodsReference.append(value)
    def insert_settlementPeriodsReference_at(self, index, value): self.settlementPeriodsReference.insert(index, value)
    def replace_settlementPeriodsReference_at(self, index, value): self.settlementPeriodsReference[index] = value
    def hasContent_(self):
        if (
            self.settlementPeriodsReference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SettlementPeriodsStep', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SettlementPeriodsStep')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SettlementPeriodsStep', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SettlementPeriodsStep'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SettlementPeriodsStep', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for settlementPeriodsReference_ in self.settlementPeriodsReference:
            settlementPeriodsReference_.export(outfile, level, namespace_, name_='settlementPeriodsReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'settlementPeriodsReference':
            obj_ = SettlementPeriodsReference.factory()
            obj_.build(child_)
            self.settlementPeriodsReference.append(obj_)
            obj_.original_tagname_ = 'settlementPeriodsReference'
# end class SettlementPeriodsStep


class UnitQuantity(GeneratedsSuper):
    """A quantity and associated unit."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'quantityUnit': MemberSpec_('quantityUnit', 'QuantityUnit', 0),
        'quantity': MemberSpec_('quantity', ['NonNegativeDecimal', 'xsd:decimal'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, quantityUnit=None, quantity=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.quantityUnit = quantityUnit
        self.quantity = quantity
        self.validate_NonNegativeDecimal(self.quantity)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UnitQuantity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UnitQuantity.subclass:
            return UnitQuantity.subclass(*args_, **kwargs_)
        else:
            return UnitQuantity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_quantityUnit(self): return self.quantityUnit
    def set_quantityUnit(self, quantityUnit): self.quantityUnit = quantityUnit
    def get_quantity(self): return self.quantity
    def set_quantity(self, quantity): self.quantity = quantity
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_NonNegativeDecimal(self, value):
        # Validate type NonNegativeDecimal, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on NonNegativeDecimal' % {"value" : value} )
    def hasContent_(self):
        if (
            self.quantityUnit is not None or
            self.quantity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='UnitQuantity', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UnitQuantity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='UnitQuantity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UnitQuantity'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='UnitQuantity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.quantityUnit is not None:
            self.quantityUnit.export(outfile, level, namespace_, name_='quantityUnit', pretty_print=pretty_print)
        if self.quantity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%squantity>%s</%squantity>%s' % (namespace_, self.gds_format_float(self.quantity, input_name='quantity'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'quantityUnit':
            obj_ = QuantityUnit.factory()
            obj_.build(child_)
            self.quantityUnit = obj_
            obj_.original_tagname_ = 'quantityUnit'
        elif nodeName_ == 'quantity':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'quantity')
            self.quantity = fval_
            # validate type NonNegativeDecimal
            self.validate_NonNegativeDecimal(self.quantity)
# end class UnitQuantity


class WeatherCalculationPeriod(GeneratedsSuper):
    """The schedule of Calculation Period First Days and Lasts Days. If
    there is only one First Day - Last Day pair then the First is
    equal to the Effective Date and the Last Day is equal to the
    Termination Date."""
    member_data_items_ = {
        'calculationPeriodFirstDay': MemberSpec_('calculationPeriodFirstDay', 'IdentifiedDate', 0),
        'calculationPeriodEndDay': MemberSpec_('calculationPeriodEndDay', 'IdentifiedDate', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, calculationPeriodFirstDay=None, calculationPeriodEndDay=None):
        self.original_tagname_ = None
        self.calculationPeriodFirstDay = calculationPeriodFirstDay
        self.calculationPeriodEndDay = calculationPeriodEndDay
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WeatherCalculationPeriod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WeatherCalculationPeriod.subclass:
            return WeatherCalculationPeriod.subclass(*args_, **kwargs_)
        else:
            return WeatherCalculationPeriod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_calculationPeriodFirstDay(self): return self.calculationPeriodFirstDay
    def set_calculationPeriodFirstDay(self, calculationPeriodFirstDay): self.calculationPeriodFirstDay = calculationPeriodFirstDay
    def get_calculationPeriodEndDay(self): return self.calculationPeriodEndDay
    def set_calculationPeriodEndDay(self, calculationPeriodEndDay): self.calculationPeriodEndDay = calculationPeriodEndDay
    def hasContent_(self):
        if (
            self.calculationPeriodFirstDay is not None or
            self.calculationPeriodEndDay is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='WeatherCalculationPeriod', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WeatherCalculationPeriod')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='WeatherCalculationPeriod', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='WeatherCalculationPeriod'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='WeatherCalculationPeriod', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.calculationPeriodFirstDay is not None:
            self.calculationPeriodFirstDay.export(outfile, level, namespace_, name_='calculationPeriodFirstDay', pretty_print=pretty_print)
        if self.calculationPeriodEndDay is not None:
            self.calculationPeriodEndDay.export(outfile, level, namespace_, name_='calculationPeriodEndDay', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'calculationPeriodFirstDay':
            obj_ = IdentifiedDate.factory()
            obj_.build(child_)
            self.calculationPeriodFirstDay = obj_
            obj_.original_tagname_ = 'calculationPeriodFirstDay'
        elif nodeName_ == 'calculationPeriodEndDay':
            obj_ = IdentifiedDate.factory()
            obj_.build(child_)
            self.calculationPeriodEndDay = obj_
            obj_.original_tagname_ = 'calculationPeriodEndDay'
# end class WeatherCalculationPeriod


class WeatherCalculationPeriods(GeneratedsSuper):
    """The schedule of Calculation Period First Days and Lasts Days. If
    there is only one First Day - Last Day pair then the First is
    equal to the Effective Date and the Last Day is equal to the
    Termination Date."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'calculationPeriod': MemberSpec_('calculationPeriod', 'WeatherCalculationPeriod', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, calculationPeriod=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if calculationPeriod is None:
            self.calculationPeriod = []
        else:
            self.calculationPeriod = calculationPeriod
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WeatherCalculationPeriods)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WeatherCalculationPeriods.subclass:
            return WeatherCalculationPeriods.subclass(*args_, **kwargs_)
        else:
            return WeatherCalculationPeriods(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_calculationPeriod(self): return self.calculationPeriod
    def set_calculationPeriod(self, calculationPeriod): self.calculationPeriod = calculationPeriod
    def add_calculationPeriod(self, value): self.calculationPeriod.append(value)
    def insert_calculationPeriod_at(self, index, value): self.calculationPeriod.insert(index, value)
    def replace_calculationPeriod_at(self, index, value): self.calculationPeriod[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.calculationPeriod
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='WeatherCalculationPeriods', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WeatherCalculationPeriods')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='WeatherCalculationPeriods', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='WeatherCalculationPeriods'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='WeatherCalculationPeriods', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for calculationPeriod_ in self.calculationPeriod:
            calculationPeriod_.export(outfile, level, namespace_, name_='calculationPeriod', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'calculationPeriod':
            obj_ = WeatherCalculationPeriod.factory()
            obj_.build(child_)
            self.calculationPeriod.append(obj_)
            obj_.original_tagname_ = 'calculationPeriod'
# end class WeatherCalculationPeriods


class WeatherIndex(GeneratedsSuper):
    """A type defining the Weather Index Level or Weather Index Strike
    Level."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'quantity': MemberSpec_('quantity', 'xsd:decimal', 0),
        'unit': MemberSpec_('unit', 'QuantityUnit', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, quantity=None, unit=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.quantity = quantity
        self.unit = unit
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WeatherIndex)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WeatherIndex.subclass:
            return WeatherIndex.subclass(*args_, **kwargs_)
        else:
            return WeatherIndex(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_quantity(self): return self.quantity
    def set_quantity(self, quantity): self.quantity = quantity
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.quantity is not None or
            self.unit is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='WeatherIndex', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WeatherIndex')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='WeatherIndex', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='WeatherIndex'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='WeatherIndex', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.quantity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%squantity>%s</%squantity>%s' % (namespace_, self.gds_format_float(self.quantity, input_name='quantity'), namespace_, eol_))
        if self.unit is not None:
            self.unit.export(outfile, level, namespace_, name_='unit', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'quantity':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'quantity')
            self.quantity = fval_
        elif nodeName_ == 'unit':
            obj_ = QuantityUnit.factory()
            obj_.build(child_)
            self.unit = obj_
            obj_.original_tagname_ = 'unit'
# end class WeatherIndex


class WeatherIndexData(GeneratedsSuper):
    member_data_items_ = {
        'referenceLevel': MemberSpec_('referenceLevel', 'ReferenceLevel', 0),
        'dataProvider': MemberSpec_('dataProvider', 'DataProvider', 0),
        'finalEditedData': MemberSpec_('finalEditedData', 'xsd:boolean', 0),
        'weatherStation': MemberSpec_('weatherStation', 'WeatherStation', 0),
        'weatherStationFallback': MemberSpec_('weatherStationFallback', 'WeatherStation', 0),
        'weatherStationSecondFallback': MemberSpec_('weatherStationSecondFallback', 'WeatherStation', 0),
        'alternativeDataProvider': MemberSpec_('alternativeDataProvider', 'xsd:boolean', 0),
        'synopticDataFallback': MemberSpec_('synopticDataFallback', 'xsd:boolean', 0),
        'adjustmentToFallbackWeatherStation': MemberSpec_('adjustmentToFallbackWeatherStation', 'xsd:boolean', 0),
        'primaryDisruptionFallbacks': MemberSpec_('primaryDisruptionFallbacks', 'DisruptionFallback', 0),
        'secondaryDisruptionFallbacks': MemberSpec_('secondaryDisruptionFallbacks', 'DisruptionFallback', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, referenceLevel=None, dataProvider=None, finalEditedData=None, weatherStation=None, weatherStationFallback=None, weatherStationSecondFallback=None, alternativeDataProvider=None, synopticDataFallback=None, adjustmentToFallbackWeatherStation=None, primaryDisruptionFallbacks=None, secondaryDisruptionFallbacks=None):
        self.original_tagname_ = None
        self.referenceLevel = referenceLevel
        self.dataProvider = dataProvider
        self.finalEditedData = finalEditedData
        self.weatherStation = weatherStation
        self.weatherStationFallback = weatherStationFallback
        self.weatherStationSecondFallback = weatherStationSecondFallback
        self.alternativeDataProvider = alternativeDataProvider
        self.synopticDataFallback = synopticDataFallback
        self.adjustmentToFallbackWeatherStation = adjustmentToFallbackWeatherStation
        self.primaryDisruptionFallbacks = primaryDisruptionFallbacks
        self.secondaryDisruptionFallbacks = secondaryDisruptionFallbacks
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WeatherIndexData)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WeatherIndexData.subclass:
            return WeatherIndexData.subclass(*args_, **kwargs_)
        else:
            return WeatherIndexData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_referenceLevel(self): return self.referenceLevel
    def set_referenceLevel(self, referenceLevel): self.referenceLevel = referenceLevel
    def get_dataProvider(self): return self.dataProvider
    def set_dataProvider(self, dataProvider): self.dataProvider = dataProvider
    def get_finalEditedData(self): return self.finalEditedData
    def set_finalEditedData(self, finalEditedData): self.finalEditedData = finalEditedData
    def get_weatherStation(self): return self.weatherStation
    def set_weatherStation(self, weatherStation): self.weatherStation = weatherStation
    def get_weatherStationFallback(self): return self.weatherStationFallback
    def set_weatherStationFallback(self, weatherStationFallback): self.weatherStationFallback = weatherStationFallback
    def get_weatherStationSecondFallback(self): return self.weatherStationSecondFallback
    def set_weatherStationSecondFallback(self, weatherStationSecondFallback): self.weatherStationSecondFallback = weatherStationSecondFallback
    def get_alternativeDataProvider(self): return self.alternativeDataProvider
    def set_alternativeDataProvider(self, alternativeDataProvider): self.alternativeDataProvider = alternativeDataProvider
    def get_synopticDataFallback(self): return self.synopticDataFallback
    def set_synopticDataFallback(self, synopticDataFallback): self.synopticDataFallback = synopticDataFallback
    def get_adjustmentToFallbackWeatherStation(self): return self.adjustmentToFallbackWeatherStation
    def set_adjustmentToFallbackWeatherStation(self, adjustmentToFallbackWeatherStation): self.adjustmentToFallbackWeatherStation = adjustmentToFallbackWeatherStation
    def get_primaryDisruptionFallbacks(self): return self.primaryDisruptionFallbacks
    def set_primaryDisruptionFallbacks(self, primaryDisruptionFallbacks): self.primaryDisruptionFallbacks = primaryDisruptionFallbacks
    def get_secondaryDisruptionFallbacks(self): return self.secondaryDisruptionFallbacks
    def set_secondaryDisruptionFallbacks(self, secondaryDisruptionFallbacks): self.secondaryDisruptionFallbacks = secondaryDisruptionFallbacks
    def hasContent_(self):
        if (
            self.referenceLevel is not None or
            self.dataProvider is not None or
            self.finalEditedData is not None or
            self.weatherStation is not None or
            self.weatherStationFallback is not None or
            self.weatherStationSecondFallback is not None or
            self.alternativeDataProvider is not None or
            self.synopticDataFallback is not None or
            self.adjustmentToFallbackWeatherStation is not None or
            self.primaryDisruptionFallbacks is not None or
            self.secondaryDisruptionFallbacks is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='WeatherIndexData', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WeatherIndexData')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='WeatherIndexData', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='WeatherIndexData'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='WeatherIndexData', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.referenceLevel is not None:
            self.referenceLevel.export(outfile, level, namespace_, name_='referenceLevel', pretty_print=pretty_print)
        if self.dataProvider is not None:
            self.dataProvider.export(outfile, level, namespace_, name_='dataProvider', pretty_print=pretty_print)
        if self.finalEditedData is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfinalEditedData>%s</%sfinalEditedData>%s' % (namespace_, self.gds_format_boolean(self.finalEditedData, input_name='finalEditedData'), namespace_, eol_))
        if self.weatherStation is not None:
            self.weatherStation.export(outfile, level, namespace_, name_='weatherStation', pretty_print=pretty_print)
        if self.weatherStationFallback is not None:
            self.weatherStationFallback.export(outfile, level, namespace_, name_='weatherStationFallback', pretty_print=pretty_print)
        if self.weatherStationSecondFallback is not None:
            self.weatherStationSecondFallback.export(outfile, level, namespace_, name_='weatherStationSecondFallback', pretty_print=pretty_print)
        if self.alternativeDataProvider is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%salternativeDataProvider>%s</%salternativeDataProvider>%s' % (namespace_, self.gds_format_boolean(self.alternativeDataProvider, input_name='alternativeDataProvider'), namespace_, eol_))
        if self.synopticDataFallback is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssynopticDataFallback>%s</%ssynopticDataFallback>%s' % (namespace_, self.gds_format_boolean(self.synopticDataFallback, input_name='synopticDataFallback'), namespace_, eol_))
        if self.adjustmentToFallbackWeatherStation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sadjustmentToFallbackWeatherStation>%s</%sadjustmentToFallbackWeatherStation>%s' % (namespace_, self.gds_format_boolean(self.adjustmentToFallbackWeatherStation, input_name='adjustmentToFallbackWeatherStation'), namespace_, eol_))
        if self.primaryDisruptionFallbacks is not None:
            self.primaryDisruptionFallbacks.export(outfile, level, namespace_, name_='primaryDisruptionFallbacks', pretty_print=pretty_print)
        if self.secondaryDisruptionFallbacks is not None:
            self.secondaryDisruptionFallbacks.export(outfile, level, namespace_, name_='secondaryDisruptionFallbacks', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'referenceLevel':
            obj_ = ReferenceLevel.factory()
            obj_.build(child_)
            self.referenceLevel = obj_
            obj_.original_tagname_ = 'referenceLevel'
        elif nodeName_ == 'dataProvider':
            obj_ = DataProvider.factory()
            obj_.build(child_)
            self.dataProvider = obj_
            obj_.original_tagname_ = 'dataProvider'
        elif nodeName_ == 'finalEditedData':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'finalEditedData')
            self.finalEditedData = ival_
        elif nodeName_ == 'weatherStation':
            obj_ = WeatherStation.factory()
            obj_.build(child_)
            self.weatherStation = obj_
            obj_.original_tagname_ = 'weatherStation'
        elif nodeName_ == 'weatherStationFallback':
            obj_ = WeatherStation.factory()
            obj_.build(child_)
            self.weatherStationFallback = obj_
            obj_.original_tagname_ = 'weatherStationFallback'
        elif nodeName_ == 'weatherStationSecondFallback':
            obj_ = WeatherStation.factory()
            obj_.build(child_)
            self.weatherStationSecondFallback = obj_
            obj_.original_tagname_ = 'weatherStationSecondFallback'
        elif nodeName_ == 'alternativeDataProvider':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'alternativeDataProvider')
            self.alternativeDataProvider = ival_
        elif nodeName_ == 'synopticDataFallback':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'synopticDataFallback')
            self.synopticDataFallback = ival_
        elif nodeName_ == 'adjustmentToFallbackWeatherStation':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'adjustmentToFallbackWeatherStation')
            self.adjustmentToFallbackWeatherStation = ival_
        elif nodeName_ == 'primaryDisruptionFallbacks':
            obj_ = DisruptionFallback.factory()
            obj_.build(child_)
            self.primaryDisruptionFallbacks = obj_
            obj_.original_tagname_ = 'primaryDisruptionFallbacks'
        elif nodeName_ == 'secondaryDisruptionFallbacks':
            obj_ = DisruptionFallback.factory()
            obj_.build(child_)
            self.secondaryDisruptionFallbacks = obj_
            obj_.original_tagname_ = 'secondaryDisruptionFallbacks'
# end class WeatherIndexData


class WeatherLegCalculation(GeneratedsSuper):
    """A type to capture details of the calculation of the Payment Amount
    on a Weather Index Transaction."""
    member_data_items_ = {
        'settlementLevel': MemberSpec_('settlementLevel', ['WeatherSettlementLevelEnum', 'Token', 'xsd:token'], 0),
        'referenceLevelEqualsZero': MemberSpec_('referenceLevelEqualsZero', 'xsd:boolean', 0),
        'calculationDate': MemberSpec_('calculationDate', 'Period', 0),
        'businessDays': MemberSpec_('businessDays', 'BusinessCenter', 0),
        'dataCorrection': MemberSpec_('dataCorrection', 'xsd:boolean', 0),
        'correctionPeriod': MemberSpec_('correctionPeriod', 'Period', 0),
        'maximumPaymentAmount': MemberSpec_('maximumPaymentAmount', 'NonNegativeMoney', 0),
        'maximumTransactionPaymentAmount': MemberSpec_('maximumTransactionPaymentAmount', 'NonNegativeMoney', 0),
        'rounding': MemberSpec_('rounding', 'Rounding', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, settlementLevel=None, referenceLevelEqualsZero=None, calculationDate=None, businessDays=None, dataCorrection=None, correctionPeriod=None, maximumPaymentAmount=None, maximumTransactionPaymentAmount=None, rounding=None):
        self.original_tagname_ = None
        self.settlementLevel = settlementLevel
        self.validate_WeatherSettlementLevelEnum(self.settlementLevel)
        self.referenceLevelEqualsZero = referenceLevelEqualsZero
        self.calculationDate = calculationDate
        self.businessDays = businessDays
        self.dataCorrection = dataCorrection
        self.correctionPeriod = correctionPeriod
        self.maximumPaymentAmount = maximumPaymentAmount
        self.maximumTransactionPaymentAmount = maximumTransactionPaymentAmount
        self.rounding = rounding
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WeatherLegCalculation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WeatherLegCalculation.subclass:
            return WeatherLegCalculation.subclass(*args_, **kwargs_)
        else:
            return WeatherLegCalculation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_settlementLevel(self): return self.settlementLevel
    def set_settlementLevel(self, settlementLevel): self.settlementLevel = settlementLevel
    def get_referenceLevelEqualsZero(self): return self.referenceLevelEqualsZero
    def set_referenceLevelEqualsZero(self, referenceLevelEqualsZero): self.referenceLevelEqualsZero = referenceLevelEqualsZero
    def get_calculationDate(self): return self.calculationDate
    def set_calculationDate(self, calculationDate): self.calculationDate = calculationDate
    def get_businessDays(self): return self.businessDays
    def set_businessDays(self, businessDays): self.businessDays = businessDays
    def get_dataCorrection(self): return self.dataCorrection
    def set_dataCorrection(self, dataCorrection): self.dataCorrection = dataCorrection
    def get_correctionPeriod(self): return self.correctionPeriod
    def set_correctionPeriod(self, correctionPeriod): self.correctionPeriod = correctionPeriod
    def get_maximumPaymentAmount(self): return self.maximumPaymentAmount
    def set_maximumPaymentAmount(self, maximumPaymentAmount): self.maximumPaymentAmount = maximumPaymentAmount
    def get_maximumTransactionPaymentAmount(self): return self.maximumTransactionPaymentAmount
    def set_maximumTransactionPaymentAmount(self, maximumTransactionPaymentAmount): self.maximumTransactionPaymentAmount = maximumTransactionPaymentAmount
    def get_rounding(self): return self.rounding
    def set_rounding(self, rounding): self.rounding = rounding
    def validate_WeatherSettlementLevelEnum(self, value):
        # Validate type WeatherSettlementLevelEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Cumulative', 'Average', 'Mximum', 'Minimum']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on WeatherSettlementLevelEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on WeatherSettlementLevelEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.settlementLevel is not None or
            self.referenceLevelEqualsZero is not None or
            self.calculationDate is not None or
            self.businessDays is not None or
            self.dataCorrection is not None or
            self.correctionPeriod is not None or
            self.maximumPaymentAmount is not None or
            self.maximumTransactionPaymentAmount is not None or
            self.rounding is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='WeatherLegCalculation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WeatherLegCalculation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='WeatherLegCalculation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='WeatherLegCalculation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='WeatherLegCalculation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.settlementLevel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssettlementLevel>%s</%ssettlementLevel>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.settlementLevel), input_name='settlementLevel')), namespace_, eol_))
        if self.referenceLevelEqualsZero is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreferenceLevelEqualsZero>%s</%sreferenceLevelEqualsZero>%s' % (namespace_, self.gds_format_boolean(self.referenceLevelEqualsZero, input_name='referenceLevelEqualsZero'), namespace_, eol_))
        if self.calculationDate is not None:
            self.calculationDate.export(outfile, level, namespace_, name_='calculationDate', pretty_print=pretty_print)
        if self.businessDays is not None:
            self.businessDays.export(outfile, level, namespace_, name_='businessDays', pretty_print=pretty_print)
        if self.dataCorrection is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdataCorrection>%s</%sdataCorrection>%s' % (namespace_, self.gds_format_boolean(self.dataCorrection, input_name='dataCorrection'), namespace_, eol_))
        if self.correctionPeriod is not None:
            self.correctionPeriod.export(outfile, level, namespace_, name_='correctionPeriod', pretty_print=pretty_print)
        if self.maximumPaymentAmount is not None:
            self.maximumPaymentAmount.export(outfile, level, namespace_, name_='maximumPaymentAmount', pretty_print=pretty_print)
        if self.maximumTransactionPaymentAmount is not None:
            self.maximumTransactionPaymentAmount.export(outfile, level, namespace_, name_='maximumTransactionPaymentAmount', pretty_print=pretty_print)
        if self.rounding is not None:
            self.rounding.export(outfile, level, namespace_, name_='rounding', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'settlementLevel':
            settlementLevel_ = child_.text
            settlementLevel_ = re_.sub(String_cleanup_pat_, " ", settlementLevel_).strip()
            settlementLevel_ = self.gds_validate_string(settlementLevel_, node, 'settlementLevel')
            self.settlementLevel = settlementLevel_
            # validate type WeatherSettlementLevelEnum
            self.validate_WeatherSettlementLevelEnum(self.settlementLevel)
        elif nodeName_ == 'referenceLevelEqualsZero':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'referenceLevelEqualsZero')
            self.referenceLevelEqualsZero = ival_
        elif nodeName_ == 'calculationDate':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.calculationDate = obj_
            obj_.original_tagname_ = 'calculationDate'
        elif nodeName_ == 'businessDays':
            obj_ = BusinessCenter.factory()
            obj_.build(child_)
            self.businessDays = obj_
            obj_.original_tagname_ = 'businessDays'
        elif nodeName_ == 'dataCorrection':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'dataCorrection')
            self.dataCorrection = ival_
        elif nodeName_ == 'correctionPeriod':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.correctionPeriod = obj_
            obj_.original_tagname_ = 'correctionPeriod'
        elif nodeName_ == 'maximumPaymentAmount':
            class_obj_ = self.get_class_obj_(child_, NonNegativeMoney)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.maximumPaymentAmount = obj_
            obj_.original_tagname_ = 'maximumPaymentAmount'
        elif nodeName_ == 'maximumTransactionPaymentAmount':
            class_obj_ = self.get_class_obj_(child_, NonNegativeMoney)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.maximumTransactionPaymentAmount = obj_
            obj_.original_tagname_ = 'maximumTransactionPaymentAmount'
        elif nodeName_ == 'rounding':
            obj_ = Rounding.factory()
            obj_.build(child_)
            self.rounding = obj_
            obj_.original_tagname_ = 'rounding'
# end class WeatherLegCalculation


class WeatherStation(GeneratedsSuper):
    """Weather Station."""
    member_data_items_ = {
        'weatherStationCity': MemberSpec_('weatherStationCity', 'BusinessCenter', 0),
        'weatherStationAirport': MemberSpec_('weatherStationAirport', 'WeatherStationAirport', 0),
        'weatherStationWBAN': MemberSpec_('weatherStationWBAN', 'WeatherStationWBAN', 0),
        'weatherStationWMO': MemberSpec_('weatherStationWMO', 'WeatherStationWMO', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, weatherStationCity=None, weatherStationAirport=None, weatherStationWBAN=None, weatherStationWMO=None):
        self.original_tagname_ = None
        self.weatherStationCity = weatherStationCity
        self.weatherStationAirport = weatherStationAirport
        self.weatherStationWBAN = weatherStationWBAN
        self.weatherStationWMO = weatherStationWMO
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WeatherStation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WeatherStation.subclass:
            return WeatherStation.subclass(*args_, **kwargs_)
        else:
            return WeatherStation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_weatherStationCity(self): return self.weatherStationCity
    def set_weatherStationCity(self, weatherStationCity): self.weatherStationCity = weatherStationCity
    def get_weatherStationAirport(self): return self.weatherStationAirport
    def set_weatherStationAirport(self, weatherStationAirport): self.weatherStationAirport = weatherStationAirport
    def get_weatherStationWBAN(self): return self.weatherStationWBAN
    def set_weatherStationWBAN(self, weatherStationWBAN): self.weatherStationWBAN = weatherStationWBAN
    def get_weatherStationWMO(self): return self.weatherStationWMO
    def set_weatherStationWMO(self, weatherStationWMO): self.weatherStationWMO = weatherStationWMO
    def hasContent_(self):
        if (
            self.weatherStationCity is not None or
            self.weatherStationAirport is not None or
            self.weatherStationWBAN is not None or
            self.weatherStationWMO is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='WeatherStation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WeatherStation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='WeatherStation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='WeatherStation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='WeatherStation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.weatherStationCity is not None:
            self.weatherStationCity.export(outfile, level, namespace_, name_='weatherStationCity', pretty_print=pretty_print)
        if self.weatherStationAirport is not None:
            self.weatherStationAirport.export(outfile, level, namespace_, name_='weatherStationAirport', pretty_print=pretty_print)
        if self.weatherStationWBAN is not None:
            self.weatherStationWBAN.export(outfile, level, namespace_, name_='weatherStationWBAN', pretty_print=pretty_print)
        if self.weatherStationWMO is not None:
            self.weatherStationWMO.export(outfile, level, namespace_, name_='weatherStationWMO', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'weatherStationCity':
            obj_ = BusinessCenter.factory()
            obj_.build(child_)
            self.weatherStationCity = obj_
            obj_.original_tagname_ = 'weatherStationCity'
        elif nodeName_ == 'weatherStationAirport':
            obj_ = WeatherStationAirport.factory()
            obj_.build(child_)
            self.weatherStationAirport = obj_
            obj_.original_tagname_ = 'weatherStationAirport'
        elif nodeName_ == 'weatherStationWBAN':
            obj_ = WeatherStationWBAN.factory()
            obj_.build(child_)
            self.weatherStationWBAN = obj_
            obj_.original_tagname_ = 'weatherStationWBAN'
        elif nodeName_ == 'weatherStationWMO':
            obj_ = WeatherStationWMO.factory()
            obj_.build(child_)
            self.weatherStationWMO = obj_
            obj_.original_tagname_ = 'weatherStationWMO'
# end class WeatherStation


class WeatherStationAirport(GeneratedsSuper):
    """A code identifying a Weather Station Airport (based on the the IATA
    standard)."""
    member_data_items_ = {
        'weatherStationAirportScheme': MemberSpec_('weatherStationAirportScheme', 'NonEmptyURI', 0),
        'id': MemberSpec_('id', 'xsd:string', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, weatherStationAirportScheme='http://www.fpml.org/coding-scheme/external/weather-station-airport', id=None, valueOf_=None):
        self.original_tagname_ = None
        self.weatherStationAirportScheme = _cast(None, weatherStationAirportScheme)
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WeatherStationAirport)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WeatherStationAirport.subclass:
            return WeatherStationAirport.subclass(*args_, **kwargs_)
        else:
            return WeatherStationAirport(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_weatherStationAirportScheme(self): return self.weatherStationAirportScheme
    def set_weatherStationAirportScheme(self, weatherStationAirportScheme): self.weatherStationAirportScheme = weatherStationAirportScheme
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='WeatherStationAirport', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WeatherStationAirport')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='WeatherStationAirport', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='WeatherStationAirport'):
        if self.weatherStationAirportScheme != "http://www.fpml.org/coding-scheme/external/weather-station-airport" and 'weatherStationAirportScheme' not in already_processed:
            already_processed.add('weatherStationAirportScheme')
            outfile.write(' weatherStationAirportScheme=%s' % (quote_attrib(self.weatherStationAirportScheme), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='WeatherStationAirport', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('weatherStationAirportScheme', node)
        if value is not None and 'weatherStationAirportScheme' not in already_processed:
            already_processed.add('weatherStationAirportScheme')
            self.weatherStationAirportScheme = value
            self.validate_NonEmptyURI(self.weatherStationAirportScheme)    # validate type NonEmptyURI
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WeatherStationAirport


class WeatherStationWBAN(GeneratedsSuper):
    """A code identifying a Weather Station WBAN."""
    member_data_items_ = {
        'weatherStationWBANScheme': MemberSpec_('weatherStationWBANScheme', 'NonEmptyURI', 0),
        'id': MemberSpec_('id', 'xsd:string', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, weatherStationWBANScheme='http://www.fpml.org/coding-scheme/external/weather-station-wban', id=None, valueOf_=None):
        self.original_tagname_ = None
        self.weatherStationWBANScheme = _cast(None, weatherStationWBANScheme)
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WeatherStationWBAN)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WeatherStationWBAN.subclass:
            return WeatherStationWBAN.subclass(*args_, **kwargs_)
        else:
            return WeatherStationWBAN(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_weatherStationWBANScheme(self): return self.weatherStationWBANScheme
    def set_weatherStationWBANScheme(self, weatherStationWBANScheme): self.weatherStationWBANScheme = weatherStationWBANScheme
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='WeatherStationWBAN', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WeatherStationWBAN')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='WeatherStationWBAN', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='WeatherStationWBAN'):
        if self.weatherStationWBANScheme != "http://www.fpml.org/coding-scheme/external/weather-station-wban" and 'weatherStationWBANScheme' not in already_processed:
            already_processed.add('weatherStationWBANScheme')
            outfile.write(' weatherStationWBANScheme=%s' % (quote_attrib(self.weatherStationWBANScheme), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='WeatherStationWBAN', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('weatherStationWBANScheme', node)
        if value is not None and 'weatherStationWBANScheme' not in already_processed:
            already_processed.add('weatherStationWBANScheme')
            self.weatherStationWBANScheme = value
            self.validate_NonEmptyURI(self.weatherStationWBANScheme)    # validate type NonEmptyURI
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WeatherStationWBAN


class WeatherStationWMO(GeneratedsSuper):
    """A code identifying a Weather Index WMO."""
    member_data_items_ = {
        'weatherStationWMOScheme': MemberSpec_('weatherStationWMOScheme', 'NonEmptyURI', 0),
        'id': MemberSpec_('id', 'xsd:string', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, weatherStationWMOScheme='http://www.fpml.org/coding-scheme/external/weather-station-wmo', id=None, valueOf_=None):
        self.original_tagname_ = None
        self.weatherStationWMOScheme = _cast(None, weatherStationWMOScheme)
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WeatherStationWMO)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WeatherStationWMO.subclass:
            return WeatherStationWMO.subclass(*args_, **kwargs_)
        else:
            return WeatherStationWMO(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_weatherStationWMOScheme(self): return self.weatherStationWMOScheme
    def set_weatherStationWMOScheme(self, weatherStationWMOScheme): self.weatherStationWMOScheme = weatherStationWMOScheme
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='WeatherStationWMO', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WeatherStationWMO')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='WeatherStationWMO', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='WeatherStationWMO'):
        if self.weatherStationWMOScheme != "http://www.fpml.org/coding-scheme/external/weather-station-wmo" and 'weatherStationWMOScheme' not in already_processed:
            already_processed.add('weatherStationWMOScheme')
            outfile.write(' weatherStationWMOScheme=%s' % (quote_attrib(self.weatherStationWMOScheme), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='WeatherStationWMO', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('weatherStationWMOScheme', node)
        if value is not None and 'weatherStationWMOScheme' not in already_processed:
            already_processed.add('weatherStationWMOScheme')
            self.weatherStationWMOScheme = value
            self.validate_NonEmptyURI(self.weatherStationWMOScheme)    # validate type NonEmptyURI
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WeatherStationWMO


class Asian(GeneratedsSuper):
    """As per ISDA 2002 Definitions."""
    member_data_items_ = {
        'averagingInOut': MemberSpec_('averagingInOut', ['AveragingInOutEnum', 'Token', 'xsd:token'], 0),
        'strikeFactor': MemberSpec_('strikeFactor', 'xsd:decimal', 0),
        'averagingPeriodIn': MemberSpec_('averagingPeriodIn', 'AveragingPeriod', 0),
        'averagingPeriodOut': MemberSpec_('averagingPeriodOut', 'AveragingPeriod', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, averagingInOut=None, strikeFactor=None, averagingPeriodIn=None, averagingPeriodOut=None):
        self.original_tagname_ = None
        self.averagingInOut = averagingInOut
        self.validate_AveragingInOutEnum(self.averagingInOut)
        self.strikeFactor = strikeFactor
        self.averagingPeriodIn = averagingPeriodIn
        self.averagingPeriodOut = averagingPeriodOut
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Asian)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Asian.subclass:
            return Asian.subclass(*args_, **kwargs_)
        else:
            return Asian(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_averagingInOut(self): return self.averagingInOut
    def set_averagingInOut(self, averagingInOut): self.averagingInOut = averagingInOut
    def get_strikeFactor(self): return self.strikeFactor
    def set_strikeFactor(self, strikeFactor): self.strikeFactor = strikeFactor
    def get_averagingPeriodIn(self): return self.averagingPeriodIn
    def set_averagingPeriodIn(self, averagingPeriodIn): self.averagingPeriodIn = averagingPeriodIn
    def get_averagingPeriodOut(self): return self.averagingPeriodOut
    def set_averagingPeriodOut(self, averagingPeriodOut): self.averagingPeriodOut = averagingPeriodOut
    def validate_AveragingInOutEnum(self, value):
        # Validate type AveragingInOutEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['In', 'Out', 'Both']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AveragingInOutEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on AveragingInOutEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.averagingInOut is not None or
            self.strikeFactor is not None or
            self.averagingPeriodIn is not None or
            self.averagingPeriodOut is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Asian', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Asian')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Asian', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Asian'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Asian', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.averagingInOut is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saveragingInOut>%s</%saveragingInOut>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.averagingInOut), input_name='averagingInOut')), namespace_, eol_))
        if self.strikeFactor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstrikeFactor>%s</%sstrikeFactor>%s' % (namespace_, self.gds_format_float(self.strikeFactor, input_name='strikeFactor'), namespace_, eol_))
        if self.averagingPeriodIn is not None:
            self.averagingPeriodIn.export(outfile, level, namespace_, name_='averagingPeriodIn', pretty_print=pretty_print)
        if self.averagingPeriodOut is not None:
            self.averagingPeriodOut.export(outfile, level, namespace_, name_='averagingPeriodOut', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'averagingInOut':
            averagingInOut_ = child_.text
            averagingInOut_ = re_.sub(String_cleanup_pat_, " ", averagingInOut_).strip()
            averagingInOut_ = self.gds_validate_string(averagingInOut_, node, 'averagingInOut')
            self.averagingInOut = averagingInOut_
            # validate type AveragingInOutEnum
            self.validate_AveragingInOutEnum(self.averagingInOut)
        elif nodeName_ == 'strikeFactor':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'strikeFactor')
            self.strikeFactor = fval_
        elif nodeName_ == 'averagingPeriodIn':
            obj_ = AveragingPeriod.factory()
            obj_.build(child_)
            self.averagingPeriodIn = obj_
            obj_.original_tagname_ = 'averagingPeriodIn'
        elif nodeName_ == 'averagingPeriodOut':
            obj_ = AveragingPeriod.factory()
            obj_.build(child_)
            self.averagingPeriodOut = obj_
            obj_.original_tagname_ = 'averagingPeriodOut'
# end class Asian


class AveragingObservationList(GeneratedsSuper):
    """An un ordered list of weighted averaging observations."""
    member_data_items_ = {
        'averagingObservation': MemberSpec_('averagingObservation', 'WeightedAveragingObservation', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, averagingObservation=None):
        self.original_tagname_ = None
        if averagingObservation is None:
            self.averagingObservation = []
        else:
            self.averagingObservation = averagingObservation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AveragingObservationList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AveragingObservationList.subclass:
            return AveragingObservationList.subclass(*args_, **kwargs_)
        else:
            return AveragingObservationList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_averagingObservation(self): return self.averagingObservation
    def set_averagingObservation(self, averagingObservation): self.averagingObservation = averagingObservation
    def add_averagingObservation(self, value): self.averagingObservation.append(value)
    def insert_averagingObservation_at(self, index, value): self.averagingObservation.insert(index, value)
    def replace_averagingObservation_at(self, index, value): self.averagingObservation[index] = value
    def hasContent_(self):
        if (
            self.averagingObservation
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AveragingObservationList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AveragingObservationList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AveragingObservationList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AveragingObservationList'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AveragingObservationList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for averagingObservation_ in self.averagingObservation:
            averagingObservation_.export(outfile, level, namespace_, name_='averagingObservation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'averagingObservation':
            obj_ = WeightedAveragingObservation.factory()
            obj_.build(child_)
            self.averagingObservation.append(obj_)
            obj_.original_tagname_ = 'averagingObservation'
# end class AveragingObservationList


class AveragingPeriod(GeneratedsSuper):
    """Period over which an average value is taken.A choice between
    unweighted and weighted averaging date and times."""
    member_data_items_ = {
        'schedule': MemberSpec_('schedule', 'AveragingSchedule', 1),
        'averagingDateTimes': MemberSpec_('averagingDateTimes', 'DateTimeList', 0),
        'averagingObservations': MemberSpec_('averagingObservations', 'AveragingObservationList', 0),
        'marketDisruption': MemberSpec_('marketDisruption', 'MarketDisruption', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, schedule=None, averagingDateTimes=None, averagingObservations=None, marketDisruption=None):
        self.original_tagname_ = None
        if schedule is None:
            self.schedule = []
        else:
            self.schedule = schedule
        self.averagingDateTimes = averagingDateTimes
        self.averagingObservations = averagingObservations
        self.marketDisruption = marketDisruption
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AveragingPeriod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AveragingPeriod.subclass:
            return AveragingPeriod.subclass(*args_, **kwargs_)
        else:
            return AveragingPeriod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_schedule(self): return self.schedule
    def set_schedule(self, schedule): self.schedule = schedule
    def add_schedule(self, value): self.schedule.append(value)
    def insert_schedule_at(self, index, value): self.schedule.insert(index, value)
    def replace_schedule_at(self, index, value): self.schedule[index] = value
    def get_averagingDateTimes(self): return self.averagingDateTimes
    def set_averagingDateTimes(self, averagingDateTimes): self.averagingDateTimes = averagingDateTimes
    def get_averagingObservations(self): return self.averagingObservations
    def set_averagingObservations(self, averagingObservations): self.averagingObservations = averagingObservations
    def get_marketDisruption(self): return self.marketDisruption
    def set_marketDisruption(self, marketDisruption): self.marketDisruption = marketDisruption
    def hasContent_(self):
        if (
            self.schedule or
            self.averagingDateTimes is not None or
            self.averagingObservations is not None or
            self.marketDisruption is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AveragingPeriod', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AveragingPeriod')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AveragingPeriod', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AveragingPeriod'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AveragingPeriod', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for schedule_ in self.schedule:
            schedule_.export(outfile, level, namespace_, name_='schedule', pretty_print=pretty_print)
        if self.averagingDateTimes is not None:
            self.averagingDateTimes.export(outfile, level, namespace_, name_='averagingDateTimes', pretty_print=pretty_print)
        if self.averagingObservations is not None:
            self.averagingObservations.export(outfile, level, namespace_, name_='averagingObservations', pretty_print=pretty_print)
        if self.marketDisruption is not None:
            self.marketDisruption.export(outfile, level, namespace_, name_='marketDisruption', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'schedule':
            obj_ = AveragingSchedule.factory()
            obj_.build(child_)
            self.schedule.append(obj_)
            obj_.original_tagname_ = 'schedule'
        elif nodeName_ == 'averagingDateTimes':
            obj_ = DateTimeList.factory()
            obj_.build(child_)
            self.averagingDateTimes = obj_
            obj_.original_tagname_ = 'averagingDateTimes'
        elif nodeName_ == 'averagingObservations':
            obj_ = AveragingObservationList.factory()
            obj_.build(child_)
            self.averagingObservations = obj_
            obj_.original_tagname_ = 'averagingObservations'
        elif nodeName_ == 'marketDisruption':
            obj_ = MarketDisruption.factory()
            obj_.build(child_)
            self.marketDisruption = obj_
            obj_.original_tagname_ = 'marketDisruption'
# end class AveragingPeriod


class AveragingSchedule(GeneratedsSuper):
    """Method of generating a series of dates."""
    member_data_items_ = {
        'startDate': MemberSpec_('startDate', 'xsd:date', 0),
        'endDate': MemberSpec_('endDate', 'xsd:date', 0),
        'averagingPeriodFrequency': MemberSpec_('averagingPeriodFrequency', 'CalculationPeriodFrequency', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, startDate=None, endDate=None, averagingPeriodFrequency=None):
        self.original_tagname_ = None
        if isinstance(startDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(startDate, '%Y-%m-%d').date()
        else:
            initvalue_ = startDate
        self.startDate = initvalue_
        if isinstance(endDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(endDate, '%Y-%m-%d').date()
        else:
            initvalue_ = endDate
        self.endDate = initvalue_
        self.averagingPeriodFrequency = averagingPeriodFrequency
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AveragingSchedule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AveragingSchedule.subclass:
            return AveragingSchedule.subclass(*args_, **kwargs_)
        else:
            return AveragingSchedule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_startDate(self): return self.startDate
    def set_startDate(self, startDate): self.startDate = startDate
    def get_endDate(self): return self.endDate
    def set_endDate(self, endDate): self.endDate = endDate
    def get_averagingPeriodFrequency(self): return self.averagingPeriodFrequency
    def set_averagingPeriodFrequency(self, averagingPeriodFrequency): self.averagingPeriodFrequency = averagingPeriodFrequency
    def hasContent_(self):
        if (
            self.startDate is not None or
            self.endDate is not None or
            self.averagingPeriodFrequency is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AveragingSchedule', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AveragingSchedule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AveragingSchedule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AveragingSchedule'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AveragingSchedule', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.startDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstartDate>%s</%sstartDate>%s' % (namespace_, self.gds_format_date(self.startDate, input_name='startDate'), namespace_, eol_))
        if self.endDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sendDate>%s</%sendDate>%s' % (namespace_, self.gds_format_date(self.endDate, input_name='endDate'), namespace_, eol_))
        if self.averagingPeriodFrequency is not None:
            self.averagingPeriodFrequency.export(outfile, level, namespace_, name_='averagingPeriodFrequency', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'startDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.startDate = dval_
        elif nodeName_ == 'endDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.endDate = dval_
        elif nodeName_ == 'averagingPeriodFrequency':
            obj_ = CalculationPeriodFrequency.factory()
            obj_.build(child_)
            self.averagingPeriodFrequency = obj_
            obj_.original_tagname_ = 'averagingPeriodFrequency'
# end class AveragingSchedule


class Barrier(GeneratedsSuper):
    """As per ISDA 2002 Definitions."""
    member_data_items_ = {
        'barrierCap': MemberSpec_('barrierCap', 'TriggerEvent', 0),
        'barrierFloor': MemberSpec_('barrierFloor', 'TriggerEvent', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, barrierCap=None, barrierFloor=None):
        self.original_tagname_ = None
        self.barrierCap = barrierCap
        self.barrierFloor = barrierFloor
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Barrier)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Barrier.subclass:
            return Barrier.subclass(*args_, **kwargs_)
        else:
            return Barrier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_barrierCap(self): return self.barrierCap
    def set_barrierCap(self, barrierCap): self.barrierCap = barrierCap
    def get_barrierFloor(self): return self.barrierFloor
    def set_barrierFloor(self, barrierFloor): self.barrierFloor = barrierFloor
    def hasContent_(self):
        if (
            self.barrierCap is not None or
            self.barrierFloor is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Barrier', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Barrier')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Barrier', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Barrier'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Barrier', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.barrierCap is not None:
            self.barrierCap.export(outfile, level, namespace_, name_='barrierCap', pretty_print=pretty_print)
        if self.barrierFloor is not None:
            self.barrierFloor.export(outfile, level, namespace_, name_='barrierFloor', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'barrierCap':
            obj_ = TriggerEvent.factory()
            obj_.build(child_)
            self.barrierCap = obj_
            obj_.original_tagname_ = 'barrierCap'
        elif nodeName_ == 'barrierFloor':
            obj_ = TriggerEvent.factory()
            obj_.build(child_)
            self.barrierFloor = obj_
            obj_.original_tagname_ = 'barrierFloor'
# end class Barrier


class CalendarSpread(GeneratedsSuper):
    """A type for defining a calendar spread feature."""
    member_data_items_ = {
        'expirationDateTwo': MemberSpec_('expirationDateTwo', 'AdjustableOrRelativeDate', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, expirationDateTwo=None):
        self.original_tagname_ = None
        self.expirationDateTwo = expirationDateTwo
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CalendarSpread)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CalendarSpread.subclass:
            return CalendarSpread.subclass(*args_, **kwargs_)
        else:
            return CalendarSpread(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_expirationDateTwo(self): return self.expirationDateTwo
    def set_expirationDateTwo(self, expirationDateTwo): self.expirationDateTwo = expirationDateTwo
    def hasContent_(self):
        if (
            self.expirationDateTwo is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CalendarSpread', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CalendarSpread')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CalendarSpread', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CalendarSpread'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CalendarSpread', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.expirationDateTwo is not None:
            self.expirationDateTwo.export(outfile, level, namespace_, name_='expirationDateTwo', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'expirationDateTwo':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.expirationDateTwo = obj_
            obj_.original_tagname_ = 'expirationDateTwo'
# end class CalendarSpread


class Composite(GeneratedsSuper):
    """Specifies the conditions to be applied for converting into a
    reference currency when the actual currency rate is not
    determined upfront."""
    member_data_items_ = {
        'determinationMethod': MemberSpec_('determinationMethod', 'DeterminationMethod', 0),
        'relativeDate': MemberSpec_('relativeDate', 'RelativeDateOffset', 0),
        'fxSpotRateSource': MemberSpec_('fxSpotRateSource', 'FxSpotRateSource', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, determinationMethod=None, relativeDate=None, fxSpotRateSource=None):
        self.original_tagname_ = None
        self.determinationMethod = determinationMethod
        self.relativeDate = relativeDate
        self.fxSpotRateSource = fxSpotRateSource
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Composite)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Composite.subclass:
            return Composite.subclass(*args_, **kwargs_)
        else:
            return Composite(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_determinationMethod(self): return self.determinationMethod
    def set_determinationMethod(self, determinationMethod): self.determinationMethod = determinationMethod
    def get_relativeDate(self): return self.relativeDate
    def set_relativeDate(self, relativeDate): self.relativeDate = relativeDate
    def get_fxSpotRateSource(self): return self.fxSpotRateSource
    def set_fxSpotRateSource(self, fxSpotRateSource): self.fxSpotRateSource = fxSpotRateSource
    def hasContent_(self):
        if (
            self.determinationMethod is not None or
            self.relativeDate is not None or
            self.fxSpotRateSource is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Composite', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Composite')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Composite', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Composite'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Composite', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.determinationMethod is not None:
            self.determinationMethod.export(outfile, level, namespace_, name_='determinationMethod', pretty_print=pretty_print)
        if self.relativeDate is not None:
            self.relativeDate.export(outfile, level, namespace_, name_='relativeDate', pretty_print=pretty_print)
        if self.fxSpotRateSource is not None:
            self.fxSpotRateSource.export(outfile, level, namespace_, name_='fxSpotRateSource', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'determinationMethod':
            obj_ = DeterminationMethod.factory()
            obj_.build(child_)
            self.determinationMethod = obj_
            obj_.original_tagname_ = 'determinationMethod'
        elif nodeName_ == 'relativeDate':
            class_obj_ = self.get_class_obj_(child_, RelativeDateOffset)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.relativeDate = obj_
            obj_.original_tagname_ = 'relativeDate'
        elif nodeName_ == 'fxSpotRateSource':
            obj_ = FxSpotRateSource.factory()
            obj_.build(child_)
            self.fxSpotRateSource = obj_
            obj_.original_tagname_ = 'fxSpotRateSource'
# end class Composite


class CreditEventNotice(GeneratedsSuper):
    member_data_items_ = {
        'notifyingParty': MemberSpec_('notifyingParty', 'NotifyingParty', 0),
        'businessCenter': MemberSpec_('businessCenter', 'BusinessCenter', 0),
        'publiclyAvailableInformation': MemberSpec_('publiclyAvailableInformation', 'PubliclyAvailableInformation', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, notifyingParty=None, businessCenter=None, publiclyAvailableInformation=None):
        self.original_tagname_ = None
        self.notifyingParty = notifyingParty
        self.businessCenter = businessCenter
        self.publiclyAvailableInformation = publiclyAvailableInformation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditEventNotice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditEventNotice.subclass:
            return CreditEventNotice.subclass(*args_, **kwargs_)
        else:
            return CreditEventNotice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_notifyingParty(self): return self.notifyingParty
    def set_notifyingParty(self, notifyingParty): self.notifyingParty = notifyingParty
    def get_businessCenter(self): return self.businessCenter
    def set_businessCenter(self, businessCenter): self.businessCenter = businessCenter
    def get_publiclyAvailableInformation(self): return self.publiclyAvailableInformation
    def set_publiclyAvailableInformation(self, publiclyAvailableInformation): self.publiclyAvailableInformation = publiclyAvailableInformation
    def hasContent_(self):
        if (
            self.notifyingParty is not None or
            self.businessCenter is not None or
            self.publiclyAvailableInformation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditEventNotice', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditEventNotice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditEventNotice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditEventNotice'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CreditEventNotice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.notifyingParty is not None:
            self.notifyingParty.export(outfile, level, namespace_, name_='notifyingParty', pretty_print=pretty_print)
        if self.businessCenter is not None:
            self.businessCenter.export(outfile, level, namespace_, name_='businessCenter', pretty_print=pretty_print)
        if self.publiclyAvailableInformation is not None:
            self.publiclyAvailableInformation.export(outfile, level, namespace_, name_='publiclyAvailableInformation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'notifyingParty':
            obj_ = NotifyingParty.factory()
            obj_.build(child_)
            self.notifyingParty = obj_
            obj_.original_tagname_ = 'notifyingParty'
        elif nodeName_ == 'businessCenter':
            obj_ = BusinessCenter.factory()
            obj_.build(child_)
            self.businessCenter = obj_
            obj_.original_tagname_ = 'businessCenter'
        elif nodeName_ == 'publiclyAvailableInformation':
            obj_ = PubliclyAvailableInformation.factory()
            obj_.build(child_)
            self.publiclyAvailableInformation = obj_
            obj_.original_tagname_ = 'publiclyAvailableInformation'
# end class CreditEventNotice


class CreditEvents(GeneratedsSuper):
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'bankruptcy': MemberSpec_('bankruptcy', 'xsd:boolean', 0),
        'failureToPay': MemberSpec_('failureToPay', 'FailureToPay', 0),
        'failureToPayPrincipal': MemberSpec_('failureToPayPrincipal', 'xsd:boolean', 0),
        'failureToPayInterest': MemberSpec_('failureToPayInterest', 'xsd:boolean', 0),
        'obligationDefault': MemberSpec_('obligationDefault', 'xsd:boolean', 0),
        'obligationAcceleration': MemberSpec_('obligationAcceleration', 'xsd:boolean', 0),
        'repudiationMoratorium': MemberSpec_('repudiationMoratorium', 'xsd:boolean', 0),
        'restructuring': MemberSpec_('restructuring', 'Restructuring', 0),
        'governmentalIntervention': MemberSpec_('governmentalIntervention', 'xsd:boolean', 0),
        'distressedRatingsDowngrade': MemberSpec_('distressedRatingsDowngrade', 'xsd:boolean', 0),
        'maturityExtension': MemberSpec_('maturityExtension', 'xsd:boolean', 0),
        'writedown': MemberSpec_('writedown', 'xsd:boolean', 0),
        'impliedWritedown': MemberSpec_('impliedWritedown', 'xsd:boolean', 0),
        'defaultRequirement': MemberSpec_('defaultRequirement', 'Money', 0),
        'creditEventNotice': MemberSpec_('creditEventNotice', 'CreditEventNotice', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, bankruptcy=None, failureToPay=None, failureToPayPrincipal=None, failureToPayInterest=None, obligationDefault=None, obligationAcceleration=None, repudiationMoratorium=None, restructuring=None, governmentalIntervention=None, distressedRatingsDowngrade=None, maturityExtension=None, writedown=None, impliedWritedown=None, defaultRequirement=None, creditEventNotice=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.bankruptcy = bankruptcy
        self.failureToPay = failureToPay
        self.failureToPayPrincipal = failureToPayPrincipal
        self.failureToPayInterest = failureToPayInterest
        self.obligationDefault = obligationDefault
        self.obligationAcceleration = obligationAcceleration
        self.repudiationMoratorium = repudiationMoratorium
        self.restructuring = restructuring
        self.governmentalIntervention = governmentalIntervention
        self.distressedRatingsDowngrade = distressedRatingsDowngrade
        self.maturityExtension = maturityExtension
        self.writedown = writedown
        self.impliedWritedown = impliedWritedown
        self.defaultRequirement = defaultRequirement
        self.creditEventNotice = creditEventNotice
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditEvents)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditEvents.subclass:
            return CreditEvents.subclass(*args_, **kwargs_)
        else:
            return CreditEvents(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_bankruptcy(self): return self.bankruptcy
    def set_bankruptcy(self, bankruptcy): self.bankruptcy = bankruptcy
    def get_failureToPay(self): return self.failureToPay
    def set_failureToPay(self, failureToPay): self.failureToPay = failureToPay
    def get_failureToPayPrincipal(self): return self.failureToPayPrincipal
    def set_failureToPayPrincipal(self, failureToPayPrincipal): self.failureToPayPrincipal = failureToPayPrincipal
    def get_failureToPayInterest(self): return self.failureToPayInterest
    def set_failureToPayInterest(self, failureToPayInterest): self.failureToPayInterest = failureToPayInterest
    def get_obligationDefault(self): return self.obligationDefault
    def set_obligationDefault(self, obligationDefault): self.obligationDefault = obligationDefault
    def get_obligationAcceleration(self): return self.obligationAcceleration
    def set_obligationAcceleration(self, obligationAcceleration): self.obligationAcceleration = obligationAcceleration
    def get_repudiationMoratorium(self): return self.repudiationMoratorium
    def set_repudiationMoratorium(self, repudiationMoratorium): self.repudiationMoratorium = repudiationMoratorium
    def get_restructuring(self): return self.restructuring
    def set_restructuring(self, restructuring): self.restructuring = restructuring
    def get_governmentalIntervention(self): return self.governmentalIntervention
    def set_governmentalIntervention(self, governmentalIntervention): self.governmentalIntervention = governmentalIntervention
    def get_distressedRatingsDowngrade(self): return self.distressedRatingsDowngrade
    def set_distressedRatingsDowngrade(self, distressedRatingsDowngrade): self.distressedRatingsDowngrade = distressedRatingsDowngrade
    def get_maturityExtension(self): return self.maturityExtension
    def set_maturityExtension(self, maturityExtension): self.maturityExtension = maturityExtension
    def get_writedown(self): return self.writedown
    def set_writedown(self, writedown): self.writedown = writedown
    def get_impliedWritedown(self): return self.impliedWritedown
    def set_impliedWritedown(self, impliedWritedown): self.impliedWritedown = impliedWritedown
    def get_defaultRequirement(self): return self.defaultRequirement
    def set_defaultRequirement(self, defaultRequirement): self.defaultRequirement = defaultRequirement
    def get_creditEventNotice(self): return self.creditEventNotice
    def set_creditEventNotice(self, creditEventNotice): self.creditEventNotice = creditEventNotice
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.bankruptcy is not None or
            self.failureToPay is not None or
            self.failureToPayPrincipal is not None or
            self.failureToPayInterest is not None or
            self.obligationDefault is not None or
            self.obligationAcceleration is not None or
            self.repudiationMoratorium is not None or
            self.restructuring is not None or
            self.governmentalIntervention is not None or
            self.distressedRatingsDowngrade is not None or
            self.maturityExtension is not None or
            self.writedown is not None or
            self.impliedWritedown is not None or
            self.defaultRequirement is not None or
            self.creditEventNotice is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditEvents', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditEvents')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditEvents', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditEvents'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CreditEvents', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.bankruptcy is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbankruptcy>%s</%sbankruptcy>%s' % (namespace_, self.gds_format_boolean(self.bankruptcy, input_name='bankruptcy'), namespace_, eol_))
        if self.failureToPay is not None:
            self.failureToPay.export(outfile, level, namespace_, name_='failureToPay', pretty_print=pretty_print)
        if self.failureToPayPrincipal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfailureToPayPrincipal>%s</%sfailureToPayPrincipal>%s' % (namespace_, self.gds_format_boolean(self.failureToPayPrincipal, input_name='failureToPayPrincipal'), namespace_, eol_))
        if self.failureToPayInterest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfailureToPayInterest>%s</%sfailureToPayInterest>%s' % (namespace_, self.gds_format_boolean(self.failureToPayInterest, input_name='failureToPayInterest'), namespace_, eol_))
        if self.obligationDefault is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sobligationDefault>%s</%sobligationDefault>%s' % (namespace_, self.gds_format_boolean(self.obligationDefault, input_name='obligationDefault'), namespace_, eol_))
        if self.obligationAcceleration is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sobligationAcceleration>%s</%sobligationAcceleration>%s' % (namespace_, self.gds_format_boolean(self.obligationAcceleration, input_name='obligationAcceleration'), namespace_, eol_))
        if self.repudiationMoratorium is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srepudiationMoratorium>%s</%srepudiationMoratorium>%s' % (namespace_, self.gds_format_boolean(self.repudiationMoratorium, input_name='repudiationMoratorium'), namespace_, eol_))
        if self.restructuring is not None:
            self.restructuring.export(outfile, level, namespace_, name_='restructuring', pretty_print=pretty_print)
        if self.governmentalIntervention is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgovernmentalIntervention>%s</%sgovernmentalIntervention>%s' % (namespace_, self.gds_format_boolean(self.governmentalIntervention, input_name='governmentalIntervention'), namespace_, eol_))
        if self.distressedRatingsDowngrade is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdistressedRatingsDowngrade>%s</%sdistressedRatingsDowngrade>%s' % (namespace_, self.gds_format_boolean(self.distressedRatingsDowngrade, input_name='distressedRatingsDowngrade'), namespace_, eol_))
        if self.maturityExtension is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaturityExtension>%s</%smaturityExtension>%s' % (namespace_, self.gds_format_boolean(self.maturityExtension, input_name='maturityExtension'), namespace_, eol_))
        if self.writedown is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%swritedown>%s</%swritedown>%s' % (namespace_, self.gds_format_boolean(self.writedown, input_name='writedown'), namespace_, eol_))
        if self.impliedWritedown is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%simpliedWritedown>%s</%simpliedWritedown>%s' % (namespace_, self.gds_format_boolean(self.impliedWritedown, input_name='impliedWritedown'), namespace_, eol_))
        if self.defaultRequirement is not None:
            self.defaultRequirement.export(outfile, level, namespace_, name_='defaultRequirement', pretty_print=pretty_print)
        if self.creditEventNotice is not None:
            self.creditEventNotice.export(outfile, level, namespace_, name_='creditEventNotice', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'bankruptcy':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'bankruptcy')
            self.bankruptcy = ival_
        elif nodeName_ == 'failureToPay':
            obj_ = FailureToPay.factory()
            obj_.build(child_)
            self.failureToPay = obj_
            obj_.original_tagname_ = 'failureToPay'
        elif nodeName_ == 'failureToPayPrincipal':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'failureToPayPrincipal')
            self.failureToPayPrincipal = ival_
        elif nodeName_ == 'failureToPayInterest':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'failureToPayInterest')
            self.failureToPayInterest = ival_
        elif nodeName_ == 'obligationDefault':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'obligationDefault')
            self.obligationDefault = ival_
        elif nodeName_ == 'obligationAcceleration':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'obligationAcceleration')
            self.obligationAcceleration = ival_
        elif nodeName_ == 'repudiationMoratorium':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'repudiationMoratorium')
            self.repudiationMoratorium = ival_
        elif nodeName_ == 'restructuring':
            obj_ = Restructuring.factory()
            obj_.build(child_)
            self.restructuring = obj_
            obj_.original_tagname_ = 'restructuring'
        elif nodeName_ == 'governmentalIntervention':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'governmentalIntervention')
            self.governmentalIntervention = ival_
        elif nodeName_ == 'distressedRatingsDowngrade':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'distressedRatingsDowngrade')
            self.distressedRatingsDowngrade = ival_
        elif nodeName_ == 'maturityExtension':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'maturityExtension')
            self.maturityExtension = ival_
        elif nodeName_ == 'writedown':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'writedown')
            self.writedown = ival_
        elif nodeName_ == 'impliedWritedown':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'impliedWritedown')
            self.impliedWritedown = ival_
        elif nodeName_ == 'defaultRequirement':
            class_obj_ = self.get_class_obj_(child_, Money)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.defaultRequirement = obj_
            obj_.original_tagname_ = 'defaultRequirement'
        elif nodeName_ == 'creditEventNotice':
            obj_ = CreditEventNotice.factory()
            obj_.build(child_)
            self.creditEventNotice = obj_
            obj_.original_tagname_ = 'creditEventNotice'
# end class CreditEvents


class FailureToPay(GeneratedsSuper):
    member_data_items_ = {
        'applicable': MemberSpec_('applicable', 'xsd:boolean', 0),
        'gracePeriodExtension': MemberSpec_('gracePeriodExtension', 'GracePeriodExtension', 0),
        'paymentRequirement': MemberSpec_('paymentRequirement', 'Money', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, applicable=None, gracePeriodExtension=None, paymentRequirement=None):
        self.original_tagname_ = None
        self.applicable = applicable
        self.gracePeriodExtension = gracePeriodExtension
        self.paymentRequirement = paymentRequirement
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FailureToPay)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FailureToPay.subclass:
            return FailureToPay.subclass(*args_, **kwargs_)
        else:
            return FailureToPay(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_applicable(self): return self.applicable
    def set_applicable(self, applicable): self.applicable = applicable
    def get_gracePeriodExtension(self): return self.gracePeriodExtension
    def set_gracePeriodExtension(self, gracePeriodExtension): self.gracePeriodExtension = gracePeriodExtension
    def get_paymentRequirement(self): return self.paymentRequirement
    def set_paymentRequirement(self, paymentRequirement): self.paymentRequirement = paymentRequirement
    def hasContent_(self):
        if (
            self.applicable is not None or
            self.gracePeriodExtension is not None or
            self.paymentRequirement is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FailureToPay', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FailureToPay')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FailureToPay', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FailureToPay'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FailureToPay', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.applicable is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sapplicable>%s</%sapplicable>%s' % (namespace_, self.gds_format_boolean(self.applicable, input_name='applicable'), namespace_, eol_))
        if self.gracePeriodExtension is not None:
            self.gracePeriodExtension.export(outfile, level, namespace_, name_='gracePeriodExtension', pretty_print=pretty_print)
        if self.paymentRequirement is not None:
            self.paymentRequirement.export(outfile, level, namespace_, name_='paymentRequirement', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'applicable':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'applicable')
            self.applicable = ival_
        elif nodeName_ == 'gracePeriodExtension':
            obj_ = GracePeriodExtension.factory()
            obj_.build(child_)
            self.gracePeriodExtension = obj_
            obj_.original_tagname_ = 'gracePeriodExtension'
        elif nodeName_ == 'paymentRequirement':
            class_obj_ = self.get_class_obj_(child_, Money)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.paymentRequirement = obj_
            obj_.original_tagname_ = 'paymentRequirement'
# end class FailureToPay


class FxFeature(GeneratedsSuper):
    """A type for defining Fx Features."""
    member_data_items_ = {
        'referenceCurrency': MemberSpec_('referenceCurrency', 'IdentifiedCurrency', 0),
        'composite': MemberSpec_('composite', 'Composite', 0),
        'quanto': MemberSpec_('quanto', 'Quanto', 0),
        'crossCurrency': MemberSpec_('crossCurrency', 'Composite', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, referenceCurrency=None, composite=None, quanto=None, crossCurrency=None):
        self.original_tagname_ = None
        self.referenceCurrency = referenceCurrency
        self.composite = composite
        self.quanto = quanto
        self.crossCurrency = crossCurrency
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FxFeature)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FxFeature.subclass:
            return FxFeature.subclass(*args_, **kwargs_)
        else:
            return FxFeature(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_referenceCurrency(self): return self.referenceCurrency
    def set_referenceCurrency(self, referenceCurrency): self.referenceCurrency = referenceCurrency
    def get_composite(self): return self.composite
    def set_composite(self, composite): self.composite = composite
    def get_quanto(self): return self.quanto
    def set_quanto(self, quanto): self.quanto = quanto
    def get_crossCurrency(self): return self.crossCurrency
    def set_crossCurrency(self, crossCurrency): self.crossCurrency = crossCurrency
    def hasContent_(self):
        if (
            self.referenceCurrency is not None or
            self.composite is not None or
            self.quanto is not None or
            self.crossCurrency is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FxFeature', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FxFeature')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FxFeature', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FxFeature'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FxFeature', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.referenceCurrency is not None:
            self.referenceCurrency.export(outfile, level, namespace_, name_='referenceCurrency', pretty_print=pretty_print)
        if self.composite is not None:
            self.composite.export(outfile, level, namespace_, name_='composite', pretty_print=pretty_print)
        if self.quanto is not None:
            self.quanto.export(outfile, level, namespace_, name_='quanto', pretty_print=pretty_print)
        if self.crossCurrency is not None:
            self.crossCurrency.export(outfile, level, namespace_, name_='crossCurrency', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'referenceCurrency':
            obj_ = IdentifiedCurrency.factory()
            obj_.build(child_)
            self.referenceCurrency = obj_
            obj_.original_tagname_ = 'referenceCurrency'
        elif nodeName_ == 'composite':
            obj_ = Composite.factory()
            obj_.build(child_)
            self.composite = obj_
            obj_.original_tagname_ = 'composite'
        elif nodeName_ == 'quanto':
            obj_ = Quanto.factory()
            obj_.build(child_)
            self.quanto = obj_
            obj_.original_tagname_ = 'quanto'
        elif nodeName_ == 'crossCurrency':
            obj_ = Composite.factory()
            obj_.build(child_)
            self.crossCurrency = obj_
            obj_.original_tagname_ = 'crossCurrency'
# end class FxFeature


class GracePeriodExtension(GeneratedsSuper):
    member_data_items_ = {
        'applicable': MemberSpec_('applicable', 'xsd:boolean', 0),
        'gracePeriod': MemberSpec_('gracePeriod', 'Offset', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, applicable=None, gracePeriod=None):
        self.original_tagname_ = None
        self.applicable = applicable
        self.gracePeriod = gracePeriod
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GracePeriodExtension)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GracePeriodExtension.subclass:
            return GracePeriodExtension.subclass(*args_, **kwargs_)
        else:
            return GracePeriodExtension(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_applicable(self): return self.applicable
    def set_applicable(self, applicable): self.applicable = applicable
    def get_gracePeriod(self): return self.gracePeriod
    def set_gracePeriod(self, gracePeriod): self.gracePeriod = gracePeriod
    def hasContent_(self):
        if (
            self.applicable is not None or
            self.gracePeriod is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GracePeriodExtension', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GracePeriodExtension')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GracePeriodExtension', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GracePeriodExtension'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GracePeriodExtension', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.applicable is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sapplicable>%s</%sapplicable>%s' % (namespace_, self.gds_format_boolean(self.applicable, input_name='applicable'), namespace_, eol_))
        if self.gracePeriod is not None:
            self.gracePeriod.export(outfile, level, namespace_, name_='gracePeriod', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'applicable':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'applicable')
            self.applicable = ival_
        elif nodeName_ == 'gracePeriod':
            class_obj_ = self.get_class_obj_(child_, Offset)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.gracePeriod = obj_
            obj_.original_tagname_ = 'gracePeriod'
# end class GracePeriodExtension


class Knock(GeneratedsSuper):
    """Knock In means option to exercise comes into existence. Knock Out
    means option to exercise goes out of existence."""
    member_data_items_ = {
        'knockIn': MemberSpec_('knockIn', 'TriggerEvent', 0),
        'knockOut': MemberSpec_('knockOut', 'TriggerEvent', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, knockIn=None, knockOut=None):
        self.original_tagname_ = None
        self.knockIn = knockIn
        self.knockOut = knockOut
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Knock)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Knock.subclass:
            return Knock.subclass(*args_, **kwargs_)
        else:
            return Knock(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_knockIn(self): return self.knockIn
    def set_knockIn(self, knockIn): self.knockIn = knockIn
    def get_knockOut(self): return self.knockOut
    def set_knockOut(self, knockOut): self.knockOut = knockOut
    def hasContent_(self):
        if (
            self.knockIn is not None or
            self.knockOut is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Knock', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Knock')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Knock', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Knock'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Knock', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.knockIn is not None:
            self.knockIn.export(outfile, level, namespace_, name_='knockIn', pretty_print=pretty_print)
        if self.knockOut is not None:
            self.knockOut.export(outfile, level, namespace_, name_='knockOut', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'knockIn':
            obj_ = TriggerEvent.factory()
            obj_.build(child_)
            self.knockIn = obj_
            obj_.original_tagname_ = 'knockIn'
        elif nodeName_ == 'knockOut':
            obj_ = TriggerEvent.factory()
            obj_.build(child_)
            self.knockOut = obj_
            obj_.original_tagname_ = 'knockOut'
# end class Knock


class MarketDisruption(GeneratedsSuper):
    """Defines the handling of an averaging date market disruption for an
    equity derivative transaction."""
    member_data_items_ = {
        'marketDisruptionScheme': MemberSpec_('marketDisruptionScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, marketDisruptionScheme='http://www.fpml.org/coding-scheme/market-disruption', valueOf_=None):
        self.original_tagname_ = None
        self.marketDisruptionScheme = _cast(None, marketDisruptionScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MarketDisruption)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MarketDisruption.subclass:
            return MarketDisruption.subclass(*args_, **kwargs_)
        else:
            return MarketDisruption(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_marketDisruptionScheme(self): return self.marketDisruptionScheme
    def set_marketDisruptionScheme(self, marketDisruptionScheme): self.marketDisruptionScheme = marketDisruptionScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MarketDisruption', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MarketDisruption')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MarketDisruption', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MarketDisruption'):
        if self.marketDisruptionScheme != "http://www.fpml.org/coding-scheme/market-disruption" and 'marketDisruptionScheme' not in already_processed:
            already_processed.add('marketDisruptionScheme')
            outfile.write(' marketDisruptionScheme=%s' % (quote_attrib(self.marketDisruptionScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MarketDisruption', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('marketDisruptionScheme', node)
        if value is not None and 'marketDisruptionScheme' not in already_processed:
            already_processed.add('marketDisruptionScheme')
            self.marketDisruptionScheme = value
            self.validate_NonEmptyURI(self.marketDisruptionScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MarketDisruption


class NotifyingParty(GeneratedsSuper):
    member_data_items_ = {
        'buyerPartyReference': MemberSpec_('buyerPartyReference', 'PartyReference', 0),
        'sellerPartyReference': MemberSpec_('sellerPartyReference', 'PartyReference', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, buyerPartyReference=None, sellerPartyReference=None):
        self.original_tagname_ = None
        self.buyerPartyReference = buyerPartyReference
        self.sellerPartyReference = sellerPartyReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NotifyingParty)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NotifyingParty.subclass:
            return NotifyingParty.subclass(*args_, **kwargs_)
        else:
            return NotifyingParty(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_buyerPartyReference(self): return self.buyerPartyReference
    def set_buyerPartyReference(self, buyerPartyReference): self.buyerPartyReference = buyerPartyReference
    def get_sellerPartyReference(self): return self.sellerPartyReference
    def set_sellerPartyReference(self, sellerPartyReference): self.sellerPartyReference = sellerPartyReference
    def hasContent_(self):
        if (
            self.buyerPartyReference is not None or
            self.sellerPartyReference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NotifyingParty', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NotifyingParty')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NotifyingParty', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NotifyingParty'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NotifyingParty', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.buyerPartyReference is not None:
            self.buyerPartyReference.export(outfile, level, namespace_, name_='buyerPartyReference', pretty_print=pretty_print)
        if self.sellerPartyReference is not None:
            self.sellerPartyReference.export(outfile, level, namespace_, name_='sellerPartyReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'buyerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.buyerPartyReference = obj_
            obj_.original_tagname_ = 'buyerPartyReference'
        elif nodeName_ == 'sellerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.sellerPartyReference = obj_
            obj_.original_tagname_ = 'sellerPartyReference'
# end class NotifyingParty


class OptionFeature(GeneratedsSuper):
    """A type for defining option features."""
    member_data_items_ = {
        'fxFeature': MemberSpec_('fxFeature', 'FxFeature', 0),
        'strategyFeature': MemberSpec_('strategyFeature', 'StrategyFeature', 0),
        'asian': MemberSpec_('asian', 'Asian', 0),
        'barrier': MemberSpec_('barrier', 'Barrier', 0),
        'knock': MemberSpec_('knock', 'Knock', 0),
        'passThrough': MemberSpec_('passThrough', 'PassThrough', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, fxFeature=None, strategyFeature=None, asian=None, barrier=None, knock=None, passThrough=None):
        self.original_tagname_ = None
        self.fxFeature = fxFeature
        self.strategyFeature = strategyFeature
        self.asian = asian
        self.barrier = barrier
        self.knock = knock
        self.passThrough = passThrough
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OptionFeature)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OptionFeature.subclass:
            return OptionFeature.subclass(*args_, **kwargs_)
        else:
            return OptionFeature(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fxFeature(self): return self.fxFeature
    def set_fxFeature(self, fxFeature): self.fxFeature = fxFeature
    def get_strategyFeature(self): return self.strategyFeature
    def set_strategyFeature(self, strategyFeature): self.strategyFeature = strategyFeature
    def get_asian(self): return self.asian
    def set_asian(self, asian): self.asian = asian
    def get_barrier(self): return self.barrier
    def set_barrier(self, barrier): self.barrier = barrier
    def get_knock(self): return self.knock
    def set_knock(self, knock): self.knock = knock
    def get_passThrough(self): return self.passThrough
    def set_passThrough(self, passThrough): self.passThrough = passThrough
    def hasContent_(self):
        if (
            self.fxFeature is not None or
            self.strategyFeature is not None or
            self.asian is not None or
            self.barrier is not None or
            self.knock is not None or
            self.passThrough is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OptionFeature', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OptionFeature')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OptionFeature', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OptionFeature'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OptionFeature', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.fxFeature is not None:
            self.fxFeature.export(outfile, level, namespace_, name_='fxFeature', pretty_print=pretty_print)
        if self.strategyFeature is not None:
            self.strategyFeature.export(outfile, level, namespace_, name_='strategyFeature', pretty_print=pretty_print)
        if self.asian is not None:
            self.asian.export(outfile, level, namespace_, name_='asian', pretty_print=pretty_print)
        if self.barrier is not None:
            self.barrier.export(outfile, level, namespace_, name_='barrier', pretty_print=pretty_print)
        if self.knock is not None:
            self.knock.export(outfile, level, namespace_, name_='knock', pretty_print=pretty_print)
        if self.passThrough is not None:
            self.passThrough.export(outfile, level, namespace_, name_='passThrough', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fxFeature':
            obj_ = FxFeature.factory()
            obj_.build(child_)
            self.fxFeature = obj_
            obj_.original_tagname_ = 'fxFeature'
        elif nodeName_ == 'strategyFeature':
            obj_ = StrategyFeature.factory()
            obj_.build(child_)
            self.strategyFeature = obj_
            obj_.original_tagname_ = 'strategyFeature'
        elif nodeName_ == 'asian':
            obj_ = Asian.factory()
            obj_.build(child_)
            self.asian = obj_
            obj_.original_tagname_ = 'asian'
        elif nodeName_ == 'barrier':
            obj_ = Barrier.factory()
            obj_.build(child_)
            self.barrier = obj_
            obj_.original_tagname_ = 'barrier'
        elif nodeName_ == 'knock':
            obj_ = Knock.factory()
            obj_.build(child_)
            self.knock = obj_
            obj_.original_tagname_ = 'knock'
        elif nodeName_ == 'passThrough':
            obj_ = PassThrough.factory()
            obj_.build(child_)
            self.passThrough = obj_
            obj_.original_tagname_ = 'passThrough'
# end class OptionFeature


class OptionNumericStrike(GeneratedsSuper):
    """A type for defining the strike price for an option as a numeric
    value without currency."""
    member_data_items_ = {
        'strikePrice': MemberSpec_('strikePrice', 'xsd:decimal', 0),
        'strikePercentage': MemberSpec_('strikePercentage', 'xsd:decimal', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, strikePrice=None, strikePercentage=None, extensiontype_=None):
        self.original_tagname_ = None
        self.strikePrice = strikePrice
        self.strikePercentage = strikePercentage
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OptionNumericStrike)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OptionNumericStrike.subclass:
            return OptionNumericStrike.subclass(*args_, **kwargs_)
        else:
            return OptionNumericStrike(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_strikePrice(self): return self.strikePrice
    def set_strikePrice(self, strikePrice): self.strikePrice = strikePrice
    def get_strikePercentage(self): return self.strikePercentage
    def set_strikePercentage(self, strikePercentage): self.strikePercentage = strikePercentage
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.strikePrice is not None or
            self.strikePercentage is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OptionNumericStrike', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OptionNumericStrike')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OptionNumericStrike', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OptionNumericStrike'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OptionNumericStrike', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.strikePrice is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstrikePrice>%s</%sstrikePrice>%s' % (namespace_, self.gds_format_float(self.strikePrice, input_name='strikePrice'), namespace_, eol_))
        if self.strikePercentage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstrikePercentage>%s</%sstrikePercentage>%s' % (namespace_, self.gds_format_float(self.strikePercentage, input_name='strikePercentage'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'strikePrice':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'strikePrice')
            self.strikePrice = fval_
        elif nodeName_ == 'strikePercentage':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'strikePercentage')
            self.strikePercentage = fval_
# end class OptionNumericStrike


class OptionStrike(OptionNumericStrike):
    """A type for defining the strike price for an equity option. The
    strike price is either: (i) in respect of an index option
    transaction, the level of the relevant index specified or
    otherwise determined in the transaction; or (ii) in respect of a
    share option transaction, the price per share specified or
    otherwise determined in the transaction. This can be expressed
    either as a percentage of notional amount or as an absolute
    value."""
    member_data_items_ = {
        'currency': MemberSpec_('currency', 'Currency', 0),
    }
    subclass = None
    superclass = OptionNumericStrike
    def __init__(self, strikePrice=None, strikePercentage=None, currency=None):
        self.original_tagname_ = None
        super(OptionStrike, self).__init__(strikePrice, strikePercentage, )
        self.currency = currency
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OptionStrike)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OptionStrike.subclass:
            return OptionStrike.subclass(*args_, **kwargs_)
        else:
            return OptionStrike(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def hasContent_(self):
        if (
            self.currency is not None or
            super(OptionStrike, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OptionStrike', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OptionStrike')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OptionStrike', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OptionStrike'):
        super(OptionStrike, self).exportAttributes(outfile, level, already_processed, namespace_, name_='OptionStrike')
    def exportChildren(self, outfile, level, namespace_='', name_='OptionStrike', fromsubclass_=False, pretty_print=True):
        super(OptionStrike, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.currency is not None:
            self.currency.export(outfile, level, namespace_, name_='currency', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(OptionStrike, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'currency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        super(OptionStrike, self).buildChildren(child_, node, nodeName_, True)
# end class OptionStrike


class PassThrough(GeneratedsSuper):
    """Type which contains pass through payments."""
    member_data_items_ = {
        'passThroughItem': MemberSpec_('passThroughItem', 'PassThroughItem', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, passThroughItem=None):
        self.original_tagname_ = None
        if passThroughItem is None:
            self.passThroughItem = []
        else:
            self.passThroughItem = passThroughItem
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PassThrough)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PassThrough.subclass:
            return PassThrough.subclass(*args_, **kwargs_)
        else:
            return PassThrough(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_passThroughItem(self): return self.passThroughItem
    def set_passThroughItem(self, passThroughItem): self.passThroughItem = passThroughItem
    def add_passThroughItem(self, value): self.passThroughItem.append(value)
    def insert_passThroughItem_at(self, index, value): self.passThroughItem.insert(index, value)
    def replace_passThroughItem_at(self, index, value): self.passThroughItem[index] = value
    def hasContent_(self):
        if (
            self.passThroughItem
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PassThrough', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PassThrough')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PassThrough', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PassThrough'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PassThrough', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for passThroughItem_ in self.passThroughItem:
            passThroughItem_.export(outfile, level, namespace_, name_='passThroughItem', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'passThroughItem':
            obj_ = PassThroughItem.factory()
            obj_.build(child_)
            self.passThroughItem.append(obj_)
            obj_.original_tagname_ = 'passThroughItem'
# end class PassThrough


class PassThroughItem(GeneratedsSuper):
    """Type to represent a single pass through payment."""
    member_data_items_ = {
        'payerPartyReference': MemberSpec_('payerPartyReference', 'PartyReference', 0),
        'payerAccountReference': MemberSpec_('payerAccountReference', 'AccountReference', 0),
        'receiverPartyReference': MemberSpec_('receiverPartyReference', 'PartyReference', 0),
        'receiverAccountReference': MemberSpec_('receiverAccountReference', 'AccountReference', 0),
        'underlyerReference': MemberSpec_('underlyerReference', 'AssetReference', 0),
        'passThroughPercentage': MemberSpec_('passThroughPercentage', 'xsd:decimal', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, underlyerReference=None, passThroughPercentage=None):
        self.original_tagname_ = None
        self.payerPartyReference = payerPartyReference
        self.payerAccountReference = payerAccountReference
        self.receiverPartyReference = receiverPartyReference
        self.receiverAccountReference = receiverAccountReference
        self.underlyerReference = underlyerReference
        self.passThroughPercentage = passThroughPercentage
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PassThroughItem)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PassThroughItem.subclass:
            return PassThroughItem.subclass(*args_, **kwargs_)
        else:
            return PassThroughItem(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_payerPartyReference(self): return self.payerPartyReference
    def set_payerPartyReference(self, payerPartyReference): self.payerPartyReference = payerPartyReference
    def get_payerAccountReference(self): return self.payerAccountReference
    def set_payerAccountReference(self, payerAccountReference): self.payerAccountReference = payerAccountReference
    def get_receiverPartyReference(self): return self.receiverPartyReference
    def set_receiverPartyReference(self, receiverPartyReference): self.receiverPartyReference = receiverPartyReference
    def get_receiverAccountReference(self): return self.receiverAccountReference
    def set_receiverAccountReference(self, receiverAccountReference): self.receiverAccountReference = receiverAccountReference
    def get_underlyerReference(self): return self.underlyerReference
    def set_underlyerReference(self, underlyerReference): self.underlyerReference = underlyerReference
    def get_passThroughPercentage(self): return self.passThroughPercentage
    def set_passThroughPercentage(self, passThroughPercentage): self.passThroughPercentage = passThroughPercentage
    def hasContent_(self):
        if (
            self.payerPartyReference is not None or
            self.payerAccountReference is not None or
            self.receiverPartyReference is not None or
            self.receiverAccountReference is not None or
            self.underlyerReference is not None or
            self.passThroughPercentage is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PassThroughItem', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PassThroughItem')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PassThroughItem', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PassThroughItem'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PassThroughItem', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.payerPartyReference is not None:
            self.payerPartyReference.export(outfile, level, namespace_, name_='payerPartyReference', pretty_print=pretty_print)
        if self.payerAccountReference is not None:
            self.payerAccountReference.export(outfile, level, namespace_, name_='payerAccountReference', pretty_print=pretty_print)
        if self.receiverPartyReference is not None:
            self.receiverPartyReference.export(outfile, level, namespace_, name_='receiverPartyReference', pretty_print=pretty_print)
        if self.receiverAccountReference is not None:
            self.receiverAccountReference.export(outfile, level, namespace_, name_='receiverAccountReference', pretty_print=pretty_print)
        if self.underlyerReference is not None:
            self.underlyerReference.export(outfile, level, namespace_, name_='underlyerReference', pretty_print=pretty_print)
        if self.passThroughPercentage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spassThroughPercentage>%s</%spassThroughPercentage>%s' % (namespace_, self.gds_format_float(self.passThroughPercentage, input_name='passThroughPercentage'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'payerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.payerPartyReference = obj_
            obj_.original_tagname_ = 'payerPartyReference'
        elif nodeName_ == 'payerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.payerAccountReference = obj_
            obj_.original_tagname_ = 'payerAccountReference'
        elif nodeName_ == 'receiverPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.receiverPartyReference = obj_
            obj_.original_tagname_ = 'receiverPartyReference'
        elif nodeName_ == 'receiverAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.receiverAccountReference = obj_
            obj_.original_tagname_ = 'receiverAccountReference'
        elif nodeName_ == 'underlyerReference':
            obj_ = AssetReference.factory()
            obj_.build(child_)
            self.underlyerReference = obj_
            obj_.original_tagname_ = 'underlyerReference'
        elif nodeName_ == 'passThroughPercentage':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'passThroughPercentage')
            self.passThroughPercentage = fval_
# end class PassThroughItem


class PubliclyAvailableInformation(GeneratedsSuper):
    member_data_items_ = {
        'standardPublicSources': MemberSpec_('standardPublicSources', 'xsd:boolean', 0),
        'publicSource': MemberSpec_('publicSource', ['String', 'xsd:string'], 1),
        'specifiedNumber': MemberSpec_('specifiedNumber', 'xsd:positiveInteger', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, standardPublicSources=None, publicSource=None, specifiedNumber=None):
        self.original_tagname_ = None
        self.standardPublicSources = standardPublicSources
        if publicSource is None:
            self.publicSource = []
        else:
            self.publicSource = publicSource
        self.specifiedNumber = specifiedNumber
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PubliclyAvailableInformation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PubliclyAvailableInformation.subclass:
            return PubliclyAvailableInformation.subclass(*args_, **kwargs_)
        else:
            return PubliclyAvailableInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_standardPublicSources(self): return self.standardPublicSources
    def set_standardPublicSources(self, standardPublicSources): self.standardPublicSources = standardPublicSources
    def get_publicSource(self): return self.publicSource
    def set_publicSource(self, publicSource): self.publicSource = publicSource
    def add_publicSource(self, value): self.publicSource.append(value)
    def insert_publicSource_at(self, index, value): self.publicSource.insert(index, value)
    def replace_publicSource_at(self, index, value): self.publicSource[index] = value
    def get_specifiedNumber(self): return self.specifiedNumber
    def set_specifiedNumber(self, specifiedNumber): self.specifiedNumber = specifiedNumber
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.standardPublicSources is not None or
            self.publicSource or
            self.specifiedNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PubliclyAvailableInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PubliclyAvailableInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PubliclyAvailableInformation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PubliclyAvailableInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PubliclyAvailableInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.standardPublicSources is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstandardPublicSources>%s</%sstandardPublicSources>%s' % (namespace_, self.gds_format_boolean(self.standardPublicSources, input_name='standardPublicSources'), namespace_, eol_))
        for publicSource_ in self.publicSource:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spublicSource>%s</%spublicSource>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(publicSource_), input_name='publicSource')), namespace_, eol_))
        if self.specifiedNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sspecifiedNumber>%s</%sspecifiedNumber>%s' % (namespace_, self.gds_format_integer(self.specifiedNumber, input_name='specifiedNumber'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'standardPublicSources':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'standardPublicSources')
            self.standardPublicSources = ival_
        elif nodeName_ == 'publicSource':
            publicSource_ = child_.text
            publicSource_ = self.gds_validate_string(publicSource_, node, 'publicSource')
            self.publicSource.append(publicSource_)
            # validate type String
            self.validate_String(self.publicSource[-1])
        elif nodeName_ == 'specifiedNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'specifiedNumber')
            self.specifiedNumber = ival_
# end class PubliclyAvailableInformation


class Quanto(GeneratedsSuper):
    """Determines the currency rate that the seller of the equity amounts
    will apply at each valuation date for converting the respective
    amounts into a currency that is different from the currency
    denomination of the underlyer."""
    member_data_items_ = {
        'fxRate': MemberSpec_('fxRate', 'FxRate', 1),
        'fxSpotRateSource': MemberSpec_('fxSpotRateSource', 'FxSpotRateSource', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, fxRate=None, fxSpotRateSource=None):
        self.original_tagname_ = None
        if fxRate is None:
            self.fxRate = []
        else:
            self.fxRate = fxRate
        self.fxSpotRateSource = fxSpotRateSource
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Quanto)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Quanto.subclass:
            return Quanto.subclass(*args_, **kwargs_)
        else:
            return Quanto(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fxRate(self): return self.fxRate
    def set_fxRate(self, fxRate): self.fxRate = fxRate
    def add_fxRate(self, value): self.fxRate.append(value)
    def insert_fxRate_at(self, index, value): self.fxRate.insert(index, value)
    def replace_fxRate_at(self, index, value): self.fxRate[index] = value
    def get_fxSpotRateSource(self): return self.fxSpotRateSource
    def set_fxSpotRateSource(self, fxSpotRateSource): self.fxSpotRateSource = fxSpotRateSource
    def hasContent_(self):
        if (
            self.fxRate or
            self.fxSpotRateSource is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Quanto', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Quanto')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Quanto', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Quanto'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Quanto', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for fxRate_ in self.fxRate:
            fxRate_.export(outfile, level, namespace_, name_='fxRate', pretty_print=pretty_print)
        if self.fxSpotRateSource is not None:
            self.fxSpotRateSource.export(outfile, level, namespace_, name_='fxSpotRateSource', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fxRate':
            obj_ = FxRate.factory()
            obj_.build(child_)
            self.fxRate.append(obj_)
            obj_.original_tagname_ = 'fxRate'
        elif nodeName_ == 'fxSpotRateSource':
            obj_ = FxSpotRateSource.factory()
            obj_.build(child_)
            self.fxSpotRateSource = obj_
            obj_.original_tagname_ = 'fxSpotRateSource'
# end class Quanto


class Restructuring(GeneratedsSuper):
    member_data_items_ = {
        'applicable': MemberSpec_('applicable', 'xsd:boolean', 0),
        'restructuringType': MemberSpec_('restructuringType', 'RestructuringType', 0),
        'multipleHolderObligation': MemberSpec_('multipleHolderObligation', 'xsd:boolean', 0),
        'multipleCreditEventNotices': MemberSpec_('multipleCreditEventNotices', 'xsd:boolean', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, applicable=None, restructuringType=None, multipleHolderObligation=None, multipleCreditEventNotices=None):
        self.original_tagname_ = None
        self.applicable = applicable
        self.restructuringType = restructuringType
        self.multipleHolderObligation = multipleHolderObligation
        self.multipleCreditEventNotices = multipleCreditEventNotices
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Restructuring)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Restructuring.subclass:
            return Restructuring.subclass(*args_, **kwargs_)
        else:
            return Restructuring(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_applicable(self): return self.applicable
    def set_applicable(self, applicable): self.applicable = applicable
    def get_restructuringType(self): return self.restructuringType
    def set_restructuringType(self, restructuringType): self.restructuringType = restructuringType
    def get_multipleHolderObligation(self): return self.multipleHolderObligation
    def set_multipleHolderObligation(self, multipleHolderObligation): self.multipleHolderObligation = multipleHolderObligation
    def get_multipleCreditEventNotices(self): return self.multipleCreditEventNotices
    def set_multipleCreditEventNotices(self, multipleCreditEventNotices): self.multipleCreditEventNotices = multipleCreditEventNotices
    def hasContent_(self):
        if (
            self.applicable is not None or
            self.restructuringType is not None or
            self.multipleHolderObligation is not None or
            self.multipleCreditEventNotices is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Restructuring', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Restructuring')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Restructuring', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Restructuring'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Restructuring', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.applicable is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sapplicable>%s</%sapplicable>%s' % (namespace_, self.gds_format_boolean(self.applicable, input_name='applicable'), namespace_, eol_))
        if self.restructuringType is not None:
            self.restructuringType.export(outfile, level, namespace_, name_='restructuringType', pretty_print=pretty_print)
        if self.multipleHolderObligation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smultipleHolderObligation>%s</%smultipleHolderObligation>%s' % (namespace_, self.gds_format_boolean(self.multipleHolderObligation, input_name='multipleHolderObligation'), namespace_, eol_))
        if self.multipleCreditEventNotices is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smultipleCreditEventNotices>%s</%smultipleCreditEventNotices>%s' % (namespace_, self.gds_format_boolean(self.multipleCreditEventNotices, input_name='multipleCreditEventNotices'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'applicable':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'applicable')
            self.applicable = ival_
        elif nodeName_ == 'restructuringType':
            obj_ = RestructuringType.factory()
            obj_.build(child_)
            self.restructuringType = obj_
            obj_.original_tagname_ = 'restructuringType'
        elif nodeName_ == 'multipleHolderObligation':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'multipleHolderObligation')
            self.multipleHolderObligation = ival_
        elif nodeName_ == 'multipleCreditEventNotices':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'multipleCreditEventNotices')
            self.multipleCreditEventNotices = ival_
# end class Restructuring


class RestructuringType(GeneratedsSuper):
    member_data_items_ = {
        'restructuringScheme': MemberSpec_('restructuringScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, restructuringScheme='http://www.fpml.org/coding-scheme/restructuring', valueOf_=None):
        self.original_tagname_ = None
        self.restructuringScheme = _cast(None, restructuringScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RestructuringType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RestructuringType.subclass:
            return RestructuringType.subclass(*args_, **kwargs_)
        else:
            return RestructuringType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_restructuringScheme(self): return self.restructuringScheme
    def set_restructuringScheme(self, restructuringScheme): self.restructuringScheme = restructuringScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RestructuringType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RestructuringType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RestructuringType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RestructuringType'):
        if self.restructuringScheme != "http://www.fpml.org/coding-scheme/restructuring" and 'restructuringScheme' not in already_processed:
            already_processed.add('restructuringScheme')
            outfile.write(' restructuringScheme=%s' % (quote_attrib(self.restructuringScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RestructuringType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('restructuringScheme', node)
        if value is not None and 'restructuringScheme' not in already_processed:
            already_processed.add('restructuringScheme')
            self.restructuringScheme = value
            self.validate_NonEmptyURI(self.restructuringScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RestructuringType


class SettlementTerms(GeneratedsSuper):
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'settlementCurrency': MemberSpec_('settlementCurrency', 'Currency', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, settlementCurrency=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.settlementCurrency = settlementCurrency
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SettlementTerms)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SettlementTerms.subclass:
            return SettlementTerms.subclass(*args_, **kwargs_)
        else:
            return SettlementTerms(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_settlementCurrency(self): return self.settlementCurrency
    def set_settlementCurrency(self, settlementCurrency): self.settlementCurrency = settlementCurrency
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.settlementCurrency is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SettlementTerms', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SettlementTerms')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SettlementTerms', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SettlementTerms'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SettlementTerms', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.settlementCurrency is not None:
            self.settlementCurrency.export(outfile, level, namespace_, name_='settlementCurrency', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'settlementCurrency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.settlementCurrency = obj_
            obj_.original_tagname_ = 'settlementCurrency'
# end class SettlementTerms


class StrategyFeature(GeneratedsSuper):
    """A type for definining equity option simple strike or calendar spread
    strategy features."""
    member_data_items_ = {
        'strikeSpread': MemberSpec_('strikeSpread', 'StrikeSpread', 0),
        'calendarSpread': MemberSpec_('calendarSpread', 'CalendarSpread', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, strikeSpread=None, calendarSpread=None):
        self.original_tagname_ = None
        self.strikeSpread = strikeSpread
        self.calendarSpread = calendarSpread
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrategyFeature)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrategyFeature.subclass:
            return StrategyFeature.subclass(*args_, **kwargs_)
        else:
            return StrategyFeature(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_strikeSpread(self): return self.strikeSpread
    def set_strikeSpread(self, strikeSpread): self.strikeSpread = strikeSpread
    def get_calendarSpread(self): return self.calendarSpread
    def set_calendarSpread(self, calendarSpread): self.calendarSpread = calendarSpread
    def hasContent_(self):
        if (
            self.strikeSpread is not None or
            self.calendarSpread is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StrategyFeature', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StrategyFeature')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StrategyFeature', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StrategyFeature'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StrategyFeature', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.strikeSpread is not None:
            self.strikeSpread.export(outfile, level, namespace_, name_='strikeSpread', pretty_print=pretty_print)
        if self.calendarSpread is not None:
            self.calendarSpread.export(outfile, level, namespace_, name_='calendarSpread', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'strikeSpread':
            obj_ = StrikeSpread.factory()
            obj_.build(child_)
            self.strikeSpread = obj_
            obj_.original_tagname_ = 'strikeSpread'
        elif nodeName_ == 'calendarSpread':
            obj_ = CalendarSpread.factory()
            obj_.build(child_)
            self.calendarSpread = obj_
            obj_.original_tagname_ = 'calendarSpread'
# end class StrategyFeature


class StrikeSpread(GeneratedsSuper):
    """A type for defining a strike spread feature."""
    member_data_items_ = {
        'upperStrike': MemberSpec_('upperStrike', 'OptionStrike', 0),
        'upperStrikeNumberOfOptions': MemberSpec_('upperStrikeNumberOfOptions', ['PositiveDecimal', 'xsd:decimal'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, upperStrike=None, upperStrikeNumberOfOptions=None):
        self.original_tagname_ = None
        self.upperStrike = upperStrike
        self.upperStrikeNumberOfOptions = upperStrikeNumberOfOptions
        self.validate_PositiveDecimal(self.upperStrikeNumberOfOptions)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrikeSpread)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrikeSpread.subclass:
            return StrikeSpread.subclass(*args_, **kwargs_)
        else:
            return StrikeSpread(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_upperStrike(self): return self.upperStrike
    def set_upperStrike(self, upperStrike): self.upperStrike = upperStrike
    def get_upperStrikeNumberOfOptions(self): return self.upperStrikeNumberOfOptions
    def set_upperStrikeNumberOfOptions(self, upperStrikeNumberOfOptions): self.upperStrikeNumberOfOptions = upperStrikeNumberOfOptions
    def validate_PositiveDecimal(self, value):
        # Validate type PositiveDecimal, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value <= 0:
                warnings_.warn('Value "%(value)s" does not match xsd minExclusive restriction on PositiveDecimal' % {"value" : value} )
    def hasContent_(self):
        if (
            self.upperStrike is not None or
            self.upperStrikeNumberOfOptions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StrikeSpread', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StrikeSpread')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StrikeSpread', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StrikeSpread'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StrikeSpread', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.upperStrike is not None:
            self.upperStrike.export(outfile, level, namespace_, name_='upperStrike', pretty_print=pretty_print)
        if self.upperStrikeNumberOfOptions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%supperStrikeNumberOfOptions>%s</%supperStrikeNumberOfOptions>%s' % (namespace_, self.gds_format_float(self.upperStrikeNumberOfOptions, input_name='upperStrikeNumberOfOptions'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'upperStrike':
            obj_ = OptionStrike.factory()
            obj_.build(child_)
            self.upperStrike = obj_
            obj_.original_tagname_ = 'upperStrike'
        elif nodeName_ == 'upperStrikeNumberOfOptions':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'upperStrikeNumberOfOptions')
            self.upperStrikeNumberOfOptions = fval_
            # validate type PositiveDecimal
            self.validate_PositiveDecimal(self.upperStrikeNumberOfOptions)
# end class StrikeSpread


class Trigger(GeneratedsSuper):
    """Trigger point at which feature is effective.Choice between either an
    explicit representation of Credit Events, or Credit Events
    defined elsewhere in the document."""
    member_data_items_ = {
        'level': MemberSpec_('level', 'xsd:decimal', 0),
        'levelPercentage': MemberSpec_('levelPercentage', 'xsd:decimal', 0),
        'creditEvents': MemberSpec_('creditEvents', 'CreditEvents', 0),
        'creditEventsReference': MemberSpec_('creditEventsReference', 'CreditEventsReference', 0),
        'triggerType': MemberSpec_('triggerType', ['TriggerTypeEnum', 'Token', 'xsd:token'], 0),
        'triggerTimeType': MemberSpec_('triggerTimeType', ['TriggerTimeTypeEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, level=None, levelPercentage=None, creditEvents=None, creditEventsReference=None, triggerType=None, triggerTimeType=None):
        self.original_tagname_ = None
        self.level = level
        self.levelPercentage = levelPercentage
        self.creditEvents = creditEvents
        self.creditEventsReference = creditEventsReference
        self.triggerType = triggerType
        self.validate_TriggerTypeEnum(self.triggerType)
        self.triggerTimeType = triggerTimeType
        self.validate_TriggerTimeTypeEnum(self.triggerTimeType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Trigger)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Trigger.subclass:
            return Trigger.subclass(*args_, **kwargs_)
        else:
            return Trigger(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_level(self): return self.level
    def set_level(self, level): self.level = level
    def get_levelPercentage(self): return self.levelPercentage
    def set_levelPercentage(self, levelPercentage): self.levelPercentage = levelPercentage
    def get_creditEvents(self): return self.creditEvents
    def set_creditEvents(self, creditEvents): self.creditEvents = creditEvents
    def get_creditEventsReference(self): return self.creditEventsReference
    def set_creditEventsReference(self, creditEventsReference): self.creditEventsReference = creditEventsReference
    def get_triggerType(self): return self.triggerType
    def set_triggerType(self, triggerType): self.triggerType = triggerType
    def get_triggerTimeType(self): return self.triggerTimeType
    def set_triggerTimeType(self, triggerTimeType): self.triggerTimeType = triggerTimeType
    def validate_TriggerTypeEnum(self, value):
        # Validate type TriggerTypeEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['EqualOrLess', 'EqualOrGreater', 'Equal', 'Less', 'Greater']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TriggerTypeEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on TriggerTypeEnum' % {"value" : value} )
    def validate_TriggerTimeTypeEnum(self, value):
        # Validate type TriggerTimeTypeEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Closing', 'Anytime']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TriggerTimeTypeEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on TriggerTimeTypeEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.level is not None or
            self.levelPercentage is not None or
            self.creditEvents is not None or
            self.creditEventsReference is not None or
            self.triggerType is not None or
            self.triggerTimeType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Trigger', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Trigger')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Trigger', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Trigger'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Trigger', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.level is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slevel>%s</%slevel>%s' % (namespace_, self.gds_format_float(self.level, input_name='level'), namespace_, eol_))
        if self.levelPercentage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slevelPercentage>%s</%slevelPercentage>%s' % (namespace_, self.gds_format_float(self.levelPercentage, input_name='levelPercentage'), namespace_, eol_))
        if self.creditEvents is not None:
            self.creditEvents.export(outfile, level, namespace_, name_='creditEvents', pretty_print=pretty_print)
        if self.creditEventsReference is not None:
            self.creditEventsReference.export(outfile, level, namespace_, name_='creditEventsReference', pretty_print=pretty_print)
        if self.triggerType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%striggerType>%s</%striggerType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.triggerType), input_name='triggerType')), namespace_, eol_))
        if self.triggerTimeType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%striggerTimeType>%s</%striggerTimeType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.triggerTimeType), input_name='triggerTimeType')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'level':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'level')
            self.level = fval_
        elif nodeName_ == 'levelPercentage':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'levelPercentage')
            self.levelPercentage = fval_
        elif nodeName_ == 'creditEvents':
            obj_ = CreditEvents.factory()
            obj_.build(child_)
            self.creditEvents = obj_
            obj_.original_tagname_ = 'creditEvents'
        elif nodeName_ == 'creditEventsReference':
            obj_ = CreditEventsReference.factory()
            obj_.build(child_)
            self.creditEventsReference = obj_
            obj_.original_tagname_ = 'creditEventsReference'
        elif nodeName_ == 'triggerType':
            triggerType_ = child_.text
            triggerType_ = re_.sub(String_cleanup_pat_, " ", triggerType_).strip()
            triggerType_ = self.gds_validate_string(triggerType_, node, 'triggerType')
            self.triggerType = triggerType_
            # validate type TriggerTypeEnum
            self.validate_TriggerTypeEnum(self.triggerType)
        elif nodeName_ == 'triggerTimeType':
            triggerTimeType_ = child_.text
            triggerTimeType_ = re_.sub(String_cleanup_pat_, " ", triggerTimeType_).strip()
            triggerTimeType_ = self.gds_validate_string(triggerTimeType_, node, 'triggerTimeType')
            self.triggerTimeType = triggerTimeType_
            # validate type TriggerTimeTypeEnum
            self.validate_TriggerTimeTypeEnum(self.triggerTimeType)
# end class Trigger


class TriggerEvent(GeneratedsSuper):
    """Observation point for trigger."""
    member_data_items_ = {
        'schedule': MemberSpec_('schedule', 'AveragingSchedule', 1),
        'triggerDates': MemberSpec_('triggerDates', 'DateList', 0),
        'trigger': MemberSpec_('trigger', 'Trigger', 0),
        'featurePayment': MemberSpec_('featurePayment', 'FeaturePayment', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, schedule=None, triggerDates=None, trigger=None, featurePayment=None):
        self.original_tagname_ = None
        if schedule is None:
            self.schedule = []
        else:
            self.schedule = schedule
        self.triggerDates = triggerDates
        self.trigger = trigger
        self.featurePayment = featurePayment
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TriggerEvent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TriggerEvent.subclass:
            return TriggerEvent.subclass(*args_, **kwargs_)
        else:
            return TriggerEvent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_schedule(self): return self.schedule
    def set_schedule(self, schedule): self.schedule = schedule
    def add_schedule(self, value): self.schedule.append(value)
    def insert_schedule_at(self, index, value): self.schedule.insert(index, value)
    def replace_schedule_at(self, index, value): self.schedule[index] = value
    def get_triggerDates(self): return self.triggerDates
    def set_triggerDates(self, triggerDates): self.triggerDates = triggerDates
    def get_trigger(self): return self.trigger
    def set_trigger(self, trigger): self.trigger = trigger
    def get_featurePayment(self): return self.featurePayment
    def set_featurePayment(self, featurePayment): self.featurePayment = featurePayment
    def hasContent_(self):
        if (
            self.schedule or
            self.triggerDates is not None or
            self.trigger is not None or
            self.featurePayment is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TriggerEvent', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TriggerEvent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TriggerEvent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TriggerEvent'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TriggerEvent', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for schedule_ in self.schedule:
            schedule_.export(outfile, level, namespace_, name_='schedule', pretty_print=pretty_print)
        if self.triggerDates is not None:
            self.triggerDates.export(outfile, level, namespace_, name_='triggerDates', pretty_print=pretty_print)
        if self.trigger is not None:
            self.trigger.export(outfile, level, namespace_, name_='trigger', pretty_print=pretty_print)
        if self.featurePayment is not None:
            self.featurePayment.export(outfile, level, namespace_, name_='featurePayment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'schedule':
            obj_ = AveragingSchedule.factory()
            obj_.build(child_)
            self.schedule.append(obj_)
            obj_.original_tagname_ = 'schedule'
        elif nodeName_ == 'triggerDates':
            obj_ = DateList.factory()
            obj_.build(child_)
            self.triggerDates = obj_
            obj_.original_tagname_ = 'triggerDates'
        elif nodeName_ == 'trigger':
            obj_ = Trigger.factory()
            obj_.build(child_)
            self.trigger = obj_
            obj_.original_tagname_ = 'trigger'
        elif nodeName_ == 'featurePayment':
            obj_ = FeaturePayment.factory()
            obj_.build(child_)
            self.featurePayment = obj_
            obj_.original_tagname_ = 'featurePayment'
# end class TriggerEvent


class WeightedAveragingObservation(GeneratedsSuper):
    """A single weighted averaging observation.Choice between date times
    for literal date values, and observation numbers for schedule
    generated observations."""
    member_data_items_ = {
        'dateTime': MemberSpec_('dateTime', 'xsd:dateTime', 0),
        'observationNumber': MemberSpec_('observationNumber', 'xsd:positiveInteger', 0),
        'weight': MemberSpec_('weight', ['NonNegativeDecimal', 'xsd:decimal'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, dateTime=None, observationNumber=None, weight=None):
        self.original_tagname_ = None
        if isinstance(dateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(dateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = dateTime
        self.dateTime = initvalue_
        self.observationNumber = observationNumber
        self.weight = weight
        self.validate_NonNegativeDecimal(self.weight)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WeightedAveragingObservation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WeightedAveragingObservation.subclass:
            return WeightedAveragingObservation.subclass(*args_, **kwargs_)
        else:
            return WeightedAveragingObservation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dateTime(self): return self.dateTime
    def set_dateTime(self, dateTime): self.dateTime = dateTime
    def get_observationNumber(self): return self.observationNumber
    def set_observationNumber(self, observationNumber): self.observationNumber = observationNumber
    def get_weight(self): return self.weight
    def set_weight(self, weight): self.weight = weight
    def validate_NonNegativeDecimal(self, value):
        # Validate type NonNegativeDecimal, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on NonNegativeDecimal' % {"value" : value} )
    def hasContent_(self):
        if (
            self.dateTime is not None or
            self.observationNumber is not None or
            self.weight is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='WeightedAveragingObservation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WeightedAveragingObservation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='WeightedAveragingObservation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='WeightedAveragingObservation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='WeightedAveragingObservation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dateTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdateTime>%s</%sdateTime>%s' % (namespace_, self.gds_format_datetime(self.dateTime, input_name='dateTime'), namespace_, eol_))
        if self.observationNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sobservationNumber>%s</%sobservationNumber>%s' % (namespace_, self.gds_format_integer(self.observationNumber, input_name='observationNumber'), namespace_, eol_))
        if self.weight is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sweight>%s</%sweight>%s' % (namespace_, self.gds_format_float(self.weight, input_name='weight'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.dateTime = dval_
        elif nodeName_ == 'observationNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'observationNumber')
            self.observationNumber = ival_
        elif nodeName_ == 'weight':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'weight')
            self.weight = fval_
            # validate type NonNegativeDecimal
            self.validate_NonNegativeDecimal(self.weight)
# end class WeightedAveragingObservation


class ActualPrice(GeneratedsSuper):
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'currency': MemberSpec_('currency', 'Currency', 0),
        'amount': MemberSpec_('amount', 'xsd:decimal', 0),
        'priceExpression': MemberSpec_('priceExpression', ['PriceExpressionEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, currency=None, amount=None, priceExpression=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.currency = currency
        self.amount = amount
        self.priceExpression = priceExpression
        self.validate_PriceExpressionEnum(self.priceExpression)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ActualPrice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ActualPrice.subclass:
            return ActualPrice.subclass(*args_, **kwargs_)
        else:
            return ActualPrice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_amount(self): return self.amount
    def set_amount(self, amount): self.amount = amount
    def get_priceExpression(self): return self.priceExpression
    def set_priceExpression(self, priceExpression): self.priceExpression = priceExpression
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_PriceExpressionEnum(self, value):
        # Validate type PriceExpressionEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AbsoluteTerms', 'PercentageOfNotional']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PriceExpressionEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on PriceExpressionEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.currency is not None or
            self.amount is not None or
            self.priceExpression is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ActualPrice', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActualPrice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ActualPrice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ActualPrice'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ActualPrice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.currency is not None:
            self.currency.export(outfile, level, namespace_, name_='currency', pretty_print=pretty_print)
        if self.amount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%samount>%s</%samount>%s' % (namespace_, self.gds_format_float(self.amount, input_name='amount'), namespace_, eol_))
        if self.priceExpression is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spriceExpression>%s</%spriceExpression>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.priceExpression), input_name='priceExpression')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'currency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'amount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'amount')
            self.amount = fval_
        elif nodeName_ == 'priceExpression':
            priceExpression_ = child_.text
            priceExpression_ = re_.sub(String_cleanup_pat_, " ", priceExpression_).strip()
            priceExpression_ = self.gds_validate_string(priceExpression_, node, 'priceExpression')
            self.priceExpression = priceExpression_
            # validate type PriceExpressionEnum
            self.validate_PriceExpressionEnum(self.priceExpression)
# end class ActualPrice


class Asset(GeneratedsSuper):
    """Abstract base class for all underlying assets."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Asset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Asset.subclass:
            return Asset.subclass(*args_, **kwargs_)
        else:
            return Asset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Asset', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Asset')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Asset', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Asset'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Asset', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Asset


class AssetMeasureType(GeneratedsSuper):
    """A scheme identifying the types of measures that can be used to
    describe an asset."""
    member_data_items_ = {
        'assetMeasureScheme': MemberSpec_('assetMeasureScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, assetMeasureScheme='http://www.fpml.org/coding-scheme/asset-measure', valueOf_=None):
        self.original_tagname_ = None
        self.assetMeasureScheme = _cast(None, assetMeasureScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AssetMeasureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AssetMeasureType.subclass:
            return AssetMeasureType.subclass(*args_, **kwargs_)
        else:
            return AssetMeasureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_assetMeasureScheme(self): return self.assetMeasureScheme
    def set_assetMeasureScheme(self, assetMeasureScheme): self.assetMeasureScheme = assetMeasureScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AssetMeasureType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AssetMeasureType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AssetMeasureType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AssetMeasureType'):
        if self.assetMeasureScheme != "http://www.fpml.org/coding-scheme/asset-measure" and 'assetMeasureScheme' not in already_processed:
            already_processed.add('assetMeasureScheme')
            outfile.write(' assetMeasureScheme=%s' % (quote_attrib(self.assetMeasureScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AssetMeasureType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('assetMeasureScheme', node)
        if value is not None and 'assetMeasureScheme' not in already_processed:
            already_processed.add('assetMeasureScheme')
            self.assetMeasureScheme = value
            self.validate_NonEmptyURI(self.assetMeasureScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AssetMeasureType


class AssetPool(GeneratedsSuper):
    """Characterise the asset pool behind an asset backed bond."""
    member_data_items_ = {
        'version': MemberSpec_('version', 'xsd:nonNegativeInteger', 0),
        'effectiveDate': MemberSpec_('effectiveDate', 'IdentifiedDate', 0),
        'initialFactor': MemberSpec_('initialFactor', 'xsd:decimal', 0),
        'currentFactor': MemberSpec_('currentFactor', 'xsd:decimal', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, version=None, effectiveDate=None, initialFactor=None, currentFactor=None):
        self.original_tagname_ = None
        self.version = version
        self.effectiveDate = effectiveDate
        self.initialFactor = initialFactor
        self.currentFactor = currentFactor
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AssetPool)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AssetPool.subclass:
            return AssetPool.subclass(*args_, **kwargs_)
        else:
            return AssetPool(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_effectiveDate(self): return self.effectiveDate
    def set_effectiveDate(self, effectiveDate): self.effectiveDate = effectiveDate
    def get_initialFactor(self): return self.initialFactor
    def set_initialFactor(self, initialFactor): self.initialFactor = initialFactor
    def get_currentFactor(self): return self.currentFactor
    def set_currentFactor(self, currentFactor): self.currentFactor = currentFactor
    def hasContent_(self):
        if (
            self.version is not None or
            self.effectiveDate is not None or
            self.initialFactor is not None or
            self.currentFactor is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AssetPool', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AssetPool')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AssetPool', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AssetPool'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AssetPool', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sversion>%s</%sversion>%s' % (namespace_, self.gds_format_integer(self.version, input_name='version'), namespace_, eol_))
        if self.effectiveDate is not None:
            self.effectiveDate.export(outfile, level, namespace_, name_='effectiveDate', pretty_print=pretty_print)
        if self.initialFactor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinitialFactor>%s</%sinitialFactor>%s' % (namespace_, self.gds_format_float(self.initialFactor, input_name='initialFactor'), namespace_, eol_))
        if self.currentFactor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scurrentFactor>%s</%scurrentFactor>%s' % (namespace_, self.gds_format_float(self.currentFactor, input_name='currentFactor'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'version':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'version')
            self.version = ival_
        elif nodeName_ == 'effectiveDate':
            obj_ = IdentifiedDate.factory()
            obj_.build(child_)
            self.effectiveDate = obj_
            obj_.original_tagname_ = 'effectiveDate'
        elif nodeName_ == 'initialFactor':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'initialFactor')
            self.initialFactor = fval_
        elif nodeName_ == 'currentFactor':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'currentFactor')
            self.currentFactor = fval_
# end class AssetPool


class BasicQuotation(GeneratedsSuper):
    """Some kind of numerical measure about an asset, eg. its NPV, together
    with characteristics of that measure."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'value': MemberSpec_('value', 'xsd:decimal', 0),
        'measureType': MemberSpec_('measureType', 'AssetMeasureType', 0),
        'quoteUnits': MemberSpec_('quoteUnits', 'PriceQuoteUnits', 0),
        'side': MemberSpec_('side', ['QuotationSideEnum', 'Token', 'xsd:token'], 0),
        'currency': MemberSpec_('currency', 'Currency', 0),
        'currencyType': MemberSpec_('currencyType', 'ReportingCurrencyType', 0),
        'timing': MemberSpec_('timing', 'QuoteTiming', 0),
        'businessCenter': MemberSpec_('businessCenter', 'BusinessCenter', 0),
        'exchangeId': MemberSpec_('exchangeId', 'ExchangeId', 0),
        'informationSource': MemberSpec_('informationSource', 'InformationSource', 1),
        'pricingModel': MemberSpec_('pricingModel', 'PricingModel', 0),
        'time': MemberSpec_('time', 'xsd:dateTime', 0),
        'valuationDate': MemberSpec_('valuationDate', 'xsd:date', 0),
        'expiryTime': MemberSpec_('expiryTime', 'xsd:dateTime', 0),
        'cashflowType': MemberSpec_('cashflowType', 'CashflowType', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, value=None, measureType=None, quoteUnits=None, side=None, currency=None, currencyType=None, timing=None, businessCenter=None, exchangeId=None, informationSource=None, pricingModel=None, time=None, valuationDate=None, expiryTime=None, cashflowType=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.value = value
        self.measureType = measureType
        self.quoteUnits = quoteUnits
        self.side = side
        self.validate_QuotationSideEnum(self.side)
        self.currency = currency
        self.currencyType = currencyType
        self.timing = timing
        self.businessCenter = businessCenter
        self.exchangeId = exchangeId
        if informationSource is None:
            self.informationSource = []
        else:
            self.informationSource = informationSource
        self.pricingModel = pricingModel
        if isinstance(time, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(time, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = time
        self.time = initvalue_
        if isinstance(valuationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(valuationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = valuationDate
        self.valuationDate = initvalue_
        if isinstance(expiryTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(expiryTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = expiryTime
        self.expiryTime = initvalue_
        self.cashflowType = cashflowType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BasicQuotation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BasicQuotation.subclass:
            return BasicQuotation.subclass(*args_, **kwargs_)
        else:
            return BasicQuotation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_measureType(self): return self.measureType
    def set_measureType(self, measureType): self.measureType = measureType
    def get_quoteUnits(self): return self.quoteUnits
    def set_quoteUnits(self, quoteUnits): self.quoteUnits = quoteUnits
    def get_side(self): return self.side
    def set_side(self, side): self.side = side
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_currencyType(self): return self.currencyType
    def set_currencyType(self, currencyType): self.currencyType = currencyType
    def get_timing(self): return self.timing
    def set_timing(self, timing): self.timing = timing
    def get_businessCenter(self): return self.businessCenter
    def set_businessCenter(self, businessCenter): self.businessCenter = businessCenter
    def get_exchangeId(self): return self.exchangeId
    def set_exchangeId(self, exchangeId): self.exchangeId = exchangeId
    def get_informationSource(self): return self.informationSource
    def set_informationSource(self, informationSource): self.informationSource = informationSource
    def add_informationSource(self, value): self.informationSource.append(value)
    def insert_informationSource_at(self, index, value): self.informationSource.insert(index, value)
    def replace_informationSource_at(self, index, value): self.informationSource[index] = value
    def get_pricingModel(self): return self.pricingModel
    def set_pricingModel(self, pricingModel): self.pricingModel = pricingModel
    def get_time(self): return self.time
    def set_time(self, time): self.time = time
    def get_valuationDate(self): return self.valuationDate
    def set_valuationDate(self, valuationDate): self.valuationDate = valuationDate
    def get_expiryTime(self): return self.expiryTime
    def set_expiryTime(self, expiryTime): self.expiryTime = expiryTime
    def get_cashflowType(self): return self.cashflowType
    def set_cashflowType(self, cashflowType): self.cashflowType = cashflowType
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_QuotationSideEnum(self, value):
        # Validate type QuotationSideEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Bid', 'Ask', 'Mid']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on QuotationSideEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on QuotationSideEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.value is not None or
            self.measureType is not None or
            self.quoteUnits is not None or
            self.side is not None or
            self.currency is not None or
            self.currencyType is not None or
            self.timing is not None or
            self.businessCenter is not None or
            self.exchangeId is not None or
            self.informationSource or
            self.pricingModel is not None or
            self.time is not None or
            self.valuationDate is not None or
            self.expiryTime is not None or
            self.cashflowType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BasicQuotation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BasicQuotation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BasicQuotation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BasicQuotation'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BasicQuotation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_float(self.value, input_name='value'), namespace_, eol_))
        if self.measureType is not None:
            self.measureType.export(outfile, level, namespace_, name_='measureType', pretty_print=pretty_print)
        if self.quoteUnits is not None:
            self.quoteUnits.export(outfile, level, namespace_, name_='quoteUnits', pretty_print=pretty_print)
        if self.side is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sside>%s</%sside>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.side), input_name='side')), namespace_, eol_))
        if self.currency is not None:
            self.currency.export(outfile, level, namespace_, name_='currency', pretty_print=pretty_print)
        if self.currencyType is not None:
            self.currencyType.export(outfile, level, namespace_, name_='currencyType', pretty_print=pretty_print)
        if self.timing is not None:
            self.timing.export(outfile, level, namespace_, name_='timing', pretty_print=pretty_print)
        if self.businessCenter is not None:
            self.businessCenter.export(outfile, level, namespace_, name_='businessCenter', pretty_print=pretty_print)
        if self.exchangeId is not None:
            self.exchangeId.export(outfile, level, namespace_, name_='exchangeId', pretty_print=pretty_print)
        for informationSource_ in self.informationSource:
            informationSource_.export(outfile, level, namespace_, name_='informationSource', pretty_print=pretty_print)
        if self.pricingModel is not None:
            self.pricingModel.export(outfile, level, namespace_, name_='pricingModel', pretty_print=pretty_print)
        if self.time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stime>%s</%stime>%s' % (namespace_, self.gds_format_datetime(self.time, input_name='time'), namespace_, eol_))
        if self.valuationDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svaluationDate>%s</%svaluationDate>%s' % (namespace_, self.gds_format_date(self.valuationDate, input_name='valuationDate'), namespace_, eol_))
        if self.expiryTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexpiryTime>%s</%sexpiryTime>%s' % (namespace_, self.gds_format_datetime(self.expiryTime, input_name='expiryTime'), namespace_, eol_))
        if self.cashflowType is not None:
            self.cashflowType.export(outfile, level, namespace_, name_='cashflowType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'value':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'value')
            self.value = fval_
        elif nodeName_ == 'measureType':
            obj_ = AssetMeasureType.factory()
            obj_.build(child_)
            self.measureType = obj_
            obj_.original_tagname_ = 'measureType'
        elif nodeName_ == 'quoteUnits':
            obj_ = PriceQuoteUnits.factory()
            obj_.build(child_)
            self.quoteUnits = obj_
            obj_.original_tagname_ = 'quoteUnits'
        elif nodeName_ == 'side':
            side_ = child_.text
            side_ = re_.sub(String_cleanup_pat_, " ", side_).strip()
            side_ = self.gds_validate_string(side_, node, 'side')
            self.side = side_
            # validate type QuotationSideEnum
            self.validate_QuotationSideEnum(self.side)
        elif nodeName_ == 'currency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'currencyType':
            obj_ = ReportingCurrencyType.factory()
            obj_.build(child_)
            self.currencyType = obj_
            obj_.original_tagname_ = 'currencyType'
        elif nodeName_ == 'timing':
            obj_ = QuoteTiming.factory()
            obj_.build(child_)
            self.timing = obj_
            obj_.original_tagname_ = 'timing'
        elif nodeName_ == 'businessCenter':
            obj_ = BusinessCenter.factory()
            obj_.build(child_)
            self.businessCenter = obj_
            obj_.original_tagname_ = 'businessCenter'
        elif nodeName_ == 'exchangeId':
            obj_ = ExchangeId.factory()
            obj_.build(child_)
            self.exchangeId = obj_
            obj_.original_tagname_ = 'exchangeId'
        elif nodeName_ == 'informationSource':
            class_obj_ = self.get_class_obj_(child_, InformationSource)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.informationSource.append(obj_)
            obj_.original_tagname_ = 'informationSource'
        elif nodeName_ == 'pricingModel':
            obj_ = PricingModel.factory()
            obj_.build(child_)
            self.pricingModel = obj_
            obj_.original_tagname_ = 'pricingModel'
        elif nodeName_ == 'time':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.time = dval_
        elif nodeName_ == 'valuationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.valuationDate = dval_
        elif nodeName_ == 'expiryTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.expiryTime = dval_
        elif nodeName_ == 'cashflowType':
            obj_ = CashflowType.factory()
            obj_.build(child_)
            self.cashflowType = obj_
            obj_.original_tagname_ = 'cashflowType'
# end class BasicQuotation


class Basket(Asset):
    """A type describing the underlyer features of a basket swap. Each of
    the basket constituents are described through an embedded
    component, the basketConstituentsType."""
    member_data_items_ = {
        'openUnits': MemberSpec_('openUnits', 'xsd:decimal', 0),
        'basketConstituent': MemberSpec_('basketConstituent', 'BasketConstituent', 1),
        'basketDivisor': MemberSpec_('basketDivisor', 'xsd:decimal', 0),
        'basketVersion': MemberSpec_('basketVersion', 'xsd:nonNegativeInteger', 0),
        'basketName': MemberSpec_('basketName', 'BasketName', 0),
        'basketId': MemberSpec_('basketId', 'BasketId', 1),
        'basketId': MemberSpec_('basketId', 'BasketId', 1),
        'basketCurrency': MemberSpec_('basketCurrency', 'Currency', 0),
    }
    subclass = None
    superclass = Asset
    def __init__(self, id=None, openUnits=None, basketConstituent=None, basketDivisor=None, basketVersion=None, basketName=None, basketId=None, basketCurrency=None):
        self.original_tagname_ = None
        super(Basket, self).__init__(id, )
        self.openUnits = openUnits
        if basketConstituent is None:
            self.basketConstituent = []
        else:
            self.basketConstituent = basketConstituent
        self.basketDivisor = basketDivisor
        self.basketVersion = basketVersion
        self.basketName = basketName
        if basketId is None:
            self.basketId = []
        else:
            self.basketId = basketId
        if basketId is None:
            self.basketId = []
        else:
            self.basketId = basketId
        self.basketCurrency = basketCurrency
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Basket)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Basket.subclass:
            return Basket.subclass(*args_, **kwargs_)
        else:
            return Basket(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_openUnits(self): return self.openUnits
    def set_openUnits(self, openUnits): self.openUnits = openUnits
    def get_basketConstituent(self): return self.basketConstituent
    def set_basketConstituent(self, basketConstituent): self.basketConstituent = basketConstituent
    def add_basketConstituent(self, value): self.basketConstituent.append(value)
    def insert_basketConstituent_at(self, index, value): self.basketConstituent.insert(index, value)
    def replace_basketConstituent_at(self, index, value): self.basketConstituent[index] = value
    def get_basketDivisor(self): return self.basketDivisor
    def set_basketDivisor(self, basketDivisor): self.basketDivisor = basketDivisor
    def get_basketVersion(self): return self.basketVersion
    def set_basketVersion(self, basketVersion): self.basketVersion = basketVersion
    def get_basketName(self): return self.basketName
    def set_basketName(self, basketName): self.basketName = basketName
    def get_basketId(self): return self.basketId
    def set_basketId(self, basketId): self.basketId = basketId
    def add_basketId(self, value): self.basketId.append(value)
    def insert_basketId_at(self, index, value): self.basketId.insert(index, value)
    def replace_basketId_at(self, index, value): self.basketId[index] = value
    def get_basketId(self): return self.basketId
    def set_basketId(self, basketId): self.basketId = basketId
    def add_basketId(self, value): self.basketId.append(value)
    def insert_basketId_at(self, index, value): self.basketId.insert(index, value)
    def replace_basketId_at(self, index, value): self.basketId[index] = value
    def get_basketCurrency(self): return self.basketCurrency
    def set_basketCurrency(self, basketCurrency): self.basketCurrency = basketCurrency
    def hasContent_(self):
        if (
            self.openUnits is not None or
            self.basketConstituent or
            self.basketDivisor is not None or
            self.basketVersion is not None or
            self.basketName is not None or
            self.basketId or
            self.basketId or
            self.basketCurrency is not None or
            super(Basket, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Basket', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Basket')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Basket', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Basket'):
        super(Basket, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Basket')
    def exportChildren(self, outfile, level, namespace_='', name_='Basket', fromsubclass_=False, pretty_print=True):
        super(Basket, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.openUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sopenUnits>%s</%sopenUnits>%s' % (namespace_, self.gds_format_float(self.openUnits, input_name='openUnits'), namespace_, eol_))
        for basketConstituent_ in self.basketConstituent:
            basketConstituent_.export(outfile, level, namespace_, name_='basketConstituent', pretty_print=pretty_print)
        if self.basketDivisor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbasketDivisor>%s</%sbasketDivisor>%s' % (namespace_, self.gds_format_float(self.basketDivisor, input_name='basketDivisor'), namespace_, eol_))
        if self.basketVersion is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbasketVersion>%s</%sbasketVersion>%s' % (namespace_, self.gds_format_integer(self.basketVersion, input_name='basketVersion'), namespace_, eol_))
        if self.basketName is not None:
            self.basketName.export(outfile, level, namespace_, name_='basketName', pretty_print=pretty_print)
        for basketId_ in self.basketId:
            basketId_.export(outfile, level, namespace_, name_='basketId', pretty_print=pretty_print)
        for basketId_ in self.basketId:
            basketId_.export(outfile, level, namespace_, name_='basketId', pretty_print=pretty_print)
        if self.basketCurrency is not None:
            self.basketCurrency.export(outfile, level, namespace_, name_='basketCurrency', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Basket, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'openUnits':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'openUnits')
            self.openUnits = fval_
        elif nodeName_ == 'basketConstituent':
            obj_ = BasketConstituent.factory()
            obj_.build(child_)
            self.basketConstituent.append(obj_)
            obj_.original_tagname_ = 'basketConstituent'
        elif nodeName_ == 'basketDivisor':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'basketDivisor')
            self.basketDivisor = fval_
        elif nodeName_ == 'basketVersion':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'basketVersion')
            self.basketVersion = ival_
        elif nodeName_ == 'basketName':
            obj_ = BasketName.factory()
            obj_.build(child_)
            self.basketName = obj_
            obj_.original_tagname_ = 'basketName'
        elif nodeName_ == 'basketId':
            obj_ = BasketId.factory()
            obj_.build(child_)
            self.basketId.append(obj_)
            obj_.original_tagname_ = 'basketId'
        elif nodeName_ == 'basketId':
            obj_ = BasketId.factory()
            obj_.build(child_)
            self.basketId.append(obj_)
            obj_.original_tagname_ = 'basketId'
        elif nodeName_ == 'basketCurrency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.basketCurrency = obj_
            obj_.original_tagname_ = 'basketCurrency'
        super(Basket, self).buildChildren(child_, node, nodeName_, True)
# end class Basket


class BasketConstituent(GeneratedsSuper):
    """A type describing each of the constituents of a basket."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'payerPartyReference': MemberSpec_('payerPartyReference', 'PartyReference', 0),
        'payerAccountReference': MemberSpec_('payerAccountReference', 'AccountReference', 0),
        'receiverPartyReference': MemberSpec_('receiverPartyReference', 'PartyReference', 0),
        'receiverAccountReference': MemberSpec_('receiverAccountReference', 'AccountReference', 0),
        'underlyingAsset': MemberSpec_('underlyingAsset', 'Asset', 0),
        'constituentWeight': MemberSpec_('constituentWeight', 'ConstituentWeight', 0),
        'dividendPayout': MemberSpec_('dividendPayout', 'DividendPayout', 0),
        'underlyerPrice': MemberSpec_('underlyerPrice', 'Price', 0),
        'underlyerNotional': MemberSpec_('underlyerNotional', 'Money', 0),
        'underlyerSpread': MemberSpec_('underlyerSpread', 'SpreadScheduleReference', 0),
        'couponPayment': MemberSpec_('couponPayment', 'PendingPayment', 0),
        'underlyerFinancing': MemberSpec_('underlyerFinancing', 'UnderlyerInterestLeg', 0),
        'underlyerLoanRate': MemberSpec_('underlyerLoanRate', 'UnderlyerLoanRate', 0),
        'underlyerCollateral': MemberSpec_('underlyerCollateral', 'Collateral', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, underlyingAsset=None, constituentWeight=None, dividendPayout=None, underlyerPrice=None, underlyerNotional=None, underlyerSpread=None, couponPayment=None, underlyerFinancing=None, underlyerLoanRate=None, underlyerCollateral=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.payerPartyReference = payerPartyReference
        self.payerAccountReference = payerAccountReference
        self.receiverPartyReference = receiverPartyReference
        self.receiverAccountReference = receiverAccountReference
        self.underlyingAsset = underlyingAsset
        self.constituentWeight = constituentWeight
        self.dividendPayout = dividendPayout
        self.underlyerPrice = underlyerPrice
        self.underlyerNotional = underlyerNotional
        self.underlyerSpread = underlyerSpread
        self.couponPayment = couponPayment
        self.underlyerFinancing = underlyerFinancing
        self.underlyerLoanRate = underlyerLoanRate
        self.underlyerCollateral = underlyerCollateral
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BasketConstituent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BasketConstituent.subclass:
            return BasketConstituent.subclass(*args_, **kwargs_)
        else:
            return BasketConstituent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_payerPartyReference(self): return self.payerPartyReference
    def set_payerPartyReference(self, payerPartyReference): self.payerPartyReference = payerPartyReference
    def get_payerAccountReference(self): return self.payerAccountReference
    def set_payerAccountReference(self, payerAccountReference): self.payerAccountReference = payerAccountReference
    def get_receiverPartyReference(self): return self.receiverPartyReference
    def set_receiverPartyReference(self, receiverPartyReference): self.receiverPartyReference = receiverPartyReference
    def get_receiverAccountReference(self): return self.receiverAccountReference
    def set_receiverAccountReference(self, receiverAccountReference): self.receiverAccountReference = receiverAccountReference
    def get_underlyingAsset(self): return self.underlyingAsset
    def set_underlyingAsset(self, underlyingAsset): self.underlyingAsset = underlyingAsset
    def get_constituentWeight(self): return self.constituentWeight
    def set_constituentWeight(self, constituentWeight): self.constituentWeight = constituentWeight
    def get_dividendPayout(self): return self.dividendPayout
    def set_dividendPayout(self, dividendPayout): self.dividendPayout = dividendPayout
    def get_underlyerPrice(self): return self.underlyerPrice
    def set_underlyerPrice(self, underlyerPrice): self.underlyerPrice = underlyerPrice
    def get_underlyerNotional(self): return self.underlyerNotional
    def set_underlyerNotional(self, underlyerNotional): self.underlyerNotional = underlyerNotional
    def get_underlyerSpread(self): return self.underlyerSpread
    def set_underlyerSpread(self, underlyerSpread): self.underlyerSpread = underlyerSpread
    def get_couponPayment(self): return self.couponPayment
    def set_couponPayment(self, couponPayment): self.couponPayment = couponPayment
    def get_underlyerFinancing(self): return self.underlyerFinancing
    def set_underlyerFinancing(self, underlyerFinancing): self.underlyerFinancing = underlyerFinancing
    def get_underlyerLoanRate(self): return self.underlyerLoanRate
    def set_underlyerLoanRate(self, underlyerLoanRate): self.underlyerLoanRate = underlyerLoanRate
    def get_underlyerCollateral(self): return self.underlyerCollateral
    def set_underlyerCollateral(self, underlyerCollateral): self.underlyerCollateral = underlyerCollateral
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.payerPartyReference is not None or
            self.payerAccountReference is not None or
            self.receiverPartyReference is not None or
            self.receiverAccountReference is not None or
            self.underlyingAsset is not None or
            self.constituentWeight is not None or
            self.dividendPayout is not None or
            self.underlyerPrice is not None or
            self.underlyerNotional is not None or
            self.underlyerSpread is not None or
            self.couponPayment is not None or
            self.underlyerFinancing is not None or
            self.underlyerLoanRate is not None or
            self.underlyerCollateral is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BasketConstituent', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BasketConstituent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BasketConstituent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BasketConstituent'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BasketConstituent', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.payerPartyReference is not None:
            self.payerPartyReference.export(outfile, level, namespace_, name_='payerPartyReference', pretty_print=pretty_print)
        if self.payerAccountReference is not None:
            self.payerAccountReference.export(outfile, level, namespace_, name_='payerAccountReference', pretty_print=pretty_print)
        if self.receiverPartyReference is not None:
            self.receiverPartyReference.export(outfile, level, namespace_, name_='receiverPartyReference', pretty_print=pretty_print)
        if self.receiverAccountReference is not None:
            self.receiverAccountReference.export(outfile, level, namespace_, name_='receiverAccountReference', pretty_print=pretty_print)
        if self.underlyingAsset is not None:
            self.underlyingAsset.export(outfile, level, namespace_, name_='underlyingAsset', pretty_print=pretty_print)
        if self.constituentWeight is not None:
            self.constituentWeight.export(outfile, level, namespace_, name_='constituentWeight', pretty_print=pretty_print)
        if self.dividendPayout is not None:
            self.dividendPayout.export(outfile, level, namespace_, name_='dividendPayout', pretty_print=pretty_print)
        if self.underlyerPrice is not None:
            self.underlyerPrice.export(outfile, level, namespace_, name_='underlyerPrice', pretty_print=pretty_print)
        if self.underlyerNotional is not None:
            self.underlyerNotional.export(outfile, level, namespace_, name_='underlyerNotional', pretty_print=pretty_print)
        if self.underlyerSpread is not None:
            self.underlyerSpread.export(outfile, level, namespace_, name_='underlyerSpread', pretty_print=pretty_print)
        if self.couponPayment is not None:
            self.couponPayment.export(outfile, level, namespace_, name_='couponPayment', pretty_print=pretty_print)
        if self.underlyerFinancing is not None:
            self.underlyerFinancing.export(outfile, level, namespace_, name_='underlyerFinancing', pretty_print=pretty_print)
        if self.underlyerLoanRate is not None:
            self.underlyerLoanRate.export(outfile, level, namespace_, name_='underlyerLoanRate', pretty_print=pretty_print)
        if self.underlyerCollateral is not None:
            self.underlyerCollateral.export(outfile, level, namespace_, name_='underlyerCollateral', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'payerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.payerPartyReference = obj_
            obj_.original_tagname_ = 'payerPartyReference'
        elif nodeName_ == 'payerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.payerAccountReference = obj_
            obj_.original_tagname_ = 'payerAccountReference'
        elif nodeName_ == 'receiverPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.receiverPartyReference = obj_
            obj_.original_tagname_ = 'receiverPartyReference'
        elif nodeName_ == 'receiverAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.receiverAccountReference = obj_
            obj_.original_tagname_ = 'receiverAccountReference'
        elif nodeName_ == 'underlyingAsset':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <underlyingAsset> element')
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'underlyingAsset'
        elif nodeName_ == 'basket':
            obj_ = Basket.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'basket'
        elif nodeName_ == 'bond':
            class_obj_ = self.get_class_obj_(child_, Bond)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'bond'
        elif nodeName_ == 'cash':
            obj_ = Cash.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'cash'
        elif nodeName_ == 'commodity':
            obj_ = Commodity.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'commodity'
        elif nodeName_ == 'convertibleBond':
            obj_ = ConvertibleBond.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'convertibleBond'
        elif nodeName_ == 'equity':
            obj_ = EquityAsset.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'equity'
        elif nodeName_ == 'exchangeTradedFund':
            obj_ = ExchangeTradedFund.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'exchangeTradedFund'
        elif nodeName_ == 'future':
            obj_ = Future.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'future'
        elif nodeName_ == 'index':
            obj_ = Index.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'index'
        elif nodeName_ == 'loan':
            obj_ = Loan.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'loan'
        elif nodeName_ == 'mortgage':
            obj_ = Mortgage.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'mortgage'
        elif nodeName_ == 'mutualFund':
            obj_ = MutualFund.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'mutualFund'
        elif nodeName_ == 'option':
            obj_ = ExchangeTradedOption.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'option'
        elif nodeName_ == 'constituentWeight':
            obj_ = ConstituentWeight.factory()
            obj_.build(child_)
            self.constituentWeight = obj_
            obj_.original_tagname_ = 'constituentWeight'
        elif nodeName_ == 'dividendPayout':
            obj_ = DividendPayout.factory()
            obj_.build(child_)
            self.dividendPayout = obj_
            obj_.original_tagname_ = 'dividendPayout'
        elif nodeName_ == 'underlyerPrice':
            obj_ = Price.factory()
            obj_.build(child_)
            self.underlyerPrice = obj_
            obj_.original_tagname_ = 'underlyerPrice'
        elif nodeName_ == 'underlyerNotional':
            class_obj_ = self.get_class_obj_(child_, Money)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.underlyerNotional = obj_
            obj_.original_tagname_ = 'underlyerNotional'
        elif nodeName_ == 'underlyerSpread':
            obj_ = SpreadScheduleReference.factory()
            obj_.build(child_)
            self.underlyerSpread = obj_
            obj_.original_tagname_ = 'underlyerSpread'
        elif nodeName_ == 'couponPayment':
            obj_ = PendingPayment.factory()
            obj_.build(child_)
            self.couponPayment = obj_
            obj_.original_tagname_ = 'couponPayment'
        elif nodeName_ == 'underlyerFinancing':
            obj_ = UnderlyerInterestLeg.factory()
            obj_.build(child_)
            self.underlyerFinancing = obj_
            obj_.original_tagname_ = 'underlyerFinancing'
        elif nodeName_ == 'underlyerLoanRate':
            obj_ = UnderlyerLoanRate.factory()
            obj_.build(child_)
            self.underlyerLoanRate = obj_
            obj_.original_tagname_ = 'underlyerLoanRate'
        elif nodeName_ == 'underlyerCollateral':
            obj_ = Collateral.factory()
            obj_.build(child_)
            self.underlyerCollateral = obj_
            obj_.original_tagname_ = 'underlyerCollateral'
# end class BasketConstituent


class BasketId(GeneratedsSuper):
    member_data_items_ = {
        'basketIdScheme': MemberSpec_('basketIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, basketIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.basketIdScheme = _cast(None, basketIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BasketId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BasketId.subclass:
            return BasketId.subclass(*args_, **kwargs_)
        else:
            return BasketId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_basketIdScheme(self): return self.basketIdScheme
    def set_basketIdScheme(self, basketIdScheme): self.basketIdScheme = basketIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BasketId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BasketId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BasketId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BasketId'):
        if self.basketIdScheme is not None and 'basketIdScheme' not in already_processed:
            already_processed.add('basketIdScheme')
            outfile.write(' basketIdScheme=%s' % (quote_attrib(self.basketIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BasketId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('basketIdScheme', node)
        if value is not None and 'basketIdScheme' not in already_processed:
            already_processed.add('basketIdScheme')
            self.basketIdScheme = value
            self.validate_NonEmptyURI(self.basketIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BasketId


class BasketName(GeneratedsSuper):
    member_data_items_ = {
        'basketNameScheme': MemberSpec_('basketNameScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, basketNameScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.basketNameScheme = _cast(None, basketNameScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BasketName)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BasketName.subclass:
            return BasketName.subclass(*args_, **kwargs_)
        else:
            return BasketName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_basketNameScheme(self): return self.basketNameScheme
    def set_basketNameScheme(self, basketNameScheme): self.basketNameScheme = basketNameScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BasketName', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BasketName')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BasketName', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BasketName'):
        if self.basketNameScheme is not None and 'basketNameScheme' not in already_processed:
            already_processed.add('basketNameScheme')
            outfile.write(' basketNameScheme=%s' % (quote_attrib(self.basketNameScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BasketName', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('basketNameScheme', node)
        if value is not None and 'basketNameScheme' not in already_processed:
            already_processed.add('basketNameScheme')
            self.basketNameScheme = value
            self.validate_NonEmptyURI(self.basketNameScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BasketName


class Cash(Asset):
    member_data_items_ = {
        'instrumentId': MemberSpec_('instrumentId', 'InstrumentId', 1),
        'description': MemberSpec_('description', ['String', 'xsd:string'], 0),
        'currency': MemberSpec_('currency', 'Currency', 0),
    }
    subclass = None
    superclass = Asset
    def __init__(self, id=None, instrumentId=None, description=None, currency=None):
        self.original_tagname_ = None
        super(Cash, self).__init__(id, )
        if instrumentId is None:
            self.instrumentId = []
        else:
            self.instrumentId = instrumentId
        self.description = description
        self.validate_String(self.description)
        self.currency = currency
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Cash)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Cash.subclass:
            return Cash.subclass(*args_, **kwargs_)
        else:
            return Cash(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_instrumentId(self): return self.instrumentId
    def set_instrumentId(self, instrumentId): self.instrumentId = instrumentId
    def add_instrumentId(self, value): self.instrumentId.append(value)
    def insert_instrumentId_at(self, index, value): self.instrumentId.insert(index, value)
    def replace_instrumentId_at(self, index, value): self.instrumentId[index] = value
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.instrumentId or
            self.description is not None or
            self.currency is not None or
            super(Cash, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Cash', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Cash')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Cash', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Cash'):
        super(Cash, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Cash')
    def exportChildren(self, outfile, level, namespace_='', name_='Cash', fromsubclass_=False, pretty_print=True):
        super(Cash, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for instrumentId_ in self.instrumentId:
            instrumentId_.export(outfile, level, namespace_, name_='instrumentId', pretty_print=pretty_print)
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespace_, eol_))
        if self.currency is not None:
            self.currency.export(outfile, level, namespace_, name_='currency', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Cash, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'instrumentId':
            obj_ = InstrumentId.factory()
            obj_.build(child_)
            self.instrumentId.append(obj_)
            obj_.original_tagname_ = 'instrumentId'
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
            # validate type String
            self.validate_String(self.description)
        elif nodeName_ == 'currency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        super(Cash, self).buildChildren(child_, node, nodeName_, True)
# end class Cash


class Commission(GeneratedsSuper):
    """A type describing the commission that will be charged for each of
    the hedge transactions."""
    member_data_items_ = {
        'commissionDenomination': MemberSpec_('commissionDenomination', ['CommissionDenominationEnum', 'Token', 'xsd:token'], 0),
        'commissionAmount': MemberSpec_('commissionAmount', 'xsd:decimal', 0),
        'currency': MemberSpec_('currency', 'Currency', 0),
        'commissionPerTrade': MemberSpec_('commissionPerTrade', 'xsd:decimal', 0),
        'fxRate': MemberSpec_('fxRate', 'FxRate', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, commissionDenomination=None, commissionAmount=None, currency=None, commissionPerTrade=None, fxRate=None):
        self.original_tagname_ = None
        self.commissionDenomination = commissionDenomination
        self.validate_CommissionDenominationEnum(self.commissionDenomination)
        self.commissionAmount = commissionAmount
        self.currency = currency
        self.commissionPerTrade = commissionPerTrade
        if fxRate is None:
            self.fxRate = []
        else:
            self.fxRate = fxRate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Commission)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Commission.subclass:
            return Commission.subclass(*args_, **kwargs_)
        else:
            return Commission(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commissionDenomination(self): return self.commissionDenomination
    def set_commissionDenomination(self, commissionDenomination): self.commissionDenomination = commissionDenomination
    def get_commissionAmount(self): return self.commissionAmount
    def set_commissionAmount(self, commissionAmount): self.commissionAmount = commissionAmount
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_commissionPerTrade(self): return self.commissionPerTrade
    def set_commissionPerTrade(self, commissionPerTrade): self.commissionPerTrade = commissionPerTrade
    def get_fxRate(self): return self.fxRate
    def set_fxRate(self, fxRate): self.fxRate = fxRate
    def add_fxRate(self, value): self.fxRate.append(value)
    def insert_fxRate_at(self, index, value): self.fxRate.insert(index, value)
    def replace_fxRate_at(self, index, value): self.fxRate[index] = value
    def validate_CommissionDenominationEnum(self, value):
        # Validate type CommissionDenominationEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['BPS', 'Percentage', 'CentsPerShare', 'FixedAmount']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CommissionDenominationEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on CommissionDenominationEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.commissionDenomination is not None or
            self.commissionAmount is not None or
            self.currency is not None or
            self.commissionPerTrade is not None or
            self.fxRate
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Commission', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Commission')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Commission', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Commission'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Commission', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.commissionDenomination is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scommissionDenomination>%s</%scommissionDenomination>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.commissionDenomination), input_name='commissionDenomination')), namespace_, eol_))
        if self.commissionAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scommissionAmount>%s</%scommissionAmount>%s' % (namespace_, self.gds_format_float(self.commissionAmount, input_name='commissionAmount'), namespace_, eol_))
        if self.currency is not None:
            self.currency.export(outfile, level, namespace_, name_='currency', pretty_print=pretty_print)
        if self.commissionPerTrade is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scommissionPerTrade>%s</%scommissionPerTrade>%s' % (namespace_, self.gds_format_float(self.commissionPerTrade, input_name='commissionPerTrade'), namespace_, eol_))
        for fxRate_ in self.fxRate:
            fxRate_.export(outfile, level, namespace_, name_='fxRate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'commissionDenomination':
            commissionDenomination_ = child_.text
            commissionDenomination_ = re_.sub(String_cleanup_pat_, " ", commissionDenomination_).strip()
            commissionDenomination_ = self.gds_validate_string(commissionDenomination_, node, 'commissionDenomination')
            self.commissionDenomination = commissionDenomination_
            # validate type CommissionDenominationEnum
            self.validate_CommissionDenominationEnum(self.commissionDenomination)
        elif nodeName_ == 'commissionAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'commissionAmount')
            self.commissionAmount = fval_
        elif nodeName_ == 'currency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'commissionPerTrade':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'commissionPerTrade')
            self.commissionPerTrade = fval_
        elif nodeName_ == 'fxRate':
            obj_ = FxRate.factory()
            obj_.build(child_)
            self.fxRate.append(obj_)
            obj_.original_tagname_ = 'fxRate'
# end class Commission


class CommodityBase(GeneratedsSuper):
    member_data_items_ = {
        'commodityBaseScheme': MemberSpec_('commodityBaseScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, commodityBaseScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.commodityBaseScheme = _cast(None, commodityBaseScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityBase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityBase.subclass:
            return CommodityBase.subclass(*args_, **kwargs_)
        else:
            return CommodityBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commodityBaseScheme(self): return self.commodityBaseScheme
    def set_commodityBaseScheme(self, commodityBaseScheme): self.commodityBaseScheme = commodityBaseScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityBase', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityBase')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityBase', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityBase'):
        if self.commodityBaseScheme is not None and 'commodityBaseScheme' not in already_processed:
            already_processed.add('commodityBaseScheme')
            outfile.write(' commodityBaseScheme=%s' % (quote_attrib(self.commodityBaseScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityBase', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('commodityBaseScheme', node)
        if value is not None and 'commodityBaseScheme' not in already_processed:
            already_processed.add('commodityBaseScheme')
            self.commodityBaseScheme = value
            self.validate_NonEmptyURI(self.commodityBaseScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CommodityBase


class CommodityBusinessCalendar(GeneratedsSuper):
    """Defines a commodity business day calendar."""
    member_data_items_ = {
        'commodityBusinessCalendarScheme': MemberSpec_('commodityBusinessCalendarScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, commodityBusinessCalendarScheme='http://www.fpml.org/coding-scheme/commodity-business-calendar', valueOf_=None):
        self.original_tagname_ = None
        self.commodityBusinessCalendarScheme = _cast(None, commodityBusinessCalendarScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityBusinessCalendar)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityBusinessCalendar.subclass:
            return CommodityBusinessCalendar.subclass(*args_, **kwargs_)
        else:
            return CommodityBusinessCalendar(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commodityBusinessCalendarScheme(self): return self.commodityBusinessCalendarScheme
    def set_commodityBusinessCalendarScheme(self, commodityBusinessCalendarScheme): self.commodityBusinessCalendarScheme = commodityBusinessCalendarScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityBusinessCalendar', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityBusinessCalendar')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityBusinessCalendar', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityBusinessCalendar'):
        if self.commodityBusinessCalendarScheme != "http://www.fpml.org/coding-scheme/commodity-business-calendar" and 'commodityBusinessCalendarScheme' not in already_processed:
            already_processed.add('commodityBusinessCalendarScheme')
            outfile.write(' commodityBusinessCalendarScheme=%s' % (quote_attrib(self.commodityBusinessCalendarScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityBusinessCalendar', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('commodityBusinessCalendarScheme', node)
        if value is not None and 'commodityBusinessCalendarScheme' not in already_processed:
            already_processed.add('commodityBusinessCalendarScheme')
            self.commodityBusinessCalendarScheme = value
            self.validate_NonEmptyURI(self.commodityBusinessCalendarScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CommodityBusinessCalendar


class CommodityDetails(GeneratedsSuper):
    member_data_items_ = {
        'commodityDetailsScheme': MemberSpec_('commodityDetailsScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, commodityDetailsScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.commodityDetailsScheme = _cast(None, commodityDetailsScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityDetails)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityDetails.subclass:
            return CommodityDetails.subclass(*args_, **kwargs_)
        else:
            return CommodityDetails(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commodityDetailsScheme(self): return self.commodityDetailsScheme
    def set_commodityDetailsScheme(self, commodityDetailsScheme): self.commodityDetailsScheme = commodityDetailsScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityDetails', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityDetails')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityDetails', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityDetails'):
        if self.commodityDetailsScheme is not None and 'commodityDetailsScheme' not in already_processed:
            already_processed.add('commodityDetailsScheme')
            outfile.write(' commodityDetailsScheme=%s' % (quote_attrib(self.commodityDetailsScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityDetails', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('commodityDetailsScheme', node)
        if value is not None and 'commodityDetailsScheme' not in already_processed:
            already_processed.add('commodityDetailsScheme')
            self.commodityDetailsScheme = value
            self.validate_NonEmptyURI(self.commodityDetailsScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CommodityDetails


class CommodityInformationProvider(GeneratedsSuper):
    """The publication in which the rate, price, index or factor is to be
    found. (e.g Gas Daily, Platts Bloomberg.)"""
    member_data_items_ = {
        'informationProviderScheme': MemberSpec_('informationProviderScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, informationProviderScheme='http://www.fpml.org/coding-scheme/commodity-information-provider', valueOf_=None):
        self.original_tagname_ = None
        self.informationProviderScheme = _cast(None, informationProviderScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityInformationProvider)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityInformationProvider.subclass:
            return CommodityInformationProvider.subclass(*args_, **kwargs_)
        else:
            return CommodityInformationProvider(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_informationProviderScheme(self): return self.informationProviderScheme
    def set_informationProviderScheme(self, informationProviderScheme): self.informationProviderScheme = informationProviderScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityInformationProvider', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityInformationProvider')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityInformationProvider', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityInformationProvider'):
        if self.informationProviderScheme != "http://www.fpml.org/coding-scheme/commodity-information-provider" and 'informationProviderScheme' not in already_processed:
            already_processed.add('informationProviderScheme')
            outfile.write(' informationProviderScheme=%s' % (quote_attrib(self.informationProviderScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityInformationProvider', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('informationProviderScheme', node)
        if value is not None and 'informationProviderScheme' not in already_processed:
            already_processed.add('informationProviderScheme')
            self.informationProviderScheme = value
            self.validate_NonEmptyURI(self.informationProviderScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CommodityInformationProvider


class CommodityInformationSource(GeneratedsSuper):
    """A type defining the source of a commodity rate, price or index or of
    a market rate or of a conversion factor (e.g. a fx conversion
    factor)."""
    member_data_items_ = {
        'rateSource': MemberSpec_('rateSource', 'CommodityInformationProvider', 0),
        'rateSourcePage': MemberSpec_('rateSourcePage', 'RateSourcePage', 0),
        'rateSourcePageHeading': MemberSpec_('rateSourcePageHeading', ['String', 'xsd:string'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, rateSource=None, rateSourcePage=None, rateSourcePageHeading=None):
        self.original_tagname_ = None
        self.rateSource = rateSource
        self.rateSourcePage = rateSourcePage
        self.rateSourcePageHeading = rateSourcePageHeading
        self.validate_String(self.rateSourcePageHeading)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityInformationSource)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityInformationSource.subclass:
            return CommodityInformationSource.subclass(*args_, **kwargs_)
        else:
            return CommodityInformationSource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rateSource(self): return self.rateSource
    def set_rateSource(self, rateSource): self.rateSource = rateSource
    def get_rateSourcePage(self): return self.rateSourcePage
    def set_rateSourcePage(self, rateSourcePage): self.rateSourcePage = rateSourcePage
    def get_rateSourcePageHeading(self): return self.rateSourcePageHeading
    def set_rateSourcePageHeading(self, rateSourcePageHeading): self.rateSourcePageHeading = rateSourcePageHeading
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.rateSource is not None or
            self.rateSourcePage is not None or
            self.rateSourcePageHeading is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityInformationSource', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityInformationSource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityInformationSource', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityInformationSource'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityInformationSource', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.rateSource is not None:
            self.rateSource.export(outfile, level, namespace_, name_='rateSource', pretty_print=pretty_print)
        if self.rateSourcePage is not None:
            self.rateSourcePage.export(outfile, level, namespace_, name_='rateSourcePage', pretty_print=pretty_print)
        if self.rateSourcePageHeading is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srateSourcePageHeading>%s</%srateSourcePageHeading>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.rateSourcePageHeading), input_name='rateSourcePageHeading')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'rateSource':
            obj_ = CommodityInformationProvider.factory()
            obj_.build(child_)
            self.rateSource = obj_
            obj_.original_tagname_ = 'rateSource'
        elif nodeName_ == 'rateSourcePage':
            obj_ = RateSourcePage.factory()
            obj_.build(child_)
            self.rateSourcePage = obj_
            obj_.original_tagname_ = 'rateSourcePage'
        elif nodeName_ == 'rateSourcePageHeading':
            rateSourcePageHeading_ = child_.text
            rateSourcePageHeading_ = self.gds_validate_string(rateSourcePageHeading_, node, 'rateSourcePageHeading')
            self.rateSourcePageHeading = rateSourcePageHeading_
            # validate type String
            self.validate_String(self.rateSourcePageHeading)
# end class CommodityInformationSource


class ConstituentWeight(GeneratedsSuper):
    """A type describing the weight of each of the underlyer constituent
    within the basket, either in absolute or relative terms."""
    member_data_items_ = {
        'openUnits': MemberSpec_('openUnits', 'xsd:decimal', 0),
        'basketPercentage': MemberSpec_('basketPercentage', ['RestrictedPercentage', 'xsd:decimal'], 0),
        'basketAmount': MemberSpec_('basketAmount', 'Money', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, openUnits=None, basketPercentage=None, basketAmount=None):
        self.original_tagname_ = None
        self.openUnits = openUnits
        self.basketPercentage = basketPercentage
        self.validate_RestrictedPercentage(self.basketPercentage)
        self.basketAmount = basketAmount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConstituentWeight)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConstituentWeight.subclass:
            return ConstituentWeight.subclass(*args_, **kwargs_)
        else:
            return ConstituentWeight(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_openUnits(self): return self.openUnits
    def set_openUnits(self, openUnits): self.openUnits = openUnits
    def get_basketPercentage(self): return self.basketPercentage
    def set_basketPercentage(self, basketPercentage): self.basketPercentage = basketPercentage
    def get_basketAmount(self): return self.basketAmount
    def set_basketAmount(self, basketAmount): self.basketAmount = basketAmount
    def validate_RestrictedPercentage(self, value):
        # Validate type RestrictedPercentage, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on RestrictedPercentage' % {"value" : value} )
            if value > 1:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on RestrictedPercentage' % {"value" : value} )
    def hasContent_(self):
        if (
            self.openUnits is not None or
            self.basketPercentage is not None or
            self.basketAmount is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ConstituentWeight', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConstituentWeight')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ConstituentWeight', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConstituentWeight'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ConstituentWeight', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.openUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sopenUnits>%s</%sopenUnits>%s' % (namespace_, self.gds_format_float(self.openUnits, input_name='openUnits'), namespace_, eol_))
        if self.basketPercentage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbasketPercentage>%s</%sbasketPercentage>%s' % (namespace_, self.gds_format_float(self.basketPercentage, input_name='basketPercentage'), namespace_, eol_))
        if self.basketAmount is not None:
            self.basketAmount.export(outfile, level, namespace_, name_='basketAmount', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'openUnits':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'openUnits')
            self.openUnits = fval_
        elif nodeName_ == 'basketPercentage':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'basketPercentage')
            self.basketPercentage = fval_
            # validate type RestrictedPercentage
            self.validate_RestrictedPercentage(self.basketPercentage)
        elif nodeName_ == 'basketAmount':
            class_obj_ = self.get_class_obj_(child_, Money)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.basketAmount = obj_
            obj_.original_tagname_ = 'basketAmount'
# end class ConstituentWeight


class CouponType(GeneratedsSuper):
    """Defines a scheme of values for specifiying if the bond has a
    variable coupon, step-up/down coupon or a zero-coupon."""
    member_data_items_ = {
        'couponTypeScheme': MemberSpec_('couponTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, couponTypeScheme='http://www.fpml.org/coding-scheme/coupon-type', valueOf_=None):
        self.original_tagname_ = None
        self.couponTypeScheme = _cast(None, couponTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CouponType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CouponType.subclass:
            return CouponType.subclass(*args_, **kwargs_)
        else:
            return CouponType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_couponTypeScheme(self): return self.couponTypeScheme
    def set_couponTypeScheme(self, couponTypeScheme): self.couponTypeScheme = couponTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CouponType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CouponType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CouponType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CouponType'):
        if self.couponTypeScheme != "http://www.fpml.org/coding-scheme/coupon-type" and 'couponTypeScheme' not in already_processed:
            already_processed.add('couponTypeScheme')
            outfile.write(' couponTypeScheme=%s' % (quote_attrib(self.couponTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CouponType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('couponTypeScheme', node)
        if value is not None and 'couponTypeScheme' not in already_processed:
            already_processed.add('couponTypeScheme')
            self.couponTypeScheme = value
            self.validate_NonEmptyURI(self.couponTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CouponType


class DeliveryNearby(GeneratedsSuper):
    """A type defines nearest Delivery Date of the underlying Commodity of
    expiration of the futures contract."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'deliveryNearbyMultiplier': MemberSpec_('deliveryNearbyMultiplier', 'xsd:positiveInteger', 0),
        'deliveryNearbyType': MemberSpec_('deliveryNearbyType', ['DeliveryNearbyTypeEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, deliveryNearbyMultiplier=None, deliveryNearbyType=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.deliveryNearbyMultiplier = deliveryNearbyMultiplier
        self.deliveryNearbyType = deliveryNearbyType
        self.validate_DeliveryNearbyTypeEnum(self.deliveryNearbyType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DeliveryNearby)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DeliveryNearby.subclass:
            return DeliveryNearby.subclass(*args_, **kwargs_)
        else:
            return DeliveryNearby(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_deliveryNearbyMultiplier(self): return self.deliveryNearbyMultiplier
    def set_deliveryNearbyMultiplier(self, deliveryNearbyMultiplier): self.deliveryNearbyMultiplier = deliveryNearbyMultiplier
    def get_deliveryNearbyType(self): return self.deliveryNearbyType
    def set_deliveryNearbyType(self, deliveryNearbyType): self.deliveryNearbyType = deliveryNearbyType
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_DeliveryNearbyTypeEnum(self, value):
        # Validate type DeliveryNearbyTypeEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CalculationPeriod', 'NearbyMonth', 'NearbyWeek']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeliveryNearbyTypeEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on DeliveryNearbyTypeEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.deliveryNearbyMultiplier is not None or
            self.deliveryNearbyType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DeliveryNearby', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeliveryNearby')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DeliveryNearby', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DeliveryNearby'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DeliveryNearby', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.deliveryNearbyMultiplier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdeliveryNearbyMultiplier>%s</%sdeliveryNearbyMultiplier>%s' % (namespace_, self.gds_format_integer(self.deliveryNearbyMultiplier, input_name='deliveryNearbyMultiplier'), namespace_, eol_))
        if self.deliveryNearbyType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdeliveryNearbyType>%s</%sdeliveryNearbyType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.deliveryNearbyType), input_name='deliveryNearbyType')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'deliveryNearbyMultiplier':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'deliveryNearbyMultiplier')
            self.deliveryNearbyMultiplier = ival_
        elif nodeName_ == 'deliveryNearbyType':
            deliveryNearbyType_ = child_.text
            deliveryNearbyType_ = re_.sub(String_cleanup_pat_, " ", deliveryNearbyType_).strip()
            deliveryNearbyType_ = self.gds_validate_string(deliveryNearbyType_, node, 'deliveryNearbyType')
            self.deliveryNearbyType = deliveryNearbyType_
            # validate type DeliveryNearbyTypeEnum
            self.validate_DeliveryNearbyTypeEnum(self.deliveryNearbyType)
# end class DeliveryNearby


class DividendPayout(GeneratedsSuper):
    """A type describing the dividend payout ratio associated with an
    equity underlyer. In certain cases the actual ratio is not known
    on trade inception, and only general conditions are then
    specified.A sequence group to describe the total, cash, and non
    cash dividend payout ratio associated with an equity underlyer.
    In certain cases the actual ratio is not known on trade
    inception, and only general conditions are then specified. Good
    practice is to specify only two of the three values, to avoid
    any inconsistency"""
    member_data_items_ = {
        'dividendPayoutRatio': MemberSpec_('dividendPayoutRatio', 'xsd:decimal', 0),
        'dividendPayoutRatioCash': MemberSpec_('dividendPayoutRatioCash', 'xsd:decimal', 0),
        'dividendPayoutRatioNonCash': MemberSpec_('dividendPayoutRatioNonCash', 'xsd:decimal', 0),
        'dividendPayoutConditions': MemberSpec_('dividendPayoutConditions', ['String', 'xsd:string'], 0),
        'dividendPayment': MemberSpec_('dividendPayment', 'PendingPayment', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, dividendPayoutRatio=None, dividendPayoutRatioCash=None, dividendPayoutRatioNonCash=None, dividendPayoutConditions=None, dividendPayment=None):
        self.original_tagname_ = None
        self.dividendPayoutRatio = dividendPayoutRatio
        self.dividendPayoutRatioCash = dividendPayoutRatioCash
        self.dividendPayoutRatioNonCash = dividendPayoutRatioNonCash
        self.dividendPayoutConditions = dividendPayoutConditions
        self.validate_String(self.dividendPayoutConditions)
        if dividendPayment is None:
            self.dividendPayment = []
        else:
            self.dividendPayment = dividendPayment
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DividendPayout)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DividendPayout.subclass:
            return DividendPayout.subclass(*args_, **kwargs_)
        else:
            return DividendPayout(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dividendPayoutRatio(self): return self.dividendPayoutRatio
    def set_dividendPayoutRatio(self, dividendPayoutRatio): self.dividendPayoutRatio = dividendPayoutRatio
    def get_dividendPayoutRatioCash(self): return self.dividendPayoutRatioCash
    def set_dividendPayoutRatioCash(self, dividendPayoutRatioCash): self.dividendPayoutRatioCash = dividendPayoutRatioCash
    def get_dividendPayoutRatioNonCash(self): return self.dividendPayoutRatioNonCash
    def set_dividendPayoutRatioNonCash(self, dividendPayoutRatioNonCash): self.dividendPayoutRatioNonCash = dividendPayoutRatioNonCash
    def get_dividendPayoutConditions(self): return self.dividendPayoutConditions
    def set_dividendPayoutConditions(self, dividendPayoutConditions): self.dividendPayoutConditions = dividendPayoutConditions
    def get_dividendPayment(self): return self.dividendPayment
    def set_dividendPayment(self, dividendPayment): self.dividendPayment = dividendPayment
    def add_dividendPayment(self, value): self.dividendPayment.append(value)
    def insert_dividendPayment_at(self, index, value): self.dividendPayment.insert(index, value)
    def replace_dividendPayment_at(self, index, value): self.dividendPayment[index] = value
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.dividendPayoutRatio is not None or
            self.dividendPayoutRatioCash is not None or
            self.dividendPayoutRatioNonCash is not None or
            self.dividendPayoutConditions is not None or
            self.dividendPayment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DividendPayout', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DividendPayout')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DividendPayout', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DividendPayout'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DividendPayout', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dividendPayoutRatio is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdividendPayoutRatio>%s</%sdividendPayoutRatio>%s' % (namespace_, self.gds_format_float(self.dividendPayoutRatio, input_name='dividendPayoutRatio'), namespace_, eol_))
        if self.dividendPayoutRatioCash is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdividendPayoutRatioCash>%s</%sdividendPayoutRatioCash>%s' % (namespace_, self.gds_format_float(self.dividendPayoutRatioCash, input_name='dividendPayoutRatioCash'), namespace_, eol_))
        if self.dividendPayoutRatioNonCash is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdividendPayoutRatioNonCash>%s</%sdividendPayoutRatioNonCash>%s' % (namespace_, self.gds_format_float(self.dividendPayoutRatioNonCash, input_name='dividendPayoutRatioNonCash'), namespace_, eol_))
        if self.dividendPayoutConditions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdividendPayoutConditions>%s</%sdividendPayoutConditions>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.dividendPayoutConditions), input_name='dividendPayoutConditions')), namespace_, eol_))
        for dividendPayment_ in self.dividendPayment:
            dividendPayment_.export(outfile, level, namespace_, name_='dividendPayment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dividendPayoutRatio':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'dividendPayoutRatio')
            self.dividendPayoutRatio = fval_
        elif nodeName_ == 'dividendPayoutRatioCash':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'dividendPayoutRatioCash')
            self.dividendPayoutRatioCash = fval_
        elif nodeName_ == 'dividendPayoutRatioNonCash':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'dividendPayoutRatioNonCash')
            self.dividendPayoutRatioNonCash = fval_
        elif nodeName_ == 'dividendPayoutConditions':
            dividendPayoutConditions_ = child_.text
            dividendPayoutConditions_ = self.gds_validate_string(dividendPayoutConditions_, node, 'dividendPayoutConditions')
            self.dividendPayoutConditions = dividendPayoutConditions_
            # validate type String
            self.validate_String(self.dividendPayoutConditions)
        elif nodeName_ == 'dividendPayment':
            obj_ = PendingPayment.factory()
            obj_.build(child_)
            self.dividendPayment.append(obj_)
            obj_.original_tagname_ = 'dividendPayment'
# end class DividendPayout


class FacilityType(GeneratedsSuper):
    """A type describing the type of loan facility."""
    member_data_items_ = {
        'facilityTypeScheme': MemberSpec_('facilityTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, facilityTypeScheme='http://www.fpml.org/coding-scheme/facility-type', valueOf_=None):
        self.original_tagname_ = None
        self.facilityTypeScheme = _cast(None, facilityTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FacilityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FacilityType.subclass:
            return FacilityType.subclass(*args_, **kwargs_)
        else:
            return FacilityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_facilityTypeScheme(self): return self.facilityTypeScheme
    def set_facilityTypeScheme(self, facilityTypeScheme): self.facilityTypeScheme = facilityTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FacilityType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FacilityType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FacilityType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FacilityType'):
        if self.facilityTypeScheme != "http://www.fpml.org/coding-scheme/facility-type" and 'facilityTypeScheme' not in already_processed:
            already_processed.add('facilityTypeScheme')
            outfile.write(' facilityTypeScheme=%s' % (quote_attrib(self.facilityTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='FacilityType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('facilityTypeScheme', node)
        if value is not None and 'facilityTypeScheme' not in already_processed:
            already_processed.add('facilityTypeScheme')
            self.facilityTypeScheme = value
            self.validate_NonEmptyURI(self.facilityTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FacilityType


class FutureId(GeneratedsSuper):
    """A type defining a short form unique identifier for a future
    contract."""
    member_data_items_ = {
        'futureIdScheme': MemberSpec_('futureIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, futureIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.futureIdScheme = _cast(None, futureIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FutureId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FutureId.subclass:
            return FutureId.subclass(*args_, **kwargs_)
        else:
            return FutureId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_futureIdScheme(self): return self.futureIdScheme
    def set_futureIdScheme(self, futureIdScheme): self.futureIdScheme = futureIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FutureId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FutureId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FutureId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FutureId'):
        if self.futureIdScheme is not None and 'futureIdScheme' not in already_processed:
            already_processed.add('futureIdScheme')
            outfile.write(' futureIdScheme=%s' % (quote_attrib(self.futureIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='FutureId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('futureIdScheme', node)
        if value is not None and 'futureIdScheme' not in already_processed:
            already_processed.add('futureIdScheme')
            self.futureIdScheme = value
            self.validate_NonEmptyURI(self.futureIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FutureId


class FxConversion(GeneratedsSuper):
    member_data_items_ = {
        'amountRelativeTo': MemberSpec_('amountRelativeTo', 'AmountReference', 0),
        'fxRate': MemberSpec_('fxRate', 'FxRate', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, amountRelativeTo=None, fxRate=None):
        self.original_tagname_ = None
        self.amountRelativeTo = amountRelativeTo
        if fxRate is None:
            self.fxRate = []
        else:
            self.fxRate = fxRate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FxConversion)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FxConversion.subclass:
            return FxConversion.subclass(*args_, **kwargs_)
        else:
            return FxConversion(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_amountRelativeTo(self): return self.amountRelativeTo
    def set_amountRelativeTo(self, amountRelativeTo): self.amountRelativeTo = amountRelativeTo
    def get_fxRate(self): return self.fxRate
    def set_fxRate(self, fxRate): self.fxRate = fxRate
    def add_fxRate(self, value): self.fxRate.append(value)
    def insert_fxRate_at(self, index, value): self.fxRate.insert(index, value)
    def replace_fxRate_at(self, index, value): self.fxRate[index] = value
    def hasContent_(self):
        if (
            self.amountRelativeTo is not None or
            self.fxRate
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FxConversion', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FxConversion')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FxConversion', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FxConversion'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FxConversion', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.amountRelativeTo is not None:
            self.amountRelativeTo.export(outfile, level, namespace_, name_='amountRelativeTo', pretty_print=pretty_print)
        for fxRate_ in self.fxRate:
            fxRate_.export(outfile, level, namespace_, name_='fxRate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'amountRelativeTo':
            obj_ = AmountReference.factory()
            obj_.build(child_)
            self.amountRelativeTo = obj_
            obj_.original_tagname_ = 'amountRelativeTo'
        elif nodeName_ == 'fxRate':
            obj_ = FxRate.factory()
            obj_.build(child_)
            self.fxRate.append(obj_)
            obj_.original_tagname_ = 'fxRate'
# end class FxConversion


class IdentifiedAsset(Asset):
    """A generic type describing an identified asset."""
    member_data_items_ = {
        'instrumentId': MemberSpec_('instrumentId', 'InstrumentId', 1),
        'description': MemberSpec_('description', ['String', 'xsd:string'], 0),
    }
    subclass = None
    superclass = Asset
    def __init__(self, id=None, instrumentId=None, description=None, extensiontype_=None):
        self.original_tagname_ = None
        super(IdentifiedAsset, self).__init__(id, extensiontype_, )
        if instrumentId is None:
            self.instrumentId = []
        else:
            self.instrumentId = instrumentId
        self.description = description
        self.validate_String(self.description)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IdentifiedAsset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IdentifiedAsset.subclass:
            return IdentifiedAsset.subclass(*args_, **kwargs_)
        else:
            return IdentifiedAsset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_instrumentId(self): return self.instrumentId
    def set_instrumentId(self, instrumentId): self.instrumentId = instrumentId
    def add_instrumentId(self, value): self.instrumentId.append(value)
    def insert_instrumentId_at(self, index, value): self.instrumentId.insert(index, value)
    def replace_instrumentId_at(self, index, value): self.instrumentId[index] = value
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.instrumentId or
            self.description is not None or
            super(IdentifiedAsset, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IdentifiedAsset', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifiedAsset')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IdentifiedAsset', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IdentifiedAsset'):
        super(IdentifiedAsset, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifiedAsset')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='IdentifiedAsset', fromsubclass_=False, pretty_print=True):
        super(IdentifiedAsset, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for instrumentId_ in self.instrumentId:
            instrumentId_.export(outfile, level, namespace_, name_='instrumentId', pretty_print=pretty_print)
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(IdentifiedAsset, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'instrumentId':
            obj_ = InstrumentId.factory()
            obj_.build(child_)
            self.instrumentId.append(obj_)
            obj_.original_tagname_ = 'instrumentId'
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
            # validate type String
            self.validate_String(self.description)
        super(IdentifiedAsset, self).buildChildren(child_, node, nodeName_, True)
# end class IdentifiedAsset


class Lien(GeneratedsSuper):
    """A type describing the liens associated with a loan facility."""
    member_data_items_ = {
        'lienScheme': MemberSpec_('lienScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, lienScheme='http://www.fpml.org/coding-scheme/designated-priority', valueOf_=None):
        self.original_tagname_ = None
        self.lienScheme = _cast(None, lienScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Lien)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Lien.subclass:
            return Lien.subclass(*args_, **kwargs_)
        else:
            return Lien(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lienScheme(self): return self.lienScheme
    def set_lienScheme(self, lienScheme): self.lienScheme = lienScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Lien', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Lien')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Lien', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Lien'):
        if self.lienScheme != "http://www.fpml.org/coding-scheme/designated-priority" and 'lienScheme' not in already_processed:
            already_processed.add('lienScheme')
            outfile.write(' lienScheme=%s' % (quote_attrib(self.lienScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Lien', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lienScheme', node)
        if value is not None and 'lienScheme' not in already_processed:
            already_processed.add('lienScheme')
            self.lienScheme = value
            self.validate_NonEmptyURI(self.lienScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Lien


class MortgageSector(GeneratedsSuper):
    """A type describing the typology of mortgage obligations."""
    member_data_items_ = {
        'mortgageSectorScheme': MemberSpec_('mortgageSectorScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, mortgageSectorScheme='http://www.fpml.org/coding-scheme/mortgage-sector', valueOf_=None):
        self.original_tagname_ = None
        self.mortgageSectorScheme = _cast(None, mortgageSectorScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MortgageSector)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MortgageSector.subclass:
            return MortgageSector.subclass(*args_, **kwargs_)
        else:
            return MortgageSector(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mortgageSectorScheme(self): return self.mortgageSectorScheme
    def set_mortgageSectorScheme(self, mortgageSectorScheme): self.mortgageSectorScheme = mortgageSectorScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MortgageSector', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MortgageSector')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MortgageSector', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MortgageSector'):
        if self.mortgageSectorScheme != "http://www.fpml.org/coding-scheme/mortgage-sector" and 'mortgageSectorScheme' not in already_processed:
            already_processed.add('mortgageSectorScheme')
            outfile.write(' mortgageSectorScheme=%s' % (quote_attrib(self.mortgageSectorScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MortgageSector', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mortgageSectorScheme', node)
        if value is not None and 'mortgageSectorScheme' not in already_processed:
            already_processed.add('mortgageSectorScheme')
            self.mortgageSectorScheme = value
            self.validate_NonEmptyURI(self.mortgageSectorScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MortgageSector


class Price(GeneratedsSuper):
    """A type describing the strike price."""
    member_data_items_ = {
        'commission': MemberSpec_('commission', 'Commission', 0),
        'determinationMethod': MemberSpec_('determinationMethod', 'DeterminationMethod', 0),
        'grossPrice': MemberSpec_('grossPrice', 'ActualPrice', 0),
        'netPrice': MemberSpec_('netPrice', 'ActualPrice', 0),
        'accruedInterestPrice': MemberSpec_('accruedInterestPrice', 'xsd:decimal', 0),
        'fxConversion': MemberSpec_('fxConversion', 'FxConversion', 0),
        'amountRelativeTo': MemberSpec_('amountRelativeTo', 'AmountReference', 0),
        'grossPrice': MemberSpec_('grossPrice', 'ActualPrice', 0),
        'netPrice': MemberSpec_('netPrice', 'ActualPrice', 0),
        'accruedInterestPrice': MemberSpec_('accruedInterestPrice', 'xsd:decimal', 0),
        'fxConversion': MemberSpec_('fxConversion', 'FxConversion', 0),
        'cleanNetPrice': MemberSpec_('cleanNetPrice', 'xsd:decimal', 0),
        'quotationCharacteristics': MemberSpec_('quotationCharacteristics', 'QuotationCharacteristics', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, commission=None, determinationMethod=None, grossPrice=None, netPrice=None, accruedInterestPrice=None, fxConversion=None, amountRelativeTo=None, cleanNetPrice=None, quotationCharacteristics=None):
        self.original_tagname_ = None
        self.commission = commission
        self.determinationMethod = determinationMethod
        self.grossPrice = grossPrice
        self.netPrice = netPrice
        self.accruedInterestPrice = accruedInterestPrice
        self.fxConversion = fxConversion
        self.amountRelativeTo = amountRelativeTo
        self.grossPrice = grossPrice
        self.netPrice = netPrice
        self.accruedInterestPrice = accruedInterestPrice
        self.fxConversion = fxConversion
        self.cleanNetPrice = cleanNetPrice
        self.quotationCharacteristics = quotationCharacteristics
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Price)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Price.subclass:
            return Price.subclass(*args_, **kwargs_)
        else:
            return Price(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commission(self): return self.commission
    def set_commission(self, commission): self.commission = commission
    def get_determinationMethod(self): return self.determinationMethod
    def set_determinationMethod(self, determinationMethod): self.determinationMethod = determinationMethod
    def get_grossPrice(self): return self.grossPrice
    def set_grossPrice(self, grossPrice): self.grossPrice = grossPrice
    def get_netPrice(self): return self.netPrice
    def set_netPrice(self, netPrice): self.netPrice = netPrice
    def get_accruedInterestPrice(self): return self.accruedInterestPrice
    def set_accruedInterestPrice(self, accruedInterestPrice): self.accruedInterestPrice = accruedInterestPrice
    def get_fxConversion(self): return self.fxConversion
    def set_fxConversion(self, fxConversion): self.fxConversion = fxConversion
    def get_amountRelativeTo(self): return self.amountRelativeTo
    def set_amountRelativeTo(self, amountRelativeTo): self.amountRelativeTo = amountRelativeTo
    def get_grossPrice(self): return self.grossPrice
    def set_grossPrice(self, grossPrice): self.grossPrice = grossPrice
    def get_netPrice(self): return self.netPrice
    def set_netPrice(self, netPrice): self.netPrice = netPrice
    def get_accruedInterestPrice(self): return self.accruedInterestPrice
    def set_accruedInterestPrice(self, accruedInterestPrice): self.accruedInterestPrice = accruedInterestPrice
    def get_fxConversion(self): return self.fxConversion
    def set_fxConversion(self, fxConversion): self.fxConversion = fxConversion
    def get_cleanNetPrice(self): return self.cleanNetPrice
    def set_cleanNetPrice(self, cleanNetPrice): self.cleanNetPrice = cleanNetPrice
    def get_quotationCharacteristics(self): return self.quotationCharacteristics
    def set_quotationCharacteristics(self, quotationCharacteristics): self.quotationCharacteristics = quotationCharacteristics
    def hasContent_(self):
        if (
            self.commission is not None or
            self.determinationMethod is not None or
            self.grossPrice is not None or
            self.netPrice is not None or
            self.accruedInterestPrice is not None or
            self.fxConversion is not None or
            self.amountRelativeTo is not None or
            self.grossPrice is not None or
            self.netPrice is not None or
            self.accruedInterestPrice is not None or
            self.fxConversion is not None or
            self.cleanNetPrice is not None or
            self.quotationCharacteristics is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Price', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Price')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Price', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Price'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Price', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.commission is not None:
            self.commission.export(outfile, level, namespace_, name_='commission', pretty_print=pretty_print)
        if self.determinationMethod is not None:
            self.determinationMethod.export(outfile, level, namespace_, name_='determinationMethod', pretty_print=pretty_print)
        if self.grossPrice is not None:
            self.grossPrice.export(outfile, level, namespace_, name_='grossPrice', pretty_print=pretty_print)
        if self.netPrice is not None:
            self.netPrice.export(outfile, level, namespace_, name_='netPrice', pretty_print=pretty_print)
        if self.accruedInterestPrice is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saccruedInterestPrice>%s</%saccruedInterestPrice>%s' % (namespace_, self.gds_format_float(self.accruedInterestPrice, input_name='accruedInterestPrice'), namespace_, eol_))
        if self.fxConversion is not None:
            self.fxConversion.export(outfile, level, namespace_, name_='fxConversion', pretty_print=pretty_print)
        if self.amountRelativeTo is not None:
            self.amountRelativeTo.export(outfile, level, namespace_, name_='amountRelativeTo', pretty_print=pretty_print)
        if self.grossPrice is not None:
            self.grossPrice.export(outfile, level, namespace_, name_='grossPrice', pretty_print=pretty_print)
        if self.netPrice is not None:
            self.netPrice.export(outfile, level, namespace_, name_='netPrice', pretty_print=pretty_print)
        if self.accruedInterestPrice is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saccruedInterestPrice>%s</%saccruedInterestPrice>%s' % (namespace_, self.gds_format_float(self.accruedInterestPrice, input_name='accruedInterestPrice'), namespace_, eol_))
        if self.fxConversion is not None:
            self.fxConversion.export(outfile, level, namespace_, name_='fxConversion', pretty_print=pretty_print)
        if self.cleanNetPrice is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scleanNetPrice>%s</%scleanNetPrice>%s' % (namespace_, self.gds_format_float(self.cleanNetPrice, input_name='cleanNetPrice'), namespace_, eol_))
        if self.quotationCharacteristics is not None:
            self.quotationCharacteristics.export(outfile, level, namespace_, name_='quotationCharacteristics', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'commission':
            obj_ = Commission.factory()
            obj_.build(child_)
            self.commission = obj_
            obj_.original_tagname_ = 'commission'
        elif nodeName_ == 'determinationMethod':
            obj_ = DeterminationMethod.factory()
            obj_.build(child_)
            self.determinationMethod = obj_
            obj_.original_tagname_ = 'determinationMethod'
        elif nodeName_ == 'grossPrice':
            obj_ = ActualPrice.factory()
            obj_.build(child_)
            self.grossPrice = obj_
            obj_.original_tagname_ = 'grossPrice'
        elif nodeName_ == 'netPrice':
            obj_ = ActualPrice.factory()
            obj_.build(child_)
            self.netPrice = obj_
            obj_.original_tagname_ = 'netPrice'
        elif nodeName_ == 'accruedInterestPrice':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'accruedInterestPrice')
            self.accruedInterestPrice = fval_
        elif nodeName_ == 'fxConversion':
            obj_ = FxConversion.factory()
            obj_.build(child_)
            self.fxConversion = obj_
            obj_.original_tagname_ = 'fxConversion'
        elif nodeName_ == 'amountRelativeTo':
            obj_ = AmountReference.factory()
            obj_.build(child_)
            self.amountRelativeTo = obj_
            obj_.original_tagname_ = 'amountRelativeTo'
        elif nodeName_ == 'grossPrice':
            obj_ = ActualPrice.factory()
            obj_.build(child_)
            self.grossPrice = obj_
            obj_.original_tagname_ = 'grossPrice'
        elif nodeName_ == 'netPrice':
            obj_ = ActualPrice.factory()
            obj_.build(child_)
            self.netPrice = obj_
            obj_.original_tagname_ = 'netPrice'
        elif nodeName_ == 'accruedInterestPrice':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'accruedInterestPrice')
            self.accruedInterestPrice = fval_
        elif nodeName_ == 'fxConversion':
            obj_ = FxConversion.factory()
            obj_.build(child_)
            self.fxConversion = obj_
            obj_.original_tagname_ = 'fxConversion'
        elif nodeName_ == 'cleanNetPrice':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'cleanNetPrice')
            self.cleanNetPrice = fval_
        elif nodeName_ == 'quotationCharacteristics':
            obj_ = QuotationCharacteristics.factory()
            obj_.build(child_)
            self.quotationCharacteristics = obj_
            obj_.original_tagname_ = 'quotationCharacteristics'
# end class Price


class PriceQuoteUnits(GeneratedsSuper):
    """The units in which a price is quoted."""
    member_data_items_ = {
        'priceQuoteUnitsScheme': MemberSpec_('priceQuoteUnitsScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, priceQuoteUnitsScheme='http://www.fpml.org/coding-scheme/price-quote-units', valueOf_=None):
        self.original_tagname_ = None
        self.priceQuoteUnitsScheme = _cast(None, priceQuoteUnitsScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PriceQuoteUnits)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PriceQuoteUnits.subclass:
            return PriceQuoteUnits.subclass(*args_, **kwargs_)
        else:
            return PriceQuoteUnits(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_priceQuoteUnitsScheme(self): return self.priceQuoteUnitsScheme
    def set_priceQuoteUnitsScheme(self, priceQuoteUnitsScheme): self.priceQuoteUnitsScheme = priceQuoteUnitsScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PriceQuoteUnits', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PriceQuoteUnits')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PriceQuoteUnits', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PriceQuoteUnits'):
        if self.priceQuoteUnitsScheme != "http://www.fpml.org/coding-scheme/price-quote-units" and 'priceQuoteUnitsScheme' not in already_processed:
            already_processed.add('priceQuoteUnitsScheme')
            outfile.write(' priceQuoteUnitsScheme=%s' % (quote_attrib(self.priceQuoteUnitsScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PriceQuoteUnits', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('priceQuoteUnitsScheme', node)
        if value is not None and 'priceQuoteUnitsScheme' not in already_processed:
            already_processed.add('priceQuoteUnitsScheme')
            self.priceQuoteUnitsScheme = value
            self.validate_NonEmptyURI(self.priceQuoteUnitsScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PriceQuoteUnits


class PricingModel(GeneratedsSuper):
    """A scheme identifying the types of pricing model used to evaluate the
    price of an asset. Examples include Intrinsic, ClosedForm,
    MonteCarlo, BackwardInduction."""
    member_data_items_ = {
        'pricingModelScheme': MemberSpec_('pricingModelScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, pricingModelScheme='http://www.fpml.org/coding-scheme/pricing-model', valueOf_=None):
        self.original_tagname_ = None
        self.pricingModelScheme = _cast(None, pricingModelScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PricingModel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PricingModel.subclass:
            return PricingModel.subclass(*args_, **kwargs_)
        else:
            return PricingModel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pricingModelScheme(self): return self.pricingModelScheme
    def set_pricingModelScheme(self, pricingModelScheme): self.pricingModelScheme = pricingModelScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PricingModel', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PricingModel')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PricingModel', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PricingModel'):
        if self.pricingModelScheme != "http://www.fpml.org/coding-scheme/pricing-model" and 'pricingModelScheme' not in already_processed:
            already_processed.add('pricingModelScheme')
            outfile.write(' pricingModelScheme=%s' % (quote_attrib(self.pricingModelScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PricingModel', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pricingModelScheme', node)
        if value is not None and 'pricingModelScheme' not in already_processed:
            already_processed.add('pricingModelScheme')
            self.pricingModelScheme = value
            self.validate_NonEmptyURI(self.pricingModelScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PricingModel


class QuantityUnit(GeneratedsSuper):
    member_data_items_ = {
        'quantityUnitScheme': MemberSpec_('quantityUnitScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, quantityUnitScheme='http://www.fpml.org/coding-scheme/price-quote-units', valueOf_=None):
        self.original_tagname_ = None
        self.quantityUnitScheme = _cast(None, quantityUnitScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QuantityUnit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QuantityUnit.subclass:
            return QuantityUnit.subclass(*args_, **kwargs_)
        else:
            return QuantityUnit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_quantityUnitScheme(self): return self.quantityUnitScheme
    def set_quantityUnitScheme(self, quantityUnitScheme): self.quantityUnitScheme = quantityUnitScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QuantityUnit', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QuantityUnit')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QuantityUnit', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QuantityUnit'):
        if self.quantityUnitScheme != "http://www.fpml.org/coding-scheme/price-quote-units" and 'quantityUnitScheme' not in already_processed:
            already_processed.add('quantityUnitScheme')
            outfile.write(' quantityUnitScheme=%s' % (quote_attrib(self.quantityUnitScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QuantityUnit', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('quantityUnitScheme', node)
        if value is not None and 'quantityUnitScheme' not in already_processed:
            already_processed.add('quantityUnitScheme')
            self.quantityUnitScheme = value
            self.validate_NonEmptyURI(self.quantityUnitScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class QuantityUnit


class QuotationCharacteristics(GeneratedsSuper):
    """A type representing a set of characteristics that describe a
    quotation."""
    member_data_items_ = {
        'measureType': MemberSpec_('measureType', 'AssetMeasureType', 0),
        'quoteUnits': MemberSpec_('quoteUnits', 'PriceQuoteUnits', 0),
        'side': MemberSpec_('side', ['QuotationSideEnum', 'Token', 'xsd:token'], 0),
        'currency': MemberSpec_('currency', 'Currency', 0),
        'currencyType': MemberSpec_('currencyType', 'ReportingCurrencyType', 0),
        'timing': MemberSpec_('timing', 'QuoteTiming', 0),
        'businessCenter': MemberSpec_('businessCenter', 'BusinessCenter', 0),
        'exchangeId': MemberSpec_('exchangeId', 'ExchangeId', 0),
        'informationSource': MemberSpec_('informationSource', 'InformationSource', 1),
        'pricingModel': MemberSpec_('pricingModel', 'PricingModel', 0),
        'time': MemberSpec_('time', 'xsd:dateTime', 0),
        'valuationDate': MemberSpec_('valuationDate', 'xsd:date', 0),
        'expiryTime': MemberSpec_('expiryTime', 'xsd:dateTime', 0),
        'cashflowType': MemberSpec_('cashflowType', 'CashflowType', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, measureType=None, quoteUnits=None, side=None, currency=None, currencyType=None, timing=None, businessCenter=None, exchangeId=None, informationSource=None, pricingModel=None, time=None, valuationDate=None, expiryTime=None, cashflowType=None):
        self.original_tagname_ = None
        self.measureType = measureType
        self.quoteUnits = quoteUnits
        self.side = side
        self.validate_QuotationSideEnum(self.side)
        self.currency = currency
        self.currencyType = currencyType
        self.timing = timing
        self.businessCenter = businessCenter
        self.exchangeId = exchangeId
        if informationSource is None:
            self.informationSource = []
        else:
            self.informationSource = informationSource
        self.pricingModel = pricingModel
        if isinstance(time, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(time, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = time
        self.time = initvalue_
        if isinstance(valuationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(valuationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = valuationDate
        self.valuationDate = initvalue_
        if isinstance(expiryTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(expiryTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = expiryTime
        self.expiryTime = initvalue_
        self.cashflowType = cashflowType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QuotationCharacteristics)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QuotationCharacteristics.subclass:
            return QuotationCharacteristics.subclass(*args_, **kwargs_)
        else:
            return QuotationCharacteristics(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_measureType(self): return self.measureType
    def set_measureType(self, measureType): self.measureType = measureType
    def get_quoteUnits(self): return self.quoteUnits
    def set_quoteUnits(self, quoteUnits): self.quoteUnits = quoteUnits
    def get_side(self): return self.side
    def set_side(self, side): self.side = side
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_currencyType(self): return self.currencyType
    def set_currencyType(self, currencyType): self.currencyType = currencyType
    def get_timing(self): return self.timing
    def set_timing(self, timing): self.timing = timing
    def get_businessCenter(self): return self.businessCenter
    def set_businessCenter(self, businessCenter): self.businessCenter = businessCenter
    def get_exchangeId(self): return self.exchangeId
    def set_exchangeId(self, exchangeId): self.exchangeId = exchangeId
    def get_informationSource(self): return self.informationSource
    def set_informationSource(self, informationSource): self.informationSource = informationSource
    def add_informationSource(self, value): self.informationSource.append(value)
    def insert_informationSource_at(self, index, value): self.informationSource.insert(index, value)
    def replace_informationSource_at(self, index, value): self.informationSource[index] = value
    def get_pricingModel(self): return self.pricingModel
    def set_pricingModel(self, pricingModel): self.pricingModel = pricingModel
    def get_time(self): return self.time
    def set_time(self, time): self.time = time
    def get_valuationDate(self): return self.valuationDate
    def set_valuationDate(self, valuationDate): self.valuationDate = valuationDate
    def get_expiryTime(self): return self.expiryTime
    def set_expiryTime(self, expiryTime): self.expiryTime = expiryTime
    def get_cashflowType(self): return self.cashflowType
    def set_cashflowType(self, cashflowType): self.cashflowType = cashflowType
    def validate_QuotationSideEnum(self, value):
        # Validate type QuotationSideEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Bid', 'Ask', 'Mid']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on QuotationSideEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on QuotationSideEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.measureType is not None or
            self.quoteUnits is not None or
            self.side is not None or
            self.currency is not None or
            self.currencyType is not None or
            self.timing is not None or
            self.businessCenter is not None or
            self.exchangeId is not None or
            self.informationSource or
            self.pricingModel is not None or
            self.time is not None or
            self.valuationDate is not None or
            self.expiryTime is not None or
            self.cashflowType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QuotationCharacteristics', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QuotationCharacteristics')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QuotationCharacteristics', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QuotationCharacteristics'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='QuotationCharacteristics', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.measureType is not None:
            self.measureType.export(outfile, level, namespace_, name_='measureType', pretty_print=pretty_print)
        if self.quoteUnits is not None:
            self.quoteUnits.export(outfile, level, namespace_, name_='quoteUnits', pretty_print=pretty_print)
        if self.side is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sside>%s</%sside>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.side), input_name='side')), namespace_, eol_))
        if self.currency is not None:
            self.currency.export(outfile, level, namespace_, name_='currency', pretty_print=pretty_print)
        if self.currencyType is not None:
            self.currencyType.export(outfile, level, namespace_, name_='currencyType', pretty_print=pretty_print)
        if self.timing is not None:
            self.timing.export(outfile, level, namespace_, name_='timing', pretty_print=pretty_print)
        if self.businessCenter is not None:
            self.businessCenter.export(outfile, level, namespace_, name_='businessCenter', pretty_print=pretty_print)
        if self.exchangeId is not None:
            self.exchangeId.export(outfile, level, namespace_, name_='exchangeId', pretty_print=pretty_print)
        for informationSource_ in self.informationSource:
            informationSource_.export(outfile, level, namespace_, name_='informationSource', pretty_print=pretty_print)
        if self.pricingModel is not None:
            self.pricingModel.export(outfile, level, namespace_, name_='pricingModel', pretty_print=pretty_print)
        if self.time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stime>%s</%stime>%s' % (namespace_, self.gds_format_datetime(self.time, input_name='time'), namespace_, eol_))
        if self.valuationDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svaluationDate>%s</%svaluationDate>%s' % (namespace_, self.gds_format_date(self.valuationDate, input_name='valuationDate'), namespace_, eol_))
        if self.expiryTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexpiryTime>%s</%sexpiryTime>%s' % (namespace_, self.gds_format_datetime(self.expiryTime, input_name='expiryTime'), namespace_, eol_))
        if self.cashflowType is not None:
            self.cashflowType.export(outfile, level, namespace_, name_='cashflowType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'measureType':
            obj_ = AssetMeasureType.factory()
            obj_.build(child_)
            self.measureType = obj_
            obj_.original_tagname_ = 'measureType'
        elif nodeName_ == 'quoteUnits':
            obj_ = PriceQuoteUnits.factory()
            obj_.build(child_)
            self.quoteUnits = obj_
            obj_.original_tagname_ = 'quoteUnits'
        elif nodeName_ == 'side':
            side_ = child_.text
            side_ = re_.sub(String_cleanup_pat_, " ", side_).strip()
            side_ = self.gds_validate_string(side_, node, 'side')
            self.side = side_
            # validate type QuotationSideEnum
            self.validate_QuotationSideEnum(self.side)
        elif nodeName_ == 'currency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'currencyType':
            obj_ = ReportingCurrencyType.factory()
            obj_.build(child_)
            self.currencyType = obj_
            obj_.original_tagname_ = 'currencyType'
        elif nodeName_ == 'timing':
            obj_ = QuoteTiming.factory()
            obj_.build(child_)
            self.timing = obj_
            obj_.original_tagname_ = 'timing'
        elif nodeName_ == 'businessCenter':
            obj_ = BusinessCenter.factory()
            obj_.build(child_)
            self.businessCenter = obj_
            obj_.original_tagname_ = 'businessCenter'
        elif nodeName_ == 'exchangeId':
            obj_ = ExchangeId.factory()
            obj_.build(child_)
            self.exchangeId = obj_
            obj_.original_tagname_ = 'exchangeId'
        elif nodeName_ == 'informationSource':
            class_obj_ = self.get_class_obj_(child_, InformationSource)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.informationSource.append(obj_)
            obj_.original_tagname_ = 'informationSource'
        elif nodeName_ == 'pricingModel':
            obj_ = PricingModel.factory()
            obj_.build(child_)
            self.pricingModel = obj_
            obj_.original_tagname_ = 'pricingModel'
        elif nodeName_ == 'time':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.time = dval_
        elif nodeName_ == 'valuationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.valuationDate = dval_
        elif nodeName_ == 'expiryTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.expiryTime = dval_
        elif nodeName_ == 'cashflowType':
            obj_ = CashflowType.factory()
            obj_.build(child_)
            self.cashflowType = obj_
            obj_.original_tagname_ = 'cashflowType'
# end class QuotationCharacteristics


class QuoteTiming(GeneratedsSuper):
    """The type of the time of the quote."""
    member_data_items_ = {
        'quoteTimingScheme': MemberSpec_('quoteTimingScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, quoteTimingScheme='http://www.fpml.org/coding-scheme/quote-timing', valueOf_=None):
        self.original_tagname_ = None
        self.quoteTimingScheme = _cast(None, quoteTimingScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QuoteTiming)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QuoteTiming.subclass:
            return QuoteTiming.subclass(*args_, **kwargs_)
        else:
            return QuoteTiming(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_quoteTimingScheme(self): return self.quoteTimingScheme
    def set_quoteTimingScheme(self, quoteTimingScheme): self.quoteTimingScheme = quoteTimingScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QuoteTiming', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QuoteTiming')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QuoteTiming', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QuoteTiming'):
        if self.quoteTimingScheme != "http://www.fpml.org/coding-scheme/quote-timing" and 'quoteTimingScheme' not in already_processed:
            already_processed.add('quoteTimingScheme')
            outfile.write(' quoteTimingScheme=%s' % (quote_attrib(self.quoteTimingScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QuoteTiming', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('quoteTimingScheme', node)
        if value is not None and 'quoteTimingScheme' not in already_processed:
            already_processed.add('quoteTimingScheme')
            self.quoteTimingScheme = value
            self.validate_NonEmptyURI(self.quoteTimingScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class QuoteTiming


class ReportingCurrencyType(GeneratedsSuper):
    """A scheme identifying the type of currency that was used to report
    the value of an asset. For example, this could contain values
    like SettlementCurrency, QuoteCurrency, UnitCurrency, etc."""
    member_data_items_ = {
        'reportingCurrencyTypeScheme': MemberSpec_('reportingCurrencyTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, reportingCurrencyTypeScheme='http://www.fpml.org/coding-scheme/reporting-currency-type', valueOf_=None):
        self.original_tagname_ = None
        self.reportingCurrencyTypeScheme = _cast(None, reportingCurrencyTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReportingCurrencyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReportingCurrencyType.subclass:
            return ReportingCurrencyType.subclass(*args_, **kwargs_)
        else:
            return ReportingCurrencyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_reportingCurrencyTypeScheme(self): return self.reportingCurrencyTypeScheme
    def set_reportingCurrencyTypeScheme(self, reportingCurrencyTypeScheme): self.reportingCurrencyTypeScheme = reportingCurrencyTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReportingCurrencyType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReportingCurrencyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReportingCurrencyType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReportingCurrencyType'):
        if self.reportingCurrencyTypeScheme != "http://www.fpml.org/coding-scheme/reporting-currency-type" and 'reportingCurrencyTypeScheme' not in already_processed:
            already_processed.add('reportingCurrencyTypeScheme')
            outfile.write(' reportingCurrencyTypeScheme=%s' % (quote_attrib(self.reportingCurrencyTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ReportingCurrencyType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('reportingCurrencyTypeScheme', node)
        if value is not None and 'reportingCurrencyTypeScheme' not in already_processed:
            already_processed.add('reportingCurrencyTypeScheme')
            self.reportingCurrencyTypeScheme = value
            self.validate_NonEmptyURI(self.reportingCurrencyTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReportingCurrencyType


class SingleUnderlyer(GeneratedsSuper):
    """A type describing a single underlyer"""
    member_data_items_ = {
        'underlyingAsset': MemberSpec_('underlyingAsset', 'Asset', 0),
        'openUnits': MemberSpec_('openUnits', 'xsd:decimal', 0),
        'dividendPayout': MemberSpec_('dividendPayout', 'DividendPayout', 0),
        'couponPayment': MemberSpec_('couponPayment', 'PendingPayment', 0),
        'averageDailyTradingVolume': MemberSpec_('averageDailyTradingVolume', 'AverageDailyTradingVolumeLimit', 0),
        'depositoryReceipt': MemberSpec_('depositoryReceipt', 'xsd:boolean', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, underlyingAsset=None, openUnits=None, dividendPayout=None, couponPayment=None, averageDailyTradingVolume=None, depositoryReceipt=None):
        self.original_tagname_ = None
        self.underlyingAsset = underlyingAsset
        self.openUnits = openUnits
        self.dividendPayout = dividendPayout
        self.couponPayment = couponPayment
        self.averageDailyTradingVolume = averageDailyTradingVolume
        self.depositoryReceipt = depositoryReceipt
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SingleUnderlyer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SingleUnderlyer.subclass:
            return SingleUnderlyer.subclass(*args_, **kwargs_)
        else:
            return SingleUnderlyer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_underlyingAsset(self): return self.underlyingAsset
    def set_underlyingAsset(self, underlyingAsset): self.underlyingAsset = underlyingAsset
    def get_openUnits(self): return self.openUnits
    def set_openUnits(self, openUnits): self.openUnits = openUnits
    def get_dividendPayout(self): return self.dividendPayout
    def set_dividendPayout(self, dividendPayout): self.dividendPayout = dividendPayout
    def get_couponPayment(self): return self.couponPayment
    def set_couponPayment(self, couponPayment): self.couponPayment = couponPayment
    def get_averageDailyTradingVolume(self): return self.averageDailyTradingVolume
    def set_averageDailyTradingVolume(self, averageDailyTradingVolume): self.averageDailyTradingVolume = averageDailyTradingVolume
    def get_depositoryReceipt(self): return self.depositoryReceipt
    def set_depositoryReceipt(self, depositoryReceipt): self.depositoryReceipt = depositoryReceipt
    def hasContent_(self):
        if (
            self.underlyingAsset is not None or
            self.openUnits is not None or
            self.dividendPayout is not None or
            self.couponPayment is not None or
            self.averageDailyTradingVolume is not None or
            self.depositoryReceipt is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SingleUnderlyer', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SingleUnderlyer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SingleUnderlyer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SingleUnderlyer'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SingleUnderlyer', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.underlyingAsset is not None:
            self.underlyingAsset.export(outfile, level, namespace_, name_='underlyingAsset', pretty_print=pretty_print)
        if self.openUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sopenUnits>%s</%sopenUnits>%s' % (namespace_, self.gds_format_float(self.openUnits, input_name='openUnits'), namespace_, eol_))
        if self.dividendPayout is not None:
            self.dividendPayout.export(outfile, level, namespace_, name_='dividendPayout', pretty_print=pretty_print)
        if self.couponPayment is not None:
            self.couponPayment.export(outfile, level, namespace_, name_='couponPayment', pretty_print=pretty_print)
        if self.averageDailyTradingVolume is not None:
            self.averageDailyTradingVolume.export(outfile, level, namespace_, name_='averageDailyTradingVolume', pretty_print=pretty_print)
        if self.depositoryReceipt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdepositoryReceipt>%s</%sdepositoryReceipt>%s' % (namespace_, self.gds_format_boolean(self.depositoryReceipt, input_name='depositoryReceipt'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'underlyingAsset':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <underlyingAsset> element')
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'underlyingAsset'
        elif nodeName_ == 'basket':
            obj_ = Basket.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'basket'
        elif nodeName_ == 'bond':
            class_obj_ = self.get_class_obj_(child_, Bond)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'bond'
        elif nodeName_ == 'cash':
            obj_ = Cash.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'cash'
        elif nodeName_ == 'commodity':
            obj_ = Commodity.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'commodity'
        elif nodeName_ == 'convertibleBond':
            obj_ = ConvertibleBond.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'convertibleBond'
        elif nodeName_ == 'equity':
            obj_ = EquityAsset.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'equity'
        elif nodeName_ == 'exchangeTradedFund':
            obj_ = ExchangeTradedFund.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'exchangeTradedFund'
        elif nodeName_ == 'future':
            obj_ = Future.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'future'
        elif nodeName_ == 'index':
            obj_ = Index.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'index'
        elif nodeName_ == 'loan':
            obj_ = Loan.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'loan'
        elif nodeName_ == 'mortgage':
            obj_ = Mortgage.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'mortgage'
        elif nodeName_ == 'mutualFund':
            obj_ = MutualFund.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'mutualFund'
        elif nodeName_ == 'option':
            obj_ = ExchangeTradedOption.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'option'
        elif nodeName_ == 'openUnits':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'openUnits')
            self.openUnits = fval_
        elif nodeName_ == 'dividendPayout':
            obj_ = DividendPayout.factory()
            obj_.build(child_)
            self.dividendPayout = obj_
            obj_.original_tagname_ = 'dividendPayout'
        elif nodeName_ == 'couponPayment':
            obj_ = PendingPayment.factory()
            obj_.build(child_)
            self.couponPayment = obj_
            obj_.original_tagname_ = 'couponPayment'
        elif nodeName_ == 'averageDailyTradingVolume':
            obj_ = AverageDailyTradingVolumeLimit.factory()
            obj_.build(child_)
            self.averageDailyTradingVolume = obj_
            obj_.original_tagname_ = 'averageDailyTradingVolume'
        elif nodeName_ == 'depositoryReceipt':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'depositoryReceipt')
            self.depositoryReceipt = ival_
# end class SingleUnderlyer


class Underlyer(GeneratedsSuper):
    """A type describing the whole set of possible underlyers: single
    underlyers or multiple underlyers, each of these having either
    security or index components."""
    member_data_items_ = {
        'singleUnderlyer': MemberSpec_('singleUnderlyer', 'SingleUnderlyer', 0),
        'basket': MemberSpec_('basket', 'Basket', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, singleUnderlyer=None, basket=None):
        self.original_tagname_ = None
        self.singleUnderlyer = singleUnderlyer
        self.basket = basket
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Underlyer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Underlyer.subclass:
            return Underlyer.subclass(*args_, **kwargs_)
        else:
            return Underlyer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_singleUnderlyer(self): return self.singleUnderlyer
    def set_singleUnderlyer(self, singleUnderlyer): self.singleUnderlyer = singleUnderlyer
    def get_basket(self): return self.basket
    def set_basket(self, basket): self.basket = basket
    def hasContent_(self):
        if (
            self.singleUnderlyer is not None or
            self.basket is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Underlyer', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Underlyer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Underlyer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Underlyer'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Underlyer', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.singleUnderlyer is not None:
            self.singleUnderlyer.export(outfile, level, namespace_, name_='singleUnderlyer', pretty_print=pretty_print)
        if self.basket is not None:
            self.basket.export(outfile, level, namespace_, name_='basket', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'singleUnderlyer':
            obj_ = SingleUnderlyer.factory()
            obj_.build(child_)
            self.singleUnderlyer = obj_
            obj_.original_tagname_ = 'singleUnderlyer'
        elif nodeName_ == 'basket':
            obj_ = Basket.factory()
            obj_.build(child_)
            self.basket = obj_
            obj_.original_tagname_ = 'basket'
# end class Underlyer


class UnderlyingAsset(IdentifiedAsset):
    """Abstract base class for all underlying assets."""
    member_data_items_ = {
        'currency': MemberSpec_('currency', 'IdentifiedCurrency', 0),
        'exchangeId': MemberSpec_('exchangeId', 'ExchangeId', 0),
        'clearanceSystem': MemberSpec_('clearanceSystem', 'ClearanceSystem', 0),
        'definition': MemberSpec_('definition', 'ProductReference', 0),
    }
    subclass = None
    superclass = IdentifiedAsset
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, extensiontype_=None):
        self.original_tagname_ = None
        super(UnderlyingAsset, self).__init__(id, instrumentId, description, extensiontype_, )
        self.currency = currency
        self.exchangeId = exchangeId
        self.clearanceSystem = clearanceSystem
        self.definition = definition
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UnderlyingAsset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UnderlyingAsset.subclass:
            return UnderlyingAsset.subclass(*args_, **kwargs_)
        else:
            return UnderlyingAsset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_exchangeId(self): return self.exchangeId
    def set_exchangeId(self, exchangeId): self.exchangeId = exchangeId
    def get_clearanceSystem(self): return self.clearanceSystem
    def set_clearanceSystem(self, clearanceSystem): self.clearanceSystem = clearanceSystem
    def get_definition(self): return self.definition
    def set_definition(self, definition): self.definition = definition
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.currency is not None or
            self.exchangeId is not None or
            self.clearanceSystem is not None or
            self.definition is not None or
            super(UnderlyingAsset, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='UnderlyingAsset', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UnderlyingAsset')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='UnderlyingAsset', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UnderlyingAsset'):
        super(UnderlyingAsset, self).exportAttributes(outfile, level, already_processed, namespace_, name_='UnderlyingAsset')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='UnderlyingAsset', fromsubclass_=False, pretty_print=True):
        super(UnderlyingAsset, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.currency is not None:
            self.currency.export(outfile, level, namespace_, name_='currency', pretty_print=pretty_print)
        if self.exchangeId is not None:
            self.exchangeId.export(outfile, level, namespace_, name_='exchangeId', pretty_print=pretty_print)
        if self.clearanceSystem is not None:
            self.clearanceSystem.export(outfile, level, namespace_, name_='clearanceSystem', pretty_print=pretty_print)
        if self.definition is not None:
            self.definition.export(outfile, level, namespace_, name_='definition', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(UnderlyingAsset, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'currency':
            obj_ = IdentifiedCurrency.factory()
            obj_.build(child_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'exchangeId':
            obj_ = ExchangeId.factory()
            obj_.build(child_)
            self.exchangeId = obj_
            obj_.original_tagname_ = 'exchangeId'
        elif nodeName_ == 'clearanceSystem':
            obj_ = ClearanceSystem.factory()
            obj_.build(child_)
            self.clearanceSystem = obj_
            obj_.original_tagname_ = 'clearanceSystem'
        elif nodeName_ == 'definition':
            obj_ = ProductReference.factory()
            obj_.build(child_)
            self.definition = obj_
            obj_.original_tagname_ = 'definition'
        super(UnderlyingAsset, self).buildChildren(child_, node, nodeName_, True)
# end class UnderlyingAsset


class UnderlyingAssetTranche(GeneratedsSuper):
    member_data_items_ = {
        'loanTrancheScheme': MemberSpec_('loanTrancheScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, loanTrancheScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.loanTrancheScheme = _cast(None, loanTrancheScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UnderlyingAssetTranche)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UnderlyingAssetTranche.subclass:
            return UnderlyingAssetTranche.subclass(*args_, **kwargs_)
        else:
            return UnderlyingAssetTranche(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_loanTrancheScheme(self): return self.loanTrancheScheme
    def set_loanTrancheScheme(self, loanTrancheScheme): self.loanTrancheScheme = loanTrancheScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='UnderlyingAssetTranche', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UnderlyingAssetTranche')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='UnderlyingAssetTranche', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UnderlyingAssetTranche'):
        if self.loanTrancheScheme is not None and 'loanTrancheScheme' not in already_processed:
            already_processed.add('loanTrancheScheme')
            outfile.write(' loanTrancheScheme=%s' % (quote_attrib(self.loanTrancheScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='UnderlyingAssetTranche', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('loanTrancheScheme', node)
        if value is not None and 'loanTrancheScheme' not in already_processed:
            already_processed.add('loanTrancheScheme')
            self.loanTrancheScheme = value
            self.validate_NonEmptyURI(self.loanTrancheScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class UnderlyingAssetTranche


class UnderlyerLoanRate(GeneratedsSuper):
    """Defines stock loan information where this is required per underlyer.
    You must not duplicate infromation within dividend conditions at
    transaction level"""
    member_data_items_ = {
        'lossOfStockBorrow': MemberSpec_('lossOfStockBorrow', 'xsd:boolean', 0),
        'maximumStockLoanRate': MemberSpec_('maximumStockLoanRate', ['RestrictedPercentage', 'xsd:decimal'], 0),
        'increasedCostOfStockBorrow': MemberSpec_('increasedCostOfStockBorrow', 'xsd:boolean', 0),
        'initialStockLoanRate': MemberSpec_('initialStockLoanRate', ['RestrictedPercentage', 'xsd:decimal'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, lossOfStockBorrow=None, maximumStockLoanRate=None, increasedCostOfStockBorrow=None, initialStockLoanRate=None):
        self.original_tagname_ = None
        self.lossOfStockBorrow = lossOfStockBorrow
        self.maximumStockLoanRate = maximumStockLoanRate
        self.validate_RestrictedPercentage(self.maximumStockLoanRate)
        self.increasedCostOfStockBorrow = increasedCostOfStockBorrow
        self.initialStockLoanRate = initialStockLoanRate
        self.validate_RestrictedPercentage(self.initialStockLoanRate)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UnderlyerLoanRate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UnderlyerLoanRate.subclass:
            return UnderlyerLoanRate.subclass(*args_, **kwargs_)
        else:
            return UnderlyerLoanRate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lossOfStockBorrow(self): return self.lossOfStockBorrow
    def set_lossOfStockBorrow(self, lossOfStockBorrow): self.lossOfStockBorrow = lossOfStockBorrow
    def get_maximumStockLoanRate(self): return self.maximumStockLoanRate
    def set_maximumStockLoanRate(self, maximumStockLoanRate): self.maximumStockLoanRate = maximumStockLoanRate
    def get_increasedCostOfStockBorrow(self): return self.increasedCostOfStockBorrow
    def set_increasedCostOfStockBorrow(self, increasedCostOfStockBorrow): self.increasedCostOfStockBorrow = increasedCostOfStockBorrow
    def get_initialStockLoanRate(self): return self.initialStockLoanRate
    def set_initialStockLoanRate(self, initialStockLoanRate): self.initialStockLoanRate = initialStockLoanRate
    def validate_RestrictedPercentage(self, value):
        # Validate type RestrictedPercentage, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on RestrictedPercentage' % {"value" : value} )
            if value > 1:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on RestrictedPercentage' % {"value" : value} )
    def hasContent_(self):
        if (
            self.lossOfStockBorrow is not None or
            self.maximumStockLoanRate is not None or
            self.increasedCostOfStockBorrow is not None or
            self.initialStockLoanRate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='UnderlyerLoanRate', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UnderlyerLoanRate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='UnderlyerLoanRate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UnderlyerLoanRate'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='UnderlyerLoanRate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.lossOfStockBorrow is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slossOfStockBorrow>%s</%slossOfStockBorrow>%s' % (namespace_, self.gds_format_boolean(self.lossOfStockBorrow, input_name='lossOfStockBorrow'), namespace_, eol_))
        if self.maximumStockLoanRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaximumStockLoanRate>%s</%smaximumStockLoanRate>%s' % (namespace_, self.gds_format_float(self.maximumStockLoanRate, input_name='maximumStockLoanRate'), namespace_, eol_))
        if self.increasedCostOfStockBorrow is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sincreasedCostOfStockBorrow>%s</%sincreasedCostOfStockBorrow>%s' % (namespace_, self.gds_format_boolean(self.increasedCostOfStockBorrow, input_name='increasedCostOfStockBorrow'), namespace_, eol_))
        if self.initialStockLoanRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinitialStockLoanRate>%s</%sinitialStockLoanRate>%s' % (namespace_, self.gds_format_float(self.initialStockLoanRate, input_name='initialStockLoanRate'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'lossOfStockBorrow':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'lossOfStockBorrow')
            self.lossOfStockBorrow = ival_
        elif nodeName_ == 'maximumStockLoanRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'maximumStockLoanRate')
            self.maximumStockLoanRate = fval_
            # validate type RestrictedPercentage
            self.validate_RestrictedPercentage(self.maximumStockLoanRate)
        elif nodeName_ == 'increasedCostOfStockBorrow':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'increasedCostOfStockBorrow')
            self.increasedCostOfStockBorrow = ival_
        elif nodeName_ == 'initialStockLoanRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'initialStockLoanRate')
            self.initialStockLoanRate = fval_
            # validate type RestrictedPercentage
            self.validate_RestrictedPercentage(self.initialStockLoanRate)
# end class UnderlyerLoanRate


class Account(GeneratedsSuper):
    """A generic account that represents any party's account at another
    party. Parties may be identified by the account at another
    party.The unique identifier for the account within the document."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'accountId': MemberSpec_('accountId', 'AccountId', 1),
        'accountName': MemberSpec_('accountName', 'AccountName', 0),
        'accountType': MemberSpec_('accountType', 'AccountType', 0),
        'accountBeneficiary': MemberSpec_('accountBeneficiary', 'PartyReference', 0),
        'servicingParty': MemberSpec_('servicingParty', 'PartyReference', 0),
        'servicingParty': MemberSpec_('servicingParty', 'PartyReference', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, accountId=None, accountName=None, accountType=None, accountBeneficiary=None, servicingParty=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if accountId is None:
            self.accountId = []
        else:
            self.accountId = accountId
        self.accountName = accountName
        self.accountType = accountType
        self.accountBeneficiary = accountBeneficiary
        self.servicingParty = servicingParty
        self.servicingParty = servicingParty
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Account)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Account.subclass:
            return Account.subclass(*args_, **kwargs_)
        else:
            return Account(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_accountId(self): return self.accountId
    def set_accountId(self, accountId): self.accountId = accountId
    def add_accountId(self, value): self.accountId.append(value)
    def insert_accountId_at(self, index, value): self.accountId.insert(index, value)
    def replace_accountId_at(self, index, value): self.accountId[index] = value
    def get_accountName(self): return self.accountName
    def set_accountName(self, accountName): self.accountName = accountName
    def get_accountType(self): return self.accountType
    def set_accountType(self, accountType): self.accountType = accountType
    def get_accountBeneficiary(self): return self.accountBeneficiary
    def set_accountBeneficiary(self, accountBeneficiary): self.accountBeneficiary = accountBeneficiary
    def get_servicingParty(self): return self.servicingParty
    def set_servicingParty(self, servicingParty): self.servicingParty = servicingParty
    def get_servicingParty(self): return self.servicingParty
    def set_servicingParty(self, servicingParty): self.servicingParty = servicingParty
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.accountId or
            self.accountName is not None or
            self.accountType is not None or
            self.accountBeneficiary is not None or
            self.servicingParty is not None or
            self.servicingParty is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Account', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Account')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Account', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Account'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Account', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for accountId_ in self.accountId:
            accountId_.export(outfile, level, namespace_, name_='accountId', pretty_print=pretty_print)
        if self.accountName is not None:
            self.accountName.export(outfile, level, namespace_, name_='accountName', pretty_print=pretty_print)
        if self.accountType is not None:
            self.accountType.export(outfile, level, namespace_, name_='accountType', pretty_print=pretty_print)
        if self.accountBeneficiary is not None:
            self.accountBeneficiary.export(outfile, level, namespace_, name_='accountBeneficiary', pretty_print=pretty_print)
        if self.servicingParty is not None:
            self.servicingParty.export(outfile, level, namespace_, name_='servicingParty', pretty_print=pretty_print)
        if self.servicingParty is not None:
            self.servicingParty.export(outfile, level, namespace_, name_='servicingParty', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'accountId':
            obj_ = AccountId.factory()
            obj_.build(child_)
            self.accountId.append(obj_)
            obj_.original_tagname_ = 'accountId'
        elif nodeName_ == 'accountName':
            obj_ = AccountName.factory()
            obj_.build(child_)
            self.accountName = obj_
            obj_.original_tagname_ = 'accountName'
        elif nodeName_ == 'accountType':
            obj_ = AccountType.factory()
            obj_.build(child_)
            self.accountType = obj_
            obj_.original_tagname_ = 'accountType'
        elif nodeName_ == 'accountBeneficiary':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.accountBeneficiary = obj_
            obj_.original_tagname_ = 'accountBeneficiary'
        elif nodeName_ == 'servicingParty':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.servicingParty = obj_
            obj_.original_tagname_ = 'servicingParty'
        elif nodeName_ == 'servicingParty':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.servicingParty = obj_
            obj_.original_tagname_ = 'servicingParty'
# end class Account


class AccountId(GeneratedsSuper):
    """The data type used for account identifiers.The identifier scheme
    used with this accountId. A unique URI to determine the
    authoritative issuer of these identifiers."""
    member_data_items_ = {
        'accountIdScheme': MemberSpec_('accountIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, accountIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.accountIdScheme = _cast(None, accountIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AccountId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AccountId.subclass:
            return AccountId.subclass(*args_, **kwargs_)
        else:
            return AccountId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_accountIdScheme(self): return self.accountIdScheme
    def set_accountIdScheme(self, accountIdScheme): self.accountIdScheme = accountIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AccountId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AccountId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AccountId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AccountId'):
        if self.accountIdScheme is not None and 'accountIdScheme' not in already_processed:
            already_processed.add('accountIdScheme')
            outfile.write(' accountIdScheme=%s' % (quote_attrib(self.accountIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AccountId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('accountIdScheme', node)
        if value is not None and 'accountIdScheme' not in already_processed:
            already_processed.add('accountIdScheme')
            self.accountIdScheme = value
            self.validate_NonEmptyURI(self.accountIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AccountId


class AccountName(GeneratedsSuper):
    """The data type used for the name of the account.The identifier scheme
    used with this accountName. A unique URI to determine the source
    of the account name."""
    member_data_items_ = {
        'accountNameScheme': MemberSpec_('accountNameScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, accountNameScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.accountNameScheme = _cast(None, accountNameScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AccountName)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AccountName.subclass:
            return AccountName.subclass(*args_, **kwargs_)
        else:
            return AccountName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_accountNameScheme(self): return self.accountNameScheme
    def set_accountNameScheme(self, accountNameScheme): self.accountNameScheme = accountNameScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AccountName', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AccountName')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AccountName', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AccountName'):
        if self.accountNameScheme is not None and 'accountNameScheme' not in already_processed:
            already_processed.add('accountNameScheme')
            outfile.write(' accountNameScheme=%s' % (quote_attrib(self.accountNameScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AccountName', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('accountNameScheme', node)
        if value is not None and 'accountNameScheme' not in already_processed:
            already_processed.add('accountNameScheme')
            self.accountNameScheme = value
            self.validate_NonEmptyURI(self.accountNameScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AccountName


class AccountType(GeneratedsSuper):
    """The data type used for account type.The identifier scheme used with
    this accountType. A unique URI to determine the the type of
    account."""
    member_data_items_ = {
        'accountTypeScheme': MemberSpec_('accountTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, accountTypeScheme='http://www.fpml.org/coding-scheme/account-type', valueOf_=None):
        self.original_tagname_ = None
        self.accountTypeScheme = _cast(None, accountTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AccountType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AccountType.subclass:
            return AccountType.subclass(*args_, **kwargs_)
        else:
            return AccountType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_accountTypeScheme(self): return self.accountTypeScheme
    def set_accountTypeScheme(self, accountTypeScheme): self.accountTypeScheme = accountTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AccountType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AccountType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AccountType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AccountType'):
        if self.accountTypeScheme != "http://www.fpml.org/coding-scheme/account-type" and 'accountTypeScheme' not in already_processed:
            already_processed.add('accountTypeScheme')
            outfile.write(' accountTypeScheme=%s' % (quote_attrib(self.accountTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AccountType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('accountTypeScheme', node)
        if value is not None and 'accountTypeScheme' not in already_processed:
            already_processed.add('accountTypeScheme')
            self.accountTypeScheme = value
            self.validate_NonEmptyURI(self.accountTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AccountType


class ActionType(GeneratedsSuper):
    """The data type used for ESMA action type.The identifier scheme used
    with this actionType. A unique URI to determine the the type of
    action."""
    member_data_items_ = {
        'actionTypeScheme': MemberSpec_('actionTypeScheme', 'xsd:anyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, actionTypeScheme='http://www.fpml.org/coding-scheme/action-type', valueOf_=None):
        self.original_tagname_ = None
        self.actionTypeScheme = _cast(None, actionTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ActionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ActionType.subclass:
            return ActionType.subclass(*args_, **kwargs_)
        else:
            return ActionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_actionTypeScheme(self): return self.actionTypeScheme
    def set_actionTypeScheme(self, actionTypeScheme): self.actionTypeScheme = actionTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ActionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ActionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ActionType'):
        if self.actionTypeScheme != "http://www.fpml.org/coding-scheme/action-type" and 'actionTypeScheme' not in already_processed:
            already_processed.add('actionTypeScheme')
            outfile.write(' actionTypeScheme=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actionTypeScheme), input_name='actionTypeScheme')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ActionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('actionTypeScheme', node)
        if value is not None and 'actionTypeScheme' not in already_processed:
            already_processed.add('actionTypeScheme')
            self.actionTypeScheme = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ActionType


class Address(GeneratedsSuper):
    """A type that represents a physical postal address."""
    member_data_items_ = {
        'streetAddress': MemberSpec_('streetAddress', 'StreetAddress', 0),
        'city': MemberSpec_('city', ['String', 'xsd:string'], 0),
        'state': MemberSpec_('state', ['String', 'xsd:string'], 0),
        'country': MemberSpec_('country', 'CountryCode', 0),
        'postalCode': MemberSpec_('postalCode', ['String', 'xsd:string'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, streetAddress=None, city=None, state=None, country=None, postalCode=None):
        self.original_tagname_ = None
        self.streetAddress = streetAddress
        self.city = city
        self.validate_String(self.city)
        self.state = state
        self.validate_String(self.state)
        self.country = country
        self.postalCode = postalCode
        self.validate_String(self.postalCode)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Address)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Address.subclass:
            return Address.subclass(*args_, **kwargs_)
        else:
            return Address(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_streetAddress(self): return self.streetAddress
    def set_streetAddress(self, streetAddress): self.streetAddress = streetAddress
    def get_city(self): return self.city
    def set_city(self, city): self.city = city
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def get_country(self): return self.country
    def set_country(self, country): self.country = country
    def get_postalCode(self): return self.postalCode
    def set_postalCode(self, postalCode): self.postalCode = postalCode
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.streetAddress is not None or
            self.city is not None or
            self.state is not None or
            self.country is not None or
            self.postalCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Address', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Address')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Address', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Address'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Address', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.streetAddress is not None:
            self.streetAddress.export(outfile, level, namespace_, name_='streetAddress', pretty_print=pretty_print)
        if self.city is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scity>%s</%scity>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.city), input_name='city')), namespace_, eol_))
        if self.state is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstate>%s</%sstate>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.state), input_name='state')), namespace_, eol_))
        if self.country is not None:
            self.country.export(outfile, level, namespace_, name_='country', pretty_print=pretty_print)
        if self.postalCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spostalCode>%s</%spostalCode>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.postalCode), input_name='postalCode')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'streetAddress':
            obj_ = StreetAddress.factory()
            obj_.build(child_)
            self.streetAddress = obj_
            obj_.original_tagname_ = 'streetAddress'
        elif nodeName_ == 'city':
            city_ = child_.text
            city_ = self.gds_validate_string(city_, node, 'city')
            self.city = city_
            # validate type String
            self.validate_String(self.city)
        elif nodeName_ == 'state':
            state_ = child_.text
            state_ = self.gds_validate_string(state_, node, 'state')
            self.state = state_
            # validate type String
            self.validate_String(self.state)
        elif nodeName_ == 'country':
            obj_ = CountryCode.factory()
            obj_.build(child_)
            self.country = obj_
            obj_.original_tagname_ = 'country'
        elif nodeName_ == 'postalCode':
            postalCode_ = child_.text
            postalCode_ = self.gds_validate_string(postalCode_, node, 'postalCode')
            self.postalCode = postalCode_
            # validate type String
            self.validate_String(self.postalCode)
# end class Address


class AdjustableDate(GeneratedsSuper):
    """A type for defining a date that shall be subject to adjustment if it
    would otherwise fall on a day that is not a business day in the
    specified business centers, together with the convention for
    adjusting the date."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'unadjustedDate': MemberSpec_('unadjustedDate', 'IdentifiedDate', 0),
        'dateAdjustments': MemberSpec_('dateAdjustments', 'BusinessDayAdjustments', 0),
        'adjustedDate': MemberSpec_('adjustedDate', 'IdentifiedDate', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, unadjustedDate=None, dateAdjustments=None, adjustedDate=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.unadjustedDate = unadjustedDate
        self.dateAdjustments = dateAdjustments
        self.adjustedDate = adjustedDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdjustableDate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdjustableDate.subclass:
            return AdjustableDate.subclass(*args_, **kwargs_)
        else:
            return AdjustableDate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unadjustedDate(self): return self.unadjustedDate
    def set_unadjustedDate(self, unadjustedDate): self.unadjustedDate = unadjustedDate
    def get_dateAdjustments(self): return self.dateAdjustments
    def set_dateAdjustments(self, dateAdjustments): self.dateAdjustments = dateAdjustments
    def get_adjustedDate(self): return self.adjustedDate
    def set_adjustedDate(self, adjustedDate): self.adjustedDate = adjustedDate
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.unadjustedDate is not None or
            self.dateAdjustments is not None or
            self.adjustedDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AdjustableDate', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdjustableDate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AdjustableDate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AdjustableDate'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AdjustableDate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.unadjustedDate is not None:
            self.unadjustedDate.export(outfile, level, namespace_, name_='unadjustedDate', pretty_print=pretty_print)
        if self.dateAdjustments is not None:
            self.dateAdjustments.export(outfile, level, namespace_, name_='dateAdjustments', pretty_print=pretty_print)
        if self.adjustedDate is not None:
            self.adjustedDate.export(outfile, level, namespace_, name_='adjustedDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'unadjustedDate':
            obj_ = IdentifiedDate.factory()
            obj_.build(child_)
            self.unadjustedDate = obj_
            obj_.original_tagname_ = 'unadjustedDate'
        elif nodeName_ == 'dateAdjustments':
            obj_ = BusinessDayAdjustments.factory()
            obj_.build(child_)
            self.dateAdjustments = obj_
            obj_.original_tagname_ = 'dateAdjustments'
        elif nodeName_ == 'adjustedDate':
            obj_ = IdentifiedDate.factory()
            obj_.build(child_)
            self.adjustedDate = obj_
            obj_.original_tagname_ = 'adjustedDate'
# end class AdjustableDate


class AdjustableDate2(GeneratedsSuper):
    """A type that is different from AdjustableDate in two regards. First,
    date adjustments can be specified with either a dateAdjustments
    element or a reference to an existing dateAdjustments element.
    Second, it does not require the specification of date
    adjustments."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'unadjustedDate': MemberSpec_('unadjustedDate', 'IdentifiedDate', 0),
        'dateAdjustments': MemberSpec_('dateAdjustments', 'BusinessDayAdjustments', 0),
        'dateAdjustmentsReference': MemberSpec_('dateAdjustmentsReference', 'BusinessDayAdjustmentsReference', 0),
        'adjustedDate': MemberSpec_('adjustedDate', 'IdentifiedDate', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, unadjustedDate=None, dateAdjustments=None, dateAdjustmentsReference=None, adjustedDate=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.unadjustedDate = unadjustedDate
        self.dateAdjustments = dateAdjustments
        self.dateAdjustmentsReference = dateAdjustmentsReference
        self.adjustedDate = adjustedDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdjustableDate2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdjustableDate2.subclass:
            return AdjustableDate2.subclass(*args_, **kwargs_)
        else:
            return AdjustableDate2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unadjustedDate(self): return self.unadjustedDate
    def set_unadjustedDate(self, unadjustedDate): self.unadjustedDate = unadjustedDate
    def get_dateAdjustments(self): return self.dateAdjustments
    def set_dateAdjustments(self, dateAdjustments): self.dateAdjustments = dateAdjustments
    def get_dateAdjustmentsReference(self): return self.dateAdjustmentsReference
    def set_dateAdjustmentsReference(self, dateAdjustmentsReference): self.dateAdjustmentsReference = dateAdjustmentsReference
    def get_adjustedDate(self): return self.adjustedDate
    def set_adjustedDate(self, adjustedDate): self.adjustedDate = adjustedDate
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.unadjustedDate is not None or
            self.dateAdjustments is not None or
            self.dateAdjustmentsReference is not None or
            self.adjustedDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AdjustableDate2', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdjustableDate2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AdjustableDate2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AdjustableDate2'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AdjustableDate2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.unadjustedDate is not None:
            self.unadjustedDate.export(outfile, level, namespace_, name_='unadjustedDate', pretty_print=pretty_print)
        if self.dateAdjustments is not None:
            self.dateAdjustments.export(outfile, level, namespace_, name_='dateAdjustments', pretty_print=pretty_print)
        if self.dateAdjustmentsReference is not None:
            self.dateAdjustmentsReference.export(outfile, level, namespace_, name_='dateAdjustmentsReference', pretty_print=pretty_print)
        if self.adjustedDate is not None:
            self.adjustedDate.export(outfile, level, namespace_, name_='adjustedDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'unadjustedDate':
            obj_ = IdentifiedDate.factory()
            obj_.build(child_)
            self.unadjustedDate = obj_
            obj_.original_tagname_ = 'unadjustedDate'
        elif nodeName_ == 'dateAdjustments':
            obj_ = BusinessDayAdjustments.factory()
            obj_.build(child_)
            self.dateAdjustments = obj_
            obj_.original_tagname_ = 'dateAdjustments'
        elif nodeName_ == 'dateAdjustmentsReference':
            obj_ = BusinessDayAdjustmentsReference.factory()
            obj_.build(child_)
            self.dateAdjustmentsReference = obj_
            obj_.original_tagname_ = 'dateAdjustmentsReference'
        elif nodeName_ == 'adjustedDate':
            obj_ = IdentifiedDate.factory()
            obj_.build(child_)
            self.adjustedDate = obj_
            obj_.original_tagname_ = 'adjustedDate'
# end class AdjustableDate2


class AdjustableDates(GeneratedsSuper):
    """A type for defining a series of dates that shall be subject to
    adjustment if they would otherwise fall on a day that is not a
    business day in the specified business centers, together with
    the convention for adjusting the dates."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'unadjustedDate': MemberSpec_('unadjustedDate', 'IdentifiedDate', 1),
        'dateAdjustments': MemberSpec_('dateAdjustments', 'BusinessDayAdjustments', 0),
        'adjustedDate': MemberSpec_('adjustedDate', 'IdentifiedDate', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, unadjustedDate=None, dateAdjustments=None, adjustedDate=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if unadjustedDate is None:
            self.unadjustedDate = []
        else:
            self.unadjustedDate = unadjustedDate
        self.dateAdjustments = dateAdjustments
        if adjustedDate is None:
            self.adjustedDate = []
        else:
            self.adjustedDate = adjustedDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdjustableDates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdjustableDates.subclass:
            return AdjustableDates.subclass(*args_, **kwargs_)
        else:
            return AdjustableDates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unadjustedDate(self): return self.unadjustedDate
    def set_unadjustedDate(self, unadjustedDate): self.unadjustedDate = unadjustedDate
    def add_unadjustedDate(self, value): self.unadjustedDate.append(value)
    def insert_unadjustedDate_at(self, index, value): self.unadjustedDate.insert(index, value)
    def replace_unadjustedDate_at(self, index, value): self.unadjustedDate[index] = value
    def get_dateAdjustments(self): return self.dateAdjustments
    def set_dateAdjustments(self, dateAdjustments): self.dateAdjustments = dateAdjustments
    def get_adjustedDate(self): return self.adjustedDate
    def set_adjustedDate(self, adjustedDate): self.adjustedDate = adjustedDate
    def add_adjustedDate(self, value): self.adjustedDate.append(value)
    def insert_adjustedDate_at(self, index, value): self.adjustedDate.insert(index, value)
    def replace_adjustedDate_at(self, index, value): self.adjustedDate[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.unadjustedDate or
            self.dateAdjustments is not None or
            self.adjustedDate
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AdjustableDates', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdjustableDates')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AdjustableDates', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AdjustableDates'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AdjustableDates', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for unadjustedDate_ in self.unadjustedDate:
            unadjustedDate_.export(outfile, level, namespace_, name_='unadjustedDate', pretty_print=pretty_print)
        if self.dateAdjustments is not None:
            self.dateAdjustments.export(outfile, level, namespace_, name_='dateAdjustments', pretty_print=pretty_print)
        for adjustedDate_ in self.adjustedDate:
            adjustedDate_.export(outfile, level, namespace_, name_='adjustedDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'unadjustedDate':
            obj_ = IdentifiedDate.factory()
            obj_.build(child_)
            self.unadjustedDate.append(obj_)
            obj_.original_tagname_ = 'unadjustedDate'
        elif nodeName_ == 'dateAdjustments':
            obj_ = BusinessDayAdjustments.factory()
            obj_.build(child_)
            self.dateAdjustments = obj_
            obj_.original_tagname_ = 'dateAdjustments'
        elif nodeName_ == 'adjustedDate':
            obj_ = IdentifiedDate.factory()
            obj_.build(child_)
            self.adjustedDate.append(obj_)
            obj_.original_tagname_ = 'adjustedDate'
# end class AdjustableDates


class AdjustableDatesOrRelativeDateOffset(GeneratedsSuper):
    """A type for defining a series of dates, either as a list of
    adjustable dates, or a as a repeating sequence from a base date"""
    member_data_items_ = {
        'adjustableDates': MemberSpec_('adjustableDates', 'AdjustableDates', 0),
        'relativeDate': MemberSpec_('relativeDate', 'RelativeDateOffset', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, adjustableDates=None, relativeDate=None):
        self.original_tagname_ = None
        self.adjustableDates = adjustableDates
        self.relativeDate = relativeDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdjustableDatesOrRelativeDateOffset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdjustableDatesOrRelativeDateOffset.subclass:
            return AdjustableDatesOrRelativeDateOffset.subclass(*args_, **kwargs_)
        else:
            return AdjustableDatesOrRelativeDateOffset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_adjustableDates(self): return self.adjustableDates
    def set_adjustableDates(self, adjustableDates): self.adjustableDates = adjustableDates
    def get_relativeDate(self): return self.relativeDate
    def set_relativeDate(self, relativeDate): self.relativeDate = relativeDate
    def hasContent_(self):
        if (
            self.adjustableDates is not None or
            self.relativeDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AdjustableDatesOrRelativeDateOffset', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdjustableDatesOrRelativeDateOffset')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AdjustableDatesOrRelativeDateOffset', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AdjustableDatesOrRelativeDateOffset'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AdjustableDatesOrRelativeDateOffset', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.adjustableDates is not None:
            self.adjustableDates.export(outfile, level, namespace_, name_='adjustableDates', pretty_print=pretty_print)
        if self.relativeDate is not None:
            self.relativeDate.export(outfile, level, namespace_, name_='relativeDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'adjustableDates':
            obj_ = AdjustableDates.factory()
            obj_.build(child_)
            self.adjustableDates = obj_
            obj_.original_tagname_ = 'adjustableDates'
        elif nodeName_ == 'relativeDate':
            class_obj_ = self.get_class_obj_(child_, RelativeDateOffset)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.relativeDate = obj_
            obj_.original_tagname_ = 'relativeDate'
# end class AdjustableDatesOrRelativeDateOffset


class AdjustableOrAdjustedDate(GeneratedsSuper):
    """A type for defining a date that shall be subject to adjustment if it
    would otherwise fall on a day that is not a business day in the
    specified business centers, together with the convention for
    adjusting the date."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'unadjustedDate': MemberSpec_('unadjustedDate', 'IdentifiedDate', 0),
        'dateAdjustments': MemberSpec_('dateAdjustments', 'BusinessDayAdjustments', 0),
        'adjustedDate': MemberSpec_('adjustedDate', 'IdentifiedDate', 0),
        'adjustedDate': MemberSpec_('adjustedDate', 'IdentifiedDate', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, unadjustedDate=None, dateAdjustments=None, adjustedDate=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.unadjustedDate = unadjustedDate
        self.dateAdjustments = dateAdjustments
        self.adjustedDate = adjustedDate
        self.adjustedDate = adjustedDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdjustableOrAdjustedDate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdjustableOrAdjustedDate.subclass:
            return AdjustableOrAdjustedDate.subclass(*args_, **kwargs_)
        else:
            return AdjustableOrAdjustedDate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unadjustedDate(self): return self.unadjustedDate
    def set_unadjustedDate(self, unadjustedDate): self.unadjustedDate = unadjustedDate
    def get_dateAdjustments(self): return self.dateAdjustments
    def set_dateAdjustments(self, dateAdjustments): self.dateAdjustments = dateAdjustments
    def get_adjustedDate(self): return self.adjustedDate
    def set_adjustedDate(self, adjustedDate): self.adjustedDate = adjustedDate
    def get_adjustedDate(self): return self.adjustedDate
    def set_adjustedDate(self, adjustedDate): self.adjustedDate = adjustedDate
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.unadjustedDate is not None or
            self.dateAdjustments is not None or
            self.adjustedDate is not None or
            self.adjustedDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AdjustableOrAdjustedDate', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdjustableOrAdjustedDate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AdjustableOrAdjustedDate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AdjustableOrAdjustedDate'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AdjustableOrAdjustedDate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.unadjustedDate is not None:
            self.unadjustedDate.export(outfile, level, namespace_, name_='unadjustedDate', pretty_print=pretty_print)
        if self.dateAdjustments is not None:
            self.dateAdjustments.export(outfile, level, namespace_, name_='dateAdjustments', pretty_print=pretty_print)
        if self.adjustedDate is not None:
            self.adjustedDate.export(outfile, level, namespace_, name_='adjustedDate', pretty_print=pretty_print)
        if self.adjustedDate is not None:
            self.adjustedDate.export(outfile, level, namespace_, name_='adjustedDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'unadjustedDate':
            obj_ = IdentifiedDate.factory()
            obj_.build(child_)
            self.unadjustedDate = obj_
            obj_.original_tagname_ = 'unadjustedDate'
        elif nodeName_ == 'dateAdjustments':
            obj_ = BusinessDayAdjustments.factory()
            obj_.build(child_)
            self.dateAdjustments = obj_
            obj_.original_tagname_ = 'dateAdjustments'
        elif nodeName_ == 'adjustedDate':
            obj_ = IdentifiedDate.factory()
            obj_.build(child_)
            self.adjustedDate = obj_
            obj_.original_tagname_ = 'adjustedDate'
        elif nodeName_ == 'adjustedDate':
            obj_ = IdentifiedDate.factory()
            obj_.build(child_)
            self.adjustedDate = obj_
            obj_.original_tagname_ = 'adjustedDate'
# end class AdjustableOrAdjustedDate


class AdjustableOrRelativeDate(GeneratedsSuper):
    """A type giving the choice between defining a date as an explicit date
    together with applicable adjustments or as relative to some
    other (anchor) date."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'adjustableDate': MemberSpec_('adjustableDate', 'AdjustableDate', 0),
        'relativeDate': MemberSpec_('relativeDate', 'RelativeDateOffset', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, adjustableDate=None, relativeDate=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.adjustableDate = adjustableDate
        self.relativeDate = relativeDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdjustableOrRelativeDate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdjustableOrRelativeDate.subclass:
            return AdjustableOrRelativeDate.subclass(*args_, **kwargs_)
        else:
            return AdjustableOrRelativeDate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_adjustableDate(self): return self.adjustableDate
    def set_adjustableDate(self, adjustableDate): self.adjustableDate = adjustableDate
    def get_relativeDate(self): return self.relativeDate
    def set_relativeDate(self, relativeDate): self.relativeDate = relativeDate
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.adjustableDate is not None or
            self.relativeDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AdjustableOrRelativeDate', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdjustableOrRelativeDate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AdjustableOrRelativeDate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AdjustableOrRelativeDate'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AdjustableOrRelativeDate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.adjustableDate is not None:
            self.adjustableDate.export(outfile, level, namespace_, name_='adjustableDate', pretty_print=pretty_print)
        if self.relativeDate is not None:
            self.relativeDate.export(outfile, level, namespace_, name_='relativeDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'adjustableDate':
            obj_ = AdjustableDate.factory()
            obj_.build(child_)
            self.adjustableDate = obj_
            obj_.original_tagname_ = 'adjustableDate'
        elif nodeName_ == 'relativeDate':
            class_obj_ = self.get_class_obj_(child_, RelativeDateOffset)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.relativeDate = obj_
            obj_.original_tagname_ = 'relativeDate'
# end class AdjustableOrRelativeDate


class AdjustableOrRelativeDates(GeneratedsSuper):
    """A type giving the choice between defining a series of dates as an
    explicit list of dates together with applicable adjustments or
    as relative to some other series of (anchor) dates."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'adjustableDates': MemberSpec_('adjustableDates', 'AdjustableDates', 0),
        'relativeDates': MemberSpec_('relativeDates', 'RelativeDates', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, adjustableDates=None, relativeDates=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.adjustableDates = adjustableDates
        self.relativeDates = relativeDates
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdjustableOrRelativeDates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdjustableOrRelativeDates.subclass:
            return AdjustableOrRelativeDates.subclass(*args_, **kwargs_)
        else:
            return AdjustableOrRelativeDates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_adjustableDates(self): return self.adjustableDates
    def set_adjustableDates(self, adjustableDates): self.adjustableDates = adjustableDates
    def get_relativeDates(self): return self.relativeDates
    def set_relativeDates(self, relativeDates): self.relativeDates = relativeDates
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.adjustableDates is not None or
            self.relativeDates is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AdjustableOrRelativeDates', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdjustableOrRelativeDates')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AdjustableOrRelativeDates', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AdjustableOrRelativeDates'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AdjustableOrRelativeDates', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.adjustableDates is not None:
            self.adjustableDates.export(outfile, level, namespace_, name_='adjustableDates', pretty_print=pretty_print)
        if self.relativeDates is not None:
            self.relativeDates.export(outfile, level, namespace_, name_='relativeDates', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'adjustableDates':
            obj_ = AdjustableDates.factory()
            obj_.build(child_)
            self.adjustableDates = obj_
            obj_.original_tagname_ = 'adjustableDates'
        elif nodeName_ == 'relativeDates':
            obj_ = RelativeDates.factory()
            obj_.build(child_)
            self.relativeDates = obj_
            obj_.original_tagname_ = 'relativeDates'
# end class AdjustableOrRelativeDates


class AdjustableRelativeOrPeriodicDates(GeneratedsSuper):
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'adjustableDates': MemberSpec_('adjustableDates', 'AdjustableDates', 0),
        'relativeDates': MemberSpec_('relativeDates', 'RelativeDates', 0),
        'relativeDateSequence': MemberSpec_('relativeDateSequence', 'RelativeDateSequence', 0),
        'periodicDates': MemberSpec_('periodicDates', 'PeriodicDates', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, adjustableDates=None, relativeDates=None, relativeDateSequence=None, periodicDates=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.adjustableDates = adjustableDates
        self.relativeDates = relativeDates
        self.relativeDateSequence = relativeDateSequence
        self.periodicDates = periodicDates
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdjustableRelativeOrPeriodicDates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdjustableRelativeOrPeriodicDates.subclass:
            return AdjustableRelativeOrPeriodicDates.subclass(*args_, **kwargs_)
        else:
            return AdjustableRelativeOrPeriodicDates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_adjustableDates(self): return self.adjustableDates
    def set_adjustableDates(self, adjustableDates): self.adjustableDates = adjustableDates
    def get_relativeDates(self): return self.relativeDates
    def set_relativeDates(self, relativeDates): self.relativeDates = relativeDates
    def get_relativeDateSequence(self): return self.relativeDateSequence
    def set_relativeDateSequence(self, relativeDateSequence): self.relativeDateSequence = relativeDateSequence
    def get_periodicDates(self): return self.periodicDates
    def set_periodicDates(self, periodicDates): self.periodicDates = periodicDates
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.adjustableDates is not None or
            self.relativeDates is not None or
            self.relativeDateSequence is not None or
            self.periodicDates is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AdjustableRelativeOrPeriodicDates', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdjustableRelativeOrPeriodicDates')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AdjustableRelativeOrPeriodicDates', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AdjustableRelativeOrPeriodicDates'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AdjustableRelativeOrPeriodicDates', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.adjustableDates is not None:
            self.adjustableDates.export(outfile, level, namespace_, name_='adjustableDates', pretty_print=pretty_print)
        if self.relativeDates is not None:
            self.relativeDates.export(outfile, level, namespace_, name_='relativeDates', pretty_print=pretty_print)
        if self.relativeDateSequence is not None:
            self.relativeDateSequence.export(outfile, level, namespace_, name_='relativeDateSequence', pretty_print=pretty_print)
        if self.periodicDates is not None:
            self.periodicDates.export(outfile, level, namespace_, name_='periodicDates', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'adjustableDates':
            obj_ = AdjustableDates.factory()
            obj_.build(child_)
            self.adjustableDates = obj_
            obj_.original_tagname_ = 'adjustableDates'
        elif nodeName_ == 'relativeDates':
            obj_ = RelativeDates.factory()
            obj_.build(child_)
            self.relativeDates = obj_
            obj_.original_tagname_ = 'relativeDates'
        elif nodeName_ == 'relativeDateSequence':
            obj_ = RelativeDateSequence.factory()
            obj_.build(child_)
            self.relativeDateSequence = obj_
            obj_.original_tagname_ = 'relativeDateSequence'
        elif nodeName_ == 'periodicDates':
            obj_ = PeriodicDates.factory()
            obj_.build(child_)
            self.periodicDates = obj_
            obj_.original_tagname_ = 'periodicDates'
# end class AdjustableRelativeOrPeriodicDates


class AdjustableRelativeOrPeriodicDates2(GeneratedsSuper):
    """A type giving the choice between defining a series of dates as an
    explicit list of dates together with applicable adjustments, or
    as relative to some other series of (anchor) dates, or as a set
    of factors to specify periodic occurences."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'adjustableDates': MemberSpec_('adjustableDates', 'AdjustableDates', 0),
        'relativeDates': MemberSpec_('relativeDates', 'RelativeDates', 0),
        'periodicDates': MemberSpec_('periodicDates', 'PeriodicDates', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, adjustableDates=None, relativeDates=None, periodicDates=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.adjustableDates = adjustableDates
        self.relativeDates = relativeDates
        self.periodicDates = periodicDates
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdjustableRelativeOrPeriodicDates2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdjustableRelativeOrPeriodicDates2.subclass:
            return AdjustableRelativeOrPeriodicDates2.subclass(*args_, **kwargs_)
        else:
            return AdjustableRelativeOrPeriodicDates2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_adjustableDates(self): return self.adjustableDates
    def set_adjustableDates(self, adjustableDates): self.adjustableDates = adjustableDates
    def get_relativeDates(self): return self.relativeDates
    def set_relativeDates(self, relativeDates): self.relativeDates = relativeDates
    def get_periodicDates(self): return self.periodicDates
    def set_periodicDates(self, periodicDates): self.periodicDates = periodicDates
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.adjustableDates is not None or
            self.relativeDates is not None or
            self.periodicDates is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AdjustableRelativeOrPeriodicDates2', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdjustableRelativeOrPeriodicDates2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AdjustableRelativeOrPeriodicDates2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AdjustableRelativeOrPeriodicDates2'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AdjustableRelativeOrPeriodicDates2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.adjustableDates is not None:
            self.adjustableDates.export(outfile, level, namespace_, name_='adjustableDates', pretty_print=pretty_print)
        if self.relativeDates is not None:
            self.relativeDates.export(outfile, level, namespace_, name_='relativeDates', pretty_print=pretty_print)
        if self.periodicDates is not None:
            self.periodicDates.export(outfile, level, namespace_, name_='periodicDates', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'adjustableDates':
            obj_ = AdjustableDates.factory()
            obj_.build(child_)
            self.adjustableDates = obj_
            obj_.original_tagname_ = 'adjustableDates'
        elif nodeName_ == 'relativeDates':
            obj_ = RelativeDates.factory()
            obj_.build(child_)
            self.relativeDates = obj_
            obj_.original_tagname_ = 'relativeDates'
        elif nodeName_ == 'periodicDates':
            obj_ = PeriodicDates.factory()
            obj_.build(child_)
            self.periodicDates = obj_
            obj_.original_tagname_ = 'periodicDates'
# end class AdjustableRelativeOrPeriodicDates2


class AgreementType(GeneratedsSuper):
    member_data_items_ = {
        'agreementTypeScheme': MemberSpec_('agreementTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, agreementTypeScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.agreementTypeScheme = _cast(None, agreementTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AgreementType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AgreementType.subclass:
            return AgreementType.subclass(*args_, **kwargs_)
        else:
            return AgreementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_agreementTypeScheme(self): return self.agreementTypeScheme
    def set_agreementTypeScheme(self, agreementTypeScheme): self.agreementTypeScheme = agreementTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AgreementType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AgreementType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AgreementType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AgreementType'):
        if self.agreementTypeScheme is not None and 'agreementTypeScheme' not in already_processed:
            already_processed.add('agreementTypeScheme')
            outfile.write(' agreementTypeScheme=%s' % (quote_attrib(self.agreementTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AgreementType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('agreementTypeScheme', node)
        if value is not None and 'agreementTypeScheme' not in already_processed:
            already_processed.add('agreementTypeScheme')
            self.agreementTypeScheme = value
            self.validate_NonEmptyURI(self.agreementTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AgreementType


class AgreementVersion(GeneratedsSuper):
    member_data_items_ = {
        'agreementVersionScheme': MemberSpec_('agreementVersionScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, agreementVersionScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.agreementVersionScheme = _cast(None, agreementVersionScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AgreementVersion)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AgreementVersion.subclass:
            return AgreementVersion.subclass(*args_, **kwargs_)
        else:
            return AgreementVersion(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_agreementVersionScheme(self): return self.agreementVersionScheme
    def set_agreementVersionScheme(self, agreementVersionScheme): self.agreementVersionScheme = agreementVersionScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AgreementVersion', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AgreementVersion')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AgreementVersion', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AgreementVersion'):
        if self.agreementVersionScheme is not None and 'agreementVersionScheme' not in already_processed:
            already_processed.add('agreementVersionScheme')
            outfile.write(' agreementVersionScheme=%s' % (quote_attrib(self.agreementVersionScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AgreementVersion', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('agreementVersionScheme', node)
        if value is not None and 'agreementVersionScheme' not in already_processed:
            already_processed.add('agreementVersionScheme')
            self.agreementVersionScheme = value
            self.validate_NonEmptyURI(self.agreementVersionScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AgreementVersion


class AssetClass(GeneratedsSuper):
    member_data_items_ = {
        'assetClassScheme': MemberSpec_('assetClassScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, assetClassScheme='http://www.fpml.org/coding-scheme/asset-class', valueOf_=None):
        self.original_tagname_ = None
        self.assetClassScheme = _cast(None, assetClassScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AssetClass)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AssetClass.subclass:
            return AssetClass.subclass(*args_, **kwargs_)
        else:
            return AssetClass(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_assetClassScheme(self): return self.assetClassScheme
    def set_assetClassScheme(self, assetClassScheme): self.assetClassScheme = assetClassScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AssetClass', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AssetClass')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AssetClass', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AssetClass'):
        if self.assetClassScheme != "http://www.fpml.org/coding-scheme/asset-class" and 'assetClassScheme' not in already_processed:
            already_processed.add('assetClassScheme')
            outfile.write(' assetClassScheme=%s' % (quote_attrib(self.assetClassScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AssetClass', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('assetClassScheme', node)
        if value is not None and 'assetClassScheme' not in already_processed:
            already_processed.add('assetClassScheme')
            self.assetClassScheme = value
            self.validate_NonEmptyURI(self.assetClassScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AssetClass


class AutomaticExercise(GeneratedsSuper):
    """A type to define automatic exercise of a swaption. With automatic
    exercise the option is deemed to have exercised if it is in the
    money by more than the threshold amount on the exercise date."""
    member_data_items_ = {
        'thresholdRate': MemberSpec_('thresholdRate', 'xsd:decimal', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, thresholdRate=None):
        self.original_tagname_ = None
        self.thresholdRate = thresholdRate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AutomaticExercise)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AutomaticExercise.subclass:
            return AutomaticExercise.subclass(*args_, **kwargs_)
        else:
            return AutomaticExercise(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_thresholdRate(self): return self.thresholdRate
    def set_thresholdRate(self, thresholdRate): self.thresholdRate = thresholdRate
    def hasContent_(self):
        if (
            self.thresholdRate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AutomaticExercise', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AutomaticExercise')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AutomaticExercise', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AutomaticExercise'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AutomaticExercise', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.thresholdRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sthresholdRate>%s</%sthresholdRate>%s' % (namespace_, self.gds_format_float(self.thresholdRate, input_name='thresholdRate'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'thresholdRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'thresholdRate')
            self.thresholdRate = fval_
# end class AutomaticExercise


class AverageDailyTradingVolumeLimit(GeneratedsSuper):
    """To indicate the limitation percentage and limitation period."""
    member_data_items_ = {
        'limitationPercentage': MemberSpec_('limitationPercentage', ['RestrictedPercentage', 'xsd:decimal'], 0),
        'limitationPeriod': MemberSpec_('limitationPeriod', 'xsd:nonNegativeInteger', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, limitationPercentage=None, limitationPeriod=None):
        self.original_tagname_ = None
        self.limitationPercentage = limitationPercentage
        self.validate_RestrictedPercentage(self.limitationPercentage)
        self.limitationPeriod = limitationPeriod
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AverageDailyTradingVolumeLimit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AverageDailyTradingVolumeLimit.subclass:
            return AverageDailyTradingVolumeLimit.subclass(*args_, **kwargs_)
        else:
            return AverageDailyTradingVolumeLimit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_limitationPercentage(self): return self.limitationPercentage
    def set_limitationPercentage(self, limitationPercentage): self.limitationPercentage = limitationPercentage
    def get_limitationPeriod(self): return self.limitationPeriod
    def set_limitationPeriod(self, limitationPeriod): self.limitationPeriod = limitationPeriod
    def validate_RestrictedPercentage(self, value):
        # Validate type RestrictedPercentage, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on RestrictedPercentage' % {"value" : value} )
            if value > 1:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on RestrictedPercentage' % {"value" : value} )
    def hasContent_(self):
        if (
            self.limitationPercentage is not None or
            self.limitationPeriod is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AverageDailyTradingVolumeLimit', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AverageDailyTradingVolumeLimit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AverageDailyTradingVolumeLimit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AverageDailyTradingVolumeLimit'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AverageDailyTradingVolumeLimit', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.limitationPercentage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slimitationPercentage>%s</%slimitationPercentage>%s' % (namespace_, self.gds_format_float(self.limitationPercentage, input_name='limitationPercentage'), namespace_, eol_))
        if self.limitationPeriod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slimitationPeriod>%s</%slimitationPeriod>%s' % (namespace_, self.gds_format_integer(self.limitationPeriod, input_name='limitationPeriod'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'limitationPercentage':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'limitationPercentage')
            self.limitationPercentage = fval_
            # validate type RestrictedPercentage
            self.validate_RestrictedPercentage(self.limitationPercentage)
        elif nodeName_ == 'limitationPeriod':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'limitationPeriod')
            self.limitationPeriod = ival_
# end class AverageDailyTradingVolumeLimit


class Beneficiary(GeneratedsSuper):
    """A type defining the beneficiary of the funds."""
    member_data_items_ = {
        'routingIds': MemberSpec_('routingIds', 'RoutingIds', 0),
        'routingExplicitDetails': MemberSpec_('routingExplicitDetails', 'RoutingExplicitDetails', 0),
        'routingIdsAndExplicitDetails': MemberSpec_('routingIdsAndExplicitDetails', 'RoutingIdsAndExplicitDetails', 0),
        'beneficiaryPartyReference': MemberSpec_('beneficiaryPartyReference', 'PartyReference', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, routingIds=None, routingExplicitDetails=None, routingIdsAndExplicitDetails=None, beneficiaryPartyReference=None):
        self.original_tagname_ = None
        self.routingIds = routingIds
        self.routingExplicitDetails = routingExplicitDetails
        self.routingIdsAndExplicitDetails = routingIdsAndExplicitDetails
        self.beneficiaryPartyReference = beneficiaryPartyReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Beneficiary)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Beneficiary.subclass:
            return Beneficiary.subclass(*args_, **kwargs_)
        else:
            return Beneficiary(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_routingIds(self): return self.routingIds
    def set_routingIds(self, routingIds): self.routingIds = routingIds
    def get_routingExplicitDetails(self): return self.routingExplicitDetails
    def set_routingExplicitDetails(self, routingExplicitDetails): self.routingExplicitDetails = routingExplicitDetails
    def get_routingIdsAndExplicitDetails(self): return self.routingIdsAndExplicitDetails
    def set_routingIdsAndExplicitDetails(self, routingIdsAndExplicitDetails): self.routingIdsAndExplicitDetails = routingIdsAndExplicitDetails
    def get_beneficiaryPartyReference(self): return self.beneficiaryPartyReference
    def set_beneficiaryPartyReference(self, beneficiaryPartyReference): self.beneficiaryPartyReference = beneficiaryPartyReference
    def hasContent_(self):
        if (
            self.routingIds is not None or
            self.routingExplicitDetails is not None or
            self.routingIdsAndExplicitDetails is not None or
            self.beneficiaryPartyReference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Beneficiary', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Beneficiary')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Beneficiary', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Beneficiary'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Beneficiary', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.routingIds is not None:
            self.routingIds.export(outfile, level, namespace_, name_='routingIds', pretty_print=pretty_print)
        if self.routingExplicitDetails is not None:
            self.routingExplicitDetails.export(outfile, level, namespace_, name_='routingExplicitDetails', pretty_print=pretty_print)
        if self.routingIdsAndExplicitDetails is not None:
            self.routingIdsAndExplicitDetails.export(outfile, level, namespace_, name_='routingIdsAndExplicitDetails', pretty_print=pretty_print)
        if self.beneficiaryPartyReference is not None:
            self.beneficiaryPartyReference.export(outfile, level, namespace_, name_='beneficiaryPartyReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'routingIds':
            obj_ = RoutingIds.factory()
            obj_.build(child_)
            self.routingIds = obj_
            obj_.original_tagname_ = 'routingIds'
        elif nodeName_ == 'routingExplicitDetails':
            obj_ = RoutingExplicitDetails.factory()
            obj_.build(child_)
            self.routingExplicitDetails = obj_
            obj_.original_tagname_ = 'routingExplicitDetails'
        elif nodeName_ == 'routingIdsAndExplicitDetails':
            obj_ = RoutingIdsAndExplicitDetails.factory()
            obj_.build(child_)
            self.routingIdsAndExplicitDetails = obj_
            obj_.original_tagname_ = 'routingIdsAndExplicitDetails'
        elif nodeName_ == 'beneficiaryPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.beneficiaryPartyReference = obj_
            obj_.original_tagname_ = 'beneficiaryPartyReference'
# end class Beneficiary


class BrokerConfirmation(GeneratedsSuper):
    """Identifies the market sector in which the trade has been arranged."""
    member_data_items_ = {
        'brokerConfirmationType': MemberSpec_('brokerConfirmationType', 'BrokerConfirmationType', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, brokerConfirmationType=None):
        self.original_tagname_ = None
        self.brokerConfirmationType = brokerConfirmationType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BrokerConfirmation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BrokerConfirmation.subclass:
            return BrokerConfirmation.subclass(*args_, **kwargs_)
        else:
            return BrokerConfirmation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_brokerConfirmationType(self): return self.brokerConfirmationType
    def set_brokerConfirmationType(self, brokerConfirmationType): self.brokerConfirmationType = brokerConfirmationType
    def hasContent_(self):
        if (
            self.brokerConfirmationType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BrokerConfirmation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BrokerConfirmation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BrokerConfirmation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BrokerConfirmation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BrokerConfirmation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.brokerConfirmationType is not None:
            self.brokerConfirmationType.export(outfile, level, namespace_, name_='brokerConfirmationType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'brokerConfirmationType':
            obj_ = BrokerConfirmationType.factory()
            obj_.build(child_)
            self.brokerConfirmationType = obj_
            obj_.original_tagname_ = 'brokerConfirmationType'
# end class BrokerConfirmation


class BrokerConfirmationType(GeneratedsSuper):
    """Identifies the market sector in which the trade has been arranged."""
    member_data_items_ = {
        'brokerConfirmationTypeScheme': MemberSpec_('brokerConfirmationTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, brokerConfirmationTypeScheme='http://www.fpml.org/coding-scheme/broker-confirmation-type', valueOf_=None):
        self.original_tagname_ = None
        self.brokerConfirmationTypeScheme = _cast(None, brokerConfirmationTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BrokerConfirmationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BrokerConfirmationType.subclass:
            return BrokerConfirmationType.subclass(*args_, **kwargs_)
        else:
            return BrokerConfirmationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_brokerConfirmationTypeScheme(self): return self.brokerConfirmationTypeScheme
    def set_brokerConfirmationTypeScheme(self, brokerConfirmationTypeScheme): self.brokerConfirmationTypeScheme = brokerConfirmationTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BrokerConfirmationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BrokerConfirmationType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BrokerConfirmationType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BrokerConfirmationType'):
        if self.brokerConfirmationTypeScheme != "http://www.fpml.org/coding-scheme/broker-confirmation-type" and 'brokerConfirmationTypeScheme' not in already_processed:
            already_processed.add('brokerConfirmationTypeScheme')
            outfile.write(' brokerConfirmationTypeScheme=%s' % (quote_attrib(self.brokerConfirmationTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BrokerConfirmationType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('brokerConfirmationTypeScheme', node)
        if value is not None and 'brokerConfirmationTypeScheme' not in already_processed:
            already_processed.add('brokerConfirmationTypeScheme')
            self.brokerConfirmationTypeScheme = value
            self.validate_NonEmptyURI(self.brokerConfirmationTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BrokerConfirmationType


class BusinessCenter(GeneratedsSuper):
    """A code identifying a business day calendar location. A business day
    calendar location is drawn from the list identified by the
    business day calendar location scheme."""
    member_data_items_ = {
        'businessCenterScheme': MemberSpec_('businessCenterScheme', 'NonEmptyURI', 0),
        'id': MemberSpec_('id', 'xsd:string', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, businessCenterScheme='http://www.fpml.org/coding-scheme/business-center', id=None, valueOf_=None):
        self.original_tagname_ = None
        self.businessCenterScheme = _cast(None, businessCenterScheme)
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BusinessCenter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BusinessCenter.subclass:
            return BusinessCenter.subclass(*args_, **kwargs_)
        else:
            return BusinessCenter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_businessCenterScheme(self): return self.businessCenterScheme
    def set_businessCenterScheme(self, businessCenterScheme): self.businessCenterScheme = businessCenterScheme
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BusinessCenter', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BusinessCenter')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BusinessCenter', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BusinessCenter'):
        if self.businessCenterScheme != "http://www.fpml.org/coding-scheme/business-center" and 'businessCenterScheme' not in already_processed:
            already_processed.add('businessCenterScheme')
            outfile.write(' businessCenterScheme=%s' % (quote_attrib(self.businessCenterScheme), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BusinessCenter', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('businessCenterScheme', node)
        if value is not None and 'businessCenterScheme' not in already_processed:
            already_processed.add('businessCenterScheme')
            self.businessCenterScheme = value
            self.validate_NonEmptyURI(self.businessCenterScheme)    # validate type NonEmptyURI
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BusinessCenter


class BusinessCenters(GeneratedsSuper):
    """A type for defining business day calendar used in determining
    whether a day is a business day or not. A list of business day
    calendar locations may be ordered in the document alphabetically
    based on business day calendar location code. An FpML document
    containing an unordered business day calendar location list is
    still regarded as a conformant document."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'businessCenter': MemberSpec_('businessCenter', 'BusinessCenter', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, businessCenter=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if businessCenter is None:
            self.businessCenter = []
        else:
            self.businessCenter = businessCenter
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BusinessCenters)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BusinessCenters.subclass:
            return BusinessCenters.subclass(*args_, **kwargs_)
        else:
            return BusinessCenters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_businessCenter(self): return self.businessCenter
    def set_businessCenter(self, businessCenter): self.businessCenter = businessCenter
    def add_businessCenter(self, value): self.businessCenter.append(value)
    def insert_businessCenter_at(self, index, value): self.businessCenter.insert(index, value)
    def replace_businessCenter_at(self, index, value): self.businessCenter[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.businessCenter
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BusinessCenters', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BusinessCenters')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BusinessCenters', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BusinessCenters'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BusinessCenters', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for businessCenter_ in self.businessCenter:
            businessCenter_.export(outfile, level, namespace_, name_='businessCenter', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'businessCenter':
            obj_ = BusinessCenter.factory()
            obj_.build(child_)
            self.businessCenter.append(obj_)
            obj_.original_tagname_ = 'businessCenter'
# end class BusinessCenters


class BusinessCenterTime(GeneratedsSuper):
    """A type for defining a time with respect to a business day calendar
    location. For example, 11:00am London time."""
    member_data_items_ = {
        'hourMinuteTime': MemberSpec_('hourMinuteTime', ['HourMinuteTime', 'xsd:time'], 0),
        'businessCenter': MemberSpec_('businessCenter', 'BusinessCenter', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, hourMinuteTime=None, businessCenter=None):
        self.original_tagname_ = None
        if isinstance(hourMinuteTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(hourMinuteTime, '%H:%M:%S').time()
        else:
            initvalue_ = hourMinuteTime
        self.hourMinuteTime = initvalue_
        self.businessCenter = businessCenter
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BusinessCenterTime)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BusinessCenterTime.subclass:
            return BusinessCenterTime.subclass(*args_, **kwargs_)
        else:
            return BusinessCenterTime(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_hourMinuteTime(self): return self.hourMinuteTime
    def set_hourMinuteTime(self, hourMinuteTime): self.hourMinuteTime = hourMinuteTime
    def get_businessCenter(self): return self.businessCenter
    def set_businessCenter(self, businessCenter): self.businessCenter = businessCenter
    def validate_HourMinuteTime(self, value):
        # Validate type HourMinuteTime, a restriction on xsd:time.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_HourMinuteTime_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_HourMinuteTime_patterns_, ))
    validate_HourMinuteTime_patterns_ = [['^[0-2][0-9]:[0-5][0-9]:00$']]
    def hasContent_(self):
        if (
            self.hourMinuteTime is not None or
            self.businessCenter is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BusinessCenterTime', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BusinessCenterTime')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BusinessCenterTime', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BusinessCenterTime'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BusinessCenterTime', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.hourMinuteTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shourMinuteTime>%s</%shourMinuteTime>%s' % (namespace_, self.gds_format_time(self.hourMinuteTime, input_name='hourMinuteTime'), namespace_, eol_))
        if self.businessCenter is not None:
            self.businessCenter.export(outfile, level, namespace_, name_='businessCenter', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'hourMinuteTime':
            sval_ = child_.text
            dval_ = self.gds_parse_time(sval_)
            self.hourMinuteTime = dval_
            # validate type HourMinuteTime
            self.validate_HourMinuteTime(self.hourMinuteTime)
        elif nodeName_ == 'businessCenter':
            obj_ = BusinessCenter.factory()
            obj_.build(child_)
            self.businessCenter = obj_
            obj_.original_tagname_ = 'businessCenter'
# end class BusinessCenterTime


class BusinessDayAdjustments(GeneratedsSuper):
    """A type defining the business day convention and financial business
    centers used for adjusting any relevant date if it would
    otherwise fall on a day that is not a business day in the
    specified business centers."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'businessDayConvention': MemberSpec_('businessDayConvention', ['BusinessDayConventionEnum', 'Token', 'xsd:token'], 0),
        'businessCentersReference': MemberSpec_('businessCentersReference', 'BusinessCentersReference', 0),
        'businessCenters': MemberSpec_('businessCenters', 'BusinessCenters', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, businessDayConvention=None, businessCentersReference=None, businessCenters=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.businessDayConvention = businessDayConvention
        self.validate_BusinessDayConventionEnum(self.businessDayConvention)
        self.businessCentersReference = businessCentersReference
        self.businessCenters = businessCenters
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BusinessDayAdjustments)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BusinessDayAdjustments.subclass:
            return BusinessDayAdjustments.subclass(*args_, **kwargs_)
        else:
            return BusinessDayAdjustments(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_businessDayConvention(self): return self.businessDayConvention
    def set_businessDayConvention(self, businessDayConvention): self.businessDayConvention = businessDayConvention
    def get_businessCentersReference(self): return self.businessCentersReference
    def set_businessCentersReference(self, businessCentersReference): self.businessCentersReference = businessCentersReference
    def get_businessCenters(self): return self.businessCenters
    def set_businessCenters(self, businessCenters): self.businessCenters = businessCenters
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_BusinessDayConventionEnum(self, value):
        # Validate type BusinessDayConventionEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FOLLOWING', 'FRN', 'MODFOLLOWING', 'PRECEDING', 'MODPRECEDING', 'NEAREST', 'NONE', 'NotApplicable']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on BusinessDayConventionEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on BusinessDayConventionEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.businessDayConvention is not None or
            self.businessCentersReference is not None or
            self.businessCenters is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BusinessDayAdjustments', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BusinessDayAdjustments')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BusinessDayAdjustments', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BusinessDayAdjustments'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BusinessDayAdjustments', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.businessDayConvention is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbusinessDayConvention>%s</%sbusinessDayConvention>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.businessDayConvention), input_name='businessDayConvention')), namespace_, eol_))
        if self.businessCentersReference is not None:
            self.businessCentersReference.export(outfile, level, namespace_, name_='businessCentersReference', pretty_print=pretty_print)
        if self.businessCenters is not None:
            self.businessCenters.export(outfile, level, namespace_, name_='businessCenters', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'businessDayConvention':
            businessDayConvention_ = child_.text
            businessDayConvention_ = re_.sub(String_cleanup_pat_, " ", businessDayConvention_).strip()
            businessDayConvention_ = self.gds_validate_string(businessDayConvention_, node, 'businessDayConvention')
            self.businessDayConvention = businessDayConvention_
            # validate type BusinessDayConventionEnum
            self.validate_BusinessDayConventionEnum(self.businessDayConvention)
        elif nodeName_ == 'businessCentersReference':
            obj_ = BusinessCentersReference.factory()
            obj_.build(child_)
            self.businessCentersReference = obj_
            obj_.original_tagname_ = 'businessCentersReference'
        elif nodeName_ == 'businessCenters':
            obj_ = BusinessCenters.factory()
            obj_.build(child_)
            self.businessCenters = obj_
            obj_.original_tagname_ = 'businessCenters'
# end class BusinessDayAdjustments


class BusinessUnit(GeneratedsSuper):
    """A type that represents information about a unit within an
    organization."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'name': MemberSpec_('name', ['String', 'xsd:string'], 0),
        'businessUnitId': MemberSpec_('businessUnitId', 'Unit', 0),
        'contactInfo': MemberSpec_('contactInfo', 'ContactInformation', 0),
        'country': MemberSpec_('country', 'CountryCode', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, businessUnitId=None, contactInfo=None, country=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.name = name
        self.validate_String(self.name)
        self.businessUnitId = businessUnitId
        self.contactInfo = contactInfo
        self.country = country
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BusinessUnit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BusinessUnit.subclass:
            return BusinessUnit.subclass(*args_, **kwargs_)
        else:
            return BusinessUnit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_businessUnitId(self): return self.businessUnitId
    def set_businessUnitId(self, businessUnitId): self.businessUnitId = businessUnitId
    def get_contactInfo(self): return self.contactInfo
    def set_contactInfo(self, contactInfo): self.contactInfo = contactInfo
    def get_country(self): return self.country
    def set_country(self, country): self.country = country
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.name is not None or
            self.businessUnitId is not None or
            self.contactInfo is not None or
            self.country is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BusinessUnit', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BusinessUnit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BusinessUnit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BusinessUnit'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BusinessUnit', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespace_, eol_))
        if self.businessUnitId is not None:
            self.businessUnitId.export(outfile, level, namespace_, name_='businessUnitId', pretty_print=pretty_print)
        if self.contactInfo is not None:
            self.contactInfo.export(outfile, level, namespace_, name_='contactInfo', pretty_print=pretty_print)
        if self.country is not None:
            self.country.export(outfile, level, namespace_, name_='country', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
            # validate type String
            self.validate_String(self.name)
        elif nodeName_ == 'businessUnitId':
            obj_ = Unit.factory()
            obj_.build(child_)
            self.businessUnitId = obj_
            obj_.original_tagname_ = 'businessUnitId'
        elif nodeName_ == 'contactInfo':
            obj_ = ContactInformation.factory()
            obj_.build(child_)
            self.contactInfo = obj_
            obj_.original_tagname_ = 'contactInfo'
        elif nodeName_ == 'country':
            obj_ = CountryCode.factory()
            obj_.build(child_)
            self.country = obj_
            obj_.original_tagname_ = 'country'
# end class BusinessUnit


class BusinessUnitRole(GeneratedsSuper):
    """A type describing a role played by a unit in one or more
    transactions. Examples include roles such as Trader, Collateral,
    Confirmation, Settlement, etc. This can be extended to provide
    custom roles."""
    member_data_items_ = {
        'unitRoleScheme': MemberSpec_('unitRoleScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, unitRoleScheme='http://www.fpml.org/coding-scheme/unit-role', valueOf_=None):
        self.original_tagname_ = None
        self.unitRoleScheme = _cast(None, unitRoleScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BusinessUnitRole)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BusinessUnitRole.subclass:
            return BusinessUnitRole.subclass(*args_, **kwargs_)
        else:
            return BusinessUnitRole(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unitRoleScheme(self): return self.unitRoleScheme
    def set_unitRoleScheme(self, unitRoleScheme): self.unitRoleScheme = unitRoleScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BusinessUnitRole', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BusinessUnitRole')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BusinessUnitRole', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BusinessUnitRole'):
        if self.unitRoleScheme != "http://www.fpml.org/coding-scheme/unit-role" and 'unitRoleScheme' not in already_processed:
            already_processed.add('unitRoleScheme')
            outfile.write(' unitRoleScheme=%s' % (quote_attrib(self.unitRoleScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BusinessUnitRole', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unitRoleScheme', node)
        if value is not None and 'unitRoleScheme' not in already_processed:
            already_processed.add('unitRoleScheme')
            self.unitRoleScheme = value
            self.validate_NonEmptyURI(self.unitRoleScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BusinessUnitRole


class CalculationAgent(GeneratedsSuper):
    """A type defining the ISDA calculation agent responsible for
    performing duties as defined in the applicable product
    definitions."""
    member_data_items_ = {
        'calculationAgentPartyReference': MemberSpec_('calculationAgentPartyReference', 'PartyReference', 1),
        'calculationAgentParty': MemberSpec_('calculationAgentParty', ['CalculationAgentPartyEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, calculationAgentPartyReference=None, calculationAgentParty=None):
        self.original_tagname_ = None
        if calculationAgentPartyReference is None:
            self.calculationAgentPartyReference = []
        else:
            self.calculationAgentPartyReference = calculationAgentPartyReference
        self.calculationAgentParty = calculationAgentParty
        self.validate_CalculationAgentPartyEnum(self.calculationAgentParty)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CalculationAgent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CalculationAgent.subclass:
            return CalculationAgent.subclass(*args_, **kwargs_)
        else:
            return CalculationAgent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_calculationAgentPartyReference(self): return self.calculationAgentPartyReference
    def set_calculationAgentPartyReference(self, calculationAgentPartyReference): self.calculationAgentPartyReference = calculationAgentPartyReference
    def add_calculationAgentPartyReference(self, value): self.calculationAgentPartyReference.append(value)
    def insert_calculationAgentPartyReference_at(self, index, value): self.calculationAgentPartyReference.insert(index, value)
    def replace_calculationAgentPartyReference_at(self, index, value): self.calculationAgentPartyReference[index] = value
    def get_calculationAgentParty(self): return self.calculationAgentParty
    def set_calculationAgentParty(self, calculationAgentParty): self.calculationAgentParty = calculationAgentParty
    def validate_CalculationAgentPartyEnum(self, value):
        # Validate type CalculationAgentPartyEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ExercisingParty', 'NonExercisingParty', 'AsSpecifiedInMasterAgreement', 'AsSpecifiedInStandardTermsSupplement', 'Both']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CalculationAgentPartyEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on CalculationAgentPartyEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.calculationAgentPartyReference or
            self.calculationAgentParty is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CalculationAgent', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CalculationAgent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CalculationAgent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CalculationAgent'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CalculationAgent', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for calculationAgentPartyReference_ in self.calculationAgentPartyReference:
            calculationAgentPartyReference_.export(outfile, level, namespace_, name_='calculationAgentPartyReference', pretty_print=pretty_print)
        if self.calculationAgentParty is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scalculationAgentParty>%s</%scalculationAgentParty>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.calculationAgentParty), input_name='calculationAgentParty')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'calculationAgentPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.calculationAgentPartyReference.append(obj_)
            obj_.original_tagname_ = 'calculationAgentPartyReference'
        elif nodeName_ == 'calculationAgentParty':
            calculationAgentParty_ = child_.text
            calculationAgentParty_ = re_.sub(String_cleanup_pat_, " ", calculationAgentParty_).strip()
            calculationAgentParty_ = self.gds_validate_string(calculationAgentParty_, node, 'calculationAgentParty')
            self.calculationAgentParty = calculationAgentParty_
            # validate type CalculationAgentPartyEnum
            self.validate_CalculationAgentPartyEnum(self.calculationAgentParty)
# end class CalculationAgent


class CashflowId(GeneratedsSuper):
    """An identifier used to identify a single component cashflow."""
    member_data_items_ = {
        'cashflowIdScheme': MemberSpec_('cashflowIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, cashflowIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.cashflowIdScheme = _cast(None, cashflowIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CashflowId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CashflowId.subclass:
            return CashflowId.subclass(*args_, **kwargs_)
        else:
            return CashflowId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cashflowIdScheme(self): return self.cashflowIdScheme
    def set_cashflowIdScheme(self, cashflowIdScheme): self.cashflowIdScheme = cashflowIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CashflowId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CashflowId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CashflowId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CashflowId'):
        if self.cashflowIdScheme is not None and 'cashflowIdScheme' not in already_processed:
            already_processed.add('cashflowIdScheme')
            outfile.write(' cashflowIdScheme=%s' % (quote_attrib(self.cashflowIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CashflowId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('cashflowIdScheme', node)
        if value is not None and 'cashflowIdScheme' not in already_processed:
            already_processed.add('cashflowIdScheme')
            self.cashflowIdScheme = value
            self.validate_NonEmptyURI(self.cashflowIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CashflowId


class CashflowNotional(GeneratedsSuper):
    """The notional/principal value/quantity/volume used to compute the
    cashflow."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'currency': MemberSpec_('currency', 'Currency', 0),
        'units': MemberSpec_('units', ['NormalizedString', 'xsd:normalizedString'], 0),
        'amount': MemberSpec_('amount', 'xsd:decimal', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, currency=None, units=None, amount=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.currency = currency
        self.units = units
        self.validate_NormalizedString(self.units)
        self.amount = amount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CashflowNotional)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CashflowNotional.subclass:
            return CashflowNotional.subclass(*args_, **kwargs_)
        else:
            return CashflowNotional(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_units(self): return self.units
    def set_units(self, units): self.units = units
    def get_amount(self): return self.amount
    def set_amount(self, amount): self.amount = amount
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_NormalizedString(self, value):
        # Validate type NormalizedString, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NormalizedString' % {"value" : value} )
    def hasContent_(self):
        if (
            self.currency is not None or
            self.units is not None or
            self.amount is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CashflowNotional', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CashflowNotional')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CashflowNotional', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CashflowNotional'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CashflowNotional', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.currency is not None:
            self.currency.export(outfile, level, namespace_, name_='currency', pretty_print=pretty_print)
        if self.units is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sunits>%s</%sunits>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.units), input_name='units')), namespace_, eol_))
        if self.amount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%samount>%s</%samount>%s' % (namespace_, self.gds_format_float(self.amount, input_name='amount'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'currency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'units':
            units_ = child_.text
            units_ = self.gds_validate_string(units_, node, 'units')
            self.units = units_
            # validate type NormalizedString
            self.validate_NormalizedString(self.units)
        elif nodeName_ == 'amount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'amount')
            self.amount = fval_
# end class CashflowNotional


class CashflowType(GeneratedsSuper):
    """A coding scheme used to describe the type or purpose of a cash flow
    or cash flow component."""
    member_data_items_ = {
        'cashflowTypeScheme': MemberSpec_('cashflowTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, cashflowTypeScheme='http://www.fpml.org/coding-scheme/cashflow-type', valueOf_=None):
        self.original_tagname_ = None
        self.cashflowTypeScheme = _cast(None, cashflowTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CashflowType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CashflowType.subclass:
            return CashflowType.subclass(*args_, **kwargs_)
        else:
            return CashflowType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cashflowTypeScheme(self): return self.cashflowTypeScheme
    def set_cashflowTypeScheme(self, cashflowTypeScheme): self.cashflowTypeScheme = cashflowTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CashflowType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CashflowType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CashflowType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CashflowType'):
        if self.cashflowTypeScheme != "http://www.fpml.org/coding-scheme/cashflow-type" and 'cashflowTypeScheme' not in already_processed:
            already_processed.add('cashflowTypeScheme')
            outfile.write(' cashflowTypeScheme=%s' % (quote_attrib(self.cashflowTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CashflowType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('cashflowTypeScheme', node)
        if value is not None and 'cashflowTypeScheme' not in already_processed:
            already_processed.add('cashflowTypeScheme')
            self.cashflowTypeScheme = value
            self.validate_NonEmptyURI(self.cashflowTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CashflowType


class CashSettlementReferenceBanks(GeneratedsSuper):
    """A type defining the list of reference institutions polled for
    relevant rates or prices when determining the cash settlement
    amount for a product where cash settlement is applicable."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'referenceBank': MemberSpec_('referenceBank', 'ReferenceBank', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, referenceBank=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if referenceBank is None:
            self.referenceBank = []
        else:
            self.referenceBank = referenceBank
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CashSettlementReferenceBanks)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CashSettlementReferenceBanks.subclass:
            return CashSettlementReferenceBanks.subclass(*args_, **kwargs_)
        else:
            return CashSettlementReferenceBanks(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_referenceBank(self): return self.referenceBank
    def set_referenceBank(self, referenceBank): self.referenceBank = referenceBank
    def add_referenceBank(self, value): self.referenceBank.append(value)
    def insert_referenceBank_at(self, index, value): self.referenceBank.insert(index, value)
    def replace_referenceBank_at(self, index, value): self.referenceBank[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.referenceBank
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CashSettlementReferenceBanks', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CashSettlementReferenceBanks')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CashSettlementReferenceBanks', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CashSettlementReferenceBanks'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CashSettlementReferenceBanks', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for referenceBank_ in self.referenceBank:
            referenceBank_.export(outfile, level, namespace_, name_='referenceBank', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'referenceBank':
            obj_ = ReferenceBank.factory()
            obj_.build(child_)
            self.referenceBank.append(obj_)
            obj_.original_tagname_ = 'referenceBank'
# end class CashSettlementReferenceBanks


class ClearanceSystem(GeneratedsSuper):
    """Unless otherwise specified, the principal clearance system
    customarily used for settling trades in the relevant underlying."""
    member_data_items_ = {
        'clearanceSystemScheme': MemberSpec_('clearanceSystemScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, clearanceSystemScheme='http://www.fpml.org/coding-scheme/clearance-system', valueOf_=None):
        self.original_tagname_ = None
        self.clearanceSystemScheme = _cast(None, clearanceSystemScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClearanceSystem)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClearanceSystem.subclass:
            return ClearanceSystem.subclass(*args_, **kwargs_)
        else:
            return ClearanceSystem(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_clearanceSystemScheme(self): return self.clearanceSystemScheme
    def set_clearanceSystemScheme(self, clearanceSystemScheme): self.clearanceSystemScheme = clearanceSystemScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ClearanceSystem', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ClearanceSystem')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ClearanceSystem', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ClearanceSystem'):
        if self.clearanceSystemScheme != "http://www.fpml.org/coding-scheme/clearance-system" and 'clearanceSystemScheme' not in already_processed:
            already_processed.add('clearanceSystemScheme')
            outfile.write(' clearanceSystemScheme=%s' % (quote_attrib(self.clearanceSystemScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ClearanceSystem', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('clearanceSystemScheme', node)
        if value is not None and 'clearanceSystemScheme' not in already_processed:
            already_processed.add('clearanceSystemScheme')
            self.clearanceSystemScheme = value
            self.validate_NonEmptyURI(self.clearanceSystemScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ClearanceSystem


class SwaptionPhysicalSettlement(GeneratedsSuper):
    member_data_items_ = {
        'clearedPhysicalSettlement': MemberSpec_('clearedPhysicalSettlement', 'xsd:boolean', 0),
        'predeterminedClearingOrganizationPartyReference': MemberSpec_('predeterminedClearingOrganizationPartyReference', 'PartyReference', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, clearedPhysicalSettlement=None, predeterminedClearingOrganizationPartyReference=None):
        self.original_tagname_ = None
        self.clearedPhysicalSettlement = clearedPhysicalSettlement
        self.predeterminedClearingOrganizationPartyReference = predeterminedClearingOrganizationPartyReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SwaptionPhysicalSettlement)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SwaptionPhysicalSettlement.subclass:
            return SwaptionPhysicalSettlement.subclass(*args_, **kwargs_)
        else:
            return SwaptionPhysicalSettlement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_clearedPhysicalSettlement(self): return self.clearedPhysicalSettlement
    def set_clearedPhysicalSettlement(self, clearedPhysicalSettlement): self.clearedPhysicalSettlement = clearedPhysicalSettlement
    def get_predeterminedClearingOrganizationPartyReference(self): return self.predeterminedClearingOrganizationPartyReference
    def set_predeterminedClearingOrganizationPartyReference(self, predeterminedClearingOrganizationPartyReference): self.predeterminedClearingOrganizationPartyReference = predeterminedClearingOrganizationPartyReference
    def hasContent_(self):
        if (
            self.clearedPhysicalSettlement is not None or
            self.predeterminedClearingOrganizationPartyReference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SwaptionPhysicalSettlement', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SwaptionPhysicalSettlement')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SwaptionPhysicalSettlement', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SwaptionPhysicalSettlement'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SwaptionPhysicalSettlement', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.clearedPhysicalSettlement is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sclearedPhysicalSettlement>%s</%sclearedPhysicalSettlement>%s' % (namespace_, self.gds_format_boolean(self.clearedPhysicalSettlement, input_name='clearedPhysicalSettlement'), namespace_, eol_))
        if self.predeterminedClearingOrganizationPartyReference is not None:
            self.predeterminedClearingOrganizationPartyReference.export(outfile, level, namespace_, name_='predeterminedClearingOrganizationPartyReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'clearedPhysicalSettlement':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'clearedPhysicalSettlement')
            self.clearedPhysicalSettlement = ival_
        elif nodeName_ == 'predeterminedClearingOrganizationPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.predeterminedClearingOrganizationPartyReference = obj_
            obj_.original_tagname_ = 'predeterminedClearingOrganizationPartyReference'
# end class SwaptionPhysicalSettlement


class Collateral(GeneratedsSuper):
    """A type for defining the obligations of the counterparty subject to
    credit support requirements."""
    member_data_items_ = {
        'independentAmount': MemberSpec_('independentAmount', 'IndependentAmount', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, independentAmount=None):
        self.original_tagname_ = None
        self.independentAmount = independentAmount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Collateral)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Collateral.subclass:
            return Collateral.subclass(*args_, **kwargs_)
        else:
            return Collateral(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_independentAmount(self): return self.independentAmount
    def set_independentAmount(self, independentAmount): self.independentAmount = independentAmount
    def hasContent_(self):
        if (
            self.independentAmount is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Collateral', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Collateral')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Collateral', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Collateral'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Collateral', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.independentAmount is not None:
            self.independentAmount.export(outfile, level, namespace_, name_='independentAmount', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'independentAmount':
            obj_ = IndependentAmount.factory()
            obj_.build(child_)
            self.independentAmount = obj_
            obj_.original_tagname_ = 'independentAmount'
# end class Collateral


class CollateralValueAllocation(GeneratedsSuper):
    member_data_items_ = {
        'type_': MemberSpec_('type_', ['CollateralValueAllocationEnum', 'Token', 'xsd:token'], 0),
        'value': MemberSpec_('value', 'Money', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, type_=None, value=None):
        self.original_tagname_ = None
        self.type_ = type_
        self.validate_CollateralValueAllocationEnum(self.type_)
        if value is None:
            self.value = []
        else:
            self.value = value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CollateralValueAllocation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CollateralValueAllocation.subclass:
            return CollateralValueAllocation.subclass(*args_, **kwargs_)
        else:
            return CollateralValueAllocation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value_at(self, index, value): self.value.insert(index, value)
    def replace_value_at(self, index, value): self.value[index] = value
    def validate_CollateralValueAllocationEnum(self, value):
        # Validate type CollateralValueAllocationEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Buffer', 'Full', 'ExcessOverMargin', 'Margin']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CollateralValueAllocationEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on CollateralValueAllocationEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.type_ is not None or
            self.value
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CollateralValueAllocation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CollateralValueAllocation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CollateralValueAllocation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CollateralValueAllocation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CollateralValueAllocation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stype>%s</%stype>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.type_), input_name='type')), namespace_, eol_))
        for value_ in self.value:
            value_.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            type_ = child_.text
            type_ = re_.sub(String_cleanup_pat_, " ", type_).strip()
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
            # validate type CollateralValueAllocationEnum
            self.validate_CollateralValueAllocationEnum(self.type_)
        elif nodeName_ == 'value':
            class_obj_ = self.get_class_obj_(child_, Money)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.value.append(obj_)
            obj_.original_tagname_ = 'value'
# end class CollateralValueAllocation


class ContactInformation(GeneratedsSuper):
    """A type that represents how to contact an individual or organization."""
    member_data_items_ = {
        'telephone': MemberSpec_('telephone', 'TelephoneNumber', 1),
        'email': MemberSpec_('email', ['NormalizedString', 'xsd:normalizedString'], 1),
        'address': MemberSpec_('address', 'Address', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, telephone=None, email=None, address=None):
        self.original_tagname_ = None
        if telephone is None:
            self.telephone = []
        else:
            self.telephone = telephone
        if email is None:
            self.email = []
        else:
            self.email = email
        self.address = address
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContactInformation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContactInformation.subclass:
            return ContactInformation.subclass(*args_, **kwargs_)
        else:
            return ContactInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_telephone(self): return self.telephone
    def set_telephone(self, telephone): self.telephone = telephone
    def add_telephone(self, value): self.telephone.append(value)
    def insert_telephone_at(self, index, value): self.telephone.insert(index, value)
    def replace_telephone_at(self, index, value): self.telephone[index] = value
    def get_email(self): return self.email
    def set_email(self, email): self.email = email
    def add_email(self, value): self.email.append(value)
    def insert_email_at(self, index, value): self.email.insert(index, value)
    def replace_email_at(self, index, value): self.email[index] = value
    def get_address(self): return self.address
    def set_address(self, address): self.address = address
    def validate_NormalizedString(self, value):
        # Validate type NormalizedString, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NormalizedString' % {"value" : value} )
    def hasContent_(self):
        if (
            self.telephone or
            self.email or
            self.address is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ContactInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContactInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ContactInformation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContactInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ContactInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for telephone_ in self.telephone:
            telephone_.export(outfile, level, namespace_, name_='telephone', pretty_print=pretty_print)
        for email_ in self.email:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%semail>%s</%semail>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(email_), input_name='email')), namespace_, eol_))
        if self.address is not None:
            self.address.export(outfile, level, namespace_, name_='address', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'telephone':
            obj_ = TelephoneNumber.factory()
            obj_.build(child_)
            self.telephone.append(obj_)
            obj_.original_tagname_ = 'telephone'
        elif nodeName_ == 'email':
            email_ = child_.text
            email_ = self.gds_validate_string(email_, node, 'email')
            self.email.append(email_)
            # validate type NormalizedString
            self.validate_NormalizedString(self.email[-1])
        elif nodeName_ == 'address':
            obj_ = Address.factory()
            obj_.build(child_)
            self.address = obj_
            obj_.original_tagname_ = 'address'
# end class ContactInformation


class ContractualDefinitions(GeneratedsSuper):
    """The definitions, such as those published by ISDA, that will define
    the terms of the trade."""
    member_data_items_ = {
        'contractualDefinitionsScheme': MemberSpec_('contractualDefinitionsScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, contractualDefinitionsScheme='http://www.fpml.org/coding-scheme/contractual-definitions', valueOf_=None):
        self.original_tagname_ = None
        self.contractualDefinitionsScheme = _cast(None, contractualDefinitionsScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContractualDefinitions)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContractualDefinitions.subclass:
            return ContractualDefinitions.subclass(*args_, **kwargs_)
        else:
            return ContractualDefinitions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_contractualDefinitionsScheme(self): return self.contractualDefinitionsScheme
    def set_contractualDefinitionsScheme(self, contractualDefinitionsScheme): self.contractualDefinitionsScheme = contractualDefinitionsScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ContractualDefinitions', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContractualDefinitions')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ContractualDefinitions', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContractualDefinitions'):
        if self.contractualDefinitionsScheme != "http://www.fpml.org/coding-scheme/contractual-definitions" and 'contractualDefinitionsScheme' not in already_processed:
            already_processed.add('contractualDefinitionsScheme')
            outfile.write(' contractualDefinitionsScheme=%s' % (quote_attrib(self.contractualDefinitionsScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ContractualDefinitions', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('contractualDefinitionsScheme', node)
        if value is not None and 'contractualDefinitionsScheme' not in already_processed:
            already_processed.add('contractualDefinitionsScheme')
            self.contractualDefinitionsScheme = value
            self.validate_NonEmptyURI(self.contractualDefinitionsScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ContractualDefinitions


class ContractualMatrix(GeneratedsSuper):
    member_data_items_ = {
        'matrixType': MemberSpec_('matrixType', 'MatrixType', 0),
        'publicationDate': MemberSpec_('publicationDate', 'xsd:date', 0),
        'matrixTerm': MemberSpec_('matrixTerm', 'MatrixTerm', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, matrixType=None, publicationDate=None, matrixTerm=None):
        self.original_tagname_ = None
        self.matrixType = matrixType
        if isinstance(publicationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(publicationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = publicationDate
        self.publicationDate = initvalue_
        self.matrixTerm = matrixTerm
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContractualMatrix)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContractualMatrix.subclass:
            return ContractualMatrix.subclass(*args_, **kwargs_)
        else:
            return ContractualMatrix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_matrixType(self): return self.matrixType
    def set_matrixType(self, matrixType): self.matrixType = matrixType
    def get_publicationDate(self): return self.publicationDate
    def set_publicationDate(self, publicationDate): self.publicationDate = publicationDate
    def get_matrixTerm(self): return self.matrixTerm
    def set_matrixTerm(self, matrixTerm): self.matrixTerm = matrixTerm
    def hasContent_(self):
        if (
            self.matrixType is not None or
            self.publicationDate is not None or
            self.matrixTerm is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ContractualMatrix', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContractualMatrix')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ContractualMatrix', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContractualMatrix'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ContractualMatrix', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.matrixType is not None:
            self.matrixType.export(outfile, level, namespace_, name_='matrixType', pretty_print=pretty_print)
        if self.publicationDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spublicationDate>%s</%spublicationDate>%s' % (namespace_, self.gds_format_date(self.publicationDate, input_name='publicationDate'), namespace_, eol_))
        if self.matrixTerm is not None:
            self.matrixTerm.export(outfile, level, namespace_, name_='matrixTerm', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'matrixType':
            obj_ = MatrixType.factory()
            obj_.build(child_)
            self.matrixType = obj_
            obj_.original_tagname_ = 'matrixType'
        elif nodeName_ == 'publicationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.publicationDate = dval_
        elif nodeName_ == 'matrixTerm':
            obj_ = MatrixTerm.factory()
            obj_.build(child_)
            self.matrixTerm = obj_
            obj_.original_tagname_ = 'matrixTerm'
# end class ContractualMatrix


class ContractualSupplement(GeneratedsSuper):
    """A contractual supplement (such as those published by ISDA) that will
    apply to the trade."""
    member_data_items_ = {
        'contractualSupplementScheme': MemberSpec_('contractualSupplementScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, contractualSupplementScheme='http://www.fpml.org/coding-scheme/contractual-supplement', valueOf_=None):
        self.original_tagname_ = None
        self.contractualSupplementScheme = _cast(None, contractualSupplementScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContractualSupplement)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContractualSupplement.subclass:
            return ContractualSupplement.subclass(*args_, **kwargs_)
        else:
            return ContractualSupplement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_contractualSupplementScheme(self): return self.contractualSupplementScheme
    def set_contractualSupplementScheme(self, contractualSupplementScheme): self.contractualSupplementScheme = contractualSupplementScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ContractualSupplement', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContractualSupplement')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ContractualSupplement', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContractualSupplement'):
        if self.contractualSupplementScheme != "http://www.fpml.org/coding-scheme/contractual-supplement" and 'contractualSupplementScheme' not in already_processed:
            already_processed.add('contractualSupplementScheme')
            outfile.write(' contractualSupplementScheme=%s' % (quote_attrib(self.contractualSupplementScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ContractualSupplement', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('contractualSupplementScheme', node)
        if value is not None and 'contractualSupplementScheme' not in already_processed:
            already_processed.add('contractualSupplementScheme')
            self.contractualSupplementScheme = value
            self.validate_NonEmptyURI(self.contractualSupplementScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ContractualSupplement


class ContractualTermsSupplement(GeneratedsSuper):
    """A contractual supplement (such as those published by ISDA) and its
    publication date that will apply to the trade."""
    member_data_items_ = {
        'type_': MemberSpec_('type_', 'ContractualSupplement', 0),
        'publicationDate': MemberSpec_('publicationDate', 'xsd:date', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, type_=None, publicationDate=None):
        self.original_tagname_ = None
        self.type_ = type_
        if isinstance(publicationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(publicationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = publicationDate
        self.publicationDate = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContractualTermsSupplement)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContractualTermsSupplement.subclass:
            return ContractualTermsSupplement.subclass(*args_, **kwargs_)
        else:
            return ContractualTermsSupplement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_publicationDate(self): return self.publicationDate
    def set_publicationDate(self, publicationDate): self.publicationDate = publicationDate
    def hasContent_(self):
        if (
            self.type_ is not None or
            self.publicationDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ContractualTermsSupplement', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContractualTermsSupplement')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ContractualTermsSupplement', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContractualTermsSupplement'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ContractualTermsSupplement', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            self.type_.export(outfile, level, namespace_, name_='type', pretty_print=pretty_print)
        if self.publicationDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spublicationDate>%s</%spublicationDate>%s' % (namespace_, self.gds_format_date(self.publicationDate, input_name='publicationDate'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            obj_ = ContractualSupplement.factory()
            obj_.build(child_)
            self.type_ = obj_
            obj_.original_tagname_ = 'type'
        elif nodeName_ == 'publicationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.publicationDate = dval_
# end class ContractualTermsSupplement


class CorrespondentInformation(GeneratedsSuper):
    """A type that describes the information to identify a correspondent
    bank that will make delivery of the funds on the paying bank's
    behalf in the country where the payment is to be made."""
    member_data_items_ = {
        'routingIds': MemberSpec_('routingIds', 'RoutingIds', 0),
        'routingExplicitDetails': MemberSpec_('routingExplicitDetails', 'RoutingExplicitDetails', 0),
        'routingIdsAndExplicitDetails': MemberSpec_('routingIdsAndExplicitDetails', 'RoutingIdsAndExplicitDetails', 0),
        'correspondentPartyReference': MemberSpec_('correspondentPartyReference', 'PartyReference', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, routingIds=None, routingExplicitDetails=None, routingIdsAndExplicitDetails=None, correspondentPartyReference=None):
        self.original_tagname_ = None
        self.routingIds = routingIds
        self.routingExplicitDetails = routingExplicitDetails
        self.routingIdsAndExplicitDetails = routingIdsAndExplicitDetails
        self.correspondentPartyReference = correspondentPartyReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CorrespondentInformation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CorrespondentInformation.subclass:
            return CorrespondentInformation.subclass(*args_, **kwargs_)
        else:
            return CorrespondentInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_routingIds(self): return self.routingIds
    def set_routingIds(self, routingIds): self.routingIds = routingIds
    def get_routingExplicitDetails(self): return self.routingExplicitDetails
    def set_routingExplicitDetails(self, routingExplicitDetails): self.routingExplicitDetails = routingExplicitDetails
    def get_routingIdsAndExplicitDetails(self): return self.routingIdsAndExplicitDetails
    def set_routingIdsAndExplicitDetails(self, routingIdsAndExplicitDetails): self.routingIdsAndExplicitDetails = routingIdsAndExplicitDetails
    def get_correspondentPartyReference(self): return self.correspondentPartyReference
    def set_correspondentPartyReference(self, correspondentPartyReference): self.correspondentPartyReference = correspondentPartyReference
    def hasContent_(self):
        if (
            self.routingIds is not None or
            self.routingExplicitDetails is not None or
            self.routingIdsAndExplicitDetails is not None or
            self.correspondentPartyReference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CorrespondentInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CorrespondentInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CorrespondentInformation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CorrespondentInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CorrespondentInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.routingIds is not None:
            self.routingIds.export(outfile, level, namespace_, name_='routingIds', pretty_print=pretty_print)
        if self.routingExplicitDetails is not None:
            self.routingExplicitDetails.export(outfile, level, namespace_, name_='routingExplicitDetails', pretty_print=pretty_print)
        if self.routingIdsAndExplicitDetails is not None:
            self.routingIdsAndExplicitDetails.export(outfile, level, namespace_, name_='routingIdsAndExplicitDetails', pretty_print=pretty_print)
        if self.correspondentPartyReference is not None:
            self.correspondentPartyReference.export(outfile, level, namespace_, name_='correspondentPartyReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'routingIds':
            obj_ = RoutingIds.factory()
            obj_.build(child_)
            self.routingIds = obj_
            obj_.original_tagname_ = 'routingIds'
        elif nodeName_ == 'routingExplicitDetails':
            obj_ = RoutingExplicitDetails.factory()
            obj_.build(child_)
            self.routingExplicitDetails = obj_
            obj_.original_tagname_ = 'routingExplicitDetails'
        elif nodeName_ == 'routingIdsAndExplicitDetails':
            obj_ = RoutingIdsAndExplicitDetails.factory()
            obj_.build(child_)
            self.routingIdsAndExplicitDetails = obj_
            obj_.original_tagname_ = 'routingIdsAndExplicitDetails'
        elif nodeName_ == 'correspondentPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.correspondentPartyReference = obj_
            obj_.original_tagname_ = 'correspondentPartyReference'
# end class CorrespondentInformation


class CountryCode(GeneratedsSuper):
    """The code representation of a country or an area of special
    sovereignty. By default it is a valid 2 character country code
    as defined by the ISO standard 3166-1 alpha-2 - Codes for
    representation of countries
    http://www.niso.org/standards/resources/3166.html."""
    member_data_items_ = {
        'countryScheme': MemberSpec_('countryScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, countryScheme='http://www.fpml.org/coding-scheme/external/iso3166', valueOf_=None):
        self.original_tagname_ = None
        self.countryScheme = _cast(None, countryScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CountryCode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CountryCode.subclass:
            return CountryCode.subclass(*args_, **kwargs_)
        else:
            return CountryCode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_countryScheme(self): return self.countryScheme
    def set_countryScheme(self, countryScheme): self.countryScheme = countryScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CountryCode', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CountryCode')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CountryCode', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CountryCode'):
        if self.countryScheme != "http://www.fpml.org/coding-scheme/external/iso3166" and 'countryScheme' not in already_processed:
            already_processed.add('countryScheme')
            outfile.write(' countryScheme=%s' % (quote_attrib(self.countryScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CountryCode', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('countryScheme', node)
        if value is not None and 'countryScheme' not in already_processed:
            already_processed.add('countryScheme')
            self.countryScheme = value
            self.validate_NonEmptyURI(self.countryScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CountryCode


class CreditSeniority(GeneratedsSuper):
    """The repayment precedence of a debt
    instrument.creditSeniorityTradingScheme overrides
    creditSeniorityScheme when the underlyer defines the reference
    obligation used in a single name credit default swap trade."""
    member_data_items_ = {
        'creditSeniorityScheme': MemberSpec_('creditSeniorityScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, creditSeniorityScheme='http://www.fpml.org/coding-scheme/credit-seniority', valueOf_=None):
        self.original_tagname_ = None
        self.creditSeniorityScheme = _cast(None, creditSeniorityScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditSeniority)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditSeniority.subclass:
            return CreditSeniority.subclass(*args_, **kwargs_)
        else:
            return CreditSeniority(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_creditSeniorityScheme(self): return self.creditSeniorityScheme
    def set_creditSeniorityScheme(self, creditSeniorityScheme): self.creditSeniorityScheme = creditSeniorityScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditSeniority', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditSeniority')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditSeniority', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditSeniority'):
        if self.creditSeniorityScheme != "http://www.fpml.org/coding-scheme/credit-seniority" and 'creditSeniorityScheme' not in already_processed:
            already_processed.add('creditSeniorityScheme')
            outfile.write(' creditSeniorityScheme=%s' % (quote_attrib(self.creditSeniorityScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CreditSeniority', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('creditSeniorityScheme', node)
        if value is not None and 'creditSeniorityScheme' not in already_processed:
            already_processed.add('creditSeniorityScheme')
            self.creditSeniorityScheme = value
            self.validate_NonEmptyURI(self.creditSeniorityScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CreditSeniority


class CreditSupportAgreement(GeneratedsSuper):
    """The agreement executed between the parties and intended to govern
    collateral arrangement for all OTC derivatives transactions
    between those parties."""
    member_data_items_ = {
        'type_': MemberSpec_('type_', 'CreditSupportAgreementType', 0),
        'date': MemberSpec_('date', 'xsd:date', 0),
        'identifier': MemberSpec_('identifier', 'CreditSupportAgreementIdentifier', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, type_=None, date=None, identifier=None):
        self.original_tagname_ = None
        self.type_ = type_
        if isinstance(date, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(date, '%Y-%m-%d').date()
        else:
            initvalue_ = date
        self.date = initvalue_
        self.identifier = identifier
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditSupportAgreement)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditSupportAgreement.subclass:
            return CreditSupportAgreement.subclass(*args_, **kwargs_)
        else:
            return CreditSupportAgreement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_date(self): return self.date
    def set_date(self, date): self.date = date
    def get_identifier(self): return self.identifier
    def set_identifier(self, identifier): self.identifier = identifier
    def hasContent_(self):
        if (
            self.type_ is not None or
            self.date is not None or
            self.identifier is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditSupportAgreement', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditSupportAgreement')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditSupportAgreement', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditSupportAgreement'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CreditSupportAgreement', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            self.type_.export(outfile, level, namespace_, name_='type', pretty_print=pretty_print)
        if self.date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdate>%s</%sdate>%s' % (namespace_, self.gds_format_date(self.date, input_name='date'), namespace_, eol_))
        if self.identifier is not None:
            self.identifier.export(outfile, level, namespace_, name_='identifier', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            obj_ = CreditSupportAgreementType.factory()
            obj_.build(child_)
            self.type_ = obj_
            obj_.original_tagname_ = 'type'
        elif nodeName_ == 'date':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.date = dval_
        elif nodeName_ == 'identifier':
            obj_ = CreditSupportAgreementIdentifier.factory()
            obj_.build(child_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
# end class CreditSupportAgreement


class CreditSupportAgreementIdentifier(GeneratedsSuper):
    member_data_items_ = {
        'creditSupportAgreementIdScheme': MemberSpec_('creditSupportAgreementIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, creditSupportAgreementIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.creditSupportAgreementIdScheme = _cast(None, creditSupportAgreementIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditSupportAgreementIdentifier)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditSupportAgreementIdentifier.subclass:
            return CreditSupportAgreementIdentifier.subclass(*args_, **kwargs_)
        else:
            return CreditSupportAgreementIdentifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_creditSupportAgreementIdScheme(self): return self.creditSupportAgreementIdScheme
    def set_creditSupportAgreementIdScheme(self, creditSupportAgreementIdScheme): self.creditSupportAgreementIdScheme = creditSupportAgreementIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditSupportAgreementIdentifier', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditSupportAgreementIdentifier')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditSupportAgreementIdentifier', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditSupportAgreementIdentifier'):
        if self.creditSupportAgreementIdScheme is not None and 'creditSupportAgreementIdScheme' not in already_processed:
            already_processed.add('creditSupportAgreementIdScheme')
            outfile.write(' creditSupportAgreementIdScheme=%s' % (quote_attrib(self.creditSupportAgreementIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CreditSupportAgreementIdentifier', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('creditSupportAgreementIdScheme', node)
        if value is not None and 'creditSupportAgreementIdScheme' not in already_processed:
            already_processed.add('creditSupportAgreementIdScheme')
            self.creditSupportAgreementIdScheme = value
            self.validate_NonEmptyURI(self.creditSupportAgreementIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CreditSupportAgreementIdentifier


class CreditSupportAgreementType(GeneratedsSuper):
    member_data_items_ = {
        'creditSupportAgreementTypeScheme': MemberSpec_('creditSupportAgreementTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, creditSupportAgreementTypeScheme='http://www.fpml.org/coding-scheme/credit-support-agreement-type', valueOf_=None):
        self.original_tagname_ = None
        self.creditSupportAgreementTypeScheme = _cast(None, creditSupportAgreementTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditSupportAgreementType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditSupportAgreementType.subclass:
            return CreditSupportAgreementType.subclass(*args_, **kwargs_)
        else:
            return CreditSupportAgreementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_creditSupportAgreementTypeScheme(self): return self.creditSupportAgreementTypeScheme
    def set_creditSupportAgreementTypeScheme(self, creditSupportAgreementTypeScheme): self.creditSupportAgreementTypeScheme = creditSupportAgreementTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditSupportAgreementType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditSupportAgreementType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditSupportAgreementType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditSupportAgreementType'):
        if self.creditSupportAgreementTypeScheme != "http://www.fpml.org/coding-scheme/credit-support-agreement-type" and 'creditSupportAgreementTypeScheme' not in already_processed:
            already_processed.add('creditSupportAgreementTypeScheme')
            outfile.write(' creditSupportAgreementTypeScheme=%s' % (quote_attrib(self.creditSupportAgreementTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CreditSupportAgreementType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('creditSupportAgreementTypeScheme', node)
        if value is not None and 'creditSupportAgreementTypeScheme' not in already_processed:
            already_processed.add('creditSupportAgreementTypeScheme')
            self.creditSupportAgreementTypeScheme = value
            self.validate_NonEmptyURI(self.creditSupportAgreementTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CreditSupportAgreementType


class CreditRating(GeneratedsSuper):
    """A party's credit rating."""
    member_data_items_ = {
        'creditRatingScheme': MemberSpec_('creditRatingScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, creditRatingScheme='http://www.fpml.org/coding-scheme/external/moodys', valueOf_=None):
        self.original_tagname_ = None
        self.creditRatingScheme = _cast(None, creditRatingScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditRating)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditRating.subclass:
            return CreditRating.subclass(*args_, **kwargs_)
        else:
            return CreditRating(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_creditRatingScheme(self): return self.creditRatingScheme
    def set_creditRatingScheme(self, creditRatingScheme): self.creditRatingScheme = creditRatingScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditRating', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditRating')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditRating', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditRating'):
        if self.creditRatingScheme != "http://www.fpml.org/coding-scheme/external/moodys" and 'creditRatingScheme' not in already_processed:
            already_processed.add('creditRatingScheme')
            outfile.write(' creditRatingScheme=%s' % (quote_attrib(self.creditRatingScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CreditRating', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('creditRatingScheme', node)
        if value is not None and 'creditRatingScheme' not in already_processed:
            already_processed.add('creditRatingScheme')
            self.creditRatingScheme = value
            self.validate_NonEmptyURI(self.creditRatingScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CreditRating


class Currency(GeneratedsSuper):
    """The code representation of a currency or fund. By default it is a
    valid currency code as defined by the ISO standard 4217 - Codes
    for representation of currencies and funds
    http://www.iso.org/iso/en/prods-
    services/popstds/currencycodeslist.html."""
    member_data_items_ = {
        'currencyScheme': MemberSpec_('currencyScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, currencyScheme='http://www.fpml.org/coding-scheme/external/iso4217-2001-08-15', valueOf_=None, extensiontype_=None):
        self.original_tagname_ = None
        self.currencyScheme = _cast(None, currencyScheme)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Currency)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Currency.subclass:
            return Currency.subclass(*args_, **kwargs_)
        else:
            return Currency(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_currencyScheme(self): return self.currencyScheme
    def set_currencyScheme(self, currencyScheme): self.currencyScheme = currencyScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Currency', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Currency')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Currency', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Currency'):
        if self.currencyScheme != "http://www.fpml.org/coding-scheme/external/iso4217-2001-08-15" and 'currencyScheme' not in already_processed:
            already_processed.add('currencyScheme')
            outfile.write(' currencyScheme=%s' % (quote_attrib(self.currencyScheme), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Currency', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('currencyScheme', node)
        if value is not None and 'currencyScheme' not in already_processed:
            already_processed.add('currencyScheme')
            self.currencyScheme = value
            self.validate_NonEmptyURI(self.currencyScheme)    # validate type NonEmptyURI
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Currency


class DateList(GeneratedsSuper):
    """List of Dates"""
    member_data_items_ = {
        'date': MemberSpec_('date', 'xsd:date', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, date=None):
        self.original_tagname_ = None
        if date is None:
            self.date = []
        else:
            self.date = date
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DateList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DateList.subclass:
            return DateList.subclass(*args_, **kwargs_)
        else:
            return DateList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_date(self): return self.date
    def set_date(self, date): self.date = date
    def add_date(self, value): self.date.append(value)
    def insert_date_at(self, index, value): self.date.insert(index, value)
    def replace_date_at(self, index, value): self.date[index] = value
    def hasContent_(self):
        if (
            self.date
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DateList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DateList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DateList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DateList'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DateList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for date_ in self.date:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdate>%s</%sdate>%s' % (namespace_, self.gds_format_date(date_, input_name='date'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'date':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.date.append(dval_)
# end class DateList


class DateRange(GeneratedsSuper):
    """A type defining a contiguous series of calendar dates. The date
    range is defined as all the dates between and including the
    first and the last date. The first date must fall before the
    last date."""
    member_data_items_ = {
        'unadjustedFirstDate': MemberSpec_('unadjustedFirstDate', 'xsd:date', 0),
        'unadjustedLastDate': MemberSpec_('unadjustedLastDate', 'xsd:date', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, unadjustedFirstDate=None, unadjustedLastDate=None, extensiontype_=None):
        self.original_tagname_ = None
        if isinstance(unadjustedFirstDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(unadjustedFirstDate, '%Y-%m-%d').date()
        else:
            initvalue_ = unadjustedFirstDate
        self.unadjustedFirstDate = initvalue_
        if isinstance(unadjustedLastDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(unadjustedLastDate, '%Y-%m-%d').date()
        else:
            initvalue_ = unadjustedLastDate
        self.unadjustedLastDate = initvalue_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DateRange)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DateRange.subclass:
            return DateRange.subclass(*args_, **kwargs_)
        else:
            return DateRange(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unadjustedFirstDate(self): return self.unadjustedFirstDate
    def set_unadjustedFirstDate(self, unadjustedFirstDate): self.unadjustedFirstDate = unadjustedFirstDate
    def get_unadjustedLastDate(self): return self.unadjustedLastDate
    def set_unadjustedLastDate(self, unadjustedLastDate): self.unadjustedLastDate = unadjustedLastDate
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.unadjustedFirstDate is not None or
            self.unadjustedLastDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DateRange', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DateRange')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DateRange', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DateRange'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DateRange', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.unadjustedFirstDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sunadjustedFirstDate>%s</%sunadjustedFirstDate>%s' % (namespace_, self.gds_format_date(self.unadjustedFirstDate, input_name='unadjustedFirstDate'), namespace_, eol_))
        if self.unadjustedLastDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sunadjustedLastDate>%s</%sunadjustedLastDate>%s' % (namespace_, self.gds_format_date(self.unadjustedLastDate, input_name='unadjustedLastDate'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'unadjustedFirstDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.unadjustedFirstDate = dval_
        elif nodeName_ == 'unadjustedLastDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.unadjustedLastDate = dval_
# end class DateRange


class DateTimeList(GeneratedsSuper):
    """List of DateTimes"""
    member_data_items_ = {
        'dateTime': MemberSpec_('dateTime', 'xsd:dateTime', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, dateTime=None):
        self.original_tagname_ = None
        if dateTime is None:
            self.dateTime = []
        else:
            self.dateTime = dateTime
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DateTimeList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DateTimeList.subclass:
            return DateTimeList.subclass(*args_, **kwargs_)
        else:
            return DateTimeList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dateTime(self): return self.dateTime
    def set_dateTime(self, dateTime): self.dateTime = dateTime
    def add_dateTime(self, value): self.dateTime.append(value)
    def insert_dateTime_at(self, index, value): self.dateTime.insert(index, value)
    def replace_dateTime_at(self, index, value): self.dateTime[index] = value
    def hasContent_(self):
        if (
            self.dateTime
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DateTimeList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DateTimeList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DateTimeList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DateTimeList'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DateTimeList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for dateTime_ in self.dateTime:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdateTime>%s</%sdateTime>%s' % (namespace_, self.gds_format_datetime(dateTime_, input_name='dateTime'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.dateTime.append(dval_)
# end class DateTimeList


class DayCountFraction(GeneratedsSuper):
    """The specification for how the number of days between two dates is
    calculated for purposes of calculation of a fixed or floating
    payment amount and the basis for how many days are assumed to be
    in a year. Day Count Fraction is an ISDA term. The equivalent
    AFB (Association Francaise de Banques) term is Calculation
    Basis."""
    member_data_items_ = {
        'dayCountFractionScheme': MemberSpec_('dayCountFractionScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, dayCountFractionScheme='http://www.fpml.org/coding-scheme/day-count-fraction', valueOf_=None):
        self.original_tagname_ = None
        self.dayCountFractionScheme = _cast(None, dayCountFractionScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DayCountFraction)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DayCountFraction.subclass:
            return DayCountFraction.subclass(*args_, **kwargs_)
        else:
            return DayCountFraction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dayCountFractionScheme(self): return self.dayCountFractionScheme
    def set_dayCountFractionScheme(self, dayCountFractionScheme): self.dayCountFractionScheme = dayCountFractionScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DayCountFraction', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DayCountFraction')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DayCountFraction', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DayCountFraction'):
        if self.dayCountFractionScheme != "http://www.fpml.org/coding-scheme/day-count-fraction" and 'dayCountFractionScheme' not in already_processed:
            already_processed.add('dayCountFractionScheme')
            outfile.write(' dayCountFractionScheme=%s' % (quote_attrib(self.dayCountFractionScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DayCountFraction', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dayCountFractionScheme', node)
        if value is not None and 'dayCountFractionScheme' not in already_processed:
            already_processed.add('dayCountFractionScheme')
            self.dayCountFractionScheme = value
            self.validate_NonEmptyURI(self.dayCountFractionScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DayCountFraction


class DeterminationMethod(GeneratedsSuper):
    """Coding scheme that specifies the method according to which an amount
    or a date is determined."""
    member_data_items_ = {
        'determinationMethodScheme': MemberSpec_('determinationMethodScheme', 'NonEmptyURI', 0),
        'id': MemberSpec_('id', 'xsd:string', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, determinationMethodScheme='http://www.fpml.org/coding-scheme/determination-method', id=None, valueOf_=None):
        self.original_tagname_ = None
        self.determinationMethodScheme = _cast(None, determinationMethodScheme)
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DeterminationMethod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DeterminationMethod.subclass:
            return DeterminationMethod.subclass(*args_, **kwargs_)
        else:
            return DeterminationMethod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_determinationMethodScheme(self): return self.determinationMethodScheme
    def set_determinationMethodScheme(self, determinationMethodScheme): self.determinationMethodScheme = determinationMethodScheme
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DeterminationMethod', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeterminationMethod')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DeterminationMethod', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DeterminationMethod'):
        if self.determinationMethodScheme != "http://www.fpml.org/coding-scheme/determination-method" and 'determinationMethodScheme' not in already_processed:
            already_processed.add('determinationMethodScheme')
            outfile.write(' determinationMethodScheme=%s' % (quote_attrib(self.determinationMethodScheme), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DeterminationMethod', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('determinationMethodScheme', node)
        if value is not None and 'determinationMethodScheme' not in already_processed:
            already_processed.add('determinationMethodScheme')
            self.determinationMethodScheme = value
            self.validate_NonEmptyURI(self.determinationMethodScheme)    # validate type NonEmptyURI
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DeterminationMethod


class Documentation(GeneratedsSuper):
    """An entity for defining the definitions that govern the document and
    should include the year and type of definitions referenced,
    along with any relevant documentation (such as master agreement)
    and the date it was signed."""
    member_data_items_ = {
        'masterAgreement': MemberSpec_('masterAgreement', 'MasterAgreement', 0),
        'masterConfirmation': MemberSpec_('masterConfirmation', 'MasterConfirmation', 0),
        'brokerConfirmation': MemberSpec_('brokerConfirmation', 'BrokerConfirmation', 0),
        'contractualDefinitions': MemberSpec_('contractualDefinitions', 'ContractualDefinitions', 1),
        'contractualTermsSupplement': MemberSpec_('contractualTermsSupplement', 'ContractualTermsSupplement', 1),
        'contractualMatrix': MemberSpec_('contractualMatrix', 'ContractualMatrix', 1),
        'creditSupportAgreement': MemberSpec_('creditSupportAgreement', 'CreditSupportAgreement', 0),
        'attachment': MemberSpec_('attachment', 'Resource', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, masterAgreement=None, masterConfirmation=None, brokerConfirmation=None, contractualDefinitions=None, contractualTermsSupplement=None, contractualMatrix=None, creditSupportAgreement=None, attachment=None):
        self.original_tagname_ = None
        self.masterAgreement = masterAgreement
        self.masterConfirmation = masterConfirmation
        self.brokerConfirmation = brokerConfirmation
        if contractualDefinitions is None:
            self.contractualDefinitions = []
        else:
            self.contractualDefinitions = contractualDefinitions
        if contractualTermsSupplement is None:
            self.contractualTermsSupplement = []
        else:
            self.contractualTermsSupplement = contractualTermsSupplement
        if contractualMatrix is None:
            self.contractualMatrix = []
        else:
            self.contractualMatrix = contractualMatrix
        self.creditSupportAgreement = creditSupportAgreement
        if attachment is None:
            self.attachment = []
        else:
            self.attachment = attachment
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Documentation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Documentation.subclass:
            return Documentation.subclass(*args_, **kwargs_)
        else:
            return Documentation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_masterAgreement(self): return self.masterAgreement
    def set_masterAgreement(self, masterAgreement): self.masterAgreement = masterAgreement
    def get_masterConfirmation(self): return self.masterConfirmation
    def set_masterConfirmation(self, masterConfirmation): self.masterConfirmation = masterConfirmation
    def get_brokerConfirmation(self): return self.brokerConfirmation
    def set_brokerConfirmation(self, brokerConfirmation): self.brokerConfirmation = brokerConfirmation
    def get_contractualDefinitions(self): return self.contractualDefinitions
    def set_contractualDefinitions(self, contractualDefinitions): self.contractualDefinitions = contractualDefinitions
    def add_contractualDefinitions(self, value): self.contractualDefinitions.append(value)
    def insert_contractualDefinitions_at(self, index, value): self.contractualDefinitions.insert(index, value)
    def replace_contractualDefinitions_at(self, index, value): self.contractualDefinitions[index] = value
    def get_contractualTermsSupplement(self): return self.contractualTermsSupplement
    def set_contractualTermsSupplement(self, contractualTermsSupplement): self.contractualTermsSupplement = contractualTermsSupplement
    def add_contractualTermsSupplement(self, value): self.contractualTermsSupplement.append(value)
    def insert_contractualTermsSupplement_at(self, index, value): self.contractualTermsSupplement.insert(index, value)
    def replace_contractualTermsSupplement_at(self, index, value): self.contractualTermsSupplement[index] = value
    def get_contractualMatrix(self): return self.contractualMatrix
    def set_contractualMatrix(self, contractualMatrix): self.contractualMatrix = contractualMatrix
    def add_contractualMatrix(self, value): self.contractualMatrix.append(value)
    def insert_contractualMatrix_at(self, index, value): self.contractualMatrix.insert(index, value)
    def replace_contractualMatrix_at(self, index, value): self.contractualMatrix[index] = value
    def get_creditSupportAgreement(self): return self.creditSupportAgreement
    def set_creditSupportAgreement(self, creditSupportAgreement): self.creditSupportAgreement = creditSupportAgreement
    def get_attachment(self): return self.attachment
    def set_attachment(self, attachment): self.attachment = attachment
    def add_attachment(self, value): self.attachment.append(value)
    def insert_attachment_at(self, index, value): self.attachment.insert(index, value)
    def replace_attachment_at(self, index, value): self.attachment[index] = value
    def hasContent_(self):
        if (
            self.masterAgreement is not None or
            self.masterConfirmation is not None or
            self.brokerConfirmation is not None or
            self.contractualDefinitions or
            self.contractualTermsSupplement or
            self.contractualMatrix or
            self.creditSupportAgreement is not None or
            self.attachment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Documentation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Documentation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Documentation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Documentation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Documentation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.masterAgreement is not None:
            self.masterAgreement.export(outfile, level, namespace_, name_='masterAgreement', pretty_print=pretty_print)
        if self.masterConfirmation is not None:
            self.masterConfirmation.export(outfile, level, namespace_, name_='masterConfirmation', pretty_print=pretty_print)
        if self.brokerConfirmation is not None:
            self.brokerConfirmation.export(outfile, level, namespace_, name_='brokerConfirmation', pretty_print=pretty_print)
        for contractualDefinitions_ in self.contractualDefinitions:
            contractualDefinitions_.export(outfile, level, namespace_, name_='contractualDefinitions', pretty_print=pretty_print)
        for contractualTermsSupplement_ in self.contractualTermsSupplement:
            contractualTermsSupplement_.export(outfile, level, namespace_, name_='contractualTermsSupplement', pretty_print=pretty_print)
        for contractualMatrix_ in self.contractualMatrix:
            contractualMatrix_.export(outfile, level, namespace_, name_='contractualMatrix', pretty_print=pretty_print)
        if self.creditSupportAgreement is not None:
            self.creditSupportAgreement.export(outfile, level, namespace_, name_='creditSupportAgreement', pretty_print=pretty_print)
        for attachment_ in self.attachment:
            attachment_.export(outfile, level, namespace_, name_='attachment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'masterAgreement':
            obj_ = MasterAgreement.factory()
            obj_.build(child_)
            self.masterAgreement = obj_
            obj_.original_tagname_ = 'masterAgreement'
        elif nodeName_ == 'masterConfirmation':
            obj_ = MasterConfirmation.factory()
            obj_.build(child_)
            self.masterConfirmation = obj_
            obj_.original_tagname_ = 'masterConfirmation'
        elif nodeName_ == 'brokerConfirmation':
            obj_ = BrokerConfirmation.factory()
            obj_.build(child_)
            self.brokerConfirmation = obj_
            obj_.original_tagname_ = 'brokerConfirmation'
        elif nodeName_ == 'contractualDefinitions':
            obj_ = ContractualDefinitions.factory()
            obj_.build(child_)
            self.contractualDefinitions.append(obj_)
            obj_.original_tagname_ = 'contractualDefinitions'
        elif nodeName_ == 'contractualTermsSupplement':
            obj_ = ContractualTermsSupplement.factory()
            obj_.build(child_)
            self.contractualTermsSupplement.append(obj_)
            obj_.original_tagname_ = 'contractualTermsSupplement'
        elif nodeName_ == 'contractualMatrix':
            obj_ = ContractualMatrix.factory()
            obj_.build(child_)
            self.contractualMatrix.append(obj_)
            obj_.original_tagname_ = 'contractualMatrix'
        elif nodeName_ == 'creditSupportAgreement':
            obj_ = CreditSupportAgreement.factory()
            obj_.build(child_)
            self.creditSupportAgreement = obj_
            obj_.original_tagname_ = 'creditSupportAgreement'
        elif nodeName_ == 'attachment':
            obj_ = Resource.factory()
            obj_.build(child_)
            self.attachment.append(obj_)
            obj_.original_tagname_ = 'attachment'
# end class Documentation


class EmbeddedOptionType(GeneratedsSuper):
    """A flexible description of the type or characteristics of an option
    embbedded within another product. For example, a cancelable
    provision or an optional early termination provision.The type
    scheme used with this option type."""
    member_data_items_ = {
        'embeddedOptionTypeScheme': MemberSpec_('embeddedOptionTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, embeddedOptionTypeScheme='http://www.fpml.org/coding-scheme/embedded-option-type', valueOf_=None):
        self.original_tagname_ = None
        self.embeddedOptionTypeScheme = _cast(None, embeddedOptionTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EmbeddedOptionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EmbeddedOptionType.subclass:
            return EmbeddedOptionType.subclass(*args_, **kwargs_)
        else:
            return EmbeddedOptionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_embeddedOptionTypeScheme(self): return self.embeddedOptionTypeScheme
    def set_embeddedOptionTypeScheme(self, embeddedOptionTypeScheme): self.embeddedOptionTypeScheme = embeddedOptionTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EmbeddedOptionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EmbeddedOptionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EmbeddedOptionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EmbeddedOptionType'):
        if self.embeddedOptionTypeScheme != "http://www.fpml.org/coding-scheme/embedded-option-type" and 'embeddedOptionTypeScheme' not in already_processed:
            already_processed.add('embeddedOptionTypeScheme')
            outfile.write(' embeddedOptionTypeScheme=%s' % (quote_attrib(self.embeddedOptionTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EmbeddedOptionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('embeddedOptionTypeScheme', node)
        if value is not None and 'embeddedOptionTypeScheme' not in already_processed:
            already_processed.add('embeddedOptionTypeScheme')
            self.embeddedOptionTypeScheme = value
            self.validate_NonEmptyURI(self.embeddedOptionTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EmbeddedOptionType


class Empty(GeneratedsSuper):
    """A special type meant to be used for elements with no content and no
    attributes."""
    member_data_items_ = {
    }
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Empty)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Empty.subclass:
            return Empty.subclass(*args_, **kwargs_)
        else:
            return Empty(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Empty', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Empty')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Empty', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Empty'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Empty', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Empty


class EntityId(GeneratedsSuper):
    """A legal entity identifier (e.g. RED entity code)."""
    member_data_items_ = {
        'entityIdScheme': MemberSpec_('entityIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, entityIdScheme='http://www.fpml.org/coding-scheme/external/entity-id-RED-1-0', valueOf_=None):
        self.original_tagname_ = None
        self.entityIdScheme = _cast(None, entityIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntityId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntityId.subclass:
            return EntityId.subclass(*args_, **kwargs_)
        else:
            return EntityId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_entityIdScheme(self): return self.entityIdScheme
    def set_entityIdScheme(self, entityIdScheme): self.entityIdScheme = entityIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EntityId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EntityId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EntityId'):
        if self.entityIdScheme != "http://www.fpml.org/coding-scheme/external/entity-id-RED-1-0" and 'entityIdScheme' not in already_processed:
            already_processed.add('entityIdScheme')
            outfile.write(' entityIdScheme=%s' % (quote_attrib(self.entityIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EntityId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('entityIdScheme', node)
        if value is not None and 'entityIdScheme' not in already_processed:
            already_processed.add('entityIdScheme')
            self.entityIdScheme = value
            self.validate_NonEmptyURI(self.entityIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntityId


class EntityName(GeneratedsSuper):
    """The name of the reference entity. A free format string. FpML does
    not define usage rules for this element."""
    member_data_items_ = {
        'entityNameScheme': MemberSpec_('entityNameScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, entityNameScheme='http://www.fpml.org/coding-scheme/external/entity-name-RED-1-0', valueOf_=None):
        self.original_tagname_ = None
        self.entityNameScheme = _cast(None, entityNameScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntityName)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntityName.subclass:
            return EntityName.subclass(*args_, **kwargs_)
        else:
            return EntityName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_entityNameScheme(self): return self.entityNameScheme
    def set_entityNameScheme(self, entityNameScheme): self.entityNameScheme = entityNameScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EntityName', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityName')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EntityName', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EntityName'):
        if self.entityNameScheme != "http://www.fpml.org/coding-scheme/external/entity-name-RED-1-0" and 'entityNameScheme' not in already_processed:
            already_processed.add('entityNameScheme')
            outfile.write(' entityNameScheme=%s' % (quote_attrib(self.entityNameScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EntityName', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('entityNameScheme', node)
        if value is not None and 'entityNameScheme' not in already_processed:
            already_processed.add('entityNameScheme')
            self.entityNameScheme = value
            self.validate_NonEmptyURI(self.entityNameScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntityName


class ExchangeId(GeneratedsSuper):
    """A short form unique identifier for an exchange. If the element is
    not present then the exchange shall be the primary exchange on
    which the underlying is listed. The term "Exchange" is assumed
    to have the meaning as defined in the ISDA 2002 Equity
    Derivatives Definitions."""
    member_data_items_ = {
        'exchangeIdScheme': MemberSpec_('exchangeIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, exchangeIdScheme='http://www.fpml.org/coding-scheme/external/exchange-id-MIC-1-0', valueOf_=None):
        self.original_tagname_ = None
        self.exchangeIdScheme = _cast(None, exchangeIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExchangeId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExchangeId.subclass:
            return ExchangeId.subclass(*args_, **kwargs_)
        else:
            return ExchangeId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_exchangeIdScheme(self): return self.exchangeIdScheme
    def set_exchangeIdScheme(self, exchangeIdScheme): self.exchangeIdScheme = exchangeIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExchangeId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExchangeId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExchangeId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExchangeId'):
        if self.exchangeIdScheme != "http://www.fpml.org/coding-scheme/external/exchange-id-MIC-1-0" and 'exchangeIdScheme' not in already_processed:
            already_processed.add('exchangeIdScheme')
            outfile.write(' exchangeIdScheme=%s' % (quote_attrib(self.exchangeIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ExchangeId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('exchangeIdScheme', node)
        if value is not None and 'exchangeIdScheme' not in already_processed:
            already_processed.add('exchangeIdScheme')
            self.exchangeIdScheme = value
            self.validate_NonEmptyURI(self.exchangeIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ExchangeId


class Exercise(GeneratedsSuper):
    """The abstract base class for all types which define way in which
    options may be exercised."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Exercise)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Exercise.subclass:
            return Exercise.subclass(*args_, **kwargs_)
        else:
            return Exercise(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Exercise', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Exercise')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Exercise', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Exercise'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Exercise', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Exercise


class ExerciseFee(GeneratedsSuper):
    """A type defining the fee payable on exercise of an option. This fee
    may be defined as an amount or a percentage of the notional
    exercised."""
    member_data_items_ = {
        'payerPartyReference': MemberSpec_('payerPartyReference', 'PartyReference', 0),
        'payerAccountReference': MemberSpec_('payerAccountReference', 'AccountReference', 0),
        'receiverPartyReference': MemberSpec_('receiverPartyReference', 'PartyReference', 0),
        'receiverAccountReference': MemberSpec_('receiverAccountReference', 'AccountReference', 0),
        'notionalReference': MemberSpec_('notionalReference', 'NotionalReference', 0),
        'feeAmount': MemberSpec_('feeAmount', 'xsd:decimal', 0),
        'feeRate': MemberSpec_('feeRate', 'xsd:decimal', 0),
        'feePaymentDate': MemberSpec_('feePaymentDate', 'RelativeDateOffset', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, notionalReference=None, feeAmount=None, feeRate=None, feePaymentDate=None):
        self.original_tagname_ = None
        self.payerPartyReference = payerPartyReference
        self.payerAccountReference = payerAccountReference
        self.receiverPartyReference = receiverPartyReference
        self.receiverAccountReference = receiverAccountReference
        self.notionalReference = notionalReference
        self.feeAmount = feeAmount
        self.feeRate = feeRate
        self.feePaymentDate = feePaymentDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExerciseFee)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExerciseFee.subclass:
            return ExerciseFee.subclass(*args_, **kwargs_)
        else:
            return ExerciseFee(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_payerPartyReference(self): return self.payerPartyReference
    def set_payerPartyReference(self, payerPartyReference): self.payerPartyReference = payerPartyReference
    def get_payerAccountReference(self): return self.payerAccountReference
    def set_payerAccountReference(self, payerAccountReference): self.payerAccountReference = payerAccountReference
    def get_receiverPartyReference(self): return self.receiverPartyReference
    def set_receiverPartyReference(self, receiverPartyReference): self.receiverPartyReference = receiverPartyReference
    def get_receiverAccountReference(self): return self.receiverAccountReference
    def set_receiverAccountReference(self, receiverAccountReference): self.receiverAccountReference = receiverAccountReference
    def get_notionalReference(self): return self.notionalReference
    def set_notionalReference(self, notionalReference): self.notionalReference = notionalReference
    def get_feeAmount(self): return self.feeAmount
    def set_feeAmount(self, feeAmount): self.feeAmount = feeAmount
    def get_feeRate(self): return self.feeRate
    def set_feeRate(self, feeRate): self.feeRate = feeRate
    def get_feePaymentDate(self): return self.feePaymentDate
    def set_feePaymentDate(self, feePaymentDate): self.feePaymentDate = feePaymentDate
    def hasContent_(self):
        if (
            self.payerPartyReference is not None or
            self.payerAccountReference is not None or
            self.receiverPartyReference is not None or
            self.receiverAccountReference is not None or
            self.notionalReference is not None or
            self.feeAmount is not None or
            self.feeRate is not None or
            self.feePaymentDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExerciseFee', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExerciseFee')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExerciseFee', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExerciseFee'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ExerciseFee', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.payerPartyReference is not None:
            self.payerPartyReference.export(outfile, level, namespace_, name_='payerPartyReference', pretty_print=pretty_print)
        if self.payerAccountReference is not None:
            self.payerAccountReference.export(outfile, level, namespace_, name_='payerAccountReference', pretty_print=pretty_print)
        if self.receiverPartyReference is not None:
            self.receiverPartyReference.export(outfile, level, namespace_, name_='receiverPartyReference', pretty_print=pretty_print)
        if self.receiverAccountReference is not None:
            self.receiverAccountReference.export(outfile, level, namespace_, name_='receiverAccountReference', pretty_print=pretty_print)
        if self.notionalReference is not None:
            self.notionalReference.export(outfile, level, namespace_, name_='notionalReference', pretty_print=pretty_print)
        if self.feeAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfeeAmount>%s</%sfeeAmount>%s' % (namespace_, self.gds_format_float(self.feeAmount, input_name='feeAmount'), namespace_, eol_))
        if self.feeRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfeeRate>%s</%sfeeRate>%s' % (namespace_, self.gds_format_float(self.feeRate, input_name='feeRate'), namespace_, eol_))
        if self.feePaymentDate is not None:
            self.feePaymentDate.export(outfile, level, namespace_, name_='feePaymentDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'payerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.payerPartyReference = obj_
            obj_.original_tagname_ = 'payerPartyReference'
        elif nodeName_ == 'payerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.payerAccountReference = obj_
            obj_.original_tagname_ = 'payerAccountReference'
        elif nodeName_ == 'receiverPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.receiverPartyReference = obj_
            obj_.original_tagname_ = 'receiverPartyReference'
        elif nodeName_ == 'receiverAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.receiverAccountReference = obj_
            obj_.original_tagname_ = 'receiverAccountReference'
        elif nodeName_ == 'notionalReference':
            obj_ = NotionalReference.factory()
            obj_.build(child_)
            self.notionalReference = obj_
            obj_.original_tagname_ = 'notionalReference'
        elif nodeName_ == 'feeAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'feeAmount')
            self.feeAmount = fval_
        elif nodeName_ == 'feeRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'feeRate')
            self.feeRate = fval_
        elif nodeName_ == 'feePaymentDate':
            class_obj_ = self.get_class_obj_(child_, RelativeDateOffset)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.feePaymentDate = obj_
            obj_.original_tagname_ = 'feePaymentDate'
# end class ExerciseFee


class ExerciseFeeSchedule(GeneratedsSuper):
    """A type to define a fee or schedule of fees to be payable on the
    exercise of an option. This fee may be defined as an amount or a
    percentage of the notional exercised."""
    member_data_items_ = {
        'payerPartyReference': MemberSpec_('payerPartyReference', 'PartyReference', 0),
        'payerAccountReference': MemberSpec_('payerAccountReference', 'AccountReference', 0),
        'receiverPartyReference': MemberSpec_('receiverPartyReference', 'PartyReference', 0),
        'receiverAccountReference': MemberSpec_('receiverAccountReference', 'AccountReference', 0),
        'notionalReference': MemberSpec_('notionalReference', 'ScheduleReference', 0),
        'feeAmountSchedule': MemberSpec_('feeAmountSchedule', 'AmountSchedule', 0),
        'feeRateSchedule': MemberSpec_('feeRateSchedule', 'Schedule', 0),
        'feePaymentDate': MemberSpec_('feePaymentDate', 'RelativeDateOffset', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, notionalReference=None, feeAmountSchedule=None, feeRateSchedule=None, feePaymentDate=None):
        self.original_tagname_ = None
        self.payerPartyReference = payerPartyReference
        self.payerAccountReference = payerAccountReference
        self.receiverPartyReference = receiverPartyReference
        self.receiverAccountReference = receiverAccountReference
        self.notionalReference = notionalReference
        self.feeAmountSchedule = feeAmountSchedule
        self.feeRateSchedule = feeRateSchedule
        self.feePaymentDate = feePaymentDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExerciseFeeSchedule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExerciseFeeSchedule.subclass:
            return ExerciseFeeSchedule.subclass(*args_, **kwargs_)
        else:
            return ExerciseFeeSchedule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_payerPartyReference(self): return self.payerPartyReference
    def set_payerPartyReference(self, payerPartyReference): self.payerPartyReference = payerPartyReference
    def get_payerAccountReference(self): return self.payerAccountReference
    def set_payerAccountReference(self, payerAccountReference): self.payerAccountReference = payerAccountReference
    def get_receiverPartyReference(self): return self.receiverPartyReference
    def set_receiverPartyReference(self, receiverPartyReference): self.receiverPartyReference = receiverPartyReference
    def get_receiverAccountReference(self): return self.receiverAccountReference
    def set_receiverAccountReference(self, receiverAccountReference): self.receiverAccountReference = receiverAccountReference
    def get_notionalReference(self): return self.notionalReference
    def set_notionalReference(self, notionalReference): self.notionalReference = notionalReference
    def get_feeAmountSchedule(self): return self.feeAmountSchedule
    def set_feeAmountSchedule(self, feeAmountSchedule): self.feeAmountSchedule = feeAmountSchedule
    def get_feeRateSchedule(self): return self.feeRateSchedule
    def set_feeRateSchedule(self, feeRateSchedule): self.feeRateSchedule = feeRateSchedule
    def get_feePaymentDate(self): return self.feePaymentDate
    def set_feePaymentDate(self, feePaymentDate): self.feePaymentDate = feePaymentDate
    def hasContent_(self):
        if (
            self.payerPartyReference is not None or
            self.payerAccountReference is not None or
            self.receiverPartyReference is not None or
            self.receiverAccountReference is not None or
            self.notionalReference is not None or
            self.feeAmountSchedule is not None or
            self.feeRateSchedule is not None or
            self.feePaymentDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExerciseFeeSchedule', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExerciseFeeSchedule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExerciseFeeSchedule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExerciseFeeSchedule'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ExerciseFeeSchedule', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.payerPartyReference is not None:
            self.payerPartyReference.export(outfile, level, namespace_, name_='payerPartyReference', pretty_print=pretty_print)
        if self.payerAccountReference is not None:
            self.payerAccountReference.export(outfile, level, namespace_, name_='payerAccountReference', pretty_print=pretty_print)
        if self.receiverPartyReference is not None:
            self.receiverPartyReference.export(outfile, level, namespace_, name_='receiverPartyReference', pretty_print=pretty_print)
        if self.receiverAccountReference is not None:
            self.receiverAccountReference.export(outfile, level, namespace_, name_='receiverAccountReference', pretty_print=pretty_print)
        if self.notionalReference is not None:
            self.notionalReference.export(outfile, level, namespace_, name_='notionalReference', pretty_print=pretty_print)
        if self.feeAmountSchedule is not None:
            self.feeAmountSchedule.export(outfile, level, namespace_, name_='feeAmountSchedule', pretty_print=pretty_print)
        if self.feeRateSchedule is not None:
            self.feeRateSchedule.export(outfile, level, namespace_, name_='feeRateSchedule', pretty_print=pretty_print)
        if self.feePaymentDate is not None:
            self.feePaymentDate.export(outfile, level, namespace_, name_='feePaymentDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'payerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.payerPartyReference = obj_
            obj_.original_tagname_ = 'payerPartyReference'
        elif nodeName_ == 'payerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.payerAccountReference = obj_
            obj_.original_tagname_ = 'payerAccountReference'
        elif nodeName_ == 'receiverPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.receiverPartyReference = obj_
            obj_.original_tagname_ = 'receiverPartyReference'
        elif nodeName_ == 'receiverAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.receiverAccountReference = obj_
            obj_.original_tagname_ = 'receiverAccountReference'
        elif nodeName_ == 'notionalReference':
            obj_ = ScheduleReference.factory()
            obj_.build(child_)
            self.notionalReference = obj_
            obj_.original_tagname_ = 'notionalReference'
        elif nodeName_ == 'feeAmountSchedule':
            obj_ = AmountSchedule.factory()
            obj_.build(child_)
            self.feeAmountSchedule = obj_
            obj_.original_tagname_ = 'feeAmountSchedule'
        elif nodeName_ == 'feeRateSchedule':
            class_obj_ = self.get_class_obj_(child_, Schedule)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.feeRateSchedule = obj_
            obj_.original_tagname_ = 'feeRateSchedule'
        elif nodeName_ == 'feePaymentDate':
            class_obj_ = self.get_class_obj_(child_, RelativeDateOffset)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.feePaymentDate = obj_
            obj_.original_tagname_ = 'feePaymentDate'
# end class ExerciseFeeSchedule


class ExerciseNotice(GeneratedsSuper):
    """A type defining to whom and where notice of execution should be
    given. The partyReference refers to one of the principal parties
    of the trade. If present the exerciseNoticePartyReference refers
    to a party, other than the principal party, to whome notice
    should be given."""
    member_data_items_ = {
        'partyReference': MemberSpec_('partyReference', 'PartyReference', 0),
        'exerciseNoticePartyReference': MemberSpec_('exerciseNoticePartyReference', 'PartyReference', 0),
        'businessCenter': MemberSpec_('businessCenter', 'BusinessCenter', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, partyReference=None, exerciseNoticePartyReference=None, businessCenter=None):
        self.original_tagname_ = None
        self.partyReference = partyReference
        self.exerciseNoticePartyReference = exerciseNoticePartyReference
        self.businessCenter = businessCenter
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExerciseNotice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExerciseNotice.subclass:
            return ExerciseNotice.subclass(*args_, **kwargs_)
        else:
            return ExerciseNotice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyReference(self): return self.partyReference
    def set_partyReference(self, partyReference): self.partyReference = partyReference
    def get_exerciseNoticePartyReference(self): return self.exerciseNoticePartyReference
    def set_exerciseNoticePartyReference(self, exerciseNoticePartyReference): self.exerciseNoticePartyReference = exerciseNoticePartyReference
    def get_businessCenter(self): return self.businessCenter
    def set_businessCenter(self, businessCenter): self.businessCenter = businessCenter
    def hasContent_(self):
        if (
            self.partyReference is not None or
            self.exerciseNoticePartyReference is not None or
            self.businessCenter is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExerciseNotice', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExerciseNotice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExerciseNotice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExerciseNotice'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ExerciseNotice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.partyReference is not None:
            self.partyReference.export(outfile, level, namespace_, name_='partyReference', pretty_print=pretty_print)
        if self.exerciseNoticePartyReference is not None:
            self.exerciseNoticePartyReference.export(outfile, level, namespace_, name_='exerciseNoticePartyReference', pretty_print=pretty_print)
        if self.businessCenter is not None:
            self.businessCenter.export(outfile, level, namespace_, name_='businessCenter', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'partyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.partyReference = obj_
            obj_.original_tagname_ = 'partyReference'
        elif nodeName_ == 'exerciseNoticePartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.exerciseNoticePartyReference = obj_
            obj_.original_tagname_ = 'exerciseNoticePartyReference'
        elif nodeName_ == 'businessCenter':
            obj_ = BusinessCenter.factory()
            obj_.build(child_)
            self.businessCenter = obj_
            obj_.original_tagname_ = 'businessCenter'
# end class ExerciseNotice


class ExerciseProcedure(GeneratedsSuper):
    """A type describing how notice of exercise should be given. This can
    be either manual or automatic."""
    member_data_items_ = {
        'manualExercise': MemberSpec_('manualExercise', 'ManualExercise', 0),
        'automaticExercise': MemberSpec_('automaticExercise', 'AutomaticExercise', 0),
        'followUpConfirmation': MemberSpec_('followUpConfirmation', 'xsd:boolean', 0),
        'limitedRightToConfirm': MemberSpec_('limitedRightToConfirm', 'xsd:boolean', 0),
        'splitTicket': MemberSpec_('splitTicket', 'xsd:boolean', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, manualExercise=None, automaticExercise=None, followUpConfirmation=None, limitedRightToConfirm=None, splitTicket=None):
        self.original_tagname_ = None
        self.manualExercise = manualExercise
        self.automaticExercise = automaticExercise
        self.followUpConfirmation = followUpConfirmation
        self.limitedRightToConfirm = limitedRightToConfirm
        self.splitTicket = splitTicket
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExerciseProcedure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExerciseProcedure.subclass:
            return ExerciseProcedure.subclass(*args_, **kwargs_)
        else:
            return ExerciseProcedure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_manualExercise(self): return self.manualExercise
    def set_manualExercise(self, manualExercise): self.manualExercise = manualExercise
    def get_automaticExercise(self): return self.automaticExercise
    def set_automaticExercise(self, automaticExercise): self.automaticExercise = automaticExercise
    def get_followUpConfirmation(self): return self.followUpConfirmation
    def set_followUpConfirmation(self, followUpConfirmation): self.followUpConfirmation = followUpConfirmation
    def get_limitedRightToConfirm(self): return self.limitedRightToConfirm
    def set_limitedRightToConfirm(self, limitedRightToConfirm): self.limitedRightToConfirm = limitedRightToConfirm
    def get_splitTicket(self): return self.splitTicket
    def set_splitTicket(self, splitTicket): self.splitTicket = splitTicket
    def hasContent_(self):
        if (
            self.manualExercise is not None or
            self.automaticExercise is not None or
            self.followUpConfirmation is not None or
            self.limitedRightToConfirm is not None or
            self.splitTicket is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExerciseProcedure', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExerciseProcedure')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExerciseProcedure', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExerciseProcedure'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ExerciseProcedure', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.manualExercise is not None:
            self.manualExercise.export(outfile, level, namespace_, name_='manualExercise', pretty_print=pretty_print)
        if self.automaticExercise is not None:
            self.automaticExercise.export(outfile, level, namespace_, name_='automaticExercise', pretty_print=pretty_print)
        if self.followUpConfirmation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfollowUpConfirmation>%s</%sfollowUpConfirmation>%s' % (namespace_, self.gds_format_boolean(self.followUpConfirmation, input_name='followUpConfirmation'), namespace_, eol_))
        if self.limitedRightToConfirm is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slimitedRightToConfirm>%s</%slimitedRightToConfirm>%s' % (namespace_, self.gds_format_boolean(self.limitedRightToConfirm, input_name='limitedRightToConfirm'), namespace_, eol_))
        if self.splitTicket is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssplitTicket>%s</%ssplitTicket>%s' % (namespace_, self.gds_format_boolean(self.splitTicket, input_name='splitTicket'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'manualExercise':
            obj_ = ManualExercise.factory()
            obj_.build(child_)
            self.manualExercise = obj_
            obj_.original_tagname_ = 'manualExercise'
        elif nodeName_ == 'automaticExercise':
            obj_ = AutomaticExercise.factory()
            obj_.build(child_)
            self.automaticExercise = obj_
            obj_.original_tagname_ = 'automaticExercise'
        elif nodeName_ == 'followUpConfirmation':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'followUpConfirmation')
            self.followUpConfirmation = ival_
        elif nodeName_ == 'limitedRightToConfirm':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'limitedRightToConfirm')
            self.limitedRightToConfirm = ival_
        elif nodeName_ == 'splitTicket':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'splitTicket')
            self.splitTicket = ival_
# end class ExerciseProcedure


class ExerciseProcedureOption(GeneratedsSuper):
    """A type describing how notice of exercise should be given. This can
    be either manual or automatic."""
    member_data_items_ = {
        'manualExercise': MemberSpec_('manualExercise', 'Empty', 0),
        'automaticExercise': MemberSpec_('automaticExercise', 'Empty', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, manualExercise=None, automaticExercise=None):
        self.original_tagname_ = None
        self.manualExercise = manualExercise
        self.automaticExercise = automaticExercise
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExerciseProcedureOption)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExerciseProcedureOption.subclass:
            return ExerciseProcedureOption.subclass(*args_, **kwargs_)
        else:
            return ExerciseProcedureOption(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_manualExercise(self): return self.manualExercise
    def set_manualExercise(self, manualExercise): self.manualExercise = manualExercise
    def get_automaticExercise(self): return self.automaticExercise
    def set_automaticExercise(self, automaticExercise): self.automaticExercise = automaticExercise
    def hasContent_(self):
        if (
            self.manualExercise is not None or
            self.automaticExercise is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExerciseProcedureOption', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExerciseProcedureOption')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExerciseProcedureOption', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExerciseProcedureOption'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ExerciseProcedureOption', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.manualExercise is not None:
            self.manualExercise.export(outfile, level, namespace_, name_='manualExercise', pretty_print=pretty_print)
        if self.automaticExercise is not None:
            self.automaticExercise.export(outfile, level, namespace_, name_='automaticExercise', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'manualExercise':
            obj_ = Empty.factory()
            obj_.build(child_)
            self.manualExercise = obj_
            obj_.original_tagname_ = 'manualExercise'
        elif nodeName_ == 'automaticExercise':
            obj_ = Empty.factory()
            obj_.build(child_)
            self.automaticExercise = obj_
            obj_.original_tagname_ = 'automaticExercise'
# end class ExerciseProcedureOption


class FloatingRateIndex(GeneratedsSuper):
    """The ISDA Floating Rate Option, i.e. the floating rate index."""
    member_data_items_ = {
        'floatingRateIndexScheme': MemberSpec_('floatingRateIndexScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, floatingRateIndexScheme='http://www.fpml.org/coding-scheme/floating-rate-index', valueOf_=None):
        self.original_tagname_ = None
        self.floatingRateIndexScheme = _cast(None, floatingRateIndexScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FloatingRateIndex)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FloatingRateIndex.subclass:
            return FloatingRateIndex.subclass(*args_, **kwargs_)
        else:
            return FloatingRateIndex(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_floatingRateIndexScheme(self): return self.floatingRateIndexScheme
    def set_floatingRateIndexScheme(self, floatingRateIndexScheme): self.floatingRateIndexScheme = floatingRateIndexScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FloatingRateIndex', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FloatingRateIndex')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FloatingRateIndex', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FloatingRateIndex'):
        if self.floatingRateIndexScheme != "http://www.fpml.org/coding-scheme/floating-rate-index" and 'floatingRateIndexScheme' not in already_processed:
            already_processed.add('floatingRateIndexScheme')
            outfile.write(' floatingRateIndexScheme=%s' % (quote_attrib(self.floatingRateIndexScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='FloatingRateIndex', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('floatingRateIndexScheme', node)
        if value is not None and 'floatingRateIndexScheme' not in already_processed:
            already_processed.add('floatingRateIndexScheme')
            self.floatingRateIndexScheme = value
            self.validate_NonEmptyURI(self.floatingRateIndexScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FloatingRateIndex


class ForecastRateIndex(GeneratedsSuper):
    """A type defining a rate index."""
    member_data_items_ = {
        'floatingRateIndex': MemberSpec_('floatingRateIndex', 'FloatingRateIndex', 0),
        'indexTenor': MemberSpec_('indexTenor', 'Period', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, floatingRateIndex=None, indexTenor=None):
        self.original_tagname_ = None
        self.floatingRateIndex = floatingRateIndex
        self.indexTenor = indexTenor
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ForecastRateIndex)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ForecastRateIndex.subclass:
            return ForecastRateIndex.subclass(*args_, **kwargs_)
        else:
            return ForecastRateIndex(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_floatingRateIndex(self): return self.floatingRateIndex
    def set_floatingRateIndex(self, floatingRateIndex): self.floatingRateIndex = floatingRateIndex
    def get_indexTenor(self): return self.indexTenor
    def set_indexTenor(self, indexTenor): self.indexTenor = indexTenor
    def hasContent_(self):
        if (
            self.floatingRateIndex is not None or
            self.indexTenor is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ForecastRateIndex', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ForecastRateIndex')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ForecastRateIndex', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ForecastRateIndex'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ForecastRateIndex', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.floatingRateIndex is not None:
            self.floatingRateIndex.export(outfile, level, namespace_, name_='floatingRateIndex', pretty_print=pretty_print)
        if self.indexTenor is not None:
            self.indexTenor.export(outfile, level, namespace_, name_='indexTenor', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'floatingRateIndex':
            obj_ = FloatingRateIndex.factory()
            obj_.build(child_)
            self.floatingRateIndex = obj_
            obj_.original_tagname_ = 'floatingRateIndex'
        elif nodeName_ == 'indexTenor':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.indexTenor = obj_
            obj_.original_tagname_ = 'indexTenor'
# end class ForecastRateIndex


class Formula(GeneratedsSuper):
    """A type describing a financial formula, with its description and
    components."""
    member_data_items_ = {
        'formulaDescription': MemberSpec_('formulaDescription', ['String', 'xsd:string'], 0),
        'math': MemberSpec_('math', 'Math', 0),
        'formulaComponent': MemberSpec_('formulaComponent', 'FormulaComponent', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, formulaDescription=None, math=None, formulaComponent=None):
        self.original_tagname_ = None
        self.formulaDescription = formulaDescription
        self.validate_String(self.formulaDescription)
        self.math = math
        if formulaComponent is None:
            self.formulaComponent = []
        else:
            self.formulaComponent = formulaComponent
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Formula)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Formula.subclass:
            return Formula.subclass(*args_, **kwargs_)
        else:
            return Formula(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_formulaDescription(self): return self.formulaDescription
    def set_formulaDescription(self, formulaDescription): self.formulaDescription = formulaDescription
    def get_math(self): return self.math
    def set_math(self, math): self.math = math
    def get_formulaComponent(self): return self.formulaComponent
    def set_formulaComponent(self, formulaComponent): self.formulaComponent = formulaComponent
    def add_formulaComponent(self, value): self.formulaComponent.append(value)
    def insert_formulaComponent_at(self, index, value): self.formulaComponent.insert(index, value)
    def replace_formulaComponent_at(self, index, value): self.formulaComponent[index] = value
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.formulaDescription is not None or
            self.math is not None or
            self.formulaComponent
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Formula', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Formula')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Formula', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Formula'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Formula', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.formulaDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sformulaDescription>%s</%sformulaDescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.formulaDescription), input_name='formulaDescription')), namespace_, eol_))
        if self.math is not None:
            self.math.export(outfile, level, namespace_, name_='math', pretty_print=pretty_print)
        for formulaComponent_ in self.formulaComponent:
            formulaComponent_.export(outfile, level, namespace_, name_='formulaComponent', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'formulaDescription':
            formulaDescription_ = child_.text
            formulaDescription_ = self.gds_validate_string(formulaDescription_, node, 'formulaDescription')
            self.formulaDescription = formulaDescription_
            # validate type String
            self.validate_String(self.formulaDescription)
        elif nodeName_ == 'math':
            obj_ = Math.factory()
            obj_.build(child_)
            self.math = obj_
            obj_.original_tagname_ = 'math'
        elif nodeName_ == 'formulaComponent':
            obj_ = FormulaComponent.factory()
            obj_.build(child_)
            self.formulaComponent.append(obj_)
            obj_.original_tagname_ = 'formulaComponent'
# end class Formula


class FormulaComponent(GeneratedsSuper):
    """Elements describing the components of the formula. The name
    attribute points to a value used in the math element. The href
    attribute points to a numeric value defined elsewhere in the
    document that is used by the formula component."""
    member_data_items_ = {
        'name': MemberSpec_('name', 'NormalizedString', 0),
        'componentDescription': MemberSpec_('componentDescription', ['String', 'xsd:string'], 0),
        'formula': MemberSpec_('formula', 'Formula', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, name=None, componentDescription=None, formula=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.componentDescription = componentDescription
        self.validate_String(self.componentDescription)
        self.formula = formula
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FormulaComponent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FormulaComponent.subclass:
            return FormulaComponent.subclass(*args_, **kwargs_)
        else:
            return FormulaComponent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_componentDescription(self): return self.componentDescription
    def set_componentDescription(self, componentDescription): self.componentDescription = componentDescription
    def get_formula(self): return self.formula
    def set_formula(self, formula): self.formula = formula
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def validate_NormalizedString(self, value):
        # Validate type NormalizedString, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NormalizedString' % {"value" : value} )
    def hasContent_(self):
        if (
            self.componentDescription is not None or
            self.formula is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FormulaComponent', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FormulaComponent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FormulaComponent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FormulaComponent'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (quote_attrib(self.name), ))
    def exportChildren(self, outfile, level, namespace_='', name_='FormulaComponent', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.componentDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomponentDescription>%s</%scomponentDescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.componentDescription), input_name='componentDescription')), namespace_, eol_))
        if self.formula is not None:
            self.formula.export(outfile, level, namespace_, name_='formula', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_NormalizedString(self.name)    # validate type NormalizedString
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'componentDescription':
            componentDescription_ = child_.text
            componentDescription_ = self.gds_validate_string(componentDescription_, node, 'componentDescription')
            self.componentDescription = componentDescription_
            # validate type String
            self.validate_String(self.componentDescription)
        elif nodeName_ == 'formula':
            obj_ = Formula.factory()
            obj_.build(child_)
            self.formula = obj_
            obj_.original_tagname_ = 'formula'
# end class FormulaComponent


class Frequency(GeneratedsSuper):
    """A type defining a time frequency, e.g. one day, three months. Used
    for specifying payment or calculation frequencies at which the
    value T (Term) is applicable."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'periodMultiplier': MemberSpec_('periodMultiplier', 'xsd:positiveInteger', 0),
        'period': MemberSpec_('period', ['PeriodExtendedEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, periodMultiplier=None, period=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.periodMultiplier = periodMultiplier
        self.period = period
        self.validate_PeriodExtendedEnum(self.period)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Frequency)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Frequency.subclass:
            return Frequency.subclass(*args_, **kwargs_)
        else:
            return Frequency(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_periodMultiplier(self): return self.periodMultiplier
    def set_periodMultiplier(self, periodMultiplier): self.periodMultiplier = periodMultiplier
    def get_period(self): return self.period
    def set_period(self, period): self.period = period
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_PeriodExtendedEnum(self, value):
        # Validate type PeriodExtendedEnum, a restriction on Token.
        pass
    def hasContent_(self):
        if (
            self.periodMultiplier is not None or
            self.period is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Frequency', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Frequency')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Frequency', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Frequency'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Frequency', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.periodMultiplier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%speriodMultiplier>%s</%speriodMultiplier>%s' % (namespace_, self.gds_format_integer(self.periodMultiplier, input_name='periodMultiplier'), namespace_, eol_))
        if self.period is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%speriod>%s</%speriod>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.period), input_name='period')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'periodMultiplier':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'periodMultiplier')
            self.periodMultiplier = ival_
        elif nodeName_ == 'period':
            period_ = child_.text
            period_ = re_.sub(String_cleanup_pat_, " ", period_).strip()
            period_ = self.gds_validate_string(period_, node, 'period')
            self.period = period_
            # validate type PeriodExtendedEnum
            self.validate_PeriodExtendedEnum(self.period)
# end class Frequency


class FxCashSettlement(GeneratedsSuper):
    """A type that is used for describing cash settlement of an option /
    non deliverable forward. It includes the currency to settle into
    together with the fixings required to calculate the currency
    amount."""
    member_data_items_ = {
        'settlementCurrency': MemberSpec_('settlementCurrency', 'Currency', 0),
        'referenceCurrency': MemberSpec_('referenceCurrency', 'Currency', 0),
        'notionalAmount': MemberSpec_('notionalAmount', 'PositiveMoney', 0),
        'fixing': MemberSpec_('fixing', 'FxFixing', 1),
        'rateSourceFixing': MemberSpec_('rateSourceFixing', 'FxRateSourceFixing', 1),
        'settlementDate': MemberSpec_('settlementDate', 'AdjustableDate', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, settlementCurrency=None, referenceCurrency=None, notionalAmount=None, fixing=None, rateSourceFixing=None, settlementDate=None):
        self.original_tagname_ = None
        self.settlementCurrency = settlementCurrency
        self.referenceCurrency = referenceCurrency
        self.notionalAmount = notionalAmount
        if fixing is None:
            self.fixing = []
        else:
            self.fixing = fixing
        if rateSourceFixing is None:
            self.rateSourceFixing = []
        else:
            self.rateSourceFixing = rateSourceFixing
        self.settlementDate = settlementDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FxCashSettlement)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FxCashSettlement.subclass:
            return FxCashSettlement.subclass(*args_, **kwargs_)
        else:
            return FxCashSettlement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_settlementCurrency(self): return self.settlementCurrency
    def set_settlementCurrency(self, settlementCurrency): self.settlementCurrency = settlementCurrency
    def get_referenceCurrency(self): return self.referenceCurrency
    def set_referenceCurrency(self, referenceCurrency): self.referenceCurrency = referenceCurrency
    def get_notionalAmount(self): return self.notionalAmount
    def set_notionalAmount(self, notionalAmount): self.notionalAmount = notionalAmount
    def get_fixing(self): return self.fixing
    def set_fixing(self, fixing): self.fixing = fixing
    def add_fixing(self, value): self.fixing.append(value)
    def insert_fixing_at(self, index, value): self.fixing.insert(index, value)
    def replace_fixing_at(self, index, value): self.fixing[index] = value
    def get_rateSourceFixing(self): return self.rateSourceFixing
    def set_rateSourceFixing(self, rateSourceFixing): self.rateSourceFixing = rateSourceFixing
    def add_rateSourceFixing(self, value): self.rateSourceFixing.append(value)
    def insert_rateSourceFixing_at(self, index, value): self.rateSourceFixing.insert(index, value)
    def replace_rateSourceFixing_at(self, index, value): self.rateSourceFixing[index] = value
    def get_settlementDate(self): return self.settlementDate
    def set_settlementDate(self, settlementDate): self.settlementDate = settlementDate
    def hasContent_(self):
        if (
            self.settlementCurrency is not None or
            self.referenceCurrency is not None or
            self.notionalAmount is not None or
            self.fixing or
            self.rateSourceFixing or
            self.settlementDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FxCashSettlement', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FxCashSettlement')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FxCashSettlement', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FxCashSettlement'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FxCashSettlement', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.settlementCurrency is not None:
            self.settlementCurrency.export(outfile, level, namespace_, name_='settlementCurrency', pretty_print=pretty_print)
        if self.referenceCurrency is not None:
            self.referenceCurrency.export(outfile, level, namespace_, name_='referenceCurrency', pretty_print=pretty_print)
        if self.notionalAmount is not None:
            self.notionalAmount.export(outfile, level, namespace_, name_='notionalAmount', pretty_print=pretty_print)
        for fixing_ in self.fixing:
            fixing_.export(outfile, level, namespace_, name_='fixing', pretty_print=pretty_print)
        for rateSourceFixing_ in self.rateSourceFixing:
            rateSourceFixing_.export(outfile, level, namespace_, name_='rateSourceFixing', pretty_print=pretty_print)
        if self.settlementDate is not None:
            self.settlementDate.export(outfile, level, namespace_, name_='settlementDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'settlementCurrency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.settlementCurrency = obj_
            obj_.original_tagname_ = 'settlementCurrency'
        elif nodeName_ == 'referenceCurrency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.referenceCurrency = obj_
            obj_.original_tagname_ = 'referenceCurrency'
        elif nodeName_ == 'notionalAmount':
            obj_ = PositiveMoney.factory()
            obj_.build(child_)
            self.notionalAmount = obj_
            obj_.original_tagname_ = 'notionalAmount'
        elif nodeName_ == 'fixing':
            obj_ = FxFixing.factory()
            obj_.build(child_)
            self.fixing.append(obj_)
            obj_.original_tagname_ = 'fixing'
        elif nodeName_ == 'rateSourceFixing':
            obj_ = FxRateSourceFixing.factory()
            obj_.build(child_)
            self.rateSourceFixing.append(obj_)
            obj_.original_tagname_ = 'rateSourceFixing'
        elif nodeName_ == 'settlementDate':
            obj_ = AdjustableDate.factory()
            obj_.build(child_)
            self.settlementDate = obj_
            obj_.original_tagname_ = 'settlementDate'
# end class FxCashSettlement


class FxCashSettlementSimple(GeneratedsSuper):
    """A type that is used for describing cash settlement of a variance or
    volatility swap option. It includes the settlement currency
    together with the spot currency exchange required to calculate
    the settlement currency amount."""
    member_data_items_ = {
        'settlementCurrency': MemberSpec_('settlementCurrency', 'Currency', 0),
        'referenceCurrency': MemberSpec_('referenceCurrency', 'Currency', 0),
        'fixing': MemberSpec_('fixing', 'FxFixing', 1),
        'rateSourceFixing': MemberSpec_('rateSourceFixing', 'FxRateSourceFixing', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, settlementCurrency=None, referenceCurrency=None, fixing=None, rateSourceFixing=None):
        self.original_tagname_ = None
        self.settlementCurrency = settlementCurrency
        self.referenceCurrency = referenceCurrency
        if fixing is None:
            self.fixing = []
        else:
            self.fixing = fixing
        if rateSourceFixing is None:
            self.rateSourceFixing = []
        else:
            self.rateSourceFixing = rateSourceFixing
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FxCashSettlementSimple)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FxCashSettlementSimple.subclass:
            return FxCashSettlementSimple.subclass(*args_, **kwargs_)
        else:
            return FxCashSettlementSimple(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_settlementCurrency(self): return self.settlementCurrency
    def set_settlementCurrency(self, settlementCurrency): self.settlementCurrency = settlementCurrency
    def get_referenceCurrency(self): return self.referenceCurrency
    def set_referenceCurrency(self, referenceCurrency): self.referenceCurrency = referenceCurrency
    def get_fixing(self): return self.fixing
    def set_fixing(self, fixing): self.fixing = fixing
    def add_fixing(self, value): self.fixing.append(value)
    def insert_fixing_at(self, index, value): self.fixing.insert(index, value)
    def replace_fixing_at(self, index, value): self.fixing[index] = value
    def get_rateSourceFixing(self): return self.rateSourceFixing
    def set_rateSourceFixing(self, rateSourceFixing): self.rateSourceFixing = rateSourceFixing
    def add_rateSourceFixing(self, value): self.rateSourceFixing.append(value)
    def insert_rateSourceFixing_at(self, index, value): self.rateSourceFixing.insert(index, value)
    def replace_rateSourceFixing_at(self, index, value): self.rateSourceFixing[index] = value
    def hasContent_(self):
        if (
            self.settlementCurrency is not None or
            self.referenceCurrency is not None or
            self.fixing or
            self.rateSourceFixing
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FxCashSettlementSimple', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FxCashSettlementSimple')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FxCashSettlementSimple', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FxCashSettlementSimple'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FxCashSettlementSimple', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.settlementCurrency is not None:
            self.settlementCurrency.export(outfile, level, namespace_, name_='settlementCurrency', pretty_print=pretty_print)
        if self.referenceCurrency is not None:
            self.referenceCurrency.export(outfile, level, namespace_, name_='referenceCurrency', pretty_print=pretty_print)
        for fixing_ in self.fixing:
            fixing_.export(outfile, level, namespace_, name_='fixing', pretty_print=pretty_print)
        for rateSourceFixing_ in self.rateSourceFixing:
            rateSourceFixing_.export(outfile, level, namespace_, name_='rateSourceFixing', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'settlementCurrency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.settlementCurrency = obj_
            obj_.original_tagname_ = 'settlementCurrency'
        elif nodeName_ == 'referenceCurrency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.referenceCurrency = obj_
            obj_.original_tagname_ = 'referenceCurrency'
        elif nodeName_ == 'fixing':
            obj_ = FxFixing.factory()
            obj_.build(child_)
            self.fixing.append(obj_)
            obj_.original_tagname_ = 'fixing'
        elif nodeName_ == 'rateSourceFixing':
            obj_ = FxRateSourceFixing.factory()
            obj_.build(child_)
            self.rateSourceFixing.append(obj_)
            obj_.original_tagname_ = 'rateSourceFixing'
# end class FxCashSettlementSimple


class FxFixing(GeneratedsSuper):
    """A type that specifies the source for and timing of a fixing of an
    exchange rate. This is used in the agreement of non-deliverable
    forward trades as well as various types of FX OTC options that
    require observations against a particular rate."""
    member_data_items_ = {
        'quotedCurrencyPair': MemberSpec_('quotedCurrencyPair', 'QuotedCurrencyPair', 0),
        'fixingDate': MemberSpec_('fixingDate', 'xsd:date', 0),
        'fxSpotRateSource': MemberSpec_('fxSpotRateSource', 'FxSpotRateSource', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, quotedCurrencyPair=None, fixingDate=None, fxSpotRateSource=None):
        self.original_tagname_ = None
        self.quotedCurrencyPair = quotedCurrencyPair
        if isinstance(fixingDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(fixingDate, '%Y-%m-%d').date()
        else:
            initvalue_ = fixingDate
        self.fixingDate = initvalue_
        self.fxSpotRateSource = fxSpotRateSource
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FxFixing)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FxFixing.subclass:
            return FxFixing.subclass(*args_, **kwargs_)
        else:
            return FxFixing(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_quotedCurrencyPair(self): return self.quotedCurrencyPair
    def set_quotedCurrencyPair(self, quotedCurrencyPair): self.quotedCurrencyPair = quotedCurrencyPair
    def get_fixingDate(self): return self.fixingDate
    def set_fixingDate(self, fixingDate): self.fixingDate = fixingDate
    def get_fxSpotRateSource(self): return self.fxSpotRateSource
    def set_fxSpotRateSource(self, fxSpotRateSource): self.fxSpotRateSource = fxSpotRateSource
    def hasContent_(self):
        if (
            self.quotedCurrencyPair is not None or
            self.fixingDate is not None or
            self.fxSpotRateSource is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FxFixing', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FxFixing')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FxFixing', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FxFixing'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FxFixing', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.quotedCurrencyPair is not None:
            self.quotedCurrencyPair.export(outfile, level, namespace_, name_='quotedCurrencyPair', pretty_print=pretty_print)
        if self.fixingDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfixingDate>%s</%sfixingDate>%s' % (namespace_, self.gds_format_date(self.fixingDate, input_name='fixingDate'), namespace_, eol_))
        if self.fxSpotRateSource is not None:
            self.fxSpotRateSource.export(outfile, level, namespace_, name_='fxSpotRateSource', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'quotedCurrencyPair':
            obj_ = QuotedCurrencyPair.factory()
            obj_.build(child_)
            self.quotedCurrencyPair = obj_
            obj_.original_tagname_ = 'quotedCurrencyPair'
        elif nodeName_ == 'fixingDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.fixingDate = dval_
        elif nodeName_ == 'fxSpotRateSource':
            obj_ = FxSpotRateSource.factory()
            obj_.build(child_)
            self.fxSpotRateSource = obj_
            obj_.original_tagname_ = 'fxSpotRateSource'
# end class FxFixing


class FxRate(GeneratedsSuper):
    """A type describing the rate of a currency conversion: pair of
    currency, quotation mode and exchange rate."""
    member_data_items_ = {
        'quotedCurrencyPair': MemberSpec_('quotedCurrencyPair', 'QuotedCurrencyPair', 0),
        'rate': MemberSpec_('rate', 'xsd:decimal', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, quotedCurrencyPair=None, rate=None):
        self.original_tagname_ = None
        self.quotedCurrencyPair = quotedCurrencyPair
        self.rate = rate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FxRate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FxRate.subclass:
            return FxRate.subclass(*args_, **kwargs_)
        else:
            return FxRate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_quotedCurrencyPair(self): return self.quotedCurrencyPair
    def set_quotedCurrencyPair(self, quotedCurrencyPair): self.quotedCurrencyPair = quotedCurrencyPair
    def get_rate(self): return self.rate
    def set_rate(self, rate): self.rate = rate
    def hasContent_(self):
        if (
            self.quotedCurrencyPair is not None or
            self.rate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FxRate', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FxRate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FxRate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FxRate'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FxRate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.quotedCurrencyPair is not None:
            self.quotedCurrencyPair.export(outfile, level, namespace_, name_='quotedCurrencyPair', pretty_print=pretty_print)
        if self.rate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srate>%s</%srate>%s' % (namespace_, self.gds_format_float(self.rate, input_name='rate'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'quotedCurrencyPair':
            obj_ = QuotedCurrencyPair.factory()
            obj_.build(child_)
            self.quotedCurrencyPair = obj_
            obj_.original_tagname_ = 'quotedCurrencyPair'
        elif nodeName_ == 'rate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'rate')
            self.rate = fval_
# end class FxRate


class FxRateSourceFixing(GeneratedsSuper):
    """Describes a rate source to be fixed and the date the fixing occurs"""
    member_data_items_ = {
        'settlementRateSource': MemberSpec_('settlementRateSource', 'FxSettlementRateSource', 0),
        'fixingDate': MemberSpec_('fixingDate', 'AdjustableDate', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, settlementRateSource=None, fixingDate=None):
        self.original_tagname_ = None
        self.settlementRateSource = settlementRateSource
        self.fixingDate = fixingDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FxRateSourceFixing)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FxRateSourceFixing.subclass:
            return FxRateSourceFixing.subclass(*args_, **kwargs_)
        else:
            return FxRateSourceFixing(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_settlementRateSource(self): return self.settlementRateSource
    def set_settlementRateSource(self, settlementRateSource): self.settlementRateSource = settlementRateSource
    def get_fixingDate(self): return self.fixingDate
    def set_fixingDate(self, fixingDate): self.fixingDate = fixingDate
    def hasContent_(self):
        if (
            self.settlementRateSource is not None or
            self.fixingDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FxRateSourceFixing', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FxRateSourceFixing')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FxRateSourceFixing', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FxRateSourceFixing'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FxRateSourceFixing', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.settlementRateSource is not None:
            self.settlementRateSource.export(outfile, level, namespace_, name_='settlementRateSource', pretty_print=pretty_print)
        if self.fixingDate is not None:
            self.fixingDate.export(outfile, level, namespace_, name_='fixingDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'settlementRateSource':
            obj_ = FxSettlementRateSource.factory()
            obj_.build(child_)
            self.settlementRateSource = obj_
            obj_.original_tagname_ = 'settlementRateSource'
        elif nodeName_ == 'fixingDate':
            obj_ = AdjustableDate.factory()
            obj_.build(child_)
            self.fixingDate = obj_
            obj_.original_tagname_ = 'fixingDate'
# end class FxRateSourceFixing


class FxSettlementRateSource(GeneratedsSuper):
    member_data_items_ = {
        'settlementRateOption': MemberSpec_('settlementRateOption', 'SettlementRateOption', 0),
        'nonstandardSettlementRate': MemberSpec_('nonstandardSettlementRate', 'FxInformationSource', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, settlementRateOption=None, nonstandardSettlementRate=None):
        self.original_tagname_ = None
        self.settlementRateOption = settlementRateOption
        self.nonstandardSettlementRate = nonstandardSettlementRate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FxSettlementRateSource)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FxSettlementRateSource.subclass:
            return FxSettlementRateSource.subclass(*args_, **kwargs_)
        else:
            return FxSettlementRateSource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_settlementRateOption(self): return self.settlementRateOption
    def set_settlementRateOption(self, settlementRateOption): self.settlementRateOption = settlementRateOption
    def get_nonstandardSettlementRate(self): return self.nonstandardSettlementRate
    def set_nonstandardSettlementRate(self, nonstandardSettlementRate): self.nonstandardSettlementRate = nonstandardSettlementRate
    def hasContent_(self):
        if (
            self.settlementRateOption is not None or
            self.nonstandardSettlementRate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FxSettlementRateSource', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FxSettlementRateSource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FxSettlementRateSource', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FxSettlementRateSource'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FxSettlementRateSource', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.settlementRateOption is not None:
            self.settlementRateOption.export(outfile, level, namespace_, name_='settlementRateOption', pretty_print=pretty_print)
        if self.nonstandardSettlementRate is not None:
            self.nonstandardSettlementRate.export(outfile, level, namespace_, name_='nonstandardSettlementRate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'settlementRateOption':
            obj_ = SettlementRateOption.factory()
            obj_.build(child_)
            self.settlementRateOption = obj_
            obj_.original_tagname_ = 'settlementRateOption'
        elif nodeName_ == 'nonstandardSettlementRate':
            obj_ = FxInformationSource.factory()
            obj_.build(child_)
            self.nonstandardSettlementRate = obj_
            obj_.original_tagname_ = 'nonstandardSettlementRate'
# end class FxSettlementRateSource


class FxSpotRateSource(GeneratedsSuper):
    """A type defining the rate source and fixing time for an fx rate."""
    member_data_items_ = {
        'primaryRateSource': MemberSpec_('primaryRateSource', 'InformationSource', 0),
        'secondaryRateSource': MemberSpec_('secondaryRateSource', 'InformationSource', 0),
        'fixingTime': MemberSpec_('fixingTime', 'BusinessCenterTime', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, primaryRateSource=None, secondaryRateSource=None, fixingTime=None):
        self.original_tagname_ = None
        self.primaryRateSource = primaryRateSource
        self.secondaryRateSource = secondaryRateSource
        self.fixingTime = fixingTime
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FxSpotRateSource)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FxSpotRateSource.subclass:
            return FxSpotRateSource.subclass(*args_, **kwargs_)
        else:
            return FxSpotRateSource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_primaryRateSource(self): return self.primaryRateSource
    def set_primaryRateSource(self, primaryRateSource): self.primaryRateSource = primaryRateSource
    def get_secondaryRateSource(self): return self.secondaryRateSource
    def set_secondaryRateSource(self, secondaryRateSource): self.secondaryRateSource = secondaryRateSource
    def get_fixingTime(self): return self.fixingTime
    def set_fixingTime(self, fixingTime): self.fixingTime = fixingTime
    def hasContent_(self):
        if (
            self.primaryRateSource is not None or
            self.secondaryRateSource is not None or
            self.fixingTime is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FxSpotRateSource', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FxSpotRateSource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FxSpotRateSource', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FxSpotRateSource'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FxSpotRateSource', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.primaryRateSource is not None:
            self.primaryRateSource.export(outfile, level, namespace_, name_='primaryRateSource', pretty_print=pretty_print)
        if self.secondaryRateSource is not None:
            self.secondaryRateSource.export(outfile, level, namespace_, name_='secondaryRateSource', pretty_print=pretty_print)
        if self.fixingTime is not None:
            self.fixingTime.export(outfile, level, namespace_, name_='fixingTime', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'primaryRateSource':
            class_obj_ = self.get_class_obj_(child_, InformationSource)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.primaryRateSource = obj_
            obj_.original_tagname_ = 'primaryRateSource'
        elif nodeName_ == 'secondaryRateSource':
            class_obj_ = self.get_class_obj_(child_, InformationSource)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.secondaryRateSource = obj_
            obj_.original_tagname_ = 'secondaryRateSource'
        elif nodeName_ == 'fixingTime':
            obj_ = BusinessCenterTime.factory()
            obj_.build(child_)
            self.fixingTime = obj_
            obj_.original_tagname_ = 'fixingTime'
# end class FxSpotRateSource


class GenericAgreement(GeneratedsSuper):
    """An entity for defining a generic agreement executed between two
    parties for any purpose."""
    member_data_items_ = {
        'type_': MemberSpec_('type_', 'AgreementType', 0),
        'version': MemberSpec_('version', 'AgreementVersion', 0),
        'date': MemberSpec_('date', 'xsd:date', 0),
        'amendmentDate': MemberSpec_('amendmentDate', 'xsd:date', 1),
        'governingLaw': MemberSpec_('governingLaw', 'GoverningLaw', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, type_=None, version=None, date=None, amendmentDate=None, governingLaw=None):
        self.original_tagname_ = None
        self.type_ = type_
        self.version = version
        if isinstance(date, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(date, '%Y-%m-%d').date()
        else:
            initvalue_ = date
        self.date = initvalue_
        if amendmentDate is None:
            self.amendmentDate = []
        else:
            self.amendmentDate = amendmentDate
        self.governingLaw = governingLaw
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GenericAgreement)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GenericAgreement.subclass:
            return GenericAgreement.subclass(*args_, **kwargs_)
        else:
            return GenericAgreement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_date(self): return self.date
    def set_date(self, date): self.date = date
    def get_amendmentDate(self): return self.amendmentDate
    def set_amendmentDate(self, amendmentDate): self.amendmentDate = amendmentDate
    def add_amendmentDate(self, value): self.amendmentDate.append(value)
    def insert_amendmentDate_at(self, index, value): self.amendmentDate.insert(index, value)
    def replace_amendmentDate_at(self, index, value): self.amendmentDate[index] = value
    def get_governingLaw(self): return self.governingLaw
    def set_governingLaw(self, governingLaw): self.governingLaw = governingLaw
    def hasContent_(self):
        if (
            self.type_ is not None or
            self.version is not None or
            self.date is not None or
            self.amendmentDate or
            self.governingLaw is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GenericAgreement', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GenericAgreement')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GenericAgreement', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GenericAgreement'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GenericAgreement', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            self.type_.export(outfile, level, namespace_, name_='type', pretty_print=pretty_print)
        if self.version is not None:
            self.version.export(outfile, level, namespace_, name_='version', pretty_print=pretty_print)
        if self.date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdate>%s</%sdate>%s' % (namespace_, self.gds_format_date(self.date, input_name='date'), namespace_, eol_))
        for amendmentDate_ in self.amendmentDate:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%samendmentDate>%s</%samendmentDate>%s' % (namespace_, self.gds_format_date(amendmentDate_, input_name='amendmentDate'), namespace_, eol_))
        if self.governingLaw is not None:
            self.governingLaw.export(outfile, level, namespace_, name_='governingLaw', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            obj_ = AgreementType.factory()
            obj_.build(child_)
            self.type_ = obj_
            obj_.original_tagname_ = 'type'
        elif nodeName_ == 'version':
            obj_ = AgreementVersion.factory()
            obj_.build(child_)
            self.version = obj_
            obj_.original_tagname_ = 'version'
        elif nodeName_ == 'date':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.date = dval_
        elif nodeName_ == 'amendmentDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.amendmentDate.append(dval_)
        elif nodeName_ == 'governingLaw':
            obj_ = GoverningLaw.factory()
            obj_.build(child_)
            self.governingLaw = obj_
            obj_.original_tagname_ = 'governingLaw'
# end class GenericAgreement


class GoverningLaw(GeneratedsSuper):
    """Identification of the law governing the transaction."""
    member_data_items_ = {
        'governingLawScheme': MemberSpec_('governingLawScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, governingLawScheme='http://www.fpml.org/coding-scheme/governing-law', valueOf_=None):
        self.original_tagname_ = None
        self.governingLawScheme = _cast(None, governingLawScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GoverningLaw)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GoverningLaw.subclass:
            return GoverningLaw.subclass(*args_, **kwargs_)
        else:
            return GoverningLaw(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_governingLawScheme(self): return self.governingLawScheme
    def set_governingLawScheme(self, governingLawScheme): self.governingLawScheme = governingLawScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GoverningLaw', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GoverningLaw')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GoverningLaw', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GoverningLaw'):
        if self.governingLawScheme != "http://www.fpml.org/coding-scheme/governing-law" and 'governingLawScheme' not in already_processed:
            already_processed.add('governingLawScheme')
            outfile.write(' governingLawScheme=%s' % (quote_attrib(self.governingLawScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='GoverningLaw', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('governingLawScheme', node)
        if value is not None and 'governingLawScheme' not in already_processed:
            already_processed.add('governingLawScheme')
            self.governingLawScheme = value
            self.validate_NonEmptyURI(self.governingLawScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class GoverningLaw


class GrossCashflow(GeneratedsSuper):
    """A payment component owed from one party to the other for the cash
    flow date. This payment component should by of only a single
    type, e.g. a fee or a cashflow from a cashflow stream."""
    member_data_items_ = {
        'cashflowId': MemberSpec_('cashflowId', 'CashflowId', 0),
        'partyTradeIdentifierReference': MemberSpec_('partyTradeIdentifierReference', 'PartyTradeIdentifierReference', 0),
        'payerPartyReference': MemberSpec_('payerPartyReference', 'PartyReference', 0),
        'payerAccountReference': MemberSpec_('payerAccountReference', 'AccountReference', 0),
        'receiverPartyReference': MemberSpec_('receiverPartyReference', 'PartyReference', 0),
        'receiverAccountReference': MemberSpec_('receiverAccountReference', 'AccountReference', 0),
        'cashflowAmount': MemberSpec_('cashflowAmount', 'Money', 0),
        'cashflowType': MemberSpec_('cashflowType', 'CashflowType', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, cashflowId=None, partyTradeIdentifierReference=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, cashflowAmount=None, cashflowType=None):
        self.original_tagname_ = None
        self.cashflowId = cashflowId
        self.partyTradeIdentifierReference = partyTradeIdentifierReference
        self.payerPartyReference = payerPartyReference
        self.payerAccountReference = payerAccountReference
        self.receiverPartyReference = receiverPartyReference
        self.receiverAccountReference = receiverAccountReference
        self.cashflowAmount = cashflowAmount
        self.cashflowType = cashflowType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GrossCashflow)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GrossCashflow.subclass:
            return GrossCashflow.subclass(*args_, **kwargs_)
        else:
            return GrossCashflow(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cashflowId(self): return self.cashflowId
    def set_cashflowId(self, cashflowId): self.cashflowId = cashflowId
    def get_partyTradeIdentifierReference(self): return self.partyTradeIdentifierReference
    def set_partyTradeIdentifierReference(self, partyTradeIdentifierReference): self.partyTradeIdentifierReference = partyTradeIdentifierReference
    def get_payerPartyReference(self): return self.payerPartyReference
    def set_payerPartyReference(self, payerPartyReference): self.payerPartyReference = payerPartyReference
    def get_payerAccountReference(self): return self.payerAccountReference
    def set_payerAccountReference(self, payerAccountReference): self.payerAccountReference = payerAccountReference
    def get_receiverPartyReference(self): return self.receiverPartyReference
    def set_receiverPartyReference(self, receiverPartyReference): self.receiverPartyReference = receiverPartyReference
    def get_receiverAccountReference(self): return self.receiverAccountReference
    def set_receiverAccountReference(self, receiverAccountReference): self.receiverAccountReference = receiverAccountReference
    def get_cashflowAmount(self): return self.cashflowAmount
    def set_cashflowAmount(self, cashflowAmount): self.cashflowAmount = cashflowAmount
    def get_cashflowType(self): return self.cashflowType
    def set_cashflowType(self, cashflowType): self.cashflowType = cashflowType
    def hasContent_(self):
        if (
            self.cashflowId is not None or
            self.partyTradeIdentifierReference is not None or
            self.payerPartyReference is not None or
            self.payerAccountReference is not None or
            self.receiverPartyReference is not None or
            self.receiverAccountReference is not None or
            self.cashflowAmount is not None or
            self.cashflowType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GrossCashflow', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GrossCashflow')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GrossCashflow', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GrossCashflow'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GrossCashflow', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cashflowId is not None:
            self.cashflowId.export(outfile, level, namespace_, name_='cashflowId', pretty_print=pretty_print)
        if self.partyTradeIdentifierReference is not None:
            self.partyTradeIdentifierReference.export(outfile, level, namespace_, name_='partyTradeIdentifierReference', pretty_print=pretty_print)
        if self.payerPartyReference is not None:
            self.payerPartyReference.export(outfile, level, namespace_, name_='payerPartyReference', pretty_print=pretty_print)
        if self.payerAccountReference is not None:
            self.payerAccountReference.export(outfile, level, namespace_, name_='payerAccountReference', pretty_print=pretty_print)
        if self.receiverPartyReference is not None:
            self.receiverPartyReference.export(outfile, level, namespace_, name_='receiverPartyReference', pretty_print=pretty_print)
        if self.receiverAccountReference is not None:
            self.receiverAccountReference.export(outfile, level, namespace_, name_='receiverAccountReference', pretty_print=pretty_print)
        if self.cashflowAmount is not None:
            self.cashflowAmount.export(outfile, level, namespace_, name_='cashflowAmount', pretty_print=pretty_print)
        if self.cashflowType is not None:
            self.cashflowType.export(outfile, level, namespace_, name_='cashflowType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cashflowId':
            obj_ = CashflowId.factory()
            obj_.build(child_)
            self.cashflowId = obj_
            obj_.original_tagname_ = 'cashflowId'
        elif nodeName_ == 'partyTradeIdentifierReference':
            obj_ = PartyTradeIdentifierReference.factory()
            obj_.build(child_)
            self.partyTradeIdentifierReference = obj_
            obj_.original_tagname_ = 'partyTradeIdentifierReference'
        elif nodeName_ == 'payerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.payerPartyReference = obj_
            obj_.original_tagname_ = 'payerPartyReference'
        elif nodeName_ == 'payerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.payerAccountReference = obj_
            obj_.original_tagname_ = 'payerAccountReference'
        elif nodeName_ == 'receiverPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.receiverPartyReference = obj_
            obj_.original_tagname_ = 'receiverPartyReference'
        elif nodeName_ == 'receiverAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.receiverAccountReference = obj_
            obj_.original_tagname_ = 'receiverAccountReference'
        elif nodeName_ == 'cashflowAmount':
            class_obj_ = self.get_class_obj_(child_, Money)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.cashflowAmount = obj_
            obj_.original_tagname_ = 'cashflowAmount'
        elif nodeName_ == 'cashflowType':
            obj_ = CashflowType.factory()
            obj_.build(child_)
            self.cashflowType = obj_
            obj_.original_tagname_ = 'cashflowType'
# end class GrossCashflow


class IdentifiedCurrency(Currency):
    """Specifies Currency with ID attribute."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'valueOf_': MemberSpec_('valueOf_', 'Currency', 0),
    }
    subclass = None
    superclass = Currency
    def __init__(self, currencyScheme='http://www.fpml.org/coding-scheme/external/iso4217-2001-08-15', id=None, valueOf_=None):
        self.original_tagname_ = None
        super(IdentifiedCurrency, self).__init__(currencyScheme, valueOf_, )
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IdentifiedCurrency)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IdentifiedCurrency.subclass:
            return IdentifiedCurrency.subclass(*args_, **kwargs_)
        else:
            return IdentifiedCurrency(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_ or
            super(IdentifiedCurrency, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IdentifiedCurrency', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifiedCurrency')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IdentifiedCurrency', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IdentifiedCurrency'):
        super(IdentifiedCurrency, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifiedCurrency')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IdentifiedCurrency', fromsubclass_=False, pretty_print=True):
        super(IdentifiedCurrency, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        super(IdentifiedCurrency, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IdentifiedCurrency


class IdentifiedDate(GeneratedsSuper):
    """A date which can be referenced elsewhere."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'valueOf_': MemberSpec_('valueOf_', 'xsd:date', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IdentifiedDate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IdentifiedDate.subclass:
            return IdentifiedDate.subclass(*args_, **kwargs_)
        else:
            return IdentifiedDate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IdentifiedDate', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifiedDate')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IdentifiedDate', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IdentifiedDate'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IdentifiedDate', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IdentifiedDate


class IdentifiedPayerReceiver(GeneratedsSuper):
    """A type extending the PayerReceiverEnum type wih an id attribute."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'valueOf_': MemberSpec_('valueOf_', ['PayerReceiverEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IdentifiedPayerReceiver)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IdentifiedPayerReceiver.subclass:
            return IdentifiedPayerReceiver.subclass(*args_, **kwargs_)
        else:
            return IdentifiedPayerReceiver(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IdentifiedPayerReceiver', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifiedPayerReceiver')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IdentifiedPayerReceiver', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IdentifiedPayerReceiver'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IdentifiedPayerReceiver', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IdentifiedPayerReceiver


class IdentifiedRate(GeneratedsSuper):
    """A rate which can be referenced elsewhere."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'valueOf_': MemberSpec_('valueOf_', 'xsd:decimal', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IdentifiedRate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IdentifiedRate.subclass:
            return IdentifiedRate.subclass(*args_, **kwargs_)
        else:
            return IdentifiedRate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IdentifiedRate', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifiedRate')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IdentifiedRate', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IdentifiedRate'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IdentifiedRate', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IdentifiedRate


class IndependentAmount(GeneratedsSuper):
    member_data_items_ = {
        'payerPartyReference': MemberSpec_('payerPartyReference', 'PartyReference', 0),
        'payerAccountReference': MemberSpec_('payerAccountReference', 'AccountReference', 0),
        'receiverPartyReference': MemberSpec_('receiverPartyReference', 'PartyReference', 0),
        'receiverAccountReference': MemberSpec_('receiverAccountReference', 'AccountReference', 0),
        'paymentDetail': MemberSpec_('paymentDetail', 'PaymentDetail', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, paymentDetail=None):
        self.original_tagname_ = None
        self.payerPartyReference = payerPartyReference
        self.payerAccountReference = payerAccountReference
        self.receiverPartyReference = receiverPartyReference
        self.receiverAccountReference = receiverAccountReference
        if paymentDetail is None:
            self.paymentDetail = []
        else:
            self.paymentDetail = paymentDetail
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IndependentAmount)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IndependentAmount.subclass:
            return IndependentAmount.subclass(*args_, **kwargs_)
        else:
            return IndependentAmount(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_payerPartyReference(self): return self.payerPartyReference
    def set_payerPartyReference(self, payerPartyReference): self.payerPartyReference = payerPartyReference
    def get_payerAccountReference(self): return self.payerAccountReference
    def set_payerAccountReference(self, payerAccountReference): self.payerAccountReference = payerAccountReference
    def get_receiverPartyReference(self): return self.receiverPartyReference
    def set_receiverPartyReference(self, receiverPartyReference): self.receiverPartyReference = receiverPartyReference
    def get_receiverAccountReference(self): return self.receiverAccountReference
    def set_receiverAccountReference(self, receiverAccountReference): self.receiverAccountReference = receiverAccountReference
    def get_paymentDetail(self): return self.paymentDetail
    def set_paymentDetail(self, paymentDetail): self.paymentDetail = paymentDetail
    def add_paymentDetail(self, value): self.paymentDetail.append(value)
    def insert_paymentDetail_at(self, index, value): self.paymentDetail.insert(index, value)
    def replace_paymentDetail_at(self, index, value): self.paymentDetail[index] = value
    def hasContent_(self):
        if (
            self.payerPartyReference is not None or
            self.payerAccountReference is not None or
            self.receiverPartyReference is not None or
            self.receiverAccountReference is not None or
            self.paymentDetail
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IndependentAmount', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IndependentAmount')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IndependentAmount', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IndependentAmount'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IndependentAmount', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.payerPartyReference is not None:
            self.payerPartyReference.export(outfile, level, namespace_, name_='payerPartyReference', pretty_print=pretty_print)
        if self.payerAccountReference is not None:
            self.payerAccountReference.export(outfile, level, namespace_, name_='payerAccountReference', pretty_print=pretty_print)
        if self.receiverPartyReference is not None:
            self.receiverPartyReference.export(outfile, level, namespace_, name_='receiverPartyReference', pretty_print=pretty_print)
        if self.receiverAccountReference is not None:
            self.receiverAccountReference.export(outfile, level, namespace_, name_='receiverAccountReference', pretty_print=pretty_print)
        for paymentDetail_ in self.paymentDetail:
            paymentDetail_.export(outfile, level, namespace_, name_='paymentDetail', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'payerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.payerPartyReference = obj_
            obj_.original_tagname_ = 'payerPartyReference'
        elif nodeName_ == 'payerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.payerAccountReference = obj_
            obj_.original_tagname_ = 'payerAccountReference'
        elif nodeName_ == 'receiverPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.receiverPartyReference = obj_
            obj_.original_tagname_ = 'receiverPartyReference'
        elif nodeName_ == 'receiverAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.receiverAccountReference = obj_
            obj_.original_tagname_ = 'receiverAccountReference'
        elif nodeName_ == 'paymentDetail':
            obj_ = PaymentDetail.factory()
            obj_.build(child_)
            self.paymentDetail.append(obj_)
            obj_.original_tagname_ = 'paymentDetail'
# end class IndependentAmount


class IndustryClassification(GeneratedsSuper):
    """A party's industry sector classification."""
    member_data_items_ = {
        'industryClassificationScheme': MemberSpec_('industryClassificationScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, industryClassificationScheme='http://www.fpml.org/coding-scheme/regulatory-corporate-sector', valueOf_=None):
        self.original_tagname_ = None
        self.industryClassificationScheme = _cast(None, industryClassificationScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IndustryClassification)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IndustryClassification.subclass:
            return IndustryClassification.subclass(*args_, **kwargs_)
        else:
            return IndustryClassification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_industryClassificationScheme(self): return self.industryClassificationScheme
    def set_industryClassificationScheme(self, industryClassificationScheme): self.industryClassificationScheme = industryClassificationScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IndustryClassification', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IndustryClassification')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IndustryClassification', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IndustryClassification'):
        if self.industryClassificationScheme != "http://www.fpml.org/coding-scheme/regulatory-corporate-sector" and 'industryClassificationScheme' not in already_processed:
            already_processed.add('industryClassificationScheme')
            outfile.write(' industryClassificationScheme=%s' % (quote_attrib(self.industryClassificationScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IndustryClassification', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('industryClassificationScheme', node)
        if value is not None and 'industryClassificationScheme' not in already_processed:
            already_processed.add('industryClassificationScheme')
            self.industryClassificationScheme = value
            self.validate_NonEmptyURI(self.industryClassificationScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IndustryClassification


class InformationProvider(GeneratedsSuper):
    member_data_items_ = {
        'informationProviderScheme': MemberSpec_('informationProviderScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, informationProviderScheme='http://www.fpml.org/coding-scheme/information-provider', valueOf_=None):
        self.original_tagname_ = None
        self.informationProviderScheme = _cast(None, informationProviderScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InformationProvider)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InformationProvider.subclass:
            return InformationProvider.subclass(*args_, **kwargs_)
        else:
            return InformationProvider(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_informationProviderScheme(self): return self.informationProviderScheme
    def set_informationProviderScheme(self, informationProviderScheme): self.informationProviderScheme = informationProviderScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InformationProvider', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InformationProvider')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InformationProvider', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InformationProvider'):
        if self.informationProviderScheme != "http://www.fpml.org/coding-scheme/information-provider" and 'informationProviderScheme' not in already_processed:
            already_processed.add('informationProviderScheme')
            outfile.write(' informationProviderScheme=%s' % (quote_attrib(self.informationProviderScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='InformationProvider', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('informationProviderScheme', node)
        if value is not None and 'informationProviderScheme' not in already_processed:
            already_processed.add('informationProviderScheme')
            self.informationProviderScheme = value
            self.validate_NonEmptyURI(self.informationProviderScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class InformationProvider


class InformationSource(GeneratedsSuper):
    """A type defining the source for a piece of information (e.g. a rate
    refix or an fx fixing)."""
    member_data_items_ = {
        'rateSource': MemberSpec_('rateSource', 'InformationProvider', 0),
        'rateSourcePage': MemberSpec_('rateSourcePage', 'RateSourcePage', 0),
        'rateSourcePageHeading': MemberSpec_('rateSourcePageHeading', ['String', 'xsd:string'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, rateSource=None, rateSourcePage=None, rateSourcePageHeading=None, extensiontype_=None):
        self.original_tagname_ = None
        self.rateSource = rateSource
        self.rateSourcePage = rateSourcePage
        self.rateSourcePageHeading = rateSourcePageHeading
        self.validate_String(self.rateSourcePageHeading)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InformationSource)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InformationSource.subclass:
            return InformationSource.subclass(*args_, **kwargs_)
        else:
            return InformationSource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rateSource(self): return self.rateSource
    def set_rateSource(self, rateSource): self.rateSource = rateSource
    def get_rateSourcePage(self): return self.rateSourcePage
    def set_rateSourcePage(self, rateSourcePage): self.rateSourcePage = rateSourcePage
    def get_rateSourcePageHeading(self): return self.rateSourcePageHeading
    def set_rateSourcePageHeading(self, rateSourcePageHeading): self.rateSourcePageHeading = rateSourcePageHeading
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.rateSource is not None or
            self.rateSourcePage is not None or
            self.rateSourcePageHeading is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InformationSource', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InformationSource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InformationSource', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InformationSource'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='InformationSource', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.rateSource is not None:
            self.rateSource.export(outfile, level, namespace_, name_='rateSource', pretty_print=pretty_print)
        if self.rateSourcePage is not None:
            self.rateSourcePage.export(outfile, level, namespace_, name_='rateSourcePage', pretty_print=pretty_print)
        if self.rateSourcePageHeading is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srateSourcePageHeading>%s</%srateSourcePageHeading>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.rateSourcePageHeading), input_name='rateSourcePageHeading')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'rateSource':
            obj_ = InformationProvider.factory()
            obj_.build(child_)
            self.rateSource = obj_
            obj_.original_tagname_ = 'rateSource'
        elif nodeName_ == 'rateSourcePage':
            obj_ = RateSourcePage.factory()
            obj_.build(child_)
            self.rateSourcePage = obj_
            obj_.original_tagname_ = 'rateSourcePage'
        elif nodeName_ == 'rateSourcePageHeading':
            rateSourcePageHeading_ = child_.text
            rateSourcePageHeading_ = self.gds_validate_string(rateSourcePageHeading_, node, 'rateSourcePageHeading')
            self.rateSourcePageHeading = rateSourcePageHeading_
            # validate type String
            self.validate_String(self.rateSourcePageHeading)
# end class InformationSource


class InstrumentId(GeneratedsSuper):
    """A short form unique identifier for a security."""
    member_data_items_ = {
        'instrumentIdScheme': MemberSpec_('instrumentIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, instrumentIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.instrumentIdScheme = _cast(None, instrumentIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InstrumentId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InstrumentId.subclass:
            return InstrumentId.subclass(*args_, **kwargs_)
        else:
            return InstrumentId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_instrumentIdScheme(self): return self.instrumentIdScheme
    def set_instrumentIdScheme(self, instrumentIdScheme): self.instrumentIdScheme = instrumentIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InstrumentId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InstrumentId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InstrumentId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InstrumentId'):
        if self.instrumentIdScheme is not None and 'instrumentIdScheme' not in already_processed:
            already_processed.add('instrumentIdScheme')
            outfile.write(' instrumentIdScheme=%s' % (quote_attrib(self.instrumentIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='InstrumentId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('instrumentIdScheme', node)
        if value is not None and 'instrumentIdScheme' not in already_processed:
            already_processed.add('instrumentIdScheme')
            self.instrumentIdScheme = value
            self.validate_NonEmptyURI(self.instrumentIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class InstrumentId


class InterestAccrualsMethod(GeneratedsSuper):
    """A type describing the method for accruing interests on dividends.
    Can be either a fixed rate reference or a floating rate
    reference."""
    member_data_items_ = {
        'floatingRateCalculation': MemberSpec_('floatingRateCalculation', 'FloatingRateCalculation', 0),
        'fixedRate': MemberSpec_('fixedRate', 'xsd:decimal', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, floatingRateCalculation=None, fixedRate=None, extensiontype_=None):
        self.original_tagname_ = None
        self.floatingRateCalculation = floatingRateCalculation
        self.fixedRate = fixedRate
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InterestAccrualsMethod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InterestAccrualsMethod.subclass:
            return InterestAccrualsMethod.subclass(*args_, **kwargs_)
        else:
            return InterestAccrualsMethod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_floatingRateCalculation(self): return self.floatingRateCalculation
    def set_floatingRateCalculation(self, floatingRateCalculation): self.floatingRateCalculation = floatingRateCalculation
    def get_fixedRate(self): return self.fixedRate
    def set_fixedRate(self, fixedRate): self.fixedRate = fixedRate
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.floatingRateCalculation is not None or
            self.fixedRate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InterestAccrualsMethod', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InterestAccrualsMethod')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InterestAccrualsMethod', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InterestAccrualsMethod'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='InterestAccrualsMethod', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.floatingRateCalculation is not None:
            self.floatingRateCalculation.export(outfile, level, namespace_, name_='floatingRateCalculation', pretty_print=pretty_print)
        if self.fixedRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfixedRate>%s</%sfixedRate>%s' % (namespace_, self.gds_format_float(self.fixedRate, input_name='fixedRate'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'floatingRateCalculation':
            obj_ = FloatingRateCalculation.factory()
            obj_.build(child_)
            self.floatingRateCalculation = obj_
            obj_.original_tagname_ = 'floatingRateCalculation'
        elif nodeName_ == 'fixedRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'fixedRate')
            self.fixedRate = fval_
# end class InterestAccrualsMethod


class IntermediaryInformation(GeneratedsSuper):
    """A type that describes the information to identify an intermediary
    through which payment will be made by the correspondent bank to
    the ultimate beneficiary of the funds."""
    member_data_items_ = {
        'routingIds': MemberSpec_('routingIds', 'RoutingIds', 0),
        'routingExplicitDetails': MemberSpec_('routingExplicitDetails', 'RoutingExplicitDetails', 0),
        'routingIdsAndExplicitDetails': MemberSpec_('routingIdsAndExplicitDetails', 'RoutingIdsAndExplicitDetails', 0),
        'intermediarySequenceNumber': MemberSpec_('intermediarySequenceNumber', 'xsd:positiveInteger', 0),
        'intermediaryPartyReference': MemberSpec_('intermediaryPartyReference', 'PartyReference', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, routingIds=None, routingExplicitDetails=None, routingIdsAndExplicitDetails=None, intermediarySequenceNumber=None, intermediaryPartyReference=None):
        self.original_tagname_ = None
        self.routingIds = routingIds
        self.routingExplicitDetails = routingExplicitDetails
        self.routingIdsAndExplicitDetails = routingIdsAndExplicitDetails
        self.intermediarySequenceNumber = intermediarySequenceNumber
        self.intermediaryPartyReference = intermediaryPartyReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IntermediaryInformation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IntermediaryInformation.subclass:
            return IntermediaryInformation.subclass(*args_, **kwargs_)
        else:
            return IntermediaryInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_routingIds(self): return self.routingIds
    def set_routingIds(self, routingIds): self.routingIds = routingIds
    def get_routingExplicitDetails(self): return self.routingExplicitDetails
    def set_routingExplicitDetails(self, routingExplicitDetails): self.routingExplicitDetails = routingExplicitDetails
    def get_routingIdsAndExplicitDetails(self): return self.routingIdsAndExplicitDetails
    def set_routingIdsAndExplicitDetails(self, routingIdsAndExplicitDetails): self.routingIdsAndExplicitDetails = routingIdsAndExplicitDetails
    def get_intermediarySequenceNumber(self): return self.intermediarySequenceNumber
    def set_intermediarySequenceNumber(self, intermediarySequenceNumber): self.intermediarySequenceNumber = intermediarySequenceNumber
    def get_intermediaryPartyReference(self): return self.intermediaryPartyReference
    def set_intermediaryPartyReference(self, intermediaryPartyReference): self.intermediaryPartyReference = intermediaryPartyReference
    def hasContent_(self):
        if (
            self.routingIds is not None or
            self.routingExplicitDetails is not None or
            self.routingIdsAndExplicitDetails is not None or
            self.intermediarySequenceNumber is not None or
            self.intermediaryPartyReference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IntermediaryInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IntermediaryInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IntermediaryInformation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IntermediaryInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IntermediaryInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.routingIds is not None:
            self.routingIds.export(outfile, level, namespace_, name_='routingIds', pretty_print=pretty_print)
        if self.routingExplicitDetails is not None:
            self.routingExplicitDetails.export(outfile, level, namespace_, name_='routingExplicitDetails', pretty_print=pretty_print)
        if self.routingIdsAndExplicitDetails is not None:
            self.routingIdsAndExplicitDetails.export(outfile, level, namespace_, name_='routingIdsAndExplicitDetails', pretty_print=pretty_print)
        if self.intermediarySequenceNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sintermediarySequenceNumber>%s</%sintermediarySequenceNumber>%s' % (namespace_, self.gds_format_integer(self.intermediarySequenceNumber, input_name='intermediarySequenceNumber'), namespace_, eol_))
        if self.intermediaryPartyReference is not None:
            self.intermediaryPartyReference.export(outfile, level, namespace_, name_='intermediaryPartyReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'routingIds':
            obj_ = RoutingIds.factory()
            obj_.build(child_)
            self.routingIds = obj_
            obj_.original_tagname_ = 'routingIds'
        elif nodeName_ == 'routingExplicitDetails':
            obj_ = RoutingExplicitDetails.factory()
            obj_.build(child_)
            self.routingExplicitDetails = obj_
            obj_.original_tagname_ = 'routingExplicitDetails'
        elif nodeName_ == 'routingIdsAndExplicitDetails':
            obj_ = RoutingIdsAndExplicitDetails.factory()
            obj_.build(child_)
            self.routingIdsAndExplicitDetails = obj_
            obj_.original_tagname_ = 'routingIdsAndExplicitDetails'
        elif nodeName_ == 'intermediarySequenceNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'intermediarySequenceNumber')
            self.intermediarySequenceNumber = ival_
        elif nodeName_ == 'intermediaryPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.intermediaryPartyReference = obj_
            obj_.original_tagname_ = 'intermediaryPartyReference'
# end class IntermediaryInformation


class InterpolationMethod(GeneratedsSuper):
    """The type of interpolation used."""
    member_data_items_ = {
        'interpolationMethodScheme': MemberSpec_('interpolationMethodScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, interpolationMethodScheme='http://www.fpml.org/coding-scheme/interpolation-method', valueOf_=None):
        self.original_tagname_ = None
        self.interpolationMethodScheme = _cast(None, interpolationMethodScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InterpolationMethod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InterpolationMethod.subclass:
            return InterpolationMethod.subclass(*args_, **kwargs_)
        else:
            return InterpolationMethod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_interpolationMethodScheme(self): return self.interpolationMethodScheme
    def set_interpolationMethodScheme(self, interpolationMethodScheme): self.interpolationMethodScheme = interpolationMethodScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InterpolationMethod', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InterpolationMethod')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InterpolationMethod', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InterpolationMethod'):
        if self.interpolationMethodScheme != "http://www.fpml.org/coding-scheme/interpolation-method" and 'interpolationMethodScheme' not in already_processed:
            already_processed.add('interpolationMethodScheme')
            outfile.write(' interpolationMethodScheme=%s' % (quote_attrib(self.interpolationMethodScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='InterpolationMethod', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('interpolationMethodScheme', node)
        if value is not None and 'interpolationMethodScheme' not in already_processed:
            already_processed.add('interpolationMethodScheme')
            self.interpolationMethodScheme = value
            self.validate_NonEmptyURI(self.interpolationMethodScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class InterpolationMethod


class Language(GeneratedsSuper):
    """The data type used for indicating the language of the resource,
    described using the ISO 639-2/T Code."""
    member_data_items_ = {
        'languageScheme': MemberSpec_('languageScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, languageScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.languageScheme = _cast(None, languageScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Language)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Language.subclass:
            return Language.subclass(*args_, **kwargs_)
        else:
            return Language(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_languageScheme(self): return self.languageScheme
    def set_languageScheme(self, languageScheme): self.languageScheme = languageScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Language', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Language')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Language', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Language'):
        if self.languageScheme is not None and 'languageScheme' not in already_processed:
            already_processed.add('languageScheme')
            outfile.write(' languageScheme=%s' % (quote_attrib(self.languageScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Language', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('languageScheme', node)
        if value is not None and 'languageScheme' not in already_processed:
            already_processed.add('languageScheme')
            self.languageScheme = value
            self.validate_NonEmptyURI(self.languageScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Language


class Leg(GeneratedsSuper):
    """A supertype of leg. All swap legs extend this type."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Leg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Leg.subclass:
            return Leg.subclass(*args_, **kwargs_)
        else:
            return Leg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Leg', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Leg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Leg', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Leg'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Leg', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Leg


class LegId(GeneratedsSuper):
    """Leg identity."""
    member_data_items_ = {
        'legIdScheme': MemberSpec_('legIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Token60', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, legIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.legIdScheme = _cast(None, legIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LegId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LegId.subclass:
            return LegId.subclass(*args_, **kwargs_)
        else:
            return LegId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_legIdScheme(self): return self.legIdScheme
    def set_legIdScheme(self, legIdScheme): self.legIdScheme = legIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LegId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LegId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LegId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LegId'):
        if self.legIdScheme is not None and 'legIdScheme' not in already_processed:
            already_processed.add('legIdScheme')
            outfile.write(' legIdScheme=%s' % (quote_attrib(self.legIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LegId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('legIdScheme', node)
        if value is not None and 'legIdScheme' not in already_processed:
            already_processed.add('legIdScheme')
            self.legIdScheme = value
            self.validate_NonEmptyURI(self.legIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LegId


class LegIdentifier(GeneratedsSuper):
    """Version aware identification of a leg."""
    member_data_items_ = {
        'legId': MemberSpec_('legId', 'LegId', 0),
        'version': MemberSpec_('version', 'xsd:nonNegativeInteger', 0),
        'effectiveDate': MemberSpec_('effectiveDate', 'IdentifiedDate', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, legId=None, version=None, effectiveDate=None):
        self.original_tagname_ = None
        self.legId = legId
        self.version = version
        self.effectiveDate = effectiveDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LegIdentifier)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LegIdentifier.subclass:
            return LegIdentifier.subclass(*args_, **kwargs_)
        else:
            return LegIdentifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_legId(self): return self.legId
    def set_legId(self, legId): self.legId = legId
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_effectiveDate(self): return self.effectiveDate
    def set_effectiveDate(self, effectiveDate): self.effectiveDate = effectiveDate
    def hasContent_(self):
        if (
            self.legId is not None or
            self.version is not None or
            self.effectiveDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LegIdentifier', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LegIdentifier')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LegIdentifier', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LegIdentifier'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LegIdentifier', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.legId is not None:
            self.legId.export(outfile, level, namespace_, name_='legId', pretty_print=pretty_print)
        if self.version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sversion>%s</%sversion>%s' % (namespace_, self.gds_format_integer(self.version, input_name='version'), namespace_, eol_))
        if self.effectiveDate is not None:
            self.effectiveDate.export(outfile, level, namespace_, name_='effectiveDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'legId':
            obj_ = LegId.factory()
            obj_.build(child_)
            self.legId = obj_
            obj_.original_tagname_ = 'legId'
        elif nodeName_ == 'version':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'version')
            self.version = ival_
        elif nodeName_ == 'effectiveDate':
            obj_ = IdentifiedDate.factory()
            obj_.build(child_)
            self.effectiveDate = obj_
            obj_.original_tagname_ = 'effectiveDate'
# end class LegIdentifier


class LegalEntity(GeneratedsSuper):
    """A type defining a legal entity."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'entityName': MemberSpec_('entityName', 'EntityName', 0),
        'entityId': MemberSpec_('entityId', 'EntityId', 1),
        'entityId': MemberSpec_('entityId', 'EntityId', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, entityName=None, entityId=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.entityName = entityName
        if entityId is None:
            self.entityId = []
        else:
            self.entityId = entityId
        if entityId is None:
            self.entityId = []
        else:
            self.entityId = entityId
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LegalEntity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LegalEntity.subclass:
            return LegalEntity.subclass(*args_, **kwargs_)
        else:
            return LegalEntity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_entityName(self): return self.entityName
    def set_entityName(self, entityName): self.entityName = entityName
    def get_entityId(self): return self.entityId
    def set_entityId(self, entityId): self.entityId = entityId
    def add_entityId(self, value): self.entityId.append(value)
    def insert_entityId_at(self, index, value): self.entityId.insert(index, value)
    def replace_entityId_at(self, index, value): self.entityId[index] = value
    def get_entityId(self): return self.entityId
    def set_entityId(self, entityId): self.entityId = entityId
    def add_entityId(self, value): self.entityId.append(value)
    def insert_entityId_at(self, index, value): self.entityId.insert(index, value)
    def replace_entityId_at(self, index, value): self.entityId[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.entityName is not None or
            self.entityId or
            self.entityId
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LegalEntity', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LegalEntity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LegalEntity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LegalEntity'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LegalEntity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.entityName is not None:
            self.entityName.export(outfile, level, namespace_, name_='entityName', pretty_print=pretty_print)
        for entityId_ in self.entityId:
            entityId_.export(outfile, level, namespace_, name_='entityId', pretty_print=pretty_print)
        for entityId_ in self.entityId:
            entityId_.export(outfile, level, namespace_, name_='entityId', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'entityName':
            obj_ = EntityName.factory()
            obj_.build(child_)
            self.entityName = obj_
            obj_.original_tagname_ = 'entityName'
        elif nodeName_ == 'entityId':
            obj_ = EntityId.factory()
            obj_.build(child_)
            self.entityId.append(obj_)
            obj_.original_tagname_ = 'entityId'
        elif nodeName_ == 'entityId':
            obj_ = EntityId.factory()
            obj_.build(child_)
            self.entityId.append(obj_)
            obj_.original_tagname_ = 'entityId'
# end class LegalEntity


class MainPublication(GeneratedsSuper):
    """A type to define the main publication source."""
    member_data_items_ = {
        'mainPublicationScheme': MemberSpec_('mainPublicationScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, mainPublicationScheme='http://www.fpml.org/coding-scheme/inflation-main-publication', valueOf_=None):
        self.original_tagname_ = None
        self.mainPublicationScheme = _cast(None, mainPublicationScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MainPublication)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MainPublication.subclass:
            return MainPublication.subclass(*args_, **kwargs_)
        else:
            return MainPublication(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mainPublicationScheme(self): return self.mainPublicationScheme
    def set_mainPublicationScheme(self, mainPublicationScheme): self.mainPublicationScheme = mainPublicationScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MainPublication', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MainPublication')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MainPublication', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MainPublication'):
        if self.mainPublicationScheme != "http://www.fpml.org/coding-scheme/inflation-main-publication" and 'mainPublicationScheme' not in already_processed:
            already_processed.add('mainPublicationScheme')
            outfile.write(' mainPublicationScheme=%s' % (quote_attrib(self.mainPublicationScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MainPublication', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mainPublicationScheme', node)
        if value is not None and 'mainPublicationScheme' not in already_processed:
            already_processed.add('mainPublicationScheme')
            self.mainPublicationScheme = value
            self.validate_NonEmptyURI(self.mainPublicationScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MainPublication


class ManualExercise(GeneratedsSuper):
    """A type defining manual exercise, i.e. that the option buyer
    counterparty must give notice to the option seller of exercise."""
    member_data_items_ = {
        'exerciseNotice': MemberSpec_('exerciseNotice', 'ExerciseNotice', 0),
        'fallbackExercise': MemberSpec_('fallbackExercise', 'xsd:boolean', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, exerciseNotice=None, fallbackExercise=None):
        self.original_tagname_ = None
        self.exerciseNotice = exerciseNotice
        self.fallbackExercise = fallbackExercise
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ManualExercise)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ManualExercise.subclass:
            return ManualExercise.subclass(*args_, **kwargs_)
        else:
            return ManualExercise(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_exerciseNotice(self): return self.exerciseNotice
    def set_exerciseNotice(self, exerciseNotice): self.exerciseNotice = exerciseNotice
    def get_fallbackExercise(self): return self.fallbackExercise
    def set_fallbackExercise(self, fallbackExercise): self.fallbackExercise = fallbackExercise
    def hasContent_(self):
        if (
            self.exerciseNotice is not None or
            self.fallbackExercise is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ManualExercise', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ManualExercise')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ManualExercise', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ManualExercise'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ManualExercise', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.exerciseNotice is not None:
            self.exerciseNotice.export(outfile, level, namespace_, name_='exerciseNotice', pretty_print=pretty_print)
        if self.fallbackExercise is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfallbackExercise>%s</%sfallbackExercise>%s' % (namespace_, self.gds_format_boolean(self.fallbackExercise, input_name='fallbackExercise'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'exerciseNotice':
            obj_ = ExerciseNotice.factory()
            obj_.build(child_)
            self.exerciseNotice = obj_
            obj_.original_tagname_ = 'exerciseNotice'
        elif nodeName_ == 'fallbackExercise':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'fallbackExercise')
            self.fallbackExercise = ival_
# end class ManualExercise


class MasterAgreement(GeneratedsSuper):
    """An entity for defining the agreement executed between the parties
    and intended to govern all OTC derivatives transactions between
    those parties."""
    member_data_items_ = {
        'masterAgreementId': MemberSpec_('masterAgreementId', 'MasterAgreementId', 1),
        'masterAgreementType': MemberSpec_('masterAgreementType', 'MasterAgreementType', 0),
        'masterAgreementVersion': MemberSpec_('masterAgreementVersion', 'MasterAgreementVersion', 0),
        'masterAgreementDate': MemberSpec_('masterAgreementDate', 'xsd:date', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, masterAgreementId=None, masterAgreementType=None, masterAgreementVersion=None, masterAgreementDate=None):
        self.original_tagname_ = None
        if masterAgreementId is None:
            self.masterAgreementId = []
        else:
            self.masterAgreementId = masterAgreementId
        self.masterAgreementType = masterAgreementType
        self.masterAgreementVersion = masterAgreementVersion
        if isinstance(masterAgreementDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(masterAgreementDate, '%Y-%m-%d').date()
        else:
            initvalue_ = masterAgreementDate
        self.masterAgreementDate = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MasterAgreement)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MasterAgreement.subclass:
            return MasterAgreement.subclass(*args_, **kwargs_)
        else:
            return MasterAgreement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_masterAgreementId(self): return self.masterAgreementId
    def set_masterAgreementId(self, masterAgreementId): self.masterAgreementId = masterAgreementId
    def add_masterAgreementId(self, value): self.masterAgreementId.append(value)
    def insert_masterAgreementId_at(self, index, value): self.masterAgreementId.insert(index, value)
    def replace_masterAgreementId_at(self, index, value): self.masterAgreementId[index] = value
    def get_masterAgreementType(self): return self.masterAgreementType
    def set_masterAgreementType(self, masterAgreementType): self.masterAgreementType = masterAgreementType
    def get_masterAgreementVersion(self): return self.masterAgreementVersion
    def set_masterAgreementVersion(self, masterAgreementVersion): self.masterAgreementVersion = masterAgreementVersion
    def get_masterAgreementDate(self): return self.masterAgreementDate
    def set_masterAgreementDate(self, masterAgreementDate): self.masterAgreementDate = masterAgreementDate
    def hasContent_(self):
        if (
            self.masterAgreementId or
            self.masterAgreementType is not None or
            self.masterAgreementVersion is not None or
            self.masterAgreementDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MasterAgreement', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MasterAgreement')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MasterAgreement', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MasterAgreement'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MasterAgreement', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for masterAgreementId_ in self.masterAgreementId:
            masterAgreementId_.export(outfile, level, namespace_, name_='masterAgreementId', pretty_print=pretty_print)
        if self.masterAgreementType is not None:
            self.masterAgreementType.export(outfile, level, namespace_, name_='masterAgreementType', pretty_print=pretty_print)
        if self.masterAgreementVersion is not None:
            self.masterAgreementVersion.export(outfile, level, namespace_, name_='masterAgreementVersion', pretty_print=pretty_print)
        if self.masterAgreementDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smasterAgreementDate>%s</%smasterAgreementDate>%s' % (namespace_, self.gds_format_date(self.masterAgreementDate, input_name='masterAgreementDate'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'masterAgreementId':
            obj_ = MasterAgreementId.factory()
            obj_.build(child_)
            self.masterAgreementId.append(obj_)
            obj_.original_tagname_ = 'masterAgreementId'
        elif nodeName_ == 'masterAgreementType':
            obj_ = MasterAgreementType.factory()
            obj_.build(child_)
            self.masterAgreementType = obj_
            obj_.original_tagname_ = 'masterAgreementType'
        elif nodeName_ == 'masterAgreementVersion':
            obj_ = MasterAgreementVersion.factory()
            obj_.build(child_)
            self.masterAgreementVersion = obj_
            obj_.original_tagname_ = 'masterAgreementVersion'
        elif nodeName_ == 'masterAgreementDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.masterAgreementDate = dval_
# end class MasterAgreement


class MasterAgreementId(GeneratedsSuper):
    """A master agreement identifier allocated by a party. FpML does not
    define the domain values associated with this element. Note that
    the domain values for this element are not strictly an
    enumerated list."""
    member_data_items_ = {
        'masterAgreementIdScheme': MemberSpec_('masterAgreementIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, masterAgreementIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.masterAgreementIdScheme = _cast(None, masterAgreementIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MasterAgreementId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MasterAgreementId.subclass:
            return MasterAgreementId.subclass(*args_, **kwargs_)
        else:
            return MasterAgreementId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_masterAgreementIdScheme(self): return self.masterAgreementIdScheme
    def set_masterAgreementIdScheme(self, masterAgreementIdScheme): self.masterAgreementIdScheme = masterAgreementIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MasterAgreementId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MasterAgreementId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MasterAgreementId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MasterAgreementId'):
        if self.masterAgreementIdScheme is not None and 'masterAgreementIdScheme' not in already_processed:
            already_processed.add('masterAgreementIdScheme')
            outfile.write(' masterAgreementIdScheme=%s' % (quote_attrib(self.masterAgreementIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MasterAgreementId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('masterAgreementIdScheme', node)
        if value is not None and 'masterAgreementIdScheme' not in already_processed:
            already_processed.add('masterAgreementIdScheme')
            self.masterAgreementIdScheme = value
            self.validate_NonEmptyURI(self.masterAgreementIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MasterAgreementId


class MasterAgreementType(GeneratedsSuper):
    member_data_items_ = {
        'masterAgreementTypeScheme': MemberSpec_('masterAgreementTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, masterAgreementTypeScheme='http://www.fpml.org/coding-scheme/master-agreement-type', valueOf_=None):
        self.original_tagname_ = None
        self.masterAgreementTypeScheme = _cast(None, masterAgreementTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MasterAgreementType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MasterAgreementType.subclass:
            return MasterAgreementType.subclass(*args_, **kwargs_)
        else:
            return MasterAgreementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_masterAgreementTypeScheme(self): return self.masterAgreementTypeScheme
    def set_masterAgreementTypeScheme(self, masterAgreementTypeScheme): self.masterAgreementTypeScheme = masterAgreementTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MasterAgreementType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MasterAgreementType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MasterAgreementType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MasterAgreementType'):
        if self.masterAgreementTypeScheme != "http://www.fpml.org/coding-scheme/master-agreement-type" and 'masterAgreementTypeScheme' not in already_processed:
            already_processed.add('masterAgreementTypeScheme')
            outfile.write(' masterAgreementTypeScheme=%s' % (quote_attrib(self.masterAgreementTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MasterAgreementType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('masterAgreementTypeScheme', node)
        if value is not None and 'masterAgreementTypeScheme' not in already_processed:
            already_processed.add('masterAgreementTypeScheme')
            self.masterAgreementTypeScheme = value
            self.validate_NonEmptyURI(self.masterAgreementTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MasterAgreementType


class MasterAgreementVersion(GeneratedsSuper):
    member_data_items_ = {
        'masterAgreementVersionScheme': MemberSpec_('masterAgreementVersionScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, masterAgreementVersionScheme='http://www.fpml.org/coding-scheme/master-agreement-version', valueOf_=None):
        self.original_tagname_ = None
        self.masterAgreementVersionScheme = _cast(None, masterAgreementVersionScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MasterAgreementVersion)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MasterAgreementVersion.subclass:
            return MasterAgreementVersion.subclass(*args_, **kwargs_)
        else:
            return MasterAgreementVersion(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_masterAgreementVersionScheme(self): return self.masterAgreementVersionScheme
    def set_masterAgreementVersionScheme(self, masterAgreementVersionScheme): self.masterAgreementVersionScheme = masterAgreementVersionScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MasterAgreementVersion', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MasterAgreementVersion')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MasterAgreementVersion', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MasterAgreementVersion'):
        if self.masterAgreementVersionScheme != "http://www.fpml.org/coding-scheme/master-agreement-version" and 'masterAgreementVersionScheme' not in already_processed:
            already_processed.add('masterAgreementVersionScheme')
            outfile.write(' masterAgreementVersionScheme=%s' % (quote_attrib(self.masterAgreementVersionScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MasterAgreementVersion', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('masterAgreementVersionScheme', node)
        if value is not None and 'masterAgreementVersionScheme' not in already_processed:
            already_processed.add('masterAgreementVersionScheme')
            self.masterAgreementVersionScheme = value
            self.validate_NonEmptyURI(self.masterAgreementVersionScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MasterAgreementVersion


class MasterConfirmation(GeneratedsSuper):
    """An entity for defining the master confirmation agreement executed
    between the parties."""
    member_data_items_ = {
        'masterConfirmationType': MemberSpec_('masterConfirmationType', 'MasterConfirmationType', 0),
        'masterConfirmationDate': MemberSpec_('masterConfirmationDate', 'xsd:date', 0),
        'masterConfirmationAnnexDate': MemberSpec_('masterConfirmationAnnexDate', 'xsd:date', 0),
        'masterConfirmationAnnexType': MemberSpec_('masterConfirmationAnnexType', 'MasterConfirmationAnnexType', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, masterConfirmationType=None, masterConfirmationDate=None, masterConfirmationAnnexDate=None, masterConfirmationAnnexType=None):
        self.original_tagname_ = None
        self.masterConfirmationType = masterConfirmationType
        if isinstance(masterConfirmationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(masterConfirmationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = masterConfirmationDate
        self.masterConfirmationDate = initvalue_
        if isinstance(masterConfirmationAnnexDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(masterConfirmationAnnexDate, '%Y-%m-%d').date()
        else:
            initvalue_ = masterConfirmationAnnexDate
        self.masterConfirmationAnnexDate = initvalue_
        self.masterConfirmationAnnexType = masterConfirmationAnnexType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MasterConfirmation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MasterConfirmation.subclass:
            return MasterConfirmation.subclass(*args_, **kwargs_)
        else:
            return MasterConfirmation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_masterConfirmationType(self): return self.masterConfirmationType
    def set_masterConfirmationType(self, masterConfirmationType): self.masterConfirmationType = masterConfirmationType
    def get_masterConfirmationDate(self): return self.masterConfirmationDate
    def set_masterConfirmationDate(self, masterConfirmationDate): self.masterConfirmationDate = masterConfirmationDate
    def get_masterConfirmationAnnexDate(self): return self.masterConfirmationAnnexDate
    def set_masterConfirmationAnnexDate(self, masterConfirmationAnnexDate): self.masterConfirmationAnnexDate = masterConfirmationAnnexDate
    def get_masterConfirmationAnnexType(self): return self.masterConfirmationAnnexType
    def set_masterConfirmationAnnexType(self, masterConfirmationAnnexType): self.masterConfirmationAnnexType = masterConfirmationAnnexType
    def hasContent_(self):
        if (
            self.masterConfirmationType is not None or
            self.masterConfirmationDate is not None or
            self.masterConfirmationAnnexDate is not None or
            self.masterConfirmationAnnexType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MasterConfirmation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MasterConfirmation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MasterConfirmation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MasterConfirmation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MasterConfirmation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.masterConfirmationType is not None:
            self.masterConfirmationType.export(outfile, level, namespace_, name_='masterConfirmationType', pretty_print=pretty_print)
        if self.masterConfirmationDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smasterConfirmationDate>%s</%smasterConfirmationDate>%s' % (namespace_, self.gds_format_date(self.masterConfirmationDate, input_name='masterConfirmationDate'), namespace_, eol_))
        if self.masterConfirmationAnnexDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smasterConfirmationAnnexDate>%s</%smasterConfirmationAnnexDate>%s' % (namespace_, self.gds_format_date(self.masterConfirmationAnnexDate, input_name='masterConfirmationAnnexDate'), namespace_, eol_))
        if self.masterConfirmationAnnexType is not None:
            self.masterConfirmationAnnexType.export(outfile, level, namespace_, name_='masterConfirmationAnnexType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'masterConfirmationType':
            obj_ = MasterConfirmationType.factory()
            obj_.build(child_)
            self.masterConfirmationType = obj_
            obj_.original_tagname_ = 'masterConfirmationType'
        elif nodeName_ == 'masterConfirmationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.masterConfirmationDate = dval_
        elif nodeName_ == 'masterConfirmationAnnexDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.masterConfirmationAnnexDate = dval_
        elif nodeName_ == 'masterConfirmationAnnexType':
            obj_ = MasterConfirmationAnnexType.factory()
            obj_.build(child_)
            self.masterConfirmationAnnexType = obj_
            obj_.original_tagname_ = 'masterConfirmationAnnexType'
# end class MasterConfirmation


class MasterConfirmationAnnexType(GeneratedsSuper):
    member_data_items_ = {
        'masterConfirmationAnnexTypeScheme': MemberSpec_('masterConfirmationAnnexTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, masterConfirmationAnnexTypeScheme='http://www.fpml.org/coding-scheme/master-confirmation-annex-type', valueOf_=None):
        self.original_tagname_ = None
        self.masterConfirmationAnnexTypeScheme = _cast(None, masterConfirmationAnnexTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MasterConfirmationAnnexType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MasterConfirmationAnnexType.subclass:
            return MasterConfirmationAnnexType.subclass(*args_, **kwargs_)
        else:
            return MasterConfirmationAnnexType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_masterConfirmationAnnexTypeScheme(self): return self.masterConfirmationAnnexTypeScheme
    def set_masterConfirmationAnnexTypeScheme(self, masterConfirmationAnnexTypeScheme): self.masterConfirmationAnnexTypeScheme = masterConfirmationAnnexTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MasterConfirmationAnnexType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MasterConfirmationAnnexType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MasterConfirmationAnnexType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MasterConfirmationAnnexType'):
        if self.masterConfirmationAnnexTypeScheme != "http://www.fpml.org/coding-scheme/master-confirmation-annex-type" and 'masterConfirmationAnnexTypeScheme' not in already_processed:
            already_processed.add('masterConfirmationAnnexTypeScheme')
            outfile.write(' masterConfirmationAnnexTypeScheme=%s' % (quote_attrib(self.masterConfirmationAnnexTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MasterConfirmationAnnexType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('masterConfirmationAnnexTypeScheme', node)
        if value is not None and 'masterConfirmationAnnexTypeScheme' not in already_processed:
            already_processed.add('masterConfirmationAnnexTypeScheme')
            self.masterConfirmationAnnexTypeScheme = value
            self.validate_NonEmptyURI(self.masterConfirmationAnnexTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MasterConfirmationAnnexType


class MasterConfirmationType(GeneratedsSuper):
    member_data_items_ = {
        'masterConfirmationTypeScheme': MemberSpec_('masterConfirmationTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, masterConfirmationTypeScheme='http://www.fpml.org/coding-scheme/master-confirmation-type', valueOf_=None):
        self.original_tagname_ = None
        self.masterConfirmationTypeScheme = _cast(None, masterConfirmationTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MasterConfirmationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MasterConfirmationType.subclass:
            return MasterConfirmationType.subclass(*args_, **kwargs_)
        else:
            return MasterConfirmationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_masterConfirmationTypeScheme(self): return self.masterConfirmationTypeScheme
    def set_masterConfirmationTypeScheme(self, masterConfirmationTypeScheme): self.masterConfirmationTypeScheme = masterConfirmationTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MasterConfirmationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MasterConfirmationType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MasterConfirmationType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MasterConfirmationType'):
        if self.masterConfirmationTypeScheme != "http://www.fpml.org/coding-scheme/master-confirmation-type" and 'masterConfirmationTypeScheme' not in already_processed:
            already_processed.add('masterConfirmationTypeScheme')
            outfile.write(' masterConfirmationTypeScheme=%s' % (quote_attrib(self.masterConfirmationTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MasterConfirmationType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('masterConfirmationTypeScheme', node)
        if value is not None and 'masterConfirmationTypeScheme' not in already_processed:
            already_processed.add('masterConfirmationTypeScheme')
            self.masterConfirmationTypeScheme = value
            self.validate_NonEmptyURI(self.masterConfirmationTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MasterConfirmationType


class MatchId(GeneratedsSuper):
    """An identifier used to identify matched cashflows."""
    member_data_items_ = {
        'matchIdScheme': MemberSpec_('matchIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, matchIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.matchIdScheme = _cast(None, matchIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MatchId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MatchId.subclass:
            return MatchId.subclass(*args_, **kwargs_)
        else:
            return MatchId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_matchIdScheme(self): return self.matchIdScheme
    def set_matchIdScheme(self, matchIdScheme): self.matchIdScheme = matchIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MatchId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MatchId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MatchId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MatchId'):
        if self.matchIdScheme is not None and 'matchIdScheme' not in already_processed:
            already_processed.add('matchIdScheme')
            outfile.write(' matchIdScheme=%s' % (quote_attrib(self.matchIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MatchId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('matchIdScheme', node)
        if value is not None and 'matchIdScheme' not in already_processed:
            already_processed.add('matchIdScheme')
            self.matchIdScheme = value
            self.validate_NonEmptyURI(self.matchIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MatchId


class Math(GeneratedsSuper):
    """A type defining a mathematical expression."""
    member_data_items_ = {
        '': MemberSpec_('', 'xsd:string', 1),
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Math)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Math.subclass:
            return Math.subclass(*args_, **kwargs_)
        else:
            return Math(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Math', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Math')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Math', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Math'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Math', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class Math


class MatrixType(GeneratedsSuper):
    member_data_items_ = {
        'matrixTypeScheme': MemberSpec_('matrixTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, matrixTypeScheme='http://www.fpml.org/coding-scheme/matrix-type', valueOf_=None):
        self.original_tagname_ = None
        self.matrixTypeScheme = _cast(None, matrixTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MatrixType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MatrixType.subclass:
            return MatrixType.subclass(*args_, **kwargs_)
        else:
            return MatrixType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_matrixTypeScheme(self): return self.matrixTypeScheme
    def set_matrixTypeScheme(self, matrixTypeScheme): self.matrixTypeScheme = matrixTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MatrixType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MatrixType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MatrixType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MatrixType'):
        if self.matrixTypeScheme != "http://www.fpml.org/coding-scheme/matrix-type" and 'matrixTypeScheme' not in already_processed:
            already_processed.add('matrixTypeScheme')
            outfile.write(' matrixTypeScheme=%s' % (quote_attrib(self.matrixTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MatrixType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('matrixTypeScheme', node)
        if value is not None and 'matrixTypeScheme' not in already_processed:
            already_processed.add('matrixTypeScheme')
            self.matrixTypeScheme = value
            self.validate_NonEmptyURI(self.matrixTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MatrixType


class MatrixTerm(GeneratedsSuper):
    member_data_items_ = {
        'matrixTermScheme': MemberSpec_('matrixTermScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, matrixTermScheme='http://www.fpml.org/coding-scheme/credit-matrix-transaction-type', valueOf_=None):
        self.original_tagname_ = None
        self.matrixTermScheme = _cast(None, matrixTermScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MatrixTerm)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MatrixTerm.subclass:
            return MatrixTerm.subclass(*args_, **kwargs_)
        else:
            return MatrixTerm(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_matrixTermScheme(self): return self.matrixTermScheme
    def set_matrixTermScheme(self, matrixTermScheme): self.matrixTermScheme = matrixTermScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MatrixTerm', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MatrixTerm')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MatrixTerm', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MatrixTerm'):
        if self.matrixTermScheme != "http://www.fpml.org/coding-scheme/credit-matrix-transaction-type" and 'matrixTermScheme' not in already_processed:
            already_processed.add('matrixTermScheme')
            outfile.write(' matrixTermScheme=%s' % (quote_attrib(self.matrixTermScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MatrixTerm', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('matrixTermScheme', node)
        if value is not None and 'matrixTermScheme' not in already_processed:
            already_processed.add('matrixTermScheme')
            self.matrixTermScheme = value
            self.validate_NonEmptyURI(self.matrixTermScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MatrixTerm


class MimeType(GeneratedsSuper):
    """The type that indicates the type of media used to store the content.
    MimeType is used to determine the software product(s) that can
    read the content. MIME types are described in RFC 2046."""
    member_data_items_ = {
        'mimeTypeScheme': MemberSpec_('mimeTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, mimeTypeScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.mimeTypeScheme = _cast(None, mimeTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MimeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MimeType.subclass:
            return MimeType.subclass(*args_, **kwargs_)
        else:
            return MimeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mimeTypeScheme(self): return self.mimeTypeScheme
    def set_mimeTypeScheme(self, mimeTypeScheme): self.mimeTypeScheme = mimeTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MimeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MimeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MimeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MimeType'):
        if self.mimeTypeScheme is not None and 'mimeTypeScheme' not in already_processed:
            already_processed.add('mimeTypeScheme')
            outfile.write(' mimeTypeScheme=%s' % (quote_attrib(self.mimeTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MimeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mimeTypeScheme', node)
        if value is not None and 'mimeTypeScheme' not in already_processed:
            already_processed.add('mimeTypeScheme')
            self.mimeTypeScheme = value
            self.validate_NonEmptyURI(self.mimeTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MimeType


class MoneyBase(GeneratedsSuper):
    """Abstract base class for all money types."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'currency': MemberSpec_('currency', 'Currency', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, currency=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.currency = currency
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MoneyBase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MoneyBase.subclass:
            return MoneyBase.subclass(*args_, **kwargs_)
        else:
            return MoneyBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.currency is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MoneyBase', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MoneyBase')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MoneyBase', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MoneyBase'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='MoneyBase', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.currency is not None:
            self.currency.export(outfile, level, namespace_, name_='currency', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'currency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
# end class MoneyBase


class MultipleExercise(GeneratedsSuper):
    """A type defining multiple exercises. As defining in the 2000 ISDA
    Definitions, Section 12.4. Multiple Exercise, the buyer of the
    option has the right to exercise all or less than all the
    unexercised notional amount of the underlying swap on one or
    more days in the exercise period, but on any such day may not
    exercise less than the minimum notional amount or more than the
    maximum notional amount, and if an integral multiple amount is
    specified, the notional exercised must be equal to or, be an
    integral multiple of, the integral multiple amount."""
    member_data_items_ = {
        'notionalReference': MemberSpec_('notionalReference', 'NotionalReference', 1),
        'integralMultipleAmount': MemberSpec_('integralMultipleAmount', 'xsd:decimal', 0),
        'minimumNotionalAmount': MemberSpec_('minimumNotionalAmount', 'xsd:decimal', 0),
        'minimumNumberOfOptions': MemberSpec_('minimumNumberOfOptions', 'xsd:nonNegativeInteger', 0),
        'maximumNotionalAmount': MemberSpec_('maximumNotionalAmount', 'xsd:decimal', 0),
        'maximumNumberOfOptions': MemberSpec_('maximumNumberOfOptions', ['NonNegativeDecimal', 'xsd:decimal'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, notionalReference=None, integralMultipleAmount=None, minimumNotionalAmount=None, minimumNumberOfOptions=None, maximumNotionalAmount=None, maximumNumberOfOptions=None):
        self.original_tagname_ = None
        if notionalReference is None:
            self.notionalReference = []
        else:
            self.notionalReference = notionalReference
        self.integralMultipleAmount = integralMultipleAmount
        self.minimumNotionalAmount = minimumNotionalAmount
        self.minimumNumberOfOptions = minimumNumberOfOptions
        self.maximumNotionalAmount = maximumNotionalAmount
        self.maximumNumberOfOptions = maximumNumberOfOptions
        self.validate_NonNegativeDecimal(self.maximumNumberOfOptions)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MultipleExercise)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MultipleExercise.subclass:
            return MultipleExercise.subclass(*args_, **kwargs_)
        else:
            return MultipleExercise(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_notionalReference(self): return self.notionalReference
    def set_notionalReference(self, notionalReference): self.notionalReference = notionalReference
    def add_notionalReference(self, value): self.notionalReference.append(value)
    def insert_notionalReference_at(self, index, value): self.notionalReference.insert(index, value)
    def replace_notionalReference_at(self, index, value): self.notionalReference[index] = value
    def get_integralMultipleAmount(self): return self.integralMultipleAmount
    def set_integralMultipleAmount(self, integralMultipleAmount): self.integralMultipleAmount = integralMultipleAmount
    def get_minimumNotionalAmount(self): return self.minimumNotionalAmount
    def set_minimumNotionalAmount(self, minimumNotionalAmount): self.minimumNotionalAmount = minimumNotionalAmount
    def get_minimumNumberOfOptions(self): return self.minimumNumberOfOptions
    def set_minimumNumberOfOptions(self, minimumNumberOfOptions): self.minimumNumberOfOptions = minimumNumberOfOptions
    def get_maximumNotionalAmount(self): return self.maximumNotionalAmount
    def set_maximumNotionalAmount(self, maximumNotionalAmount): self.maximumNotionalAmount = maximumNotionalAmount
    def get_maximumNumberOfOptions(self): return self.maximumNumberOfOptions
    def set_maximumNumberOfOptions(self, maximumNumberOfOptions): self.maximumNumberOfOptions = maximumNumberOfOptions
    def validate_NonNegativeDecimal(self, value):
        # Validate type NonNegativeDecimal, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on NonNegativeDecimal' % {"value" : value} )
    def hasContent_(self):
        if (
            self.notionalReference or
            self.integralMultipleAmount is not None or
            self.minimumNotionalAmount is not None or
            self.minimumNumberOfOptions is not None or
            self.maximumNotionalAmount is not None or
            self.maximumNumberOfOptions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MultipleExercise', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MultipleExercise')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MultipleExercise', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MultipleExercise'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MultipleExercise', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for notionalReference_ in self.notionalReference:
            notionalReference_.export(outfile, level, namespace_, name_='notionalReference', pretty_print=pretty_print)
        if self.integralMultipleAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sintegralMultipleAmount>%s</%sintegralMultipleAmount>%s' % (namespace_, self.gds_format_float(self.integralMultipleAmount, input_name='integralMultipleAmount'), namespace_, eol_))
        if self.minimumNotionalAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sminimumNotionalAmount>%s</%sminimumNotionalAmount>%s' % (namespace_, self.gds_format_float(self.minimumNotionalAmount, input_name='minimumNotionalAmount'), namespace_, eol_))
        if self.minimumNumberOfOptions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sminimumNumberOfOptions>%s</%sminimumNumberOfOptions>%s' % (namespace_, self.gds_format_integer(self.minimumNumberOfOptions, input_name='minimumNumberOfOptions'), namespace_, eol_))
        if self.maximumNotionalAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaximumNotionalAmount>%s</%smaximumNotionalAmount>%s' % (namespace_, self.gds_format_float(self.maximumNotionalAmount, input_name='maximumNotionalAmount'), namespace_, eol_))
        if self.maximumNumberOfOptions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaximumNumberOfOptions>%s</%smaximumNumberOfOptions>%s' % (namespace_, self.gds_format_float(self.maximumNumberOfOptions, input_name='maximumNumberOfOptions'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'notionalReference':
            obj_ = NotionalReference.factory()
            obj_.build(child_)
            self.notionalReference.append(obj_)
            obj_.original_tagname_ = 'notionalReference'
        elif nodeName_ == 'integralMultipleAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'integralMultipleAmount')
            self.integralMultipleAmount = fval_
        elif nodeName_ == 'minimumNotionalAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'minimumNotionalAmount')
            self.minimumNotionalAmount = fval_
        elif nodeName_ == 'minimumNumberOfOptions':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'minimumNumberOfOptions')
            self.minimumNumberOfOptions = ival_
        elif nodeName_ == 'maximumNotionalAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'maximumNotionalAmount')
            self.maximumNotionalAmount = fval_
        elif nodeName_ == 'maximumNumberOfOptions':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'maximumNumberOfOptions')
            self.maximumNumberOfOptions = fval_
            # validate type NonNegativeDecimal
            self.validate_NonNegativeDecimal(self.maximumNumberOfOptions)
# end class MultipleExercise


class NonNegativeMoney(MoneyBase):
    """A type defining a non negative money amount."""
    member_data_items_ = {
        'amount': MemberSpec_('amount', ['NonNegativeDecimal', 'xsd:decimal'], 0),
    }
    subclass = None
    superclass = MoneyBase
    def __init__(self, id=None, currency=None, amount=None, extensiontype_=None):
        self.original_tagname_ = None
        super(NonNegativeMoney, self).__init__(id, currency, extensiontype_, )
        self.amount = amount
        self.validate_NonNegativeDecimal(self.amount)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NonNegativeMoney)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NonNegativeMoney.subclass:
            return NonNegativeMoney.subclass(*args_, **kwargs_)
        else:
            return NonNegativeMoney(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_amount(self): return self.amount
    def set_amount(self, amount): self.amount = amount
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_NonNegativeDecimal(self, value):
        # Validate type NonNegativeDecimal, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on NonNegativeDecimal' % {"value" : value} )
    def hasContent_(self):
        if (
            self.amount is not None or
            super(NonNegativeMoney, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NonNegativeMoney', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NonNegativeMoney')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NonNegativeMoney', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NonNegativeMoney'):
        super(NonNegativeMoney, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NonNegativeMoney')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='NonNegativeMoney', fromsubclass_=False, pretty_print=True):
        super(NonNegativeMoney, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.amount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%samount>%s</%samount>%s' % (namespace_, self.gds_format_float(self.amount, input_name='amount'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(NonNegativeMoney, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'amount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'amount')
            self.amount = fval_
            # validate type NonNegativeDecimal
            self.validate_NonNegativeDecimal(self.amount)
        super(NonNegativeMoney, self).buildChildren(child_, node, nodeName_, True)
# end class NonNegativeMoney


class NonNegativeSchedule(GeneratedsSuper):
    """A type defining a schedule of non-negative rates or amounts in terms
    of an initial value and then a series of step date and value
    pairs. On each step date the rate or amount changes to the new
    step value. The series of step date and value pairs are
    optional. If not specified, this implies that the initial value
    remains unchanged over time."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'initialValue': MemberSpec_('initialValue', ['NonNegativeDecimal', 'xsd:decimal'], 0),
        'step': MemberSpec_('step', 'NonNegativeStep', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, initialValue=None, step=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.initialValue = initialValue
        self.validate_NonNegativeDecimal(self.initialValue)
        if step is None:
            self.step = []
        else:
            self.step = step
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NonNegativeSchedule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NonNegativeSchedule.subclass:
            return NonNegativeSchedule.subclass(*args_, **kwargs_)
        else:
            return NonNegativeSchedule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_initialValue(self): return self.initialValue
    def set_initialValue(self, initialValue): self.initialValue = initialValue
    def get_step(self): return self.step
    def set_step(self, step): self.step = step
    def add_step(self, value): self.step.append(value)
    def insert_step_at(self, index, value): self.step.insert(index, value)
    def replace_step_at(self, index, value): self.step[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_NonNegativeDecimal(self, value):
        # Validate type NonNegativeDecimal, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on NonNegativeDecimal' % {"value" : value} )
    def hasContent_(self):
        if (
            self.initialValue is not None or
            self.step
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NonNegativeSchedule', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NonNegativeSchedule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NonNegativeSchedule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NonNegativeSchedule'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='NonNegativeSchedule', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.initialValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinitialValue>%s</%sinitialValue>%s' % (namespace_, self.gds_format_float(self.initialValue, input_name='initialValue'), namespace_, eol_))
        for step_ in self.step:
            step_.export(outfile, level, namespace_, name_='step', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'initialValue':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'initialValue')
            self.initialValue = fval_
            # validate type NonNegativeDecimal
            self.validate_NonNegativeDecimal(self.initialValue)
        elif nodeName_ == 'step':
            obj_ = NonNegativeStep.factory()
            obj_.build(child_)
            self.step.append(obj_)
            obj_.original_tagname_ = 'step'
# end class NonNegativeSchedule


class NotionalAmount(NonNegativeMoney):
    """A complex type to specify the notional amount."""
    member_data_items_ = {
    }
    subclass = None
    superclass = NonNegativeMoney
    def __init__(self, id=None, currency=None, amount=None):
        self.original_tagname_ = None
        super(NotionalAmount, self).__init__(id, currency, amount, )
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NotionalAmount)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NotionalAmount.subclass:
            return NotionalAmount.subclass(*args_, **kwargs_)
        else:
            return NotionalAmount(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(NotionalAmount, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NotionalAmount', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NotionalAmount')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NotionalAmount', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NotionalAmount'):
        super(NotionalAmount, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NotionalAmount')
    def exportChildren(self, outfile, level, namespace_='', name_='NotionalAmount', fromsubclass_=False, pretty_print=True):
        super(NotionalAmount, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NotionalAmount, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(NotionalAmount, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class NotionalAmount


class OffsetPrevailingTime(GeneratedsSuper):
    """Allows the specification of a time that may be on a day prior or
    subsequent to the day in question. This type is intended for use
    with a day of the week (i.e. where no actual date is specified)
    as part of, for example, a period that runs from 23:00-07:00 on
    a series of days and where holidays on the actual days would
    affect the entire time period."""
    member_data_items_ = {
        'time': MemberSpec_('time', 'PrevailingTime', 0),
        'offset': MemberSpec_('offset', 'Offset', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, time=None, offset=None):
        self.original_tagname_ = None
        self.time = time
        self.offset = offset
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OffsetPrevailingTime)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OffsetPrevailingTime.subclass:
            return OffsetPrevailingTime.subclass(*args_, **kwargs_)
        else:
            return OffsetPrevailingTime(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_time(self): return self.time
    def set_time(self, time): self.time = time
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def hasContent_(self):
        if (
            self.time is not None or
            self.offset is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OffsetPrevailingTime', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OffsetPrevailingTime')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OffsetPrevailingTime', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OffsetPrevailingTime'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OffsetPrevailingTime', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.time is not None:
            self.time.export(outfile, level, namespace_, name_='time', pretty_print=pretty_print)
        if self.offset is not None:
            self.offset.export(outfile, level, namespace_, name_='offset', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'time':
            obj_ = PrevailingTime.factory()
            obj_.build(child_)
            self.time = obj_
            obj_.original_tagname_ = 'time'
        elif nodeName_ == 'offset':
            class_obj_ = self.get_class_obj_(child_, Offset)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.offset = obj_
            obj_.original_tagname_ = 'offset'
# end class OffsetPrevailingTime


class OnBehalfOf(GeneratedsSuper):
    member_data_items_ = {
        'partyReference': MemberSpec_('partyReference', 'PartyReference', 0),
        'accountReference': MemberSpec_('accountReference', 'AccountReference', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, partyReference=None, accountReference=None):
        self.original_tagname_ = None
        self.partyReference = partyReference
        if accountReference is None:
            self.accountReference = []
        else:
            self.accountReference = accountReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OnBehalfOf)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OnBehalfOf.subclass:
            return OnBehalfOf.subclass(*args_, **kwargs_)
        else:
            return OnBehalfOf(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyReference(self): return self.partyReference
    def set_partyReference(self, partyReference): self.partyReference = partyReference
    def get_accountReference(self): return self.accountReference
    def set_accountReference(self, accountReference): self.accountReference = accountReference
    def add_accountReference(self, value): self.accountReference.append(value)
    def insert_accountReference_at(self, index, value): self.accountReference.insert(index, value)
    def replace_accountReference_at(self, index, value): self.accountReference[index] = value
    def hasContent_(self):
        if (
            self.partyReference is not None or
            self.accountReference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OnBehalfOf', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OnBehalfOf')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OnBehalfOf', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OnBehalfOf'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OnBehalfOf', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.partyReference is not None:
            self.partyReference.export(outfile, level, namespace_, name_='partyReference', pretty_print=pretty_print)
        for accountReference_ in self.accountReference:
            accountReference_.export(outfile, level, namespace_, name_='accountReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'partyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.partyReference = obj_
            obj_.original_tagname_ = 'partyReference'
        elif nodeName_ == 'accountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.accountReference.append(obj_)
            obj_.original_tagname_ = 'accountReference'
# end class OnBehalfOf


class OrganizationType(GeneratedsSuper):
    """A code that describes what type of role an organization plays, for
    example a SwapsDealer, a Major Swaps Participant, or Other"""
    member_data_items_ = {
        'organizationTypeScheme': MemberSpec_('organizationTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, organizationTypeScheme='http://www.fpml.org/coding-scheme/organization-type', valueOf_=None):
        self.original_tagname_ = None
        self.organizationTypeScheme = _cast(None, organizationTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OrganizationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OrganizationType.subclass:
            return OrganizationType.subclass(*args_, **kwargs_)
        else:
            return OrganizationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_organizationTypeScheme(self): return self.organizationTypeScheme
    def set_organizationTypeScheme(self, organizationTypeScheme): self.organizationTypeScheme = organizationTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OrganizationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OrganizationType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OrganizationType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OrganizationType'):
        if self.organizationTypeScheme != "http://www.fpml.org/coding-scheme/organization-type" and 'organizationTypeScheme' not in already_processed:
            already_processed.add('organizationTypeScheme')
            outfile.write(' organizationTypeScheme=%s' % (quote_attrib(self.organizationTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OrganizationType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('organizationTypeScheme', node)
        if value is not None and 'organizationTypeScheme' not in already_processed:
            already_processed.add('organizationTypeScheme')
            self.organizationTypeScheme = value
            self.validate_NonEmptyURI(self.organizationTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OrganizationType


class OriginatingEvent(GeneratedsSuper):
    member_data_items_ = {
        'originatingEventScheme': MemberSpec_('originatingEventScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, originatingEventScheme='http://www.fpml.org/coding-scheme/originating-event', valueOf_=None):
        self.original_tagname_ = None
        self.originatingEventScheme = _cast(None, originatingEventScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OriginatingEvent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OriginatingEvent.subclass:
            return OriginatingEvent.subclass(*args_, **kwargs_)
        else:
            return OriginatingEvent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_originatingEventScheme(self): return self.originatingEventScheme
    def set_originatingEventScheme(self, originatingEventScheme): self.originatingEventScheme = originatingEventScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OriginatingEvent', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OriginatingEvent')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OriginatingEvent', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OriginatingEvent'):
        if self.originatingEventScheme != "http://www.fpml.org/coding-scheme/originating-event" and 'originatingEventScheme' not in already_processed:
            already_processed.add('originatingEventScheme')
            outfile.write(' originatingEventScheme=%s' % (quote_attrib(self.originatingEventScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OriginatingEvent', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('originatingEventScheme', node)
        if value is not None and 'originatingEventScheme' not in already_processed:
            already_processed.add('originatingEventScheme')
            self.originatingEventScheme = value
            self.validate_NonEmptyURI(self.originatingEventScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OriginatingEvent


class PartialExercise(GeneratedsSuper):
    """A type defining partial exercise. As defined in the 2000 ISDA
    Definitions, Section 12.3 Partial Exercise, the buyer of the
    option may exercise all or less than all the notional amount of
    the underlying swap but may not be less than the minimum
    notional amount (if specified) and must be an integral multiple
    of the integral multiple amount if specified."""
    member_data_items_ = {
        'notionalReference': MemberSpec_('notionalReference', 'NotionalReference', 1),
        'integralMultipleAmount': MemberSpec_('integralMultipleAmount', 'xsd:decimal', 0),
        'minimumNotionalAmount': MemberSpec_('minimumNotionalAmount', 'xsd:decimal', 0),
        'minimumNumberOfOptions': MemberSpec_('minimumNumberOfOptions', 'xsd:nonNegativeInteger', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, notionalReference=None, integralMultipleAmount=None, minimumNotionalAmount=None, minimumNumberOfOptions=None):
        self.original_tagname_ = None
        if notionalReference is None:
            self.notionalReference = []
        else:
            self.notionalReference = notionalReference
        self.integralMultipleAmount = integralMultipleAmount
        self.minimumNotionalAmount = minimumNotionalAmount
        self.minimumNumberOfOptions = minimumNumberOfOptions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartialExercise)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartialExercise.subclass:
            return PartialExercise.subclass(*args_, **kwargs_)
        else:
            return PartialExercise(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_notionalReference(self): return self.notionalReference
    def set_notionalReference(self, notionalReference): self.notionalReference = notionalReference
    def add_notionalReference(self, value): self.notionalReference.append(value)
    def insert_notionalReference_at(self, index, value): self.notionalReference.insert(index, value)
    def replace_notionalReference_at(self, index, value): self.notionalReference[index] = value
    def get_integralMultipleAmount(self): return self.integralMultipleAmount
    def set_integralMultipleAmount(self, integralMultipleAmount): self.integralMultipleAmount = integralMultipleAmount
    def get_minimumNotionalAmount(self): return self.minimumNotionalAmount
    def set_minimumNotionalAmount(self, minimumNotionalAmount): self.minimumNotionalAmount = minimumNotionalAmount
    def get_minimumNumberOfOptions(self): return self.minimumNumberOfOptions
    def set_minimumNumberOfOptions(self, minimumNumberOfOptions): self.minimumNumberOfOptions = minimumNumberOfOptions
    def hasContent_(self):
        if (
            self.notionalReference or
            self.integralMultipleAmount is not None or
            self.minimumNotionalAmount is not None or
            self.minimumNumberOfOptions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartialExercise', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartialExercise')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartialExercise', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartialExercise'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PartialExercise', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for notionalReference_ in self.notionalReference:
            notionalReference_.export(outfile, level, namespace_, name_='notionalReference', pretty_print=pretty_print)
        if self.integralMultipleAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sintegralMultipleAmount>%s</%sintegralMultipleAmount>%s' % (namespace_, self.gds_format_float(self.integralMultipleAmount, input_name='integralMultipleAmount'), namespace_, eol_))
        if self.minimumNotionalAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sminimumNotionalAmount>%s</%sminimumNotionalAmount>%s' % (namespace_, self.gds_format_float(self.minimumNotionalAmount, input_name='minimumNotionalAmount'), namespace_, eol_))
        if self.minimumNumberOfOptions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sminimumNumberOfOptions>%s</%sminimumNumberOfOptions>%s' % (namespace_, self.gds_format_integer(self.minimumNumberOfOptions, input_name='minimumNumberOfOptions'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'notionalReference':
            obj_ = NotionalReference.factory()
            obj_.build(child_)
            self.notionalReference.append(obj_)
            obj_.original_tagname_ = 'notionalReference'
        elif nodeName_ == 'integralMultipleAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'integralMultipleAmount')
            self.integralMultipleAmount = fval_
        elif nodeName_ == 'minimumNotionalAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'minimumNotionalAmount')
            self.minimumNotionalAmount = fval_
        elif nodeName_ == 'minimumNumberOfOptions':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'minimumNumberOfOptions')
            self.minimumNumberOfOptions = ival_
# end class PartialExercise


class Party(GeneratedsSuper):
    """A type defining a legal entity or a subdivision of a legal
    entity.Parties can perform multiple roles in a trade lifecycle.
    For example, the principal parties obligated to make payments
    from time to time during the term of the trade, but may include
    other parties involved in, or incidental to, the trade, such as
    parties acting in the role of novation transferor/transferee,
    broker, calculation agent, etc. In FpML roles are defined in
    multiple places within a document.A group of parties acting as a
    single party (e.g. joint and several).The id uniquely
    identifying the Party within the document."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'partyId': MemberSpec_('partyId', 'PartyId', 1),
        'partyName': MemberSpec_('partyName', 'PartyName', 0),
        'classification': MemberSpec_('classification', 'IndustryClassification', 1),
        'creditRating': MemberSpec_('creditRating', 'CreditRating', 1),
        'country': MemberSpec_('country', 'CountryCode', 0),
        'region': MemberSpec_('region', 'Region', 1),
        'jurisdiction': MemberSpec_('jurisdiction', 'GoverningLaw', 1),
        'organizationType': MemberSpec_('organizationType', 'OrganizationType', 0),
        'relatedParty': MemberSpec_('relatedParty', 'PartyRelationship', 1),
        'contactInfo': MemberSpec_('contactInfo', 'ContactInformation', 0),
        'businessUnit': MemberSpec_('businessUnit', 'BusinessUnit', 1),
        'person': MemberSpec_('person', 'Person', 1),
        'groupType': MemberSpec_('groupType', 'PartyGroupType', 0),
        'partyReference': MemberSpec_('partyReference', 'PartyReference', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, partyId=None, partyName=None, classification=None, creditRating=None, country=None, region=None, jurisdiction=None, organizationType=None, relatedParty=None, contactInfo=None, businessUnit=None, person=None, groupType=None, partyReference=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if partyId is None:
            self.partyId = []
        else:
            self.partyId = partyId
        self.partyName = partyName
        if classification is None:
            self.classification = []
        else:
            self.classification = classification
        if creditRating is None:
            self.creditRating = []
        else:
            self.creditRating = creditRating
        self.country = country
        if region is None:
            self.region = []
        else:
            self.region = region
        if jurisdiction is None:
            self.jurisdiction = []
        else:
            self.jurisdiction = jurisdiction
        self.organizationType = organizationType
        if relatedParty is None:
            self.relatedParty = []
        else:
            self.relatedParty = relatedParty
        self.contactInfo = contactInfo
        if businessUnit is None:
            self.businessUnit = []
        else:
            self.businessUnit = businessUnit
        if person is None:
            self.person = []
        else:
            self.person = person
        self.groupType = groupType
        if partyReference is None:
            self.partyReference = []
        else:
            self.partyReference = partyReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Party)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Party.subclass:
            return Party.subclass(*args_, **kwargs_)
        else:
            return Party(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyId(self): return self.partyId
    def set_partyId(self, partyId): self.partyId = partyId
    def add_partyId(self, value): self.partyId.append(value)
    def insert_partyId_at(self, index, value): self.partyId.insert(index, value)
    def replace_partyId_at(self, index, value): self.partyId[index] = value
    def get_partyName(self): return self.partyName
    def set_partyName(self, partyName): self.partyName = partyName
    def get_classification(self): return self.classification
    def set_classification(self, classification): self.classification = classification
    def add_classification(self, value): self.classification.append(value)
    def insert_classification_at(self, index, value): self.classification.insert(index, value)
    def replace_classification_at(self, index, value): self.classification[index] = value
    def get_creditRating(self): return self.creditRating
    def set_creditRating(self, creditRating): self.creditRating = creditRating
    def add_creditRating(self, value): self.creditRating.append(value)
    def insert_creditRating_at(self, index, value): self.creditRating.insert(index, value)
    def replace_creditRating_at(self, index, value): self.creditRating[index] = value
    def get_country(self): return self.country
    def set_country(self, country): self.country = country
    def get_region(self): return self.region
    def set_region(self, region): self.region = region
    def add_region(self, value): self.region.append(value)
    def insert_region_at(self, index, value): self.region.insert(index, value)
    def replace_region_at(self, index, value): self.region[index] = value
    def get_jurisdiction(self): return self.jurisdiction
    def set_jurisdiction(self, jurisdiction): self.jurisdiction = jurisdiction
    def add_jurisdiction(self, value): self.jurisdiction.append(value)
    def insert_jurisdiction_at(self, index, value): self.jurisdiction.insert(index, value)
    def replace_jurisdiction_at(self, index, value): self.jurisdiction[index] = value
    def get_organizationType(self): return self.organizationType
    def set_organizationType(self, organizationType): self.organizationType = organizationType
    def get_relatedParty(self): return self.relatedParty
    def set_relatedParty(self, relatedParty): self.relatedParty = relatedParty
    def add_relatedParty(self, value): self.relatedParty.append(value)
    def insert_relatedParty_at(self, index, value): self.relatedParty.insert(index, value)
    def replace_relatedParty_at(self, index, value): self.relatedParty[index] = value
    def get_contactInfo(self): return self.contactInfo
    def set_contactInfo(self, contactInfo): self.contactInfo = contactInfo
    def get_businessUnit(self): return self.businessUnit
    def set_businessUnit(self, businessUnit): self.businessUnit = businessUnit
    def add_businessUnit(self, value): self.businessUnit.append(value)
    def insert_businessUnit_at(self, index, value): self.businessUnit.insert(index, value)
    def replace_businessUnit_at(self, index, value): self.businessUnit[index] = value
    def get_person(self): return self.person
    def set_person(self, person): self.person = person
    def add_person(self, value): self.person.append(value)
    def insert_person_at(self, index, value): self.person.insert(index, value)
    def replace_person_at(self, index, value): self.person[index] = value
    def get_groupType(self): return self.groupType
    def set_groupType(self, groupType): self.groupType = groupType
    def get_partyReference(self): return self.partyReference
    def set_partyReference(self, partyReference): self.partyReference = partyReference
    def add_partyReference(self, value): self.partyReference.append(value)
    def insert_partyReference_at(self, index, value): self.partyReference.insert(index, value)
    def replace_partyReference_at(self, index, value): self.partyReference[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.partyId or
            self.partyName is not None or
            self.classification or
            self.creditRating or
            self.country is not None or
            self.region or
            self.jurisdiction or
            self.organizationType is not None or
            self.relatedParty or
            self.contactInfo is not None or
            self.businessUnit or
            self.person or
            self.groupType is not None or
            self.partyReference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Party', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Party')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Party', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Party'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Party', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for partyId_ in self.partyId:
            partyId_.export(outfile, level, namespace_, name_='partyId', pretty_print=pretty_print)
        if self.partyName is not None:
            self.partyName.export(outfile, level, namespace_, name_='partyName', pretty_print=pretty_print)
        for classification_ in self.classification:
            classification_.export(outfile, level, namespace_, name_='classification', pretty_print=pretty_print)
        for creditRating_ in self.creditRating:
            creditRating_.export(outfile, level, namespace_, name_='creditRating', pretty_print=pretty_print)
        if self.country is not None:
            self.country.export(outfile, level, namespace_, name_='country', pretty_print=pretty_print)
        for region_ in self.region:
            region_.export(outfile, level, namespace_, name_='region', pretty_print=pretty_print)
        for jurisdiction_ in self.jurisdiction:
            jurisdiction_.export(outfile, level, namespace_, name_='jurisdiction', pretty_print=pretty_print)
        if self.organizationType is not None:
            self.organizationType.export(outfile, level, namespace_, name_='organizationType', pretty_print=pretty_print)
        for relatedParty_ in self.relatedParty:
            relatedParty_.export(outfile, level, namespace_, name_='relatedParty', pretty_print=pretty_print)
        if self.contactInfo is not None:
            self.contactInfo.export(outfile, level, namespace_, name_='contactInfo', pretty_print=pretty_print)
        for businessUnit_ in self.businessUnit:
            businessUnit_.export(outfile, level, namespace_, name_='businessUnit', pretty_print=pretty_print)
        for person_ in self.person:
            person_.export(outfile, level, namespace_, name_='person', pretty_print=pretty_print)
        if self.groupType is not None:
            self.groupType.export(outfile, level, namespace_, name_='groupType', pretty_print=pretty_print)
        for partyReference_ in self.partyReference:
            partyReference_.export(outfile, level, namespace_, name_='partyReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'partyId':
            obj_ = PartyId.factory()
            obj_.build(child_)
            self.partyId.append(obj_)
            obj_.original_tagname_ = 'partyId'
        elif nodeName_ == 'partyName':
            obj_ = PartyName.factory()
            obj_.build(child_)
            self.partyName = obj_
            obj_.original_tagname_ = 'partyName'
        elif nodeName_ == 'classification':
            obj_ = IndustryClassification.factory()
            obj_.build(child_)
            self.classification.append(obj_)
            obj_.original_tagname_ = 'classification'
        elif nodeName_ == 'creditRating':
            obj_ = CreditRating.factory()
            obj_.build(child_)
            self.creditRating.append(obj_)
            obj_.original_tagname_ = 'creditRating'
        elif nodeName_ == 'country':
            obj_ = CountryCode.factory()
            obj_.build(child_)
            self.country = obj_
            obj_.original_tagname_ = 'country'
        elif nodeName_ == 'region':
            obj_ = Region.factory()
            obj_.build(child_)
            self.region.append(obj_)
            obj_.original_tagname_ = 'region'
        elif nodeName_ == 'jurisdiction':
            obj_ = GoverningLaw.factory()
            obj_.build(child_)
            self.jurisdiction.append(obj_)
            obj_.original_tagname_ = 'jurisdiction'
        elif nodeName_ == 'organizationType':
            obj_ = OrganizationType.factory()
            obj_.build(child_)
            self.organizationType = obj_
            obj_.original_tagname_ = 'organizationType'
        elif nodeName_ == 'relatedParty':
            obj_ = PartyRelationship.factory()
            obj_.build(child_)
            self.relatedParty.append(obj_)
            obj_.original_tagname_ = 'relatedParty'
        elif nodeName_ == 'contactInfo':
            obj_ = ContactInformation.factory()
            obj_.build(child_)
            self.contactInfo = obj_
            obj_.original_tagname_ = 'contactInfo'
        elif nodeName_ == 'businessUnit':
            obj_ = BusinessUnit.factory()
            obj_.build(child_)
            self.businessUnit.append(obj_)
            obj_.original_tagname_ = 'businessUnit'
        elif nodeName_ == 'person':
            obj_ = Person.factory()
            obj_.build(child_)
            self.person.append(obj_)
            obj_.original_tagname_ = 'person'
        elif nodeName_ == 'groupType':
            obj_ = PartyGroupType.factory()
            obj_.build(child_)
            self.groupType = obj_
            obj_.original_tagname_ = 'groupType'
        elif nodeName_ == 'partyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.partyReference.append(obj_)
            obj_.original_tagname_ = 'partyReference'
# end class Party


class PartyContactInformation(GeneratedsSuper):
    member_data_items_ = {
        'partyReference': MemberSpec_('partyReference', 'PartyReference', 0),
        'contactInfo': MemberSpec_('contactInfo', 'ContactInformation', 0),
        'businessUnit': MemberSpec_('businessUnit', 'BusinessUnit', 1),
        'person': MemberSpec_('person', 'Person', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, partyReference=None, contactInfo=None, businessUnit=None, person=None):
        self.original_tagname_ = None
        self.partyReference = partyReference
        self.contactInfo = contactInfo
        if businessUnit is None:
            self.businessUnit = []
        else:
            self.businessUnit = businessUnit
        if person is None:
            self.person = []
        else:
            self.person = person
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyContactInformation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyContactInformation.subclass:
            return PartyContactInformation.subclass(*args_, **kwargs_)
        else:
            return PartyContactInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyReference(self): return self.partyReference
    def set_partyReference(self, partyReference): self.partyReference = partyReference
    def get_contactInfo(self): return self.contactInfo
    def set_contactInfo(self, contactInfo): self.contactInfo = contactInfo
    def get_businessUnit(self): return self.businessUnit
    def set_businessUnit(self, businessUnit): self.businessUnit = businessUnit
    def add_businessUnit(self, value): self.businessUnit.append(value)
    def insert_businessUnit_at(self, index, value): self.businessUnit.insert(index, value)
    def replace_businessUnit_at(self, index, value): self.businessUnit[index] = value
    def get_person(self): return self.person
    def set_person(self, person): self.person = person
    def add_person(self, value): self.person.append(value)
    def insert_person_at(self, index, value): self.person.insert(index, value)
    def replace_person_at(self, index, value): self.person[index] = value
    def hasContent_(self):
        if (
            self.partyReference is not None or
            self.contactInfo is not None or
            self.businessUnit or
            self.person
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartyContactInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyContactInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartyContactInformation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyContactInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PartyContactInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.partyReference is not None:
            self.partyReference.export(outfile, level, namespace_, name_='partyReference', pretty_print=pretty_print)
        if self.contactInfo is not None:
            self.contactInfo.export(outfile, level, namespace_, name_='contactInfo', pretty_print=pretty_print)
        for businessUnit_ in self.businessUnit:
            businessUnit_.export(outfile, level, namespace_, name_='businessUnit', pretty_print=pretty_print)
        for person_ in self.person:
            person_.export(outfile, level, namespace_, name_='person', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'partyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.partyReference = obj_
            obj_.original_tagname_ = 'partyReference'
        elif nodeName_ == 'contactInfo':
            obj_ = ContactInformation.factory()
            obj_.build(child_)
            self.contactInfo = obj_
            obj_.original_tagname_ = 'contactInfo'
        elif nodeName_ == 'businessUnit':
            obj_ = BusinessUnit.factory()
            obj_.build(child_)
            self.businessUnit.append(obj_)
            obj_.original_tagname_ = 'businessUnit'
        elif nodeName_ == 'person':
            obj_ = Person.factory()
            obj_.build(child_)
            self.person.append(obj_)
            obj_.original_tagname_ = 'person'
# end class PartyContactInformation


class PartyGroupType(GeneratedsSuper):
    """The data type used for party group classification."""
    member_data_items_ = {
        'partyGroupTypeScheme': MemberSpec_('partyGroupTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, partyGroupTypeScheme='http://www.fpml.org/coding-scheme/party-group-type', valueOf_=None):
        self.original_tagname_ = None
        self.partyGroupTypeScheme = _cast(None, partyGroupTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyGroupType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyGroupType.subclass:
            return PartyGroupType.subclass(*args_, **kwargs_)
        else:
            return PartyGroupType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyGroupTypeScheme(self): return self.partyGroupTypeScheme
    def set_partyGroupTypeScheme(self, partyGroupTypeScheme): self.partyGroupTypeScheme = partyGroupTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartyGroupType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyGroupType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartyGroupType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyGroupType'):
        if self.partyGroupTypeScheme != "http://www.fpml.org/coding-scheme/party-group-type" and 'partyGroupTypeScheme' not in already_processed:
            already_processed.add('partyGroupTypeScheme')
            outfile.write(' partyGroupTypeScheme=%s' % (quote_attrib(self.partyGroupTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PartyGroupType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partyGroupTypeScheme', node)
        if value is not None and 'partyGroupTypeScheme' not in already_processed:
            already_processed.add('partyGroupTypeScheme')
            self.partyGroupTypeScheme = value
            self.validate_NonEmptyURI(self.partyGroupTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PartyGroupType


class PartyId(GeneratedsSuper):
    """The data type used for party identifiers."""
    member_data_items_ = {
        'partyIdScheme': MemberSpec_('partyIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, partyIdScheme='http://www.fpml.org/coding-scheme/external/iso9362', valueOf_=None):
        self.original_tagname_ = None
        self.partyIdScheme = _cast(None, partyIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyId.subclass:
            return PartyId.subclass(*args_, **kwargs_)
        else:
            return PartyId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyIdScheme(self): return self.partyIdScheme
    def set_partyIdScheme(self, partyIdScheme): self.partyIdScheme = partyIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartyId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartyId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyId'):
        if self.partyIdScheme != "http://www.fpml.org/coding-scheme/external/iso9362" and 'partyIdScheme' not in already_processed:
            already_processed.add('partyIdScheme')
            outfile.write(' partyIdScheme=%s' % (quote_attrib(self.partyIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PartyId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partyIdScheme', node)
        if value is not None and 'partyIdScheme' not in already_processed:
            already_processed.add('partyIdScheme')
            self.partyIdScheme = value
            self.validate_NonEmptyURI(self.partyIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PartyId


class PartyName(GeneratedsSuper):
    """The data type used for the legal name of an organization."""
    member_data_items_ = {
        'partyNameScheme': MemberSpec_('partyNameScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, partyNameScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.partyNameScheme = _cast(None, partyNameScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyName)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyName.subclass:
            return PartyName.subclass(*args_, **kwargs_)
        else:
            return PartyName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyNameScheme(self): return self.partyNameScheme
    def set_partyNameScheme(self, partyNameScheme): self.partyNameScheme = partyNameScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartyName', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyName')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartyName', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyName'):
        if self.partyNameScheme is not None and 'partyNameScheme' not in already_processed:
            already_processed.add('partyNameScheme')
            outfile.write(' partyNameScheme=%s' % (quote_attrib(self.partyNameScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PartyName', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partyNameScheme', node)
        if value is not None and 'partyNameScheme' not in already_processed:
            already_processed.add('partyNameScheme')
            self.partyNameScheme = value
            self.validate_NonEmptyURI(self.partyNameScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PartyName


class PartyRelationship(GeneratedsSuper):
    member_data_items_ = {
        'partyReference': MemberSpec_('partyReference', 'PartyReference', 0),
        'accountReference': MemberSpec_('accountReference', 'AccountReference', 0),
        'role': MemberSpec_('role', 'PartyRole', 0),
        'type_': MemberSpec_('type_', 'PartyRoleType', 0),
        'effectiveDate': MemberSpec_('effectiveDate', 'xsd:date', 0),
        'terminationDate': MemberSpec_('terminationDate', 'xsd:date', 0),
        'documentation': MemberSpec_('documentation', 'PartyRelationshipDocumentation', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, partyReference=None, accountReference=None, role=None, type_=None, effectiveDate=None, terminationDate=None, documentation=None):
        self.original_tagname_ = None
        self.partyReference = partyReference
        self.accountReference = accountReference
        self.role = role
        self.type_ = type_
        if isinstance(effectiveDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(effectiveDate, '%Y-%m-%d').date()
        else:
            initvalue_ = effectiveDate
        self.effectiveDate = initvalue_
        if isinstance(terminationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(terminationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = terminationDate
        self.terminationDate = initvalue_
        self.documentation = documentation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyRelationship)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyRelationship.subclass:
            return PartyRelationship.subclass(*args_, **kwargs_)
        else:
            return PartyRelationship(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyReference(self): return self.partyReference
    def set_partyReference(self, partyReference): self.partyReference = partyReference
    def get_accountReference(self): return self.accountReference
    def set_accountReference(self, accountReference): self.accountReference = accountReference
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_effectiveDate(self): return self.effectiveDate
    def set_effectiveDate(self, effectiveDate): self.effectiveDate = effectiveDate
    def get_terminationDate(self): return self.terminationDate
    def set_terminationDate(self, terminationDate): self.terminationDate = terminationDate
    def get_documentation(self): return self.documentation
    def set_documentation(self, documentation): self.documentation = documentation
    def hasContent_(self):
        if (
            self.partyReference is not None or
            self.accountReference is not None or
            self.role is not None or
            self.type_ is not None or
            self.effectiveDate is not None or
            self.terminationDate is not None or
            self.documentation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartyRelationship', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyRelationship')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartyRelationship', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyRelationship'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PartyRelationship', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.partyReference is not None:
            self.partyReference.export(outfile, level, namespace_, name_='partyReference', pretty_print=pretty_print)
        if self.accountReference is not None:
            self.accountReference.export(outfile, level, namespace_, name_='accountReference', pretty_print=pretty_print)
        if self.role is not None:
            self.role.export(outfile, level, namespace_, name_='role', pretty_print=pretty_print)
        if self.type_ is not None:
            self.type_.export(outfile, level, namespace_, name_='type', pretty_print=pretty_print)
        if self.effectiveDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%seffectiveDate>%s</%seffectiveDate>%s' % (namespace_, self.gds_format_date(self.effectiveDate, input_name='effectiveDate'), namespace_, eol_))
        if self.terminationDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sterminationDate>%s</%sterminationDate>%s' % (namespace_, self.gds_format_date(self.terminationDate, input_name='terminationDate'), namespace_, eol_))
        if self.documentation is not None:
            self.documentation.export(outfile, level, namespace_, name_='documentation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'partyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.partyReference = obj_
            obj_.original_tagname_ = 'partyReference'
        elif nodeName_ == 'accountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.accountReference = obj_
            obj_.original_tagname_ = 'accountReference'
        elif nodeName_ == 'role':
            obj_ = PartyRole.factory()
            obj_.build(child_)
            self.role = obj_
            obj_.original_tagname_ = 'role'
        elif nodeName_ == 'type':
            obj_ = PartyRoleType.factory()
            obj_.build(child_)
            self.type_ = obj_
            obj_.original_tagname_ = 'type'
        elif nodeName_ == 'effectiveDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.effectiveDate = dval_
        elif nodeName_ == 'terminationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.terminationDate = dval_
        elif nodeName_ == 'documentation':
            obj_ = PartyRelationshipDocumentation.factory()
            obj_.build(child_)
            self.documentation = obj_
            obj_.original_tagname_ = 'documentation'
# end class PartyRelationship


class PartyRelationshipDocumentation(GeneratedsSuper):
    """A description of the legal agreement(s) and definitions that
    document a party's relationships with other parties"""
    member_data_items_ = {
        'masterAgreement': MemberSpec_('masterAgreement', 'MasterAgreement', 1),
        'creditSupportAgreement': MemberSpec_('creditSupportAgreement', 'CreditSupportAgreement', 1),
        'agreement': MemberSpec_('agreement', 'GenericAgreement', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, masterAgreement=None, creditSupportAgreement=None, agreement=None):
        self.original_tagname_ = None
        if masterAgreement is None:
            self.masterAgreement = []
        else:
            self.masterAgreement = masterAgreement
        if creditSupportAgreement is None:
            self.creditSupportAgreement = []
        else:
            self.creditSupportAgreement = creditSupportAgreement
        if agreement is None:
            self.agreement = []
        else:
            self.agreement = agreement
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyRelationshipDocumentation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyRelationshipDocumentation.subclass:
            return PartyRelationshipDocumentation.subclass(*args_, **kwargs_)
        else:
            return PartyRelationshipDocumentation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_masterAgreement(self): return self.masterAgreement
    def set_masterAgreement(self, masterAgreement): self.masterAgreement = masterAgreement
    def add_masterAgreement(self, value): self.masterAgreement.append(value)
    def insert_masterAgreement_at(self, index, value): self.masterAgreement.insert(index, value)
    def replace_masterAgreement_at(self, index, value): self.masterAgreement[index] = value
    def get_creditSupportAgreement(self): return self.creditSupportAgreement
    def set_creditSupportAgreement(self, creditSupportAgreement): self.creditSupportAgreement = creditSupportAgreement
    def add_creditSupportAgreement(self, value): self.creditSupportAgreement.append(value)
    def insert_creditSupportAgreement_at(self, index, value): self.creditSupportAgreement.insert(index, value)
    def replace_creditSupportAgreement_at(self, index, value): self.creditSupportAgreement[index] = value
    def get_agreement(self): return self.agreement
    def set_agreement(self, agreement): self.agreement = agreement
    def add_agreement(self, value): self.agreement.append(value)
    def insert_agreement_at(self, index, value): self.agreement.insert(index, value)
    def replace_agreement_at(self, index, value): self.agreement[index] = value
    def hasContent_(self):
        if (
            self.masterAgreement or
            self.creditSupportAgreement or
            self.agreement
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartyRelationshipDocumentation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyRelationshipDocumentation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartyRelationshipDocumentation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyRelationshipDocumentation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PartyRelationshipDocumentation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for masterAgreement_ in self.masterAgreement:
            masterAgreement_.export(outfile, level, namespace_, name_='masterAgreement', pretty_print=pretty_print)
        for creditSupportAgreement_ in self.creditSupportAgreement:
            creditSupportAgreement_.export(outfile, level, namespace_, name_='creditSupportAgreement', pretty_print=pretty_print)
        for agreement_ in self.agreement:
            agreement_.export(outfile, level, namespace_, name_='agreement', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'masterAgreement':
            obj_ = MasterAgreement.factory()
            obj_.build(child_)
            self.masterAgreement.append(obj_)
            obj_.original_tagname_ = 'masterAgreement'
        elif nodeName_ == 'creditSupportAgreement':
            obj_ = CreditSupportAgreement.factory()
            obj_.build(child_)
            self.creditSupportAgreement.append(obj_)
            obj_.original_tagname_ = 'creditSupportAgreement'
        elif nodeName_ == 'agreement':
            obj_ = GenericAgreement.factory()
            obj_.build(child_)
            self.agreement.append(obj_)
            obj_.original_tagname_ = 'agreement'
# end class PartyRelationshipDocumentation


class PartyRole(GeneratedsSuper):
    """A type describing a role played by a party in one or more
    transactions. Examples include roles such as guarantor,
    custodian, confirmation service provider, etc. This can be
    extended to provide custom roles."""
    member_data_items_ = {
        'partyRoleScheme': MemberSpec_('partyRoleScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, partyRoleScheme='http://www.fpml.org/coding-scheme/party-role', valueOf_=None):
        self.original_tagname_ = None
        self.partyRoleScheme = _cast(None, partyRoleScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyRole)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyRole.subclass:
            return PartyRole.subclass(*args_, **kwargs_)
        else:
            return PartyRole(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyRoleScheme(self): return self.partyRoleScheme
    def set_partyRoleScheme(self, partyRoleScheme): self.partyRoleScheme = partyRoleScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartyRole', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyRole')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartyRole', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyRole'):
        if self.partyRoleScheme != "http://www.fpml.org/coding-scheme/party-role" and 'partyRoleScheme' not in already_processed:
            already_processed.add('partyRoleScheme')
            outfile.write(' partyRoleScheme=%s' % (quote_attrib(self.partyRoleScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PartyRole', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partyRoleScheme', node)
        if value is not None and 'partyRoleScheme' not in already_processed:
            already_processed.add('partyRoleScheme')
            self.partyRoleScheme = value
            self.validate_NonEmptyURI(self.partyRoleScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PartyRole


class PartyRoleType(GeneratedsSuper):
    """A type refining the role a role played by a party in one or more
    transactions. Examples include "AllPositions" and
    "SomePositions" for Guarantor. This can be extended to provide
    custom types."""
    member_data_items_ = {
        'partyRoleTypeScheme': MemberSpec_('partyRoleTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, partyRoleTypeScheme='http://www.fpml.org/coding-scheme/party-role-type', valueOf_=None):
        self.original_tagname_ = None
        self.partyRoleTypeScheme = _cast(None, partyRoleTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyRoleType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyRoleType.subclass:
            return PartyRoleType.subclass(*args_, **kwargs_)
        else:
            return PartyRoleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyRoleTypeScheme(self): return self.partyRoleTypeScheme
    def set_partyRoleTypeScheme(self, partyRoleTypeScheme): self.partyRoleTypeScheme = partyRoleTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartyRoleType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyRoleType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartyRoleType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyRoleType'):
        if self.partyRoleTypeScheme != "http://www.fpml.org/coding-scheme/party-role-type" and 'partyRoleTypeScheme' not in already_processed:
            already_processed.add('partyRoleTypeScheme')
            outfile.write(' partyRoleTypeScheme=%s' % (quote_attrib(self.partyRoleTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PartyRoleType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partyRoleTypeScheme', node)
        if value is not None and 'partyRoleTypeScheme' not in already_processed:
            already_processed.add('partyRoleTypeScheme')
            self.partyRoleTypeScheme = value
            self.validate_NonEmptyURI(self.partyRoleTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PartyRoleType


class PaymentBase(GeneratedsSuper):
    """An abstract base class for payment types."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PaymentBase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PaymentBase.subclass:
            return PaymentBase.subclass(*args_, **kwargs_)
        else:
            return PaymentBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PaymentBase', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentBase')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PaymentBase', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PaymentBase'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='PaymentBase', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PaymentBase


class PaymentBaseExtended(PaymentBase):
    """Base type for payments."""
    member_data_items_ = {
        'payerPartyReference': MemberSpec_('payerPartyReference', 'PartyReference', 0),
        'payerAccountReference': MemberSpec_('payerAccountReference', 'AccountReference', 0),
        'receiverPartyReference': MemberSpec_('receiverPartyReference', 'PartyReference', 0),
        'receiverAccountReference': MemberSpec_('receiverAccountReference', 'AccountReference', 0),
        'paymentDate': MemberSpec_('paymentDate', 'AdjustableOrRelativeDate', 0),
    }
    subclass = None
    superclass = PaymentBase
    def __init__(self, id=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, paymentDate=None, extensiontype_=None):
        self.original_tagname_ = None
        super(PaymentBaseExtended, self).__init__(id, extensiontype_, )
        self.payerPartyReference = payerPartyReference
        self.payerAccountReference = payerAccountReference
        self.receiverPartyReference = receiverPartyReference
        self.receiverAccountReference = receiverAccountReference
        self.paymentDate = paymentDate
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PaymentBaseExtended)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PaymentBaseExtended.subclass:
            return PaymentBaseExtended.subclass(*args_, **kwargs_)
        else:
            return PaymentBaseExtended(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_payerPartyReference(self): return self.payerPartyReference
    def set_payerPartyReference(self, payerPartyReference): self.payerPartyReference = payerPartyReference
    def get_payerAccountReference(self): return self.payerAccountReference
    def set_payerAccountReference(self, payerAccountReference): self.payerAccountReference = payerAccountReference
    def get_receiverPartyReference(self): return self.receiverPartyReference
    def set_receiverPartyReference(self, receiverPartyReference): self.receiverPartyReference = receiverPartyReference
    def get_receiverAccountReference(self): return self.receiverAccountReference
    def set_receiverAccountReference(self, receiverAccountReference): self.receiverAccountReference = receiverAccountReference
    def get_paymentDate(self): return self.paymentDate
    def set_paymentDate(self, paymentDate): self.paymentDate = paymentDate
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.payerPartyReference is not None or
            self.payerAccountReference is not None or
            self.receiverPartyReference is not None or
            self.receiverAccountReference is not None or
            self.paymentDate is not None or
            super(PaymentBaseExtended, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PaymentBaseExtended', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentBaseExtended')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PaymentBaseExtended', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PaymentBaseExtended'):
        super(PaymentBaseExtended, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentBaseExtended')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='PaymentBaseExtended', fromsubclass_=False, pretty_print=True):
        super(PaymentBaseExtended, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.payerPartyReference is not None:
            self.payerPartyReference.export(outfile, level, namespace_, name_='payerPartyReference', pretty_print=pretty_print)
        if self.payerAccountReference is not None:
            self.payerAccountReference.export(outfile, level, namespace_, name_='payerAccountReference', pretty_print=pretty_print)
        if self.receiverPartyReference is not None:
            self.receiverPartyReference.export(outfile, level, namespace_, name_='receiverPartyReference', pretty_print=pretty_print)
        if self.receiverAccountReference is not None:
            self.receiverAccountReference.export(outfile, level, namespace_, name_='receiverAccountReference', pretty_print=pretty_print)
        if self.paymentDate is not None:
            self.paymentDate.export(outfile, level, namespace_, name_='paymentDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(PaymentBaseExtended, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'payerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.payerPartyReference = obj_
            obj_.original_tagname_ = 'payerPartyReference'
        elif nodeName_ == 'payerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.payerAccountReference = obj_
            obj_.original_tagname_ = 'payerAccountReference'
        elif nodeName_ == 'receiverPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.receiverPartyReference = obj_
            obj_.original_tagname_ = 'receiverPartyReference'
        elif nodeName_ == 'receiverAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.receiverAccountReference = obj_
            obj_.original_tagname_ = 'receiverAccountReference'
        elif nodeName_ == 'paymentDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.paymentDate = obj_
            obj_.original_tagname_ = 'paymentDate'
        super(PaymentBaseExtended, self).buildChildren(child_, node, nodeName_, True)
# end class PaymentBaseExtended


class PaymentDetail(PaymentBase):
    member_data_items_ = {
        'paymentDate': MemberSpec_('paymentDate', 'AdjustableOrRelativeDate', 0),
        'paymentAmount': MemberSpec_('paymentAmount', 'Money', 0),
        'paymentRule': MemberSpec_('paymentRule', 'PaymentRule', 0),
        'paymentAmount': MemberSpec_('paymentAmount', 'Money', 0),
    }
    subclass = None
    superclass = PaymentBase
    def __init__(self, id=None, paymentDate=None, paymentAmount=None, paymentRule=None):
        self.original_tagname_ = None
        super(PaymentDetail, self).__init__(id, )
        self.paymentDate = paymentDate
        self.paymentAmount = paymentAmount
        self.paymentRule = paymentRule
        self.paymentAmount = paymentAmount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PaymentDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PaymentDetail.subclass:
            return PaymentDetail.subclass(*args_, **kwargs_)
        else:
            return PaymentDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_paymentDate(self): return self.paymentDate
    def set_paymentDate(self, paymentDate): self.paymentDate = paymentDate
    def get_paymentAmount(self): return self.paymentAmount
    def set_paymentAmount(self, paymentAmount): self.paymentAmount = paymentAmount
    def get_paymentRule(self): return self.paymentRule
    def set_paymentRule(self, paymentRule): self.paymentRule = paymentRule
    def get_paymentAmount(self): return self.paymentAmount
    def set_paymentAmount(self, paymentAmount): self.paymentAmount = paymentAmount
    def hasContent_(self):
        if (
            self.paymentDate is not None or
            self.paymentAmount is not None or
            self.paymentRule is not None or
            self.paymentAmount is not None or
            super(PaymentDetail, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PaymentDetail', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PaymentDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PaymentDetail'):
        super(PaymentDetail, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentDetail')
    def exportChildren(self, outfile, level, namespace_='', name_='PaymentDetail', fromsubclass_=False, pretty_print=True):
        super(PaymentDetail, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.paymentDate is not None:
            self.paymentDate.export(outfile, level, namespace_, name_='paymentDate', pretty_print=pretty_print)
        if self.paymentAmount is not None:
            self.paymentAmount.export(outfile, level, namespace_, name_='paymentAmount', pretty_print=pretty_print)
        if self.paymentRule is not None:
            self.paymentRule.export(outfile, level, namespace_, name_='paymentRule', pretty_print=pretty_print)
        if self.paymentAmount is not None:
            self.paymentAmount.export(outfile, level, namespace_, name_='paymentAmount', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PaymentDetail, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'paymentDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.paymentDate = obj_
            obj_.original_tagname_ = 'paymentDate'
        elif nodeName_ == 'paymentAmount':
            class_obj_ = self.get_class_obj_(child_, Money)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.paymentAmount = obj_
            obj_.original_tagname_ = 'paymentAmount'
        elif nodeName_ == 'paymentRule':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <paymentRule> element')
            self.paymentRule = obj_
            obj_.original_tagname_ = 'paymentRule'
        elif nodeName_ == 'paymentAmount':
            class_obj_ = self.get_class_obj_(child_, Money)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.paymentAmount = obj_
            obj_.original_tagname_ = 'paymentAmount'
        super(PaymentDetail, self).buildChildren(child_, node, nodeName_, True)
# end class PaymentDetail


class PaymentDetails(GeneratedsSuper):
    """Details on the referenced payment. e.g. Its cashflow components,
    settlement details."""
    member_data_items_ = {
        'paymentReference': MemberSpec_('paymentReference', 'PaymentReference', 0),
        'grossCashflow': MemberSpec_('grossCashflow', 'GrossCashflow', 1),
        'settlementInformation': MemberSpec_('settlementInformation', 'SettlementInformation', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, paymentReference=None, grossCashflow=None, settlementInformation=None):
        self.original_tagname_ = None
        self.paymentReference = paymentReference
        if grossCashflow is None:
            self.grossCashflow = []
        else:
            self.grossCashflow = grossCashflow
        self.settlementInformation = settlementInformation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PaymentDetails)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PaymentDetails.subclass:
            return PaymentDetails.subclass(*args_, **kwargs_)
        else:
            return PaymentDetails(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_paymentReference(self): return self.paymentReference
    def set_paymentReference(self, paymentReference): self.paymentReference = paymentReference
    def get_grossCashflow(self): return self.grossCashflow
    def set_grossCashflow(self, grossCashflow): self.grossCashflow = grossCashflow
    def add_grossCashflow(self, value): self.grossCashflow.append(value)
    def insert_grossCashflow_at(self, index, value): self.grossCashflow.insert(index, value)
    def replace_grossCashflow_at(self, index, value): self.grossCashflow[index] = value
    def get_settlementInformation(self): return self.settlementInformation
    def set_settlementInformation(self, settlementInformation): self.settlementInformation = settlementInformation
    def hasContent_(self):
        if (
            self.paymentReference is not None or
            self.grossCashflow or
            self.settlementInformation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PaymentDetails', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentDetails')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PaymentDetails', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PaymentDetails'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PaymentDetails', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.paymentReference is not None:
            self.paymentReference.export(outfile, level, namespace_, name_='paymentReference', pretty_print=pretty_print)
        for grossCashflow_ in self.grossCashflow:
            grossCashflow_.export(outfile, level, namespace_, name_='grossCashflow', pretty_print=pretty_print)
        if self.settlementInformation is not None:
            self.settlementInformation.export(outfile, level, namespace_, name_='settlementInformation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'paymentReference':
            obj_ = PaymentReference.factory()
            obj_.build(child_)
            self.paymentReference = obj_
            obj_.original_tagname_ = 'paymentReference'
        elif nodeName_ == 'grossCashflow':
            obj_ = GrossCashflow.factory()
            obj_.build(child_)
            self.grossCashflow.append(obj_)
            obj_.original_tagname_ = 'grossCashflow'
        elif nodeName_ == 'settlementInformation':
            obj_ = SettlementInformation.factory()
            obj_.build(child_)
            self.settlementInformation = obj_
            obj_.original_tagname_ = 'settlementInformation'
# end class PaymentDetails


class PaymentId(GeneratedsSuper):
    """An identifier used to identify a matchable payment."""
    member_data_items_ = {
        'paymentIdScheme': MemberSpec_('paymentIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, paymentIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.paymentIdScheme = _cast(None, paymentIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PaymentId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PaymentId.subclass:
            return PaymentId.subclass(*args_, **kwargs_)
        else:
            return PaymentId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_paymentIdScheme(self): return self.paymentIdScheme
    def set_paymentIdScheme(self, paymentIdScheme): self.paymentIdScheme = paymentIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PaymentId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PaymentId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PaymentId'):
        if self.paymentIdScheme is not None and 'paymentIdScheme' not in already_processed:
            already_processed.add('paymentIdScheme')
            outfile.write(' paymentIdScheme=%s' % (quote_attrib(self.paymentIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PaymentId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('paymentIdScheme', node)
        if value is not None and 'paymentIdScheme' not in already_processed:
            already_processed.add('paymentIdScheme')
            self.paymentIdScheme = value
            self.validate_NonEmptyURI(self.paymentIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PaymentId


class PaymentRule(GeneratedsSuper):
    """The abstract base type from which all calculation rules of the
    independent amount must be derived."""
    member_data_items_ = {
    }
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PaymentRule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PaymentRule.subclass:
            return PaymentRule.subclass(*args_, **kwargs_)
        else:
            return PaymentRule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PaymentRule', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentRule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PaymentRule', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PaymentRule'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PaymentRule', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PaymentRule


class PaymentType(GeneratedsSuper):
    member_data_items_ = {
        'paymentTypeScheme': MemberSpec_('paymentTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, paymentTypeScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.paymentTypeScheme = _cast(None, paymentTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PaymentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PaymentType.subclass:
            return PaymentType.subclass(*args_, **kwargs_)
        else:
            return PaymentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_paymentTypeScheme(self): return self.paymentTypeScheme
    def set_paymentTypeScheme(self, paymentTypeScheme): self.paymentTypeScheme = paymentTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PaymentType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PaymentType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PaymentType'):
        if self.paymentTypeScheme is not None and 'paymentTypeScheme' not in already_processed:
            already_processed.add('paymentTypeScheme')
            outfile.write(' paymentTypeScheme=%s' % (quote_attrib(self.paymentTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PaymentType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('paymentTypeScheme', node)
        if value is not None and 'paymentTypeScheme' not in already_processed:
            already_processed.add('paymentTypeScheme')
            self.paymentTypeScheme = value
            self.validate_NonEmptyURI(self.paymentTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PaymentType


class Period(GeneratedsSuper):
    """A type to define recurring periods or time offsets."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'periodMultiplier': MemberSpec_('periodMultiplier', 'xsd:integer', 0),
        'period': MemberSpec_('period', ['PeriodEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, periodMultiplier=None, period=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.periodMultiplier = periodMultiplier
        self.period = period
        self.validate_PeriodEnum(self.period)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Period)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Period.subclass:
            return Period.subclass(*args_, **kwargs_)
        else:
            return Period(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_periodMultiplier(self): return self.periodMultiplier
    def set_periodMultiplier(self, periodMultiplier): self.periodMultiplier = periodMultiplier
    def get_period(self): return self.period
    def set_period(self, period): self.period = period
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_PeriodEnum(self, value):
        # Validate type PeriodEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['D', 'W', 'M', 'Y']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PeriodEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on PeriodEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.periodMultiplier is not None or
            self.period is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Period', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Period')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Period', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Period'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Period', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.periodMultiplier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%speriodMultiplier>%s</%speriodMultiplier>%s' % (namespace_, self.gds_format_integer(self.periodMultiplier, input_name='periodMultiplier'), namespace_, eol_))
        if self.period is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%speriod>%s</%speriod>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.period), input_name='period')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'periodMultiplier':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'periodMultiplier')
            self.periodMultiplier = ival_
        elif nodeName_ == 'period':
            period_ = child_.text
            period_ = re_.sub(String_cleanup_pat_, " ", period_).strip()
            period_ = self.gds_validate_string(period_, node, 'period')
            self.period = period_
            # validate type PeriodEnum
            self.validate_PeriodEnum(self.period)
# end class Period


class PeriodicDates(GeneratedsSuper):
    member_data_items_ = {
        'calculationStartDate': MemberSpec_('calculationStartDate', 'AdjustableOrRelativeDate', 0),
        'calculationEndDate': MemberSpec_('calculationEndDate', 'AdjustableOrRelativeDate', 0),
        'calculationPeriodFrequency': MemberSpec_('calculationPeriodFrequency', 'CalculationPeriodFrequency', 0),
        'calculationPeriodDatesAdjustments': MemberSpec_('calculationPeriodDatesAdjustments', 'BusinessDayAdjustments', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, calculationStartDate=None, calculationEndDate=None, calculationPeriodFrequency=None, calculationPeriodDatesAdjustments=None):
        self.original_tagname_ = None
        self.calculationStartDate = calculationStartDate
        self.calculationEndDate = calculationEndDate
        self.calculationPeriodFrequency = calculationPeriodFrequency
        self.calculationPeriodDatesAdjustments = calculationPeriodDatesAdjustments
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PeriodicDates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PeriodicDates.subclass:
            return PeriodicDates.subclass(*args_, **kwargs_)
        else:
            return PeriodicDates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_calculationStartDate(self): return self.calculationStartDate
    def set_calculationStartDate(self, calculationStartDate): self.calculationStartDate = calculationStartDate
    def get_calculationEndDate(self): return self.calculationEndDate
    def set_calculationEndDate(self, calculationEndDate): self.calculationEndDate = calculationEndDate
    def get_calculationPeriodFrequency(self): return self.calculationPeriodFrequency
    def set_calculationPeriodFrequency(self, calculationPeriodFrequency): self.calculationPeriodFrequency = calculationPeriodFrequency
    def get_calculationPeriodDatesAdjustments(self): return self.calculationPeriodDatesAdjustments
    def set_calculationPeriodDatesAdjustments(self, calculationPeriodDatesAdjustments): self.calculationPeriodDatesAdjustments = calculationPeriodDatesAdjustments
    def hasContent_(self):
        if (
            self.calculationStartDate is not None or
            self.calculationEndDate is not None or
            self.calculationPeriodFrequency is not None or
            self.calculationPeriodDatesAdjustments is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PeriodicDates', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PeriodicDates')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PeriodicDates', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PeriodicDates'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PeriodicDates', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.calculationStartDate is not None:
            self.calculationStartDate.export(outfile, level, namespace_, name_='calculationStartDate', pretty_print=pretty_print)
        if self.calculationEndDate is not None:
            self.calculationEndDate.export(outfile, level, namespace_, name_='calculationEndDate', pretty_print=pretty_print)
        if self.calculationPeriodFrequency is not None:
            self.calculationPeriodFrequency.export(outfile, level, namespace_, name_='calculationPeriodFrequency', pretty_print=pretty_print)
        if self.calculationPeriodDatesAdjustments is not None:
            self.calculationPeriodDatesAdjustments.export(outfile, level, namespace_, name_='calculationPeriodDatesAdjustments', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'calculationStartDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.calculationStartDate = obj_
            obj_.original_tagname_ = 'calculationStartDate'
        elif nodeName_ == 'calculationEndDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.calculationEndDate = obj_
            obj_.original_tagname_ = 'calculationEndDate'
        elif nodeName_ == 'calculationPeriodFrequency':
            obj_ = CalculationPeriodFrequency.factory()
            obj_.build(child_)
            self.calculationPeriodFrequency = obj_
            obj_.original_tagname_ = 'calculationPeriodFrequency'
        elif nodeName_ == 'calculationPeriodDatesAdjustments':
            obj_ = BusinessDayAdjustments.factory()
            obj_.build(child_)
            self.calculationPeriodDatesAdjustments = obj_
            obj_.original_tagname_ = 'calculationPeriodDatesAdjustments'
# end class PeriodicDates


class Person(GeneratedsSuper):
    """A type that represents information about a person connected with a
    trade or business process."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'honorific': MemberSpec_('honorific', ['NormalizedString', 'xsd:normalizedString'], 0),
        'firstName': MemberSpec_('firstName', ['NormalizedString', 'xsd:normalizedString'], 0),
        'middleName': MemberSpec_('middleName', ['NormalizedString', 'xsd:normalizedString'], 1),
        'initial': MemberSpec_('initial', ['Initial', 'xsd:normalizedString'], 1),
        'surname': MemberSpec_('surname', ['NormalizedString', 'xsd:normalizedString'], 0),
        'suffix': MemberSpec_('suffix', ['NormalizedString', 'xsd:normalizedString'], 0),
        'personId': MemberSpec_('personId', 'PersonId', 1),
        'businessUnitReference': MemberSpec_('businessUnitReference', 'BusinessUnitReference', 0),
        'contactInfo': MemberSpec_('contactInfo', 'ContactInformation', 0),
        'dateOfBirth': MemberSpec_('dateOfBirth', 'xsd:date', 0),
        'country': MemberSpec_('country', 'CountryCode', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, honorific=None, firstName=None, middleName=None, initial=None, surname=None, suffix=None, personId=None, businessUnitReference=None, contactInfo=None, dateOfBirth=None, country=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.honorific = honorific
        self.validate_NormalizedString(self.honorific)
        self.firstName = firstName
        self.validate_NormalizedString(self.firstName)
        if middleName is None:
            self.middleName = []
        else:
            self.middleName = middleName
        if initial is None:
            self.initial = []
        else:
            self.initial = initial
        self.surname = surname
        self.validate_NormalizedString(self.surname)
        self.suffix = suffix
        self.validate_NormalizedString(self.suffix)
        if personId is None:
            self.personId = []
        else:
            self.personId = personId
        self.businessUnitReference = businessUnitReference
        self.contactInfo = contactInfo
        if isinstance(dateOfBirth, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(dateOfBirth, '%Y-%m-%d').date()
        else:
            initvalue_ = dateOfBirth
        self.dateOfBirth = initvalue_
        self.country = country
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Person)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Person.subclass:
            return Person.subclass(*args_, **kwargs_)
        else:
            return Person(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_honorific(self): return self.honorific
    def set_honorific(self, honorific): self.honorific = honorific
    def get_firstName(self): return self.firstName
    def set_firstName(self, firstName): self.firstName = firstName
    def get_middleName(self): return self.middleName
    def set_middleName(self, middleName): self.middleName = middleName
    def add_middleName(self, value): self.middleName.append(value)
    def insert_middleName_at(self, index, value): self.middleName.insert(index, value)
    def replace_middleName_at(self, index, value): self.middleName[index] = value
    def get_initial(self): return self.initial
    def set_initial(self, initial): self.initial = initial
    def add_initial(self, value): self.initial.append(value)
    def insert_initial_at(self, index, value): self.initial.insert(index, value)
    def replace_initial_at(self, index, value): self.initial[index] = value
    def get_surname(self): return self.surname
    def set_surname(self, surname): self.surname = surname
    def get_suffix(self): return self.suffix
    def set_suffix(self, suffix): self.suffix = suffix
    def get_personId(self): return self.personId
    def set_personId(self, personId): self.personId = personId
    def add_personId(self, value): self.personId.append(value)
    def insert_personId_at(self, index, value): self.personId.insert(index, value)
    def replace_personId_at(self, index, value): self.personId[index] = value
    def get_businessUnitReference(self): return self.businessUnitReference
    def set_businessUnitReference(self, businessUnitReference): self.businessUnitReference = businessUnitReference
    def get_contactInfo(self): return self.contactInfo
    def set_contactInfo(self, contactInfo): self.contactInfo = contactInfo
    def get_dateOfBirth(self): return self.dateOfBirth
    def set_dateOfBirth(self, dateOfBirth): self.dateOfBirth = dateOfBirth
    def get_country(self): return self.country
    def set_country(self, country): self.country = country
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_NormalizedString(self, value):
        # Validate type NormalizedString, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NormalizedString' % {"value" : value} )
    def validate_Initial(self, value):
        # Validate type Initial, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on Initial' % {"value" : value} )
    def hasContent_(self):
        if (
            self.honorific is not None or
            self.firstName is not None or
            self.middleName or
            self.initial or
            self.surname is not None or
            self.suffix is not None or
            self.personId or
            self.businessUnitReference is not None or
            self.contactInfo is not None or
            self.dateOfBirth is not None or
            self.country is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Person', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Person')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Person', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Person'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Person', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.honorific is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shonorific>%s</%shonorific>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.honorific), input_name='honorific')), namespace_, eol_))
        if self.firstName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfirstName>%s</%sfirstName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.firstName), input_name='firstName')), namespace_, eol_))
        for middleName_ in self.middleName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smiddleName>%s</%smiddleName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(middleName_), input_name='middleName')), namespace_, eol_))
        for initial_ in self.initial:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinitial>%s</%sinitial>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(initial_), input_name='initial')), namespace_, eol_))
        if self.surname is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssurname>%s</%ssurname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.surname), input_name='surname')), namespace_, eol_))
        if self.suffix is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssuffix>%s</%ssuffix>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.suffix), input_name='suffix')), namespace_, eol_))
        for personId_ in self.personId:
            personId_.export(outfile, level, namespace_, name_='personId', pretty_print=pretty_print)
        if self.businessUnitReference is not None:
            self.businessUnitReference.export(outfile, level, namespace_, name_='businessUnitReference', pretty_print=pretty_print)
        if self.contactInfo is not None:
            self.contactInfo.export(outfile, level, namespace_, name_='contactInfo', pretty_print=pretty_print)
        if self.dateOfBirth is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdateOfBirth>%s</%sdateOfBirth>%s' % (namespace_, self.gds_format_date(self.dateOfBirth, input_name='dateOfBirth'), namespace_, eol_))
        if self.country is not None:
            self.country.export(outfile, level, namespace_, name_='country', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'honorific':
            honorific_ = child_.text
            honorific_ = self.gds_validate_string(honorific_, node, 'honorific')
            self.honorific = honorific_
            # validate type NormalizedString
            self.validate_NormalizedString(self.honorific)
        elif nodeName_ == 'firstName':
            firstName_ = child_.text
            firstName_ = self.gds_validate_string(firstName_, node, 'firstName')
            self.firstName = firstName_
            # validate type NormalizedString
            self.validate_NormalizedString(self.firstName)
        elif nodeName_ == 'middleName':
            middleName_ = child_.text
            middleName_ = self.gds_validate_string(middleName_, node, 'middleName')
            self.middleName.append(middleName_)
            # validate type NormalizedString
            self.validate_NormalizedString(self.middleName[-1])
        elif nodeName_ == 'initial':
            initial_ = child_.text
            initial_ = self.gds_validate_string(initial_, node, 'initial')
            self.initial.append(initial_)
            # validate type Initial
            self.validate_Initial(self.initial[-1])
        elif nodeName_ == 'surname':
            surname_ = child_.text
            surname_ = self.gds_validate_string(surname_, node, 'surname')
            self.surname = surname_
            # validate type NormalizedString
            self.validate_NormalizedString(self.surname)
        elif nodeName_ == 'suffix':
            suffix_ = child_.text
            suffix_ = self.gds_validate_string(suffix_, node, 'suffix')
            self.suffix = suffix_
            # validate type NormalizedString
            self.validate_NormalizedString(self.suffix)
        elif nodeName_ == 'personId':
            obj_ = PersonId.factory()
            obj_.build(child_)
            self.personId.append(obj_)
            obj_.original_tagname_ = 'personId'
        elif nodeName_ == 'businessUnitReference':
            obj_ = BusinessUnitReference.factory()
            obj_.build(child_)
            self.businessUnitReference = obj_
            obj_.original_tagname_ = 'businessUnitReference'
        elif nodeName_ == 'contactInfo':
            obj_ = ContactInformation.factory()
            obj_.build(child_)
            self.contactInfo = obj_
            obj_.original_tagname_ = 'contactInfo'
        elif nodeName_ == 'dateOfBirth':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.dateOfBirth = dval_
        elif nodeName_ == 'country':
            obj_ = CountryCode.factory()
            obj_.build(child_)
            self.country = obj_
            obj_.original_tagname_ = 'country'
# end class Person


class PersonId(GeneratedsSuper):
    """An identifier used to identify an individual person."""
    member_data_items_ = {
        'personIdScheme': MemberSpec_('personIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, personIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.personIdScheme = _cast(None, personIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PersonId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PersonId.subclass:
            return PersonId.subclass(*args_, **kwargs_)
        else:
            return PersonId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_personIdScheme(self): return self.personIdScheme
    def set_personIdScheme(self, personIdScheme): self.personIdScheme = personIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PersonId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PersonId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PersonId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PersonId'):
        if self.personIdScheme is not None and 'personIdScheme' not in already_processed:
            already_processed.add('personIdScheme')
            outfile.write(' personIdScheme=%s' % (quote_attrib(self.personIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PersonId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('personIdScheme', node)
        if value is not None and 'personIdScheme' not in already_processed:
            already_processed.add('personIdScheme')
            self.personIdScheme = value
            self.validate_NonEmptyURI(self.personIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PersonId


class PersonRole(GeneratedsSuper):
    """A type describing a role played by a person in one or more
    transactions. Examples include roles such as Trader, Broker,
    MiddleOffice, Legal, etc. This can be extended to provide custom
    roles."""
    member_data_items_ = {
        'personRoleScheme': MemberSpec_('personRoleScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, personRoleScheme='http://www.fpml.org/coding-scheme/person-role', valueOf_=None):
        self.original_tagname_ = None
        self.personRoleScheme = _cast(None, personRoleScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PersonRole)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PersonRole.subclass:
            return PersonRole.subclass(*args_, **kwargs_)
        else:
            return PersonRole(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_personRoleScheme(self): return self.personRoleScheme
    def set_personRoleScheme(self, personRoleScheme): self.personRoleScheme = personRoleScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PersonRole', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PersonRole')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PersonRole', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PersonRole'):
        if self.personRoleScheme != "http://www.fpml.org/coding-scheme/person-role" and 'personRoleScheme' not in already_processed:
            already_processed.add('personRoleScheme')
            outfile.write(' personRoleScheme=%s' % (quote_attrib(self.personRoleScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PersonRole', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('personRoleScheme', node)
        if value is not None and 'personRoleScheme' not in already_processed:
            already_processed.add('personRoleScheme')
            self.personRoleScheme = value
            self.validate_NonEmptyURI(self.personRoleScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PersonRole


class PositiveMoney(MoneyBase):
    """A type defining a positive money amount"""
    member_data_items_ = {
        'amount': MemberSpec_('amount', ['PositiveDecimal', 'xsd:decimal'], 0),
    }
    subclass = None
    superclass = MoneyBase
    def __init__(self, id=None, currency=None, amount=None):
        self.original_tagname_ = None
        super(PositiveMoney, self).__init__(id, currency, )
        self.amount = amount
        self.validate_PositiveDecimal(self.amount)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PositiveMoney)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PositiveMoney.subclass:
            return PositiveMoney.subclass(*args_, **kwargs_)
        else:
            return PositiveMoney(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_amount(self): return self.amount
    def set_amount(self, amount): self.amount = amount
    def validate_PositiveDecimal(self, value):
        # Validate type PositiveDecimal, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value <= 0:
                warnings_.warn('Value "%(value)s" does not match xsd minExclusive restriction on PositiveDecimal' % {"value" : value} )
    def hasContent_(self):
        if (
            self.amount is not None or
            super(PositiveMoney, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PositiveMoney', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PositiveMoney')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PositiveMoney', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PositiveMoney'):
        super(PositiveMoney, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PositiveMoney')
    def exportChildren(self, outfile, level, namespace_='', name_='PositiveMoney', fromsubclass_=False, pretty_print=True):
        super(PositiveMoney, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.amount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%samount>%s</%samount>%s' % (namespace_, self.gds_format_float(self.amount, input_name='amount'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PositiveMoney, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'amount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'amount')
            self.amount = fval_
            # validate type PositiveDecimal
            self.validate_PositiveDecimal(self.amount)
        super(PositiveMoney, self).buildChildren(child_, node, nodeName_, True)
# end class PositiveMoney


class PrevailingTime(GeneratedsSuper):
    """A type for defining a time with respect to a geographic location,
    for example 11:00 Phoenix, USA. This type should be used where a
    wider range of locations than those available as business
    centres is required."""
    member_data_items_ = {
        'hourMinuteTime': MemberSpec_('hourMinuteTime', ['HourMinuteTime', 'xsd:time'], 0),
        'location': MemberSpec_('location', 'TimezoneLocation', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, hourMinuteTime=None, location=None):
        self.original_tagname_ = None
        if isinstance(hourMinuteTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(hourMinuteTime, '%H:%M:%S').time()
        else:
            initvalue_ = hourMinuteTime
        self.hourMinuteTime = initvalue_
        self.location = location
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PrevailingTime)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PrevailingTime.subclass:
            return PrevailingTime.subclass(*args_, **kwargs_)
        else:
            return PrevailingTime(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_hourMinuteTime(self): return self.hourMinuteTime
    def set_hourMinuteTime(self, hourMinuteTime): self.hourMinuteTime = hourMinuteTime
    def get_location(self): return self.location
    def set_location(self, location): self.location = location
    def validate_HourMinuteTime(self, value):
        # Validate type HourMinuteTime, a restriction on xsd:time.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_HourMinuteTime_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_HourMinuteTime_patterns_, ))
    validate_HourMinuteTime_patterns_ = [['^[0-2][0-9]:[0-5][0-9]:00$']]
    def hasContent_(self):
        if (
            self.hourMinuteTime is not None or
            self.location is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PrevailingTime', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PrevailingTime')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PrevailingTime', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PrevailingTime'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PrevailingTime', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.hourMinuteTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shourMinuteTime>%s</%shourMinuteTime>%s' % (namespace_, self.gds_format_time(self.hourMinuteTime, input_name='hourMinuteTime'), namespace_, eol_))
        if self.location is not None:
            self.location.export(outfile, level, namespace_, name_='location', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'hourMinuteTime':
            sval_ = child_.text
            dval_ = self.gds_parse_time(sval_)
            self.hourMinuteTime = dval_
            # validate type HourMinuteTime
            self.validate_HourMinuteTime(self.hourMinuteTime)
        elif nodeName_ == 'location':
            obj_ = TimezoneLocation.factory()
            obj_.build(child_)
            self.location = obj_
            obj_.original_tagname_ = 'location'
# end class PrevailingTime


class PricingStructure(GeneratedsSuper):
    """An abstract pricing structure base type. Used as a base for
    structures such as yield curves and volatility matrices."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'name': MemberSpec_('name', ['NormalizedString', 'xsd:normalizedString'], 0),
        'currency': MemberSpec_('currency', 'Currency', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, currency=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.name = name
        self.validate_NormalizedString(self.name)
        self.currency = currency
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PricingStructure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PricingStructure.subclass:
            return PricingStructure.subclass(*args_, **kwargs_)
        else:
            return PricingStructure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_NormalizedString(self, value):
        # Validate type NormalizedString, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NormalizedString' % {"value" : value} )
    def hasContent_(self):
        if (
            self.name is not None or
            self.currency is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PricingStructure', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PricingStructure')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PricingStructure', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PricingStructure'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PricingStructure', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespace_, eol_))
        if self.currency is not None:
            self.currency.export(outfile, level, namespace_, name_='currency', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
            # validate type NormalizedString
            self.validate_NormalizedString(self.name)
        elif nodeName_ == 'currency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
# end class PricingStructure


class PrincipalExchanges(GeneratedsSuper):
    """A type defining which principal exchanges occur for the stream."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'initialExchange': MemberSpec_('initialExchange', 'xsd:boolean', 0),
        'finalExchange': MemberSpec_('finalExchange', 'xsd:boolean', 0),
        'intermediateExchange': MemberSpec_('intermediateExchange', 'xsd:boolean', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, initialExchange=None, finalExchange=None, intermediateExchange=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.initialExchange = initialExchange
        self.finalExchange = finalExchange
        self.intermediateExchange = intermediateExchange
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PrincipalExchanges)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PrincipalExchanges.subclass:
            return PrincipalExchanges.subclass(*args_, **kwargs_)
        else:
            return PrincipalExchanges(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_initialExchange(self): return self.initialExchange
    def set_initialExchange(self, initialExchange): self.initialExchange = initialExchange
    def get_finalExchange(self): return self.finalExchange
    def set_finalExchange(self, finalExchange): self.finalExchange = finalExchange
    def get_intermediateExchange(self): return self.intermediateExchange
    def set_intermediateExchange(self, intermediateExchange): self.intermediateExchange = intermediateExchange
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.initialExchange is not None or
            self.finalExchange is not None or
            self.intermediateExchange is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PrincipalExchanges', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PrincipalExchanges')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PrincipalExchanges', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PrincipalExchanges'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PrincipalExchanges', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.initialExchange is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinitialExchange>%s</%sinitialExchange>%s' % (namespace_, self.gds_format_boolean(self.initialExchange, input_name='initialExchange'), namespace_, eol_))
        if self.finalExchange is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfinalExchange>%s</%sfinalExchange>%s' % (namespace_, self.gds_format_boolean(self.finalExchange, input_name='finalExchange'), namespace_, eol_))
        if self.intermediateExchange is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sintermediateExchange>%s</%sintermediateExchange>%s' % (namespace_, self.gds_format_boolean(self.intermediateExchange, input_name='intermediateExchange'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'initialExchange':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'initialExchange')
            self.initialExchange = ival_
        elif nodeName_ == 'finalExchange':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'finalExchange')
            self.finalExchange = ival_
        elif nodeName_ == 'intermediateExchange':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'intermediateExchange')
            self.intermediateExchange = ival_
# end class PrincipalExchanges


class Product(GeneratedsSuper):
    """The base type which all FpML products extend."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'primaryAssetClass': MemberSpec_('primaryAssetClass', 'AssetClass', 0),
        'secondaryAssetClass': MemberSpec_('secondaryAssetClass', 'AssetClass', 1),
        'productType': MemberSpec_('productType', 'ProductType', 1),
        'productId': MemberSpec_('productId', 'ProductId', 1),
        'productId': MemberSpec_('productId', 'ProductId', 1),
        'assetClass': MemberSpec_('assetClass', 'AssetClass', 1),
        'embeddedOptionType': MemberSpec_('embeddedOptionType', 'EmbeddedOptionType', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, primaryAssetClass=None, secondaryAssetClass=None, productType=None, productId=None, assetClass=None, embeddedOptionType=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.primaryAssetClass = primaryAssetClass
        if secondaryAssetClass is None:
            self.secondaryAssetClass = []
        else:
            self.secondaryAssetClass = secondaryAssetClass
        if productType is None:
            self.productType = []
        else:
            self.productType = productType
        if productId is None:
            self.productId = []
        else:
            self.productId = productId
        if productId is None:
            self.productId = []
        else:
            self.productId = productId
        if assetClass is None:
            self.assetClass = []
        else:
            self.assetClass = assetClass
        if embeddedOptionType is None:
            self.embeddedOptionType = []
        else:
            self.embeddedOptionType = embeddedOptionType
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Product)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Product.subclass:
            return Product.subclass(*args_, **kwargs_)
        else:
            return Product(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_primaryAssetClass(self): return self.primaryAssetClass
    def set_primaryAssetClass(self, primaryAssetClass): self.primaryAssetClass = primaryAssetClass
    def get_secondaryAssetClass(self): return self.secondaryAssetClass
    def set_secondaryAssetClass(self, secondaryAssetClass): self.secondaryAssetClass = secondaryAssetClass
    def add_secondaryAssetClass(self, value): self.secondaryAssetClass.append(value)
    def insert_secondaryAssetClass_at(self, index, value): self.secondaryAssetClass.insert(index, value)
    def replace_secondaryAssetClass_at(self, index, value): self.secondaryAssetClass[index] = value
    def get_productType(self): return self.productType
    def set_productType(self, productType): self.productType = productType
    def add_productType(self, value): self.productType.append(value)
    def insert_productType_at(self, index, value): self.productType.insert(index, value)
    def replace_productType_at(self, index, value): self.productType[index] = value
    def get_productId(self): return self.productId
    def set_productId(self, productId): self.productId = productId
    def add_productId(self, value): self.productId.append(value)
    def insert_productId_at(self, index, value): self.productId.insert(index, value)
    def replace_productId_at(self, index, value): self.productId[index] = value
    def get_productId(self): return self.productId
    def set_productId(self, productId): self.productId = productId
    def add_productId(self, value): self.productId.append(value)
    def insert_productId_at(self, index, value): self.productId.insert(index, value)
    def replace_productId_at(self, index, value): self.productId[index] = value
    def get_assetClass(self): return self.assetClass
    def set_assetClass(self, assetClass): self.assetClass = assetClass
    def add_assetClass(self, value): self.assetClass.append(value)
    def insert_assetClass_at(self, index, value): self.assetClass.insert(index, value)
    def replace_assetClass_at(self, index, value): self.assetClass[index] = value
    def get_embeddedOptionType(self): return self.embeddedOptionType
    def set_embeddedOptionType(self, embeddedOptionType): self.embeddedOptionType = embeddedOptionType
    def add_embeddedOptionType(self, value): self.embeddedOptionType.append(value)
    def insert_embeddedOptionType_at(self, index, value): self.embeddedOptionType.insert(index, value)
    def replace_embeddedOptionType_at(self, index, value): self.embeddedOptionType[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.primaryAssetClass is not None or
            self.secondaryAssetClass or
            self.productType or
            self.productId or
            self.productId or
            self.assetClass or
            self.embeddedOptionType
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Product', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Product')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Product', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Product'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Product', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.primaryAssetClass is not None:
            self.primaryAssetClass.export(outfile, level, namespace_, name_='primaryAssetClass', pretty_print=pretty_print)
        for secondaryAssetClass_ in self.secondaryAssetClass:
            secondaryAssetClass_.export(outfile, level, namespace_, name_='secondaryAssetClass', pretty_print=pretty_print)
        for productType_ in self.productType:
            productType_.export(outfile, level, namespace_, name_='productType', pretty_print=pretty_print)
        for productId_ in self.productId:
            productId_.export(outfile, level, namespace_, name_='productId', pretty_print=pretty_print)
        for productId_ in self.productId:
            productId_.export(outfile, level, namespace_, name_='productId', pretty_print=pretty_print)
        for assetClass_ in self.assetClass:
            assetClass_.export(outfile, level, namespace_, name_='assetClass', pretty_print=pretty_print)
        for embeddedOptionType_ in self.embeddedOptionType:
            embeddedOptionType_.export(outfile, level, namespace_, name_='embeddedOptionType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'primaryAssetClass':
            obj_ = AssetClass.factory()
            obj_.build(child_)
            self.primaryAssetClass = obj_
            obj_.original_tagname_ = 'primaryAssetClass'
        elif nodeName_ == 'secondaryAssetClass':
            obj_ = AssetClass.factory()
            obj_.build(child_)
            self.secondaryAssetClass.append(obj_)
            obj_.original_tagname_ = 'secondaryAssetClass'
        elif nodeName_ == 'productType':
            obj_ = ProductType.factory()
            obj_.build(child_)
            self.productType.append(obj_)
            obj_.original_tagname_ = 'productType'
        elif nodeName_ == 'productId':
            obj_ = ProductId.factory()
            obj_.build(child_)
            self.productId.append(obj_)
            obj_.original_tagname_ = 'productId'
        elif nodeName_ == 'productId':
            obj_ = ProductId.factory()
            obj_.build(child_)
            self.productId.append(obj_)
            obj_.original_tagname_ = 'productId'
        elif nodeName_ == 'assetClass':
            obj_ = AssetClass.factory()
            obj_.build(child_)
            self.assetClass.append(obj_)
            obj_.original_tagname_ = 'assetClass'
        elif nodeName_ == 'embeddedOptionType':
            obj_ = EmbeddedOptionType.factory()
            obj_.build(child_)
            self.embeddedOptionType.append(obj_)
            obj_.original_tagname_ = 'embeddedOptionType'
# end class Product


class ProductId(GeneratedsSuper):
    member_data_items_ = {
        'productIdScheme': MemberSpec_('productIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyLongScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, productIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.productIdScheme = _cast(None, productIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductId.subclass:
            return ProductId.subclass(*args_, **kwargs_)
        else:
            return ProductId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_productIdScheme(self): return self.productIdScheme
    def set_productIdScheme(self, productIdScheme): self.productIdScheme = productIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ProductId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ProductId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProductId'):
        if self.productIdScheme is not None and 'productIdScheme' not in already_processed:
            already_processed.add('productIdScheme')
            outfile.write(' productIdScheme=%s' % (quote_attrib(self.productIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ProductId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('productIdScheme', node)
        if value is not None and 'productIdScheme' not in already_processed:
            already_processed.add('productIdScheme')
            self.productIdScheme = value
            self.validate_NonEmptyURI(self.productIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ProductId


class ProductType(GeneratedsSuper):
    member_data_items_ = {
        'productTypeScheme': MemberSpec_('productTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyLongScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, productTypeScheme='http://www.fpml.org/coding-scheme/product-taxonomy', valueOf_=None):
        self.original_tagname_ = None
        self.productTypeScheme = _cast(None, productTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductType.subclass:
            return ProductType.subclass(*args_, **kwargs_)
        else:
            return ProductType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_productTypeScheme(self): return self.productTypeScheme
    def set_productTypeScheme(self, productTypeScheme): self.productTypeScheme = productTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ProductType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ProductType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProductType'):
        if self.productTypeScheme != "http://www.fpml.org/coding-scheme/product-taxonomy" and 'productTypeScheme' not in already_processed:
            already_processed.add('productTypeScheme')
            outfile.write(' productTypeScheme=%s' % (quote_attrib(self.productTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ProductType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('productTypeScheme', node)
        if value is not None and 'productTypeScheme' not in already_processed:
            already_processed.add('productTypeScheme')
            self.productTypeScheme = value
            self.validate_NonEmptyURI(self.productTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ProductType


class ProposedCollateralAllocation(GeneratedsSuper):
    """The proposed collateral allocation."""
    member_data_items_ = {
        'allocationPartyReference': MemberSpec_('allocationPartyReference', 'PartyReference', 0),
        'allocationAccountReference': MemberSpec_('allocationAccountReference', 'AccountReference', 0),
        'collateralValueAllocation': MemberSpec_('collateralValueAllocation', 'CollateralValueAllocation', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, allocationPartyReference=None, allocationAccountReference=None, collateralValueAllocation=None):
        self.original_tagname_ = None
        self.allocationPartyReference = allocationPartyReference
        self.allocationAccountReference = allocationAccountReference
        if collateralValueAllocation is None:
            self.collateralValueAllocation = []
        else:
            self.collateralValueAllocation = collateralValueAllocation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProposedCollateralAllocation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProposedCollateralAllocation.subclass:
            return ProposedCollateralAllocation.subclass(*args_, **kwargs_)
        else:
            return ProposedCollateralAllocation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_allocationPartyReference(self): return self.allocationPartyReference
    def set_allocationPartyReference(self, allocationPartyReference): self.allocationPartyReference = allocationPartyReference
    def get_allocationAccountReference(self): return self.allocationAccountReference
    def set_allocationAccountReference(self, allocationAccountReference): self.allocationAccountReference = allocationAccountReference
    def get_collateralValueAllocation(self): return self.collateralValueAllocation
    def set_collateralValueAllocation(self, collateralValueAllocation): self.collateralValueAllocation = collateralValueAllocation
    def add_collateralValueAllocation(self, value): self.collateralValueAllocation.append(value)
    def insert_collateralValueAllocation_at(self, index, value): self.collateralValueAllocation.insert(index, value)
    def replace_collateralValueAllocation_at(self, index, value): self.collateralValueAllocation[index] = value
    def hasContent_(self):
        if (
            self.allocationPartyReference is not None or
            self.allocationAccountReference is not None or
            self.collateralValueAllocation
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ProposedCollateralAllocation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProposedCollateralAllocation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ProposedCollateralAllocation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProposedCollateralAllocation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ProposedCollateralAllocation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.allocationPartyReference is not None:
            self.allocationPartyReference.export(outfile, level, namespace_, name_='allocationPartyReference', pretty_print=pretty_print)
        if self.allocationAccountReference is not None:
            self.allocationAccountReference.export(outfile, level, namespace_, name_='allocationAccountReference', pretty_print=pretty_print)
        for collateralValueAllocation_ in self.collateralValueAllocation:
            collateralValueAllocation_.export(outfile, level, namespace_, name_='collateralValueAllocation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'allocationPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.allocationPartyReference = obj_
            obj_.original_tagname_ = 'allocationPartyReference'
        elif nodeName_ == 'allocationAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.allocationAccountReference = obj_
            obj_.original_tagname_ = 'allocationAccountReference'
        elif nodeName_ == 'collateralValueAllocation':
            obj_ = CollateralValueAllocation.factory()
            obj_.build(child_)
            self.collateralValueAllocation.append(obj_)
            obj_.original_tagname_ = 'collateralValueAllocation'
# end class ProposedCollateralAllocation


class QuotedCurrencyPair(GeneratedsSuper):
    """A type that describes the composition of a rate that has been quoted
    or is to be quoted. This includes the two currencies and the
    quotation relationship between the two currencies and is used as
    a building block throughout the FX specification."""
    member_data_items_ = {
        'currency1': MemberSpec_('currency1', 'Currency', 0),
        'currency2': MemberSpec_('currency2', 'Currency', 0),
        'quoteBasis': MemberSpec_('quoteBasis', ['QuoteBasisEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, currency1=None, currency2=None, quoteBasis=None):
        self.original_tagname_ = None
        self.currency1 = currency1
        self.currency2 = currency2
        self.quoteBasis = quoteBasis
        self.validate_QuoteBasisEnum(self.quoteBasis)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QuotedCurrencyPair)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QuotedCurrencyPair.subclass:
            return QuotedCurrencyPair.subclass(*args_, **kwargs_)
        else:
            return QuotedCurrencyPair(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_currency1(self): return self.currency1
    def set_currency1(self, currency1): self.currency1 = currency1
    def get_currency2(self): return self.currency2
    def set_currency2(self, currency2): self.currency2 = currency2
    def get_quoteBasis(self): return self.quoteBasis
    def set_quoteBasis(self, quoteBasis): self.quoteBasis = quoteBasis
    def validate_QuoteBasisEnum(self, value):
        # Validate type QuoteBasisEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Currency1PerCurrency2', 'Currency2PerCurrency1']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on QuoteBasisEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on QuoteBasisEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.currency1 is not None or
            self.currency2 is not None or
            self.quoteBasis is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QuotedCurrencyPair', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QuotedCurrencyPair')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QuotedCurrencyPair', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QuotedCurrencyPair'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='QuotedCurrencyPair', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.currency1 is not None:
            self.currency1.export(outfile, level, namespace_, name_='currency1', pretty_print=pretty_print)
        if self.currency2 is not None:
            self.currency2.export(outfile, level, namespace_, name_='currency2', pretty_print=pretty_print)
        if self.quoteBasis is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%squoteBasis>%s</%squoteBasis>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.quoteBasis), input_name='quoteBasis')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'currency1':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency1 = obj_
            obj_.original_tagname_ = 'currency1'
        elif nodeName_ == 'currency2':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency2 = obj_
            obj_.original_tagname_ = 'currency2'
        elif nodeName_ == 'quoteBasis':
            quoteBasis_ = child_.text
            quoteBasis_ = re_.sub(String_cleanup_pat_, " ", quoteBasis_).strip()
            quoteBasis_ = self.gds_validate_string(quoteBasis_, node, 'quoteBasis')
            self.quoteBasis = quoteBasis_
            # validate type QuoteBasisEnum
            self.validate_QuoteBasisEnum(self.quoteBasis)
# end class QuotedCurrencyPair


class Rate(GeneratedsSuper):
    """The abstract base class for all types which define interest rate
    streams."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Rate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Rate.subclass:
            return Rate.subclass(*args_, **kwargs_)
        else:
            return Rate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Rate', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Rate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Rate', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Rate'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Rate', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Rate


class RateObservation(GeneratedsSuper):
    """A type defining parameters associated with an individual observation
    or fixing. This type forms part of the cashflow representation
    of a stream."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'resetDate': MemberSpec_('resetDate', 'xsd:date', 0),
        'adjustedFixingDate': MemberSpec_('adjustedFixingDate', 'xsd:date', 0),
        'observedRate': MemberSpec_('observedRate', 'xsd:decimal', 0),
        'treatedRate': MemberSpec_('treatedRate', 'xsd:decimal', 0),
        'observationWeight': MemberSpec_('observationWeight', 'xsd:positiveInteger', 0),
        'rateReference': MemberSpec_('rateReference', 'RateReference', 0),
        'forecastRate': MemberSpec_('forecastRate', 'xsd:decimal', 0),
        'treatedForecastRate': MemberSpec_('treatedForecastRate', 'xsd:decimal', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, resetDate=None, adjustedFixingDate=None, observedRate=None, treatedRate=None, observationWeight=None, rateReference=None, forecastRate=None, treatedForecastRate=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if isinstance(resetDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(resetDate, '%Y-%m-%d').date()
        else:
            initvalue_ = resetDate
        self.resetDate = initvalue_
        if isinstance(adjustedFixingDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(adjustedFixingDate, '%Y-%m-%d').date()
        else:
            initvalue_ = adjustedFixingDate
        self.adjustedFixingDate = initvalue_
        self.observedRate = observedRate
        self.treatedRate = treatedRate
        self.observationWeight = observationWeight
        self.rateReference = rateReference
        self.forecastRate = forecastRate
        self.treatedForecastRate = treatedForecastRate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RateObservation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RateObservation.subclass:
            return RateObservation.subclass(*args_, **kwargs_)
        else:
            return RateObservation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_resetDate(self): return self.resetDate
    def set_resetDate(self, resetDate): self.resetDate = resetDate
    def get_adjustedFixingDate(self): return self.adjustedFixingDate
    def set_adjustedFixingDate(self, adjustedFixingDate): self.adjustedFixingDate = adjustedFixingDate
    def get_observedRate(self): return self.observedRate
    def set_observedRate(self, observedRate): self.observedRate = observedRate
    def get_treatedRate(self): return self.treatedRate
    def set_treatedRate(self, treatedRate): self.treatedRate = treatedRate
    def get_observationWeight(self): return self.observationWeight
    def set_observationWeight(self, observationWeight): self.observationWeight = observationWeight
    def get_rateReference(self): return self.rateReference
    def set_rateReference(self, rateReference): self.rateReference = rateReference
    def get_forecastRate(self): return self.forecastRate
    def set_forecastRate(self, forecastRate): self.forecastRate = forecastRate
    def get_treatedForecastRate(self): return self.treatedForecastRate
    def set_treatedForecastRate(self, treatedForecastRate): self.treatedForecastRate = treatedForecastRate
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.resetDate is not None or
            self.adjustedFixingDate is not None or
            self.observedRate is not None or
            self.treatedRate is not None or
            self.observationWeight is not None or
            self.rateReference is not None or
            self.forecastRate is not None or
            self.treatedForecastRate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RateObservation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RateObservation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RateObservation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RateObservation'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RateObservation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.resetDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sresetDate>%s</%sresetDate>%s' % (namespace_, self.gds_format_date(self.resetDate, input_name='resetDate'), namespace_, eol_))
        if self.adjustedFixingDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sadjustedFixingDate>%s</%sadjustedFixingDate>%s' % (namespace_, self.gds_format_date(self.adjustedFixingDate, input_name='adjustedFixingDate'), namespace_, eol_))
        if self.observedRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sobservedRate>%s</%sobservedRate>%s' % (namespace_, self.gds_format_float(self.observedRate, input_name='observedRate'), namespace_, eol_))
        if self.treatedRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%streatedRate>%s</%streatedRate>%s' % (namespace_, self.gds_format_float(self.treatedRate, input_name='treatedRate'), namespace_, eol_))
        if self.observationWeight is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sobservationWeight>%s</%sobservationWeight>%s' % (namespace_, self.gds_format_integer(self.observationWeight, input_name='observationWeight'), namespace_, eol_))
        if self.rateReference is not None:
            self.rateReference.export(outfile, level, namespace_, name_='rateReference', pretty_print=pretty_print)
        if self.forecastRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sforecastRate>%s</%sforecastRate>%s' % (namespace_, self.gds_format_float(self.forecastRate, input_name='forecastRate'), namespace_, eol_))
        if self.treatedForecastRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%streatedForecastRate>%s</%streatedForecastRate>%s' % (namespace_, self.gds_format_float(self.treatedForecastRate, input_name='treatedForecastRate'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'resetDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.resetDate = dval_
        elif nodeName_ == 'adjustedFixingDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.adjustedFixingDate = dval_
        elif nodeName_ == 'observedRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'observedRate')
            self.observedRate = fval_
        elif nodeName_ == 'treatedRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'treatedRate')
            self.treatedRate = fval_
        elif nodeName_ == 'observationWeight':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'observationWeight')
            self.observationWeight = ival_
        elif nodeName_ == 'rateReference':
            obj_ = RateReference.factory()
            obj_.build(child_)
            self.rateReference = obj_
            obj_.original_tagname_ = 'rateReference'
        elif nodeName_ == 'forecastRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'forecastRate')
            self.forecastRate = fval_
        elif nodeName_ == 'treatedForecastRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'treatedForecastRate')
            self.treatedForecastRate = fval_
# end class RateObservation


class RateReference(GeneratedsSuper):
    """Reference to any rate (floating, inflation) derived from the
    abstract Rate component."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, href=None):
        self.original_tagname_ = None
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RateReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RateReference.subclass:
            return RateReference.subclass(*args_, **kwargs_)
        else:
            return RateReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RateReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RateReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RateReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RateReference'):
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RateReference', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RateReference


class RateSourcePage(GeneratedsSuper):
    member_data_items_ = {
        'rateSourcePageScheme': MemberSpec_('rateSourcePageScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, rateSourcePageScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.rateSourcePageScheme = _cast(None, rateSourcePageScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RateSourcePage)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RateSourcePage.subclass:
            return RateSourcePage.subclass(*args_, **kwargs_)
        else:
            return RateSourcePage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rateSourcePageScheme(self): return self.rateSourcePageScheme
    def set_rateSourcePageScheme(self, rateSourcePageScheme): self.rateSourcePageScheme = rateSourcePageScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RateSourcePage', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RateSourcePage')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RateSourcePage', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RateSourcePage'):
        if self.rateSourcePageScheme is not None and 'rateSourcePageScheme' not in already_processed:
            already_processed.add('rateSourcePageScheme')
            outfile.write(' rateSourcePageScheme=%s' % (quote_attrib(self.rateSourcePageScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RateSourcePage', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('rateSourcePageScheme', node)
        if value is not None and 'rateSourcePageScheme' not in already_processed:
            already_processed.add('rateSourcePageScheme')
            self.rateSourcePageScheme = value
            self.validate_NonEmptyURI(self.rateSourcePageScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RateSourcePage


class Reference(GeneratedsSuper):
    """The abstract base class for all types which define intra-document
    pointers."""
    member_data_items_ = {
    }
    subclass = None
    superclass = None
    def __init__(self, extensiontype_=None):
        self.original_tagname_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Reference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Reference.subclass:
            return Reference.subclass(*args_, **kwargs_)
        else:
            return Reference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Reference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Reference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Reference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Reference'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Reference', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Reference


class ReferenceAmount(GeneratedsSuper):
    """Specifies the reference amount using a scheme."""
    member_data_items_ = {
        'referenceAmountScheme': MemberSpec_('referenceAmountScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, referenceAmountScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.referenceAmountScheme = _cast(None, referenceAmountScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferenceAmount)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferenceAmount.subclass:
            return ReferenceAmount.subclass(*args_, **kwargs_)
        else:
            return ReferenceAmount(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_referenceAmountScheme(self): return self.referenceAmountScheme
    def set_referenceAmountScheme(self, referenceAmountScheme): self.referenceAmountScheme = referenceAmountScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReferenceAmount', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceAmount')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReferenceAmount', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReferenceAmount'):
        if self.referenceAmountScheme is not None and 'referenceAmountScheme' not in already_processed:
            already_processed.add('referenceAmountScheme')
            outfile.write(' referenceAmountScheme=%s' % (quote_attrib(self.referenceAmountScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ReferenceAmount', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('referenceAmountScheme', node)
        if value is not None and 'referenceAmountScheme' not in already_processed:
            already_processed.add('referenceAmountScheme')
            self.referenceAmountScheme = value
            self.validate_NonEmptyURI(self.referenceAmountScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReferenceAmount


class ReferenceBank(GeneratedsSuper):
    """A type to describe an institution (party) identified by means of a
    coding scheme and an optional name."""
    member_data_items_ = {
        'referenceBankId': MemberSpec_('referenceBankId', 'ReferenceBankId', 0),
        'referenceBankName': MemberSpec_('referenceBankName', ['String', 'xsd:string'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, referenceBankId=None, referenceBankName=None):
        self.original_tagname_ = None
        self.referenceBankId = referenceBankId
        self.referenceBankName = referenceBankName
        self.validate_String(self.referenceBankName)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferenceBank)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferenceBank.subclass:
            return ReferenceBank.subclass(*args_, **kwargs_)
        else:
            return ReferenceBank(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_referenceBankId(self): return self.referenceBankId
    def set_referenceBankId(self, referenceBankId): self.referenceBankId = referenceBankId
    def get_referenceBankName(self): return self.referenceBankName
    def set_referenceBankName(self, referenceBankName): self.referenceBankName = referenceBankName
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.referenceBankId is not None or
            self.referenceBankName is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReferenceBank', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceBank')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReferenceBank', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReferenceBank'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ReferenceBank', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.referenceBankId is not None:
            self.referenceBankId.export(outfile, level, namespace_, name_='referenceBankId', pretty_print=pretty_print)
        if self.referenceBankName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreferenceBankName>%s</%sreferenceBankName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.referenceBankName), input_name='referenceBankName')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'referenceBankId':
            obj_ = ReferenceBankId.factory()
            obj_.build(child_)
            self.referenceBankId = obj_
            obj_.original_tagname_ = 'referenceBankId'
        elif nodeName_ == 'referenceBankName':
            referenceBankName_ = child_.text
            referenceBankName_ = self.gds_validate_string(referenceBankName_, node, 'referenceBankName')
            self.referenceBankName = referenceBankName_
            # validate type String
            self.validate_String(self.referenceBankName)
# end class ReferenceBank


class ReferenceBankId(GeneratedsSuper):
    member_data_items_ = {
        'referenceBankIdScheme': MemberSpec_('referenceBankIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, referenceBankIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.referenceBankIdScheme = _cast(None, referenceBankIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferenceBankId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferenceBankId.subclass:
            return ReferenceBankId.subclass(*args_, **kwargs_)
        else:
            return ReferenceBankId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_referenceBankIdScheme(self): return self.referenceBankIdScheme
    def set_referenceBankIdScheme(self, referenceBankIdScheme): self.referenceBankIdScheme = referenceBankIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReferenceBankId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceBankId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReferenceBankId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReferenceBankId'):
        if self.referenceBankIdScheme is not None and 'referenceBankIdScheme' not in already_processed:
            already_processed.add('referenceBankIdScheme')
            outfile.write(' referenceBankIdScheme=%s' % (quote_attrib(self.referenceBankIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ReferenceBankId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('referenceBankIdScheme', node)
        if value is not None and 'referenceBankIdScheme' not in already_processed:
            already_processed.add('referenceBankIdScheme')
            self.referenceBankIdScheme = value
            self.validate_NonEmptyURI(self.referenceBankIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReferenceBankId


class Region(GeneratedsSuper):
    """A code that describes the world region of a counterparty. For
    example, NorthAmerica, Europe, Asia."""
    member_data_items_ = {
        'regionScheme': MemberSpec_('regionScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, regionScheme='http://www.fpml.org/coding-scheme/region', valueOf_=None):
        self.original_tagname_ = None
        self.regionScheme = _cast(None, regionScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Region)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Region.subclass:
            return Region.subclass(*args_, **kwargs_)
        else:
            return Region(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_regionScheme(self): return self.regionScheme
    def set_regionScheme(self, regionScheme): self.regionScheme = regionScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Region', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Region')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Region', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Region'):
        if self.regionScheme != "http://www.fpml.org/coding-scheme/region" and 'regionScheme' not in already_processed:
            already_processed.add('regionScheme')
            outfile.write(' regionScheme=%s' % (quote_attrib(self.regionScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Region', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('regionScheme', node)
        if value is not None and 'regionScheme' not in already_processed:
            already_processed.add('regionScheme')
            self.regionScheme = value
            self.validate_NonEmptyURI(self.regionScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Region


class RelatedBusinessUnit(GeneratedsSuper):
    member_data_items_ = {
        'businessUnitReference': MemberSpec_('businessUnitReference', 'BusinessUnitReference', 0),
        'role': MemberSpec_('role', 'BusinessUnitRole', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, businessUnitReference=None, role=None):
        self.original_tagname_ = None
        self.businessUnitReference = businessUnitReference
        self.role = role
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RelatedBusinessUnit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RelatedBusinessUnit.subclass:
            return RelatedBusinessUnit.subclass(*args_, **kwargs_)
        else:
            return RelatedBusinessUnit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_businessUnitReference(self): return self.businessUnitReference
    def set_businessUnitReference(self, businessUnitReference): self.businessUnitReference = businessUnitReference
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def hasContent_(self):
        if (
            self.businessUnitReference is not None or
            self.role is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RelatedBusinessUnit', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RelatedBusinessUnit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RelatedBusinessUnit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RelatedBusinessUnit'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RelatedBusinessUnit', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.businessUnitReference is not None:
            self.businessUnitReference.export(outfile, level, namespace_, name_='businessUnitReference', pretty_print=pretty_print)
        if self.role is not None:
            self.role.export(outfile, level, namespace_, name_='role', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'businessUnitReference':
            obj_ = BusinessUnitReference.factory()
            obj_.build(child_)
            self.businessUnitReference = obj_
            obj_.original_tagname_ = 'businessUnitReference'
        elif nodeName_ == 'role':
            obj_ = BusinessUnitRole.factory()
            obj_.build(child_)
            self.role = obj_
            obj_.original_tagname_ = 'role'
# end class RelatedBusinessUnit


class RelatedParty(GeneratedsSuper):
    member_data_items_ = {
        'partyReference': MemberSpec_('partyReference', 'PartyReference', 0),
        'accountReference': MemberSpec_('accountReference', 'AccountReference', 0),
        'role': MemberSpec_('role', 'PartyRole', 0),
        'type_': MemberSpec_('type_', 'PartyRoleType', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, partyReference=None, accountReference=None, role=None, type_=None):
        self.original_tagname_ = None
        self.partyReference = partyReference
        self.accountReference = accountReference
        self.role = role
        self.type_ = type_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RelatedParty)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RelatedParty.subclass:
            return RelatedParty.subclass(*args_, **kwargs_)
        else:
            return RelatedParty(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyReference(self): return self.partyReference
    def set_partyReference(self, partyReference): self.partyReference = partyReference
    def get_accountReference(self): return self.accountReference
    def set_accountReference(self, accountReference): self.accountReference = accountReference
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (
            self.partyReference is not None or
            self.accountReference is not None or
            self.role is not None or
            self.type_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RelatedParty', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RelatedParty')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RelatedParty', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RelatedParty'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RelatedParty', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.partyReference is not None:
            self.partyReference.export(outfile, level, namespace_, name_='partyReference', pretty_print=pretty_print)
        if self.accountReference is not None:
            self.accountReference.export(outfile, level, namespace_, name_='accountReference', pretty_print=pretty_print)
        if self.role is not None:
            self.role.export(outfile, level, namespace_, name_='role', pretty_print=pretty_print)
        if self.type_ is not None:
            self.type_.export(outfile, level, namespace_, name_='type', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'partyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.partyReference = obj_
            obj_.original_tagname_ = 'partyReference'
        elif nodeName_ == 'accountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.accountReference = obj_
            obj_.original_tagname_ = 'accountReference'
        elif nodeName_ == 'role':
            obj_ = PartyRole.factory()
            obj_.build(child_)
            self.role = obj_
            obj_.original_tagname_ = 'role'
        elif nodeName_ == 'type':
            obj_ = PartyRoleType.factory()
            obj_.build(child_)
            self.type_ = obj_
            obj_.original_tagname_ = 'type'
# end class RelatedParty


class RelatedPerson(GeneratedsSuper):
    member_data_items_ = {
        'personReference': MemberSpec_('personReference', 'PersonReference', 0),
        'role': MemberSpec_('role', 'PersonRole', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, personReference=None, role=None):
        self.original_tagname_ = None
        self.personReference = personReference
        self.role = role
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RelatedPerson)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RelatedPerson.subclass:
            return RelatedPerson.subclass(*args_, **kwargs_)
        else:
            return RelatedPerson(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_personReference(self): return self.personReference
    def set_personReference(self, personReference): self.personReference = personReference
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def hasContent_(self):
        if (
            self.personReference is not None or
            self.role is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RelatedPerson', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RelatedPerson')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RelatedPerson', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RelatedPerson'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RelatedPerson', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.personReference is not None:
            self.personReference.export(outfile, level, namespace_, name_='personReference', pretty_print=pretty_print)
        if self.role is not None:
            self.role.export(outfile, level, namespace_, name_='role', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'personReference':
            obj_ = PersonReference.factory()
            obj_.build(child_)
            self.personReference = obj_
            obj_.original_tagname_ = 'personReference'
        elif nodeName_ == 'role':
            obj_ = PersonRole.factory()
            obj_.build(child_)
            self.role = obj_
            obj_.original_tagname_ = 'role'
# end class RelatedPerson


class RelativeDateSequence(GeneratedsSuper):
    """A type describing a date when this date is defined in reference to
    another date through one or several date offsets."""
    member_data_items_ = {
        'dateRelativeTo': MemberSpec_('dateRelativeTo', 'DateReference', 0),
        'dateOffset': MemberSpec_('dateOffset', 'DateOffset', 1),
        'businessCentersReference': MemberSpec_('businessCentersReference', 'BusinessCentersReference', 0),
        'businessCenters': MemberSpec_('businessCenters', 'BusinessCenters', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, dateRelativeTo=None, dateOffset=None, businessCentersReference=None, businessCenters=None):
        self.original_tagname_ = None
        self.dateRelativeTo = dateRelativeTo
        if dateOffset is None:
            self.dateOffset = []
        else:
            self.dateOffset = dateOffset
        self.businessCentersReference = businessCentersReference
        self.businessCenters = businessCenters
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RelativeDateSequence)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RelativeDateSequence.subclass:
            return RelativeDateSequence.subclass(*args_, **kwargs_)
        else:
            return RelativeDateSequence(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dateRelativeTo(self): return self.dateRelativeTo
    def set_dateRelativeTo(self, dateRelativeTo): self.dateRelativeTo = dateRelativeTo
    def get_dateOffset(self): return self.dateOffset
    def set_dateOffset(self, dateOffset): self.dateOffset = dateOffset
    def add_dateOffset(self, value): self.dateOffset.append(value)
    def insert_dateOffset_at(self, index, value): self.dateOffset.insert(index, value)
    def replace_dateOffset_at(self, index, value): self.dateOffset[index] = value
    def get_businessCentersReference(self): return self.businessCentersReference
    def set_businessCentersReference(self, businessCentersReference): self.businessCentersReference = businessCentersReference
    def get_businessCenters(self): return self.businessCenters
    def set_businessCenters(self, businessCenters): self.businessCenters = businessCenters
    def hasContent_(self):
        if (
            self.dateRelativeTo is not None or
            self.dateOffset or
            self.businessCentersReference is not None or
            self.businessCenters is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RelativeDateSequence', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RelativeDateSequence')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RelativeDateSequence', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RelativeDateSequence'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RelativeDateSequence', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dateRelativeTo is not None:
            self.dateRelativeTo.export(outfile, level, namespace_, name_='dateRelativeTo', pretty_print=pretty_print)
        for dateOffset_ in self.dateOffset:
            dateOffset_.export(outfile, level, namespace_, name_='dateOffset', pretty_print=pretty_print)
        if self.businessCentersReference is not None:
            self.businessCentersReference.export(outfile, level, namespace_, name_='businessCentersReference', pretty_print=pretty_print)
        if self.businessCenters is not None:
            self.businessCenters.export(outfile, level, namespace_, name_='businessCenters', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dateRelativeTo':
            obj_ = DateReference.factory()
            obj_.build(child_)
            self.dateRelativeTo = obj_
            obj_.original_tagname_ = 'dateRelativeTo'
        elif nodeName_ == 'dateOffset':
            obj_ = DateOffset.factory()
            obj_.build(child_)
            self.dateOffset.append(obj_)
            obj_.original_tagname_ = 'dateOffset'
        elif nodeName_ == 'businessCentersReference':
            obj_ = BusinessCentersReference.factory()
            obj_.build(child_)
            self.businessCentersReference = obj_
            obj_.original_tagname_ = 'businessCentersReference'
        elif nodeName_ == 'businessCenters':
            obj_ = BusinessCenters.factory()
            obj_.build(child_)
            self.businessCenters = obj_
            obj_.original_tagname_ = 'businessCenters'
# end class RelativeDateSequence


class ReportingRegimeName(GeneratedsSuper):
    """An identifier of an reporting regime or format used for regulatory
    reporting, for example DoddFrankAct, MiFID,
    HongKongOTCDRepository, etc."""
    member_data_items_ = {
        'reportingRegimeNameScheme': MemberSpec_('reportingRegimeNameScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, reportingRegimeNameScheme='http://www.fpml.org/coding-scheme/reporting-regime', valueOf_=None):
        self.original_tagname_ = None
        self.reportingRegimeNameScheme = _cast(None, reportingRegimeNameScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReportingRegimeName)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReportingRegimeName.subclass:
            return ReportingRegimeName.subclass(*args_, **kwargs_)
        else:
            return ReportingRegimeName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_reportingRegimeNameScheme(self): return self.reportingRegimeNameScheme
    def set_reportingRegimeNameScheme(self, reportingRegimeNameScheme): self.reportingRegimeNameScheme = reportingRegimeNameScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReportingRegimeName', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReportingRegimeName')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReportingRegimeName', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReportingRegimeName'):
        if self.reportingRegimeNameScheme != "http://www.fpml.org/coding-scheme/reporting-regime" and 'reportingRegimeNameScheme' not in already_processed:
            already_processed.add('reportingRegimeNameScheme')
            outfile.write(' reportingRegimeNameScheme=%s' % (quote_attrib(self.reportingRegimeNameScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ReportingRegimeName', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('reportingRegimeNameScheme', node)
        if value is not None and 'reportingRegimeNameScheme' not in already_processed:
            already_processed.add('reportingRegimeNameScheme')
            self.reportingRegimeNameScheme = value
            self.validate_NonEmptyURI(self.reportingRegimeNameScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReportingRegimeName


class RequestedAction(GeneratedsSuper):
    member_data_items_ = {
        'requestedActionScheme': MemberSpec_('requestedActionScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, requestedActionScheme='http://www.fpml.org/coding-scheme/requested-action', valueOf_=None):
        self.original_tagname_ = None
        self.requestedActionScheme = _cast(None, requestedActionScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RequestedAction)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RequestedAction.subclass:
            return RequestedAction.subclass(*args_, **kwargs_)
        else:
            return RequestedAction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_requestedActionScheme(self): return self.requestedActionScheme
    def set_requestedActionScheme(self, requestedActionScheme): self.requestedActionScheme = requestedActionScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RequestedAction', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RequestedAction')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RequestedAction', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RequestedAction'):
        if self.requestedActionScheme != "http://www.fpml.org/coding-scheme/requested-action" and 'requestedActionScheme' not in already_processed:
            already_processed.add('requestedActionScheme')
            outfile.write(' requestedActionScheme=%s' % (quote_attrib(self.requestedActionScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RequestedAction', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('requestedActionScheme', node)
        if value is not None and 'requestedActionScheme' not in already_processed:
            already_processed.add('requestedActionScheme')
            self.requestedActionScheme = value
            self.validate_NonEmptyURI(self.requestedActionScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RequestedAction


class RequiredIdentifierDate(GeneratedsSuper):
    """A date with a required identifier which can be referenced elsewhere."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'valueOf_': MemberSpec_('valueOf_', 'xsd:date', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RequiredIdentifierDate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RequiredIdentifierDate.subclass:
            return RequiredIdentifierDate.subclass(*args_, **kwargs_)
        else:
            return RequiredIdentifierDate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RequiredIdentifierDate', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RequiredIdentifierDate')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RequiredIdentifierDate', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RequiredIdentifierDate'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RequiredIdentifierDate', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RequiredIdentifierDate


class ResetFrequency(Frequency):
    """A type defining the reset frequency. In the case of a weekly reset,
    also specifies the day of the week that the reset occurs. If the
    reset frequency is greater than the calculation period frequency
    the this implies that more or more reset dates is established
    for each calculation period and some form of rate averaginhg is
    applicable. The specific averaging method of calculation is
    specified in FloatingRateCalculation. In case the reset
    frequency is of value T (term), the period is defined by the
    swap\swapStream\calculationPerioDates\effectiveDate and the
    swap\swapStream\calculationPerioDates\terminationDate."""
    member_data_items_ = {
        'weeklyRollConvention': MemberSpec_('weeklyRollConvention', ['WeeklyRollConventionEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = Frequency
    def __init__(self, id=None, periodMultiplier=None, period=None, weeklyRollConvention=None):
        self.original_tagname_ = None
        super(ResetFrequency, self).__init__(id, periodMultiplier, period, )
        self.weeklyRollConvention = weeklyRollConvention
        self.validate_WeeklyRollConventionEnum(self.weeklyRollConvention)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResetFrequency)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResetFrequency.subclass:
            return ResetFrequency.subclass(*args_, **kwargs_)
        else:
            return ResetFrequency(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_weeklyRollConvention(self): return self.weeklyRollConvention
    def set_weeklyRollConvention(self, weeklyRollConvention): self.weeklyRollConvention = weeklyRollConvention
    def validate_WeeklyRollConventionEnum(self, value):
        # Validate type WeeklyRollConventionEnum, a restriction on Token.
        pass
    def hasContent_(self):
        if (
            self.weeklyRollConvention is not None or
            super(ResetFrequency, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ResetFrequency', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResetFrequency')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ResetFrequency', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ResetFrequency'):
        super(ResetFrequency, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ResetFrequency')
    def exportChildren(self, outfile, level, namespace_='', name_='ResetFrequency', fromsubclass_=False, pretty_print=True):
        super(ResetFrequency, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.weeklyRollConvention is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sweeklyRollConvention>%s</%sweeklyRollConvention>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.weeklyRollConvention), input_name='weeklyRollConvention')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ResetFrequency, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'weeklyRollConvention':
            weeklyRollConvention_ = child_.text
            weeklyRollConvention_ = re_.sub(String_cleanup_pat_, " ", weeklyRollConvention_).strip()
            weeklyRollConvention_ = self.gds_validate_string(weeklyRollConvention_, node, 'weeklyRollConvention')
            self.weeklyRollConvention = weeklyRollConvention_
            # validate type WeeklyRollConventionEnum
            self.validate_WeeklyRollConventionEnum(self.weeklyRollConvention)
        super(ResetFrequency, self).buildChildren(child_, node, nodeName_, True)
# end class ResetFrequency


class Resource(GeneratedsSuper):
    """Describes the resource that contains the media representation of a
    business event (i.e used for stating the Publicly Available
    Information). For example, can describe a file or a URL that
    represents the event. This type is an extended version of a type
    defined by RIXML (www.rixml.org)."""
    member_data_items_ = {
        'resourceId': MemberSpec_('resourceId', 'ResourceId', 0),
        'resourceType': MemberSpec_('resourceType', 'ResourceType', 0),
        'language': MemberSpec_('language', 'Language', 0),
        'sizeInBytes': MemberSpec_('sizeInBytes', 'xsd:decimal', 0),
        'length': MemberSpec_('length', 'ResourceLength', 0),
        'mimeType': MemberSpec_('mimeType', 'MimeType', 0),
        'name': MemberSpec_('name', ['NormalizedString', 'xsd:normalizedString'], 0),
        'comments': MemberSpec_('comments', ['String', 'xsd:string'], 0),
        'string': MemberSpec_('string', ['String', 'xsd:string'], 0),
        'hexadecimalBinary': MemberSpec_('hexadecimalBinary', 'xsd:hexBinary', 0),
        'base64Binary': MemberSpec_('base64Binary', 'xsd:base64Binary', 0),
        'url': MemberSpec_('url', ['NonEmptyURI', 'xsd:anyURI'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, resourceId=None, resourceType=None, language=None, sizeInBytes=None, length=None, mimeType=None, name=None, comments=None, string=None, hexadecimalBinary=None, base64Binary=None, url=None):
        self.original_tagname_ = None
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.language = language
        self.sizeInBytes = sizeInBytes
        self.length = length
        self.mimeType = mimeType
        self.name = name
        self.validate_NormalizedString(self.name)
        self.comments = comments
        self.validate_String(self.comments)
        self.string = string
        self.validate_String(self.string)
        self.hexadecimalBinary = hexadecimalBinary
        self.base64Binary = base64Binary
        self.url = url
        self.validate_NonEmptyURI(self.url)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Resource)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Resource.subclass:
            return Resource.subclass(*args_, **kwargs_)
        else:
            return Resource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_resourceId(self): return self.resourceId
    def set_resourceId(self, resourceId): self.resourceId = resourceId
    def get_resourceType(self): return self.resourceType
    def set_resourceType(self, resourceType): self.resourceType = resourceType
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def get_sizeInBytes(self): return self.sizeInBytes
    def set_sizeInBytes(self, sizeInBytes): self.sizeInBytes = sizeInBytes
    def get_length(self): return self.length
    def set_length(self, length): self.length = length
    def get_mimeType(self): return self.mimeType
    def set_mimeType(self, mimeType): self.mimeType = mimeType
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_comments(self): return self.comments
    def set_comments(self, comments): self.comments = comments
    def get_string(self): return self.string
    def set_string(self, string): self.string = string
    def get_hexadecimalBinary(self): return self.hexadecimalBinary
    def set_hexadecimalBinary(self, hexadecimalBinary): self.hexadecimalBinary = hexadecimalBinary
    def get_base64Binary(self): return self.base64Binary
    def set_base64Binary(self, base64Binary): self.base64Binary = base64Binary
    def get_url(self): return self.url
    def set_url(self, url): self.url = url
    def validate_NormalizedString(self, value):
        # Validate type NormalizedString, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NormalizedString' % {"value" : value} )
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            self.resourceId is not None or
            self.resourceType is not None or
            self.language is not None or
            self.sizeInBytes is not None or
            self.length is not None or
            self.mimeType is not None or
            self.name is not None or
            self.comments is not None or
            self.string is not None or
            self.hexadecimalBinary is not None or
            self.base64Binary is not None or
            self.url is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Resource', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Resource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Resource', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Resource'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Resource', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.resourceId is not None:
            self.resourceId.export(outfile, level, namespace_, name_='resourceId', pretty_print=pretty_print)
        if self.resourceType is not None:
            self.resourceType.export(outfile, level, namespace_, name_='resourceType', pretty_print=pretty_print)
        if self.language is not None:
            self.language.export(outfile, level, namespace_, name_='language', pretty_print=pretty_print)
        if self.sizeInBytes is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssizeInBytes>%s</%ssizeInBytes>%s' % (namespace_, self.gds_format_float(self.sizeInBytes, input_name='sizeInBytes'), namespace_, eol_))
        if self.length is not None:
            self.length.export(outfile, level, namespace_, name_='length', pretty_print=pretty_print)
        if self.mimeType is not None:
            self.mimeType.export(outfile, level, namespace_, name_='mimeType', pretty_print=pretty_print)
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespace_, eol_))
        if self.comments is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomments>%s</%scomments>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.comments), input_name='comments')), namespace_, eol_))
        if self.string is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstring>%s</%sstring>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.string), input_name='string')), namespace_, eol_))
        if self.hexadecimalBinary is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shexadecimalBinary>%s</%shexadecimalBinary>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.hexadecimalBinary), input_name='hexadecimalBinary')), namespace_, eol_))
        if self.base64Binary is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbase64Binary>%s</%sbase64Binary>%s' % (namespace_, self.gds_format_base64(self.base64Binary, input_name='base64Binary'), namespace_, eol_))
        if self.url is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%surl>%s</%surl>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.url), input_name='url')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'resourceId':
            obj_ = ResourceId.factory()
            obj_.build(child_)
            self.resourceId = obj_
            obj_.original_tagname_ = 'resourceId'
        elif nodeName_ == 'resourceType':
            obj_ = ResourceType.factory()
            obj_.build(child_)
            self.resourceType = obj_
            obj_.original_tagname_ = 'resourceType'
        elif nodeName_ == 'language':
            obj_ = Language.factory()
            obj_.build(child_)
            self.language = obj_
            obj_.original_tagname_ = 'language'
        elif nodeName_ == 'sizeInBytes':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'sizeInBytes')
            self.sizeInBytes = fval_
        elif nodeName_ == 'length':
            obj_ = ResourceLength.factory()
            obj_.build(child_)
            self.length = obj_
            obj_.original_tagname_ = 'length'
        elif nodeName_ == 'mimeType':
            obj_ = MimeType.factory()
            obj_.build(child_)
            self.mimeType = obj_
            obj_.original_tagname_ = 'mimeType'
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
            # validate type NormalizedString
            self.validate_NormalizedString(self.name)
        elif nodeName_ == 'comments':
            comments_ = child_.text
            comments_ = self.gds_validate_string(comments_, node, 'comments')
            self.comments = comments_
            # validate type String
            self.validate_String(self.comments)
        elif nodeName_ == 'string':
            string_ = child_.text
            string_ = self.gds_validate_string(string_, node, 'string')
            self.string = string_
            # validate type String
            self.validate_String(self.string)
        elif nodeName_ == 'hexadecimalBinary':
            hexadecimalBinary_ = child_.text
            hexadecimalBinary_ = self.gds_validate_string(hexadecimalBinary_, node, 'hexadecimalBinary')
            self.hexadecimalBinary = hexadecimalBinary_
        elif nodeName_ == 'base64Binary':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'base64Binary')
            else:
                bval_ = None
            self.base64Binary = bval_
        elif nodeName_ == 'url':
            url_ = child_.text
            url_ = self.gds_validate_string(url_, node, 'url')
            self.url = url_
            # validate type NonEmptyURI
            self.validate_NonEmptyURI(self.url)
# end class Resource


class ResourceId(GeneratedsSuper):
    """The data type used for resource identifiers."""
    member_data_items_ = {
        'resourceIdScheme': MemberSpec_('resourceIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, resourceIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.resourceIdScheme = _cast(None, resourceIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResourceId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResourceId.subclass:
            return ResourceId.subclass(*args_, **kwargs_)
        else:
            return ResourceId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_resourceIdScheme(self): return self.resourceIdScheme
    def set_resourceIdScheme(self, resourceIdScheme): self.resourceIdScheme = resourceIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ResourceId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResourceId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ResourceId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ResourceId'):
        if self.resourceIdScheme is not None and 'resourceIdScheme' not in already_processed:
            already_processed.add('resourceIdScheme')
            outfile.write(' resourceIdScheme=%s' % (quote_attrib(self.resourceIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ResourceId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('resourceIdScheme', node)
        if value is not None and 'resourceIdScheme' not in already_processed:
            already_processed.add('resourceIdScheme')
            self.resourceIdScheme = value
            self.validate_NonEmptyURI(self.resourceIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ResourceId


class ResourceLength(GeneratedsSuper):
    """The type that indicates the length of the resource."""
    member_data_items_ = {
        'lengthUnit': MemberSpec_('lengthUnit', ['LengthUnitEnum', 'Token', 'xsd:token'], 0),
        'lengthValue': MemberSpec_('lengthValue', 'xsd:decimal', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, lengthUnit=None, lengthValue=None):
        self.original_tagname_ = None
        self.lengthUnit = lengthUnit
        self.validate_LengthUnitEnum(self.lengthUnit)
        self.lengthValue = lengthValue
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResourceLength)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResourceLength.subclass:
            return ResourceLength.subclass(*args_, **kwargs_)
        else:
            return ResourceLength(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lengthUnit(self): return self.lengthUnit
    def set_lengthUnit(self, lengthUnit): self.lengthUnit = lengthUnit
    def get_lengthValue(self): return self.lengthValue
    def set_lengthValue(self, lengthValue): self.lengthValue = lengthValue
    def validate_LengthUnitEnum(self, value):
        # Validate type LengthUnitEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Pages', 'TimeUnit']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on LengthUnitEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on LengthUnitEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.lengthUnit is not None or
            self.lengthValue is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ResourceLength', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResourceLength')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ResourceLength', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ResourceLength'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ResourceLength', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.lengthUnit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slengthUnit>%s</%slengthUnit>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.lengthUnit), input_name='lengthUnit')), namespace_, eol_))
        if self.lengthValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slengthValue>%s</%slengthValue>%s' % (namespace_, self.gds_format_float(self.lengthValue, input_name='lengthValue'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'lengthUnit':
            lengthUnit_ = child_.text
            lengthUnit_ = re_.sub(String_cleanup_pat_, " ", lengthUnit_).strip()
            lengthUnit_ = self.gds_validate_string(lengthUnit_, node, 'lengthUnit')
            self.lengthUnit = lengthUnit_
            # validate type LengthUnitEnum
            self.validate_LengthUnitEnum(self.lengthUnit)
        elif nodeName_ == 'lengthValue':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'lengthValue')
            self.lengthValue = fval_
# end class ResourceLength


class ResourceType(GeneratedsSuper):
    """The data type used for describing the type or purpose of a resource,
    e.g. "Confirmation"."""
    member_data_items_ = {
        'resourceTypeScheme': MemberSpec_('resourceTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, resourceTypeScheme='http://www.fpml.org/coding-scheme/resource-type', valueOf_=None):
        self.original_tagname_ = None
        self.resourceTypeScheme = _cast(None, resourceTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResourceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResourceType.subclass:
            return ResourceType.subclass(*args_, **kwargs_)
        else:
            return ResourceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_resourceTypeScheme(self): return self.resourceTypeScheme
    def set_resourceTypeScheme(self, resourceTypeScheme): self.resourceTypeScheme = resourceTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ResourceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResourceType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ResourceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ResourceType'):
        if self.resourceTypeScheme != "http://www.fpml.org/coding-scheme/resource-type" and 'resourceTypeScheme' not in already_processed:
            already_processed.add('resourceTypeScheme')
            outfile.write(' resourceTypeScheme=%s' % (quote_attrib(self.resourceTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ResourceType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('resourceTypeScheme', node)
        if value is not None and 'resourceTypeScheme' not in already_processed:
            already_processed.add('resourceTypeScheme')
            self.resourceTypeScheme = value
            self.validate_NonEmptyURI(self.resourceTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ResourceType


class ReturnSwapNotionalAmountReference(Reference):
    """A reference to the return swap notional amount."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(ReturnSwapNotionalAmountReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReturnSwapNotionalAmountReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReturnSwapNotionalAmountReference.subclass:
            return ReturnSwapNotionalAmountReference.subclass(*args_, **kwargs_)
        else:
            return ReturnSwapNotionalAmountReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(ReturnSwapNotionalAmountReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReturnSwapNotionalAmountReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReturnSwapNotionalAmountReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReturnSwapNotionalAmountReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReturnSwapNotionalAmountReference'):
        super(ReturnSwapNotionalAmountReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ReturnSwapNotionalAmountReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ReturnSwapNotionalAmountReference', fromsubclass_=False, pretty_print=True):
        super(ReturnSwapNotionalAmountReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(ReturnSwapNotionalAmountReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ReturnSwapNotionalAmountReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ReturnSwapNotionalAmountReference


class Rounding(GeneratedsSuper):
    """A type defining a rounding direction and precision to be used in the
    rounding of a rate."""
    member_data_items_ = {
        'roundingDirection': MemberSpec_('roundingDirection', ['RoundingDirectionEnum', 'Token', 'xsd:token'], 0),
        'precision': MemberSpec_('precision', 'xsd:nonNegativeInteger', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, roundingDirection=None, precision=None):
        self.original_tagname_ = None
        self.roundingDirection = roundingDirection
        self.validate_RoundingDirectionEnum(self.roundingDirection)
        self.precision = precision
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Rounding)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Rounding.subclass:
            return Rounding.subclass(*args_, **kwargs_)
        else:
            return Rounding(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_roundingDirection(self): return self.roundingDirection
    def set_roundingDirection(self, roundingDirection): self.roundingDirection = roundingDirection
    def get_precision(self): return self.precision
    def set_precision(self, precision): self.precision = precision
    def validate_RoundingDirectionEnum(self, value):
        # Validate type RoundingDirectionEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Up', 'Down', 'Nearest']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RoundingDirectionEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on RoundingDirectionEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.roundingDirection is not None or
            self.precision is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Rounding', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Rounding')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Rounding', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Rounding'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Rounding', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.roundingDirection is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sroundingDirection>%s</%sroundingDirection>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.roundingDirection), input_name='roundingDirection')), namespace_, eol_))
        if self.precision is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprecision>%s</%sprecision>%s' % (namespace_, self.gds_format_integer(self.precision, input_name='precision'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'roundingDirection':
            roundingDirection_ = child_.text
            roundingDirection_ = re_.sub(String_cleanup_pat_, " ", roundingDirection_).strip()
            roundingDirection_ = self.gds_validate_string(roundingDirection_, node, 'roundingDirection')
            self.roundingDirection = roundingDirection_
            # validate type RoundingDirectionEnum
            self.validate_RoundingDirectionEnum(self.roundingDirection)
        elif nodeName_ == 'precision':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'precision')
            self.precision = ival_
# end class Rounding


class Routing(GeneratedsSuper):
    """A type that provides three alternative ways of identifying a party
    involved in the routing of a payment. The identification may use
    payment system identifiers only; actual name, address and other
    reference information; or a combination of both."""
    member_data_items_ = {
        'routingIds': MemberSpec_('routingIds', 'RoutingIds', 0),
        'routingExplicitDetails': MemberSpec_('routingExplicitDetails', 'RoutingExplicitDetails', 0),
        'routingIdsAndExplicitDetails': MemberSpec_('routingIdsAndExplicitDetails', 'RoutingIdsAndExplicitDetails', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, routingIds=None, routingExplicitDetails=None, routingIdsAndExplicitDetails=None):
        self.original_tagname_ = None
        self.routingIds = routingIds
        self.routingExplicitDetails = routingExplicitDetails
        self.routingIdsAndExplicitDetails = routingIdsAndExplicitDetails
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Routing)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Routing.subclass:
            return Routing.subclass(*args_, **kwargs_)
        else:
            return Routing(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_routingIds(self): return self.routingIds
    def set_routingIds(self, routingIds): self.routingIds = routingIds
    def get_routingExplicitDetails(self): return self.routingExplicitDetails
    def set_routingExplicitDetails(self, routingExplicitDetails): self.routingExplicitDetails = routingExplicitDetails
    def get_routingIdsAndExplicitDetails(self): return self.routingIdsAndExplicitDetails
    def set_routingIdsAndExplicitDetails(self, routingIdsAndExplicitDetails): self.routingIdsAndExplicitDetails = routingIdsAndExplicitDetails
    def hasContent_(self):
        if (
            self.routingIds is not None or
            self.routingExplicitDetails is not None or
            self.routingIdsAndExplicitDetails is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Routing', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Routing')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Routing', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Routing'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Routing', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.routingIds is not None:
            self.routingIds.export(outfile, level, namespace_, name_='routingIds', pretty_print=pretty_print)
        if self.routingExplicitDetails is not None:
            self.routingExplicitDetails.export(outfile, level, namespace_, name_='routingExplicitDetails', pretty_print=pretty_print)
        if self.routingIdsAndExplicitDetails is not None:
            self.routingIdsAndExplicitDetails.export(outfile, level, namespace_, name_='routingIdsAndExplicitDetails', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'routingIds':
            obj_ = RoutingIds.factory()
            obj_.build(child_)
            self.routingIds = obj_
            obj_.original_tagname_ = 'routingIds'
        elif nodeName_ == 'routingExplicitDetails':
            obj_ = RoutingExplicitDetails.factory()
            obj_.build(child_)
            self.routingExplicitDetails = obj_
            obj_.original_tagname_ = 'routingExplicitDetails'
        elif nodeName_ == 'routingIdsAndExplicitDetails':
            obj_ = RoutingIdsAndExplicitDetails.factory()
            obj_.build(child_)
            self.routingIdsAndExplicitDetails = obj_
            obj_.original_tagname_ = 'routingIdsAndExplicitDetails'
# end class Routing


class RoutingExplicitDetails(GeneratedsSuper):
    """A type that models name, address and supplementary textual
    information for the purposes of identifying a party involved in
    the routing of a payment."""
    member_data_items_ = {
        'routingName': MemberSpec_('routingName', ['String', 'xsd:string'], 0),
        'routingAddress': MemberSpec_('routingAddress', 'Address', 0),
        'routingAccountNumber': MemberSpec_('routingAccountNumber', ['String', 'xsd:string'], 0),
        'routingReferenceText': MemberSpec_('routingReferenceText', ['String', 'xsd:string'], 1),
    }
    subclass = None
    superclass = None
    def __init__(self, routingName=None, routingAddress=None, routingAccountNumber=None, routingReferenceText=None):
        self.original_tagname_ = None
        self.routingName = routingName
        self.validate_String(self.routingName)
        self.routingAddress = routingAddress
        self.routingAccountNumber = routingAccountNumber
        self.validate_String(self.routingAccountNumber)
        if routingReferenceText is None:
            self.routingReferenceText = []
        else:
            self.routingReferenceText = routingReferenceText
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RoutingExplicitDetails)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RoutingExplicitDetails.subclass:
            return RoutingExplicitDetails.subclass(*args_, **kwargs_)
        else:
            return RoutingExplicitDetails(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_routingName(self): return self.routingName
    def set_routingName(self, routingName): self.routingName = routingName
    def get_routingAddress(self): return self.routingAddress
    def set_routingAddress(self, routingAddress): self.routingAddress = routingAddress
    def get_routingAccountNumber(self): return self.routingAccountNumber
    def set_routingAccountNumber(self, routingAccountNumber): self.routingAccountNumber = routingAccountNumber
    def get_routingReferenceText(self): return self.routingReferenceText
    def set_routingReferenceText(self, routingReferenceText): self.routingReferenceText = routingReferenceText
    def add_routingReferenceText(self, value): self.routingReferenceText.append(value)
    def insert_routingReferenceText_at(self, index, value): self.routingReferenceText.insert(index, value)
    def replace_routingReferenceText_at(self, index, value): self.routingReferenceText[index] = value
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.routingName is not None or
            self.routingAddress is not None or
            self.routingAccountNumber is not None or
            self.routingReferenceText
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RoutingExplicitDetails', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RoutingExplicitDetails')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RoutingExplicitDetails', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RoutingExplicitDetails'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RoutingExplicitDetails', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.routingName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sroutingName>%s</%sroutingName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.routingName), input_name='routingName')), namespace_, eol_))
        if self.routingAddress is not None:
            self.routingAddress.export(outfile, level, namespace_, name_='routingAddress', pretty_print=pretty_print)
        if self.routingAccountNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sroutingAccountNumber>%s</%sroutingAccountNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.routingAccountNumber), input_name='routingAccountNumber')), namespace_, eol_))
        for routingReferenceText_ in self.routingReferenceText:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sroutingReferenceText>%s</%sroutingReferenceText>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(routingReferenceText_), input_name='routingReferenceText')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'routingName':
            routingName_ = child_.text
            routingName_ = self.gds_validate_string(routingName_, node, 'routingName')
            self.routingName = routingName_
            # validate type String
            self.validate_String(self.routingName)
        elif nodeName_ == 'routingAddress':
            obj_ = Address.factory()
            obj_.build(child_)
            self.routingAddress = obj_
            obj_.original_tagname_ = 'routingAddress'
        elif nodeName_ == 'routingAccountNumber':
            routingAccountNumber_ = child_.text
            routingAccountNumber_ = self.gds_validate_string(routingAccountNumber_, node, 'routingAccountNumber')
            self.routingAccountNumber = routingAccountNumber_
            # validate type String
            self.validate_String(self.routingAccountNumber)
        elif nodeName_ == 'routingReferenceText':
            routingReferenceText_ = child_.text
            routingReferenceText_ = self.gds_validate_string(routingReferenceText_, node, 'routingReferenceText')
            self.routingReferenceText.append(routingReferenceText_)
            # validate type String
            self.validate_String(self.routingReferenceText[-1])
# end class RoutingExplicitDetails


class RoutingId(GeneratedsSuper):
    member_data_items_ = {
        'routingIdCodeScheme': MemberSpec_('routingIdCodeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, routingIdCodeScheme='http://www.fpml.org/coding-scheme/external/iso9362', valueOf_=None):
        self.original_tagname_ = None
        self.routingIdCodeScheme = _cast(None, routingIdCodeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RoutingId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RoutingId.subclass:
            return RoutingId.subclass(*args_, **kwargs_)
        else:
            return RoutingId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_routingIdCodeScheme(self): return self.routingIdCodeScheme
    def set_routingIdCodeScheme(self, routingIdCodeScheme): self.routingIdCodeScheme = routingIdCodeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RoutingId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RoutingId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RoutingId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RoutingId'):
        if self.routingIdCodeScheme != "http://www.fpml.org/coding-scheme/external/iso9362" and 'routingIdCodeScheme' not in already_processed:
            already_processed.add('routingIdCodeScheme')
            outfile.write(' routingIdCodeScheme=%s' % (quote_attrib(self.routingIdCodeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RoutingId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('routingIdCodeScheme', node)
        if value is not None and 'routingIdCodeScheme' not in already_processed:
            already_processed.add('routingIdCodeScheme')
            self.routingIdCodeScheme = value
            self.validate_NonEmptyURI(self.routingIdCodeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RoutingId


class RoutingIds(GeneratedsSuper):
    """A type that provides for identifying a party involved in the routing
    of a payment by means of one or more standard identification
    codes. For example, both a SWIFT BIC code and a national bank
    identifier may be required."""
    member_data_items_ = {
        'routingId': MemberSpec_('routingId', 'RoutingId', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, routingId=None):
        self.original_tagname_ = None
        if routingId is None:
            self.routingId = []
        else:
            self.routingId = routingId
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RoutingIds)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RoutingIds.subclass:
            return RoutingIds.subclass(*args_, **kwargs_)
        else:
            return RoutingIds(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_routingId(self): return self.routingId
    def set_routingId(self, routingId): self.routingId = routingId
    def add_routingId(self, value): self.routingId.append(value)
    def insert_routingId_at(self, index, value): self.routingId.insert(index, value)
    def replace_routingId_at(self, index, value): self.routingId[index] = value
    def hasContent_(self):
        if (
            self.routingId
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RoutingIds', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RoutingIds')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RoutingIds', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RoutingIds'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RoutingIds', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for routingId_ in self.routingId:
            routingId_.export(outfile, level, namespace_, name_='routingId', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'routingId':
            obj_ = RoutingId.factory()
            obj_.build(child_)
            self.routingId.append(obj_)
            obj_.original_tagname_ = 'routingId'
# end class RoutingIds


class RoutingIdsAndExplicitDetails(GeneratedsSuper):
    """A type that provides a combination of payment system identification
    codes with physical postal address details, for the purposes of
    identifying a party involved in the routing of a payment."""
    member_data_items_ = {
        'routingIds': MemberSpec_('routingIds', 'RoutingIds', 1),
        'routingName': MemberSpec_('routingName', ['String', 'xsd:string'], 0),
        'routingAddress': MemberSpec_('routingAddress', 'Address', 0),
        'routingAccountNumber': MemberSpec_('routingAccountNumber', ['String', 'xsd:string'], 0),
        'routingReferenceText': MemberSpec_('routingReferenceText', ['String', 'xsd:string'], 1),
    }
    subclass = None
    superclass = None
    def __init__(self, routingIds=None, routingName=None, routingAddress=None, routingAccountNumber=None, routingReferenceText=None):
        self.original_tagname_ = None
        if routingIds is None:
            self.routingIds = []
        else:
            self.routingIds = routingIds
        self.routingName = routingName
        self.validate_String(self.routingName)
        self.routingAddress = routingAddress
        self.routingAccountNumber = routingAccountNumber
        self.validate_String(self.routingAccountNumber)
        if routingReferenceText is None:
            self.routingReferenceText = []
        else:
            self.routingReferenceText = routingReferenceText
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RoutingIdsAndExplicitDetails)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RoutingIdsAndExplicitDetails.subclass:
            return RoutingIdsAndExplicitDetails.subclass(*args_, **kwargs_)
        else:
            return RoutingIdsAndExplicitDetails(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_routingIds(self): return self.routingIds
    def set_routingIds(self, routingIds): self.routingIds = routingIds
    def add_routingIds(self, value): self.routingIds.append(value)
    def insert_routingIds_at(self, index, value): self.routingIds.insert(index, value)
    def replace_routingIds_at(self, index, value): self.routingIds[index] = value
    def get_routingName(self): return self.routingName
    def set_routingName(self, routingName): self.routingName = routingName
    def get_routingAddress(self): return self.routingAddress
    def set_routingAddress(self, routingAddress): self.routingAddress = routingAddress
    def get_routingAccountNumber(self): return self.routingAccountNumber
    def set_routingAccountNumber(self, routingAccountNumber): self.routingAccountNumber = routingAccountNumber
    def get_routingReferenceText(self): return self.routingReferenceText
    def set_routingReferenceText(self, routingReferenceText): self.routingReferenceText = routingReferenceText
    def add_routingReferenceText(self, value): self.routingReferenceText.append(value)
    def insert_routingReferenceText_at(self, index, value): self.routingReferenceText.insert(index, value)
    def replace_routingReferenceText_at(self, index, value): self.routingReferenceText[index] = value
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.routingIds or
            self.routingName is not None or
            self.routingAddress is not None or
            self.routingAccountNumber is not None or
            self.routingReferenceText
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RoutingIdsAndExplicitDetails', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RoutingIdsAndExplicitDetails')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RoutingIdsAndExplicitDetails', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RoutingIdsAndExplicitDetails'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RoutingIdsAndExplicitDetails', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for routingIds_ in self.routingIds:
            routingIds_.export(outfile, level, namespace_, name_='routingIds', pretty_print=pretty_print)
        if self.routingName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sroutingName>%s</%sroutingName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.routingName), input_name='routingName')), namespace_, eol_))
        if self.routingAddress is not None:
            self.routingAddress.export(outfile, level, namespace_, name_='routingAddress', pretty_print=pretty_print)
        if self.routingAccountNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sroutingAccountNumber>%s</%sroutingAccountNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.routingAccountNumber), input_name='routingAccountNumber')), namespace_, eol_))
        for routingReferenceText_ in self.routingReferenceText:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sroutingReferenceText>%s</%sroutingReferenceText>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(routingReferenceText_), input_name='routingReferenceText')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'routingIds':
            obj_ = RoutingIds.factory()
            obj_.build(child_)
            self.routingIds.append(obj_)
            obj_.original_tagname_ = 'routingIds'
        elif nodeName_ == 'routingName':
            routingName_ = child_.text
            routingName_ = self.gds_validate_string(routingName_, node, 'routingName')
            self.routingName = routingName_
            # validate type String
            self.validate_String(self.routingName)
        elif nodeName_ == 'routingAddress':
            obj_ = Address.factory()
            obj_.build(child_)
            self.routingAddress = obj_
            obj_.original_tagname_ = 'routingAddress'
        elif nodeName_ == 'routingAccountNumber':
            routingAccountNumber_ = child_.text
            routingAccountNumber_ = self.gds_validate_string(routingAccountNumber_, node, 'routingAccountNumber')
            self.routingAccountNumber = routingAccountNumber_
            # validate type String
            self.validate_String(self.routingAccountNumber)
        elif nodeName_ == 'routingReferenceText':
            routingReferenceText_ = child_.text
            routingReferenceText_ = self.gds_validate_string(routingReferenceText_, node, 'routingReferenceText')
            self.routingReferenceText.append(routingReferenceText_)
            # validate type String
            self.validate_String(self.routingReferenceText[-1])
# end class RoutingIdsAndExplicitDetails


class Schedule(GeneratedsSuper):
    """A type defining a schedule of rates or amounts in terms of an
    initial value and then a series of step date and value pairs. On
    each step date the rate or amount changes to the new step value.
    The series of step date and value pairs are optional. If not
    specified, this implies that the initial value remains unchanged
    over time."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'initialValue': MemberSpec_('initialValue', 'xsd:decimal', 0),
        'step': MemberSpec_('step', 'Step', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, initialValue=None, step=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.initialValue = initialValue
        if step is None:
            self.step = []
        else:
            self.step = step
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Schedule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Schedule.subclass:
            return Schedule.subclass(*args_, **kwargs_)
        else:
            return Schedule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_initialValue(self): return self.initialValue
    def set_initialValue(self, initialValue): self.initialValue = initialValue
    def get_step(self): return self.step
    def set_step(self, step): self.step = step
    def add_step(self, value): self.step.append(value)
    def insert_step_at(self, index, value): self.step.insert(index, value)
    def replace_step_at(self, index, value): self.step[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.initialValue is not None or
            self.step
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Schedule', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Schedule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Schedule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Schedule'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Schedule', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.initialValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinitialValue>%s</%sinitialValue>%s' % (namespace_, self.gds_format_float(self.initialValue, input_name='initialValue'), namespace_, eol_))
        for step_ in self.step:
            step_.export(outfile, level, namespace_, name_='step', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'initialValue':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'initialValue')
            self.initialValue = fval_
        elif nodeName_ == 'step':
            obj_ = Step.factory()
            obj_.build(child_)
            self.step.append(obj_)
            obj_.original_tagname_ = 'step'
# end class Schedule


class ScheduleReference(Reference):
    """Reference to a schedule of rates or amounts."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(ScheduleReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ScheduleReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ScheduleReference.subclass:
            return ScheduleReference.subclass(*args_, **kwargs_)
        else:
            return ScheduleReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(ScheduleReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ScheduleReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ScheduleReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ScheduleReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ScheduleReference'):
        super(ScheduleReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ScheduleReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ScheduleReference', fromsubclass_=False, pretty_print=True):
        super(ScheduleReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(ScheduleReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ScheduleReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ScheduleReference


class SettlementInformation(GeneratedsSuper):
    """A type that represents the choice of methods for settling a
    potential currency payment resulting from a trade: by means of a
    standard settlement instruction, by netting it out with other
    payments, or with an explicit settlement instruction."""
    member_data_items_ = {
        'standardSettlementStyle': MemberSpec_('standardSettlementStyle', ['StandardSettlementStyleEnum', 'Token', 'xsd:token'], 0),
        'settlementInstruction': MemberSpec_('settlementInstruction', 'SettlementInstruction', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, standardSettlementStyle=None, settlementInstruction=None):
        self.original_tagname_ = None
        self.standardSettlementStyle = standardSettlementStyle
        self.validate_StandardSettlementStyleEnum(self.standardSettlementStyle)
        self.settlementInstruction = settlementInstruction
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SettlementInformation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SettlementInformation.subclass:
            return SettlementInformation.subclass(*args_, **kwargs_)
        else:
            return SettlementInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_standardSettlementStyle(self): return self.standardSettlementStyle
    def set_standardSettlementStyle(self, standardSettlementStyle): self.standardSettlementStyle = standardSettlementStyle
    def get_settlementInstruction(self): return self.settlementInstruction
    def set_settlementInstruction(self, settlementInstruction): self.settlementInstruction = settlementInstruction
    def validate_StandardSettlementStyleEnum(self, value):
        # Validate type StandardSettlementStyleEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Standard', 'Net', 'StandardAndNet']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on StandardSettlementStyleEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on StandardSettlementStyleEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.standardSettlementStyle is not None or
            self.settlementInstruction is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SettlementInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SettlementInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SettlementInformation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SettlementInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SettlementInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.standardSettlementStyle is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstandardSettlementStyle>%s</%sstandardSettlementStyle>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.standardSettlementStyle), input_name='standardSettlementStyle')), namespace_, eol_))
        if self.settlementInstruction is not None:
            self.settlementInstruction.export(outfile, level, namespace_, name_='settlementInstruction', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'standardSettlementStyle':
            standardSettlementStyle_ = child_.text
            standardSettlementStyle_ = re_.sub(String_cleanup_pat_, " ", standardSettlementStyle_).strip()
            standardSettlementStyle_ = self.gds_validate_string(standardSettlementStyle_, node, 'standardSettlementStyle')
            self.standardSettlementStyle = standardSettlementStyle_
            # validate type StandardSettlementStyleEnum
            self.validate_StandardSettlementStyleEnum(self.standardSettlementStyle)
        elif nodeName_ == 'settlementInstruction':
            obj_ = SettlementInstruction.factory()
            obj_.build(child_)
            self.settlementInstruction = obj_
            obj_.original_tagname_ = 'settlementInstruction'
# end class SettlementInformation


class SettlementInstruction(GeneratedsSuper):
    """A type that models a complete instruction for settling a currency
    payment, including the settlement method to be used, the
    correspondent bank, any intermediary banks and the ultimate
    beneficary."""
    member_data_items_ = {
        'settlementMethod': MemberSpec_('settlementMethod', 'SettlementMethod', 0),
        'correspondentInformation': MemberSpec_('correspondentInformation', 'CorrespondentInformation', 0),
        'intermediaryInformation': MemberSpec_('intermediaryInformation', 'IntermediaryInformation', 1),
        'beneficiaryBank': MemberSpec_('beneficiaryBank', 'Beneficiary', 0),
        'beneficiary': MemberSpec_('beneficiary', 'Beneficiary', 0),
        'depositoryPartyReference': MemberSpec_('depositoryPartyReference', 'PartyReference', 0),
        'splitSettlement': MemberSpec_('splitSettlement', 'SplitSettlement', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, settlementMethod=None, correspondentInformation=None, intermediaryInformation=None, beneficiaryBank=None, beneficiary=None, depositoryPartyReference=None, splitSettlement=None):
        self.original_tagname_ = None
        self.settlementMethod = settlementMethod
        self.correspondentInformation = correspondentInformation
        if intermediaryInformation is None:
            self.intermediaryInformation = []
        else:
            self.intermediaryInformation = intermediaryInformation
        self.beneficiaryBank = beneficiaryBank
        self.beneficiary = beneficiary
        self.depositoryPartyReference = depositoryPartyReference
        if splitSettlement is None:
            self.splitSettlement = []
        else:
            self.splitSettlement = splitSettlement
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SettlementInstruction)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SettlementInstruction.subclass:
            return SettlementInstruction.subclass(*args_, **kwargs_)
        else:
            return SettlementInstruction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_settlementMethod(self): return self.settlementMethod
    def set_settlementMethod(self, settlementMethod): self.settlementMethod = settlementMethod
    def get_correspondentInformation(self): return self.correspondentInformation
    def set_correspondentInformation(self, correspondentInformation): self.correspondentInformation = correspondentInformation
    def get_intermediaryInformation(self): return self.intermediaryInformation
    def set_intermediaryInformation(self, intermediaryInformation): self.intermediaryInformation = intermediaryInformation
    def add_intermediaryInformation(self, value): self.intermediaryInformation.append(value)
    def insert_intermediaryInformation_at(self, index, value): self.intermediaryInformation.insert(index, value)
    def replace_intermediaryInformation_at(self, index, value): self.intermediaryInformation[index] = value
    def get_beneficiaryBank(self): return self.beneficiaryBank
    def set_beneficiaryBank(self, beneficiaryBank): self.beneficiaryBank = beneficiaryBank
    def get_beneficiary(self): return self.beneficiary
    def set_beneficiary(self, beneficiary): self.beneficiary = beneficiary
    def get_depositoryPartyReference(self): return self.depositoryPartyReference
    def set_depositoryPartyReference(self, depositoryPartyReference): self.depositoryPartyReference = depositoryPartyReference
    def get_splitSettlement(self): return self.splitSettlement
    def set_splitSettlement(self, splitSettlement): self.splitSettlement = splitSettlement
    def add_splitSettlement(self, value): self.splitSettlement.append(value)
    def insert_splitSettlement_at(self, index, value): self.splitSettlement.insert(index, value)
    def replace_splitSettlement_at(self, index, value): self.splitSettlement[index] = value
    def hasContent_(self):
        if (
            self.settlementMethod is not None or
            self.correspondentInformation is not None or
            self.intermediaryInformation or
            self.beneficiaryBank is not None or
            self.beneficiary is not None or
            self.depositoryPartyReference is not None or
            self.splitSettlement
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SettlementInstruction', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SettlementInstruction')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SettlementInstruction', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SettlementInstruction'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SettlementInstruction', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.settlementMethod is not None:
            self.settlementMethod.export(outfile, level, namespace_, name_='settlementMethod', pretty_print=pretty_print)
        if self.correspondentInformation is not None:
            self.correspondentInformation.export(outfile, level, namespace_, name_='correspondentInformation', pretty_print=pretty_print)
        for intermediaryInformation_ in self.intermediaryInformation:
            intermediaryInformation_.export(outfile, level, namespace_, name_='intermediaryInformation', pretty_print=pretty_print)
        if self.beneficiaryBank is not None:
            self.beneficiaryBank.export(outfile, level, namespace_, name_='beneficiaryBank', pretty_print=pretty_print)
        if self.beneficiary is not None:
            self.beneficiary.export(outfile, level, namespace_, name_='beneficiary', pretty_print=pretty_print)
        if self.depositoryPartyReference is not None:
            self.depositoryPartyReference.export(outfile, level, namespace_, name_='depositoryPartyReference', pretty_print=pretty_print)
        for splitSettlement_ in self.splitSettlement:
            splitSettlement_.export(outfile, level, namespace_, name_='splitSettlement', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'settlementMethod':
            obj_ = SettlementMethod.factory()
            obj_.build(child_)
            self.settlementMethod = obj_
            obj_.original_tagname_ = 'settlementMethod'
        elif nodeName_ == 'correspondentInformation':
            obj_ = CorrespondentInformation.factory()
            obj_.build(child_)
            self.correspondentInformation = obj_
            obj_.original_tagname_ = 'correspondentInformation'
        elif nodeName_ == 'intermediaryInformation':
            obj_ = IntermediaryInformation.factory()
            obj_.build(child_)
            self.intermediaryInformation.append(obj_)
            obj_.original_tagname_ = 'intermediaryInformation'
        elif nodeName_ == 'beneficiaryBank':
            obj_ = Beneficiary.factory()
            obj_.build(child_)
            self.beneficiaryBank = obj_
            obj_.original_tagname_ = 'beneficiaryBank'
        elif nodeName_ == 'beneficiary':
            obj_ = Beneficiary.factory()
            obj_.build(child_)
            self.beneficiary = obj_
            obj_.original_tagname_ = 'beneficiary'
        elif nodeName_ == 'depositoryPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.depositoryPartyReference = obj_
            obj_.original_tagname_ = 'depositoryPartyReference'
        elif nodeName_ == 'splitSettlement':
            obj_ = SplitSettlement.factory()
            obj_.build(child_)
            self.splitSettlement.append(obj_)
            obj_.original_tagname_ = 'splitSettlement'
# end class SettlementInstruction


class SettlementMethod(GeneratedsSuper):
    member_data_items_ = {
        'settlementMethodScheme': MemberSpec_('settlementMethodScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, settlementMethodScheme='http://www.fpml.org/coding-scheme/settlement-method', valueOf_=None):
        self.original_tagname_ = None
        self.settlementMethodScheme = _cast(None, settlementMethodScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SettlementMethod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SettlementMethod.subclass:
            return SettlementMethod.subclass(*args_, **kwargs_)
        else:
            return SettlementMethod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_settlementMethodScheme(self): return self.settlementMethodScheme
    def set_settlementMethodScheme(self, settlementMethodScheme): self.settlementMethodScheme = settlementMethodScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SettlementMethod', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SettlementMethod')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SettlementMethod', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SettlementMethod'):
        if self.settlementMethodScheme != "http://www.fpml.org/coding-scheme/settlement-method" and 'settlementMethodScheme' not in already_processed:
            already_processed.add('settlementMethodScheme')
            outfile.write(' settlementMethodScheme=%s' % (quote_attrib(self.settlementMethodScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SettlementMethod', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('settlementMethodScheme', node)
        if value is not None and 'settlementMethodScheme' not in already_processed:
            already_processed.add('settlementMethodScheme')
            self.settlementMethodScheme = value
            self.validate_NonEmptyURI(self.settlementMethodScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SettlementMethod


class SettlementPriceDefaultElection(GeneratedsSuper):
    """Coding scheme that specifies the settlement price default election."""
    member_data_items_ = {
        'settlementPriceDefaultElectionScheme': MemberSpec_('settlementPriceDefaultElectionScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, settlementPriceDefaultElectionScheme='http://www.fpml.org/coding-scheme/settlement-price-default-election', valueOf_=None):
        self.original_tagname_ = None
        self.settlementPriceDefaultElectionScheme = _cast(None, settlementPriceDefaultElectionScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SettlementPriceDefaultElection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SettlementPriceDefaultElection.subclass:
            return SettlementPriceDefaultElection.subclass(*args_, **kwargs_)
        else:
            return SettlementPriceDefaultElection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_settlementPriceDefaultElectionScheme(self): return self.settlementPriceDefaultElectionScheme
    def set_settlementPriceDefaultElectionScheme(self, settlementPriceDefaultElectionScheme): self.settlementPriceDefaultElectionScheme = settlementPriceDefaultElectionScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SettlementPriceDefaultElection', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SettlementPriceDefaultElection')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SettlementPriceDefaultElection', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SettlementPriceDefaultElection'):
        if self.settlementPriceDefaultElectionScheme != "http://www.fpml.org/coding-scheme/settlement-price-default-election" and 'settlementPriceDefaultElectionScheme' not in already_processed:
            already_processed.add('settlementPriceDefaultElectionScheme')
            outfile.write(' settlementPriceDefaultElectionScheme=%s' % (quote_attrib(self.settlementPriceDefaultElectionScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SettlementPriceDefaultElection', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('settlementPriceDefaultElectionScheme', node)
        if value is not None and 'settlementPriceDefaultElectionScheme' not in already_processed:
            already_processed.add('settlementPriceDefaultElectionScheme')
            self.settlementPriceDefaultElectionScheme = value
            self.validate_NonEmptyURI(self.settlementPriceDefaultElectionScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SettlementPriceDefaultElection


class SettlementPriceSource(GeneratedsSuper):
    """The source from which the settlement price is to be obtained, e.g. a
    Reuters page, Prezzo di Riferimento, etc."""
    member_data_items_ = {
        'settlementPriceSourceScheme': MemberSpec_('settlementPriceSourceScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, settlementPriceSourceScheme='http://www.fpml.org/coding-scheme/settlement-price-source', valueOf_=None):
        self.original_tagname_ = None
        self.settlementPriceSourceScheme = _cast(None, settlementPriceSourceScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SettlementPriceSource)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SettlementPriceSource.subclass:
            return SettlementPriceSource.subclass(*args_, **kwargs_)
        else:
            return SettlementPriceSource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_settlementPriceSourceScheme(self): return self.settlementPriceSourceScheme
    def set_settlementPriceSourceScheme(self, settlementPriceSourceScheme): self.settlementPriceSourceScheme = settlementPriceSourceScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SettlementPriceSource', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SettlementPriceSource')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SettlementPriceSource', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SettlementPriceSource'):
        if self.settlementPriceSourceScheme != "http://www.fpml.org/coding-scheme/settlement-price-source" and 'settlementPriceSourceScheme' not in already_processed:
            already_processed.add('settlementPriceSourceScheme')
            outfile.write(' settlementPriceSourceScheme=%s' % (quote_attrib(self.settlementPriceSourceScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SettlementPriceSource', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('settlementPriceSourceScheme', node)
        if value is not None and 'settlementPriceSourceScheme' not in already_processed:
            already_processed.add('settlementPriceSourceScheme')
            self.settlementPriceSourceScheme = value
            self.validate_NonEmptyURI(self.settlementPriceSourceScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SettlementPriceSource


class SettlementRateOption(GeneratedsSuper):
    """A type defining the settlement rate options through a scheme
    reflecting the terms of the Annex A to the 1998 FX and Currency
    Option Definitions."""
    member_data_items_ = {
        'settlementRateOptionScheme': MemberSpec_('settlementRateOptionScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, settlementRateOptionScheme='http://www.fpml.org/coding-scheme/settlement-rate-option', valueOf_=None):
        self.original_tagname_ = None
        self.settlementRateOptionScheme = _cast(None, settlementRateOptionScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SettlementRateOption)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SettlementRateOption.subclass:
            return SettlementRateOption.subclass(*args_, **kwargs_)
        else:
            return SettlementRateOption(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_settlementRateOptionScheme(self): return self.settlementRateOptionScheme
    def set_settlementRateOptionScheme(self, settlementRateOptionScheme): self.settlementRateOptionScheme = settlementRateOptionScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SettlementRateOption', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SettlementRateOption')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SettlementRateOption', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SettlementRateOption'):
        if self.settlementRateOptionScheme != "http://www.fpml.org/coding-scheme/settlement-rate-option" and 'settlementRateOptionScheme' not in already_processed:
            already_processed.add('settlementRateOptionScheme')
            outfile.write(' settlementRateOptionScheme=%s' % (quote_attrib(self.settlementRateOptionScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SettlementRateOption', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('settlementRateOptionScheme', node)
        if value is not None and 'settlementRateOptionScheme' not in already_processed:
            already_processed.add('settlementRateOptionScheme')
            self.settlementRateOptionScheme = value
            self.validate_NonEmptyURI(self.settlementRateOptionScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SettlementRateOption


class SettlementRateSource(GeneratedsSuper):
    """A type describing the method for obtaining a settlement rate."""
    member_data_items_ = {
        'informationSource': MemberSpec_('informationSource', 'InformationSource', 0),
        'cashSettlementReferenceBanks': MemberSpec_('cashSettlementReferenceBanks', 'CashSettlementReferenceBanks', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, informationSource=None, cashSettlementReferenceBanks=None):
        self.original_tagname_ = None
        self.informationSource = informationSource
        self.cashSettlementReferenceBanks = cashSettlementReferenceBanks
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SettlementRateSource)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SettlementRateSource.subclass:
            return SettlementRateSource.subclass(*args_, **kwargs_)
        else:
            return SettlementRateSource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_informationSource(self): return self.informationSource
    def set_informationSource(self, informationSource): self.informationSource = informationSource
    def get_cashSettlementReferenceBanks(self): return self.cashSettlementReferenceBanks
    def set_cashSettlementReferenceBanks(self, cashSettlementReferenceBanks): self.cashSettlementReferenceBanks = cashSettlementReferenceBanks
    def hasContent_(self):
        if (
            self.informationSource is not None or
            self.cashSettlementReferenceBanks is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SettlementRateSource', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SettlementRateSource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SettlementRateSource', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SettlementRateSource'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SettlementRateSource', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.informationSource is not None:
            self.informationSource.export(outfile, level, namespace_, name_='informationSource', pretty_print=pretty_print)
        if self.cashSettlementReferenceBanks is not None:
            self.cashSettlementReferenceBanks.export(outfile, level, namespace_, name_='cashSettlementReferenceBanks', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'informationSource':
            class_obj_ = self.get_class_obj_(child_, InformationSource)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.informationSource = obj_
            obj_.original_tagname_ = 'informationSource'
        elif nodeName_ == 'cashSettlementReferenceBanks':
            obj_ = CashSettlementReferenceBanks.factory()
            obj_.build(child_)
            self.cashSettlementReferenceBanks = obj_
            obj_.original_tagname_ = 'cashSettlementReferenceBanks'
# end class SettlementRateSource


class SharedAmericanExercise(Exercise):
    """TBAChoice between latest exercise time expressed as literal time, or
    using a determination method."""
    member_data_items_ = {
        'commencementDate': MemberSpec_('commencementDate', 'AdjustableOrRelativeDate', 0),
        'expirationDate': MemberSpec_('expirationDate', 'AdjustableOrRelativeDate', 0),
        'latestExerciseTime': MemberSpec_('latestExerciseTime', 'BusinessCenterTime', 0),
        'latestExerciseTimeDetermination': MemberSpec_('latestExerciseTimeDetermination', 'DeterminationMethod', 0),
    }
    subclass = None
    superclass = Exercise
    def __init__(self, id=None, commencementDate=None, expirationDate=None, latestExerciseTime=None, latestExerciseTimeDetermination=None):
        self.original_tagname_ = None
        super(SharedAmericanExercise, self).__init__(id, )
        self.commencementDate = commencementDate
        self.expirationDate = expirationDate
        self.latestExerciseTime = latestExerciseTime
        self.latestExerciseTimeDetermination = latestExerciseTimeDetermination
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SharedAmericanExercise)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SharedAmericanExercise.subclass:
            return SharedAmericanExercise.subclass(*args_, **kwargs_)
        else:
            return SharedAmericanExercise(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commencementDate(self): return self.commencementDate
    def set_commencementDate(self, commencementDate): self.commencementDate = commencementDate
    def get_expirationDate(self): return self.expirationDate
    def set_expirationDate(self, expirationDate): self.expirationDate = expirationDate
    def get_latestExerciseTime(self): return self.latestExerciseTime
    def set_latestExerciseTime(self, latestExerciseTime): self.latestExerciseTime = latestExerciseTime
    def get_latestExerciseTimeDetermination(self): return self.latestExerciseTimeDetermination
    def set_latestExerciseTimeDetermination(self, latestExerciseTimeDetermination): self.latestExerciseTimeDetermination = latestExerciseTimeDetermination
    def hasContent_(self):
        if (
            self.commencementDate is not None or
            self.expirationDate is not None or
            self.latestExerciseTime is not None or
            self.latestExerciseTimeDetermination is not None or
            super(SharedAmericanExercise, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SharedAmericanExercise', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SharedAmericanExercise')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SharedAmericanExercise', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SharedAmericanExercise'):
        super(SharedAmericanExercise, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SharedAmericanExercise')
    def exportChildren(self, outfile, level, namespace_='', name_='SharedAmericanExercise', fromsubclass_=False, pretty_print=True):
        super(SharedAmericanExercise, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.commencementDate is not None:
            self.commencementDate.export(outfile, level, namespace_, name_='commencementDate', pretty_print=pretty_print)
        if self.expirationDate is not None:
            self.expirationDate.export(outfile, level, namespace_, name_='expirationDate', pretty_print=pretty_print)
        if self.latestExerciseTime is not None:
            self.latestExerciseTime.export(outfile, level, namespace_, name_='latestExerciseTime', pretty_print=pretty_print)
        if self.latestExerciseTimeDetermination is not None:
            self.latestExerciseTimeDetermination.export(outfile, level, namespace_, name_='latestExerciseTimeDetermination', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SharedAmericanExercise, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'commencementDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.commencementDate = obj_
            obj_.original_tagname_ = 'commencementDate'
        elif nodeName_ == 'expirationDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.expirationDate = obj_
            obj_.original_tagname_ = 'expirationDate'
        elif nodeName_ == 'latestExerciseTime':
            obj_ = BusinessCenterTime.factory()
            obj_.build(child_)
            self.latestExerciseTime = obj_
            obj_.original_tagname_ = 'latestExerciseTime'
        elif nodeName_ == 'latestExerciseTimeDetermination':
            obj_ = DeterminationMethod.factory()
            obj_.build(child_)
            self.latestExerciseTimeDetermination = obj_
            obj_.original_tagname_ = 'latestExerciseTimeDetermination'
        super(SharedAmericanExercise, self).buildChildren(child_, node, nodeName_, True)
# end class SharedAmericanExercise


class SimplePayment(PaymentBase):
    """A complex type to specified payments in a simpler fashion than the
    Payment type. This construct should be used from the version 4.3
    onwards."""
    member_data_items_ = {
        'payerPartyReference': MemberSpec_('payerPartyReference', 'PartyReference', 0),
        'payerAccountReference': MemberSpec_('payerAccountReference', 'AccountReference', 0),
        'receiverPartyReference': MemberSpec_('receiverPartyReference', 'PartyReference', 0),
        'receiverAccountReference': MemberSpec_('receiverAccountReference', 'AccountReference', 0),
        'paymentAmount': MemberSpec_('paymentAmount', 'NonNegativeMoney', 0),
        'paymentDate': MemberSpec_('paymentDate', 'AdjustableOrRelativeDate', 0),
    }
    subclass = None
    superclass = PaymentBase
    def __init__(self, id=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, paymentAmount=None, paymentDate=None, extensiontype_=None):
        self.original_tagname_ = None
        super(SimplePayment, self).__init__(id, extensiontype_, )
        self.payerPartyReference = payerPartyReference
        self.payerAccountReference = payerAccountReference
        self.receiverPartyReference = receiverPartyReference
        self.receiverAccountReference = receiverAccountReference
        self.paymentAmount = paymentAmount
        self.paymentDate = paymentDate
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SimplePayment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SimplePayment.subclass:
            return SimplePayment.subclass(*args_, **kwargs_)
        else:
            return SimplePayment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_payerPartyReference(self): return self.payerPartyReference
    def set_payerPartyReference(self, payerPartyReference): self.payerPartyReference = payerPartyReference
    def get_payerAccountReference(self): return self.payerAccountReference
    def set_payerAccountReference(self, payerAccountReference): self.payerAccountReference = payerAccountReference
    def get_receiverPartyReference(self): return self.receiverPartyReference
    def set_receiverPartyReference(self, receiverPartyReference): self.receiverPartyReference = receiverPartyReference
    def get_receiverAccountReference(self): return self.receiverAccountReference
    def set_receiverAccountReference(self, receiverAccountReference): self.receiverAccountReference = receiverAccountReference
    def get_paymentAmount(self): return self.paymentAmount
    def set_paymentAmount(self, paymentAmount): self.paymentAmount = paymentAmount
    def get_paymentDate(self): return self.paymentDate
    def set_paymentDate(self, paymentDate): self.paymentDate = paymentDate
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.payerPartyReference is not None or
            self.payerAccountReference is not None or
            self.receiverPartyReference is not None or
            self.receiverAccountReference is not None or
            self.paymentAmount is not None or
            self.paymentDate is not None or
            super(SimplePayment, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SimplePayment', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SimplePayment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SimplePayment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SimplePayment'):
        super(SimplePayment, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SimplePayment')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='SimplePayment', fromsubclass_=False, pretty_print=True):
        super(SimplePayment, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.payerPartyReference is not None:
            self.payerPartyReference.export(outfile, level, namespace_, name_='payerPartyReference', pretty_print=pretty_print)
        if self.payerAccountReference is not None:
            self.payerAccountReference.export(outfile, level, namespace_, name_='payerAccountReference', pretty_print=pretty_print)
        if self.receiverPartyReference is not None:
            self.receiverPartyReference.export(outfile, level, namespace_, name_='receiverPartyReference', pretty_print=pretty_print)
        if self.receiverAccountReference is not None:
            self.receiverAccountReference.export(outfile, level, namespace_, name_='receiverAccountReference', pretty_print=pretty_print)
        if self.paymentAmount is not None:
            self.paymentAmount.export(outfile, level, namespace_, name_='paymentAmount', pretty_print=pretty_print)
        if self.paymentDate is not None:
            self.paymentDate.export(outfile, level, namespace_, name_='paymentDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(SimplePayment, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'payerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.payerPartyReference = obj_
            obj_.original_tagname_ = 'payerPartyReference'
        elif nodeName_ == 'payerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.payerAccountReference = obj_
            obj_.original_tagname_ = 'payerAccountReference'
        elif nodeName_ == 'receiverPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.receiverPartyReference = obj_
            obj_.original_tagname_ = 'receiverPartyReference'
        elif nodeName_ == 'receiverAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.receiverAccountReference = obj_
            obj_.original_tagname_ = 'receiverAccountReference'
        elif nodeName_ == 'paymentAmount':
            class_obj_ = self.get_class_obj_(child_, NonNegativeMoney)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.paymentAmount = obj_
            obj_.original_tagname_ = 'paymentAmount'
        elif nodeName_ == 'paymentDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.paymentDate = obj_
            obj_.original_tagname_ = 'paymentDate'
        super(SimplePayment, self).buildChildren(child_, node, nodeName_, True)
# end class SimplePayment


class SplitSettlement(GeneratedsSuper):
    """A type that supports the division of a gross settlement amount into
    a number of split settlements, each requiring its own settlement
    instruction."""
    member_data_items_ = {
        'splitSettlementAmount': MemberSpec_('splitSettlementAmount', 'Money', 0),
        'beneficiaryBank': MemberSpec_('beneficiaryBank', 'Routing', 0),
        'beneficiary': MemberSpec_('beneficiary', 'Routing', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, splitSettlementAmount=None, beneficiaryBank=None, beneficiary=None):
        self.original_tagname_ = None
        self.splitSettlementAmount = splitSettlementAmount
        self.beneficiaryBank = beneficiaryBank
        self.beneficiary = beneficiary
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SplitSettlement)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SplitSettlement.subclass:
            return SplitSettlement.subclass(*args_, **kwargs_)
        else:
            return SplitSettlement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_splitSettlementAmount(self): return self.splitSettlementAmount
    def set_splitSettlementAmount(self, splitSettlementAmount): self.splitSettlementAmount = splitSettlementAmount
    def get_beneficiaryBank(self): return self.beneficiaryBank
    def set_beneficiaryBank(self, beneficiaryBank): self.beneficiaryBank = beneficiaryBank
    def get_beneficiary(self): return self.beneficiary
    def set_beneficiary(self, beneficiary): self.beneficiary = beneficiary
    def hasContent_(self):
        if (
            self.splitSettlementAmount is not None or
            self.beneficiaryBank is not None or
            self.beneficiary is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SplitSettlement', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SplitSettlement')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SplitSettlement', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SplitSettlement'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SplitSettlement', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.splitSettlementAmount is not None:
            self.splitSettlementAmount.export(outfile, level, namespace_, name_='splitSettlementAmount', pretty_print=pretty_print)
        if self.beneficiaryBank is not None:
            self.beneficiaryBank.export(outfile, level, namespace_, name_='beneficiaryBank', pretty_print=pretty_print)
        if self.beneficiary is not None:
            self.beneficiary.export(outfile, level, namespace_, name_='beneficiary', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'splitSettlementAmount':
            class_obj_ = self.get_class_obj_(child_, Money)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.splitSettlementAmount = obj_
            obj_.original_tagname_ = 'splitSettlementAmount'
        elif nodeName_ == 'beneficiaryBank':
            obj_ = Routing.factory()
            obj_.build(child_)
            self.beneficiaryBank = obj_
            obj_.original_tagname_ = 'beneficiaryBank'
        elif nodeName_ == 'beneficiary':
            obj_ = Routing.factory()
            obj_.build(child_)
            self.beneficiary = obj_
            obj_.original_tagname_ = 'beneficiary'
# end class SplitSettlement


class SpreadSchedule(Schedule):
    """Adds an optional spread type element to the Schedule to identify a
    long or short spread value."""
    member_data_items_ = {
        'type_': MemberSpec_('type_', 'SpreadScheduleType', 0),
    }
    subclass = None
    superclass = Schedule
    def __init__(self, id=None, initialValue=None, step=None, type_=None):
        self.original_tagname_ = None
        super(SpreadSchedule, self).__init__(id, initialValue, step, )
        self.type_ = type_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpreadSchedule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpreadSchedule.subclass:
            return SpreadSchedule.subclass(*args_, **kwargs_)
        else:
            return SpreadSchedule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (
            self.type_ is not None or
            super(SpreadSchedule, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SpreadSchedule', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SpreadSchedule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SpreadSchedule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SpreadSchedule'):
        super(SpreadSchedule, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SpreadSchedule')
    def exportChildren(self, outfile, level, namespace_='', name_='SpreadSchedule', fromsubclass_=False, pretty_print=True):
        super(SpreadSchedule, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            self.type_.export(outfile, level, namespace_, name_='type', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SpreadSchedule, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            obj_ = SpreadScheduleType.factory()
            obj_.build(child_)
            self.type_ = obj_
            obj_.original_tagname_ = 'type'
        super(SpreadSchedule, self).buildChildren(child_, node, nodeName_, True)
# end class SpreadSchedule


class SpreadScheduleReference(Reference):
    """Provides a reference to a spread schedule."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(SpreadScheduleReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpreadScheduleReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpreadScheduleReference.subclass:
            return SpreadScheduleReference.subclass(*args_, **kwargs_)
        else:
            return SpreadScheduleReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(SpreadScheduleReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SpreadScheduleReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SpreadScheduleReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SpreadScheduleReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SpreadScheduleReference'):
        super(SpreadScheduleReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SpreadScheduleReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SpreadScheduleReference', fromsubclass_=False, pretty_print=True):
        super(SpreadScheduleReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(SpreadScheduleReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SpreadScheduleReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SpreadScheduleReference


class SpreadScheduleType(GeneratedsSuper):
    """Defines a Spread Type Scheme to identify a long or short spread
    value."""
    member_data_items_ = {
        'spreadScheduleTypeScheme': MemberSpec_('spreadScheduleTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, spreadScheduleTypeScheme='http://www.fpml.org/coding-scheme/spread-schedule-type', valueOf_=None):
        self.original_tagname_ = None
        self.spreadScheduleTypeScheme = _cast(None, spreadScheduleTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpreadScheduleType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpreadScheduleType.subclass:
            return SpreadScheduleType.subclass(*args_, **kwargs_)
        else:
            return SpreadScheduleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_spreadScheduleTypeScheme(self): return self.spreadScheduleTypeScheme
    def set_spreadScheduleTypeScheme(self, spreadScheduleTypeScheme): self.spreadScheduleTypeScheme = spreadScheduleTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SpreadScheduleType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SpreadScheduleType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SpreadScheduleType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SpreadScheduleType'):
        if self.spreadScheduleTypeScheme != "http://www.fpml.org/coding-scheme/spread-schedule-type" and 'spreadScheduleTypeScheme' not in already_processed:
            already_processed.add('spreadScheduleTypeScheme')
            outfile.write(' spreadScheduleTypeScheme=%s' % (quote_attrib(self.spreadScheduleTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SpreadScheduleType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('spreadScheduleTypeScheme', node)
        if value is not None and 'spreadScheduleTypeScheme' not in already_processed:
            already_processed.add('spreadScheduleTypeScheme')
            self.spreadScheduleTypeScheme = value
            self.validate_NonEmptyURI(self.spreadScheduleTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SpreadScheduleType


class StepBase(GeneratedsSuper):
    """A type defining a step date and step value pair. This step
    definitions are used to define varying rate or amount schedules,
    e.g. a notional amortization or a step-up coupon schedule."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'stepDate': MemberSpec_('stepDate', 'xsd:date', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, stepDate=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if isinstance(stepDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(stepDate, '%Y-%m-%d').date()
        else:
            initvalue_ = stepDate
        self.stepDate = initvalue_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StepBase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StepBase.subclass:
            return StepBase.subclass(*args_, **kwargs_)
        else:
            return StepBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_stepDate(self): return self.stepDate
    def set_stepDate(self, stepDate): self.stepDate = stepDate
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.stepDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StepBase', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StepBase')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StepBase', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StepBase'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='StepBase', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.stepDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstepDate>%s</%sstepDate>%s' % (namespace_, self.gds_format_date(self.stepDate, input_name='stepDate'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'stepDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.stepDate = dval_
# end class StepBase


class StreetAddress(GeneratedsSuper):
    """A type that describes the set of street and building number
    information that identifies a postal address within a city."""
    member_data_items_ = {
        'streetLine': MemberSpec_('streetLine', ['String', 'xsd:string'], 1),
    }
    subclass = None
    superclass = None
    def __init__(self, streetLine=None):
        self.original_tagname_ = None
        if streetLine is None:
            self.streetLine = []
        else:
            self.streetLine = streetLine
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StreetAddress)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StreetAddress.subclass:
            return StreetAddress.subclass(*args_, **kwargs_)
        else:
            return StreetAddress(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_streetLine(self): return self.streetLine
    def set_streetLine(self, streetLine): self.streetLine = streetLine
    def add_streetLine(self, value): self.streetLine.append(value)
    def insert_streetLine_at(self, index, value): self.streetLine.insert(index, value)
    def replace_streetLine_at(self, index, value): self.streetLine[index] = value
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.streetLine
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StreetAddress', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StreetAddress')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StreetAddress', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StreetAddress'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StreetAddress', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for streetLine_ in self.streetLine:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstreetLine>%s</%sstreetLine>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(streetLine_), input_name='streetLine')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'streetLine':
            streetLine_ = child_.text
            streetLine_ = self.gds_validate_string(streetLine_, node, 'streetLine')
            self.streetLine.append(streetLine_)
            # validate type String
            self.validate_String(self.streetLine[-1])
# end class StreetAddress


class Strike(GeneratedsSuper):
    """A type describing a single cap or floor rate."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'strikeRate': MemberSpec_('strikeRate', 'xsd:decimal', 0),
        'buyer': MemberSpec_('buyer', 'IdentifiedPayerReceiver', 0),
        'seller': MemberSpec_('seller', 'IdentifiedPayerReceiver', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, strikeRate=None, buyer=None, seller=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.strikeRate = strikeRate
        self.buyer = buyer
        self.seller = seller
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Strike)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Strike.subclass:
            return Strike.subclass(*args_, **kwargs_)
        else:
            return Strike(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_strikeRate(self): return self.strikeRate
    def set_strikeRate(self, strikeRate): self.strikeRate = strikeRate
    def get_buyer(self): return self.buyer
    def set_buyer(self, buyer): self.buyer = buyer
    def get_seller(self): return self.seller
    def set_seller(self, seller): self.seller = seller
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.strikeRate is not None or
            self.buyer is not None or
            self.seller is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Strike', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Strike')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Strike', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Strike'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Strike', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.strikeRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstrikeRate>%s</%sstrikeRate>%s' % (namespace_, self.gds_format_float(self.strikeRate, input_name='strikeRate'), namespace_, eol_))
        if self.buyer is not None:
            self.buyer.export(outfile, level, namespace_, name_='buyer', pretty_print=pretty_print)
        if self.seller is not None:
            self.seller.export(outfile, level, namespace_, name_='seller', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'strikeRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'strikeRate')
            self.strikeRate = fval_
        elif nodeName_ == 'buyer':
            obj_ = IdentifiedPayerReceiver.factory()
            obj_.build(child_)
            self.buyer = obj_
            obj_.original_tagname_ = 'buyer'
        elif nodeName_ == 'seller':
            obj_ = IdentifiedPayerReceiver.factory()
            obj_.build(child_)
            self.seller = obj_
            obj_.original_tagname_ = 'seller'
# end class Strike


class StrikeSchedule(Schedule):
    """A type describing a schedule of cap or floor rates."""
    member_data_items_ = {
        'buyer': MemberSpec_('buyer', 'IdentifiedPayerReceiver', 0),
        'seller': MemberSpec_('seller', 'IdentifiedPayerReceiver', 0),
    }
    subclass = None
    superclass = Schedule
    def __init__(self, id=None, initialValue=None, step=None, buyer=None, seller=None):
        self.original_tagname_ = None
        super(StrikeSchedule, self).__init__(id, initialValue, step, )
        self.buyer = buyer
        self.seller = seller
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrikeSchedule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrikeSchedule.subclass:
            return StrikeSchedule.subclass(*args_, **kwargs_)
        else:
            return StrikeSchedule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_buyer(self): return self.buyer
    def set_buyer(self, buyer): self.buyer = buyer
    def get_seller(self): return self.seller
    def set_seller(self, seller): self.seller = seller
    def hasContent_(self):
        if (
            self.buyer is not None or
            self.seller is not None or
            super(StrikeSchedule, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StrikeSchedule', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StrikeSchedule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StrikeSchedule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StrikeSchedule'):
        super(StrikeSchedule, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StrikeSchedule')
    def exportChildren(self, outfile, level, namespace_='', name_='StrikeSchedule', fromsubclass_=False, pretty_print=True):
        super(StrikeSchedule, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.buyer is not None:
            self.buyer.export(outfile, level, namespace_, name_='buyer', pretty_print=pretty_print)
        if self.seller is not None:
            self.seller.export(outfile, level, namespace_, name_='seller', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(StrikeSchedule, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'buyer':
            obj_ = IdentifiedPayerReceiver.factory()
            obj_.build(child_)
            self.buyer = obj_
            obj_.original_tagname_ = 'buyer'
        elif nodeName_ == 'seller':
            obj_ = IdentifiedPayerReceiver.factory()
            obj_.build(child_)
            self.seller = obj_
            obj_.original_tagname_ = 'seller'
        super(StrikeSchedule, self).buildChildren(child_, node, nodeName_, True)
# end class StrikeSchedule


class StubValue(GeneratedsSuper):
    """A type defining how a stub calculation period amount is calculated.
    A single floating rate tenor different to that used for the
    regular part of the calculation periods schedule may be
    specified, or two floating rate tenors many be specified. If two
    floating rate tenors are specified then Linear Interpolation (in
    accordance with the 2000 ISDA Definitions, Section 8.3
    Interpolation) is assumed to apply. Alternatively, an actual
    known stub rate or stub amount may be specified."""
    member_data_items_ = {
        'floatingRate': MemberSpec_('floatingRate', 'StubFloatingRate', 1),
        'stubRate': MemberSpec_('stubRate', 'xsd:decimal', 0),
        'stubAmount': MemberSpec_('stubAmount', 'Money', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, floatingRate=None, stubRate=None, stubAmount=None, extensiontype_=None):
        self.original_tagname_ = None
        if floatingRate is None:
            self.floatingRate = []
        else:
            self.floatingRate = floatingRate
        self.stubRate = stubRate
        self.stubAmount = stubAmount
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StubValue)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StubValue.subclass:
            return StubValue.subclass(*args_, **kwargs_)
        else:
            return StubValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_floatingRate(self): return self.floatingRate
    def set_floatingRate(self, floatingRate): self.floatingRate = floatingRate
    def add_floatingRate(self, value): self.floatingRate.append(value)
    def insert_floatingRate_at(self, index, value): self.floatingRate.insert(index, value)
    def replace_floatingRate_at(self, index, value): self.floatingRate[index] = value
    def get_stubRate(self): return self.stubRate
    def set_stubRate(self, stubRate): self.stubRate = stubRate
    def get_stubAmount(self): return self.stubAmount
    def set_stubAmount(self, stubAmount): self.stubAmount = stubAmount
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.floatingRate or
            self.stubRate is not None or
            self.stubAmount is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StubValue', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StubValue')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StubValue', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StubValue'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StubValue', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for floatingRate_ in self.floatingRate:
            floatingRate_.export(outfile, level, namespace_, name_='floatingRate', pretty_print=pretty_print)
        if self.stubRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstubRate>%s</%sstubRate>%s' % (namespace_, self.gds_format_float(self.stubRate, input_name='stubRate'), namespace_, eol_))
        if self.stubAmount is not None:
            self.stubAmount.export(outfile, level, namespace_, name_='stubAmount', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'floatingRate':
            obj_ = StubFloatingRate.factory()
            obj_.build(child_)
            self.floatingRate.append(obj_)
            obj_.original_tagname_ = 'floatingRate'
        elif nodeName_ == 'stubRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'stubRate')
            self.stubRate = fval_
        elif nodeName_ == 'stubAmount':
            class_obj_ = self.get_class_obj_(child_, Money)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.stubAmount = obj_
            obj_.original_tagname_ = 'stubAmount'
# end class StubValue


class StubFloatingRate(Rate):
    """A type defining a floating rate."""
    member_data_items_ = {
        'floatingRateIndex': MemberSpec_('floatingRateIndex', 'FloatingRateIndex', 0),
        'indexTenor': MemberSpec_('indexTenor', 'Period', 0),
        'floatingRateMultiplierSchedule': MemberSpec_('floatingRateMultiplierSchedule', 'Schedule', 0),
        'spreadSchedule': MemberSpec_('spreadSchedule', 'SpreadSchedule', 1),
        'rateTreatment': MemberSpec_('rateTreatment', ['RateTreatmentEnum', 'Token', 'xsd:token'], 0),
        'capRateSchedule': MemberSpec_('capRateSchedule', 'StrikeSchedule', 1),
        'floorRateSchedule': MemberSpec_('floorRateSchedule', 'StrikeSchedule', 1),
        'capFloorStraddle': MemberSpec_('capFloorStraddle', 'xsd:boolean', 0),
    }
    subclass = None
    superclass = Rate
    def __init__(self, id=None, floatingRateIndex=None, indexTenor=None, floatingRateMultiplierSchedule=None, spreadSchedule=None, rateTreatment=None, capRateSchedule=None, floorRateSchedule=None, capFloorStraddle=None):
        self.original_tagname_ = None
        super(StubFloatingRate, self).__init__(id, )
        self.floatingRateIndex = floatingRateIndex
        self.indexTenor = indexTenor
        self.floatingRateMultiplierSchedule = floatingRateMultiplierSchedule
        if spreadSchedule is None:
            self.spreadSchedule = []
        else:
            self.spreadSchedule = spreadSchedule
        self.rateTreatment = rateTreatment
        self.validate_RateTreatmentEnum(self.rateTreatment)
        if capRateSchedule is None:
            self.capRateSchedule = []
        else:
            self.capRateSchedule = capRateSchedule
        if floorRateSchedule is None:
            self.floorRateSchedule = []
        else:
            self.floorRateSchedule = floorRateSchedule
        self.capFloorStraddle = capFloorStraddle
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StubFloatingRate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StubFloatingRate.subclass:
            return StubFloatingRate.subclass(*args_, **kwargs_)
        else:
            return StubFloatingRate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_floatingRateIndex(self): return self.floatingRateIndex
    def set_floatingRateIndex(self, floatingRateIndex): self.floatingRateIndex = floatingRateIndex
    def get_indexTenor(self): return self.indexTenor
    def set_indexTenor(self, indexTenor): self.indexTenor = indexTenor
    def get_floatingRateMultiplierSchedule(self): return self.floatingRateMultiplierSchedule
    def set_floatingRateMultiplierSchedule(self, floatingRateMultiplierSchedule): self.floatingRateMultiplierSchedule = floatingRateMultiplierSchedule
    def get_spreadSchedule(self): return self.spreadSchedule
    def set_spreadSchedule(self, spreadSchedule): self.spreadSchedule = spreadSchedule
    def add_spreadSchedule(self, value): self.spreadSchedule.append(value)
    def insert_spreadSchedule_at(self, index, value): self.spreadSchedule.insert(index, value)
    def replace_spreadSchedule_at(self, index, value): self.spreadSchedule[index] = value
    def get_rateTreatment(self): return self.rateTreatment
    def set_rateTreatment(self, rateTreatment): self.rateTreatment = rateTreatment
    def get_capRateSchedule(self): return self.capRateSchedule
    def set_capRateSchedule(self, capRateSchedule): self.capRateSchedule = capRateSchedule
    def add_capRateSchedule(self, value): self.capRateSchedule.append(value)
    def insert_capRateSchedule_at(self, index, value): self.capRateSchedule.insert(index, value)
    def replace_capRateSchedule_at(self, index, value): self.capRateSchedule[index] = value
    def get_floorRateSchedule(self): return self.floorRateSchedule
    def set_floorRateSchedule(self, floorRateSchedule): self.floorRateSchedule = floorRateSchedule
    def add_floorRateSchedule(self, value): self.floorRateSchedule.append(value)
    def insert_floorRateSchedule_at(self, index, value): self.floorRateSchedule.insert(index, value)
    def replace_floorRateSchedule_at(self, index, value): self.floorRateSchedule[index] = value
    def get_capFloorStraddle(self): return self.capFloorStraddle
    def set_capFloorStraddle(self, capFloorStraddle): self.capFloorStraddle = capFloorStraddle
    def validate_RateTreatmentEnum(self, value):
        # Validate type RateTreatmentEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['BondEquivalentYield', 'MoneyMarketYield']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RateTreatmentEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on RateTreatmentEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.floatingRateIndex is not None or
            self.indexTenor is not None or
            self.floatingRateMultiplierSchedule is not None or
            self.spreadSchedule or
            self.rateTreatment is not None or
            self.capRateSchedule or
            self.floorRateSchedule or
            self.capFloorStraddle is not None or
            super(StubFloatingRate, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StubFloatingRate', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StubFloatingRate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StubFloatingRate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StubFloatingRate'):
        super(StubFloatingRate, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StubFloatingRate')
    def exportChildren(self, outfile, level, namespace_='', name_='StubFloatingRate', fromsubclass_=False, pretty_print=True):
        super(StubFloatingRate, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.floatingRateIndex is not None:
            self.floatingRateIndex.export(outfile, level, namespace_, name_='floatingRateIndex', pretty_print=pretty_print)
        if self.indexTenor is not None:
            self.indexTenor.export(outfile, level, namespace_, name_='indexTenor', pretty_print=pretty_print)
        if self.floatingRateMultiplierSchedule is not None:
            self.floatingRateMultiplierSchedule.export(outfile, level, namespace_, name_='floatingRateMultiplierSchedule', pretty_print=pretty_print)
        for spreadSchedule_ in self.spreadSchedule:
            spreadSchedule_.export(outfile, level, namespace_, name_='spreadSchedule', pretty_print=pretty_print)
        if self.rateTreatment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srateTreatment>%s</%srateTreatment>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.rateTreatment), input_name='rateTreatment')), namespace_, eol_))
        for capRateSchedule_ in self.capRateSchedule:
            capRateSchedule_.export(outfile, level, namespace_, name_='capRateSchedule', pretty_print=pretty_print)
        for floorRateSchedule_ in self.floorRateSchedule:
            floorRateSchedule_.export(outfile, level, namespace_, name_='floorRateSchedule', pretty_print=pretty_print)
        if self.capFloorStraddle is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scapFloorStraddle>%s</%scapFloorStraddle>%s' % (namespace_, self.gds_format_boolean(self.capFloorStraddle, input_name='capFloorStraddle'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(StubFloatingRate, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'floatingRateIndex':
            obj_ = FloatingRateIndex.factory()
            obj_.build(child_)
            self.floatingRateIndex = obj_
            obj_.original_tagname_ = 'floatingRateIndex'
        elif nodeName_ == 'indexTenor':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.indexTenor = obj_
            obj_.original_tagname_ = 'indexTenor'
        elif nodeName_ == 'floatingRateMultiplierSchedule':
            class_obj_ = self.get_class_obj_(child_, Schedule)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.floatingRateMultiplierSchedule = obj_
            obj_.original_tagname_ = 'floatingRateMultiplierSchedule'
        elif nodeName_ == 'spreadSchedule':
            obj_ = SpreadSchedule.factory()
            obj_.build(child_)
            self.spreadSchedule.append(obj_)
            obj_.original_tagname_ = 'spreadSchedule'
        elif nodeName_ == 'rateTreatment':
            rateTreatment_ = child_.text
            rateTreatment_ = re_.sub(String_cleanup_pat_, " ", rateTreatment_).strip()
            rateTreatment_ = self.gds_validate_string(rateTreatment_, node, 'rateTreatment')
            self.rateTreatment = rateTreatment_
            # validate type RateTreatmentEnum
            self.validate_RateTreatmentEnum(self.rateTreatment)
        elif nodeName_ == 'capRateSchedule':
            obj_ = StrikeSchedule.factory()
            obj_.build(child_)
            self.capRateSchedule.append(obj_)
            obj_.original_tagname_ = 'capRateSchedule'
        elif nodeName_ == 'floorRateSchedule':
            obj_ = StrikeSchedule.factory()
            obj_.build(child_)
            self.floorRateSchedule.append(obj_)
            obj_.original_tagname_ = 'floorRateSchedule'
        elif nodeName_ == 'capFloorStraddle':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'capFloorStraddle')
            self.capFloorStraddle = ival_
        super(StubFloatingRate, self).buildChildren(child_, node, nodeName_, True)
# end class StubFloatingRate


class SupervisoryBody(GeneratedsSuper):
    """An identifier of an organization that supervises or regulates
    trading activity, e.g. CFTC, SEC, FSA, ODRF, etc."""
    member_data_items_ = {
        'supervisoryBodyScheme': MemberSpec_('supervisoryBodyScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, supervisoryBodyScheme='http://www.fpml.org/coding-scheme/supervisory-body', valueOf_=None):
        self.original_tagname_ = None
        self.supervisoryBodyScheme = _cast(None, supervisoryBodyScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SupervisoryBody)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SupervisoryBody.subclass:
            return SupervisoryBody.subclass(*args_, **kwargs_)
        else:
            return SupervisoryBody(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_supervisoryBodyScheme(self): return self.supervisoryBodyScheme
    def set_supervisoryBodyScheme(self, supervisoryBodyScheme): self.supervisoryBodyScheme = supervisoryBodyScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SupervisoryBody', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SupervisoryBody')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SupervisoryBody', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SupervisoryBody'):
        if self.supervisoryBodyScheme != "http://www.fpml.org/coding-scheme/supervisory-body" and 'supervisoryBodyScheme' not in already_processed:
            already_processed.add('supervisoryBodyScheme')
            outfile.write(' supervisoryBodyScheme=%s' % (quote_attrib(self.supervisoryBodyScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SupervisoryBody', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('supervisoryBodyScheme', node)
        if value is not None and 'supervisoryBodyScheme' not in already_processed:
            already_processed.add('supervisoryBodyScheme')
            self.supervisoryBodyScheme = value
            self.validate_NonEmptyURI(self.supervisoryBodyScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SupervisoryBody


class TelephoneNumber(GeneratedsSuper):
    """A type that represents a telephonic contact."""
    member_data_items_ = {
        'type_': MemberSpec_('type_', ['TelephoneTypeEnum', 'Token', 'xsd:token'], 0),
        'number': MemberSpec_('number', ['String', 'xsd:string'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, type_=None, number=None):
        self.original_tagname_ = None
        self.type_ = type_
        self.validate_TelephoneTypeEnum(self.type_)
        self.number = number
        self.validate_String(self.number)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TelephoneNumber)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TelephoneNumber.subclass:
            return TelephoneNumber.subclass(*args_, **kwargs_)
        else:
            return TelephoneNumber(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_number(self): return self.number
    def set_number(self, number): self.number = number
    def validate_TelephoneTypeEnum(self, value):
        # Validate type TelephoneTypeEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Work', 'Mobile', 'Fax', 'Personal']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TelephoneTypeEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on TelephoneTypeEnum' % {"value" : value} )
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.type_ is not None or
            self.number is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TelephoneNumber', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TelephoneNumber')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TelephoneNumber', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TelephoneNumber'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TelephoneNumber', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stype>%s</%stype>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.type_), input_name='type')), namespace_, eol_))
        if self.number is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumber>%s</%snumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.number), input_name='number')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            type_ = child_.text
            type_ = re_.sub(String_cleanup_pat_, " ", type_).strip()
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
            # validate type TelephoneTypeEnum
            self.validate_TelephoneTypeEnum(self.type_)
        elif nodeName_ == 'number':
            number_ = child_.text
            number_ = self.gds_validate_string(number_, node, 'number')
            self.number = number_
            # validate type String
            self.validate_String(self.number)
# end class TelephoneNumber


class TimezoneLocation(GeneratedsSuper):
    """A geophraphic location for the purposes of defining a prevailing
    time according to the tz database."""
    member_data_items_ = {
        'timezoneLocationScheme': MemberSpec_('timezoneLocationScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, timezoneLocationScheme='http://www.fpml.org/coding-scheme/external/tzdatabase', valueOf_=None):
        self.original_tagname_ = None
        self.timezoneLocationScheme = _cast(None, timezoneLocationScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimezoneLocation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimezoneLocation.subclass:
            return TimezoneLocation.subclass(*args_, **kwargs_)
        else:
            return TimezoneLocation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_timezoneLocationScheme(self): return self.timezoneLocationScheme
    def set_timezoneLocationScheme(self, timezoneLocationScheme): self.timezoneLocationScheme = timezoneLocationScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TimezoneLocation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimezoneLocation')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TimezoneLocation', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimezoneLocation'):
        if self.timezoneLocationScheme != "http://www.fpml.org/coding-scheme/external/tzdatabase" and 'timezoneLocationScheme' not in already_processed:
            already_processed.add('timezoneLocationScheme')
            outfile.write(' timezoneLocationScheme=%s' % (quote_attrib(self.timezoneLocationScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TimezoneLocation', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('timezoneLocationScheme', node)
        if value is not None and 'timezoneLocationScheme' not in already_processed:
            already_processed.add('timezoneLocationScheme')
            self.timezoneLocationScheme = value
            self.validate_NonEmptyURI(self.timezoneLocationScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TimezoneLocation


class TradeId(GeneratedsSuper):
    """A trade reference identifier allocated by a party. FpML does not
    define the domain values associated with this element. Note that
    the domain values for this element are not strictly an
    enumerated list."""
    member_data_items_ = {
        'tradeIdScheme': MemberSpec_('tradeIdScheme', 'NonEmptyURI', 0),
        'id': MemberSpec_('id', 'xsd:string', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, tradeIdScheme=None, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.tradeIdScheme = _cast(None, tradeIdScheme)
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TradeId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TradeId.subclass:
            return TradeId.subclass(*args_, **kwargs_)
        else:
            return TradeId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tradeIdScheme(self): return self.tradeIdScheme
    def set_tradeIdScheme(self, tradeIdScheme): self.tradeIdScheme = tradeIdScheme
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TradeId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TradeId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TradeId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TradeId'):
        if self.tradeIdScheme is not None and 'tradeIdScheme' not in already_processed:
            already_processed.add('tradeIdScheme')
            outfile.write(' tradeIdScheme=%s' % (quote_attrib(self.tradeIdScheme), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TradeId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('tradeIdScheme', node)
        if value is not None and 'tradeIdScheme' not in already_processed:
            already_processed.add('tradeIdScheme')
            self.tradeIdScheme = value
            self.validate_NonEmptyURI(self.tradeIdScheme)    # validate type NonEmptyURI
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TradeId


class Unit(GeneratedsSuper):
    """A type used to record information about a unit, subdivision, desk,
    or other similar business entity."""
    member_data_items_ = {
        'unitScheme': MemberSpec_('unitScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, unitScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.unitScheme = _cast(None, unitScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Unit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Unit.subclass:
            return Unit.subclass(*args_, **kwargs_)
        else:
            return Unit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unitScheme(self): return self.unitScheme
    def set_unitScheme(self, unitScheme): self.unitScheme = unitScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Unit', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Unit')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Unit', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Unit'):
        if self.unitScheme is not None and 'unitScheme' not in already_processed:
            already_processed.add('unitScheme')
            outfile.write(' unitScheme=%s' % (quote_attrib(self.unitScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Unit', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unitScheme', node)
        if value is not None and 'unitScheme' not in already_processed:
            already_processed.add('unitScheme')
            self.unitScheme = value
            self.validate_NonEmptyURI(self.unitScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Unit


class IssuerId(GeneratedsSuper):
    """The data type used for issuer identifiers."""
    member_data_items_ = {
        'issuerIdScheme': MemberSpec_('issuerIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, issuerIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.issuerIdScheme = _cast(None, issuerIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IssuerId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IssuerId.subclass:
            return IssuerId.subclass(*args_, **kwargs_)
        else:
            return IssuerId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_issuerIdScheme(self): return self.issuerIdScheme
    def set_issuerIdScheme(self, issuerIdScheme): self.issuerIdScheme = issuerIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IssuerId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IssuerId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IssuerId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IssuerId'):
        if self.issuerIdScheme is not None and 'issuerIdScheme' not in already_processed:
            already_processed.add('issuerIdScheme')
            outfile.write(' issuerIdScheme=%s' % (quote_attrib(self.issuerIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IssuerId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('issuerIdScheme', node)
        if value is not None and 'issuerIdScheme' not in already_processed:
            already_processed.add('issuerIdScheme')
            self.issuerIdScheme = value
            self.validate_NonEmptyURI(self.issuerIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IssuerId


class IssuerTradeId(GeneratedsSuper):
    """A complex type for a two part identifier such as a USI."""
    member_data_items_ = {
        'issuer': MemberSpec_('issuer', 'IssuerId', 0),
        'tradeId': MemberSpec_('tradeId', 'TradeId', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, issuer=None, tradeId=None):
        self.original_tagname_ = None
        self.issuer = issuer
        self.tradeId = tradeId
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IssuerTradeId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IssuerTradeId.subclass:
            return IssuerTradeId.subclass(*args_, **kwargs_)
        else:
            return IssuerTradeId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_issuer(self): return self.issuer
    def set_issuer(self, issuer): self.issuer = issuer
    def get_tradeId(self): return self.tradeId
    def set_tradeId(self, tradeId): self.tradeId = tradeId
    def hasContent_(self):
        if (
            self.issuer is not None or
            self.tradeId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IssuerTradeId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IssuerTradeId')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IssuerTradeId', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IssuerTradeId'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IssuerTradeId', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.issuer is not None:
            self.issuer.export(outfile, level, namespace_, name_='issuer', pretty_print=pretty_print)
        if self.tradeId is not None:
            self.tradeId.export(outfile, level, namespace_, name_='tradeId', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'issuer':
            obj_ = IssuerId.factory()
            obj_.build(child_)
            self.issuer = obj_
            obj_.original_tagname_ = 'issuer'
        elif nodeName_ == 'tradeId':
            obj_ = TradeId.factory()
            obj_.build(child_)
            self.tradeId = obj_
            obj_.original_tagname_ = 'tradeId'
# end class IssuerTradeId


class Stub(StubValue):
    """A type defining how a stub calculation period amount is calculated
    and the start and end date of the stub. A single floating rate
    tenor different to that used for the regular part of the
    calculation periods schedule may be specified, or two floating
    rate tenors many be specified. If two floating rate tenors are
    specified then Linear Interpolation (in accordance with the 2000
    ISDA Definitions, Section 8.3 Interpolation) is assumed to
    apply. Alternatively, an actual known stub rate or stub amount
    may be specified."""
    member_data_items_ = {
        'stubStartDate': MemberSpec_('stubStartDate', 'AdjustableOrRelativeDate', 0),
        'stubEndDate': MemberSpec_('stubEndDate', 'AdjustableOrRelativeDate', 0),
    }
    subclass = None
    superclass = StubValue
    def __init__(self, floatingRate=None, stubRate=None, stubAmount=None, stubStartDate=None, stubEndDate=None):
        self.original_tagname_ = None
        super(Stub, self).__init__(floatingRate, stubRate, stubAmount, )
        self.stubStartDate = stubStartDate
        self.stubEndDate = stubEndDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Stub)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Stub.subclass:
            return Stub.subclass(*args_, **kwargs_)
        else:
            return Stub(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_stubStartDate(self): return self.stubStartDate
    def set_stubStartDate(self, stubStartDate): self.stubStartDate = stubStartDate
    def get_stubEndDate(self): return self.stubEndDate
    def set_stubEndDate(self, stubEndDate): self.stubEndDate = stubEndDate
    def hasContent_(self):
        if (
            self.stubStartDate is not None or
            self.stubEndDate is not None or
            super(Stub, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Stub', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Stub')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Stub', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Stub'):
        super(Stub, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Stub')
    def exportChildren(self, outfile, level, namespace_='', name_='Stub', fromsubclass_=False, pretty_print=True):
        super(Stub, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.stubStartDate is not None:
            self.stubStartDate.export(outfile, level, namespace_, name_='stubStartDate', pretty_print=pretty_print)
        if self.stubEndDate is not None:
            self.stubEndDate.export(outfile, level, namespace_, name_='stubEndDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Stub, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'stubStartDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.stubStartDate = obj_
            obj_.original_tagname_ = 'stubStartDate'
        elif nodeName_ == 'stubEndDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.stubEndDate = obj_
            obj_.original_tagname_ = 'stubEndDate'
        super(Stub, self).buildChildren(child_, node, nodeName_, True)
# end class Stub


class Step(StepBase):
    """A type defining a step date and step value pair. This step
    definitions are used to define varying rate or amount schedules,
    e.g. a notional amortization or a step-up coupon schedule."""
    member_data_items_ = {
        'stepValue': MemberSpec_('stepValue', 'xsd:decimal', 0),
    }
    subclass = None
    superclass = StepBase
    def __init__(self, id=None, stepDate=None, stepValue=None):
        self.original_tagname_ = None
        super(Step, self).__init__(id, stepDate, )
        self.stepValue = stepValue
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Step)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Step.subclass:
            return Step.subclass(*args_, **kwargs_)
        else:
            return Step(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_stepValue(self): return self.stepValue
    def set_stepValue(self, stepValue): self.stepValue = stepValue
    def hasContent_(self):
        if (
            self.stepValue is not None or
            super(Step, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Step', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Step')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Step', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Step'):
        super(Step, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Step')
    def exportChildren(self, outfile, level, namespace_='', name_='Step', fromsubclass_=False, pretty_print=True):
        super(Step, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.stepValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstepValue>%s</%sstepValue>%s' % (namespace_, self.gds_format_float(self.stepValue, input_name='stepValue'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Step, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'stepValue':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'stepValue')
            self.stepValue = fval_
        super(Step, self).buildChildren(child_, node, nodeName_, True)
# end class Step


class ProductReference(Reference):
    """Reference to a full FpML product."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(ProductReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductReference.subclass:
            return ProductReference.subclass(*args_, **kwargs_)
        else:
            return ProductReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(ProductReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ProductReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ProductReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProductReference'):
        super(ProductReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ProductReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ProductReference', fromsubclass_=False, pretty_print=True):
        super(ProductReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(ProductReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ProductReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ProductReference


class PricingStructureReference(Reference):
    """Reference to a pricing structure or any derived components (i.e.
    yield curve)."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(PricingStructureReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PricingStructureReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PricingStructureReference.subclass:
            return PricingStructureReference.subclass(*args_, **kwargs_)
        else:
            return PricingStructureReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(PricingStructureReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PricingStructureReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PricingStructureReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PricingStructureReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PricingStructureReference'):
        super(PricingStructureReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PricingStructureReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PricingStructureReference', fromsubclass_=False, pretty_print=True):
        super(PricingStructureReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(PricingStructureReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(PricingStructureReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PricingStructureReference


class PaymentReference(Reference):
    """Reference to a payment."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(PaymentReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PaymentReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PaymentReference.subclass:
            return PaymentReference.subclass(*args_, **kwargs_)
        else:
            return PaymentReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(PaymentReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PaymentReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PaymentReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PaymentReference'):
        super(PaymentReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PaymentReference', fromsubclass_=False, pretty_print=True):
        super(PaymentReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(PaymentReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(PaymentReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PaymentReference


class Payment(PaymentBase):
    """A type for defining payments. In Transparency view, normally the
    payer and receiver party references are not used; however they
    may be provided if necessary for administrative activities such
    as Reporting Party Determination in FX.Can be used to reference
    the yield curve used to estimate the discount factor."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
        'payerPartyReference': MemberSpec_('payerPartyReference', 'PartyReference', 0),
        'payerAccountReference': MemberSpec_('payerAccountReference', 'AccountReference', 0),
        'receiverPartyReference': MemberSpec_('receiverPartyReference', 'PartyReference', 0),
        'receiverAccountReference': MemberSpec_('receiverAccountReference', 'AccountReference', 0),
        'paymentAmount': MemberSpec_('paymentAmount', 'NonNegativeMoney', 0),
        'paymentDate': MemberSpec_('paymentDate', 'AdjustableOrAdjustedDate', 0),
        'paymentType': MemberSpec_('paymentType', 'PaymentType', 0),
        'settlementInformation': MemberSpec_('settlementInformation', 'SettlementInformation', 0),
        'discountFactor': MemberSpec_('discountFactor', 'xsd:decimal', 0),
        'presentValueAmount': MemberSpec_('presentValueAmount', 'Money', 0),
    }
    subclass = None
    superclass = PaymentBase
    def __init__(self, id=None, href=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, paymentAmount=None, paymentDate=None, paymentType=None, settlementInformation=None, discountFactor=None, presentValueAmount=None):
        self.original_tagname_ = None
        super(Payment, self).__init__(id, )
        self.href = _cast(None, href)
        self.payerPartyReference = payerPartyReference
        self.payerAccountReference = payerAccountReference
        self.receiverPartyReference = receiverPartyReference
        self.receiverAccountReference = receiverAccountReference
        self.paymentAmount = paymentAmount
        self.paymentDate = paymentDate
        self.paymentType = paymentType
        self.settlementInformation = settlementInformation
        self.discountFactor = discountFactor
        self.presentValueAmount = presentValueAmount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Payment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Payment.subclass:
            return Payment.subclass(*args_, **kwargs_)
        else:
            return Payment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_payerPartyReference(self): return self.payerPartyReference
    def set_payerPartyReference(self, payerPartyReference): self.payerPartyReference = payerPartyReference
    def get_payerAccountReference(self): return self.payerAccountReference
    def set_payerAccountReference(self, payerAccountReference): self.payerAccountReference = payerAccountReference
    def get_receiverPartyReference(self): return self.receiverPartyReference
    def set_receiverPartyReference(self, receiverPartyReference): self.receiverPartyReference = receiverPartyReference
    def get_receiverAccountReference(self): return self.receiverAccountReference
    def set_receiverAccountReference(self, receiverAccountReference): self.receiverAccountReference = receiverAccountReference
    def get_paymentAmount(self): return self.paymentAmount
    def set_paymentAmount(self, paymentAmount): self.paymentAmount = paymentAmount
    def get_paymentDate(self): return self.paymentDate
    def set_paymentDate(self, paymentDate): self.paymentDate = paymentDate
    def get_paymentType(self): return self.paymentType
    def set_paymentType(self, paymentType): self.paymentType = paymentType
    def get_settlementInformation(self): return self.settlementInformation
    def set_settlementInformation(self, settlementInformation): self.settlementInformation = settlementInformation
    def get_discountFactor(self): return self.discountFactor
    def set_discountFactor(self, discountFactor): self.discountFactor = discountFactor
    def get_presentValueAmount(self): return self.presentValueAmount
    def set_presentValueAmount(self, presentValueAmount): self.presentValueAmount = presentValueAmount
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            self.payerPartyReference is not None or
            self.payerAccountReference is not None or
            self.receiverPartyReference is not None or
            self.receiverAccountReference is not None or
            self.paymentAmount is not None or
            self.paymentDate is not None or
            self.paymentType is not None or
            self.settlementInformation is not None or
            self.discountFactor is not None or
            self.presentValueAmount is not None or
            super(Payment, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Payment', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Payment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Payment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Payment'):
        super(Payment, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Payment')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Payment', fromsubclass_=False, pretty_print=True):
        super(Payment, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.payerPartyReference is not None:
            self.payerPartyReference.export(outfile, level, namespace_, name_='payerPartyReference', pretty_print=pretty_print)
        if self.payerAccountReference is not None:
            self.payerAccountReference.export(outfile, level, namespace_, name_='payerAccountReference', pretty_print=pretty_print)
        if self.receiverPartyReference is not None:
            self.receiverPartyReference.export(outfile, level, namespace_, name_='receiverPartyReference', pretty_print=pretty_print)
        if self.receiverAccountReference is not None:
            self.receiverAccountReference.export(outfile, level, namespace_, name_='receiverAccountReference', pretty_print=pretty_print)
        if self.paymentAmount is not None:
            self.paymentAmount.export(outfile, level, namespace_, name_='paymentAmount', pretty_print=pretty_print)
        if self.paymentDate is not None:
            self.paymentDate.export(outfile, level, namespace_, name_='paymentDate', pretty_print=pretty_print)
        if self.paymentType is not None:
            self.paymentType.export(outfile, level, namespace_, name_='paymentType', pretty_print=pretty_print)
        if self.settlementInformation is not None:
            self.settlementInformation.export(outfile, level, namespace_, name_='settlementInformation', pretty_print=pretty_print)
        if self.discountFactor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdiscountFactor>%s</%sdiscountFactor>%s' % (namespace_, self.gds_format_float(self.discountFactor, input_name='discountFactor'), namespace_, eol_))
        if self.presentValueAmount is not None:
            self.presentValueAmount.export(outfile, level, namespace_, name_='presentValueAmount', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(Payment, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'payerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.payerPartyReference = obj_
            obj_.original_tagname_ = 'payerPartyReference'
        elif nodeName_ == 'payerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.payerAccountReference = obj_
            obj_.original_tagname_ = 'payerAccountReference'
        elif nodeName_ == 'receiverPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.receiverPartyReference = obj_
            obj_.original_tagname_ = 'receiverPartyReference'
        elif nodeName_ == 'receiverAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.receiverAccountReference = obj_
            obj_.original_tagname_ = 'receiverAccountReference'
        elif nodeName_ == 'paymentAmount':
            class_obj_ = self.get_class_obj_(child_, NonNegativeMoney)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.paymentAmount = obj_
            obj_.original_tagname_ = 'paymentAmount'
        elif nodeName_ == 'paymentDate':
            obj_ = AdjustableOrAdjustedDate.factory()
            obj_.build(child_)
            self.paymentDate = obj_
            obj_.original_tagname_ = 'paymentDate'
        elif nodeName_ == 'paymentType':
            obj_ = PaymentType.factory()
            obj_.build(child_)
            self.paymentType = obj_
            obj_.original_tagname_ = 'paymentType'
        elif nodeName_ == 'settlementInformation':
            obj_ = SettlementInformation.factory()
            obj_.build(child_)
            self.settlementInformation = obj_
            obj_.original_tagname_ = 'settlementInformation'
        elif nodeName_ == 'discountFactor':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'discountFactor')
            self.discountFactor = fval_
        elif nodeName_ == 'presentValueAmount':
            class_obj_ = self.get_class_obj_(child_, Money)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.presentValueAmount = obj_
            obj_.original_tagname_ = 'presentValueAmount'
        super(Payment, self).buildChildren(child_, node, nodeName_, True)
# end class Payment


class PartyTradeIdentifierReference(Reference):
    """A reference to a partyTradeIdentifier object."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(PartyTradeIdentifierReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyTradeIdentifierReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyTradeIdentifierReference.subclass:
            return PartyTradeIdentifierReference.subclass(*args_, **kwargs_)
        else:
            return PartyTradeIdentifierReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(PartyTradeIdentifierReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartyTradeIdentifierReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyTradeIdentifierReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartyTradeIdentifierReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyTradeIdentifierReference'):
        super(PartyTradeIdentifierReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PartyTradeIdentifierReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PartyTradeIdentifierReference', fromsubclass_=False, pretty_print=True):
        super(PartyTradeIdentifierReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(PartyTradeIdentifierReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(PartyTradeIdentifierReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PartyTradeIdentifierReference


class PersonReference(Reference):
    """Reference to an individual."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(PersonReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PersonReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PersonReference.subclass:
            return PersonReference.subclass(*args_, **kwargs_)
        else:
            return PersonReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(PersonReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PersonReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PersonReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PersonReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PersonReference'):
        super(PersonReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PersonReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PersonReference', fromsubclass_=False, pretty_print=True):
        super(PersonReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(PersonReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(PersonReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PersonReference


class PartyReference(Reference):
    """Reference to a party."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(PartyReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyReference.subclass:
            return PartyReference.subclass(*args_, **kwargs_)
        else:
            return PartyReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(PartyReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartyReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartyReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyReference'):
        super(PartyReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PartyReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PartyReference', fromsubclass_=False, pretty_print=True):
        super(PartyReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(PartyReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(PartyReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PartyReference


class Offset(Period):
    """A type defining an offset used in calculating a new date relative to
    a reference date. E.g. calendar days, business days, Commodity
    Business days, etc.."""
    member_data_items_ = {
        'dayType': MemberSpec_('dayType', ['DayTypeEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = Period
    def __init__(self, id=None, periodMultiplier=None, period=None, dayType=None, extensiontype_=None):
        self.original_tagname_ = None
        super(Offset, self).__init__(id, periodMultiplier, period, extensiontype_, )
        self.dayType = dayType
        self.validate_DayTypeEnum(self.dayType)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Offset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Offset.subclass:
            return Offset.subclass(*args_, **kwargs_)
        else:
            return Offset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dayType(self): return self.dayType
    def set_dayType(self, dayType): self.dayType = dayType
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_DayTypeEnum(self, value):
        # Validate type DayTypeEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Business', 'Calendar', 'CommodityBusiness', 'CurrencyBusiness', 'ExchangeBusiness', 'ScheduledTradingDay']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DayTypeEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on DayTypeEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.dayType is not None or
            super(Offset, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Offset', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Offset')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Offset', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Offset'):
        super(Offset, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Offset')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Offset', fromsubclass_=False, pretty_print=True):
        super(Offset, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dayType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdayType>%s</%sdayType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.dayType), input_name='dayType')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(Offset, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dayType':
            dayType_ = child_.text
            dayType_ = re_.sub(String_cleanup_pat_, " ", dayType_).strip()
            dayType_ = self.gds_validate_string(dayType_, node, 'dayType')
            self.dayType = dayType_
            # validate type DayTypeEnum
            self.validate_DayTypeEnum(self.dayType)
        super(Offset, self).buildChildren(child_, node, nodeName_, True)
# end class Offset


class ObservationFrequency(Period):
    """A type defining the frequency at which calculation period end dates
    occur within the regular part of the calculation period schedule
    and thier roll date convention. In case the calculation
    frequency is of value T (term), the period is defined by the
    swap\swapStream\calculationPerioDates\effectiveDate and the
    swap\swapStream\calculationPerioDates\terminationDate."""
    member_data_items_ = {
        'periodConvention': MemberSpec_('periodConvention', ['RollConventionEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = Period
    def __init__(self, id=None, periodMultiplier=None, period=None, periodConvention=None):
        self.original_tagname_ = None
        super(ObservationFrequency, self).__init__(id, periodMultiplier, period, )
        self.periodConvention = periodConvention
        self.validate_RollConventionEnum(self.periodConvention)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ObservationFrequency)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ObservationFrequency.subclass:
            return ObservationFrequency.subclass(*args_, **kwargs_)
        else:
            return ObservationFrequency(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_periodConvention(self): return self.periodConvention
    def set_periodConvention(self, periodConvention): self.periodConvention = periodConvention
    def validate_RollConventionEnum(self, value):
        # Validate type RollConventionEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['EOM', 'FRN', 'IMM', 'IMMCAD', 'IMMAUD', 'IMMNZD', 'SFE', 'NONE', 'TBILL', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '30', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT', 'SUN']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RollConventionEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on RollConventionEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.periodConvention is not None or
            super(ObservationFrequency, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ObservationFrequency', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObservationFrequency')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ObservationFrequency', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ObservationFrequency'):
        super(ObservationFrequency, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ObservationFrequency')
    def exportChildren(self, outfile, level, namespace_='', name_='ObservationFrequency', fromsubclass_=False, pretty_print=True):
        super(ObservationFrequency, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.periodConvention is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%speriodConvention>%s</%speriodConvention>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.periodConvention), input_name='periodConvention')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ObservationFrequency, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'periodConvention':
            periodConvention_ = child_.text
            periodConvention_ = re_.sub(String_cleanup_pat_, " ", periodConvention_).strip()
            periodConvention_ = self.gds_validate_string(periodConvention_, node, 'periodConvention')
            self.periodConvention = periodConvention_
            # validate type RollConventionEnum
            self.validate_RollConventionEnum(self.periodConvention)
        super(ObservationFrequency, self).buildChildren(child_, node, nodeName_, True)
# end class ObservationFrequency


class NumberOfUnitsReference(Reference):
    """A reference to the number of units."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(NumberOfUnitsReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NumberOfUnitsReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NumberOfUnitsReference.subclass:
            return NumberOfUnitsReference.subclass(*args_, **kwargs_)
        else:
            return NumberOfUnitsReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(NumberOfUnitsReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NumberOfUnitsReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NumberOfUnitsReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NumberOfUnitsReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NumberOfUnitsReference'):
        super(NumberOfUnitsReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NumberOfUnitsReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NumberOfUnitsReference', fromsubclass_=False, pretty_print=True):
        super(NumberOfUnitsReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(NumberOfUnitsReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(NumberOfUnitsReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class NumberOfUnitsReference


class NumberOfOptionsReference(Reference):
    """A reference to the number of options."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(NumberOfOptionsReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NumberOfOptionsReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NumberOfOptionsReference.subclass:
            return NumberOfOptionsReference.subclass(*args_, **kwargs_)
        else:
            return NumberOfOptionsReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(NumberOfOptionsReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NumberOfOptionsReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NumberOfOptionsReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NumberOfOptionsReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NumberOfOptionsReference'):
        super(NumberOfOptionsReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NumberOfOptionsReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NumberOfOptionsReference', fromsubclass_=False, pretty_print=True):
        super(NumberOfOptionsReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(NumberOfOptionsReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(NumberOfOptionsReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class NumberOfOptionsReference


class NotionalReference(Reference):
    """A reference to the notional amount."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(NotionalReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NotionalReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NotionalReference.subclass:
            return NotionalReference.subclass(*args_, **kwargs_)
        else:
            return NotionalReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(NotionalReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NotionalReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NotionalReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NotionalReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NotionalReference'):
        super(NotionalReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NotionalReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NotionalReference', fromsubclass_=False, pretty_print=True):
        super(NotionalReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(NotionalReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(NotionalReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class NotionalReference


class NotionalAmountReference(Reference):
    """A reference to the notional amount."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(NotionalAmountReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NotionalAmountReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NotionalAmountReference.subclass:
            return NotionalAmountReference.subclass(*args_, **kwargs_)
        else:
            return NotionalAmountReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(NotionalAmountReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NotionalAmountReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NotionalAmountReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NotionalAmountReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NotionalAmountReference'):
        super(NotionalAmountReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NotionalAmountReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NotionalAmountReference', fromsubclass_=False, pretty_print=True):
        super(NotionalAmountReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(NotionalAmountReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(NotionalAmountReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class NotionalAmountReference


class NonNegativeStep(StepBase):
    """A type defining a step date and non-negative step value pair. This
    step definitions are used to define varying rate or amount
    schedules, e.g. a notional amortization or a step-up coupon
    schedule."""
    member_data_items_ = {
        'stepValue': MemberSpec_('stepValue', ['NonNegativeDecimal', 'xsd:decimal'], 0),
    }
    subclass = None
    superclass = StepBase
    def __init__(self, id=None, stepDate=None, stepValue=None):
        self.original_tagname_ = None
        super(NonNegativeStep, self).__init__(id, stepDate, )
        self.stepValue = stepValue
        self.validate_NonNegativeDecimal(self.stepValue)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NonNegativeStep)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NonNegativeStep.subclass:
            return NonNegativeStep.subclass(*args_, **kwargs_)
        else:
            return NonNegativeStep(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_stepValue(self): return self.stepValue
    def set_stepValue(self, stepValue): self.stepValue = stepValue
    def validate_NonNegativeDecimal(self, value):
        # Validate type NonNegativeDecimal, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on NonNegativeDecimal' % {"value" : value} )
    def hasContent_(self):
        if (
            self.stepValue is not None or
            super(NonNegativeStep, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NonNegativeStep', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NonNegativeStep')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NonNegativeStep', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NonNegativeStep'):
        super(NonNegativeStep, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NonNegativeStep')
    def exportChildren(self, outfile, level, namespace_='', name_='NonNegativeStep', fromsubclass_=False, pretty_print=True):
        super(NonNegativeStep, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.stepValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstepValue>%s</%sstepValue>%s' % (namespace_, self.gds_format_float(self.stepValue, input_name='stepValue'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NonNegativeStep, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'stepValue':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'stepValue')
            self.stepValue = fval_
            # validate type NonNegativeDecimal
            self.validate_NonNegativeDecimal(self.stepValue)
        super(NonNegativeStep, self).buildChildren(child_, node, nodeName_, True)
# end class NonNegativeStep


class NonNegativePayment(PaymentBaseExtended):
    """A complex type to specify non negative payments."""
    member_data_items_ = {
        'paymentAmount': MemberSpec_('paymentAmount', 'NonNegativeMoney', 0),
    }
    subclass = None
    superclass = PaymentBaseExtended
    def __init__(self, id=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, paymentDate=None, paymentAmount=None, extensiontype_=None):
        self.original_tagname_ = None
        super(NonNegativePayment, self).__init__(id, payerPartyReference, payerAccountReference, receiverPartyReference, receiverAccountReference, paymentDate, extensiontype_, )
        self.paymentAmount = paymentAmount
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NonNegativePayment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NonNegativePayment.subclass:
            return NonNegativePayment.subclass(*args_, **kwargs_)
        else:
            return NonNegativePayment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_paymentAmount(self): return self.paymentAmount
    def set_paymentAmount(self, paymentAmount): self.paymentAmount = paymentAmount
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.paymentAmount is not None or
            super(NonNegativePayment, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NonNegativePayment', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NonNegativePayment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NonNegativePayment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NonNegativePayment'):
        super(NonNegativePayment, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NonNegativePayment')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='NonNegativePayment', fromsubclass_=False, pretty_print=True):
        super(NonNegativePayment, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.paymentAmount is not None:
            self.paymentAmount.export(outfile, level, namespace_, name_='paymentAmount', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(NonNegativePayment, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'paymentAmount':
            class_obj_ = self.get_class_obj_(child_, NonNegativeMoney)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.paymentAmount = obj_
            obj_.original_tagname_ = 'paymentAmount'
        super(NonNegativePayment, self).buildChildren(child_, node, nodeName_, True)
# end class NonNegativePayment


class NonNegativeAmountSchedule(NonNegativeSchedule):
    """A type defining a currency amount or a currency amount schedule."""
    member_data_items_ = {
        'currency': MemberSpec_('currency', 'Currency', 0),
    }
    subclass = None
    superclass = NonNegativeSchedule
    def __init__(self, id=None, initialValue=None, step=None, currency=None):
        self.original_tagname_ = None
        super(NonNegativeAmountSchedule, self).__init__(id, initialValue, step, )
        self.currency = currency
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NonNegativeAmountSchedule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NonNegativeAmountSchedule.subclass:
            return NonNegativeAmountSchedule.subclass(*args_, **kwargs_)
        else:
            return NonNegativeAmountSchedule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def hasContent_(self):
        if (
            self.currency is not None or
            super(NonNegativeAmountSchedule, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NonNegativeAmountSchedule', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NonNegativeAmountSchedule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NonNegativeAmountSchedule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NonNegativeAmountSchedule'):
        super(NonNegativeAmountSchedule, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NonNegativeAmountSchedule')
    def exportChildren(self, outfile, level, namespace_='', name_='NonNegativeAmountSchedule', fromsubclass_=False, pretty_print=True):
        super(NonNegativeAmountSchedule, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.currency is not None:
            self.currency.export(outfile, level, namespace_, name_='currency', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NonNegativeAmountSchedule, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'currency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        super(NonNegativeAmountSchedule, self).buildChildren(child_, node, nodeName_, True)
# end class NonNegativeAmountSchedule


class Money(MoneyBase):
    """A type defining a currency amount."""
    member_data_items_ = {
        'amount': MemberSpec_('amount', 'xsd:decimal', 0),
    }
    subclass = None
    superclass = MoneyBase
    def __init__(self, id=None, currency=None, amount=None, extensiontype_=None):
        self.original_tagname_ = None
        super(Money, self).__init__(id, currency, extensiontype_, )
        self.amount = amount
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Money)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Money.subclass:
            return Money.subclass(*args_, **kwargs_)
        else:
            return Money(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_amount(self): return self.amount
    def set_amount(self, amount): self.amount = amount
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.amount is not None or
            super(Money, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Money', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Money')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Money', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Money'):
        super(Money, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Money')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Money', fromsubclass_=False, pretty_print=True):
        super(Money, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.amount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%samount>%s</%samount>%s' % (namespace_, self.gds_format_float(self.amount, input_name='amount'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(Money, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'amount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'amount')
            self.amount = fval_
        super(Money, self).buildChildren(child_, node, nodeName_, True)
# end class Money


class LegalEntityReference(Reference):
    """References a credit entity defined elsewhere in the document."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(LegalEntityReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LegalEntityReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LegalEntityReference.subclass:
            return LegalEntityReference.subclass(*args_, **kwargs_)
        else:
            return LegalEntityReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(LegalEntityReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LegalEntityReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LegalEntityReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LegalEntityReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LegalEntityReference'):
        super(LegalEntityReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LegalEntityReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LegalEntityReference', fromsubclass_=False, pretty_print=True):
        super(LegalEntityReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(LegalEntityReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(LegalEntityReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class LegalEntityReference


class InterestAccrualsCompoundingMethod(InterestAccrualsMethod):
    """A type defining the way in which interests are accrued: the
    applicable rate (fixed or floating reference) and the
    compounding method."""
    member_data_items_ = {
        'compoundingMethod': MemberSpec_('compoundingMethod', ['CompoundingMethodEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = InterestAccrualsMethod
    def __init__(self, floatingRateCalculation=None, fixedRate=None, compoundingMethod=None):
        self.original_tagname_ = None
        super(InterestAccrualsCompoundingMethod, self).__init__(floatingRateCalculation, fixedRate, )
        self.compoundingMethod = compoundingMethod
        self.validate_CompoundingMethodEnum(self.compoundingMethod)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InterestAccrualsCompoundingMethod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InterestAccrualsCompoundingMethod.subclass:
            return InterestAccrualsCompoundingMethod.subclass(*args_, **kwargs_)
        else:
            return InterestAccrualsCompoundingMethod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_compoundingMethod(self): return self.compoundingMethod
    def set_compoundingMethod(self, compoundingMethod): self.compoundingMethod = compoundingMethod
    def validate_CompoundingMethodEnum(self, value):
        # Validate type CompoundingMethodEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Flat', 'None', 'Straight', 'SpreadExclusive']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CompoundingMethodEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on CompoundingMethodEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.compoundingMethod is not None or
            super(InterestAccrualsCompoundingMethod, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InterestAccrualsCompoundingMethod', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InterestAccrualsCompoundingMethod')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InterestAccrualsCompoundingMethod', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InterestAccrualsCompoundingMethod'):
        super(InterestAccrualsCompoundingMethod, self).exportAttributes(outfile, level, already_processed, namespace_, name_='InterestAccrualsCompoundingMethod')
    def exportChildren(self, outfile, level, namespace_='', name_='InterestAccrualsCompoundingMethod', fromsubclass_=False, pretty_print=True):
        super(InterestAccrualsCompoundingMethod, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.compoundingMethod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scompoundingMethod>%s</%scompoundingMethod>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.compoundingMethod), input_name='compoundingMethod')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(InterestAccrualsCompoundingMethod, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'compoundingMethod':
            compoundingMethod_ = child_.text
            compoundingMethod_ = re_.sub(String_cleanup_pat_, " ", compoundingMethod_).strip()
            compoundingMethod_ = self.gds_validate_string(compoundingMethod_, node, 'compoundingMethod')
            self.compoundingMethod = compoundingMethod_
            # validate type CompoundingMethodEnum
            self.validate_CompoundingMethodEnum(self.compoundingMethod)
        super(InterestAccrualsCompoundingMethod, self).buildChildren(child_, node, nodeName_, True)
# end class InterestAccrualsCompoundingMethod


class IdentifiedCurrencyReference(Reference):
    """Reference to a currency with ID attribute"""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(IdentifiedCurrencyReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IdentifiedCurrencyReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IdentifiedCurrencyReference.subclass:
            return IdentifiedCurrencyReference.subclass(*args_, **kwargs_)
        else:
            return IdentifiedCurrencyReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(IdentifiedCurrencyReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IdentifiedCurrencyReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifiedCurrencyReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IdentifiedCurrencyReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IdentifiedCurrencyReference'):
        super(IdentifiedCurrencyReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifiedCurrencyReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IdentifiedCurrencyReference', fromsubclass_=False, pretty_print=True):
        super(IdentifiedCurrencyReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(IdentifiedCurrencyReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(IdentifiedCurrencyReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IdentifiedCurrencyReference


class FxInformationSource(InformationSource):
    member_data_items_ = {
        'fixingTime': MemberSpec_('fixingTime', 'BusinessCenterTime', 0),
    }
    subclass = None
    superclass = InformationSource
    def __init__(self, rateSource=None, rateSourcePage=None, rateSourcePageHeading=None, fixingTime=None):
        self.original_tagname_ = None
        super(FxInformationSource, self).__init__(rateSource, rateSourcePage, rateSourcePageHeading, )
        self.fixingTime = fixingTime
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FxInformationSource)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FxInformationSource.subclass:
            return FxInformationSource.subclass(*args_, **kwargs_)
        else:
            return FxInformationSource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fixingTime(self): return self.fixingTime
    def set_fixingTime(self, fixingTime): self.fixingTime = fixingTime
    def hasContent_(self):
        if (
            self.fixingTime is not None or
            super(FxInformationSource, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FxInformationSource', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FxInformationSource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FxInformationSource', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FxInformationSource'):
        super(FxInformationSource, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FxInformationSource')
    def exportChildren(self, outfile, level, namespace_='', name_='FxInformationSource', fromsubclass_=False, pretty_print=True):
        super(FxInformationSource, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.fixingTime is not None:
            self.fixingTime.export(outfile, level, namespace_, name_='fixingTime', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FxInformationSource, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fixingTime':
            obj_ = BusinessCenterTime.factory()
            obj_.build(child_)
            self.fixingTime = obj_
            obj_.original_tagname_ = 'fixingTime'
        super(FxInformationSource, self).buildChildren(child_, node, nodeName_, True)
# end class FxInformationSource


class FutureValueAmount(NonNegativeMoney):
    """A type defining a currency amount as at a future value date.A type
    defining a currency amount as at a future value date. - For use
    with pre-trade Credit Limit Check messages."""
    member_data_items_ = {
        'calculationPeriodNumberOfDays': MemberSpec_('calculationPeriodNumberOfDays', 'xsd:positiveInteger', 0),
        'valueDate': MemberSpec_('valueDate', 'xsd:date', 0),
    }
    subclass = None
    superclass = NonNegativeMoney
    def __init__(self, id=None, currency=None, amount=None, calculationPeriodNumberOfDays=None, valueDate=None):
        self.original_tagname_ = None
        super(FutureValueAmount, self).__init__(id, currency, amount, )
        self.calculationPeriodNumberOfDays = calculationPeriodNumberOfDays
        if isinstance(valueDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(valueDate, '%Y-%m-%d').date()
        else:
            initvalue_ = valueDate
        self.valueDate = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FutureValueAmount)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FutureValueAmount.subclass:
            return FutureValueAmount.subclass(*args_, **kwargs_)
        else:
            return FutureValueAmount(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_calculationPeriodNumberOfDays(self): return self.calculationPeriodNumberOfDays
    def set_calculationPeriodNumberOfDays(self, calculationPeriodNumberOfDays): self.calculationPeriodNumberOfDays = calculationPeriodNumberOfDays
    def get_valueDate(self): return self.valueDate
    def set_valueDate(self, valueDate): self.valueDate = valueDate
    def hasContent_(self):
        if (
            self.calculationPeriodNumberOfDays is not None or
            self.valueDate is not None or
            super(FutureValueAmount, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FutureValueAmount', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FutureValueAmount')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FutureValueAmount', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FutureValueAmount'):
        super(FutureValueAmount, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FutureValueAmount')
    def exportChildren(self, outfile, level, namespace_='', name_='FutureValueAmount', fromsubclass_=False, pretty_print=True):
        super(FutureValueAmount, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.calculationPeriodNumberOfDays is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scalculationPeriodNumberOfDays>%s</%scalculationPeriodNumberOfDays>%s' % (namespace_, self.gds_format_integer(self.calculationPeriodNumberOfDays, input_name='calculationPeriodNumberOfDays'), namespace_, eol_))
        if self.valueDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalueDate>%s</%svalueDate>%s' % (namespace_, self.gds_format_date(self.valueDate, input_name='valueDate'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FutureValueAmount, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'calculationPeriodNumberOfDays':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'calculationPeriodNumberOfDays')
            self.calculationPeriodNumberOfDays = ival_
        elif nodeName_ == 'valueDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.valueDate = dval_
        super(FutureValueAmount, self).buildChildren(child_, node, nodeName_, True)
# end class FutureValueAmount


class FloatingRate(Rate):
    """A type defining a floating rate."""
    member_data_items_ = {
        'floatingRateIndex': MemberSpec_('floatingRateIndex', 'FloatingRateIndex', 0),
        'indexTenor': MemberSpec_('indexTenor', 'Period', 0),
        'floatingRateMultiplierSchedule': MemberSpec_('floatingRateMultiplierSchedule', 'Schedule', 0),
        'spreadSchedule': MemberSpec_('spreadSchedule', 'SpreadSchedule', 1),
        'rateTreatment': MemberSpec_('rateTreatment', ['RateTreatmentEnum', 'Token', 'xsd:token'], 0),
        'capRateSchedule': MemberSpec_('capRateSchedule', 'StrikeSchedule', 1),
        'floorRateSchedule': MemberSpec_('floorRateSchedule', 'StrikeSchedule', 1),
        'capFloorStraddle': MemberSpec_('capFloorStraddle', 'xsd:boolean', 0),
    }
    subclass = None
    superclass = Rate
    def __init__(self, id=None, floatingRateIndex=None, indexTenor=None, floatingRateMultiplierSchedule=None, spreadSchedule=None, rateTreatment=None, capRateSchedule=None, floorRateSchedule=None, capFloorStraddle=None, extensiontype_=None):
        self.original_tagname_ = None
        super(FloatingRate, self).__init__(id, extensiontype_, )
        self.floatingRateIndex = floatingRateIndex
        self.indexTenor = indexTenor
        self.floatingRateMultiplierSchedule = floatingRateMultiplierSchedule
        if spreadSchedule is None:
            self.spreadSchedule = []
        else:
            self.spreadSchedule = spreadSchedule
        self.rateTreatment = rateTreatment
        self.validate_RateTreatmentEnum(self.rateTreatment)
        if capRateSchedule is None:
            self.capRateSchedule = []
        else:
            self.capRateSchedule = capRateSchedule
        if floorRateSchedule is None:
            self.floorRateSchedule = []
        else:
            self.floorRateSchedule = floorRateSchedule
        self.capFloorStraddle = capFloorStraddle
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FloatingRate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FloatingRate.subclass:
            return FloatingRate.subclass(*args_, **kwargs_)
        else:
            return FloatingRate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_floatingRateIndex(self): return self.floatingRateIndex
    def set_floatingRateIndex(self, floatingRateIndex): self.floatingRateIndex = floatingRateIndex
    def get_indexTenor(self): return self.indexTenor
    def set_indexTenor(self, indexTenor): self.indexTenor = indexTenor
    def get_floatingRateMultiplierSchedule(self): return self.floatingRateMultiplierSchedule
    def set_floatingRateMultiplierSchedule(self, floatingRateMultiplierSchedule): self.floatingRateMultiplierSchedule = floatingRateMultiplierSchedule
    def get_spreadSchedule(self): return self.spreadSchedule
    def set_spreadSchedule(self, spreadSchedule): self.spreadSchedule = spreadSchedule
    def add_spreadSchedule(self, value): self.spreadSchedule.append(value)
    def insert_spreadSchedule_at(self, index, value): self.spreadSchedule.insert(index, value)
    def replace_spreadSchedule_at(self, index, value): self.spreadSchedule[index] = value
    def get_rateTreatment(self): return self.rateTreatment
    def set_rateTreatment(self, rateTreatment): self.rateTreatment = rateTreatment
    def get_capRateSchedule(self): return self.capRateSchedule
    def set_capRateSchedule(self, capRateSchedule): self.capRateSchedule = capRateSchedule
    def add_capRateSchedule(self, value): self.capRateSchedule.append(value)
    def insert_capRateSchedule_at(self, index, value): self.capRateSchedule.insert(index, value)
    def replace_capRateSchedule_at(self, index, value): self.capRateSchedule[index] = value
    def get_floorRateSchedule(self): return self.floorRateSchedule
    def set_floorRateSchedule(self, floorRateSchedule): self.floorRateSchedule = floorRateSchedule
    def add_floorRateSchedule(self, value): self.floorRateSchedule.append(value)
    def insert_floorRateSchedule_at(self, index, value): self.floorRateSchedule.insert(index, value)
    def replace_floorRateSchedule_at(self, index, value): self.floorRateSchedule[index] = value
    def get_capFloorStraddle(self): return self.capFloorStraddle
    def set_capFloorStraddle(self, capFloorStraddle): self.capFloorStraddle = capFloorStraddle
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_RateTreatmentEnum(self, value):
        # Validate type RateTreatmentEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['BondEquivalentYield', 'MoneyMarketYield']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RateTreatmentEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on RateTreatmentEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.floatingRateIndex is not None or
            self.indexTenor is not None or
            self.floatingRateMultiplierSchedule is not None or
            self.spreadSchedule or
            self.rateTreatment is not None or
            self.capRateSchedule or
            self.floorRateSchedule or
            self.capFloorStraddle is not None or
            super(FloatingRate, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FloatingRate', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FloatingRate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FloatingRate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FloatingRate'):
        super(FloatingRate, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FloatingRate')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='FloatingRate', fromsubclass_=False, pretty_print=True):
        super(FloatingRate, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.floatingRateIndex is not None:
            self.floatingRateIndex.export(outfile, level, namespace_, name_='floatingRateIndex', pretty_print=pretty_print)
        if self.indexTenor is not None:
            self.indexTenor.export(outfile, level, namespace_, name_='indexTenor', pretty_print=pretty_print)
        if self.floatingRateMultiplierSchedule is not None:
            self.floatingRateMultiplierSchedule.export(outfile, level, namespace_, name_='floatingRateMultiplierSchedule', pretty_print=pretty_print)
        for spreadSchedule_ in self.spreadSchedule:
            spreadSchedule_.export(outfile, level, namespace_, name_='spreadSchedule', pretty_print=pretty_print)
        if self.rateTreatment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srateTreatment>%s</%srateTreatment>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.rateTreatment), input_name='rateTreatment')), namespace_, eol_))
        for capRateSchedule_ in self.capRateSchedule:
            capRateSchedule_.export(outfile, level, namespace_, name_='capRateSchedule', pretty_print=pretty_print)
        for floorRateSchedule_ in self.floorRateSchedule:
            floorRateSchedule_.export(outfile, level, namespace_, name_='floorRateSchedule', pretty_print=pretty_print)
        if self.capFloorStraddle is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scapFloorStraddle>%s</%scapFloorStraddle>%s' % (namespace_, self.gds_format_boolean(self.capFloorStraddle, input_name='capFloorStraddle'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(FloatingRate, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'floatingRateIndex':
            obj_ = FloatingRateIndex.factory()
            obj_.build(child_)
            self.floatingRateIndex = obj_
            obj_.original_tagname_ = 'floatingRateIndex'
        elif nodeName_ == 'indexTenor':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.indexTenor = obj_
            obj_.original_tagname_ = 'indexTenor'
        elif nodeName_ == 'floatingRateMultiplierSchedule':
            class_obj_ = self.get_class_obj_(child_, Schedule)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.floatingRateMultiplierSchedule = obj_
            obj_.original_tagname_ = 'floatingRateMultiplierSchedule'
        elif nodeName_ == 'spreadSchedule':
            obj_ = SpreadSchedule.factory()
            obj_.build(child_)
            self.spreadSchedule.append(obj_)
            obj_.original_tagname_ = 'spreadSchedule'
        elif nodeName_ == 'rateTreatment':
            rateTreatment_ = child_.text
            rateTreatment_ = re_.sub(String_cleanup_pat_, " ", rateTreatment_).strip()
            rateTreatment_ = self.gds_validate_string(rateTreatment_, node, 'rateTreatment')
            self.rateTreatment = rateTreatment_
            # validate type RateTreatmentEnum
            self.validate_RateTreatmentEnum(self.rateTreatment)
        elif nodeName_ == 'capRateSchedule':
            obj_ = StrikeSchedule.factory()
            obj_.build(child_)
            self.capRateSchedule.append(obj_)
            obj_.original_tagname_ = 'capRateSchedule'
        elif nodeName_ == 'floorRateSchedule':
            obj_ = StrikeSchedule.factory()
            obj_.build(child_)
            self.floorRateSchedule.append(obj_)
            obj_.original_tagname_ = 'floorRateSchedule'
        elif nodeName_ == 'capFloorStraddle':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'capFloorStraddle')
            self.capFloorStraddle = ival_
        super(FloatingRate, self).buildChildren(child_, node, nodeName_, True)
# end class FloatingRate


class EuropeanExercise(Exercise):
    """A type defining the exercise period for a European style option
    together with any rules governing the notional amount of the
    underlying which can be exercised on any given exercise date and
    any associated exercise fees."""
    member_data_items_ = {
        'expirationDate': MemberSpec_('expirationDate', 'AdjustableOrRelativeDate', 0),
        'relevantUnderlyingDate': MemberSpec_('relevantUnderlyingDate', 'AdjustableOrRelativeDates', 0),
        'earliestExerciseTime': MemberSpec_('earliestExerciseTime', 'BusinessCenterTime', 0),
        'expirationTime': MemberSpec_('expirationTime', 'BusinessCenterTime', 0),
        'partialExercise': MemberSpec_('partialExercise', 'PartialExercise', 0),
        'exerciseFee': MemberSpec_('exerciseFee', 'ExerciseFee', 0),
    }
    subclass = None
    superclass = Exercise
    def __init__(self, id=None, expirationDate=None, relevantUnderlyingDate=None, earliestExerciseTime=None, expirationTime=None, partialExercise=None, exerciseFee=None):
        self.original_tagname_ = None
        super(EuropeanExercise, self).__init__(id, )
        self.expirationDate = expirationDate
        self.relevantUnderlyingDate = relevantUnderlyingDate
        self.earliestExerciseTime = earliestExerciseTime
        self.expirationTime = expirationTime
        self.partialExercise = partialExercise
        self.exerciseFee = exerciseFee
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EuropeanExercise)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EuropeanExercise.subclass:
            return EuropeanExercise.subclass(*args_, **kwargs_)
        else:
            return EuropeanExercise(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_expirationDate(self): return self.expirationDate
    def set_expirationDate(self, expirationDate): self.expirationDate = expirationDate
    def get_relevantUnderlyingDate(self): return self.relevantUnderlyingDate
    def set_relevantUnderlyingDate(self, relevantUnderlyingDate): self.relevantUnderlyingDate = relevantUnderlyingDate
    def get_earliestExerciseTime(self): return self.earliestExerciseTime
    def set_earliestExerciseTime(self, earliestExerciseTime): self.earliestExerciseTime = earliestExerciseTime
    def get_expirationTime(self): return self.expirationTime
    def set_expirationTime(self, expirationTime): self.expirationTime = expirationTime
    def get_partialExercise(self): return self.partialExercise
    def set_partialExercise(self, partialExercise): self.partialExercise = partialExercise
    def get_exerciseFee(self): return self.exerciseFee
    def set_exerciseFee(self, exerciseFee): self.exerciseFee = exerciseFee
    def hasContent_(self):
        if (
            self.expirationDate is not None or
            self.relevantUnderlyingDate is not None or
            self.earliestExerciseTime is not None or
            self.expirationTime is not None or
            self.partialExercise is not None or
            self.exerciseFee is not None or
            super(EuropeanExercise, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EuropeanExercise', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EuropeanExercise')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EuropeanExercise', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EuropeanExercise'):
        super(EuropeanExercise, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EuropeanExercise')
    def exportChildren(self, outfile, level, namespace_='', name_='EuropeanExercise', fromsubclass_=False, pretty_print=True):
        super(EuropeanExercise, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.expirationDate is not None:
            self.expirationDate.export(outfile, level, namespace_, name_='expirationDate', pretty_print=pretty_print)
        if self.relevantUnderlyingDate is not None:
            self.relevantUnderlyingDate.export(outfile, level, namespace_, name_='relevantUnderlyingDate', pretty_print=pretty_print)
        if self.earliestExerciseTime is not None:
            self.earliestExerciseTime.export(outfile, level, namespace_, name_='earliestExerciseTime', pretty_print=pretty_print)
        if self.expirationTime is not None:
            self.expirationTime.export(outfile, level, namespace_, name_='expirationTime', pretty_print=pretty_print)
        if self.partialExercise is not None:
            self.partialExercise.export(outfile, level, namespace_, name_='partialExercise', pretty_print=pretty_print)
        if self.exerciseFee is not None:
            self.exerciseFee.export(outfile, level, namespace_, name_='exerciseFee', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EuropeanExercise, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'expirationDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.expirationDate = obj_
            obj_.original_tagname_ = 'expirationDate'
        elif nodeName_ == 'relevantUnderlyingDate':
            obj_ = AdjustableOrRelativeDates.factory()
            obj_.build(child_)
            self.relevantUnderlyingDate = obj_
            obj_.original_tagname_ = 'relevantUnderlyingDate'
        elif nodeName_ == 'earliestExerciseTime':
            obj_ = BusinessCenterTime.factory()
            obj_.build(child_)
            self.earliestExerciseTime = obj_
            obj_.original_tagname_ = 'earliestExerciseTime'
        elif nodeName_ == 'expirationTime':
            obj_ = BusinessCenterTime.factory()
            obj_.build(child_)
            self.expirationTime = obj_
            obj_.original_tagname_ = 'expirationTime'
        elif nodeName_ == 'partialExercise':
            obj_ = PartialExercise.factory()
            obj_.build(child_)
            self.partialExercise = obj_
            obj_.original_tagname_ = 'partialExercise'
        elif nodeName_ == 'exerciseFee':
            obj_ = ExerciseFee.factory()
            obj_.build(child_)
            self.exerciseFee = obj_
            obj_.original_tagname_ = 'exerciseFee'
        super(EuropeanExercise, self).buildChildren(child_, node, nodeName_, True)
# end class EuropeanExercise


class DirectionalLeg(Leg):
    """An abstract base class for all directional leg types with effective
    date, termination date, where a payer makes a stream of payments
    of greater than zero value to a receiver."""
    member_data_items_ = {
        'legIdentifier': MemberSpec_('legIdentifier', 'LegIdentifier', 1),
        'payerPartyReference': MemberSpec_('payerPartyReference', 'PartyReference', 0),
        'payerAccountReference': MemberSpec_('payerAccountReference', 'AccountReference', 0),
        'receiverPartyReference': MemberSpec_('receiverPartyReference', 'PartyReference', 0),
        'receiverAccountReference': MemberSpec_('receiverAccountReference', 'AccountReference', 0),
        'effectiveDate': MemberSpec_('effectiveDate', 'AdjustableOrRelativeDate', 0),
        'terminationDate': MemberSpec_('terminationDate', 'AdjustableOrRelativeDate', 0),
    }
    subclass = None
    superclass = Leg
    def __init__(self, id=None, legIdentifier=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, effectiveDate=None, terminationDate=None, extensiontype_=None):
        self.original_tagname_ = None
        super(DirectionalLeg, self).__init__(id, extensiontype_, )
        if legIdentifier is None:
            self.legIdentifier = []
        else:
            self.legIdentifier = legIdentifier
        self.payerPartyReference = payerPartyReference
        self.payerAccountReference = payerAccountReference
        self.receiverPartyReference = receiverPartyReference
        self.receiverAccountReference = receiverAccountReference
        self.effectiveDate = effectiveDate
        self.terminationDate = terminationDate
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DirectionalLeg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DirectionalLeg.subclass:
            return DirectionalLeg.subclass(*args_, **kwargs_)
        else:
            return DirectionalLeg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_legIdentifier(self): return self.legIdentifier
    def set_legIdentifier(self, legIdentifier): self.legIdentifier = legIdentifier
    def add_legIdentifier(self, value): self.legIdentifier.append(value)
    def insert_legIdentifier_at(self, index, value): self.legIdentifier.insert(index, value)
    def replace_legIdentifier_at(self, index, value): self.legIdentifier[index] = value
    def get_payerPartyReference(self): return self.payerPartyReference
    def set_payerPartyReference(self, payerPartyReference): self.payerPartyReference = payerPartyReference
    def get_payerAccountReference(self): return self.payerAccountReference
    def set_payerAccountReference(self, payerAccountReference): self.payerAccountReference = payerAccountReference
    def get_receiverPartyReference(self): return self.receiverPartyReference
    def set_receiverPartyReference(self, receiverPartyReference): self.receiverPartyReference = receiverPartyReference
    def get_receiverAccountReference(self): return self.receiverAccountReference
    def set_receiverAccountReference(self, receiverAccountReference): self.receiverAccountReference = receiverAccountReference
    def get_effectiveDate(self): return self.effectiveDate
    def set_effectiveDate(self, effectiveDate): self.effectiveDate = effectiveDate
    def get_terminationDate(self): return self.terminationDate
    def set_terminationDate(self, terminationDate): self.terminationDate = terminationDate
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.legIdentifier or
            self.payerPartyReference is not None or
            self.payerAccountReference is not None or
            self.receiverPartyReference is not None or
            self.receiverAccountReference is not None or
            self.effectiveDate is not None or
            self.terminationDate is not None or
            super(DirectionalLeg, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DirectionalLeg', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DirectionalLeg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DirectionalLeg', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DirectionalLeg'):
        super(DirectionalLeg, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DirectionalLeg')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='DirectionalLeg', fromsubclass_=False, pretty_print=True):
        super(DirectionalLeg, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for legIdentifier_ in self.legIdentifier:
            legIdentifier_.export(outfile, level, namespace_, name_='legIdentifier', pretty_print=pretty_print)
        if self.payerPartyReference is not None:
            self.payerPartyReference.export(outfile, level, namespace_, name_='payerPartyReference', pretty_print=pretty_print)
        if self.payerAccountReference is not None:
            self.payerAccountReference.export(outfile, level, namespace_, name_='payerAccountReference', pretty_print=pretty_print)
        if self.receiverPartyReference is not None:
            self.receiverPartyReference.export(outfile, level, namespace_, name_='receiverPartyReference', pretty_print=pretty_print)
        if self.receiverAccountReference is not None:
            self.receiverAccountReference.export(outfile, level, namespace_, name_='receiverAccountReference', pretty_print=pretty_print)
        if self.effectiveDate is not None:
            self.effectiveDate.export(outfile, level, namespace_, name_='effectiveDate', pretty_print=pretty_print)
        if self.terminationDate is not None:
            self.terminationDate.export(outfile, level, namespace_, name_='terminationDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(DirectionalLeg, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'legIdentifier':
            obj_ = LegIdentifier.factory()
            obj_.build(child_)
            self.legIdentifier.append(obj_)
            obj_.original_tagname_ = 'legIdentifier'
        elif nodeName_ == 'payerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.payerPartyReference = obj_
            obj_.original_tagname_ = 'payerPartyReference'
        elif nodeName_ == 'payerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.payerAccountReference = obj_
            obj_.original_tagname_ = 'payerAccountReference'
        elif nodeName_ == 'receiverPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.receiverPartyReference = obj_
            obj_.original_tagname_ = 'receiverPartyReference'
        elif nodeName_ == 'receiverAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.receiverAccountReference = obj_
            obj_.original_tagname_ = 'receiverAccountReference'
        elif nodeName_ == 'effectiveDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.effectiveDate = obj_
            obj_.original_tagname_ = 'effectiveDate'
        elif nodeName_ == 'terminationDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.terminationDate = obj_
            obj_.original_tagname_ = 'terminationDate'
        super(DirectionalLeg, self).buildChildren(child_, node, nodeName_, True)
# end class DirectionalLeg


class DeterminationMethodReference(Reference):
    """A reference to the return swap notional determination method."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(DeterminationMethodReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DeterminationMethodReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DeterminationMethodReference.subclass:
            return DeterminationMethodReference.subclass(*args_, **kwargs_)
        else:
            return DeterminationMethodReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(DeterminationMethodReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DeterminationMethodReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeterminationMethodReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DeterminationMethodReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DeterminationMethodReference'):
        super(DeterminationMethodReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DeterminationMethodReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DeterminationMethodReference', fromsubclass_=False, pretty_print=True):
        super(DeterminationMethodReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(DeterminationMethodReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DeterminationMethodReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DeterminationMethodReference


class DateReference(Reference):
    """Reference to an identified date or a complex date structure."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(DateReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DateReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DateReference.subclass:
            return DateReference.subclass(*args_, **kwargs_)
        else:
            return DateReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(DateReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DateReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DateReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DateReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DateReference'):
        super(DateReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DateReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DateReference', fromsubclass_=False, pretty_print=True):
        super(DateReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(DateReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DateReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DateReference


class DateOffset(Offset):
    """A type defining an offset used in calculating a date when this date
    is defined in reference to another date through a date offset.
    The type includes the convention for adjusting the date and an
    optional sequence element to indicate the order in a sequence of
    multiple date offsets."""
    member_data_items_ = {
        'businessDayConvention': MemberSpec_('businessDayConvention', ['BusinessDayConventionEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = Offset
    def __init__(self, id=None, periodMultiplier=None, period=None, dayType=None, businessDayConvention=None):
        self.original_tagname_ = None
        super(DateOffset, self).__init__(id, periodMultiplier, period, dayType, )
        self.businessDayConvention = businessDayConvention
        self.validate_BusinessDayConventionEnum(self.businessDayConvention)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DateOffset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DateOffset.subclass:
            return DateOffset.subclass(*args_, **kwargs_)
        else:
            return DateOffset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_businessDayConvention(self): return self.businessDayConvention
    def set_businessDayConvention(self, businessDayConvention): self.businessDayConvention = businessDayConvention
    def validate_BusinessDayConventionEnum(self, value):
        # Validate type BusinessDayConventionEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FOLLOWING', 'FRN', 'MODFOLLOWING', 'PRECEDING', 'MODPRECEDING', 'NEAREST', 'NONE', 'NotApplicable']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on BusinessDayConventionEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on BusinessDayConventionEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.businessDayConvention is not None or
            super(DateOffset, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DateOffset', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DateOffset')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DateOffset', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DateOffset'):
        super(DateOffset, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DateOffset')
    def exportChildren(self, outfile, level, namespace_='', name_='DateOffset', fromsubclass_=False, pretty_print=True):
        super(DateOffset, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.businessDayConvention is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbusinessDayConvention>%s</%sbusinessDayConvention>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.businessDayConvention), input_name='businessDayConvention')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DateOffset, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'businessDayConvention':
            businessDayConvention_ = child_.text
            businessDayConvention_ = re_.sub(String_cleanup_pat_, " ", businessDayConvention_).strip()
            businessDayConvention_ = self.gds_validate_string(businessDayConvention_, node, 'businessDayConvention')
            self.businessDayConvention = businessDayConvention_
            # validate type BusinessDayConventionEnum
            self.validate_BusinessDayConventionEnum(self.businessDayConvention)
        super(DateOffset, self).buildChildren(child_, node, nodeName_, True)
# end class DateOffset


class CalculationPeriodFrequency(Frequency):
    """A type defining the frequency at which calculation period end dates
    occur within the regular part of the calculation period schedule
    and thier roll date convention. In case the calculation
    frequency is of value T (term), the period is defined by the
    swap\swapStream\calculationPerioDates\effectiveDate and the
    swap\swapStream\calculationPerioDates\terminationDate."""
    member_data_items_ = {
        'rollConvention': MemberSpec_('rollConvention', ['RollConventionEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = Frequency
    def __init__(self, id=None, periodMultiplier=None, period=None, rollConvention=None):
        self.original_tagname_ = None
        super(CalculationPeriodFrequency, self).__init__(id, periodMultiplier, period, )
        self.rollConvention = rollConvention
        self.validate_RollConventionEnum(self.rollConvention)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CalculationPeriodFrequency)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CalculationPeriodFrequency.subclass:
            return CalculationPeriodFrequency.subclass(*args_, **kwargs_)
        else:
            return CalculationPeriodFrequency(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rollConvention(self): return self.rollConvention
    def set_rollConvention(self, rollConvention): self.rollConvention = rollConvention
    def validate_RollConventionEnum(self, value):
        # Validate type RollConventionEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['EOM', 'FRN', 'IMM', 'IMMCAD', 'IMMAUD', 'IMMNZD', 'SFE', 'NONE', 'TBILL', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '30', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT', 'SUN']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RollConventionEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on RollConventionEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.rollConvention is not None or
            super(CalculationPeriodFrequency, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CalculationPeriodFrequency', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CalculationPeriodFrequency')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CalculationPeriodFrequency', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CalculationPeriodFrequency'):
        super(CalculationPeriodFrequency, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CalculationPeriodFrequency')
    def exportChildren(self, outfile, level, namespace_='', name_='CalculationPeriodFrequency', fromsubclass_=False, pretty_print=True):
        super(CalculationPeriodFrequency, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.rollConvention is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srollConvention>%s</%srollConvention>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.rollConvention), input_name='rollConvention')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CalculationPeriodFrequency, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'rollConvention':
            rollConvention_ = child_.text
            rollConvention_ = re_.sub(String_cleanup_pat_, " ", rollConvention_).strip()
            rollConvention_ = self.gds_validate_string(rollConvention_, node, 'rollConvention')
            self.rollConvention = rollConvention_
            # validate type RollConventionEnum
            self.validate_RollConventionEnum(self.rollConvention)
        super(CalculationPeriodFrequency, self).buildChildren(child_, node, nodeName_, True)
# end class CalculationPeriodFrequency


class BusinessUnitReference(Reference):
    """Reference to an organizational unit."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(BusinessUnitReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BusinessUnitReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BusinessUnitReference.subclass:
            return BusinessUnitReference.subclass(*args_, **kwargs_)
        else:
            return BusinessUnitReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(BusinessUnitReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BusinessUnitReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BusinessUnitReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BusinessUnitReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BusinessUnitReference'):
        super(BusinessUnitReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BusinessUnitReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BusinessUnitReference', fromsubclass_=False, pretty_print=True):
        super(BusinessUnitReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(BusinessUnitReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(BusinessUnitReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BusinessUnitReference


class BusinessDayAdjustmentsReference(Reference):
    """Reference to a business day adjustments structure."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(BusinessDayAdjustmentsReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BusinessDayAdjustmentsReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BusinessDayAdjustmentsReference.subclass:
            return BusinessDayAdjustmentsReference.subclass(*args_, **kwargs_)
        else:
            return BusinessDayAdjustmentsReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(BusinessDayAdjustmentsReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BusinessDayAdjustmentsReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BusinessDayAdjustmentsReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BusinessDayAdjustmentsReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BusinessDayAdjustmentsReference'):
        super(BusinessDayAdjustmentsReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BusinessDayAdjustmentsReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BusinessDayAdjustmentsReference', fromsubclass_=False, pretty_print=True):
        super(BusinessDayAdjustmentsReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(BusinessDayAdjustmentsReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(BusinessDayAdjustmentsReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BusinessDayAdjustmentsReference


class BusinessDateRange(DateRange):
    """A type defining a range of contiguous business days by defining an
    unadjusted first date, an unadjusted last date and a business
    day convention and business centers for adjusting the first and
    last dates if they would otherwise fall on a non business day in
    the specified business centers. The days between the first and
    last date must also be good business days in the specified
    centers to be counted in the range."""
    member_data_items_ = {
        'businessDayConvention': MemberSpec_('businessDayConvention', ['BusinessDayConventionEnum', 'Token', 'xsd:token'], 0),
        'businessCentersReference': MemberSpec_('businessCentersReference', 'BusinessCentersReference', 0),
        'businessCenters': MemberSpec_('businessCenters', 'BusinessCenters', 0),
    }
    subclass = None
    superclass = DateRange
    def __init__(self, unadjustedFirstDate=None, unadjustedLastDate=None, businessDayConvention=None, businessCentersReference=None, businessCenters=None):
        self.original_tagname_ = None
        super(BusinessDateRange, self).__init__(unadjustedFirstDate, unadjustedLastDate, )
        self.businessDayConvention = businessDayConvention
        self.validate_BusinessDayConventionEnum(self.businessDayConvention)
        self.businessCentersReference = businessCentersReference
        self.businessCenters = businessCenters
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BusinessDateRange)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BusinessDateRange.subclass:
            return BusinessDateRange.subclass(*args_, **kwargs_)
        else:
            return BusinessDateRange(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_businessDayConvention(self): return self.businessDayConvention
    def set_businessDayConvention(self, businessDayConvention): self.businessDayConvention = businessDayConvention
    def get_businessCentersReference(self): return self.businessCentersReference
    def set_businessCentersReference(self, businessCentersReference): self.businessCentersReference = businessCentersReference
    def get_businessCenters(self): return self.businessCenters
    def set_businessCenters(self, businessCenters): self.businessCenters = businessCenters
    def validate_BusinessDayConventionEnum(self, value):
        # Validate type BusinessDayConventionEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FOLLOWING', 'FRN', 'MODFOLLOWING', 'PRECEDING', 'MODPRECEDING', 'NEAREST', 'NONE', 'NotApplicable']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on BusinessDayConventionEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on BusinessDayConventionEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.businessDayConvention is not None or
            self.businessCentersReference is not None or
            self.businessCenters is not None or
            super(BusinessDateRange, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BusinessDateRange', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BusinessDateRange')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BusinessDateRange', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BusinessDateRange'):
        super(BusinessDateRange, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BusinessDateRange')
    def exportChildren(self, outfile, level, namespace_='', name_='BusinessDateRange', fromsubclass_=False, pretty_print=True):
        super(BusinessDateRange, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.businessDayConvention is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbusinessDayConvention>%s</%sbusinessDayConvention>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.businessDayConvention), input_name='businessDayConvention')), namespace_, eol_))
        if self.businessCentersReference is not None:
            self.businessCentersReference.export(outfile, level, namespace_, name_='businessCentersReference', pretty_print=pretty_print)
        if self.businessCenters is not None:
            self.businessCenters.export(outfile, level, namespace_, name_='businessCenters', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(BusinessDateRange, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'businessDayConvention':
            businessDayConvention_ = child_.text
            businessDayConvention_ = re_.sub(String_cleanup_pat_, " ", businessDayConvention_).strip()
            businessDayConvention_ = self.gds_validate_string(businessDayConvention_, node, 'businessDayConvention')
            self.businessDayConvention = businessDayConvention_
            # validate type BusinessDayConventionEnum
            self.validate_BusinessDayConventionEnum(self.businessDayConvention)
        elif nodeName_ == 'businessCentersReference':
            obj_ = BusinessCentersReference.factory()
            obj_.build(child_)
            self.businessCentersReference = obj_
            obj_.original_tagname_ = 'businessCentersReference'
        elif nodeName_ == 'businessCenters':
            obj_ = BusinessCenters.factory()
            obj_.build(child_)
            self.businessCenters = obj_
            obj_.original_tagname_ = 'businessCenters'
        super(BusinessDateRange, self).buildChildren(child_, node, nodeName_, True)
# end class BusinessDateRange


class BusinessCentersReference(Reference):
    """A pointer style reference to a set of business day calendar defined
    elsewhere in the document."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(BusinessCentersReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BusinessCentersReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BusinessCentersReference.subclass:
            return BusinessCentersReference.subclass(*args_, **kwargs_)
        else:
            return BusinessCentersReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(BusinessCentersReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BusinessCentersReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BusinessCentersReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BusinessCentersReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BusinessCentersReference'):
        super(BusinessCentersReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BusinessCentersReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BusinessCentersReference', fromsubclass_=False, pretty_print=True):
        super(BusinessCentersReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(BusinessCentersReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(BusinessCentersReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BusinessCentersReference


class BermudaExercise(Exercise):
    """A type defining the Bermuda option exercise dates and the expiration
    date together with any rules govenerning the notional amount of
    the underlying which can be exercised on any given exercise date
    and any associated exercise fee."""
    member_data_items_ = {
        'bermudaExerciseDates': MemberSpec_('bermudaExerciseDates', 'AdjustableOrRelativeDates', 0),
        'relevantUnderlyingDate': MemberSpec_('relevantUnderlyingDate', 'AdjustableOrRelativeDates', 0),
        'earliestExerciseTime': MemberSpec_('earliestExerciseTime', 'BusinessCenterTime', 0),
        'latestExerciseTime': MemberSpec_('latestExerciseTime', 'BusinessCenterTime', 0),
        'expirationTime': MemberSpec_('expirationTime', 'BusinessCenterTime', 0),
        'multipleExercise': MemberSpec_('multipleExercise', 'MultipleExercise', 0),
        'exerciseFeeSchedule': MemberSpec_('exerciseFeeSchedule', 'ExerciseFeeSchedule', 0),
    }
    subclass = None
    superclass = Exercise
    def __init__(self, id=None, bermudaExerciseDates=None, relevantUnderlyingDate=None, earliestExerciseTime=None, latestExerciseTime=None, expirationTime=None, multipleExercise=None, exerciseFeeSchedule=None):
        self.original_tagname_ = None
        super(BermudaExercise, self).__init__(id, )
        self.bermudaExerciseDates = bermudaExerciseDates
        self.relevantUnderlyingDate = relevantUnderlyingDate
        self.earliestExerciseTime = earliestExerciseTime
        self.latestExerciseTime = latestExerciseTime
        self.expirationTime = expirationTime
        self.multipleExercise = multipleExercise
        self.exerciseFeeSchedule = exerciseFeeSchedule
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BermudaExercise)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BermudaExercise.subclass:
            return BermudaExercise.subclass(*args_, **kwargs_)
        else:
            return BermudaExercise(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_bermudaExerciseDates(self): return self.bermudaExerciseDates
    def set_bermudaExerciseDates(self, bermudaExerciseDates): self.bermudaExerciseDates = bermudaExerciseDates
    def get_relevantUnderlyingDate(self): return self.relevantUnderlyingDate
    def set_relevantUnderlyingDate(self, relevantUnderlyingDate): self.relevantUnderlyingDate = relevantUnderlyingDate
    def get_earliestExerciseTime(self): return self.earliestExerciseTime
    def set_earliestExerciseTime(self, earliestExerciseTime): self.earliestExerciseTime = earliestExerciseTime
    def get_latestExerciseTime(self): return self.latestExerciseTime
    def set_latestExerciseTime(self, latestExerciseTime): self.latestExerciseTime = latestExerciseTime
    def get_expirationTime(self): return self.expirationTime
    def set_expirationTime(self, expirationTime): self.expirationTime = expirationTime
    def get_multipleExercise(self): return self.multipleExercise
    def set_multipleExercise(self, multipleExercise): self.multipleExercise = multipleExercise
    def get_exerciseFeeSchedule(self): return self.exerciseFeeSchedule
    def set_exerciseFeeSchedule(self, exerciseFeeSchedule): self.exerciseFeeSchedule = exerciseFeeSchedule
    def hasContent_(self):
        if (
            self.bermudaExerciseDates is not None or
            self.relevantUnderlyingDate is not None or
            self.earliestExerciseTime is not None or
            self.latestExerciseTime is not None or
            self.expirationTime is not None or
            self.multipleExercise is not None or
            self.exerciseFeeSchedule is not None or
            super(BermudaExercise, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BermudaExercise', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BermudaExercise')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BermudaExercise', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BermudaExercise'):
        super(BermudaExercise, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BermudaExercise')
    def exportChildren(self, outfile, level, namespace_='', name_='BermudaExercise', fromsubclass_=False, pretty_print=True):
        super(BermudaExercise, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.bermudaExerciseDates is not None:
            self.bermudaExerciseDates.export(outfile, level, namespace_, name_='bermudaExerciseDates', pretty_print=pretty_print)
        if self.relevantUnderlyingDate is not None:
            self.relevantUnderlyingDate.export(outfile, level, namespace_, name_='relevantUnderlyingDate', pretty_print=pretty_print)
        if self.earliestExerciseTime is not None:
            self.earliestExerciseTime.export(outfile, level, namespace_, name_='earliestExerciseTime', pretty_print=pretty_print)
        if self.latestExerciseTime is not None:
            self.latestExerciseTime.export(outfile, level, namespace_, name_='latestExerciseTime', pretty_print=pretty_print)
        if self.expirationTime is not None:
            self.expirationTime.export(outfile, level, namespace_, name_='expirationTime', pretty_print=pretty_print)
        if self.multipleExercise is not None:
            self.multipleExercise.export(outfile, level, namespace_, name_='multipleExercise', pretty_print=pretty_print)
        if self.exerciseFeeSchedule is not None:
            self.exerciseFeeSchedule.export(outfile, level, namespace_, name_='exerciseFeeSchedule', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(BermudaExercise, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'bermudaExerciseDates':
            obj_ = AdjustableOrRelativeDates.factory()
            obj_.build(child_)
            self.bermudaExerciseDates = obj_
            obj_.original_tagname_ = 'bermudaExerciseDates'
        elif nodeName_ == 'relevantUnderlyingDate':
            obj_ = AdjustableOrRelativeDates.factory()
            obj_.build(child_)
            self.relevantUnderlyingDate = obj_
            obj_.original_tagname_ = 'relevantUnderlyingDate'
        elif nodeName_ == 'earliestExerciseTime':
            obj_ = BusinessCenterTime.factory()
            obj_.build(child_)
            self.earliestExerciseTime = obj_
            obj_.original_tagname_ = 'earliestExerciseTime'
        elif nodeName_ == 'latestExerciseTime':
            obj_ = BusinessCenterTime.factory()
            obj_.build(child_)
            self.latestExerciseTime = obj_
            obj_.original_tagname_ = 'latestExerciseTime'
        elif nodeName_ == 'expirationTime':
            obj_ = BusinessCenterTime.factory()
            obj_.build(child_)
            self.expirationTime = obj_
            obj_.original_tagname_ = 'expirationTime'
        elif nodeName_ == 'multipleExercise':
            obj_ = MultipleExercise.factory()
            obj_.build(child_)
            self.multipleExercise = obj_
            obj_.original_tagname_ = 'multipleExercise'
        elif nodeName_ == 'exerciseFeeSchedule':
            obj_ = ExerciseFeeSchedule.factory()
            obj_.build(child_)
            self.exerciseFeeSchedule = obj_
            obj_.original_tagname_ = 'exerciseFeeSchedule'
        super(BermudaExercise, self).buildChildren(child_, node, nodeName_, True)
# end class BermudaExercise


class AmountSchedule(Schedule):
    """A type defining a currency amount or a currency amount schedule."""
    member_data_items_ = {
        'currency': MemberSpec_('currency', 'Currency', 0),
    }
    subclass = None
    superclass = Schedule
    def __init__(self, id=None, initialValue=None, step=None, currency=None):
        self.original_tagname_ = None
        super(AmountSchedule, self).__init__(id, initialValue, step, )
        self.currency = currency
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AmountSchedule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AmountSchedule.subclass:
            return AmountSchedule.subclass(*args_, **kwargs_)
        else:
            return AmountSchedule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def hasContent_(self):
        if (
            self.currency is not None or
            super(AmountSchedule, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AmountSchedule', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AmountSchedule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AmountSchedule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AmountSchedule'):
        super(AmountSchedule, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AmountSchedule')
    def exportChildren(self, outfile, level, namespace_='', name_='AmountSchedule', fromsubclass_=False, pretty_print=True):
        super(AmountSchedule, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.currency is not None:
            self.currency.export(outfile, level, namespace_, name_='currency', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AmountSchedule, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'currency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        super(AmountSchedule, self).buildChildren(child_, node, nodeName_, True)
# end class AmountSchedule


class AmountReference(Reference):
    """Specifies a reference to a monetary amount."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(AmountReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AmountReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AmountReference.subclass:
            return AmountReference.subclass(*args_, **kwargs_)
        else:
            return AmountReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(AmountReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AmountReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AmountReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AmountReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AmountReference'):
        super(AmountReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AmountReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AmountReference', fromsubclass_=False, pretty_print=True):
        super(AmountReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(AmountReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AmountReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AmountReference


class AmericanExercise(Exercise):
    """A type defining the exercise period for an American style option
    together with any rules governing the notional amount of the
    underlying which can be exercised on any given exercise date and
    any associated exercise fees."""
    member_data_items_ = {
        'commencementDate': MemberSpec_('commencementDate', 'AdjustableOrRelativeDate', 0),
        'expirationDate': MemberSpec_('expirationDate', 'AdjustableOrRelativeDate', 0),
        'relevantUnderlyingDate': MemberSpec_('relevantUnderlyingDate', 'AdjustableOrRelativeDates', 0),
        'earliestExerciseTime': MemberSpec_('earliestExerciseTime', 'BusinessCenterTime', 0),
        'latestExerciseTime': MemberSpec_('latestExerciseTime', 'BusinessCenterTime', 0),
        'expirationTime': MemberSpec_('expirationTime', 'BusinessCenterTime', 0),
        'multipleExercise': MemberSpec_('multipleExercise', 'MultipleExercise', 0),
        'exerciseFeeSchedule': MemberSpec_('exerciseFeeSchedule', 'ExerciseFeeSchedule', 0),
    }
    subclass = None
    superclass = Exercise
    def __init__(self, id=None, commencementDate=None, expirationDate=None, relevantUnderlyingDate=None, earliestExerciseTime=None, latestExerciseTime=None, expirationTime=None, multipleExercise=None, exerciseFeeSchedule=None):
        self.original_tagname_ = None
        super(AmericanExercise, self).__init__(id, )
        self.commencementDate = commencementDate
        self.expirationDate = expirationDate
        self.relevantUnderlyingDate = relevantUnderlyingDate
        self.earliestExerciseTime = earliestExerciseTime
        self.latestExerciseTime = latestExerciseTime
        self.expirationTime = expirationTime
        self.multipleExercise = multipleExercise
        self.exerciseFeeSchedule = exerciseFeeSchedule
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AmericanExercise)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AmericanExercise.subclass:
            return AmericanExercise.subclass(*args_, **kwargs_)
        else:
            return AmericanExercise(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commencementDate(self): return self.commencementDate
    def set_commencementDate(self, commencementDate): self.commencementDate = commencementDate
    def get_expirationDate(self): return self.expirationDate
    def set_expirationDate(self, expirationDate): self.expirationDate = expirationDate
    def get_relevantUnderlyingDate(self): return self.relevantUnderlyingDate
    def set_relevantUnderlyingDate(self, relevantUnderlyingDate): self.relevantUnderlyingDate = relevantUnderlyingDate
    def get_earliestExerciseTime(self): return self.earliestExerciseTime
    def set_earliestExerciseTime(self, earliestExerciseTime): self.earliestExerciseTime = earliestExerciseTime
    def get_latestExerciseTime(self): return self.latestExerciseTime
    def set_latestExerciseTime(self, latestExerciseTime): self.latestExerciseTime = latestExerciseTime
    def get_expirationTime(self): return self.expirationTime
    def set_expirationTime(self, expirationTime): self.expirationTime = expirationTime
    def get_multipleExercise(self): return self.multipleExercise
    def set_multipleExercise(self, multipleExercise): self.multipleExercise = multipleExercise
    def get_exerciseFeeSchedule(self): return self.exerciseFeeSchedule
    def set_exerciseFeeSchedule(self, exerciseFeeSchedule): self.exerciseFeeSchedule = exerciseFeeSchedule
    def hasContent_(self):
        if (
            self.commencementDate is not None or
            self.expirationDate is not None or
            self.relevantUnderlyingDate is not None or
            self.earliestExerciseTime is not None or
            self.latestExerciseTime is not None or
            self.expirationTime is not None or
            self.multipleExercise is not None or
            self.exerciseFeeSchedule is not None or
            super(AmericanExercise, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AmericanExercise', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AmericanExercise')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AmericanExercise', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AmericanExercise'):
        super(AmericanExercise, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AmericanExercise')
    def exportChildren(self, outfile, level, namespace_='', name_='AmericanExercise', fromsubclass_=False, pretty_print=True):
        super(AmericanExercise, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.commencementDate is not None:
            self.commencementDate.export(outfile, level, namespace_, name_='commencementDate', pretty_print=pretty_print)
        if self.expirationDate is not None:
            self.expirationDate.export(outfile, level, namespace_, name_='expirationDate', pretty_print=pretty_print)
        if self.relevantUnderlyingDate is not None:
            self.relevantUnderlyingDate.export(outfile, level, namespace_, name_='relevantUnderlyingDate', pretty_print=pretty_print)
        if self.earliestExerciseTime is not None:
            self.earliestExerciseTime.export(outfile, level, namespace_, name_='earliestExerciseTime', pretty_print=pretty_print)
        if self.latestExerciseTime is not None:
            self.latestExerciseTime.export(outfile, level, namespace_, name_='latestExerciseTime', pretty_print=pretty_print)
        if self.expirationTime is not None:
            self.expirationTime.export(outfile, level, namespace_, name_='expirationTime', pretty_print=pretty_print)
        if self.multipleExercise is not None:
            self.multipleExercise.export(outfile, level, namespace_, name_='multipleExercise', pretty_print=pretty_print)
        if self.exerciseFeeSchedule is not None:
            self.exerciseFeeSchedule.export(outfile, level, namespace_, name_='exerciseFeeSchedule', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AmericanExercise, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'commencementDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.commencementDate = obj_
            obj_.original_tagname_ = 'commencementDate'
        elif nodeName_ == 'expirationDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.expirationDate = obj_
            obj_.original_tagname_ = 'expirationDate'
        elif nodeName_ == 'relevantUnderlyingDate':
            obj_ = AdjustableOrRelativeDates.factory()
            obj_.build(child_)
            self.relevantUnderlyingDate = obj_
            obj_.original_tagname_ = 'relevantUnderlyingDate'
        elif nodeName_ == 'earliestExerciseTime':
            obj_ = BusinessCenterTime.factory()
            obj_.build(child_)
            self.earliestExerciseTime = obj_
            obj_.original_tagname_ = 'earliestExerciseTime'
        elif nodeName_ == 'latestExerciseTime':
            obj_ = BusinessCenterTime.factory()
            obj_.build(child_)
            self.latestExerciseTime = obj_
            obj_.original_tagname_ = 'latestExerciseTime'
        elif nodeName_ == 'expirationTime':
            obj_ = BusinessCenterTime.factory()
            obj_.build(child_)
            self.expirationTime = obj_
            obj_.original_tagname_ = 'expirationTime'
        elif nodeName_ == 'multipleExercise':
            obj_ = MultipleExercise.factory()
            obj_.build(child_)
            self.multipleExercise = obj_
            obj_.original_tagname_ = 'multipleExercise'
        elif nodeName_ == 'exerciseFeeSchedule':
            obj_ = ExerciseFeeSchedule.factory()
            obj_.build(child_)
            self.exerciseFeeSchedule = obj_
            obj_.original_tagname_ = 'exerciseFeeSchedule'
        super(AmericanExercise, self).buildChildren(child_, node, nodeName_, True)
# end class AmericanExercise


class AccountReference(Reference):
    """Reference to an account."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(AccountReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AccountReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AccountReference.subclass:
            return AccountReference.subclass(*args_, **kwargs_)
        else:
            return AccountReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(AccountReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AccountReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AccountReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AccountReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AccountReference'):
        super(AccountReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AccountReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AccountReference', fromsubclass_=False, pretty_print=True):
        super(AccountReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(AccountReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AccountReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AccountReference


class SimpleIRSwap(UnderlyingAsset):
    member_data_items_ = {
        'term': MemberSpec_('term', 'Period', 0),
        'paymentFrequency': MemberSpec_('paymentFrequency', 'Period', 0),
        'dayCountFraction': MemberSpec_('dayCountFraction', 'DayCountFraction', 0),
    }
    subclass = None
    superclass = UnderlyingAsset
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, term=None, paymentFrequency=None, dayCountFraction=None):
        self.original_tagname_ = None
        super(SimpleIRSwap, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, )
        self.term = term
        self.paymentFrequency = paymentFrequency
        self.dayCountFraction = dayCountFraction
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SimpleIRSwap)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SimpleIRSwap.subclass:
            return SimpleIRSwap.subclass(*args_, **kwargs_)
        else:
            return SimpleIRSwap(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_term(self): return self.term
    def set_term(self, term): self.term = term
    def get_paymentFrequency(self): return self.paymentFrequency
    def set_paymentFrequency(self, paymentFrequency): self.paymentFrequency = paymentFrequency
    def get_dayCountFraction(self): return self.dayCountFraction
    def set_dayCountFraction(self, dayCountFraction): self.dayCountFraction = dayCountFraction
    def hasContent_(self):
        if (
            self.term is not None or
            self.paymentFrequency is not None or
            self.dayCountFraction is not None or
            super(SimpleIRSwap, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SimpleIRSwap', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SimpleIRSwap')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SimpleIRSwap', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SimpleIRSwap'):
        super(SimpleIRSwap, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SimpleIRSwap')
    def exportChildren(self, outfile, level, namespace_='', name_='SimpleIRSwap', fromsubclass_=False, pretty_print=True):
        super(SimpleIRSwap, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.term is not None:
            self.term.export(outfile, level, namespace_, name_='term', pretty_print=pretty_print)
        if self.paymentFrequency is not None:
            self.paymentFrequency.export(outfile, level, namespace_, name_='paymentFrequency', pretty_print=pretty_print)
        if self.dayCountFraction is not None:
            self.dayCountFraction.export(outfile, level, namespace_, name_='dayCountFraction', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SimpleIRSwap, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'term':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.term = obj_
            obj_.original_tagname_ = 'term'
        elif nodeName_ == 'paymentFrequency':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.paymentFrequency = obj_
            obj_.original_tagname_ = 'paymentFrequency'
        elif nodeName_ == 'dayCountFraction':
            obj_ = DayCountFraction.factory()
            obj_.build(child_)
            self.dayCountFraction = obj_
            obj_.original_tagname_ = 'dayCountFraction'
        super(SimpleIRSwap, self).buildChildren(child_, node, nodeName_, True)
# end class SimpleIRSwap


class SimpleFra(UnderlyingAsset):
    member_data_items_ = {
        'startTerm': MemberSpec_('startTerm', 'Period', 0),
        'endTerm': MemberSpec_('endTerm', 'Period', 0),
        'dayCountFraction': MemberSpec_('dayCountFraction', 'DayCountFraction', 0),
    }
    subclass = None
    superclass = UnderlyingAsset
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, startTerm=None, endTerm=None, dayCountFraction=None):
        self.original_tagname_ = None
        super(SimpleFra, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, )
        self.startTerm = startTerm
        self.endTerm = endTerm
        self.dayCountFraction = dayCountFraction
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SimpleFra)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SimpleFra.subclass:
            return SimpleFra.subclass(*args_, **kwargs_)
        else:
            return SimpleFra(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_startTerm(self): return self.startTerm
    def set_startTerm(self, startTerm): self.startTerm = startTerm
    def get_endTerm(self): return self.endTerm
    def set_endTerm(self, endTerm): self.endTerm = endTerm
    def get_dayCountFraction(self): return self.dayCountFraction
    def set_dayCountFraction(self, dayCountFraction): self.dayCountFraction = dayCountFraction
    def hasContent_(self):
        if (
            self.startTerm is not None or
            self.endTerm is not None or
            self.dayCountFraction is not None or
            super(SimpleFra, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SimpleFra', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SimpleFra')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SimpleFra', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SimpleFra'):
        super(SimpleFra, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SimpleFra')
    def exportChildren(self, outfile, level, namespace_='', name_='SimpleFra', fromsubclass_=False, pretty_print=True):
        super(SimpleFra, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.startTerm is not None:
            self.startTerm.export(outfile, level, namespace_, name_='startTerm', pretty_print=pretty_print)
        if self.endTerm is not None:
            self.endTerm.export(outfile, level, namespace_, name_='endTerm', pretty_print=pretty_print)
        if self.dayCountFraction is not None:
            self.dayCountFraction.export(outfile, level, namespace_, name_='dayCountFraction', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SimpleFra, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'startTerm':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.startTerm = obj_
            obj_.original_tagname_ = 'startTerm'
        elif nodeName_ == 'endTerm':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.endTerm = obj_
            obj_.original_tagname_ = 'endTerm'
        elif nodeName_ == 'dayCountFraction':
            obj_ = DayCountFraction.factory()
            obj_.build(child_)
            self.dayCountFraction = obj_
            obj_.original_tagname_ = 'dayCountFraction'
        super(SimpleFra, self).buildChildren(child_, node, nodeName_, True)
# end class SimpleFra


class SimpleCreditDefaultSwap(UnderlyingAsset):
    member_data_items_ = {
        'referenceEntity': MemberSpec_('referenceEntity', 'LegalEntity', 0),
        'creditEntityReference': MemberSpec_('creditEntityReference', 'LegalEntityReference', 0),
        'term': MemberSpec_('term', 'Period', 0),
        'paymentFrequency': MemberSpec_('paymentFrequency', 'Period', 0),
    }
    subclass = None
    superclass = UnderlyingAsset
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, referenceEntity=None, creditEntityReference=None, term=None, paymentFrequency=None):
        self.original_tagname_ = None
        super(SimpleCreditDefaultSwap, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, )
        self.referenceEntity = referenceEntity
        self.creditEntityReference = creditEntityReference
        self.term = term
        self.paymentFrequency = paymentFrequency
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SimpleCreditDefaultSwap)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SimpleCreditDefaultSwap.subclass:
            return SimpleCreditDefaultSwap.subclass(*args_, **kwargs_)
        else:
            return SimpleCreditDefaultSwap(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_referenceEntity(self): return self.referenceEntity
    def set_referenceEntity(self, referenceEntity): self.referenceEntity = referenceEntity
    def get_creditEntityReference(self): return self.creditEntityReference
    def set_creditEntityReference(self, creditEntityReference): self.creditEntityReference = creditEntityReference
    def get_term(self): return self.term
    def set_term(self, term): self.term = term
    def get_paymentFrequency(self): return self.paymentFrequency
    def set_paymentFrequency(self, paymentFrequency): self.paymentFrequency = paymentFrequency
    def hasContent_(self):
        if (
            self.referenceEntity is not None or
            self.creditEntityReference is not None or
            self.term is not None or
            self.paymentFrequency is not None or
            super(SimpleCreditDefaultSwap, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SimpleCreditDefaultSwap', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SimpleCreditDefaultSwap')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SimpleCreditDefaultSwap', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SimpleCreditDefaultSwap'):
        super(SimpleCreditDefaultSwap, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SimpleCreditDefaultSwap')
    def exportChildren(self, outfile, level, namespace_='', name_='SimpleCreditDefaultSwap', fromsubclass_=False, pretty_print=True):
        super(SimpleCreditDefaultSwap, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.referenceEntity is not None:
            self.referenceEntity.export(outfile, level, namespace_, name_='referenceEntity', pretty_print=pretty_print)
        if self.creditEntityReference is not None:
            self.creditEntityReference.export(outfile, level, namespace_, name_='creditEntityReference', pretty_print=pretty_print)
        if self.term is not None:
            self.term.export(outfile, level, namespace_, name_='term', pretty_print=pretty_print)
        if self.paymentFrequency is not None:
            self.paymentFrequency.export(outfile, level, namespace_, name_='paymentFrequency', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SimpleCreditDefaultSwap, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'referenceEntity':
            obj_ = LegalEntity.factory()
            obj_.build(child_)
            self.referenceEntity = obj_
            obj_.original_tagname_ = 'referenceEntity'
        elif nodeName_ == 'creditEntityReference':
            obj_ = LegalEntityReference.factory()
            obj_.build(child_)
            self.creditEntityReference = obj_
            obj_.original_tagname_ = 'creditEntityReference'
        elif nodeName_ == 'term':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.term = obj_
            obj_.original_tagname_ = 'term'
        elif nodeName_ == 'paymentFrequency':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.paymentFrequency = obj_
            obj_.original_tagname_ = 'paymentFrequency'
        super(SimpleCreditDefaultSwap, self).buildChildren(child_, node, nodeName_, True)
# end class SimpleCreditDefaultSwap


class RateIndex(UnderlyingAsset):
    member_data_items_ = {
        'floatingRateIndex': MemberSpec_('floatingRateIndex', 'FloatingRateIndex', 0),
        'term': MemberSpec_('term', 'Period', 0),
        'paymentFrequency': MemberSpec_('paymentFrequency', 'Period', 0),
        'dayCountFraction': MemberSpec_('dayCountFraction', 'DayCountFraction', 0),
    }
    subclass = None
    superclass = UnderlyingAsset
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, floatingRateIndex=None, term=None, paymentFrequency=None, dayCountFraction=None):
        self.original_tagname_ = None
        super(RateIndex, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, )
        self.floatingRateIndex = floatingRateIndex
        self.term = term
        self.paymentFrequency = paymentFrequency
        self.dayCountFraction = dayCountFraction
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RateIndex)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RateIndex.subclass:
            return RateIndex.subclass(*args_, **kwargs_)
        else:
            return RateIndex(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_floatingRateIndex(self): return self.floatingRateIndex
    def set_floatingRateIndex(self, floatingRateIndex): self.floatingRateIndex = floatingRateIndex
    def get_term(self): return self.term
    def set_term(self, term): self.term = term
    def get_paymentFrequency(self): return self.paymentFrequency
    def set_paymentFrequency(self, paymentFrequency): self.paymentFrequency = paymentFrequency
    def get_dayCountFraction(self): return self.dayCountFraction
    def set_dayCountFraction(self, dayCountFraction): self.dayCountFraction = dayCountFraction
    def hasContent_(self):
        if (
            self.floatingRateIndex is not None or
            self.term is not None or
            self.paymentFrequency is not None or
            self.dayCountFraction is not None or
            super(RateIndex, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RateIndex', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RateIndex')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RateIndex', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RateIndex'):
        super(RateIndex, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RateIndex')
    def exportChildren(self, outfile, level, namespace_='', name_='RateIndex', fromsubclass_=False, pretty_print=True):
        super(RateIndex, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.floatingRateIndex is not None:
            self.floatingRateIndex.export(outfile, level, namespace_, name_='floatingRateIndex', pretty_print=pretty_print)
        if self.term is not None:
            self.term.export(outfile, level, namespace_, name_='term', pretty_print=pretty_print)
        if self.paymentFrequency is not None:
            self.paymentFrequency.export(outfile, level, namespace_, name_='paymentFrequency', pretty_print=pretty_print)
        if self.dayCountFraction is not None:
            self.dayCountFraction.export(outfile, level, namespace_, name_='dayCountFraction', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RateIndex, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'floatingRateIndex':
            obj_ = FloatingRateIndex.factory()
            obj_.build(child_)
            self.floatingRateIndex = obj_
            obj_.original_tagname_ = 'floatingRateIndex'
        elif nodeName_ == 'term':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.term = obj_
            obj_.original_tagname_ = 'term'
        elif nodeName_ == 'paymentFrequency':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.paymentFrequency = obj_
            obj_.original_tagname_ = 'paymentFrequency'
        elif nodeName_ == 'dayCountFraction':
            obj_ = DayCountFraction.factory()
            obj_.build(child_)
            self.dayCountFraction = obj_
            obj_.original_tagname_ = 'dayCountFraction'
        super(RateIndex, self).buildChildren(child_, node, nodeName_, True)
# end class RateIndex


class PendingPayment(PaymentBase):
    """A structure representing a pending dividend or coupon payment."""
    member_data_items_ = {
        'paymentDate': MemberSpec_('paymentDate', 'xsd:date', 0),
        'amount': MemberSpec_('amount', 'Money', 0),
        'accruedInterest': MemberSpec_('accruedInterest', 'Money', 0),
    }
    subclass = None
    superclass = PaymentBase
    def __init__(self, id=None, paymentDate=None, amount=None, accruedInterest=None):
        self.original_tagname_ = None
        super(PendingPayment, self).__init__(id, )
        if isinstance(paymentDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(paymentDate, '%Y-%m-%d').date()
        else:
            initvalue_ = paymentDate
        self.paymentDate = initvalue_
        self.amount = amount
        self.accruedInterest = accruedInterest
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PendingPayment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PendingPayment.subclass:
            return PendingPayment.subclass(*args_, **kwargs_)
        else:
            return PendingPayment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_paymentDate(self): return self.paymentDate
    def set_paymentDate(self, paymentDate): self.paymentDate = paymentDate
    def get_amount(self): return self.amount
    def set_amount(self, amount): self.amount = amount
    def get_accruedInterest(self): return self.accruedInterest
    def set_accruedInterest(self, accruedInterest): self.accruedInterest = accruedInterest
    def hasContent_(self):
        if (
            self.paymentDate is not None or
            self.amount is not None or
            self.accruedInterest is not None or
            super(PendingPayment, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PendingPayment', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PendingPayment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PendingPayment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PendingPayment'):
        super(PendingPayment, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PendingPayment')
    def exportChildren(self, outfile, level, namespace_='', name_='PendingPayment', fromsubclass_=False, pretty_print=True):
        super(PendingPayment, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.paymentDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spaymentDate>%s</%spaymentDate>%s' % (namespace_, self.gds_format_date(self.paymentDate, input_name='paymentDate'), namespace_, eol_))
        if self.amount is not None:
            self.amount.export(outfile, level, namespace_, name_='amount', pretty_print=pretty_print)
        if self.accruedInterest is not None:
            self.accruedInterest.export(outfile, level, namespace_, name_='accruedInterest', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PendingPayment, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'paymentDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.paymentDate = dval_
        elif nodeName_ == 'amount':
            class_obj_ = self.get_class_obj_(child_, Money)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.amount = obj_
            obj_.original_tagname_ = 'amount'
        elif nodeName_ == 'accruedInterest':
            class_obj_ = self.get_class_obj_(child_, Money)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.accruedInterest = obj_
            obj_.original_tagname_ = 'accruedInterest'
        super(PendingPayment, self).buildChildren(child_, node, nodeName_, True)
# end class PendingPayment


class MutualFund(UnderlyingAsset):
    member_data_items_ = {
        'openEndedFund': MemberSpec_('openEndedFund', 'xsd:boolean', 0),
        'fundManager': MemberSpec_('fundManager', ['String', 'xsd:string'], 0),
    }
    subclass = None
    superclass = UnderlyingAsset
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, openEndedFund=None, fundManager=None):
        self.original_tagname_ = None
        super(MutualFund, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, )
        self.openEndedFund = openEndedFund
        self.fundManager = fundManager
        self.validate_String(self.fundManager)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MutualFund)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MutualFund.subclass:
            return MutualFund.subclass(*args_, **kwargs_)
        else:
            return MutualFund(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_openEndedFund(self): return self.openEndedFund
    def set_openEndedFund(self, openEndedFund): self.openEndedFund = openEndedFund
    def get_fundManager(self): return self.fundManager
    def set_fundManager(self, fundManager): self.fundManager = fundManager
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.openEndedFund is not None or
            self.fundManager is not None or
            super(MutualFund, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MutualFund', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MutualFund')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MutualFund', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MutualFund'):
        super(MutualFund, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MutualFund')
    def exportChildren(self, outfile, level, namespace_='', name_='MutualFund', fromsubclass_=False, pretty_print=True):
        super(MutualFund, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.openEndedFund is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sopenEndedFund>%s</%sopenEndedFund>%s' % (namespace_, self.gds_format_boolean(self.openEndedFund, input_name='openEndedFund'), namespace_, eol_))
        if self.fundManager is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfundManager>%s</%sfundManager>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.fundManager), input_name='fundManager')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MutualFund, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'openEndedFund':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'openEndedFund')
            self.openEndedFund = ival_
        elif nodeName_ == 'fundManager':
            fundManager_ = child_.text
            fundManager_ = self.gds_validate_string(fundManager_, node, 'fundManager')
            self.fundManager = fundManager_
            # validate type String
            self.validate_String(self.fundManager)
        super(MutualFund, self).buildChildren(child_, node, nodeName_, True)
# end class MutualFund


class Mortgage(UnderlyingAsset):
    """A type describing a mortgage asset.Applicable to the case of default
    swaps on MBS terms. For specifying the insurer name, when
    applicable (when the element is not present, it signifies that
    the insurer is Not Applicable)Specifies the issuer name of a
    fixed income security or convertible bond. This name can either
    be explicitly stated, or specified as an href into another
    element of the document, such as the obligor."""
    member_data_items_ = {
        'insurer': MemberSpec_('insurer', 'LegalEntity', 0),
        'insurerReference': MemberSpec_('insurerReference', 'LegalEntityReference', 0),
        'issuerName': MemberSpec_('issuerName', ['String', 'xsd:string'], 0),
        'issuerPartyReference': MemberSpec_('issuerPartyReference', 'PartyReference', 0),
        'seniority': MemberSpec_('seniority', 'CreditSeniority', 0),
        'couponType': MemberSpec_('couponType', 'CouponType', 0),
        'couponRate': MemberSpec_('couponRate', 'xsd:decimal', 0),
        'maturity': MemberSpec_('maturity', 'xsd:date', 0),
        'paymentFrequency': MemberSpec_('paymentFrequency', 'Period', 0),
        'dayCountFraction': MemberSpec_('dayCountFraction', 'DayCountFraction', 0),
        'originalPrincipalAmount': MemberSpec_('originalPrincipalAmount', 'xsd:decimal', 0),
        'pool': MemberSpec_('pool', 'AssetPool', 0),
        'sector': MemberSpec_('sector', 'MortgageSector', 0),
        'tranche': MemberSpec_('tranche', ['Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = UnderlyingAsset
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, insurer=None, insurerReference=None, issuerName=None, issuerPartyReference=None, seniority=None, couponType=None, couponRate=None, maturity=None, paymentFrequency=None, dayCountFraction=None, originalPrincipalAmount=None, pool=None, sector=None, tranche=None):
        self.original_tagname_ = None
        super(Mortgage, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, )
        self.insurer = insurer
        self.insurerReference = insurerReference
        self.issuerName = issuerName
        self.validate_String(self.issuerName)
        self.issuerPartyReference = issuerPartyReference
        self.seniority = seniority
        self.couponType = couponType
        self.couponRate = couponRate
        if isinstance(maturity, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(maturity, '%Y-%m-%d').date()
        else:
            initvalue_ = maturity
        self.maturity = initvalue_
        self.paymentFrequency = paymentFrequency
        self.dayCountFraction = dayCountFraction
        self.originalPrincipalAmount = originalPrincipalAmount
        self.pool = pool
        self.sector = sector
        self.tranche = tranche
        self.validate_Token(self.tranche)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Mortgage)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Mortgage.subclass:
            return Mortgage.subclass(*args_, **kwargs_)
        else:
            return Mortgage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_insurer(self): return self.insurer
    def set_insurer(self, insurer): self.insurer = insurer
    def get_insurerReference(self): return self.insurerReference
    def set_insurerReference(self, insurerReference): self.insurerReference = insurerReference
    def get_issuerName(self): return self.issuerName
    def set_issuerName(self, issuerName): self.issuerName = issuerName
    def get_issuerPartyReference(self): return self.issuerPartyReference
    def set_issuerPartyReference(self, issuerPartyReference): self.issuerPartyReference = issuerPartyReference
    def get_seniority(self): return self.seniority
    def set_seniority(self, seniority): self.seniority = seniority
    def get_couponType(self): return self.couponType
    def set_couponType(self, couponType): self.couponType = couponType
    def get_couponRate(self): return self.couponRate
    def set_couponRate(self, couponRate): self.couponRate = couponRate
    def get_maturity(self): return self.maturity
    def set_maturity(self, maturity): self.maturity = maturity
    def get_paymentFrequency(self): return self.paymentFrequency
    def set_paymentFrequency(self, paymentFrequency): self.paymentFrequency = paymentFrequency
    def get_dayCountFraction(self): return self.dayCountFraction
    def set_dayCountFraction(self, dayCountFraction): self.dayCountFraction = dayCountFraction
    def get_originalPrincipalAmount(self): return self.originalPrincipalAmount
    def set_originalPrincipalAmount(self, originalPrincipalAmount): self.originalPrincipalAmount = originalPrincipalAmount
    def get_pool(self): return self.pool
    def set_pool(self, pool): self.pool = pool
    def get_sector(self): return self.sector
    def set_sector(self, sector): self.sector = sector
    def get_tranche(self): return self.tranche
    def set_tranche(self, tranche): self.tranche = tranche
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def validate_Token(self, value):
        # Validate type Token, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Token' % {"value" : value} )
    def hasContent_(self):
        if (
            self.insurer is not None or
            self.insurerReference is not None or
            self.issuerName is not None or
            self.issuerPartyReference is not None or
            self.seniority is not None or
            self.couponType is not None or
            self.couponRate is not None or
            self.maturity is not None or
            self.paymentFrequency is not None or
            self.dayCountFraction is not None or
            self.originalPrincipalAmount is not None or
            self.pool is not None or
            self.sector is not None or
            self.tranche is not None or
            super(Mortgage, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Mortgage', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Mortgage')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Mortgage', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Mortgage'):
        super(Mortgage, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Mortgage')
    def exportChildren(self, outfile, level, namespace_='', name_='Mortgage', fromsubclass_=False, pretty_print=True):
        super(Mortgage, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.insurer is not None:
            self.insurer.export(outfile, level, namespace_, name_='insurer', pretty_print=pretty_print)
        if self.insurerReference is not None:
            self.insurerReference.export(outfile, level, namespace_, name_='insurerReference', pretty_print=pretty_print)
        if self.issuerName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sissuerName>%s</%sissuerName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.issuerName), input_name='issuerName')), namespace_, eol_))
        if self.issuerPartyReference is not None:
            self.issuerPartyReference.export(outfile, level, namespace_, name_='issuerPartyReference', pretty_print=pretty_print)
        if self.seniority is not None:
            self.seniority.export(outfile, level, namespace_, name_='seniority', pretty_print=pretty_print)
        if self.couponType is not None:
            self.couponType.export(outfile, level, namespace_, name_='couponType', pretty_print=pretty_print)
        if self.couponRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scouponRate>%s</%scouponRate>%s' % (namespace_, self.gds_format_float(self.couponRate, input_name='couponRate'), namespace_, eol_))
        if self.maturity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaturity>%s</%smaturity>%s' % (namespace_, self.gds_format_date(self.maturity, input_name='maturity'), namespace_, eol_))
        if self.paymentFrequency is not None:
            self.paymentFrequency.export(outfile, level, namespace_, name_='paymentFrequency', pretty_print=pretty_print)
        if self.dayCountFraction is not None:
            self.dayCountFraction.export(outfile, level, namespace_, name_='dayCountFraction', pretty_print=pretty_print)
        if self.originalPrincipalAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soriginalPrincipalAmount>%s</%soriginalPrincipalAmount>%s' % (namespace_, self.gds_format_float(self.originalPrincipalAmount, input_name='originalPrincipalAmount'), namespace_, eol_))
        if self.pool is not None:
            self.pool.export(outfile, level, namespace_, name_='pool', pretty_print=pretty_print)
        if self.sector is not None:
            self.sector.export(outfile, level, namespace_, name_='sector', pretty_print=pretty_print)
        if self.tranche is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stranche>%s</%stranche>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.tranche), input_name='tranche')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Mortgage, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'insurer':
            obj_ = LegalEntity.factory()
            obj_.build(child_)
            self.insurer = obj_
            obj_.original_tagname_ = 'insurer'
        elif nodeName_ == 'insurerReference':
            obj_ = LegalEntityReference.factory()
            obj_.build(child_)
            self.insurerReference = obj_
            obj_.original_tagname_ = 'insurerReference'
        elif nodeName_ == 'issuerName':
            issuerName_ = child_.text
            issuerName_ = self.gds_validate_string(issuerName_, node, 'issuerName')
            self.issuerName = issuerName_
            # validate type String
            self.validate_String(self.issuerName)
        elif nodeName_ == 'issuerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.issuerPartyReference = obj_
            obj_.original_tagname_ = 'issuerPartyReference'
        elif nodeName_ == 'seniority':
            obj_ = CreditSeniority.factory()
            obj_.build(child_)
            self.seniority = obj_
            obj_.original_tagname_ = 'seniority'
        elif nodeName_ == 'couponType':
            obj_ = CouponType.factory()
            obj_.build(child_)
            self.couponType = obj_
            obj_.original_tagname_ = 'couponType'
        elif nodeName_ == 'couponRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'couponRate')
            self.couponRate = fval_
        elif nodeName_ == 'maturity':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.maturity = dval_
        elif nodeName_ == 'paymentFrequency':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.paymentFrequency = obj_
            obj_.original_tagname_ = 'paymentFrequency'
        elif nodeName_ == 'dayCountFraction':
            obj_ = DayCountFraction.factory()
            obj_.build(child_)
            self.dayCountFraction = obj_
            obj_.original_tagname_ = 'dayCountFraction'
        elif nodeName_ == 'originalPrincipalAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'originalPrincipalAmount')
            self.originalPrincipalAmount = fval_
        elif nodeName_ == 'pool':
            obj_ = AssetPool.factory()
            obj_.build(child_)
            self.pool = obj_
            obj_.original_tagname_ = 'pool'
        elif nodeName_ == 'sector':
            obj_ = MortgageSector.factory()
            obj_.build(child_)
            self.sector = obj_
            obj_.original_tagname_ = 'sector'
        elif nodeName_ == 'tranche':
            tranche_ = child_.text
            tranche_ = re_.sub(String_cleanup_pat_, " ", tranche_).strip()
            tranche_ = self.gds_validate_string(tranche_, node, 'tranche')
            self.tranche = tranche_
            # validate type Token
            self.validate_Token(self.tranche)
        super(Mortgage, self).buildChildren(child_, node, nodeName_, True)
# end class Mortgage


class Loan(UnderlyingAsset):
    """A type describing a loan underlying asset.Specifies the borrower.
    There can be more than one borrower. It is meant to be used in
    the event that there is no Bloomberg Id or the Secured List
    isn't applicable."""
    member_data_items_ = {
        'borrower': MemberSpec_('borrower', 'LegalEntity', 1),
        'borrowerReference': MemberSpec_('borrowerReference', 'LegalEntityReference', 1),
        'lien': MemberSpec_('lien', 'Lien', 0),
        'facilityType': MemberSpec_('facilityType', 'FacilityType', 0),
        'maturity': MemberSpec_('maturity', 'xsd:date', 0),
        'creditAgreementDate': MemberSpec_('creditAgreementDate', 'xsd:date', 0),
        'tranche': MemberSpec_('tranche', 'UnderlyingAssetTranche', 0),
    }
    subclass = None
    superclass = UnderlyingAsset
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, borrower=None, borrowerReference=None, lien=None, facilityType=None, maturity=None, creditAgreementDate=None, tranche=None):
        self.original_tagname_ = None
        super(Loan, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, )
        if borrower is None:
            self.borrower = []
        else:
            self.borrower = borrower
        if borrowerReference is None:
            self.borrowerReference = []
        else:
            self.borrowerReference = borrowerReference
        self.lien = lien
        self.facilityType = facilityType
        if isinstance(maturity, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(maturity, '%Y-%m-%d').date()
        else:
            initvalue_ = maturity
        self.maturity = initvalue_
        if isinstance(creditAgreementDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(creditAgreementDate, '%Y-%m-%d').date()
        else:
            initvalue_ = creditAgreementDate
        self.creditAgreementDate = initvalue_
        self.tranche = tranche
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Loan)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Loan.subclass:
            return Loan.subclass(*args_, **kwargs_)
        else:
            return Loan(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_borrower(self): return self.borrower
    def set_borrower(self, borrower): self.borrower = borrower
    def add_borrower(self, value): self.borrower.append(value)
    def insert_borrower_at(self, index, value): self.borrower.insert(index, value)
    def replace_borrower_at(self, index, value): self.borrower[index] = value
    def get_borrowerReference(self): return self.borrowerReference
    def set_borrowerReference(self, borrowerReference): self.borrowerReference = borrowerReference
    def add_borrowerReference(self, value): self.borrowerReference.append(value)
    def insert_borrowerReference_at(self, index, value): self.borrowerReference.insert(index, value)
    def replace_borrowerReference_at(self, index, value): self.borrowerReference[index] = value
    def get_lien(self): return self.lien
    def set_lien(self, lien): self.lien = lien
    def get_facilityType(self): return self.facilityType
    def set_facilityType(self, facilityType): self.facilityType = facilityType
    def get_maturity(self): return self.maturity
    def set_maturity(self, maturity): self.maturity = maturity
    def get_creditAgreementDate(self): return self.creditAgreementDate
    def set_creditAgreementDate(self, creditAgreementDate): self.creditAgreementDate = creditAgreementDate
    def get_tranche(self): return self.tranche
    def set_tranche(self, tranche): self.tranche = tranche
    def hasContent_(self):
        if (
            self.borrower or
            self.borrowerReference or
            self.lien is not None or
            self.facilityType is not None or
            self.maturity is not None or
            self.creditAgreementDate is not None or
            self.tranche is not None or
            super(Loan, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Loan', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Loan')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Loan', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Loan'):
        super(Loan, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Loan')
    def exportChildren(self, outfile, level, namespace_='', name_='Loan', fromsubclass_=False, pretty_print=True):
        super(Loan, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for borrower_ in self.borrower:
            borrower_.export(outfile, level, namespace_, name_='borrower', pretty_print=pretty_print)
        for borrowerReference_ in self.borrowerReference:
            borrowerReference_.export(outfile, level, namespace_, name_='borrowerReference', pretty_print=pretty_print)
        if self.lien is not None:
            self.lien.export(outfile, level, namespace_, name_='lien', pretty_print=pretty_print)
        if self.facilityType is not None:
            self.facilityType.export(outfile, level, namespace_, name_='facilityType', pretty_print=pretty_print)
        if self.maturity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaturity>%s</%smaturity>%s' % (namespace_, self.gds_format_date(self.maturity, input_name='maturity'), namespace_, eol_))
        if self.creditAgreementDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%screditAgreementDate>%s</%screditAgreementDate>%s' % (namespace_, self.gds_format_date(self.creditAgreementDate, input_name='creditAgreementDate'), namespace_, eol_))
        if self.tranche is not None:
            self.tranche.export(outfile, level, namespace_, name_='tranche', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Loan, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'borrower':
            obj_ = LegalEntity.factory()
            obj_.build(child_)
            self.borrower.append(obj_)
            obj_.original_tagname_ = 'borrower'
        elif nodeName_ == 'borrowerReference':
            obj_ = LegalEntityReference.factory()
            obj_.build(child_)
            self.borrowerReference.append(obj_)
            obj_.original_tagname_ = 'borrowerReference'
        elif nodeName_ == 'lien':
            obj_ = Lien.factory()
            obj_.build(child_)
            self.lien = obj_
            obj_.original_tagname_ = 'lien'
        elif nodeName_ == 'facilityType':
            obj_ = FacilityType.factory()
            obj_.build(child_)
            self.facilityType = obj_
            obj_.original_tagname_ = 'facilityType'
        elif nodeName_ == 'maturity':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.maturity = dval_
        elif nodeName_ == 'creditAgreementDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.creditAgreementDate = dval_
        elif nodeName_ == 'tranche':
            obj_ = UnderlyingAssetTranche.factory()
            obj_.build(child_)
            self.tranche = obj_
            obj_.original_tagname_ = 'tranche'
        super(Loan, self).buildChildren(child_, node, nodeName_, True)
# end class Loan


class FxRateAsset(UnderlyingAsset):
    member_data_items_ = {
        'quotedCurrencyPair': MemberSpec_('quotedCurrencyPair', 'QuotedCurrencyPair', 0),
        'rateSource': MemberSpec_('rateSource', 'FxSpotRateSource', 0),
    }
    subclass = None
    superclass = UnderlyingAsset
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, quotedCurrencyPair=None, rateSource=None):
        self.original_tagname_ = None
        super(FxRateAsset, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, )
        self.quotedCurrencyPair = quotedCurrencyPair
        self.rateSource = rateSource
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FxRateAsset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FxRateAsset.subclass:
            return FxRateAsset.subclass(*args_, **kwargs_)
        else:
            return FxRateAsset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_quotedCurrencyPair(self): return self.quotedCurrencyPair
    def set_quotedCurrencyPair(self, quotedCurrencyPair): self.quotedCurrencyPair = quotedCurrencyPair
    def get_rateSource(self): return self.rateSource
    def set_rateSource(self, rateSource): self.rateSource = rateSource
    def hasContent_(self):
        if (
            self.quotedCurrencyPair is not None or
            self.rateSource is not None or
            super(FxRateAsset, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FxRateAsset', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FxRateAsset')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FxRateAsset', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FxRateAsset'):
        super(FxRateAsset, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FxRateAsset')
    def exportChildren(self, outfile, level, namespace_='', name_='FxRateAsset', fromsubclass_=False, pretty_print=True):
        super(FxRateAsset, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.quotedCurrencyPair is not None:
            self.quotedCurrencyPair.export(outfile, level, namespace_, name_='quotedCurrencyPair', pretty_print=pretty_print)
        if self.rateSource is not None:
            self.rateSource.export(outfile, level, namespace_, name_='rateSource', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FxRateAsset, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'quotedCurrencyPair':
            obj_ = QuotedCurrencyPair.factory()
            obj_.build(child_)
            self.quotedCurrencyPair = obj_
            obj_.original_tagname_ = 'quotedCurrencyPair'
        elif nodeName_ == 'rateSource':
            obj_ = FxSpotRateSource.factory()
            obj_.build(child_)
            self.rateSource = obj_
            obj_.original_tagname_ = 'rateSource'
        super(FxRateAsset, self).buildChildren(child_, node, nodeName_, True)
# end class FxRateAsset


class ExchangeTraded(UnderlyingAsset):
    """An abstract base class for all exchange traded financial products."""
    member_data_items_ = {
        'relatedExchangeId': MemberSpec_('relatedExchangeId', 'ExchangeId', 1),
        'optionsExchangeId': MemberSpec_('optionsExchangeId', 'ExchangeId', 1),
        'specifiedExchangeId': MemberSpec_('specifiedExchangeId', 'ExchangeId', 1),
    }
    subclass = None
    superclass = UnderlyingAsset
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, relatedExchangeId=None, optionsExchangeId=None, specifiedExchangeId=None, extensiontype_=None):
        self.original_tagname_ = None
        super(ExchangeTraded, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, extensiontype_, )
        if relatedExchangeId is None:
            self.relatedExchangeId = []
        else:
            self.relatedExchangeId = relatedExchangeId
        if optionsExchangeId is None:
            self.optionsExchangeId = []
        else:
            self.optionsExchangeId = optionsExchangeId
        if specifiedExchangeId is None:
            self.specifiedExchangeId = []
        else:
            self.specifiedExchangeId = specifiedExchangeId
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExchangeTraded)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExchangeTraded.subclass:
            return ExchangeTraded.subclass(*args_, **kwargs_)
        else:
            return ExchangeTraded(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_relatedExchangeId(self): return self.relatedExchangeId
    def set_relatedExchangeId(self, relatedExchangeId): self.relatedExchangeId = relatedExchangeId
    def add_relatedExchangeId(self, value): self.relatedExchangeId.append(value)
    def insert_relatedExchangeId_at(self, index, value): self.relatedExchangeId.insert(index, value)
    def replace_relatedExchangeId_at(self, index, value): self.relatedExchangeId[index] = value
    def get_optionsExchangeId(self): return self.optionsExchangeId
    def set_optionsExchangeId(self, optionsExchangeId): self.optionsExchangeId = optionsExchangeId
    def add_optionsExchangeId(self, value): self.optionsExchangeId.append(value)
    def insert_optionsExchangeId_at(self, index, value): self.optionsExchangeId.insert(index, value)
    def replace_optionsExchangeId_at(self, index, value): self.optionsExchangeId[index] = value
    def get_specifiedExchangeId(self): return self.specifiedExchangeId
    def set_specifiedExchangeId(self, specifiedExchangeId): self.specifiedExchangeId = specifiedExchangeId
    def add_specifiedExchangeId(self, value): self.specifiedExchangeId.append(value)
    def insert_specifiedExchangeId_at(self, index, value): self.specifiedExchangeId.insert(index, value)
    def replace_specifiedExchangeId_at(self, index, value): self.specifiedExchangeId[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.relatedExchangeId or
            self.optionsExchangeId or
            self.specifiedExchangeId or
            super(ExchangeTraded, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExchangeTraded', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExchangeTraded')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExchangeTraded', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExchangeTraded'):
        super(ExchangeTraded, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ExchangeTraded')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='ExchangeTraded', fromsubclass_=False, pretty_print=True):
        super(ExchangeTraded, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for relatedExchangeId_ in self.relatedExchangeId:
            relatedExchangeId_.export(outfile, level, namespace_, name_='relatedExchangeId', pretty_print=pretty_print)
        for optionsExchangeId_ in self.optionsExchangeId:
            optionsExchangeId_.export(outfile, level, namespace_, name_='optionsExchangeId', pretty_print=pretty_print)
        for specifiedExchangeId_ in self.specifiedExchangeId:
            specifiedExchangeId_.export(outfile, level, namespace_, name_='specifiedExchangeId', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ExchangeTraded, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'relatedExchangeId':
            obj_ = ExchangeId.factory()
            obj_.build(child_)
            self.relatedExchangeId.append(obj_)
            obj_.original_tagname_ = 'relatedExchangeId'
        elif nodeName_ == 'optionsExchangeId':
            obj_ = ExchangeId.factory()
            obj_.build(child_)
            self.optionsExchangeId.append(obj_)
            obj_.original_tagname_ = 'optionsExchangeId'
        elif nodeName_ == 'specifiedExchangeId':
            obj_ = ExchangeId.factory()
            obj_.build(child_)
            self.specifiedExchangeId.append(obj_)
            obj_.original_tagname_ = 'specifiedExchangeId'
        super(ExchangeTraded, self).buildChildren(child_, node, nodeName_, True)
# end class ExchangeTraded


class EquityAsset(ExchangeTraded):
    """An exchange traded equity asset."""
    member_data_items_ = {
    }
    subclass = None
    superclass = ExchangeTraded
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, relatedExchangeId=None, optionsExchangeId=None, specifiedExchangeId=None):
        self.original_tagname_ = None
        super(EquityAsset, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, relatedExchangeId, optionsExchangeId, specifiedExchangeId, )
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EquityAsset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EquityAsset.subclass:
            return EquityAsset.subclass(*args_, **kwargs_)
        else:
            return EquityAsset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(EquityAsset, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EquityAsset', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EquityAsset')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EquityAsset', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EquityAsset'):
        super(EquityAsset, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EquityAsset')
    def exportChildren(self, outfile, level, namespace_='', name_='EquityAsset', fromsubclass_=False, pretty_print=True):
        super(EquityAsset, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EquityAsset, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(EquityAsset, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class EquityAsset


class Deposit(UnderlyingAsset):
    member_data_items_ = {
        'term': MemberSpec_('term', 'Period', 0),
        'paymentFrequency': MemberSpec_('paymentFrequency', 'Period', 0),
        'dayCountFraction': MemberSpec_('dayCountFraction', 'DayCountFraction', 0),
    }
    subclass = None
    superclass = UnderlyingAsset
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, term=None, paymentFrequency=None, dayCountFraction=None):
        self.original_tagname_ = None
        super(Deposit, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, )
        self.term = term
        self.paymentFrequency = paymentFrequency
        self.dayCountFraction = dayCountFraction
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Deposit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Deposit.subclass:
            return Deposit.subclass(*args_, **kwargs_)
        else:
            return Deposit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_term(self): return self.term
    def set_term(self, term): self.term = term
    def get_paymentFrequency(self): return self.paymentFrequency
    def set_paymentFrequency(self, paymentFrequency): self.paymentFrequency = paymentFrequency
    def get_dayCountFraction(self): return self.dayCountFraction
    def set_dayCountFraction(self, dayCountFraction): self.dayCountFraction = dayCountFraction
    def hasContent_(self):
        if (
            self.term is not None or
            self.paymentFrequency is not None or
            self.dayCountFraction is not None or
            super(Deposit, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Deposit', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Deposit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Deposit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Deposit'):
        super(Deposit, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Deposit')
    def exportChildren(self, outfile, level, namespace_='', name_='Deposit', fromsubclass_=False, pretty_print=True):
        super(Deposit, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.term is not None:
            self.term.export(outfile, level, namespace_, name_='term', pretty_print=pretty_print)
        if self.paymentFrequency is not None:
            self.paymentFrequency.export(outfile, level, namespace_, name_='paymentFrequency', pretty_print=pretty_print)
        if self.dayCountFraction is not None:
            self.dayCountFraction.export(outfile, level, namespace_, name_='dayCountFraction', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Deposit, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'term':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.term = obj_
            obj_.original_tagname_ = 'term'
        elif nodeName_ == 'paymentFrequency':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.paymentFrequency = obj_
            obj_.original_tagname_ = 'paymentFrequency'
        elif nodeName_ == 'dayCountFraction':
            obj_ = DayCountFraction.factory()
            obj_.build(child_)
            self.dayCountFraction = obj_
            obj_.original_tagname_ = 'dayCountFraction'
        super(Deposit, self).buildChildren(child_, node, nodeName_, True)
# end class Deposit


class Commodity(IdentifiedAsset):
    """A type describing a commodity underlying asset."""
    member_data_items_ = {
        'commodityBase': MemberSpec_('commodityBase', 'CommodityBase', 0),
        'commodityDetails': MemberSpec_('commodityDetails', 'CommodityDetails', 0),
        'unit': MemberSpec_('unit', 'QuantityUnit', 0),
        'currency': MemberSpec_('currency', 'Currency', 0),
        'exchangeId': MemberSpec_('exchangeId', 'ExchangeId', 0),
        'publication': MemberSpec_('publication', 'CommodityInformationSource', 0),
        'specifiedPrice': MemberSpec_('specifiedPrice', ['SpecifiedPriceEnum', 'Token', 'xsd:token'], 0),
        'deliveryDates': MemberSpec_('deliveryDates', ['DeliveryDatesEnum', 'Token', 'xsd:token'], 0),
        'deliveryNearby': MemberSpec_('deliveryNearby', 'DeliveryNearby', 0),
        'deliveryDate': MemberSpec_('deliveryDate', 'AdjustableDate', 0),
        'deliveryDateYearMonth': MemberSpec_('deliveryDateYearMonth', 'xsd:gYearMonth', 0),
        'deliveryDateRollConvention': MemberSpec_('deliveryDateRollConvention', 'Offset', 0),
        'deliveryDateExpirationConvention': MemberSpec_('deliveryDateExpirationConvention', 'Offset', 0),
        'multiplier': MemberSpec_('multiplier', ['PositiveDecimal', 'xsd:decimal'], 0),
    }
    subclass = None
    superclass = IdentifiedAsset
    def __init__(self, id=None, instrumentId=None, description=None, commodityBase=None, commodityDetails=None, unit=None, currency=None, exchangeId=None, publication=None, specifiedPrice=None, deliveryDates=None, deliveryNearby=None, deliveryDate=None, deliveryDateYearMonth=None, deliveryDateRollConvention=None, deliveryDateExpirationConvention=None, multiplier=None):
        self.original_tagname_ = None
        super(Commodity, self).__init__(id, instrumentId, description, )
        self.commodityBase = commodityBase
        self.commodityDetails = commodityDetails
        self.unit = unit
        self.currency = currency
        self.exchangeId = exchangeId
        self.publication = publication
        self.specifiedPrice = specifiedPrice
        self.validate_SpecifiedPriceEnum(self.specifiedPrice)
        self.deliveryDates = deliveryDates
        self.validate_DeliveryDatesEnum(self.deliveryDates)
        self.deliveryNearby = deliveryNearby
        self.deliveryDate = deliveryDate
        self.deliveryDateYearMonth = deliveryDateYearMonth
        self.deliveryDateRollConvention = deliveryDateRollConvention
        self.deliveryDateExpirationConvention = deliveryDateExpirationConvention
        self.multiplier = multiplier
        self.validate_PositiveDecimal(self.multiplier)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Commodity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Commodity.subclass:
            return Commodity.subclass(*args_, **kwargs_)
        else:
            return Commodity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commodityBase(self): return self.commodityBase
    def set_commodityBase(self, commodityBase): self.commodityBase = commodityBase
    def get_commodityDetails(self): return self.commodityDetails
    def set_commodityDetails(self, commodityDetails): self.commodityDetails = commodityDetails
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_exchangeId(self): return self.exchangeId
    def set_exchangeId(self, exchangeId): self.exchangeId = exchangeId
    def get_publication(self): return self.publication
    def set_publication(self, publication): self.publication = publication
    def get_specifiedPrice(self): return self.specifiedPrice
    def set_specifiedPrice(self, specifiedPrice): self.specifiedPrice = specifiedPrice
    def get_deliveryDates(self): return self.deliveryDates
    def set_deliveryDates(self, deliveryDates): self.deliveryDates = deliveryDates
    def get_deliveryNearby(self): return self.deliveryNearby
    def set_deliveryNearby(self, deliveryNearby): self.deliveryNearby = deliveryNearby
    def get_deliveryDate(self): return self.deliveryDate
    def set_deliveryDate(self, deliveryDate): self.deliveryDate = deliveryDate
    def get_deliveryDateYearMonth(self): return self.deliveryDateYearMonth
    def set_deliveryDateYearMonth(self, deliveryDateYearMonth): self.deliveryDateYearMonth = deliveryDateYearMonth
    def get_deliveryDateRollConvention(self): return self.deliveryDateRollConvention
    def set_deliveryDateRollConvention(self, deliveryDateRollConvention): self.deliveryDateRollConvention = deliveryDateRollConvention
    def get_deliveryDateExpirationConvention(self): return self.deliveryDateExpirationConvention
    def set_deliveryDateExpirationConvention(self, deliveryDateExpirationConvention): self.deliveryDateExpirationConvention = deliveryDateExpirationConvention
    def get_multiplier(self): return self.multiplier
    def set_multiplier(self, multiplier): self.multiplier = multiplier
    def validate_SpecifiedPriceEnum(self, value):
        # Validate type SpecifiedPriceEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Afternoon', 'Ask', 'Bid', 'Closing', 'High', 'Index', 'MeanOfBidAndAsk', 'LocationalMarginal', 'Low', 'MarginalHourly', 'MarketClearing', 'MeanOfHighAndLow', 'Morning', 'Official', 'Opening', 'OSP', 'Settlement', 'Spot', 'Midpoint', 'NationalSingle', 'WeightedAverage', 'UnWeightedAverage']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SpecifiedPriceEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on SpecifiedPriceEnum' % {"value" : value} )
    def validate_DeliveryDatesEnum(self, value):
        # Validate type DeliveryDatesEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CalculationPeriod', 'FirstNearby', 'SecondNearby', 'ThirdNearby', 'FourthNearby', 'FifthNearby', 'SixthNearby', 'SeventhNearby', 'EighthNearby', 'NinthNearby', 'TenthNearby', 'EleventhNearby', 'TwelfthNearby', 'ThirteenthNearby', 'FourteenthNearby', 'FifteenthNearby', 'SixteenthNearby', 'SeventeenthNearby', 'EighteenthNearby', 'NineteenthNearby', 'TwentiethNearby', 'TwentyFirstNearby', 'TwentySecondNearby', 'TwentyThirdNearby', 'TwentyFourthNearby', 'TwentyFifthNearby', 'TwentySixthNearby', 'TwentySeventhNearby', 'TwentyEighthNearby', 'TwentyNinthNearby', 'ThirtiethNearby', 'ThirtyFirstNearby', 'ThirtySecondNearby', 'ThirtyThirdNearby', 'ThirtyFourthNearby', 'ThirtyFifthNearby', 'ThirtySixthNearby', 'ThirtySeventhNearby', 'ThirtyEighthNearby', 'ThirtyNinthNearby', 'FortiethNearby', 'FortyFirstNearby', 'FortySecondNearby', 'FortyThirdNearby', 'FortyFourthNearby', 'FortyFifthNearby', 'FortySixthNearby', 'FortySeventhNearby', 'FortyEighthNearby', 'FortyNinthNearby', 'FiftiethNearby', 'FiftyFirstNearby', 'FiftySecondNearby', 'FiftyThirdNearby', 'FiftyFourthNearby', 'FiftyFifthNearby', 'FiftySixthNearby', 'FiftySeventhNearby', 'FiftyEighthNearby', 'FiftyNinthNearby', 'Spot', 'FirstNearbyWeek', 'SecondNearbyWeek', 'ThirdNearbyWeek', 'FourthNearbyWeek', 'FifthNearbyWeek', 'SixthNearbyWeek', 'SeventhNearbyWeek', 'EighthNearbyWeek', 'NinthNearbyWeek', 'TenthNearbyWeek', 'EleventhNearbyWeek', 'TwelfthNearbyWeek', 'ThirteenthNearbyWeek', 'FourteenthNearbyWeek', 'FifteenthNearbyWeek', 'SixteenthNearbyWeek', 'SeventeenthNearbyWeek', 'EighteenthNearbyWeek', 'NineteenthNearbyWeek', 'TwentiethNearbyWeek', 'TwentyFirstNearbyWeek', 'TwentySecondNearbyWeek', 'TwentyThirdNearbyWeek', 'TwentyFourthearbyWeek', 'TwentyFifthNearbyWeek', 'TwentySixthNearbyWeek', 'TwentySeventhNearbyWeek', 'TwentyEighthNearbyWeek', 'TwentyNinthNearbyWeek', 'ThirtiethNearbyWeek', 'ThirtyFirstNearbyWeek', 'ThirtySecondNearbyWeek', 'ThirtyThirdNearbyWeek', 'ThirtyFourthNearbyWeek', 'ThirtyFifthNearbyWeek', 'ThirtySixthNearbyWeek', 'ThirtySeventhNearbyWeek', 'ThirtyEighthNearbyWeek', 'ThirtyNinthNearbyWeek', 'FortiethNearbyWeek', 'FortyFirstNearbyWeek', 'FortySecondNearbyWeek', 'FortyThirdNearbyWeek', 'FortyFourthNearbyWeek', 'FortyFifthNearbyWeek', 'FortySixthNearbyWeek', 'FortySeventhNearbyWeek', 'FortyEighthNearbyWeek', 'FortyNinthNearbyWeek', 'FiftiethNearbyWeek', 'FiftyFirstNearbyWeek', 'FiftySecondNearbyWeek']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeliveryDatesEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on DeliveryDatesEnum' % {"value" : value} )
    def validate_PositiveDecimal(self, value):
        # Validate type PositiveDecimal, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value <= 0:
                warnings_.warn('Value "%(value)s" does not match xsd minExclusive restriction on PositiveDecimal' % {"value" : value} )
    def hasContent_(self):
        if (
            self.commodityBase is not None or
            self.commodityDetails is not None or
            self.unit is not None or
            self.currency is not None or
            self.exchangeId is not None or
            self.publication is not None or
            self.specifiedPrice is not None or
            self.deliveryDates is not None or
            self.deliveryNearby is not None or
            self.deliveryDate is not None or
            self.deliveryDateYearMonth is not None or
            self.deliveryDateRollConvention is not None or
            self.deliveryDateExpirationConvention is not None or
            self.multiplier is not None or
            super(Commodity, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Commodity', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Commodity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Commodity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Commodity'):
        super(Commodity, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Commodity')
    def exportChildren(self, outfile, level, namespace_='', name_='Commodity', fromsubclass_=False, pretty_print=True):
        super(Commodity, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.commodityBase is not None:
            self.commodityBase.export(outfile, level, namespace_, name_='commodityBase', pretty_print=pretty_print)
        if self.commodityDetails is not None:
            self.commodityDetails.export(outfile, level, namespace_, name_='commodityDetails', pretty_print=pretty_print)
        if self.unit is not None:
            self.unit.export(outfile, level, namespace_, name_='unit', pretty_print=pretty_print)
        if self.currency is not None:
            self.currency.export(outfile, level, namespace_, name_='currency', pretty_print=pretty_print)
        if self.exchangeId is not None:
            self.exchangeId.export(outfile, level, namespace_, name_='exchangeId', pretty_print=pretty_print)
        if self.publication is not None:
            self.publication.export(outfile, level, namespace_, name_='publication', pretty_print=pretty_print)
        if self.specifiedPrice is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sspecifiedPrice>%s</%sspecifiedPrice>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.specifiedPrice), input_name='specifiedPrice')), namespace_, eol_))
        if self.deliveryDates is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdeliveryDates>%s</%sdeliveryDates>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.deliveryDates), input_name='deliveryDates')), namespace_, eol_))
        if self.deliveryNearby is not None:
            self.deliveryNearby.export(outfile, level, namespace_, name_='deliveryNearby', pretty_print=pretty_print)
        if self.deliveryDate is not None:
            self.deliveryDate.export(outfile, level, namespace_, name_='deliveryDate', pretty_print=pretty_print)
        if self.deliveryDateYearMonth is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdeliveryDateYearMonth>%s</%sdeliveryDateYearMonth>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.deliveryDateYearMonth), input_name='deliveryDateYearMonth')), namespace_, eol_))
        if self.deliveryDateRollConvention is not None:
            self.deliveryDateRollConvention.export(outfile, level, namespace_, name_='deliveryDateRollConvention', pretty_print=pretty_print)
        if self.deliveryDateExpirationConvention is not None:
            self.deliveryDateExpirationConvention.export(outfile, level, namespace_, name_='deliveryDateExpirationConvention', pretty_print=pretty_print)
        if self.multiplier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smultiplier>%s</%smultiplier>%s' % (namespace_, self.gds_format_float(self.multiplier, input_name='multiplier'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Commodity, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'commodityBase':
            obj_ = CommodityBase.factory()
            obj_.build(child_)
            self.commodityBase = obj_
            obj_.original_tagname_ = 'commodityBase'
        elif nodeName_ == 'commodityDetails':
            obj_ = CommodityDetails.factory()
            obj_.build(child_)
            self.commodityDetails = obj_
            obj_.original_tagname_ = 'commodityDetails'
        elif nodeName_ == 'unit':
            obj_ = QuantityUnit.factory()
            obj_.build(child_)
            self.unit = obj_
            obj_.original_tagname_ = 'unit'
        elif nodeName_ == 'currency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'exchangeId':
            obj_ = ExchangeId.factory()
            obj_.build(child_)
            self.exchangeId = obj_
            obj_.original_tagname_ = 'exchangeId'
        elif nodeName_ == 'publication':
            obj_ = CommodityInformationSource.factory()
            obj_.build(child_)
            self.publication = obj_
            obj_.original_tagname_ = 'publication'
        elif nodeName_ == 'specifiedPrice':
            specifiedPrice_ = child_.text
            specifiedPrice_ = re_.sub(String_cleanup_pat_, " ", specifiedPrice_).strip()
            specifiedPrice_ = self.gds_validate_string(specifiedPrice_, node, 'specifiedPrice')
            self.specifiedPrice = specifiedPrice_
            # validate type SpecifiedPriceEnum
            self.validate_SpecifiedPriceEnum(self.specifiedPrice)
        elif nodeName_ == 'deliveryDates':
            deliveryDates_ = child_.text
            deliveryDates_ = re_.sub(String_cleanup_pat_, " ", deliveryDates_).strip()
            deliveryDates_ = self.gds_validate_string(deliveryDates_, node, 'deliveryDates')
            self.deliveryDates = deliveryDates_
            # validate type DeliveryDatesEnum
            self.validate_DeliveryDatesEnum(self.deliveryDates)
        elif nodeName_ == 'deliveryNearby':
            obj_ = DeliveryNearby.factory()
            obj_.build(child_)
            self.deliveryNearby = obj_
            obj_.original_tagname_ = 'deliveryNearby'
        elif nodeName_ == 'deliveryDate':
            obj_ = AdjustableDate.factory()
            obj_.build(child_)
            self.deliveryDate = obj_
            obj_.original_tagname_ = 'deliveryDate'
        elif nodeName_ == 'deliveryDateYearMonth':
            deliveryDateYearMonth_ = child_.text
            deliveryDateYearMonth_ = self.gds_validate_string(deliveryDateYearMonth_, node, 'deliveryDateYearMonth')
            self.deliveryDateYearMonth = deliveryDateYearMonth_
        elif nodeName_ == 'deliveryDateRollConvention':
            class_obj_ = self.get_class_obj_(child_, Offset)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.deliveryDateRollConvention = obj_
            obj_.original_tagname_ = 'deliveryDateRollConvention'
        elif nodeName_ == 'deliveryDateExpirationConvention':
            class_obj_ = self.get_class_obj_(child_, Offset)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.deliveryDateExpirationConvention = obj_
            obj_.original_tagname_ = 'deliveryDateExpirationConvention'
        elif nodeName_ == 'multiplier':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'multiplier')
            self.multiplier = fval_
            # validate type PositiveDecimal
            self.validate_PositiveDecimal(self.multiplier)
        super(Commodity, self).buildChildren(child_, node, nodeName_, True)
# end class Commodity


class Bond(UnderlyingAsset):
    """An exchange traded bond.Specifies the issuer name of a fixed income
    security or convertible bond. This name can either be explicitly
    stated, or specified as an href into another element of the
    document, such as the obligor."""
    member_data_items_ = {
        'issuerName': MemberSpec_('issuerName', ['String', 'xsd:string'], 0),
        'issuerPartyReference': MemberSpec_('issuerPartyReference', 'PartyReference', 0),
        'seniority': MemberSpec_('seniority', 'CreditSeniority', 0),
        'couponType': MemberSpec_('couponType', 'CouponType', 0),
        'couponRate': MemberSpec_('couponRate', 'xsd:decimal', 0),
        'maturity': MemberSpec_('maturity', 'xsd:date', 0),
        'parValue': MemberSpec_('parValue', 'xsd:decimal', 0),
        'faceAmount': MemberSpec_('faceAmount', 'xsd:decimal', 0),
        'paymentFrequency': MemberSpec_('paymentFrequency', 'Period', 0),
        'dayCountFraction': MemberSpec_('dayCountFraction', 'DayCountFraction', 0),
    }
    subclass = None
    superclass = UnderlyingAsset
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, issuerName=None, issuerPartyReference=None, seniority=None, couponType=None, couponRate=None, maturity=None, parValue=None, faceAmount=None, paymentFrequency=None, dayCountFraction=None, extensiontype_=None):
        self.original_tagname_ = None
        super(Bond, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, extensiontype_, )
        self.issuerName = issuerName
        self.validate_String(self.issuerName)
        self.issuerPartyReference = issuerPartyReference
        self.seniority = seniority
        self.couponType = couponType
        self.couponRate = couponRate
        if isinstance(maturity, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(maturity, '%Y-%m-%d').date()
        else:
            initvalue_ = maturity
        self.maturity = initvalue_
        self.parValue = parValue
        self.faceAmount = faceAmount
        self.paymentFrequency = paymentFrequency
        self.dayCountFraction = dayCountFraction
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Bond)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Bond.subclass:
            return Bond.subclass(*args_, **kwargs_)
        else:
            return Bond(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_issuerName(self): return self.issuerName
    def set_issuerName(self, issuerName): self.issuerName = issuerName
    def get_issuerPartyReference(self): return self.issuerPartyReference
    def set_issuerPartyReference(self, issuerPartyReference): self.issuerPartyReference = issuerPartyReference
    def get_seniority(self): return self.seniority
    def set_seniority(self, seniority): self.seniority = seniority
    def get_couponType(self): return self.couponType
    def set_couponType(self, couponType): self.couponType = couponType
    def get_couponRate(self): return self.couponRate
    def set_couponRate(self, couponRate): self.couponRate = couponRate
    def get_maturity(self): return self.maturity
    def set_maturity(self, maturity): self.maturity = maturity
    def get_parValue(self): return self.parValue
    def set_parValue(self, parValue): self.parValue = parValue
    def get_faceAmount(self): return self.faceAmount
    def set_faceAmount(self, faceAmount): self.faceAmount = faceAmount
    def get_paymentFrequency(self): return self.paymentFrequency
    def set_paymentFrequency(self, paymentFrequency): self.paymentFrequency = paymentFrequency
    def get_dayCountFraction(self): return self.dayCountFraction
    def set_dayCountFraction(self, dayCountFraction): self.dayCountFraction = dayCountFraction
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.issuerName is not None or
            self.issuerPartyReference is not None or
            self.seniority is not None or
            self.couponType is not None or
            self.couponRate is not None or
            self.maturity is not None or
            self.parValue is not None or
            self.faceAmount is not None or
            self.paymentFrequency is not None or
            self.dayCountFraction is not None or
            super(Bond, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Bond', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Bond')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Bond', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Bond'):
        super(Bond, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Bond')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Bond', fromsubclass_=False, pretty_print=True):
        super(Bond, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.issuerName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sissuerName>%s</%sissuerName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.issuerName), input_name='issuerName')), namespace_, eol_))
        if self.issuerPartyReference is not None:
            self.issuerPartyReference.export(outfile, level, namespace_, name_='issuerPartyReference', pretty_print=pretty_print)
        if self.seniority is not None:
            self.seniority.export(outfile, level, namespace_, name_='seniority', pretty_print=pretty_print)
        if self.couponType is not None:
            self.couponType.export(outfile, level, namespace_, name_='couponType', pretty_print=pretty_print)
        if self.couponRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scouponRate>%s</%scouponRate>%s' % (namespace_, self.gds_format_float(self.couponRate, input_name='couponRate'), namespace_, eol_))
        if self.maturity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaturity>%s</%smaturity>%s' % (namespace_, self.gds_format_date(self.maturity, input_name='maturity'), namespace_, eol_))
        if self.parValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sparValue>%s</%sparValue>%s' % (namespace_, self.gds_format_float(self.parValue, input_name='parValue'), namespace_, eol_))
        if self.faceAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfaceAmount>%s</%sfaceAmount>%s' % (namespace_, self.gds_format_float(self.faceAmount, input_name='faceAmount'), namespace_, eol_))
        if self.paymentFrequency is not None:
            self.paymentFrequency.export(outfile, level, namespace_, name_='paymentFrequency', pretty_print=pretty_print)
        if self.dayCountFraction is not None:
            self.dayCountFraction.export(outfile, level, namespace_, name_='dayCountFraction', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(Bond, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'issuerName':
            issuerName_ = child_.text
            issuerName_ = self.gds_validate_string(issuerName_, node, 'issuerName')
            self.issuerName = issuerName_
            # validate type String
            self.validate_String(self.issuerName)
        elif nodeName_ == 'issuerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.issuerPartyReference = obj_
            obj_.original_tagname_ = 'issuerPartyReference'
        elif nodeName_ == 'seniority':
            obj_ = CreditSeniority.factory()
            obj_.build(child_)
            self.seniority = obj_
            obj_.original_tagname_ = 'seniority'
        elif nodeName_ == 'couponType':
            obj_ = CouponType.factory()
            obj_.build(child_)
            self.couponType = obj_
            obj_.original_tagname_ = 'couponType'
        elif nodeName_ == 'couponRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'couponRate')
            self.couponRate = fval_
        elif nodeName_ == 'maturity':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.maturity = dval_
        elif nodeName_ == 'parValue':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'parValue')
            self.parValue = fval_
        elif nodeName_ == 'faceAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'faceAmount')
            self.faceAmount = fval_
        elif nodeName_ == 'paymentFrequency':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.paymentFrequency = obj_
            obj_.original_tagname_ = 'paymentFrequency'
        elif nodeName_ == 'dayCountFraction':
            obj_ = DayCountFraction.factory()
            obj_.build(child_)
            self.dayCountFraction = obj_
            obj_.original_tagname_ = 'dayCountFraction'
        super(Bond, self).buildChildren(child_, node, nodeName_, True)
# end class Bond


class AssetReference(Reference):
    """Reference to an underlying asset."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(AssetReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AssetReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AssetReference.subclass:
            return AssetReference.subclass(*args_, **kwargs_)
        else:
            return AssetReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(AssetReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AssetReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AssetReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AssetReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AssetReference'):
        super(AssetReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AssetReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AssetReference', fromsubclass_=False, pretty_print=True):
        super(AssetReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(AssetReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AssetReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AssetReference


class AnyAssetReference(Reference):
    """A reference to an asset, e.g. a portfolio, trade, or reference
    instrument.."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(AnyAssetReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnyAssetReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnyAssetReference.subclass:
            return AnyAssetReference.subclass(*args_, **kwargs_)
        else:
            return AnyAssetReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(AnyAssetReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AnyAssetReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnyAssetReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AnyAssetReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AnyAssetReference'):
        super(AnyAssetReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AnyAssetReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AnyAssetReference', fromsubclass_=False, pretty_print=True):
        super(AnyAssetReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(AnyAssetReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AnyAssetReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AnyAssetReference


class Premium(SimplePayment):
    """A type for defining a premium."""
    member_data_items_ = {
        'premiumType': MemberSpec_('premiumType', ['PremiumTypeEnum', 'Token', 'xsd:token'], 0),
        'pricePerOption': MemberSpec_('pricePerOption', 'Money', 0),
        'percentageOfNotional': MemberSpec_('percentageOfNotional', 'xsd:decimal', 0),
        'discountFactor': MemberSpec_('discountFactor', 'xsd:decimal', 0),
        'presentValueAmount': MemberSpec_('presentValueAmount', 'Money', 0),
    }
    subclass = None
    superclass = SimplePayment
    def __init__(self, id=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, paymentAmount=None, paymentDate=None, premiumType=None, pricePerOption=None, percentageOfNotional=None, discountFactor=None, presentValueAmount=None):
        self.original_tagname_ = None
        super(Premium, self).__init__(id, payerPartyReference, payerAccountReference, receiverPartyReference, receiverAccountReference, paymentAmount, paymentDate, )
        self.premiumType = premiumType
        self.validate_PremiumTypeEnum(self.premiumType)
        self.pricePerOption = pricePerOption
        self.percentageOfNotional = percentageOfNotional
        self.discountFactor = discountFactor
        self.presentValueAmount = presentValueAmount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Premium)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Premium.subclass:
            return Premium.subclass(*args_, **kwargs_)
        else:
            return Premium(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_premiumType(self): return self.premiumType
    def set_premiumType(self, premiumType): self.premiumType = premiumType
    def get_pricePerOption(self): return self.pricePerOption
    def set_pricePerOption(self, pricePerOption): self.pricePerOption = pricePerOption
    def get_percentageOfNotional(self): return self.percentageOfNotional
    def set_percentageOfNotional(self, percentageOfNotional): self.percentageOfNotional = percentageOfNotional
    def get_discountFactor(self): return self.discountFactor
    def set_discountFactor(self, discountFactor): self.discountFactor = discountFactor
    def get_presentValueAmount(self): return self.presentValueAmount
    def set_presentValueAmount(self, presentValueAmount): self.presentValueAmount = presentValueAmount
    def validate_PremiumTypeEnum(self, value):
        # Validate type PremiumTypeEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['PrePaid', 'PostPaid', 'Variable', 'Fixed']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PremiumTypeEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on PremiumTypeEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.premiumType is not None or
            self.pricePerOption is not None or
            self.percentageOfNotional is not None or
            self.discountFactor is not None or
            self.presentValueAmount is not None or
            super(Premium, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Premium', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Premium')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Premium', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Premium'):
        super(Premium, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Premium')
    def exportChildren(self, outfile, level, namespace_='', name_='Premium', fromsubclass_=False, pretty_print=True):
        super(Premium, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.premiumType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spremiumType>%s</%spremiumType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.premiumType), input_name='premiumType')), namespace_, eol_))
        if self.pricePerOption is not None:
            self.pricePerOption.export(outfile, level, namespace_, name_='pricePerOption', pretty_print=pretty_print)
        if self.percentageOfNotional is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spercentageOfNotional>%s</%spercentageOfNotional>%s' % (namespace_, self.gds_format_float(self.percentageOfNotional, input_name='percentageOfNotional'), namespace_, eol_))
        if self.discountFactor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdiscountFactor>%s</%sdiscountFactor>%s' % (namespace_, self.gds_format_float(self.discountFactor, input_name='discountFactor'), namespace_, eol_))
        if self.presentValueAmount is not None:
            self.presentValueAmount.export(outfile, level, namespace_, name_='presentValueAmount', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Premium, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'premiumType':
            premiumType_ = child_.text
            premiumType_ = re_.sub(String_cleanup_pat_, " ", premiumType_).strip()
            premiumType_ = self.gds_validate_string(premiumType_, node, 'premiumType')
            self.premiumType = premiumType_
            # validate type PremiumTypeEnum
            self.validate_PremiumTypeEnum(self.premiumType)
        elif nodeName_ == 'pricePerOption':
            class_obj_ = self.get_class_obj_(child_, Money)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.pricePerOption = obj_
            obj_.original_tagname_ = 'pricePerOption'
        elif nodeName_ == 'percentageOfNotional':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'percentageOfNotional')
            self.percentageOfNotional = fval_
        elif nodeName_ == 'discountFactor':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'discountFactor')
            self.discountFactor = fval_
        elif nodeName_ == 'presentValueAmount':
            class_obj_ = self.get_class_obj_(child_, Money)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.presentValueAmount = obj_
            obj_.original_tagname_ = 'presentValueAmount'
        super(Premium, self).buildChildren(child_, node, nodeName_, True)
# end class Premium


class Option(Product):
    """A type for defining the common features of options. Buyer/seller
    information is not normally used in Transparency view but is
    optional in case the information is needed for administrative
    purposes such as Reporting Party determination."""
    member_data_items_ = {
        'buyerPartyReference': MemberSpec_('buyerPartyReference', 'PartyReference', 0),
        'buyerAccountReference': MemberSpec_('buyerAccountReference', 'AccountReference', 0),
        'sellerPartyReference': MemberSpec_('sellerPartyReference', 'PartyReference', 0),
        'sellerAccountReference': MemberSpec_('sellerAccountReference', 'AccountReference', 0),
    }
    subclass = None
    superclass = Product
    def __init__(self, id=None, primaryAssetClass=None, secondaryAssetClass=None, productType=None, productId=None, assetClass=None, embeddedOptionType=None, buyerPartyReference=None, buyerAccountReference=None, sellerPartyReference=None, sellerAccountReference=None, extensiontype_=None):
        self.original_tagname_ = None
        super(Option, self).__init__(id, primaryAssetClass, secondaryAssetClass, productType, productId, assetClass, embeddedOptionType, extensiontype_, )
        self.buyerPartyReference = buyerPartyReference
        self.buyerAccountReference = buyerAccountReference
        self.sellerPartyReference = sellerPartyReference
        self.sellerAccountReference = sellerAccountReference
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Option)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Option.subclass:
            return Option.subclass(*args_, **kwargs_)
        else:
            return Option(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_buyerPartyReference(self): return self.buyerPartyReference
    def set_buyerPartyReference(self, buyerPartyReference): self.buyerPartyReference = buyerPartyReference
    def get_buyerAccountReference(self): return self.buyerAccountReference
    def set_buyerAccountReference(self, buyerAccountReference): self.buyerAccountReference = buyerAccountReference
    def get_sellerPartyReference(self): return self.sellerPartyReference
    def set_sellerPartyReference(self, sellerPartyReference): self.sellerPartyReference = sellerPartyReference
    def get_sellerAccountReference(self): return self.sellerAccountReference
    def set_sellerAccountReference(self, sellerAccountReference): self.sellerAccountReference = sellerAccountReference
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.buyerPartyReference is not None or
            self.buyerAccountReference is not None or
            self.sellerPartyReference is not None or
            self.sellerAccountReference is not None or
            super(Option, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Option', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Option')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Option', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Option'):
        super(Option, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Option')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Option', fromsubclass_=False, pretty_print=True):
        super(Option, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.buyerPartyReference is not None:
            self.buyerPartyReference.export(outfile, level, namespace_, name_='buyerPartyReference', pretty_print=pretty_print)
        if self.buyerAccountReference is not None:
            self.buyerAccountReference.export(outfile, level, namespace_, name_='buyerAccountReference', pretty_print=pretty_print)
        if self.sellerPartyReference is not None:
            self.sellerPartyReference.export(outfile, level, namespace_, name_='sellerPartyReference', pretty_print=pretty_print)
        if self.sellerAccountReference is not None:
            self.sellerAccountReference.export(outfile, level, namespace_, name_='sellerAccountReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(Option, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'buyerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.buyerPartyReference = obj_
            obj_.original_tagname_ = 'buyerPartyReference'
        elif nodeName_ == 'buyerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.buyerAccountReference = obj_
            obj_.original_tagname_ = 'buyerAccountReference'
        elif nodeName_ == 'sellerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.sellerPartyReference = obj_
            obj_.original_tagname_ = 'sellerPartyReference'
        elif nodeName_ == 'sellerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.sellerAccountReference = obj_
            obj_.original_tagname_ = 'sellerAccountReference'
        super(Option, self).buildChildren(child_, node, nodeName_, True)
# end class Option


class FeaturePayment(PaymentBase):
    """Payment made following trigger occurence."""
    member_data_items_ = {
        'payerPartyReference': MemberSpec_('payerPartyReference', 'PartyReference', 0),
        'payerAccountReference': MemberSpec_('payerAccountReference', 'AccountReference', 0),
        'receiverPartyReference': MemberSpec_('receiverPartyReference', 'PartyReference', 0),
        'receiverAccountReference': MemberSpec_('receiverAccountReference', 'AccountReference', 0),
        'levelPercentage': MemberSpec_('levelPercentage', 'xsd:decimal', 0),
        'amount': MemberSpec_('amount', ['NonNegativeDecimal', 'xsd:decimal'], 0),
        'time': MemberSpec_('time', ['TimeTypeEnum', 'Token', 'xsd:token'], 0),
        'currency': MemberSpec_('currency', 'Currency', 0),
        'featurePaymentDate': MemberSpec_('featurePaymentDate', 'AdjustableOrRelativeDate', 0),
    }
    subclass = None
    superclass = PaymentBase
    def __init__(self, id=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, levelPercentage=None, amount=None, time=None, currency=None, featurePaymentDate=None):
        self.original_tagname_ = None
        super(FeaturePayment, self).__init__(id, )
        self.payerPartyReference = payerPartyReference
        self.payerAccountReference = payerAccountReference
        self.receiverPartyReference = receiverPartyReference
        self.receiverAccountReference = receiverAccountReference
        self.levelPercentage = levelPercentage
        self.amount = amount
        self.validate_NonNegativeDecimal(self.amount)
        self.time = time
        self.validate_TimeTypeEnum(self.time)
        self.currency = currency
        self.featurePaymentDate = featurePaymentDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FeaturePayment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FeaturePayment.subclass:
            return FeaturePayment.subclass(*args_, **kwargs_)
        else:
            return FeaturePayment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_payerPartyReference(self): return self.payerPartyReference
    def set_payerPartyReference(self, payerPartyReference): self.payerPartyReference = payerPartyReference
    def get_payerAccountReference(self): return self.payerAccountReference
    def set_payerAccountReference(self, payerAccountReference): self.payerAccountReference = payerAccountReference
    def get_receiverPartyReference(self): return self.receiverPartyReference
    def set_receiverPartyReference(self, receiverPartyReference): self.receiverPartyReference = receiverPartyReference
    def get_receiverAccountReference(self): return self.receiverAccountReference
    def set_receiverAccountReference(self, receiverAccountReference): self.receiverAccountReference = receiverAccountReference
    def get_levelPercentage(self): return self.levelPercentage
    def set_levelPercentage(self, levelPercentage): self.levelPercentage = levelPercentage
    def get_amount(self): return self.amount
    def set_amount(self, amount): self.amount = amount
    def get_time(self): return self.time
    def set_time(self, time): self.time = time
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_featurePaymentDate(self): return self.featurePaymentDate
    def set_featurePaymentDate(self, featurePaymentDate): self.featurePaymentDate = featurePaymentDate
    def validate_NonNegativeDecimal(self, value):
        # Validate type NonNegativeDecimal, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on NonNegativeDecimal' % {"value" : value} )
    def validate_TimeTypeEnum(self, value):
        # Validate type TimeTypeEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Close', 'Open', 'OSP', 'SpecificTime', 'XETRA', 'DerivativesClose', 'AsSpecifiedInMasterConfirmation']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TimeTypeEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on TimeTypeEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.payerPartyReference is not None or
            self.payerAccountReference is not None or
            self.receiverPartyReference is not None or
            self.receiverAccountReference is not None or
            self.levelPercentage is not None or
            self.amount is not None or
            self.time is not None or
            self.currency is not None or
            self.featurePaymentDate is not None or
            super(FeaturePayment, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FeaturePayment', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FeaturePayment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FeaturePayment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FeaturePayment'):
        super(FeaturePayment, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FeaturePayment')
    def exportChildren(self, outfile, level, namespace_='', name_='FeaturePayment', fromsubclass_=False, pretty_print=True):
        super(FeaturePayment, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.payerPartyReference is not None:
            self.payerPartyReference.export(outfile, level, namespace_, name_='payerPartyReference', pretty_print=pretty_print)
        if self.payerAccountReference is not None:
            self.payerAccountReference.export(outfile, level, namespace_, name_='payerAccountReference', pretty_print=pretty_print)
        if self.receiverPartyReference is not None:
            self.receiverPartyReference.export(outfile, level, namespace_, name_='receiverPartyReference', pretty_print=pretty_print)
        if self.receiverAccountReference is not None:
            self.receiverAccountReference.export(outfile, level, namespace_, name_='receiverAccountReference', pretty_print=pretty_print)
        if self.levelPercentage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slevelPercentage>%s</%slevelPercentage>%s' % (namespace_, self.gds_format_float(self.levelPercentage, input_name='levelPercentage'), namespace_, eol_))
        if self.amount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%samount>%s</%samount>%s' % (namespace_, self.gds_format_float(self.amount, input_name='amount'), namespace_, eol_))
        if self.time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stime>%s</%stime>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.time), input_name='time')), namespace_, eol_))
        if self.currency is not None:
            self.currency.export(outfile, level, namespace_, name_='currency', pretty_print=pretty_print)
        if self.featurePaymentDate is not None:
            self.featurePaymentDate.export(outfile, level, namespace_, name_='featurePaymentDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FeaturePayment, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'payerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.payerPartyReference = obj_
            obj_.original_tagname_ = 'payerPartyReference'
        elif nodeName_ == 'payerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.payerAccountReference = obj_
            obj_.original_tagname_ = 'payerAccountReference'
        elif nodeName_ == 'receiverPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.receiverPartyReference = obj_
            obj_.original_tagname_ = 'receiverPartyReference'
        elif nodeName_ == 'receiverAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.receiverAccountReference = obj_
            obj_.original_tagname_ = 'receiverAccountReference'
        elif nodeName_ == 'levelPercentage':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'levelPercentage')
            self.levelPercentage = fval_
        elif nodeName_ == 'amount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'amount')
            self.amount = fval_
            # validate type NonNegativeDecimal
            self.validate_NonNegativeDecimal(self.amount)
        elif nodeName_ == 'time':
            time_ = child_.text
            time_ = re_.sub(String_cleanup_pat_, " ", time_).strip()
            time_ = self.gds_validate_string(time_, node, 'time')
            self.time = time_
            # validate type TimeTypeEnum
            self.validate_TimeTypeEnum(self.time)
        elif nodeName_ == 'currency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'featurePaymentDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.featurePaymentDate = obj_
            obj_.original_tagname_ = 'featurePaymentDate'
        super(FeaturePayment, self).buildChildren(child_, node, nodeName_, True)
# end class FeaturePayment


class CreditEventsReference(Reference):
    """Reference to credit events."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(CreditEventsReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditEventsReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditEventsReference.subclass:
            return CreditEventsReference.subclass(*args_, **kwargs_)
        else:
            return CreditEventsReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(CreditEventsReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditEventsReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditEventsReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditEventsReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditEventsReference'):
        super(CreditEventsReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CreditEventsReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CreditEventsReference', fromsubclass_=False, pretty_print=True):
        super(CreditEventsReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(CreditEventsReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(CreditEventsReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CreditEventsReference


class ClassifiablePayment(NonNegativePayment):
    """A classified non negative payment."""
    member_data_items_ = {
        'paymentType': MemberSpec_('paymentType', 'PaymentType', 1),
    }
    subclass = None
    superclass = NonNegativePayment
    def __init__(self, id=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, paymentDate=None, paymentAmount=None, paymentType=None):
        self.original_tagname_ = None
        super(ClassifiablePayment, self).__init__(id, payerPartyReference, payerAccountReference, receiverPartyReference, receiverAccountReference, paymentDate, paymentAmount, )
        if paymentType is None:
            self.paymentType = []
        else:
            self.paymentType = paymentType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClassifiablePayment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClassifiablePayment.subclass:
            return ClassifiablePayment.subclass(*args_, **kwargs_)
        else:
            return ClassifiablePayment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_paymentType(self): return self.paymentType
    def set_paymentType(self, paymentType): self.paymentType = paymentType
    def add_paymentType(self, value): self.paymentType.append(value)
    def insert_paymentType_at(self, index, value): self.paymentType.insert(index, value)
    def replace_paymentType_at(self, index, value): self.paymentType[index] = value
    def hasContent_(self):
        if (
            self.paymentType or
            super(ClassifiablePayment, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ClassifiablePayment', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ClassifiablePayment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ClassifiablePayment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ClassifiablePayment'):
        super(ClassifiablePayment, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ClassifiablePayment')
    def exportChildren(self, outfile, level, namespace_='', name_='ClassifiablePayment', fromsubclass_=False, pretty_print=True):
        super(ClassifiablePayment, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for paymentType_ in self.paymentType:
            paymentType_.export(outfile, level, namespace_, name_='paymentType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ClassifiablePayment, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'paymentType':
            obj_ = PaymentType.factory()
            obj_.build(child_)
            self.paymentType.append(obj_)
            obj_.original_tagname_ = 'paymentType'
        super(ClassifiablePayment, self).buildChildren(child_, node, nodeName_, True)
# end class ClassifiablePayment


class StrikePriceUnderlyingReference(Reference):
    """A pointer style reference to a product leg in the document"""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(StrikePriceUnderlyingReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrikePriceUnderlyingReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrikePriceUnderlyingReference.subclass:
            return StrikePriceUnderlyingReference.subclass(*args_, **kwargs_)
        else:
            return StrikePriceUnderlyingReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(StrikePriceUnderlyingReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StrikePriceUnderlyingReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StrikePriceUnderlyingReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StrikePriceUnderlyingReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StrikePriceUnderlyingReference'):
        super(StrikePriceUnderlyingReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StrikePriceUnderlyingReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='StrikePriceUnderlyingReference', fromsubclass_=False, pretty_print=True):
        super(StrikePriceUnderlyingReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(StrikePriceUnderlyingReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(StrikePriceUnderlyingReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class StrikePriceUnderlyingReference


class StrikePriceBasketReference(Reference):
    """A pointer style reference to a basket in the document"""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(StrikePriceBasketReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrikePriceBasketReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrikePriceBasketReference.subclass:
            return StrikePriceBasketReference.subclass(*args_, **kwargs_)
        else:
            return StrikePriceBasketReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(StrikePriceBasketReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StrikePriceBasketReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StrikePriceBasketReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StrikePriceBasketReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StrikePriceBasketReference'):
        super(StrikePriceBasketReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StrikePriceBasketReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='StrikePriceBasketReference', fromsubclass_=False, pretty_print=True):
        super(StrikePriceBasketReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(StrikePriceBasketReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(StrikePriceBasketReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class StrikePriceBasketReference


class SettlementPeriodsReference(Reference):
    """Allows a set of Settlement Periods to reference one already defined
    elsewhere in the trade."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(SettlementPeriodsReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SettlementPeriodsReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SettlementPeriodsReference.subclass:
            return SettlementPeriodsReference.subclass(*args_, **kwargs_)
        else:
            return SettlementPeriodsReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(SettlementPeriodsReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SettlementPeriodsReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SettlementPeriodsReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SettlementPeriodsReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SettlementPeriodsReference'):
        super(SettlementPeriodsReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SettlementPeriodsReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SettlementPeriodsReference', fromsubclass_=False, pretty_print=True):
        super(SettlementPeriodsReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(SettlementPeriodsReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SettlementPeriodsReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SettlementPeriodsReference


class QuantityReference(Reference):
    """A pointer tyle reference to a Quantity defined elsewhere."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(QuantityReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QuantityReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QuantityReference.subclass:
            return QuantityReference.subclass(*args_, **kwargs_)
        else:
            return QuantityReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(QuantityReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QuantityReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QuantityReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QuantityReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QuantityReference'):
        super(QuantityReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QuantityReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QuantityReference', fromsubclass_=False, pretty_print=True):
        super(QuantityReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(QuantityReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QuantityReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QuantityReference


class LagReference(Reference):
    """Allows a lag to reference one already defined elsewhere in the
    trade."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(LagReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LagReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LagReference.subclass:
            return LagReference.subclass(*args_, **kwargs_)
        else:
            return LagReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(LagReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LagReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LagReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LagReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LagReference'):
        super(LagReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LagReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LagReference', fromsubclass_=False, pretty_print=True):
        super(LagReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(LagReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(LagReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class LagReference


class CommoditySwaption(Product):
    """Commodity Swaption."""
    member_data_items_ = {
        'buyerPartyReference': MemberSpec_('buyerPartyReference', 'PartyReference', 0),
        'buyerAccountReference': MemberSpec_('buyerAccountReference', 'AccountReference', 0),
        'sellerPartyReference': MemberSpec_('sellerPartyReference', 'PartyReference', 0),
        'sellerAccountReference': MemberSpec_('sellerAccountReference', 'AccountReference', 0),
        'optionType': MemberSpec_('optionType', ['PutCallEnum', 'Token', 'xsd:token'], 0),
        'commoditySwap': MemberSpec_('commoditySwap', 'CommoditySwap', 0),
        'physicalExercise': MemberSpec_('physicalExercise', 'CommodityPhysicalExercise', 0),
        'premium': MemberSpec_('premium', 'CommodityPremium', 0),
        'commonPricing': MemberSpec_('commonPricing', 'xsd:boolean', 0),
        'marketDisruption': MemberSpec_('marketDisruption', 'CommodityMarketDisruption', 0),
        'settlementDisruption': MemberSpec_('settlementDisruption', ['CommodityBullionSettlementDisruptionEnum', 'Token', 'xsd:token'], 0),
        'rounding': MemberSpec_('rounding', 'Rounding', 0),
    }
    subclass = None
    superclass = Product
    def __init__(self, id=None, primaryAssetClass=None, secondaryAssetClass=None, productType=None, productId=None, assetClass=None, embeddedOptionType=None, buyerPartyReference=None, buyerAccountReference=None, sellerPartyReference=None, sellerAccountReference=None, optionType=None, commoditySwap=None, physicalExercise=None, premium=None, commonPricing=None, marketDisruption=None, settlementDisruption=None, rounding=None):
        self.original_tagname_ = None
        super(CommoditySwaption, self).__init__(id, primaryAssetClass, secondaryAssetClass, productType, productId, assetClass, embeddedOptionType, )
        self.buyerPartyReference = buyerPartyReference
        self.buyerAccountReference = buyerAccountReference
        self.sellerPartyReference = sellerPartyReference
        self.sellerAccountReference = sellerAccountReference
        self.optionType = optionType
        self.validate_PutCallEnum(self.optionType)
        self.commoditySwap = commoditySwap
        self.physicalExercise = physicalExercise
        self.premium = premium
        self.commonPricing = commonPricing
        self.marketDisruption = marketDisruption
        self.settlementDisruption = settlementDisruption
        self.validate_CommodityBullionSettlementDisruptionEnum(self.settlementDisruption)
        self.rounding = rounding
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommoditySwaption)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommoditySwaption.subclass:
            return CommoditySwaption.subclass(*args_, **kwargs_)
        else:
            return CommoditySwaption(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_buyerPartyReference(self): return self.buyerPartyReference
    def set_buyerPartyReference(self, buyerPartyReference): self.buyerPartyReference = buyerPartyReference
    def get_buyerAccountReference(self): return self.buyerAccountReference
    def set_buyerAccountReference(self, buyerAccountReference): self.buyerAccountReference = buyerAccountReference
    def get_sellerPartyReference(self): return self.sellerPartyReference
    def set_sellerPartyReference(self, sellerPartyReference): self.sellerPartyReference = sellerPartyReference
    def get_sellerAccountReference(self): return self.sellerAccountReference
    def set_sellerAccountReference(self, sellerAccountReference): self.sellerAccountReference = sellerAccountReference
    def get_optionType(self): return self.optionType
    def set_optionType(self, optionType): self.optionType = optionType
    def get_commoditySwap(self): return self.commoditySwap
    def set_commoditySwap(self, commoditySwap): self.commoditySwap = commoditySwap
    def get_physicalExercise(self): return self.physicalExercise
    def set_physicalExercise(self, physicalExercise): self.physicalExercise = physicalExercise
    def get_premium(self): return self.premium
    def set_premium(self, premium): self.premium = premium
    def get_commonPricing(self): return self.commonPricing
    def set_commonPricing(self, commonPricing): self.commonPricing = commonPricing
    def get_marketDisruption(self): return self.marketDisruption
    def set_marketDisruption(self, marketDisruption): self.marketDisruption = marketDisruption
    def get_settlementDisruption(self): return self.settlementDisruption
    def set_settlementDisruption(self, settlementDisruption): self.settlementDisruption = settlementDisruption
    def get_rounding(self): return self.rounding
    def set_rounding(self, rounding): self.rounding = rounding
    def validate_PutCallEnum(self, value):
        # Validate type PutCallEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Put', 'Call']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PutCallEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on PutCallEnum' % {"value" : value} )
    def validate_CommodityBullionSettlementDisruptionEnum(self, value):
        # Validate type CommodityBullionSettlementDisruptionEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Negotiation', 'Cancellation and Payment']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CommodityBullionSettlementDisruptionEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on CommodityBullionSettlementDisruptionEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.buyerPartyReference is not None or
            self.buyerAccountReference is not None or
            self.sellerPartyReference is not None or
            self.sellerAccountReference is not None or
            self.optionType is not None or
            self.commoditySwap is not None or
            self.physicalExercise is not None or
            self.premium is not None or
            self.commonPricing is not None or
            self.marketDisruption is not None or
            self.settlementDisruption is not None or
            self.rounding is not None or
            super(CommoditySwaption, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommoditySwaption', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommoditySwaption')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommoditySwaption', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommoditySwaption'):
        super(CommoditySwaption, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CommoditySwaption')
    def exportChildren(self, outfile, level, namespace_='', name_='CommoditySwaption', fromsubclass_=False, pretty_print=True):
        super(CommoditySwaption, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.buyerPartyReference is not None:
            self.buyerPartyReference.export(outfile, level, namespace_, name_='buyerPartyReference', pretty_print=pretty_print)
        if self.buyerAccountReference is not None:
            self.buyerAccountReference.export(outfile, level, namespace_, name_='buyerAccountReference', pretty_print=pretty_print)
        if self.sellerPartyReference is not None:
            self.sellerPartyReference.export(outfile, level, namespace_, name_='sellerPartyReference', pretty_print=pretty_print)
        if self.sellerAccountReference is not None:
            self.sellerAccountReference.export(outfile, level, namespace_, name_='sellerAccountReference', pretty_print=pretty_print)
        if self.optionType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soptionType>%s</%soptionType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.optionType), input_name='optionType')), namespace_, eol_))
        if self.commoditySwap is not None:
            self.commoditySwap.export(outfile, level, namespace_, name_='commoditySwap', pretty_print=pretty_print)
        if self.physicalExercise is not None:
            self.physicalExercise.export(outfile, level, namespace_, name_='physicalExercise', pretty_print=pretty_print)
        if self.premium is not None:
            self.premium.export(outfile, level, namespace_, name_='premium', pretty_print=pretty_print)
        if self.commonPricing is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scommonPricing>%s</%scommonPricing>%s' % (namespace_, self.gds_format_boolean(self.commonPricing, input_name='commonPricing'), namespace_, eol_))
        if self.marketDisruption is not None:
            self.marketDisruption.export(outfile, level, namespace_, name_='marketDisruption', pretty_print=pretty_print)
        if self.settlementDisruption is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssettlementDisruption>%s</%ssettlementDisruption>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.settlementDisruption), input_name='settlementDisruption')), namespace_, eol_))
        if self.rounding is not None:
            self.rounding.export(outfile, level, namespace_, name_='rounding', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CommoditySwaption, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'buyerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.buyerPartyReference = obj_
            obj_.original_tagname_ = 'buyerPartyReference'
        elif nodeName_ == 'buyerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.buyerAccountReference = obj_
            obj_.original_tagname_ = 'buyerAccountReference'
        elif nodeName_ == 'sellerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.sellerPartyReference = obj_
            obj_.original_tagname_ = 'sellerPartyReference'
        elif nodeName_ == 'sellerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.sellerAccountReference = obj_
            obj_.original_tagname_ = 'sellerAccountReference'
        elif nodeName_ == 'optionType':
            optionType_ = child_.text
            optionType_ = re_.sub(String_cleanup_pat_, " ", optionType_).strip()
            optionType_ = self.gds_validate_string(optionType_, node, 'optionType')
            self.optionType = optionType_
            # validate type PutCallEnum
            self.validate_PutCallEnum(self.optionType)
        elif nodeName_ == 'commoditySwap':
            obj_ = CommoditySwaptionUnderlying.factory()
            obj_.build(child_)
            self.commoditySwap = obj_
            obj_.original_tagname_ = 'commoditySwap'
        elif nodeName_ == 'physicalExercise':
            obj_ = CommodityPhysicalExercise.factory()
            obj_.build(child_)
            self.physicalExercise = obj_
            obj_.original_tagname_ = 'physicalExercise'
        elif nodeName_ == 'premium':
            obj_ = CommodityPremium.factory()
            obj_.build(child_)
            self.premium = obj_
            obj_.original_tagname_ = 'premium'
        elif nodeName_ == 'commonPricing':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'commonPricing')
            self.commonPricing = ival_
        elif nodeName_ == 'marketDisruption':
            obj_ = CommodityMarketDisruption.factory()
            obj_.build(child_)
            self.marketDisruption = obj_
            obj_.original_tagname_ = 'marketDisruption'
        elif nodeName_ == 'settlementDisruption':
            settlementDisruption_ = child_.text
            settlementDisruption_ = re_.sub(String_cleanup_pat_, " ", settlementDisruption_).strip()
            settlementDisruption_ = self.gds_validate_string(settlementDisruption_, node, 'settlementDisruption')
            self.settlementDisruption = settlementDisruption_
            # validate type CommodityBullionSettlementDisruptionEnum
            self.validate_CommodityBullionSettlementDisruptionEnum(self.settlementDisruption)
        elif nodeName_ == 'rounding':
            obj_ = Rounding.factory()
            obj_.build(child_)
            self.rounding = obj_
            obj_.original_tagname_ = 'rounding'
        super(CommoditySwaption, self).buildChildren(child_, node, nodeName_, True)
# end class CommoditySwaption


class CommoditySwapLeg(Leg):
    """Abstract base class for all commodity swap legs"""
    member_data_items_ = {
    }
    subclass = None
    superclass = Leg
    def __init__(self, id=None, extensiontype_=None):
        self.original_tagname_ = None
        super(CommoditySwapLeg, self).__init__(id, extensiontype_, )
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommoditySwapLeg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommoditySwapLeg.subclass:
            return CommoditySwapLeg.subclass(*args_, **kwargs_)
        else:
            return CommoditySwapLeg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(CommoditySwapLeg, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommoditySwapLeg', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommoditySwapLeg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommoditySwapLeg', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommoditySwapLeg'):
        super(CommoditySwapLeg, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CommoditySwapLeg')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='CommoditySwapLeg', fromsubclass_=False, pretty_print=True):
        super(CommoditySwapLeg, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(CommoditySwapLeg, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(CommoditySwapLeg, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CommoditySwapLeg


class CommoditySwap(Product):
    """The commodity swap product model is designed to support fixed-float
    swaps, float-float swaps, fixed vs. physical swaps, float vs.
    physical swaps as well as, weather specific swaps. Its design is
    fully compatible with other FpML products and the product reuses
    standard common types."""
    member_data_items_ = {
        'effectiveDate': MemberSpec_('effectiveDate', 'AdjustableOrRelativeDate', 0),
        'terminationDate': MemberSpec_('terminationDate', 'AdjustableOrRelativeDate', 0),
        'settlementCurrency': MemberSpec_('settlementCurrency', 'IdentifiedCurrency', 0),
        'commoditySwapLeg': MemberSpec_('commoditySwapLeg', 'CommoditySwapLeg', 1),
        'weatherLeg': MemberSpec_('weatherLeg', 'WeatherLeg', 1),
        'commonPricing': MemberSpec_('commonPricing', 'xsd:boolean', 0),
        'marketDisruption': MemberSpec_('marketDisruption', 'CommodityMarketDisruption', 0),
        'settlementDisruption': MemberSpec_('settlementDisruption', ['CommodityBullionSettlementDisruptionEnum', 'Token', 'xsd:token', 'Token', 'xsd:token'], 0),
        'rounding': MemberSpec_('rounding', 'Rounding', 0),
    }
    subclass = None
    superclass = Product
    def __init__(self, id=None, primaryAssetClass=None, secondaryAssetClass=None, productType=None, productId=None, assetClass=None, embeddedOptionType=None, effectiveDate=None, terminationDate=None, settlementCurrency=None, commoditySwapLeg=None, weatherLeg=None, commonPricing=None, marketDisruption=None, settlementDisruption=None, rounding=None):
        self.original_tagname_ = None
        super(CommoditySwap, self).__init__(id, primaryAssetClass, secondaryAssetClass, productType, productId, assetClass, embeddedOptionType, )
        self.effectiveDate = effectiveDate
        self.terminationDate = terminationDate
        self.settlementCurrency = settlementCurrency
        if commoditySwapLeg is None:
            self.commoditySwapLeg = []
        else:
            self.commoditySwapLeg = commoditySwapLeg
        if weatherLeg is None:
            self.weatherLeg = []
        else:
            self.weatherLeg = weatherLeg
        self.commonPricing = commonPricing
        self.marketDisruption = marketDisruption
        self.settlementDisruption = settlementDisruption
        self.validate_CommodityBullionSettlementDisruptionEnum(self.settlementDisruption)
        self.rounding = rounding
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommoditySwap)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommoditySwap.subclass:
            return CommoditySwap.subclass(*args_, **kwargs_)
        else:
            return CommoditySwap(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_effectiveDate(self): return self.effectiveDate
    def set_effectiveDate(self, effectiveDate): self.effectiveDate = effectiveDate
    def get_terminationDate(self): return self.terminationDate
    def set_terminationDate(self, terminationDate): self.terminationDate = terminationDate
    def get_settlementCurrency(self): return self.settlementCurrency
    def set_settlementCurrency(self, settlementCurrency): self.settlementCurrency = settlementCurrency
    def get_commoditySwapLeg(self): return self.commoditySwapLeg
    def set_commoditySwapLeg(self, commoditySwapLeg): self.commoditySwapLeg = commoditySwapLeg
    def add_commoditySwapLeg(self, value): self.commoditySwapLeg.append(value)
    def insert_commoditySwapLeg_at(self, index, value): self.commoditySwapLeg.insert(index, value)
    def replace_commoditySwapLeg_at(self, index, value): self.commoditySwapLeg[index] = value
    def get_weatherLeg(self): return self.weatherLeg
    def set_weatherLeg(self, weatherLeg): self.weatherLeg = weatherLeg
    def add_weatherLeg(self, value): self.weatherLeg.append(value)
    def insert_weatherLeg_at(self, index, value): self.weatherLeg.insert(index, value)
    def replace_weatherLeg_at(self, index, value): self.weatherLeg[index] = value
    def get_commonPricing(self): return self.commonPricing
    def set_commonPricing(self, commonPricing): self.commonPricing = commonPricing
    def get_marketDisruption(self): return self.marketDisruption
    def set_marketDisruption(self, marketDisruption): self.marketDisruption = marketDisruption
    def get_settlementDisruption(self): return self.settlementDisruption
    def set_settlementDisruption(self, settlementDisruption): self.settlementDisruption = settlementDisruption
    def get_rounding(self): return self.rounding
    def set_rounding(self, rounding): self.rounding = rounding
    def validate_CommodityBullionSettlementDisruptionEnum(self, value):
        # Validate type CommodityBullionSettlementDisruptionEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Negotiation', 'Cancellation and Payment']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CommodityBullionSettlementDisruptionEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on CommodityBullionSettlementDisruptionEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.effectiveDate is not None or
            self.terminationDate is not None or
            self.settlementCurrency is not None or
            self.commoditySwapLeg or
            self.weatherLeg or
            self.commonPricing is not None or
            self.marketDisruption is not None or
            self.settlementDisruption is not None or
            self.rounding is not None or
            super(CommoditySwap, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommoditySwap', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommoditySwap')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommoditySwap', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommoditySwap'):
        super(CommoditySwap, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CommoditySwap')
    def exportChildren(self, outfile, level, namespace_='', name_='CommoditySwap', fromsubclass_=False, pretty_print=True):
        super(CommoditySwap, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.effectiveDate is not None:
            self.effectiveDate.export(outfile, level, namespace_, name_='effectiveDate', pretty_print=pretty_print)
        if self.terminationDate is not None:
            self.terminationDate.export(outfile, level, namespace_, name_='terminationDate', pretty_print=pretty_print)
        if self.settlementCurrency is not None:
            self.settlementCurrency.export(outfile, level, namespace_, name_='settlementCurrency', pretty_print=pretty_print)
        for commoditySwapLeg_ in self.commoditySwapLeg:
            commoditySwapLeg_.export(outfile, level, namespace_, name_='commoditySwapLeg', pretty_print=pretty_print)
        for weatherLeg_ in self.weatherLeg:
            weatherLeg_.export(outfile, level, namespace_, name_='weatherLeg', pretty_print=pretty_print)
        if self.commonPricing is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scommonPricing>%s</%scommonPricing>%s' % (namespace_, self.gds_format_boolean(self.commonPricing, input_name='commonPricing'), namespace_, eol_))
        if self.marketDisruption is not None:
            self.marketDisruption.export(outfile, level, namespace_, name_='marketDisruption', pretty_print=pretty_print)
        if self.settlementDisruption is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssettlementDisruption>%s</%ssettlementDisruption>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.settlementDisruption), input_name='settlementDisruption')), namespace_, eol_))
        if self.rounding is not None:
            self.rounding.export(outfile, level, namespace_, name_='rounding', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CommoditySwap, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'effectiveDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.effectiveDate = obj_
            obj_.original_tagname_ = 'effectiveDate'
        elif nodeName_ == 'terminationDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.terminationDate = obj_
            obj_.original_tagname_ = 'terminationDate'
        elif nodeName_ == 'settlementCurrency':
            obj_ = IdentifiedCurrency.factory()
            obj_.build(child_)
            self.settlementCurrency = obj_
            obj_.original_tagname_ = 'settlementCurrency'
        elif nodeName_ == 'commoditySwapLeg':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <commoditySwapLeg> element')
            self.commoditySwapLeg.append(obj_)
            obj_.original_tagname_ = 'commoditySwapLeg'
        elif nodeName_ == 'coalPhysicalLeg':
            obj_ = CoalPhysicalLeg.factory()
            obj_.build(child_)
            self.commoditySwapLeg.append(obj_)
            obj_.original_tagname_ = 'coalPhysicalLeg'
        elif nodeName_ == 'electricityPhysicalLeg':
            obj_ = ElectricityPhysicalLeg.factory()
            obj_.build(child_)
            self.commoditySwapLeg.append(obj_)
            obj_.original_tagname_ = 'electricityPhysicalLeg'
        elif nodeName_ == 'environmentalPhysicalLeg':
            obj_ = EnvironmentalPhysicalLeg.factory()
            obj_.build(child_)
            self.commoditySwapLeg.append(obj_)
            obj_.original_tagname_ = 'environmentalPhysicalLeg'
        elif nodeName_ == 'fixedLeg':
            obj_ = FixedPriceLeg.factory()
            obj_.build(child_)
            self.commoditySwapLeg.append(obj_)
            obj_.original_tagname_ = 'fixedLeg'
        elif nodeName_ == 'floatingLeg':
            obj_ = FloatingPriceLeg.factory()
            obj_.build(child_)
            self.commoditySwapLeg.append(obj_)
            obj_.original_tagname_ = 'floatingLeg'
        elif nodeName_ == 'gasPhysicalLeg':
            obj_ = GasPhysicalLeg.factory()
            obj_.build(child_)
            self.commoditySwapLeg.append(obj_)
            obj_.original_tagname_ = 'gasPhysicalLeg'
        elif nodeName_ == 'oilPhysicalLeg':
            obj_ = OilPhysicalLeg.factory()
            obj_.build(child_)
            self.commoditySwapLeg.append(obj_)
            obj_.original_tagname_ = 'oilPhysicalLeg'
        elif nodeName_ == 'weatherLeg':
            obj_ = WeatherLeg.factory()
            obj_.build(child_)
            self.weatherLeg.append(obj_)
            obj_.original_tagname_ = 'weatherLeg'
        elif nodeName_ == 'commonPricing':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'commonPricing')
            self.commonPricing = ival_
        elif nodeName_ == 'marketDisruption':
            obj_ = CommodityMarketDisruption.factory()
            obj_.build(child_)
            self.marketDisruption = obj_
            obj_.original_tagname_ = 'marketDisruption'
        elif nodeName_ == 'settlementDisruption':
            settlementDisruption_ = child_.text
            settlementDisruption_ = re_.sub(String_cleanup_pat_, " ", settlementDisruption_).strip()
            settlementDisruption_ = self.gds_validate_string(settlementDisruption_, node, 'settlementDisruption')
            self.settlementDisruption = settlementDisruption_
            # validate type CommodityBullionSettlementDisruptionEnum
            self.validate_CommodityBullionSettlementDisruptionEnum(self.settlementDisruption)
        elif nodeName_ == 'rounding':
            obj_ = Rounding.factory()
            obj_.build(child_)
            self.rounding = obj_
            obj_.original_tagname_ = 'rounding'
        super(CommoditySwap, self).buildChildren(child_, node, nodeName_, True)
# end class CommoditySwap


class CommoditySpread(Money):
    member_data_items_ = {
        'spreadConversionFactor': MemberSpec_('spreadConversionFactor', 'xsd:decimal', 0),
        'spreadUnit': MemberSpec_('spreadUnit', 'QuantityUnit', 0),
    }
    subclass = None
    superclass = Money
    def __init__(self, id=None, currency=None, amount=None, spreadConversionFactor=None, spreadUnit=None):
        self.original_tagname_ = None
        super(CommoditySpread, self).__init__(id, currency, amount, )
        self.spreadConversionFactor = spreadConversionFactor
        self.spreadUnit = spreadUnit
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommoditySpread)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommoditySpread.subclass:
            return CommoditySpread.subclass(*args_, **kwargs_)
        else:
            return CommoditySpread(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_spreadConversionFactor(self): return self.spreadConversionFactor
    def set_spreadConversionFactor(self, spreadConversionFactor): self.spreadConversionFactor = spreadConversionFactor
    def get_spreadUnit(self): return self.spreadUnit
    def set_spreadUnit(self, spreadUnit): self.spreadUnit = spreadUnit
    def hasContent_(self):
        if (
            self.spreadConversionFactor is not None or
            self.spreadUnit is not None or
            super(CommoditySpread, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommoditySpread', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommoditySpread')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommoditySpread', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommoditySpread'):
        super(CommoditySpread, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CommoditySpread')
    def exportChildren(self, outfile, level, namespace_='', name_='CommoditySpread', fromsubclass_=False, pretty_print=True):
        super(CommoditySpread, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.spreadConversionFactor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sspreadConversionFactor>%s</%sspreadConversionFactor>%s' % (namespace_, self.gds_format_float(self.spreadConversionFactor, input_name='spreadConversionFactor'), namespace_, eol_))
        if self.spreadUnit is not None:
            self.spreadUnit.export(outfile, level, namespace_, name_='spreadUnit', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CommoditySpread, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'spreadConversionFactor':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'spreadConversionFactor')
            self.spreadConversionFactor = fval_
        elif nodeName_ == 'spreadUnit':
            obj_ = QuantityUnit.factory()
            obj_.build(child_)
            self.spreadUnit = obj_
            obj_.original_tagname_ = 'spreadUnit'
        super(CommoditySpread, self).buildChildren(child_, node, nodeName_, True)
# end class CommoditySpread


class CommodityPremium(NonNegativePayment):
    """The commodity option premium payable by the buyer to the seller."""
    member_data_items_ = {
        'premiumPerUnit': MemberSpec_('premiumPerUnit', 'NonNegativeMoney', 0),
    }
    subclass = None
    superclass = NonNegativePayment
    def __init__(self, id=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, paymentDate=None, paymentAmount=None, premiumPerUnit=None):
        self.original_tagname_ = None
        super(CommodityPremium, self).__init__(id, payerPartyReference, payerAccountReference, receiverPartyReference, receiverAccountReference, paymentDate, paymentAmount, )
        self.premiumPerUnit = premiumPerUnit
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityPremium)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityPremium.subclass:
            return CommodityPremium.subclass(*args_, **kwargs_)
        else:
            return CommodityPremium(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_premiumPerUnit(self): return self.premiumPerUnit
    def set_premiumPerUnit(self, premiumPerUnit): self.premiumPerUnit = premiumPerUnit
    def hasContent_(self):
        if (
            self.premiumPerUnit is not None or
            super(CommodityPremium, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityPremium', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityPremium')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityPremium', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityPremium'):
        super(CommodityPremium, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityPremium')
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityPremium', fromsubclass_=False, pretty_print=True):
        super(CommodityPremium, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.premiumPerUnit is not None:
            self.premiumPerUnit.export(outfile, level, namespace_, name_='premiumPerUnit', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CommodityPremium, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'premiumPerUnit':
            class_obj_ = self.get_class_obj_(child_, NonNegativeMoney)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.premiumPerUnit = obj_
            obj_.original_tagname_ = 'premiumPerUnit'
        super(CommodityPremium, self).buildChildren(child_, node, nodeName_, True)
# end class CommodityPremium


class CommodityPhysicalQuantity(CommodityPhysicalQuantityBase):
    """A type defining the physical quantity of the commodity to be
    delivered."""
    member_data_items_ = {
        'physicalQuantity': MemberSpec_('physicalQuantity', 'CommodityNotionalQuantity', 0),
        'physicalQuantitySchedule': MemberSpec_('physicalQuantitySchedule', 'CommodityPhysicalQuantitySchedule', 0),
        'totalPhysicalQuantity': MemberSpec_('totalPhysicalQuantity', 'UnitQuantity', 0),
    }
    subclass = None
    superclass = CommodityPhysicalQuantityBase
    def __init__(self, id=None, physicalQuantity=None, physicalQuantitySchedule=None, totalPhysicalQuantity=None):
        self.original_tagname_ = None
        super(CommodityPhysicalQuantity, self).__init__(id, )
        self.physicalQuantity = physicalQuantity
        self.physicalQuantitySchedule = physicalQuantitySchedule
        self.totalPhysicalQuantity = totalPhysicalQuantity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityPhysicalQuantity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityPhysicalQuantity.subclass:
            return CommodityPhysicalQuantity.subclass(*args_, **kwargs_)
        else:
            return CommodityPhysicalQuantity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_physicalQuantity(self): return self.physicalQuantity
    def set_physicalQuantity(self, physicalQuantity): self.physicalQuantity = physicalQuantity
    def get_physicalQuantitySchedule(self): return self.physicalQuantitySchedule
    def set_physicalQuantitySchedule(self, physicalQuantitySchedule): self.physicalQuantitySchedule = physicalQuantitySchedule
    def get_totalPhysicalQuantity(self): return self.totalPhysicalQuantity
    def set_totalPhysicalQuantity(self, totalPhysicalQuantity): self.totalPhysicalQuantity = totalPhysicalQuantity
    def hasContent_(self):
        if (
            self.physicalQuantity is not None or
            self.physicalQuantitySchedule is not None or
            self.totalPhysicalQuantity is not None or
            super(CommodityPhysicalQuantity, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityPhysicalQuantity', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityPhysicalQuantity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityPhysicalQuantity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityPhysicalQuantity'):
        super(CommodityPhysicalQuantity, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityPhysicalQuantity')
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityPhysicalQuantity', fromsubclass_=False, pretty_print=True):
        super(CommodityPhysicalQuantity, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.physicalQuantity is not None:
            self.physicalQuantity.export(outfile, level, namespace_, name_='physicalQuantity', pretty_print=pretty_print)
        if self.physicalQuantitySchedule is not None:
            self.physicalQuantitySchedule.export(outfile, level, namespace_, name_='physicalQuantitySchedule', pretty_print=pretty_print)
        if self.totalPhysicalQuantity is not None:
            self.totalPhysicalQuantity.export(outfile, level, namespace_, name_='totalPhysicalQuantity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CommodityPhysicalQuantity, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'physicalQuantity':
            class_obj_ = self.get_class_obj_(child_, CommodityNotionalQuantity)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.physicalQuantity = obj_
            obj_.original_tagname_ = 'physicalQuantity'
        elif nodeName_ == 'physicalQuantitySchedule':
            class_obj_ = self.get_class_obj_(child_, CommodityPhysicalQuantitySchedule)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.physicalQuantitySchedule = obj_
            obj_.original_tagname_ = 'physicalQuantitySchedule'
        elif nodeName_ == 'totalPhysicalQuantity':
            obj_ = UnitQuantity.factory()
            obj_.build(child_)
            self.totalPhysicalQuantity = obj_
            obj_.original_tagname_ = 'totalPhysicalQuantity'
        super(CommodityPhysicalQuantity, self).buildChildren(child_, node, nodeName_, True)
# end class CommodityPhysicalQuantity


class CommodityPhysicalEuropeanExercise(Exercise):
    """The parameters for defining the expiration date(s) and time(s) for a
    European style option."""
    member_data_items_ = {
        'expirationDate': MemberSpec_('expirationDate', 'AdjustableOrRelativeDate', 0),
        'expirationDates': MemberSpec_('expirationDates', 'AdjustableRelativeOrPeriodicDates2', 0),
        'relativeExpirationDates': MemberSpec_('relativeExpirationDates', 'CommodityRelativeExpirationDates', 0),
        'expirationTime': MemberSpec_('expirationTime', 'PrevailingTime', 0),
    }
    subclass = None
    superclass = Exercise
    def __init__(self, id=None, expirationDate=None, expirationDates=None, relativeExpirationDates=None, expirationTime=None):
        self.original_tagname_ = None
        super(CommodityPhysicalEuropeanExercise, self).__init__(id, )
        self.expirationDate = expirationDate
        self.expirationDates = expirationDates
        self.relativeExpirationDates = relativeExpirationDates
        self.expirationTime = expirationTime
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityPhysicalEuropeanExercise)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityPhysicalEuropeanExercise.subclass:
            return CommodityPhysicalEuropeanExercise.subclass(*args_, **kwargs_)
        else:
            return CommodityPhysicalEuropeanExercise(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_expirationDate(self): return self.expirationDate
    def set_expirationDate(self, expirationDate): self.expirationDate = expirationDate
    def get_expirationDates(self): return self.expirationDates
    def set_expirationDates(self, expirationDates): self.expirationDates = expirationDates
    def get_relativeExpirationDates(self): return self.relativeExpirationDates
    def set_relativeExpirationDates(self, relativeExpirationDates): self.relativeExpirationDates = relativeExpirationDates
    def get_expirationTime(self): return self.expirationTime
    def set_expirationTime(self, expirationTime): self.expirationTime = expirationTime
    def hasContent_(self):
        if (
            self.expirationDate is not None or
            self.expirationDates is not None or
            self.relativeExpirationDates is not None or
            self.expirationTime is not None or
            super(CommodityPhysicalEuropeanExercise, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityPhysicalEuropeanExercise', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityPhysicalEuropeanExercise')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityPhysicalEuropeanExercise', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityPhysicalEuropeanExercise'):
        super(CommodityPhysicalEuropeanExercise, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityPhysicalEuropeanExercise')
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityPhysicalEuropeanExercise', fromsubclass_=False, pretty_print=True):
        super(CommodityPhysicalEuropeanExercise, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.expirationDate is not None:
            self.expirationDate.export(outfile, level, namespace_, name_='expirationDate', pretty_print=pretty_print)
        if self.expirationDates is not None:
            self.expirationDates.export(outfile, level, namespace_, name_='expirationDates', pretty_print=pretty_print)
        if self.relativeExpirationDates is not None:
            self.relativeExpirationDates.export(outfile, level, namespace_, name_='relativeExpirationDates', pretty_print=pretty_print)
        if self.expirationTime is not None:
            self.expirationTime.export(outfile, level, namespace_, name_='expirationTime', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CommodityPhysicalEuropeanExercise, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'expirationDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.expirationDate = obj_
            obj_.original_tagname_ = 'expirationDate'
        elif nodeName_ == 'expirationDates':
            obj_ = AdjustableRelativeOrPeriodicDates2.factory()
            obj_.build(child_)
            self.expirationDates = obj_
            obj_.original_tagname_ = 'expirationDates'
        elif nodeName_ == 'relativeExpirationDates':
            obj_ = CommodityRelativeExpirationDates.factory()
            obj_.build(child_)
            self.relativeExpirationDates = obj_
            obj_.original_tagname_ = 'relativeExpirationDates'
        elif nodeName_ == 'expirationTime':
            obj_ = PrevailingTime.factory()
            obj_.build(child_)
            self.expirationTime = obj_
            obj_.original_tagname_ = 'expirationTime'
        super(CommodityPhysicalEuropeanExercise, self).buildChildren(child_, node, nodeName_, True)
# end class CommodityPhysicalEuropeanExercise


class CommodityPhysicalAmericanExercise(Exercise):
    """The parameters for defining the expiration date(s) and time(s) for
    an American style option."""
    member_data_items_ = {
        'commencementDates': MemberSpec_('commencementDates', 'AdjustableOrRelativeDates', 0),
        'expirationDates': MemberSpec_('expirationDates', 'AdjustableOrRelativeDates', 0),
        'relativeCommencementDates': MemberSpec_('relativeCommencementDates', 'CommodityRelativeExpirationDates', 0),
        'relativeExpirationDates': MemberSpec_('relativeExpirationDates', 'CommodityRelativeExpirationDates', 0),
        'latestExerciseTime': MemberSpec_('latestExerciseTime', 'PrevailingTime', 0),
        'expirationTime': MemberSpec_('expirationTime', 'PrevailingTime', 0),
    }
    subclass = None
    superclass = Exercise
    def __init__(self, id=None, commencementDates=None, expirationDates=None, relativeCommencementDates=None, relativeExpirationDates=None, latestExerciseTime=None, expirationTime=None):
        self.original_tagname_ = None
        super(CommodityPhysicalAmericanExercise, self).__init__(id, )
        self.commencementDates = commencementDates
        self.expirationDates = expirationDates
        self.relativeCommencementDates = relativeCommencementDates
        self.relativeExpirationDates = relativeExpirationDates
        self.latestExerciseTime = latestExerciseTime
        self.expirationTime = expirationTime
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityPhysicalAmericanExercise)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityPhysicalAmericanExercise.subclass:
            return CommodityPhysicalAmericanExercise.subclass(*args_, **kwargs_)
        else:
            return CommodityPhysicalAmericanExercise(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commencementDates(self): return self.commencementDates
    def set_commencementDates(self, commencementDates): self.commencementDates = commencementDates
    def get_expirationDates(self): return self.expirationDates
    def set_expirationDates(self, expirationDates): self.expirationDates = expirationDates
    def get_relativeCommencementDates(self): return self.relativeCommencementDates
    def set_relativeCommencementDates(self, relativeCommencementDates): self.relativeCommencementDates = relativeCommencementDates
    def get_relativeExpirationDates(self): return self.relativeExpirationDates
    def set_relativeExpirationDates(self, relativeExpirationDates): self.relativeExpirationDates = relativeExpirationDates
    def get_latestExerciseTime(self): return self.latestExerciseTime
    def set_latestExerciseTime(self, latestExerciseTime): self.latestExerciseTime = latestExerciseTime
    def get_expirationTime(self): return self.expirationTime
    def set_expirationTime(self, expirationTime): self.expirationTime = expirationTime
    def hasContent_(self):
        if (
            self.commencementDates is not None or
            self.expirationDates is not None or
            self.relativeCommencementDates is not None or
            self.relativeExpirationDates is not None or
            self.latestExerciseTime is not None or
            self.expirationTime is not None or
            super(CommodityPhysicalAmericanExercise, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityPhysicalAmericanExercise', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityPhysicalAmericanExercise')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityPhysicalAmericanExercise', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityPhysicalAmericanExercise'):
        super(CommodityPhysicalAmericanExercise, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityPhysicalAmericanExercise')
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityPhysicalAmericanExercise', fromsubclass_=False, pretty_print=True):
        super(CommodityPhysicalAmericanExercise, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.commencementDates is not None:
            self.commencementDates.export(outfile, level, namespace_, name_='commencementDates', pretty_print=pretty_print)
        if self.expirationDates is not None:
            self.expirationDates.export(outfile, level, namespace_, name_='expirationDates', pretty_print=pretty_print)
        if self.relativeCommencementDates is not None:
            self.relativeCommencementDates.export(outfile, level, namespace_, name_='relativeCommencementDates', pretty_print=pretty_print)
        if self.relativeExpirationDates is not None:
            self.relativeExpirationDates.export(outfile, level, namespace_, name_='relativeExpirationDates', pretty_print=pretty_print)
        if self.latestExerciseTime is not None:
            self.latestExerciseTime.export(outfile, level, namespace_, name_='latestExerciseTime', pretty_print=pretty_print)
        if self.expirationTime is not None:
            self.expirationTime.export(outfile, level, namespace_, name_='expirationTime', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CommodityPhysicalAmericanExercise, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'commencementDates':
            obj_ = AdjustableOrRelativeDates.factory()
            obj_.build(child_)
            self.commencementDates = obj_
            obj_.original_tagname_ = 'commencementDates'
        elif nodeName_ == 'expirationDates':
            obj_ = AdjustableOrRelativeDates.factory()
            obj_.build(child_)
            self.expirationDates = obj_
            obj_.original_tagname_ = 'expirationDates'
        elif nodeName_ == 'relativeCommencementDates':
            obj_ = CommodityRelativeExpirationDates.factory()
            obj_.build(child_)
            self.relativeCommencementDates = obj_
            obj_.original_tagname_ = 'relativeCommencementDates'
        elif nodeName_ == 'relativeExpirationDates':
            obj_ = CommodityRelativeExpirationDates.factory()
            obj_.build(child_)
            self.relativeExpirationDates = obj_
            obj_.original_tagname_ = 'relativeExpirationDates'
        elif nodeName_ == 'latestExerciseTime':
            obj_ = PrevailingTime.factory()
            obj_.build(child_)
            self.latestExerciseTime = obj_
            obj_.original_tagname_ = 'latestExerciseTime'
        elif nodeName_ == 'expirationTime':
            obj_ = PrevailingTime.factory()
            obj_.build(child_)
            self.expirationTime = obj_
            obj_.original_tagname_ = 'expirationTime'
        super(CommodityPhysicalAmericanExercise, self).buildChildren(child_, node, nodeName_, True)
# end class CommodityPhysicalAmericanExercise


class CommodityPerformanceSwapLeg(Leg):
    """Abstract base class for all commodity performance swap legs."""
    member_data_items_ = {
        'payerPartyReference': MemberSpec_('payerPartyReference', 'PartyReference', 0),
        'payerAccountReference': MemberSpec_('payerAccountReference', 'AccountReference', 0),
        'receiverPartyReference': MemberSpec_('receiverPartyReference', 'PartyReference', 0),
        'receiverAccountReference': MemberSpec_('receiverAccountReference', 'AccountReference', 0),
    }
    subclass = None
    superclass = Leg
    def __init__(self, id=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, extensiontype_=None):
        self.original_tagname_ = None
        super(CommodityPerformanceSwapLeg, self).__init__(id, extensiontype_, )
        self.payerPartyReference = payerPartyReference
        self.payerAccountReference = payerAccountReference
        self.receiverPartyReference = receiverPartyReference
        self.receiverAccountReference = receiverAccountReference
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityPerformanceSwapLeg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityPerformanceSwapLeg.subclass:
            return CommodityPerformanceSwapLeg.subclass(*args_, **kwargs_)
        else:
            return CommodityPerformanceSwapLeg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_payerPartyReference(self): return self.payerPartyReference
    def set_payerPartyReference(self, payerPartyReference): self.payerPartyReference = payerPartyReference
    def get_payerAccountReference(self): return self.payerAccountReference
    def set_payerAccountReference(self, payerAccountReference): self.payerAccountReference = payerAccountReference
    def get_receiverPartyReference(self): return self.receiverPartyReference
    def set_receiverPartyReference(self, receiverPartyReference): self.receiverPartyReference = receiverPartyReference
    def get_receiverAccountReference(self): return self.receiverAccountReference
    def set_receiverAccountReference(self, receiverAccountReference): self.receiverAccountReference = receiverAccountReference
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.payerPartyReference is not None or
            self.payerAccountReference is not None or
            self.receiverPartyReference is not None or
            self.receiverAccountReference is not None or
            super(CommodityPerformanceSwapLeg, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityPerformanceSwapLeg', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityPerformanceSwapLeg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityPerformanceSwapLeg', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityPerformanceSwapLeg'):
        super(CommodityPerformanceSwapLeg, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityPerformanceSwapLeg')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityPerformanceSwapLeg', fromsubclass_=False, pretty_print=True):
        super(CommodityPerformanceSwapLeg, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.payerPartyReference is not None:
            self.payerPartyReference.export(outfile, level, namespace_, name_='payerPartyReference', pretty_print=pretty_print)
        if self.payerAccountReference is not None:
            self.payerAccountReference.export(outfile, level, namespace_, name_='payerAccountReference', pretty_print=pretty_print)
        if self.receiverPartyReference is not None:
            self.receiverPartyReference.export(outfile, level, namespace_, name_='receiverPartyReference', pretty_print=pretty_print)
        if self.receiverAccountReference is not None:
            self.receiverAccountReference.export(outfile, level, namespace_, name_='receiverAccountReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(CommodityPerformanceSwapLeg, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'payerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.payerPartyReference = obj_
            obj_.original_tagname_ = 'payerPartyReference'
        elif nodeName_ == 'payerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.payerAccountReference = obj_
            obj_.original_tagname_ = 'payerAccountReference'
        elif nodeName_ == 'receiverPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.receiverPartyReference = obj_
            obj_.original_tagname_ = 'receiverPartyReference'
        elif nodeName_ == 'receiverAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.receiverAccountReference = obj_
            obj_.original_tagname_ = 'receiverAccountReference'
        super(CommodityPerformanceSwapLeg, self).buildChildren(child_, node, nodeName_, True)
# end class CommodityPerformanceSwapLeg


class CommodityPerformanceSwapBase(Product):
    """A product with which to represent return swaps, total return swaps
    and excess return swaps."""
    member_data_items_ = {
        'effectiveDate': MemberSpec_('effectiveDate', 'AdjustableOrRelativeDate', 0),
        'terminationDate': MemberSpec_('terminationDate', 'AdjustableOrRelativeDate', 0),
        'settlementCurrency': MemberSpec_('settlementCurrency', 'IdentifiedCurrency', 0),
        'commodityPerformanceSwapLeg': MemberSpec_('commodityPerformanceSwapLeg', 'CommodityPerformanceSwapLeg', 1),
        'commonPricing': MemberSpec_('commonPricing', 'xsd:boolean', 0),
        'marketDisruption': MemberSpec_('marketDisruption', 'CommodityMarketDisruption', 0),
        'settlementDisruption': MemberSpec_('settlementDisruption', ['CommodityBullionSettlementDisruptionEnum', 'Token', 'xsd:token'], 0),
        'rounding': MemberSpec_('rounding', 'Rounding', 0),
    }
    subclass = None
    superclass = Product
    def __init__(self, id=None, primaryAssetClass=None, secondaryAssetClass=None, productType=None, productId=None, assetClass=None, embeddedOptionType=None, effectiveDate=None, terminationDate=None, settlementCurrency=None, commodityPerformanceSwapLeg=None, commonPricing=None, marketDisruption=None, settlementDisruption=None, rounding=None, extensiontype_=None):
        self.original_tagname_ = None
        super(CommodityPerformanceSwapBase, self).__init__(id, primaryAssetClass, secondaryAssetClass, productType, productId, assetClass, embeddedOptionType, extensiontype_, )
        self.effectiveDate = effectiveDate
        self.terminationDate = terminationDate
        self.settlementCurrency = settlementCurrency
        if commodityPerformanceSwapLeg is None:
            self.commodityPerformanceSwapLeg = []
        else:
            self.commodityPerformanceSwapLeg = commodityPerformanceSwapLeg
        self.commonPricing = commonPricing
        self.marketDisruption = marketDisruption
        self.settlementDisruption = settlementDisruption
        self.validate_CommodityBullionSettlementDisruptionEnum(self.settlementDisruption)
        self.rounding = rounding
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityPerformanceSwapBase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityPerformanceSwapBase.subclass:
            return CommodityPerformanceSwapBase.subclass(*args_, **kwargs_)
        else:
            return CommodityPerformanceSwapBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_effectiveDate(self): return self.effectiveDate
    def set_effectiveDate(self, effectiveDate): self.effectiveDate = effectiveDate
    def get_terminationDate(self): return self.terminationDate
    def set_terminationDate(self, terminationDate): self.terminationDate = terminationDate
    def get_settlementCurrency(self): return self.settlementCurrency
    def set_settlementCurrency(self, settlementCurrency): self.settlementCurrency = settlementCurrency
    def get_commodityPerformanceSwapLeg(self): return self.commodityPerformanceSwapLeg
    def set_commodityPerformanceSwapLeg(self, commodityPerformanceSwapLeg): self.commodityPerformanceSwapLeg = commodityPerformanceSwapLeg
    def add_commodityPerformanceSwapLeg(self, value): self.commodityPerformanceSwapLeg.append(value)
    def insert_commodityPerformanceSwapLeg_at(self, index, value): self.commodityPerformanceSwapLeg.insert(index, value)
    def replace_commodityPerformanceSwapLeg_at(self, index, value): self.commodityPerformanceSwapLeg[index] = value
    def get_commonPricing(self): return self.commonPricing
    def set_commonPricing(self, commonPricing): self.commonPricing = commonPricing
    def get_marketDisruption(self): return self.marketDisruption
    def set_marketDisruption(self, marketDisruption): self.marketDisruption = marketDisruption
    def get_settlementDisruption(self): return self.settlementDisruption
    def set_settlementDisruption(self, settlementDisruption): self.settlementDisruption = settlementDisruption
    def get_rounding(self): return self.rounding
    def set_rounding(self, rounding): self.rounding = rounding
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_CommodityBullionSettlementDisruptionEnum(self, value):
        # Validate type CommodityBullionSettlementDisruptionEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Negotiation', 'Cancellation and Payment']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CommodityBullionSettlementDisruptionEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on CommodityBullionSettlementDisruptionEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.effectiveDate is not None or
            self.terminationDate is not None or
            self.settlementCurrency is not None or
            self.commodityPerformanceSwapLeg or
            self.commonPricing is not None or
            self.marketDisruption is not None or
            self.settlementDisruption is not None or
            self.rounding is not None or
            super(CommodityPerformanceSwapBase, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityPerformanceSwapBase', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityPerformanceSwapBase')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityPerformanceSwapBase', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityPerformanceSwapBase'):
        super(CommodityPerformanceSwapBase, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityPerformanceSwapBase')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityPerformanceSwapBase', fromsubclass_=False, pretty_print=True):
        super(CommodityPerformanceSwapBase, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.effectiveDate is not None:
            self.effectiveDate.export(outfile, level, namespace_, name_='effectiveDate', pretty_print=pretty_print)
        if self.terminationDate is not None:
            self.terminationDate.export(outfile, level, namespace_, name_='terminationDate', pretty_print=pretty_print)
        if self.settlementCurrency is not None:
            self.settlementCurrency.export(outfile, level, namespace_, name_='settlementCurrency', pretty_print=pretty_print)
        for commodityPerformanceSwapLeg_ in self.commodityPerformanceSwapLeg:
            commodityPerformanceSwapLeg_.export(outfile, level, namespace_, name_='commodityPerformanceSwapLeg', pretty_print=pretty_print)
        if self.commonPricing is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scommonPricing>%s</%scommonPricing>%s' % (namespace_, self.gds_format_boolean(self.commonPricing, input_name='commonPricing'), namespace_, eol_))
        if self.marketDisruption is not None:
            self.marketDisruption.export(outfile, level, namespace_, name_='marketDisruption', pretty_print=pretty_print)
        if self.settlementDisruption is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssettlementDisruption>%s</%ssettlementDisruption>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.settlementDisruption), input_name='settlementDisruption')), namespace_, eol_))
        if self.rounding is not None:
            self.rounding.export(outfile, level, namespace_, name_='rounding', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(CommodityPerformanceSwapBase, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'effectiveDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.effectiveDate = obj_
            obj_.original_tagname_ = 'effectiveDate'
        elif nodeName_ == 'terminationDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.terminationDate = obj_
            obj_.original_tagname_ = 'terminationDate'
        elif nodeName_ == 'settlementCurrency':
            obj_ = IdentifiedCurrency.factory()
            obj_.build(child_)
            self.settlementCurrency = obj_
            obj_.original_tagname_ = 'settlementCurrency'
        elif nodeName_ == 'commodityPerformanceSwapLeg':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <commodityPerformanceSwapLeg> element')
            self.commodityPerformanceSwapLeg.append(obj_)
            obj_.original_tagname_ = 'commodityPerformanceSwapLeg'
        elif nodeName_ == 'commodityInterestLeg':
            obj_ = CommodityInterestLeg.factory()
            obj_.build(child_)
            self.commodityPerformanceSwapLeg.append(obj_)
            obj_.original_tagname_ = 'commodityInterestLeg'
        elif nodeName_ == 'commodityReturnLeg':
            obj_ = CommodityReturnLeg.factory()
            obj_.build(child_)
            self.commodityPerformanceSwapLeg.append(obj_)
            obj_.original_tagname_ = 'commodityReturnLeg'
        elif nodeName_ == 'commodityVarianceLeg':
            obj_ = CommodityVarianceLeg.factory()
            obj_.build(child_)
            self.commodityPerformanceSwapLeg.append(obj_)
            obj_.original_tagname_ = 'commodityVarianceLeg'
        elif nodeName_ == 'commonPricing':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'commonPricing')
            self.commonPricing = ival_
        elif nodeName_ == 'marketDisruption':
            obj_ = CommodityMarketDisruption.factory()
            obj_.build(child_)
            self.marketDisruption = obj_
            obj_.original_tagname_ = 'marketDisruption'
        elif nodeName_ == 'settlementDisruption':
            settlementDisruption_ = child_.text
            settlementDisruption_ = re_.sub(String_cleanup_pat_, " ", settlementDisruption_).strip()
            settlementDisruption_ = self.gds_validate_string(settlementDisruption_, node, 'settlementDisruption')
            self.settlementDisruption = settlementDisruption_
            # validate type CommodityBullionSettlementDisruptionEnum
            self.validate_CommodityBullionSettlementDisruptionEnum(self.settlementDisruption)
        elif nodeName_ == 'rounding':
            obj_ = Rounding.factory()
            obj_.build(child_)
            self.rounding = obj_
            obj_.original_tagname_ = 'rounding'
        super(CommodityPerformanceSwapBase, self).buildChildren(child_, node, nodeName_, True)
# end class CommodityPerformanceSwapBase


class CommodityPerformanceSwap(CommodityPerformanceSwapBase):
    """A type describing a commodity performance swap in which one leg pays
    out based on the return on a reference commodity index or
    commodity reference price."""
    member_data_items_ = {
        'earlyTermination': MemberSpec_('earlyTermination', 'CommodityPerformanceSwapEarlyTermination', 1),
    }
    subclass = None
    superclass = CommodityPerformanceSwapBase
    def __init__(self, id=None, primaryAssetClass=None, secondaryAssetClass=None, productType=None, productId=None, assetClass=None, embeddedOptionType=None, effectiveDate=None, terminationDate=None, settlementCurrency=None, commodityPerformanceSwapLeg=None, commonPricing=None, marketDisruption=None, settlementDisruption=None, rounding=None, earlyTermination=None):
        self.original_tagname_ = None
        super(CommodityPerformanceSwap, self).__init__(id, primaryAssetClass, secondaryAssetClass, productType, productId, assetClass, embeddedOptionType, effectiveDate, terminationDate, settlementCurrency, commodityPerformanceSwapLeg, commonPricing, marketDisruption, settlementDisruption, rounding, )
        if earlyTermination is None:
            self.earlyTermination = []
        else:
            self.earlyTermination = earlyTermination
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityPerformanceSwap)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityPerformanceSwap.subclass:
            return CommodityPerformanceSwap.subclass(*args_, **kwargs_)
        else:
            return CommodityPerformanceSwap(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_earlyTermination(self): return self.earlyTermination
    def set_earlyTermination(self, earlyTermination): self.earlyTermination = earlyTermination
    def add_earlyTermination(self, value): self.earlyTermination.append(value)
    def insert_earlyTermination_at(self, index, value): self.earlyTermination.insert(index, value)
    def replace_earlyTermination_at(self, index, value): self.earlyTermination[index] = value
    def hasContent_(self):
        if (
            self.earlyTermination or
            super(CommodityPerformanceSwap, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityPerformanceSwap', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityPerformanceSwap')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityPerformanceSwap', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityPerformanceSwap'):
        super(CommodityPerformanceSwap, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityPerformanceSwap')
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityPerformanceSwap', fromsubclass_=False, pretty_print=True):
        super(CommodityPerformanceSwap, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for earlyTermination_ in self.earlyTermination:
            earlyTermination_.export(outfile, level, namespace_, name_='earlyTermination', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CommodityPerformanceSwap, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'earlyTermination':
            obj_ = CommodityPerformanceSwapEarlyTermination.factory()
            obj_.build(child_)
            self.earlyTermination.append(obj_)
            obj_.original_tagname_ = 'earlyTermination'
        super(CommodityPerformanceSwap, self).buildChildren(child_, node, nodeName_, True)
# end class CommodityPerformanceSwap


class CommodityOption(Product):
    """Defines a commodity option product type. The product support for
    financially-settled exercises or exercise into physical forward
    contracts written on precious and non-precious metals. options
    in FpML is based on the creation of a 'commodityOption' product.
    The product references the 'commodity' underlyer in order to
    support the underlying asset of the option."""
    member_data_items_ = {
        'buyerPartyReference': MemberSpec_('buyerPartyReference', 'PartyReference', 0),
        'buyerAccountReference': MemberSpec_('buyerAccountReference', 'AccountReference', 0),
        'sellerPartyReference': MemberSpec_('sellerPartyReference', 'PartyReference', 0),
        'sellerAccountReference': MemberSpec_('sellerAccountReference', 'AccountReference', 0),
        'optionType': MemberSpec_('optionType', ['PutCallEnum', 'Token', 'xsd:token'], 0),
        'commodity': MemberSpec_('commodity', 'Commodity', 0),
        'effectiveDate': MemberSpec_('effectiveDate', 'AdjustableOrRelativeDate', 0),
        'terminationDate': MemberSpec_('terminationDate', 'AdjustableOrRelativeDate', 0),
        'calculationPeriodsSchedule': MemberSpec_('calculationPeriodsSchedule', 'CommodityCalculationPeriodsSchedule', 0),
        'calculationPeriods': MemberSpec_('calculationPeriods', 'AdjustableDates', 0),
        'pricingDates': MemberSpec_('pricingDates', 'CommodityPricingDates', 0),
        'averagingMethod': MemberSpec_('averagingMethod', ['AveragingMethodEnum', 'Token', 'xsd:token'], 0),
        'barrier': MemberSpec_('barrier', 'CommodityBarrier', 0),
        'barrier': MemberSpec_('barrier', 'CommodityBarrier', 0),
        'notionalQuantitySchedule': MemberSpec_('notionalQuantitySchedule', 'CommodityNotionalQuantitySchedule', 0),
        'notionalQuantity': MemberSpec_('notionalQuantity', 'CommodityNotionalQuantity', 0),
        'settlementPeriodsNotionalQuantity': MemberSpec_('settlementPeriodsNotionalQuantity', 'CommoditySettlementPeriodsNotionalQuantity', 1),
        'totalNotionalQuantity': MemberSpec_('totalNotionalQuantity', 'xsd:decimal', 0),
        'quantityReference': MemberSpec_('quantityReference', 'QuantityReference', 0),
        'exercise': MemberSpec_('exercise', 'Exercise', 0),
        'strikePricePerUnit': MemberSpec_('strikePricePerUnit', 'NonNegativeMoney', 0),
        'strikePricePerUnitSchedule': MemberSpec_('strikePricePerUnitSchedule', 'CommodityStrikeSchedule', 0),
        'floatingStrikePricePerUnit': MemberSpec_('floatingStrikePricePerUnit', 'FloatingStrikePrice', 0),
        'floatingStrikePricePerUnitSchedule': MemberSpec_('floatingStrikePricePerUnitSchedule', 'CommodityCalculationPeriodsSchedule', 0),
        'commoditySwap': MemberSpec_('commoditySwap', 'CommoditySwap', 0),
        'commodityForward': MemberSpec_('commodityForward', 'CommodityForward', 0),
        'physicalExercise': MemberSpec_('physicalExercise', 'CommodityPhysicalExercise', 0),
        'effectiveDate': MemberSpec_('effectiveDate', 'AdjustableOrRelativeDate', 0),
        'weatherCalculationPeriods': MemberSpec_('weatherCalculationPeriods', 'WeatherCalculationPeriods', 0),
        'weatherCalculationPeriodsReference': MemberSpec_('weatherCalculationPeriodsReference', 'CalculationPeriodsReference', 0),
        'weatherNotionalAmount': MemberSpec_('weatherNotionalAmount', 'NonNegativeMoney', 0),
        'exercise': MemberSpec_('exercise', 'Exercise', 0),
        'weatherIndexStrikeLevel': MemberSpec_('weatherIndexStrikeLevel', 'WeatherIndex', 0),
        'calculation': MemberSpec_('calculation', 'WeatherLegCalculation', 0),
        'weatherIndexData': MemberSpec_('weatherIndexData', 'WeatherIndexData', 0),
        'premium': MemberSpec_('premium', 'CommodityPremium', 1),
        'commonPricing': MemberSpec_('commonPricing', 'xsd:boolean', 0),
        'marketDisruption': MemberSpec_('marketDisruption', 'CommodityMarketDisruption', 0),
        'settlementDisruption': MemberSpec_('settlementDisruption', ['CommodityBullionSettlementDisruptionEnum', 'Token', 'xsd:token'], 0),
        'rounding': MemberSpec_('rounding', 'Rounding', 0),
    }
    subclass = None
    superclass = Product
    def __init__(self, id=None, primaryAssetClass=None, secondaryAssetClass=None, productType=None, productId=None, assetClass=None, embeddedOptionType=None, buyerPartyReference=None, buyerAccountReference=None, sellerPartyReference=None, sellerAccountReference=None, optionType=None, commodity=None, effectiveDate=None, terminationDate=None, calculationPeriodsSchedule=None, calculationPeriods=None, pricingDates=None, averagingMethod=None, barrier=None, notionalQuantitySchedule=None, notionalQuantity=None, settlementPeriodsNotionalQuantity=None, totalNotionalQuantity=None, quantityReference=None, exercise=None, strikePricePerUnit=None, strikePricePerUnitSchedule=None, floatingStrikePricePerUnit=None, floatingStrikePricePerUnitSchedule=None, commoditySwap=None, commodityForward=None, physicalExercise=None, weatherCalculationPeriods=None, weatherCalculationPeriodsReference=None, weatherNotionalAmount=None, weatherIndexStrikeLevel=None, calculation=None, weatherIndexData=None, premium=None, commonPricing=None, marketDisruption=None, settlementDisruption=None, rounding=None):
        self.original_tagname_ = None
        super(CommodityOption, self).__init__(id, primaryAssetClass, secondaryAssetClass, productType, productId, assetClass, embeddedOptionType, )
        self.buyerPartyReference = buyerPartyReference
        self.buyerAccountReference = buyerAccountReference
        self.sellerPartyReference = sellerPartyReference
        self.sellerAccountReference = sellerAccountReference
        self.optionType = optionType
        self.validate_PutCallEnum(self.optionType)
        self.commodity = commodity
        self.effectiveDate = effectiveDate
        self.terminationDate = terminationDate
        self.calculationPeriodsSchedule = calculationPeriodsSchedule
        self.calculationPeriods = calculationPeriods
        self.pricingDates = pricingDates
        self.averagingMethod = averagingMethod
        self.validate_AveragingMethodEnum(self.averagingMethod)
        self.barrier = barrier
        self.barrier = barrier
        self.notionalQuantitySchedule = notionalQuantitySchedule
        self.notionalQuantity = notionalQuantity
        if settlementPeriodsNotionalQuantity is None:
            self.settlementPeriodsNotionalQuantity = []
        else:
            self.settlementPeriodsNotionalQuantity = settlementPeriodsNotionalQuantity
        self.totalNotionalQuantity = totalNotionalQuantity
        self.quantityReference = quantityReference
        self.exercise = exercise
        self.strikePricePerUnit = strikePricePerUnit
        self.strikePricePerUnitSchedule = strikePricePerUnitSchedule
        self.floatingStrikePricePerUnit = floatingStrikePricePerUnit
        self.floatingStrikePricePerUnitSchedule = floatingStrikePricePerUnitSchedule
        self.commoditySwap = commoditySwap
        self.commodityForward = commodityForward
        self.physicalExercise = physicalExercise
        self.effectiveDate = effectiveDate
        self.weatherCalculationPeriods = weatherCalculationPeriods
        self.weatherCalculationPeriodsReference = weatherCalculationPeriodsReference
        self.weatherNotionalAmount = weatherNotionalAmount
        self.exercise = exercise
        self.weatherIndexStrikeLevel = weatherIndexStrikeLevel
        self.calculation = calculation
        self.weatherIndexData = weatherIndexData
        if premium is None:
            self.premium = []
        else:
            self.premium = premium
        self.commonPricing = commonPricing
        self.marketDisruption = marketDisruption
        self.settlementDisruption = settlementDisruption
        self.validate_CommodityBullionSettlementDisruptionEnum(self.settlementDisruption)
        self.rounding = rounding
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityOption)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityOption.subclass:
            return CommodityOption.subclass(*args_, **kwargs_)
        else:
            return CommodityOption(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_buyerPartyReference(self): return self.buyerPartyReference
    def set_buyerPartyReference(self, buyerPartyReference): self.buyerPartyReference = buyerPartyReference
    def get_buyerAccountReference(self): return self.buyerAccountReference
    def set_buyerAccountReference(self, buyerAccountReference): self.buyerAccountReference = buyerAccountReference
    def get_sellerPartyReference(self): return self.sellerPartyReference
    def set_sellerPartyReference(self, sellerPartyReference): self.sellerPartyReference = sellerPartyReference
    def get_sellerAccountReference(self): return self.sellerAccountReference
    def set_sellerAccountReference(self, sellerAccountReference): self.sellerAccountReference = sellerAccountReference
    def get_optionType(self): return self.optionType
    def set_optionType(self, optionType): self.optionType = optionType
    def get_commodity(self): return self.commodity
    def set_commodity(self, commodity): self.commodity = commodity
    def get_effectiveDate(self): return self.effectiveDate
    def set_effectiveDate(self, effectiveDate): self.effectiveDate = effectiveDate
    def get_terminationDate(self): return self.terminationDate
    def set_terminationDate(self, terminationDate): self.terminationDate = terminationDate
    def get_calculationPeriodsSchedule(self): return self.calculationPeriodsSchedule
    def set_calculationPeriodsSchedule(self, calculationPeriodsSchedule): self.calculationPeriodsSchedule = calculationPeriodsSchedule
    def get_calculationPeriods(self): return self.calculationPeriods
    def set_calculationPeriods(self, calculationPeriods): self.calculationPeriods = calculationPeriods
    def get_pricingDates(self): return self.pricingDates
    def set_pricingDates(self, pricingDates): self.pricingDates = pricingDates
    def get_averagingMethod(self): return self.averagingMethod
    def set_averagingMethod(self, averagingMethod): self.averagingMethod = averagingMethod
    def get_barrier(self): return self.barrier
    def set_barrier(self, barrier): self.barrier = barrier
    def get_barrier(self): return self.barrier
    def set_barrier(self, barrier): self.barrier = barrier
    def get_notionalQuantitySchedule(self): return self.notionalQuantitySchedule
    def set_notionalQuantitySchedule(self, notionalQuantitySchedule): self.notionalQuantitySchedule = notionalQuantitySchedule
    def get_notionalQuantity(self): return self.notionalQuantity
    def set_notionalQuantity(self, notionalQuantity): self.notionalQuantity = notionalQuantity
    def get_settlementPeriodsNotionalQuantity(self): return self.settlementPeriodsNotionalQuantity
    def set_settlementPeriodsNotionalQuantity(self, settlementPeriodsNotionalQuantity): self.settlementPeriodsNotionalQuantity = settlementPeriodsNotionalQuantity
    def add_settlementPeriodsNotionalQuantity(self, value): self.settlementPeriodsNotionalQuantity.append(value)
    def insert_settlementPeriodsNotionalQuantity_at(self, index, value): self.settlementPeriodsNotionalQuantity.insert(index, value)
    def replace_settlementPeriodsNotionalQuantity_at(self, index, value): self.settlementPeriodsNotionalQuantity[index] = value
    def get_totalNotionalQuantity(self): return self.totalNotionalQuantity
    def set_totalNotionalQuantity(self, totalNotionalQuantity): self.totalNotionalQuantity = totalNotionalQuantity
    def get_quantityReference(self): return self.quantityReference
    def set_quantityReference(self, quantityReference): self.quantityReference = quantityReference
    def get_exercise(self): return self.exercise
    def set_exercise(self, exercise): self.exercise = exercise
    def get_strikePricePerUnit(self): return self.strikePricePerUnit
    def set_strikePricePerUnit(self, strikePricePerUnit): self.strikePricePerUnit = strikePricePerUnit
    def get_strikePricePerUnitSchedule(self): return self.strikePricePerUnitSchedule
    def set_strikePricePerUnitSchedule(self, strikePricePerUnitSchedule): self.strikePricePerUnitSchedule = strikePricePerUnitSchedule
    def get_floatingStrikePricePerUnit(self): return self.floatingStrikePricePerUnit
    def set_floatingStrikePricePerUnit(self, floatingStrikePricePerUnit): self.floatingStrikePricePerUnit = floatingStrikePricePerUnit
    def get_floatingStrikePricePerUnitSchedule(self): return self.floatingStrikePricePerUnitSchedule
    def set_floatingStrikePricePerUnitSchedule(self, floatingStrikePricePerUnitSchedule): self.floatingStrikePricePerUnitSchedule = floatingStrikePricePerUnitSchedule
    def get_commoditySwap(self): return self.commoditySwap
    def set_commoditySwap(self, commoditySwap): self.commoditySwap = commoditySwap
    def get_commodityForward(self): return self.commodityForward
    def set_commodityForward(self, commodityForward): self.commodityForward = commodityForward
    def get_physicalExercise(self): return self.physicalExercise
    def set_physicalExercise(self, physicalExercise): self.physicalExercise = physicalExercise
    def get_effectiveDate(self): return self.effectiveDate
    def set_effectiveDate(self, effectiveDate): self.effectiveDate = effectiveDate
    def get_weatherCalculationPeriods(self): return self.weatherCalculationPeriods
    def set_weatherCalculationPeriods(self, weatherCalculationPeriods): self.weatherCalculationPeriods = weatherCalculationPeriods
    def get_weatherCalculationPeriodsReference(self): return self.weatherCalculationPeriodsReference
    def set_weatherCalculationPeriodsReference(self, weatherCalculationPeriodsReference): self.weatherCalculationPeriodsReference = weatherCalculationPeriodsReference
    def get_weatherNotionalAmount(self): return self.weatherNotionalAmount
    def set_weatherNotionalAmount(self, weatherNotionalAmount): self.weatherNotionalAmount = weatherNotionalAmount
    def get_exercise(self): return self.exercise
    def set_exercise(self, exercise): self.exercise = exercise
    def get_weatherIndexStrikeLevel(self): return self.weatherIndexStrikeLevel
    def set_weatherIndexStrikeLevel(self, weatherIndexStrikeLevel): self.weatherIndexStrikeLevel = weatherIndexStrikeLevel
    def get_calculation(self): return self.calculation
    def set_calculation(self, calculation): self.calculation = calculation
    def get_weatherIndexData(self): return self.weatherIndexData
    def set_weatherIndexData(self, weatherIndexData): self.weatherIndexData = weatherIndexData
    def get_premium(self): return self.premium
    def set_premium(self, premium): self.premium = premium
    def add_premium(self, value): self.premium.append(value)
    def insert_premium_at(self, index, value): self.premium.insert(index, value)
    def replace_premium_at(self, index, value): self.premium[index] = value
    def get_commonPricing(self): return self.commonPricing
    def set_commonPricing(self, commonPricing): self.commonPricing = commonPricing
    def get_marketDisruption(self): return self.marketDisruption
    def set_marketDisruption(self, marketDisruption): self.marketDisruption = marketDisruption
    def get_settlementDisruption(self): return self.settlementDisruption
    def set_settlementDisruption(self, settlementDisruption): self.settlementDisruption = settlementDisruption
    def get_rounding(self): return self.rounding
    def set_rounding(self, rounding): self.rounding = rounding
    def validate_PutCallEnum(self, value):
        # Validate type PutCallEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Put', 'Call']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PutCallEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on PutCallEnum' % {"value" : value} )
    def validate_AveragingMethodEnum(self, value):
        # Validate type AveragingMethodEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Unweighted', 'Weighted']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AveragingMethodEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on AveragingMethodEnum' % {"value" : value} )
    def validate_CommodityBullionSettlementDisruptionEnum(self, value):
        # Validate type CommodityBullionSettlementDisruptionEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Negotiation', 'Cancellation and Payment']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CommodityBullionSettlementDisruptionEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on CommodityBullionSettlementDisruptionEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.buyerPartyReference is not None or
            self.buyerAccountReference is not None or
            self.sellerPartyReference is not None or
            self.sellerAccountReference is not None or
            self.optionType is not None or
            self.commodity is not None or
            self.effectiveDate is not None or
            self.terminationDate is not None or
            self.calculationPeriodsSchedule is not None or
            self.calculationPeriods is not None or
            self.pricingDates is not None or
            self.averagingMethod is not None or
            self.barrier is not None or
            self.barrier is not None or
            self.notionalQuantitySchedule is not None or
            self.notionalQuantity is not None or
            self.settlementPeriodsNotionalQuantity or
            self.totalNotionalQuantity is not None or
            self.quantityReference is not None or
            self.exercise is not None or
            self.strikePricePerUnit is not None or
            self.strikePricePerUnitSchedule is not None or
            self.floatingStrikePricePerUnit is not None or
            self.floatingStrikePricePerUnitSchedule is not None or
            self.commoditySwap is not None or
            self.commodityForward is not None or
            self.physicalExercise is not None or
            self.effectiveDate is not None or
            self.weatherCalculationPeriods is not None or
            self.weatherCalculationPeriodsReference is not None or
            self.weatherNotionalAmount is not None or
            self.exercise is not None or
            self.weatherIndexStrikeLevel is not None or
            self.calculation is not None or
            self.weatherIndexData is not None or
            self.premium or
            self.commonPricing is not None or
            self.marketDisruption is not None or
            self.settlementDisruption is not None or
            self.rounding is not None or
            super(CommodityOption, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityOption', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityOption')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityOption', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityOption'):
        super(CommodityOption, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityOption')
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityOption', fromsubclass_=False, pretty_print=True):
        super(CommodityOption, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.buyerPartyReference is not None:
            self.buyerPartyReference.export(outfile, level, namespace_, name_='buyerPartyReference', pretty_print=pretty_print)
        if self.buyerAccountReference is not None:
            self.buyerAccountReference.export(outfile, level, namespace_, name_='buyerAccountReference', pretty_print=pretty_print)
        if self.sellerPartyReference is not None:
            self.sellerPartyReference.export(outfile, level, namespace_, name_='sellerPartyReference', pretty_print=pretty_print)
        if self.sellerAccountReference is not None:
            self.sellerAccountReference.export(outfile, level, namespace_, name_='sellerAccountReference', pretty_print=pretty_print)
        if self.optionType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soptionType>%s</%soptionType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.optionType), input_name='optionType')), namespace_, eol_))
        if self.commodity is not None:
            self.commodity.export(outfile, level, namespace_, name_='commodity', pretty_print=pretty_print)
        if self.effectiveDate is not None:
            self.effectiveDate.export(outfile, level, namespace_, name_='effectiveDate', pretty_print=pretty_print)
        if self.terminationDate is not None:
            self.terminationDate.export(outfile, level, namespace_, name_='terminationDate', pretty_print=pretty_print)
        if self.calculationPeriodsSchedule is not None:
            self.calculationPeriodsSchedule.export(outfile, level, namespace_, name_='calculationPeriodsSchedule', pretty_print=pretty_print)
        if self.calculationPeriods is not None:
            self.calculationPeriods.export(outfile, level, namespace_, name_='calculationPeriods', pretty_print=pretty_print)
        if self.pricingDates is not None:
            self.pricingDates.export(outfile, level, namespace_, name_='pricingDates', pretty_print=pretty_print)
        if self.averagingMethod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saveragingMethod>%s</%saveragingMethod>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.averagingMethod), input_name='averagingMethod')), namespace_, eol_))
        if self.barrier is not None:
            self.barrier.export(outfile, level, namespace_, name_='barrier', pretty_print=pretty_print)
        if self.barrier is not None:
            self.barrier.export(outfile, level, namespace_, name_='barrier', pretty_print=pretty_print)
        if self.notionalQuantitySchedule is not None:
            self.notionalQuantitySchedule.export(outfile, level, namespace_, name_='notionalQuantitySchedule', pretty_print=pretty_print)
        if self.notionalQuantity is not None:
            self.notionalQuantity.export(outfile, level, namespace_, name_='notionalQuantity', pretty_print=pretty_print)
        for settlementPeriodsNotionalQuantity_ in self.settlementPeriodsNotionalQuantity:
            settlementPeriodsNotionalQuantity_.export(outfile, level, namespace_, name_='settlementPeriodsNotionalQuantity', pretty_print=pretty_print)
        if self.totalNotionalQuantity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalNotionalQuantity>%s</%stotalNotionalQuantity>%s' % (namespace_, self.gds_format_float(self.totalNotionalQuantity, input_name='totalNotionalQuantity'), namespace_, eol_))
        if self.quantityReference is not None:
            self.quantityReference.export(outfile, level, namespace_, name_='quantityReference', pretty_print=pretty_print)
        if self.exercise is not None:
            self.exercise.export(outfile, level, namespace_, name_='exercise', pretty_print=pretty_print)
        if self.strikePricePerUnit is not None:
            self.strikePricePerUnit.export(outfile, level, namespace_, name_='strikePricePerUnit', pretty_print=pretty_print)
        if self.strikePricePerUnitSchedule is not None:
            self.strikePricePerUnitSchedule.export(outfile, level, namespace_, name_='strikePricePerUnitSchedule', pretty_print=pretty_print)
        if self.floatingStrikePricePerUnit is not None:
            self.floatingStrikePricePerUnit.export(outfile, level, namespace_, name_='floatingStrikePricePerUnit', pretty_print=pretty_print)
        if self.floatingStrikePricePerUnitSchedule is not None:
            self.floatingStrikePricePerUnitSchedule.export(outfile, level, namespace_, name_='floatingStrikePricePerUnitSchedule', pretty_print=pretty_print)
        if self.commoditySwap is not None:
            self.commoditySwap.export(outfile, level, namespace_, name_='commoditySwap', pretty_print=pretty_print)
        if self.commodityForward is not None:
            self.commodityForward.export(outfile, level, namespace_, name_='commodityForward', pretty_print=pretty_print)
        if self.physicalExercise is not None:
            self.physicalExercise.export(outfile, level, namespace_, name_='physicalExercise', pretty_print=pretty_print)
        if self.effectiveDate is not None:
            self.effectiveDate.export(outfile, level, namespace_, name_='effectiveDate', pretty_print=pretty_print)
        if self.weatherCalculationPeriods is not None:
            self.weatherCalculationPeriods.export(outfile, level, namespace_, name_='weatherCalculationPeriods', pretty_print=pretty_print)
        if self.weatherCalculationPeriodsReference is not None:
            self.weatherCalculationPeriodsReference.export(outfile, level, namespace_, name_='weatherCalculationPeriodsReference', pretty_print=pretty_print)
        if self.weatherNotionalAmount is not None:
            self.weatherNotionalAmount.export(outfile, level, namespace_, name_='weatherNotionalAmount', pretty_print=pretty_print)
        if self.exercise is not None:
            self.exercise.export(outfile, level, namespace_, name_='exercise', pretty_print=pretty_print)
        if self.weatherIndexStrikeLevel is not None:
            self.weatherIndexStrikeLevel.export(outfile, level, namespace_, name_='weatherIndexStrikeLevel', pretty_print=pretty_print)
        if self.calculation is not None:
            self.calculation.export(outfile, level, namespace_, name_='calculation', pretty_print=pretty_print)
        if self.weatherIndexData is not None:
            self.weatherIndexData.export(outfile, level, namespace_, name_='weatherIndexData', pretty_print=pretty_print)
        for premium_ in self.premium:
            premium_.export(outfile, level, namespace_, name_='premium', pretty_print=pretty_print)
        if self.commonPricing is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scommonPricing>%s</%scommonPricing>%s' % (namespace_, self.gds_format_boolean(self.commonPricing, input_name='commonPricing'), namespace_, eol_))
        if self.marketDisruption is not None:
            self.marketDisruption.export(outfile, level, namespace_, name_='marketDisruption', pretty_print=pretty_print)
        if self.settlementDisruption is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssettlementDisruption>%s</%ssettlementDisruption>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.settlementDisruption), input_name='settlementDisruption')), namespace_, eol_))
        if self.rounding is not None:
            self.rounding.export(outfile, level, namespace_, name_='rounding', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CommodityOption, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'buyerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.buyerPartyReference = obj_
            obj_.original_tagname_ = 'buyerPartyReference'
        elif nodeName_ == 'buyerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.buyerAccountReference = obj_
            obj_.original_tagname_ = 'buyerAccountReference'
        elif nodeName_ == 'sellerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.sellerPartyReference = obj_
            obj_.original_tagname_ = 'sellerPartyReference'
        elif nodeName_ == 'sellerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.sellerAccountReference = obj_
            obj_.original_tagname_ = 'sellerAccountReference'
        elif nodeName_ == 'optionType':
            optionType_ = child_.text
            optionType_ = re_.sub(String_cleanup_pat_, " ", optionType_).strip()
            optionType_ = self.gds_validate_string(optionType_, node, 'optionType')
            self.optionType = optionType_
            # validate type PutCallEnum
            self.validate_PutCallEnum(self.optionType)
        elif nodeName_ == 'commodity':
            obj_ = Commodity.factory()
            obj_.build(child_)
            self.commodity = obj_
            obj_.original_tagname_ = 'commodity'
        elif nodeName_ == 'effectiveDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.effectiveDate = obj_
            obj_.original_tagname_ = 'effectiveDate'
        elif nodeName_ == 'terminationDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.terminationDate = obj_
            obj_.original_tagname_ = 'terminationDate'
        elif nodeName_ == 'calculationPeriodsSchedule':
            obj_ = CommodityCalculationPeriodsSchedule.factory()
            obj_.build(child_)
            self.calculationPeriodsSchedule = obj_
            obj_.original_tagname_ = 'calculationPeriodsSchedule'
        elif nodeName_ == 'calculationPeriods':
            obj_ = AdjustableDates.factory()
            obj_.build(child_)
            self.calculationPeriods = obj_
            obj_.original_tagname_ = 'calculationPeriods'
        elif nodeName_ == 'pricingDates':
            obj_ = CommodityPricingDates.factory()
            obj_.build(child_)
            self.pricingDates = obj_
            obj_.original_tagname_ = 'pricingDates'
        elif nodeName_ == 'averagingMethod':
            averagingMethod_ = child_.text
            averagingMethod_ = re_.sub(String_cleanup_pat_, " ", averagingMethod_).strip()
            averagingMethod_ = self.gds_validate_string(averagingMethod_, node, 'averagingMethod')
            self.averagingMethod = averagingMethod_
            # validate type AveragingMethodEnum
            self.validate_AveragingMethodEnum(self.averagingMethod)
        elif nodeName_ == 'barrier':
            obj_ = CommodityBarrier.factory()
            obj_.build(child_)
            self.barrier = obj_
            obj_.original_tagname_ = 'barrier'
        elif nodeName_ == 'barrier':
            obj_ = CommodityBarrier.factory()
            obj_.build(child_)
            self.barrier = obj_
            obj_.original_tagname_ = 'barrier'
        elif nodeName_ == 'notionalQuantitySchedule':
            obj_ = CommodityNotionalQuantitySchedule.factory()
            obj_.build(child_)
            self.notionalQuantitySchedule = obj_
            obj_.original_tagname_ = 'notionalQuantitySchedule'
        elif nodeName_ == 'notionalQuantity':
            class_obj_ = self.get_class_obj_(child_, CommodityNotionalQuantity)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.notionalQuantity = obj_
            obj_.original_tagname_ = 'notionalQuantity'
        elif nodeName_ == 'settlementPeriodsNotionalQuantity':
            obj_ = CommoditySettlementPeriodsNotionalQuantity.factory()
            obj_.build(child_)
            self.settlementPeriodsNotionalQuantity.append(obj_)
            obj_.original_tagname_ = 'settlementPeriodsNotionalQuantity'
        elif nodeName_ == 'totalNotionalQuantity':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'totalNotionalQuantity')
            self.totalNotionalQuantity = fval_
        elif nodeName_ == 'quantityReference':
            obj_ = QuantityReference.factory()
            obj_.build(child_)
            self.quantityReference = obj_
            obj_.original_tagname_ = 'quantityReference'
        elif nodeName_ == 'exercise':
            obj_ = CommodityExercise.factory()
            obj_.build(child_)
            self.exercise = obj_
            obj_.original_tagname_ = 'exercise'
        elif nodeName_ == 'americanExercise':
            obj_ = AmericanExercise.factory()
            obj_.build(child_)
            self.exercise = obj_
            obj_.original_tagname_ = 'americanExercise'
        elif nodeName_ == 'bermudaExercise':
            obj_ = BermudaExercise.factory()
            obj_.build(child_)
            self.exercise = obj_
            obj_.original_tagname_ = 'bermudaExercise'
        elif nodeName_ == 'europeanExercise':
            obj_ = EuropeanExercise.factory()
            obj_.build(child_)
            self.exercise = obj_
            obj_.original_tagname_ = 'europeanExercise'
        elif nodeName_ == 'strikePricePerUnit':
            class_obj_ = self.get_class_obj_(child_, NonNegativeMoney)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.strikePricePerUnit = obj_
            obj_.original_tagname_ = 'strikePricePerUnit'
        elif nodeName_ == 'strikePricePerUnitSchedule':
            obj_ = CommodityStrikeSchedule.factory()
            obj_.build(child_)
            self.strikePricePerUnitSchedule = obj_
            obj_.original_tagname_ = 'strikePricePerUnitSchedule'
        elif nodeName_ == 'floatingStrikePricePerUnit':
            obj_ = FloatingStrikePrice.factory()
            obj_.build(child_)
            self.floatingStrikePricePerUnit = obj_
            obj_.original_tagname_ = 'floatingStrikePricePerUnit'
        elif nodeName_ == 'floatingStrikePricePerUnitSchedule':
            obj_ = CommodityCalculationPeriodsSchedule.factory()
            obj_.build(child_)
            self.floatingStrikePricePerUnitSchedule = obj_
            obj_.original_tagname_ = 'floatingStrikePricePerUnitSchedule'
        elif nodeName_ == 'commoditySwap':
            obj_ = CommoditySwap.factory()
            obj_.build(child_)
            self.commoditySwap = obj_
            obj_.original_tagname_ = 'commoditySwap'
        elif nodeName_ == 'commodityForward':
            obj_ = CommodityForward.factory()
            obj_.build(child_)
            self.commodityForward = obj_
            obj_.original_tagname_ = 'commodityForward'
        elif nodeName_ == 'physicalExercise':
            obj_ = CommodityPhysicalExercise.factory()
            obj_.build(child_)
            self.physicalExercise = obj_
            obj_.original_tagname_ = 'physicalExercise'
        elif nodeName_ == 'effectiveDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.effectiveDate = obj_
            obj_.original_tagname_ = 'effectiveDate'
        elif nodeName_ == 'weatherCalculationPeriods':
            obj_ = WeatherCalculationPeriods.factory()
            obj_.build(child_)
            self.weatherCalculationPeriods = obj_
            obj_.original_tagname_ = 'weatherCalculationPeriods'
        elif nodeName_ == 'weatherCalculationPeriodsReference':
            obj_ = CalculationPeriodsReference.factory()
            obj_.build(child_)
            self.weatherCalculationPeriodsReference = obj_
            obj_.original_tagname_ = 'weatherCalculationPeriodsReference'
        elif nodeName_ == 'weatherNotionalAmount':
            class_obj_ = self.get_class_obj_(child_, NonNegativeMoney)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.weatherNotionalAmount = obj_
            obj_.original_tagname_ = 'weatherNotionalAmount'
        elif nodeName_ == 'exercise':
            obj_ = CommodityExercise.factory()
            obj_.build(child_)
            self.exercise = obj_
            obj_.original_tagname_ = 'exercise'
        elif nodeName_ == 'americanExercise':
            obj_ = AmericanExercise.factory()
            obj_.build(child_)
            self.exercise = obj_
            obj_.original_tagname_ = 'americanExercise'
        elif nodeName_ == 'bermudaExercise':
            obj_ = BermudaExercise.factory()
            obj_.build(child_)
            self.exercise = obj_
            obj_.original_tagname_ = 'bermudaExercise'
        elif nodeName_ == 'europeanExercise':
            obj_ = EuropeanExercise.factory()
            obj_.build(child_)
            self.exercise = obj_
            obj_.original_tagname_ = 'europeanExercise'
        elif nodeName_ == 'weatherIndexStrikeLevel':
            obj_ = WeatherIndex.factory()
            obj_.build(child_)
            self.weatherIndexStrikeLevel = obj_
            obj_.original_tagname_ = 'weatherIndexStrikeLevel'
        elif nodeName_ == 'calculation':
            obj_ = WeatherLegCalculation.factory()
            obj_.build(child_)
            self.calculation = obj_
            obj_.original_tagname_ = 'calculation'
        elif nodeName_ == 'weatherIndexData':
            obj_ = WeatherIndexData.factory()
            obj_.build(child_)
            self.weatherIndexData = obj_
            obj_.original_tagname_ = 'weatherIndexData'
        elif nodeName_ == 'premium':
            obj_ = CommodityPremium.factory()
            obj_.build(child_)
            self.premium.append(obj_)
            obj_.original_tagname_ = 'premium'
        elif nodeName_ == 'commonPricing':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'commonPricing')
            self.commonPricing = ival_
        elif nodeName_ == 'marketDisruption':
            obj_ = CommodityMarketDisruption.factory()
            obj_.build(child_)
            self.marketDisruption = obj_
            obj_.original_tagname_ = 'marketDisruption'
        elif nodeName_ == 'settlementDisruption':
            settlementDisruption_ = child_.text
            settlementDisruption_ = re_.sub(String_cleanup_pat_, " ", settlementDisruption_).strip()
            settlementDisruption_ = self.gds_validate_string(settlementDisruption_, node, 'settlementDisruption')
            self.settlementDisruption = settlementDisruption_
            # validate type CommodityBullionSettlementDisruptionEnum
            self.validate_CommodityBullionSettlementDisruptionEnum(self.settlementDisruption)
        elif nodeName_ == 'rounding':
            obj_ = Rounding.factory()
            obj_.build(child_)
            self.rounding = obj_
            obj_.original_tagname_ = 'rounding'
        super(CommodityOption, self).buildChildren(child_, node, nodeName_, True)
# end class CommodityOption


class CommodityNotionalAmountReference(Reference):
    """A reference to the return swap notional amount."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(CommodityNotionalAmountReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityNotionalAmountReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityNotionalAmountReference.subclass:
            return CommodityNotionalAmountReference.subclass(*args_, **kwargs_)
        else:
            return CommodityNotionalAmountReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(CommodityNotionalAmountReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityNotionalAmountReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityNotionalAmountReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityNotionalAmountReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityNotionalAmountReference'):
        super(CommodityNotionalAmountReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityNotionalAmountReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityNotionalAmountReference', fromsubclass_=False, pretty_print=True):
        super(CommodityNotionalAmountReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(CommodityNotionalAmountReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(CommodityNotionalAmountReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CommodityNotionalAmountReference


class CommodityNotionalAmount(NonNegativeMoney):
    """A complex type to specify the notional amount."""
    member_data_items_ = {
        'reinvestmentFeature': MemberSpec_('reinvestmentFeature', 'xsd:boolean', 0),
    }
    subclass = None
    superclass = NonNegativeMoney
    def __init__(self, id=None, currency=None, amount=None, reinvestmentFeature=None):
        self.original_tagname_ = None
        super(CommodityNotionalAmount, self).__init__(id, currency, amount, )
        self.reinvestmentFeature = reinvestmentFeature
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityNotionalAmount)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityNotionalAmount.subclass:
            return CommodityNotionalAmount.subclass(*args_, **kwargs_)
        else:
            return CommodityNotionalAmount(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_reinvestmentFeature(self): return self.reinvestmentFeature
    def set_reinvestmentFeature(self, reinvestmentFeature): self.reinvestmentFeature = reinvestmentFeature
    def hasContent_(self):
        if (
            self.reinvestmentFeature is not None or
            super(CommodityNotionalAmount, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityNotionalAmount', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityNotionalAmount')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityNotionalAmount', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityNotionalAmount'):
        super(CommodityNotionalAmount, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityNotionalAmount')
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityNotionalAmount', fromsubclass_=False, pretty_print=True):
        super(CommodityNotionalAmount, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.reinvestmentFeature is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreinvestmentFeature>%s</%sreinvestmentFeature>%s' % (namespace_, self.gds_format_boolean(self.reinvestmentFeature, input_name='reinvestmentFeature'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CommodityNotionalAmount, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'reinvestmentFeature':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'reinvestmentFeature')
            self.reinvestmentFeature = ival_
        super(CommodityNotionalAmount, self).buildChildren(child_, node, nodeName_, True)
# end class CommodityNotionalAmount


class CommodityInterestLeg(CommodityPerformanceSwapLeg):
    """A type describing the interest rate leg (a.k.a fee leg) of the
    commodity performance swap."""
    member_data_items_ = {
        'calculationDates': MemberSpec_('calculationDates', 'AdjustableDates', 0),
        'calculationPeriods': MemberSpec_('calculationPeriods', 'AdjustableDates', 0),
        'calculationPeriodsSchedule': MemberSpec_('calculationPeriodsSchedule', 'CommodityCalculationPeriodsSchedule', 0),
        'calculationPeriodsReference': MemberSpec_('calculationPeriodsReference', 'CalculationPeriodsReference', 0),
        'calculationPeriodsScheduleReference': MemberSpec_('calculationPeriodsScheduleReference', 'CalculationPeriodsScheduleReference', 0),
        'calculationPeriodsDatesReference': MemberSpec_('calculationPeriodsDatesReference', 'CalculationPeriodsDatesReference', 0),
        'relativePaymentDates': MemberSpec_('relativePaymentDates', 'CommodityRelativePaymentDates', 0),
        'paymentDates': MemberSpec_('paymentDates', 'AdjustableDatesOrRelativeDateOffset', 0),
        'masterAgreementPaymentDates': MemberSpec_('masterAgreementPaymentDates', 'xsd:boolean', 0),
        'notionalAmount': MemberSpec_('notionalAmount', 'CommodityNotionalAmount', 0),
        'notionalAmountReference': MemberSpec_('notionalAmountReference', 'CommodityNotionalAmountReference', 0),
        'commodityFixedInterestCalculation': MemberSpec_('commodityFixedInterestCalculation', 'CommodityFixedInterestCalculation', 0),
    }
    subclass = None
    superclass = CommodityPerformanceSwapLeg
    def __init__(self, id=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, calculationDates=None, calculationPeriods=None, calculationPeriodsSchedule=None, calculationPeriodsReference=None, calculationPeriodsScheduleReference=None, calculationPeriodsDatesReference=None, relativePaymentDates=None, paymentDates=None, masterAgreementPaymentDates=None, notionalAmount=None, notionalAmountReference=None, commodityFixedInterestCalculation=None):
        self.original_tagname_ = None
        super(CommodityInterestLeg, self).__init__(id, payerPartyReference, payerAccountReference, receiverPartyReference, receiverAccountReference, )
        self.calculationDates = calculationDates
        self.calculationPeriods = calculationPeriods
        self.calculationPeriodsSchedule = calculationPeriodsSchedule
        self.calculationPeriodsReference = calculationPeriodsReference
        self.calculationPeriodsScheduleReference = calculationPeriodsScheduleReference
        self.calculationPeriodsDatesReference = calculationPeriodsDatesReference
        self.relativePaymentDates = relativePaymentDates
        self.paymentDates = paymentDates
        self.masterAgreementPaymentDates = masterAgreementPaymentDates
        self.notionalAmount = notionalAmount
        self.notionalAmountReference = notionalAmountReference
        self.commodityFixedInterestCalculation = commodityFixedInterestCalculation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityInterestLeg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityInterestLeg.subclass:
            return CommodityInterestLeg.subclass(*args_, **kwargs_)
        else:
            return CommodityInterestLeg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_calculationDates(self): return self.calculationDates
    def set_calculationDates(self, calculationDates): self.calculationDates = calculationDates
    def get_calculationPeriods(self): return self.calculationPeriods
    def set_calculationPeriods(self, calculationPeriods): self.calculationPeriods = calculationPeriods
    def get_calculationPeriodsSchedule(self): return self.calculationPeriodsSchedule
    def set_calculationPeriodsSchedule(self, calculationPeriodsSchedule): self.calculationPeriodsSchedule = calculationPeriodsSchedule
    def get_calculationPeriodsReference(self): return self.calculationPeriodsReference
    def set_calculationPeriodsReference(self, calculationPeriodsReference): self.calculationPeriodsReference = calculationPeriodsReference
    def get_calculationPeriodsScheduleReference(self): return self.calculationPeriodsScheduleReference
    def set_calculationPeriodsScheduleReference(self, calculationPeriodsScheduleReference): self.calculationPeriodsScheduleReference = calculationPeriodsScheduleReference
    def get_calculationPeriodsDatesReference(self): return self.calculationPeriodsDatesReference
    def set_calculationPeriodsDatesReference(self, calculationPeriodsDatesReference): self.calculationPeriodsDatesReference = calculationPeriodsDatesReference
    def get_relativePaymentDates(self): return self.relativePaymentDates
    def set_relativePaymentDates(self, relativePaymentDates): self.relativePaymentDates = relativePaymentDates
    def get_paymentDates(self): return self.paymentDates
    def set_paymentDates(self, paymentDates): self.paymentDates = paymentDates
    def get_masterAgreementPaymentDates(self): return self.masterAgreementPaymentDates
    def set_masterAgreementPaymentDates(self, masterAgreementPaymentDates): self.masterAgreementPaymentDates = masterAgreementPaymentDates
    def get_notionalAmount(self): return self.notionalAmount
    def set_notionalAmount(self, notionalAmount): self.notionalAmount = notionalAmount
    def get_notionalAmountReference(self): return self.notionalAmountReference
    def set_notionalAmountReference(self, notionalAmountReference): self.notionalAmountReference = notionalAmountReference
    def get_commodityFixedInterestCalculation(self): return self.commodityFixedInterestCalculation
    def set_commodityFixedInterestCalculation(self, commodityFixedInterestCalculation): self.commodityFixedInterestCalculation = commodityFixedInterestCalculation
    def hasContent_(self):
        if (
            self.calculationDates is not None or
            self.calculationPeriods is not None or
            self.calculationPeriodsSchedule is not None or
            self.calculationPeriodsReference is not None or
            self.calculationPeriodsScheduleReference is not None or
            self.calculationPeriodsDatesReference is not None or
            self.relativePaymentDates is not None or
            self.paymentDates is not None or
            self.masterAgreementPaymentDates is not None or
            self.notionalAmount is not None or
            self.notionalAmountReference is not None or
            self.commodityFixedInterestCalculation is not None or
            super(CommodityInterestLeg, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityInterestLeg', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityInterestLeg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityInterestLeg', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityInterestLeg'):
        super(CommodityInterestLeg, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityInterestLeg')
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityInterestLeg', fromsubclass_=False, pretty_print=True):
        super(CommodityInterestLeg, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.calculationDates is not None:
            self.calculationDates.export(outfile, level, namespace_, name_='calculationDates', pretty_print=pretty_print)
        if self.calculationPeriods is not None:
            self.calculationPeriods.export(outfile, level, namespace_, name_='calculationPeriods', pretty_print=pretty_print)
        if self.calculationPeriodsSchedule is not None:
            self.calculationPeriodsSchedule.export(outfile, level, namespace_, name_='calculationPeriodsSchedule', pretty_print=pretty_print)
        if self.calculationPeriodsReference is not None:
            self.calculationPeriodsReference.export(outfile, level, namespace_, name_='calculationPeriodsReference', pretty_print=pretty_print)
        if self.calculationPeriodsScheduleReference is not None:
            self.calculationPeriodsScheduleReference.export(outfile, level, namespace_, name_='calculationPeriodsScheduleReference', pretty_print=pretty_print)
        if self.calculationPeriodsDatesReference is not None:
            self.calculationPeriodsDatesReference.export(outfile, level, namespace_, name_='calculationPeriodsDatesReference', pretty_print=pretty_print)
        if self.relativePaymentDates is not None:
            self.relativePaymentDates.export(outfile, level, namespace_, name_='relativePaymentDates', pretty_print=pretty_print)
        if self.paymentDates is not None:
            self.paymentDates.export(outfile, level, namespace_, name_='paymentDates', pretty_print=pretty_print)
        if self.masterAgreementPaymentDates is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smasterAgreementPaymentDates>%s</%smasterAgreementPaymentDates>%s' % (namespace_, self.gds_format_boolean(self.masterAgreementPaymentDates, input_name='masterAgreementPaymentDates'), namespace_, eol_))
        if self.notionalAmount is not None:
            self.notionalAmount.export(outfile, level, namespace_, name_='notionalAmount', pretty_print=pretty_print)
        if self.notionalAmountReference is not None:
            self.notionalAmountReference.export(outfile, level, namespace_, name_='notionalAmountReference', pretty_print=pretty_print)
        if self.commodityFixedInterestCalculation is not None:
            self.commodityFixedInterestCalculation.export(outfile, level, namespace_, name_='commodityFixedInterestCalculation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CommodityInterestLeg, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'calculationDates':
            obj_ = AdjustableDates.factory()
            obj_.build(child_)
            self.calculationDates = obj_
            obj_.original_tagname_ = 'calculationDates'
        elif nodeName_ == 'calculationPeriods':
            obj_ = AdjustableDates.factory()
            obj_.build(child_)
            self.calculationPeriods = obj_
            obj_.original_tagname_ = 'calculationPeriods'
        elif nodeName_ == 'calculationPeriodsSchedule':
            obj_ = CommodityCalculationPeriodsSchedule.factory()
            obj_.build(child_)
            self.calculationPeriodsSchedule = obj_
            obj_.original_tagname_ = 'calculationPeriodsSchedule'
        elif nodeName_ == 'calculationPeriodsReference':
            obj_ = CalculationPeriodsReference.factory()
            obj_.build(child_)
            self.calculationPeriodsReference = obj_
            obj_.original_tagname_ = 'calculationPeriodsReference'
        elif nodeName_ == 'calculationPeriodsScheduleReference':
            obj_ = CalculationPeriodsScheduleReference.factory()
            obj_.build(child_)
            self.calculationPeriodsScheduleReference = obj_
            obj_.original_tagname_ = 'calculationPeriodsScheduleReference'
        elif nodeName_ == 'calculationPeriodsDatesReference':
            obj_ = CalculationPeriodsDatesReference.factory()
            obj_.build(child_)
            self.calculationPeriodsDatesReference = obj_
            obj_.original_tagname_ = 'calculationPeriodsDatesReference'
        elif nodeName_ == 'relativePaymentDates':
            obj_ = CommodityRelativePaymentDates.factory()
            obj_.build(child_)
            self.relativePaymentDates = obj_
            obj_.original_tagname_ = 'relativePaymentDates'
        elif nodeName_ == 'paymentDates':
            obj_ = AdjustableDatesOrRelativeDateOffset.factory()
            obj_.build(child_)
            self.paymentDates = obj_
            obj_.original_tagname_ = 'paymentDates'
        elif nodeName_ == 'masterAgreementPaymentDates':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'masterAgreementPaymentDates')
            self.masterAgreementPaymentDates = ival_
        elif nodeName_ == 'notionalAmount':
            obj_ = CommodityNotionalAmount.factory()
            obj_.build(child_)
            self.notionalAmount = obj_
            obj_.original_tagname_ = 'notionalAmount'
        elif nodeName_ == 'notionalAmountReference':
            obj_ = CommodityNotionalAmountReference.factory()
            obj_.build(child_)
            self.notionalAmountReference = obj_
            obj_.original_tagname_ = 'notionalAmountReference'
        elif nodeName_ == 'commodityFixedInterestCalculation':
            obj_ = CommodityFixedInterestCalculation.factory()
            obj_.build(child_)
            self.commodityFixedInterestCalculation = obj_
            obj_.original_tagname_ = 'commodityFixedInterestCalculation'
        super(CommodityInterestLeg, self).buildChildren(child_, node, nodeName_, True)
# end class CommodityInterestLeg


class CommodityForwardLeg(Leg):
    """Abstract base class for all commodity forward legs"""
    member_data_items_ = {
    }
    subclass = None
    superclass = Leg
    def __init__(self, id=None, extensiontype_=None):
        self.original_tagname_ = None
        super(CommodityForwardLeg, self).__init__(id, extensiontype_, )
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityForwardLeg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityForwardLeg.subclass:
            return CommodityForwardLeg.subclass(*args_, **kwargs_)
        else:
            return CommodityForwardLeg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(CommodityForwardLeg, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityForwardLeg', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityForwardLeg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityForwardLeg', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityForwardLeg'):
        super(CommodityForwardLeg, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityForwardLeg')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityForwardLeg', fromsubclass_=False, pretty_print=True):
        super(CommodityForwardLeg, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(CommodityForwardLeg, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(CommodityForwardLeg, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CommodityForwardLeg


class CommodityForward(Product):
    """Commodity Forward"""
    member_data_items_ = {
        'valueDate': MemberSpec_('valueDate', 'AdjustableOrRelativeDate', 0),
        'fixedLeg': MemberSpec_('fixedLeg', 'FixedPriceLeg', 0),
        'averagePriceLeg': MemberSpec_('averagePriceLeg', 'AveragePriceLeg', 0),
        'commodityForwardLeg': MemberSpec_('commodityForwardLeg', 'CommodityForwardLeg', 0),
        'commonPricing': MemberSpec_('commonPricing', 'xsd:boolean', 0),
        'marketDisruption': MemberSpec_('marketDisruption', 'CommodityMarketDisruption', 0),
        'settlementDisruption': MemberSpec_('settlementDisruption', ['CommodityBullionSettlementDisruptionEnum', 'Token', 'xsd:token'], 0),
        'rounding': MemberSpec_('rounding', 'Rounding', 0),
    }
    subclass = None
    superclass = Product
    def __init__(self, id=None, primaryAssetClass=None, secondaryAssetClass=None, productType=None, productId=None, assetClass=None, embeddedOptionType=None, valueDate=None, fixedLeg=None, averagePriceLeg=None, commodityForwardLeg=None, commonPricing=None, marketDisruption=None, settlementDisruption=None, rounding=None):
        self.original_tagname_ = None
        super(CommodityForward, self).__init__(id, primaryAssetClass, secondaryAssetClass, productType, productId, assetClass, embeddedOptionType, )
        self.valueDate = valueDate
        self.fixedLeg = fixedLeg
        self.averagePriceLeg = averagePriceLeg
        self.commodityForwardLeg = commodityForwardLeg
        self.commonPricing = commonPricing
        self.marketDisruption = marketDisruption
        self.settlementDisruption = settlementDisruption
        self.validate_CommodityBullionSettlementDisruptionEnum(self.settlementDisruption)
        self.rounding = rounding
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityForward)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityForward.subclass:
            return CommodityForward.subclass(*args_, **kwargs_)
        else:
            return CommodityForward(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueDate(self): return self.valueDate
    def set_valueDate(self, valueDate): self.valueDate = valueDate
    def get_fixedLeg(self): return self.fixedLeg
    def set_fixedLeg(self, fixedLeg): self.fixedLeg = fixedLeg
    def get_averagePriceLeg(self): return self.averagePriceLeg
    def set_averagePriceLeg(self, averagePriceLeg): self.averagePriceLeg = averagePriceLeg
    def get_commodityForwardLeg(self): return self.commodityForwardLeg
    def set_commodityForwardLeg(self, commodityForwardLeg): self.commodityForwardLeg = commodityForwardLeg
    def get_commonPricing(self): return self.commonPricing
    def set_commonPricing(self, commonPricing): self.commonPricing = commonPricing
    def get_marketDisruption(self): return self.marketDisruption
    def set_marketDisruption(self, marketDisruption): self.marketDisruption = marketDisruption
    def get_settlementDisruption(self): return self.settlementDisruption
    def set_settlementDisruption(self, settlementDisruption): self.settlementDisruption = settlementDisruption
    def get_rounding(self): return self.rounding
    def set_rounding(self, rounding): self.rounding = rounding
    def validate_CommodityBullionSettlementDisruptionEnum(self, value):
        # Validate type CommodityBullionSettlementDisruptionEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Negotiation', 'Cancellation and Payment']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CommodityBullionSettlementDisruptionEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on CommodityBullionSettlementDisruptionEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.valueDate is not None or
            self.fixedLeg is not None or
            self.averagePriceLeg is not None or
            self.commodityForwardLeg is not None or
            self.commonPricing is not None or
            self.marketDisruption is not None or
            self.settlementDisruption is not None or
            self.rounding is not None or
            super(CommodityForward, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityForward', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityForward')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityForward', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityForward'):
        super(CommodityForward, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityForward')
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityForward', fromsubclass_=False, pretty_print=True):
        super(CommodityForward, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.valueDate is not None:
            self.valueDate.export(outfile, level, namespace_, name_='valueDate', pretty_print=pretty_print)
        if self.fixedLeg is not None:
            self.fixedLeg.export(outfile, level, namespace_, name_='fixedLeg', pretty_print=pretty_print)
        if self.averagePriceLeg is not None:
            self.averagePriceLeg.export(outfile, level, namespace_, name_='averagePriceLeg', pretty_print=pretty_print)
        if self.commodityForwardLeg is not None:
            self.commodityForwardLeg.export(outfile, level, namespace_, name_='commodityForwardLeg', pretty_print=pretty_print)
        if self.commonPricing is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scommonPricing>%s</%scommonPricing>%s' % (namespace_, self.gds_format_boolean(self.commonPricing, input_name='commonPricing'), namespace_, eol_))
        if self.marketDisruption is not None:
            self.marketDisruption.export(outfile, level, namespace_, name_='marketDisruption', pretty_print=pretty_print)
        if self.settlementDisruption is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssettlementDisruption>%s</%ssettlementDisruption>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.settlementDisruption), input_name='settlementDisruption')), namespace_, eol_))
        if self.rounding is not None:
            self.rounding.export(outfile, level, namespace_, name_='rounding', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CommodityForward, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'valueDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.valueDate = obj_
            obj_.original_tagname_ = 'valueDate'
        elif nodeName_ == 'fixedLeg':
            obj_ = NonPeriodicFixedPriceLeg.factory()
            obj_.build(child_)
            self.fixedLeg = obj_
            obj_.original_tagname_ = 'fixedLeg'
        elif nodeName_ == 'averagePriceLeg':
            obj_ = AveragePriceLeg.factory()
            obj_.build(child_)
            self.averagePriceLeg = obj_
            obj_.original_tagname_ = 'averagePriceLeg'
        elif nodeName_ == 'commodityForwardLeg':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <commodityForwardLeg> element')
            self.commodityForwardLeg = obj_
            obj_.original_tagname_ = 'commodityForwardLeg'
        elif nodeName_ == 'bullionPhysicalLeg':
            obj_ = BullionPhysicalLeg.factory()
            obj_.build(child_)
            self.commodityForwardLeg = obj_
            obj_.original_tagname_ = 'bullionPhysicalLeg'
        elif nodeName_ == 'metalPhysicalLeg':
            obj_ = MetalPhysicalLeg.factory()
            obj_.build(child_)
            self.commodityForwardLeg = obj_
            obj_.original_tagname_ = 'metalPhysicalLeg'
        elif nodeName_ == 'commonPricing':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'commonPricing')
            self.commonPricing = ival_
        elif nodeName_ == 'marketDisruption':
            obj_ = CommodityMarketDisruption.factory()
            obj_.build(child_)
            self.marketDisruption = obj_
            obj_.original_tagname_ = 'marketDisruption'
        elif nodeName_ == 'settlementDisruption':
            settlementDisruption_ = child_.text
            settlementDisruption_ = re_.sub(String_cleanup_pat_, " ", settlementDisruption_).strip()
            settlementDisruption_ = self.gds_validate_string(settlementDisruption_, node, 'settlementDisruption')
            self.settlementDisruption = settlementDisruption_
            # validate type CommodityBullionSettlementDisruptionEnum
            self.validate_CommodityBullionSettlementDisruptionEnum(self.settlementDisruption)
        elif nodeName_ == 'rounding':
            obj_ = Rounding.factory()
            obj_.build(child_)
            self.rounding = obj_
            obj_.original_tagname_ = 'rounding'
        super(CommodityForward, self).buildChildren(child_, node, nodeName_, True)
# end class CommodityForward


class CommodityEuropeanExercise(Exercise):
    """A type for defining exercise procedures associated with a European
    style exercise of a commodity option.Option Strip"""
    member_data_items_ = {
        'expirationDate': MemberSpec_('expirationDate', 'AdjustableOrRelativeDate', 0),
        'expirationDate': MemberSpec_('expirationDate', 'AdjustableOrRelativeDate', 1),
        'exerciseFrequency': MemberSpec_('exerciseFrequency', 'Frequency', 0),
        'expirationTime': MemberSpec_('expirationTime', 'BusinessCenterTime', 0),
    }
    subclass = None
    superclass = Exercise
    def __init__(self, id=None, expirationDate=None, exerciseFrequency=None, expirationTime=None):
        self.original_tagname_ = None
        super(CommodityEuropeanExercise, self).__init__(id, )
        self.expirationDate = expirationDate
        if expirationDate is None:
            self.expirationDate = []
        else:
            self.expirationDate = expirationDate
        self.exerciseFrequency = exerciseFrequency
        self.expirationTime = expirationTime
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityEuropeanExercise)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityEuropeanExercise.subclass:
            return CommodityEuropeanExercise.subclass(*args_, **kwargs_)
        else:
            return CommodityEuropeanExercise(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_expirationDate(self): return self.expirationDate
    def set_expirationDate(self, expirationDate): self.expirationDate = expirationDate
    def get_expirationDate(self): return self.expirationDate
    def set_expirationDate(self, expirationDate): self.expirationDate = expirationDate
    def add_expirationDate(self, value): self.expirationDate.append(value)
    def insert_expirationDate_at(self, index, value): self.expirationDate.insert(index, value)
    def replace_expirationDate_at(self, index, value): self.expirationDate[index] = value
    def get_exerciseFrequency(self): return self.exerciseFrequency
    def set_exerciseFrequency(self, exerciseFrequency): self.exerciseFrequency = exerciseFrequency
    def get_expirationTime(self): return self.expirationTime
    def set_expirationTime(self, expirationTime): self.expirationTime = expirationTime
    def hasContent_(self):
        if (
            self.expirationDate is not None or
            self.expirationDate or
            self.exerciseFrequency is not None or
            self.expirationTime is not None or
            super(CommodityEuropeanExercise, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityEuropeanExercise', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityEuropeanExercise')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityEuropeanExercise', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityEuropeanExercise'):
        super(CommodityEuropeanExercise, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityEuropeanExercise')
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityEuropeanExercise', fromsubclass_=False, pretty_print=True):
        super(CommodityEuropeanExercise, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.expirationDate is not None:
            self.expirationDate.export(outfile, level, namespace_, name_='expirationDate', pretty_print=pretty_print)
        for expirationDate_ in self.expirationDate:
            expirationDate_.export(outfile, level, namespace_, name_='expirationDate', pretty_print=pretty_print)
        if self.exerciseFrequency is not None:
            self.exerciseFrequency.export(outfile, level, namespace_, name_='exerciseFrequency', pretty_print=pretty_print)
        if self.expirationTime is not None:
            self.expirationTime.export(outfile, level, namespace_, name_='expirationTime', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CommodityEuropeanExercise, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'expirationDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.expirationDate = obj_
            obj_.original_tagname_ = 'expirationDate'
        elif nodeName_ == 'expirationDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.expirationDate.append(obj_)
            obj_.original_tagname_ = 'expirationDate'
        elif nodeName_ == 'exerciseFrequency':
            class_obj_ = self.get_class_obj_(child_, Frequency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.exerciseFrequency = obj_
            obj_.original_tagname_ = 'exerciseFrequency'
        elif nodeName_ == 'expirationTime':
            obj_ = BusinessCenterTime.factory()
            obj_.build(child_)
            self.expirationTime = obj_
            obj_.original_tagname_ = 'expirationTime'
        super(CommodityEuropeanExercise, self).buildChildren(child_, node, nodeName_, True)
# end class CommodityEuropeanExercise


class CommodityDigitalOption(Option):
    """Defines the digital commodity option product type. Digital options
    exercise when a barrier is breached and are financially settled.
    The 'commodityDigitalOption' type is an extension of the
    'commodityOption' product."""
    member_data_items_ = {
        'optionType': MemberSpec_('optionType', ['PutCallEnum', 'Token', 'xsd:token'], 0),
        'commodity': MemberSpec_('commodity', 'Commodity', 0),
        'effectiveDate': MemberSpec_('effectiveDate', 'AdjustableOrRelativeDate', 0),
        'terminationDate': MemberSpec_('terminationDate', 'AdjustableOrRelativeDate', 0),
        'calculationPeriodsSchedule': MemberSpec_('calculationPeriodsSchedule', 'CommodityCalculationPeriodsSchedule', 0),
        'calculationPeriods': MemberSpec_('calculationPeriods', 'AdjustableDates', 0),
        'pricingDates': MemberSpec_('pricingDates', 'CommodityPricingDates', 0),
        'averagingMethod': MemberSpec_('averagingMethod', ['AveragingMethodEnum', 'Token', 'xsd:token'], 0),
        'digital': MemberSpec_('digital', 'CommodityDigital', 0),
        'notionalAmount': MemberSpec_('notionalAmount', 'NotionalAmount', 0),
        'notionalQuantity': MemberSpec_('notionalQuantity', 'CommodityNotionalQuantity', 0),
        'totalNotionalQuantity': MemberSpec_('totalNotionalQuantity', 'xsd:decimal', 0),
        'exercise': MemberSpec_('exercise', 'Exercise', 0),
        'premium': MemberSpec_('premium', 'CommodityPremium', 1),
        'commonPricing': MemberSpec_('commonPricing', 'xsd:boolean', 0),
        'marketDisruption': MemberSpec_('marketDisruption', 'CommodityMarketDisruption', 0),
        'settlementDisruption': MemberSpec_('settlementDisruption', ['CommodityBullionSettlementDisruptionEnum', 'Token', 'xsd:token'], 0),
        'rounding': MemberSpec_('rounding', 'Rounding', 0),
    }
    subclass = None
    superclass = Option
    def __init__(self, id=None, primaryAssetClass=None, secondaryAssetClass=None, productType=None, productId=None, assetClass=None, embeddedOptionType=None, buyerPartyReference=None, buyerAccountReference=None, sellerPartyReference=None, sellerAccountReference=None, optionType=None, commodity=None, effectiveDate=None, terminationDate=None, calculationPeriodsSchedule=None, calculationPeriods=None, pricingDates=None, averagingMethod=None, digital=None, notionalAmount=None, notionalQuantity=None, totalNotionalQuantity=None, exercise=None, premium=None, commonPricing=None, marketDisruption=None, settlementDisruption=None, rounding=None):
        self.original_tagname_ = None
        super(CommodityDigitalOption, self).__init__(id, primaryAssetClass, secondaryAssetClass, productType, productId, assetClass, embeddedOptionType, buyerPartyReference, buyerAccountReference, sellerPartyReference, sellerAccountReference, )
        self.optionType = optionType
        self.validate_PutCallEnum(self.optionType)
        self.commodity = commodity
        self.effectiveDate = effectiveDate
        self.terminationDate = terminationDate
        self.calculationPeriodsSchedule = calculationPeriodsSchedule
        self.calculationPeriods = calculationPeriods
        self.pricingDates = pricingDates
        self.averagingMethod = averagingMethod
        self.validate_AveragingMethodEnum(self.averagingMethod)
        self.digital = digital
        self.notionalAmount = notionalAmount
        self.notionalQuantity = notionalQuantity
        self.totalNotionalQuantity = totalNotionalQuantity
        self.exercise = exercise
        if premium is None:
            self.premium = []
        else:
            self.premium = premium
        self.commonPricing = commonPricing
        self.marketDisruption = marketDisruption
        self.settlementDisruption = settlementDisruption
        self.validate_CommodityBullionSettlementDisruptionEnum(self.settlementDisruption)
        self.rounding = rounding
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityDigitalOption)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityDigitalOption.subclass:
            return CommodityDigitalOption.subclass(*args_, **kwargs_)
        else:
            return CommodityDigitalOption(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_optionType(self): return self.optionType
    def set_optionType(self, optionType): self.optionType = optionType
    def get_commodity(self): return self.commodity
    def set_commodity(self, commodity): self.commodity = commodity
    def get_effectiveDate(self): return self.effectiveDate
    def set_effectiveDate(self, effectiveDate): self.effectiveDate = effectiveDate
    def get_terminationDate(self): return self.terminationDate
    def set_terminationDate(self, terminationDate): self.terminationDate = terminationDate
    def get_calculationPeriodsSchedule(self): return self.calculationPeriodsSchedule
    def set_calculationPeriodsSchedule(self, calculationPeriodsSchedule): self.calculationPeriodsSchedule = calculationPeriodsSchedule
    def get_calculationPeriods(self): return self.calculationPeriods
    def set_calculationPeriods(self, calculationPeriods): self.calculationPeriods = calculationPeriods
    def get_pricingDates(self): return self.pricingDates
    def set_pricingDates(self, pricingDates): self.pricingDates = pricingDates
    def get_averagingMethod(self): return self.averagingMethod
    def set_averagingMethod(self, averagingMethod): self.averagingMethod = averagingMethod
    def get_digital(self): return self.digital
    def set_digital(self, digital): self.digital = digital
    def get_notionalAmount(self): return self.notionalAmount
    def set_notionalAmount(self, notionalAmount): self.notionalAmount = notionalAmount
    def get_notionalQuantity(self): return self.notionalQuantity
    def set_notionalQuantity(self, notionalQuantity): self.notionalQuantity = notionalQuantity
    def get_totalNotionalQuantity(self): return self.totalNotionalQuantity
    def set_totalNotionalQuantity(self, totalNotionalQuantity): self.totalNotionalQuantity = totalNotionalQuantity
    def get_exercise(self): return self.exercise
    def set_exercise(self, exercise): self.exercise = exercise
    def get_premium(self): return self.premium
    def set_premium(self, premium): self.premium = premium
    def add_premium(self, value): self.premium.append(value)
    def insert_premium_at(self, index, value): self.premium.insert(index, value)
    def replace_premium_at(self, index, value): self.premium[index] = value
    def get_commonPricing(self): return self.commonPricing
    def set_commonPricing(self, commonPricing): self.commonPricing = commonPricing
    def get_marketDisruption(self): return self.marketDisruption
    def set_marketDisruption(self, marketDisruption): self.marketDisruption = marketDisruption
    def get_settlementDisruption(self): return self.settlementDisruption
    def set_settlementDisruption(self, settlementDisruption): self.settlementDisruption = settlementDisruption
    def get_rounding(self): return self.rounding
    def set_rounding(self, rounding): self.rounding = rounding
    def validate_PutCallEnum(self, value):
        # Validate type PutCallEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Put', 'Call']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PutCallEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on PutCallEnum' % {"value" : value} )
    def validate_AveragingMethodEnum(self, value):
        # Validate type AveragingMethodEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Unweighted', 'Weighted']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AveragingMethodEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on AveragingMethodEnum' % {"value" : value} )
    def validate_CommodityBullionSettlementDisruptionEnum(self, value):
        # Validate type CommodityBullionSettlementDisruptionEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Negotiation', 'Cancellation and Payment']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CommodityBullionSettlementDisruptionEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on CommodityBullionSettlementDisruptionEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.optionType is not None or
            self.commodity is not None or
            self.effectiveDate is not None or
            self.terminationDate is not None or
            self.calculationPeriodsSchedule is not None or
            self.calculationPeriods is not None or
            self.pricingDates is not None or
            self.averagingMethod is not None or
            self.digital is not None or
            self.notionalAmount is not None or
            self.notionalQuantity is not None or
            self.totalNotionalQuantity is not None or
            self.exercise is not None or
            self.premium or
            self.commonPricing is not None or
            self.marketDisruption is not None or
            self.settlementDisruption is not None or
            self.rounding is not None or
            super(CommodityDigitalOption, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityDigitalOption', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityDigitalOption')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityDigitalOption', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityDigitalOption'):
        super(CommodityDigitalOption, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityDigitalOption')
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityDigitalOption', fromsubclass_=False, pretty_print=True):
        super(CommodityDigitalOption, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.optionType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soptionType>%s</%soptionType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.optionType), input_name='optionType')), namespace_, eol_))
        if self.commodity is not None:
            self.commodity.export(outfile, level, namespace_, name_='commodity', pretty_print=pretty_print)
        if self.effectiveDate is not None:
            self.effectiveDate.export(outfile, level, namespace_, name_='effectiveDate', pretty_print=pretty_print)
        if self.terminationDate is not None:
            self.terminationDate.export(outfile, level, namespace_, name_='terminationDate', pretty_print=pretty_print)
        if self.calculationPeriodsSchedule is not None:
            self.calculationPeriodsSchedule.export(outfile, level, namespace_, name_='calculationPeriodsSchedule', pretty_print=pretty_print)
        if self.calculationPeriods is not None:
            self.calculationPeriods.export(outfile, level, namespace_, name_='calculationPeriods', pretty_print=pretty_print)
        if self.pricingDates is not None:
            self.pricingDates.export(outfile, level, namespace_, name_='pricingDates', pretty_print=pretty_print)
        if self.averagingMethod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saveragingMethod>%s</%saveragingMethod>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.averagingMethod), input_name='averagingMethod')), namespace_, eol_))
        if self.digital is not None:
            self.digital.export(outfile, level, namespace_, name_='digital', pretty_print=pretty_print)
        if self.notionalAmount is not None:
            self.notionalAmount.export(outfile, level, namespace_, name_='notionalAmount', pretty_print=pretty_print)
        if self.notionalQuantity is not None:
            self.notionalQuantity.export(outfile, level, namespace_, name_='notionalQuantity', pretty_print=pretty_print)
        if self.totalNotionalQuantity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalNotionalQuantity>%s</%stotalNotionalQuantity>%s' % (namespace_, self.gds_format_float(self.totalNotionalQuantity, input_name='totalNotionalQuantity'), namespace_, eol_))
        if self.exercise is not None:
            self.exercise.export(outfile, level, namespace_, name_='exercise', pretty_print=pretty_print)
        for premium_ in self.premium:
            premium_.export(outfile, level, namespace_, name_='premium', pretty_print=pretty_print)
        if self.commonPricing is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scommonPricing>%s</%scommonPricing>%s' % (namespace_, self.gds_format_boolean(self.commonPricing, input_name='commonPricing'), namespace_, eol_))
        if self.marketDisruption is not None:
            self.marketDisruption.export(outfile, level, namespace_, name_='marketDisruption', pretty_print=pretty_print)
        if self.settlementDisruption is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssettlementDisruption>%s</%ssettlementDisruption>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.settlementDisruption), input_name='settlementDisruption')), namespace_, eol_))
        if self.rounding is not None:
            self.rounding.export(outfile, level, namespace_, name_='rounding', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CommodityDigitalOption, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'optionType':
            optionType_ = child_.text
            optionType_ = re_.sub(String_cleanup_pat_, " ", optionType_).strip()
            optionType_ = self.gds_validate_string(optionType_, node, 'optionType')
            self.optionType = optionType_
            # validate type PutCallEnum
            self.validate_PutCallEnum(self.optionType)
        elif nodeName_ == 'commodity':
            obj_ = Commodity.factory()
            obj_.build(child_)
            self.commodity = obj_
            obj_.original_tagname_ = 'commodity'
        elif nodeName_ == 'effectiveDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.effectiveDate = obj_
            obj_.original_tagname_ = 'effectiveDate'
        elif nodeName_ == 'terminationDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.terminationDate = obj_
            obj_.original_tagname_ = 'terminationDate'
        elif nodeName_ == 'calculationPeriodsSchedule':
            obj_ = CommodityCalculationPeriodsSchedule.factory()
            obj_.build(child_)
            self.calculationPeriodsSchedule = obj_
            obj_.original_tagname_ = 'calculationPeriodsSchedule'
        elif nodeName_ == 'calculationPeriods':
            obj_ = AdjustableDates.factory()
            obj_.build(child_)
            self.calculationPeriods = obj_
            obj_.original_tagname_ = 'calculationPeriods'
        elif nodeName_ == 'pricingDates':
            obj_ = CommodityPricingDates.factory()
            obj_.build(child_)
            self.pricingDates = obj_
            obj_.original_tagname_ = 'pricingDates'
        elif nodeName_ == 'averagingMethod':
            averagingMethod_ = child_.text
            averagingMethod_ = re_.sub(String_cleanup_pat_, " ", averagingMethod_).strip()
            averagingMethod_ = self.gds_validate_string(averagingMethod_, node, 'averagingMethod')
            self.averagingMethod = averagingMethod_
            # validate type AveragingMethodEnum
            self.validate_AveragingMethodEnum(self.averagingMethod)
        elif nodeName_ == 'digital':
            obj_ = CommodityDigital.factory()
            obj_.build(child_)
            self.digital = obj_
            obj_.original_tagname_ = 'digital'
        elif nodeName_ == 'notionalAmount':
            obj_ = NotionalAmount.factory()
            obj_.build(child_)
            self.notionalAmount = obj_
            obj_.original_tagname_ = 'notionalAmount'
        elif nodeName_ == 'notionalQuantity':
            class_obj_ = self.get_class_obj_(child_, CommodityNotionalQuantity)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.notionalQuantity = obj_
            obj_.original_tagname_ = 'notionalQuantity'
        elif nodeName_ == 'totalNotionalQuantity':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'totalNotionalQuantity')
            self.totalNotionalQuantity = fval_
        elif nodeName_ == 'exercise':
            obj_ = CommodityDigitalExercise.factory()
            obj_.build(child_)
            self.exercise = obj_
            obj_.original_tagname_ = 'exercise'
        elif nodeName_ == 'americanExercise':
            obj_ = AmericanExercise.factory()
            obj_.build(child_)
            self.exercise = obj_
            obj_.original_tagname_ = 'americanExercise'
        elif nodeName_ == 'bermudaExercise':
            obj_ = BermudaExercise.factory()
            obj_.build(child_)
            self.exercise = obj_
            obj_.original_tagname_ = 'bermudaExercise'
        elif nodeName_ == 'europeanExercise':
            obj_ = EuropeanExercise.factory()
            obj_.build(child_)
            self.exercise = obj_
            obj_.original_tagname_ = 'europeanExercise'
        elif nodeName_ == 'premium':
            obj_ = CommodityPremium.factory()
            obj_.build(child_)
            self.premium.append(obj_)
            obj_.original_tagname_ = 'premium'
        elif nodeName_ == 'commonPricing':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'commonPricing')
            self.commonPricing = ival_
        elif nodeName_ == 'marketDisruption':
            obj_ = CommodityMarketDisruption.factory()
            obj_.build(child_)
            self.marketDisruption = obj_
            obj_.original_tagname_ = 'marketDisruption'
        elif nodeName_ == 'settlementDisruption':
            settlementDisruption_ = child_.text
            settlementDisruption_ = re_.sub(String_cleanup_pat_, " ", settlementDisruption_).strip()
            settlementDisruption_ = self.gds_validate_string(settlementDisruption_, node, 'settlementDisruption')
            self.settlementDisruption = settlementDisruption_
            # validate type CommodityBullionSettlementDisruptionEnum
            self.validate_CommodityBullionSettlementDisruptionEnum(self.settlementDisruption)
        elif nodeName_ == 'rounding':
            obj_ = Rounding.factory()
            obj_.build(child_)
            self.rounding = obj_
            obj_.original_tagname_ = 'rounding'
        super(CommodityDigitalOption, self).buildChildren(child_, node, nodeName_, True)
# end class CommodityDigitalOption


class CommodityCalculationPeriodsSchedule(Frequency):
    """A parametric representation of the Calculation Periods for on Asian
    option or a leg of a swap. In case the calculation frequency is
    of value T (term), the period is defined by the
    commoditySwap\effectiveDate and the
    commoditySwap\terminationDate."""
    member_data_items_ = {
        'balanceOfFirstPeriod': MemberSpec_('balanceOfFirstPeriod', 'xsd:boolean', 0),
    }
    subclass = None
    superclass = Frequency
    def __init__(self, id=None, periodMultiplier=None, period=None, balanceOfFirstPeriod=None):
        self.original_tagname_ = None
        super(CommodityCalculationPeriodsSchedule, self).__init__(id, periodMultiplier, period, )
        self.balanceOfFirstPeriod = balanceOfFirstPeriod
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityCalculationPeriodsSchedule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityCalculationPeriodsSchedule.subclass:
            return CommodityCalculationPeriodsSchedule.subclass(*args_, **kwargs_)
        else:
            return CommodityCalculationPeriodsSchedule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_balanceOfFirstPeriod(self): return self.balanceOfFirstPeriod
    def set_balanceOfFirstPeriod(self, balanceOfFirstPeriod): self.balanceOfFirstPeriod = balanceOfFirstPeriod
    def hasContent_(self):
        if (
            self.balanceOfFirstPeriod is not None or
            super(CommodityCalculationPeriodsSchedule, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityCalculationPeriodsSchedule', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityCalculationPeriodsSchedule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityCalculationPeriodsSchedule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityCalculationPeriodsSchedule'):
        super(CommodityCalculationPeriodsSchedule, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityCalculationPeriodsSchedule')
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityCalculationPeriodsSchedule', fromsubclass_=False, pretty_print=True):
        super(CommodityCalculationPeriodsSchedule, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.balanceOfFirstPeriod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbalanceOfFirstPeriod>%s</%sbalanceOfFirstPeriod>%s' % (namespace_, self.gds_format_boolean(self.balanceOfFirstPeriod, input_name='balanceOfFirstPeriod'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CommodityCalculationPeriodsSchedule, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'balanceOfFirstPeriod':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'balanceOfFirstPeriod')
            self.balanceOfFirstPeriod = ival_
        super(CommodityCalculationPeriodsSchedule, self).buildChildren(child_, node, nodeName_, True)
# end class CommodityCalculationPeriodsSchedule


class CommodityBasketOption(Option):
    member_data_items_ = {
        'optionType': MemberSpec_('optionType', ['PutCallEnum', 'Token', 'xsd:token'], 0),
        'effectiveDate': MemberSpec_('effectiveDate', 'AdjustableOrRelativeDate', 0),
        'terminationDate': MemberSpec_('terminationDate', 'AdjustableOrRelativeDate', 0),
        'calculationPeriodsSchedule': MemberSpec_('calculationPeriodsSchedule', 'CommodityCalculationPeriodsSchedule', 0),
        'calculationPeriods': MemberSpec_('calculationPeriods', 'AdjustableDates', 0),
        'notionalQuantityBasket': MemberSpec_('notionalQuantityBasket', 'CommodityBasketByNotional', 0),
        'notionalAmountBasket': MemberSpec_('notionalAmountBasket', 'CommodityBasketByPercentage', 0),
        'strikePriceUnderlyingReference': MemberSpec_('strikePriceUnderlyingReference', 'StrikePriceUnderlyingReference', 0),
        'strikePriceBasketReference': MemberSpec_('strikePriceBasketReference', 'StrikePriceBasketReference', 0),
        'strikePricePerUnit': MemberSpec_('strikePricePerUnit', 'NonNegativeMoney', 0),
        'strikePricePerUnitSchedule': MemberSpec_('strikePricePerUnitSchedule', 'CommodityStrikeSchedule', 0),
        'floatingStrikePricePerUnit': MemberSpec_('floatingStrikePricePerUnit', 'FloatingStrikePrice', 0),
        'floatingStrikePricePerUnitSchedule': MemberSpec_('floatingStrikePricePerUnitSchedule', 'CommodityCalculationPeriodsSchedule', 0),
        'exercise': MemberSpec_('exercise', 'Exercise', 0),
        'premium': MemberSpec_('premium', 'CommodityPremium', 1),
        'commonPricing': MemberSpec_('commonPricing', 'xsd:boolean', 0),
        'marketDisruption': MemberSpec_('marketDisruption', 'CommodityMarketDisruption', 0),
        'settlementDisruption': MemberSpec_('settlementDisruption', ['CommodityBullionSettlementDisruptionEnum', 'Token', 'xsd:token'], 0),
        'rounding': MemberSpec_('rounding', 'Rounding', 0),
    }
    subclass = None
    superclass = Option
    def __init__(self, id=None, primaryAssetClass=None, secondaryAssetClass=None, productType=None, productId=None, assetClass=None, embeddedOptionType=None, buyerPartyReference=None, buyerAccountReference=None, sellerPartyReference=None, sellerAccountReference=None, optionType=None, effectiveDate=None, terminationDate=None, calculationPeriodsSchedule=None, calculationPeriods=None, notionalQuantityBasket=None, notionalAmountBasket=None, strikePriceUnderlyingReference=None, strikePriceBasketReference=None, strikePricePerUnit=None, strikePricePerUnitSchedule=None, floatingStrikePricePerUnit=None, floatingStrikePricePerUnitSchedule=None, exercise=None, premium=None, commonPricing=None, marketDisruption=None, settlementDisruption=None, rounding=None):
        self.original_tagname_ = None
        super(CommodityBasketOption, self).__init__(id, primaryAssetClass, secondaryAssetClass, productType, productId, assetClass, embeddedOptionType, buyerPartyReference, buyerAccountReference, sellerPartyReference, sellerAccountReference, )
        self.optionType = optionType
        self.validate_PutCallEnum(self.optionType)
        self.effectiveDate = effectiveDate
        self.terminationDate = terminationDate
        self.calculationPeriodsSchedule = calculationPeriodsSchedule
        self.calculationPeriods = calculationPeriods
        self.notionalQuantityBasket = notionalQuantityBasket
        self.notionalAmountBasket = notionalAmountBasket
        self.strikePriceUnderlyingReference = strikePriceUnderlyingReference
        self.strikePriceBasketReference = strikePriceBasketReference
        self.strikePricePerUnit = strikePricePerUnit
        self.strikePricePerUnitSchedule = strikePricePerUnitSchedule
        self.floatingStrikePricePerUnit = floatingStrikePricePerUnit
        self.floatingStrikePricePerUnitSchedule = floatingStrikePricePerUnitSchedule
        self.exercise = exercise
        if premium is None:
            self.premium = []
        else:
            self.premium = premium
        self.commonPricing = commonPricing
        self.marketDisruption = marketDisruption
        self.settlementDisruption = settlementDisruption
        self.validate_CommodityBullionSettlementDisruptionEnum(self.settlementDisruption)
        self.rounding = rounding
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityBasketOption)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityBasketOption.subclass:
            return CommodityBasketOption.subclass(*args_, **kwargs_)
        else:
            return CommodityBasketOption(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_optionType(self): return self.optionType
    def set_optionType(self, optionType): self.optionType = optionType
    def get_effectiveDate(self): return self.effectiveDate
    def set_effectiveDate(self, effectiveDate): self.effectiveDate = effectiveDate
    def get_terminationDate(self): return self.terminationDate
    def set_terminationDate(self, terminationDate): self.terminationDate = terminationDate
    def get_calculationPeriodsSchedule(self): return self.calculationPeriodsSchedule
    def set_calculationPeriodsSchedule(self, calculationPeriodsSchedule): self.calculationPeriodsSchedule = calculationPeriodsSchedule
    def get_calculationPeriods(self): return self.calculationPeriods
    def set_calculationPeriods(self, calculationPeriods): self.calculationPeriods = calculationPeriods
    def get_notionalQuantityBasket(self): return self.notionalQuantityBasket
    def set_notionalQuantityBasket(self, notionalQuantityBasket): self.notionalQuantityBasket = notionalQuantityBasket
    def get_notionalAmountBasket(self): return self.notionalAmountBasket
    def set_notionalAmountBasket(self, notionalAmountBasket): self.notionalAmountBasket = notionalAmountBasket
    def get_strikePriceUnderlyingReference(self): return self.strikePriceUnderlyingReference
    def set_strikePriceUnderlyingReference(self, strikePriceUnderlyingReference): self.strikePriceUnderlyingReference = strikePriceUnderlyingReference
    def get_strikePriceBasketReference(self): return self.strikePriceBasketReference
    def set_strikePriceBasketReference(self, strikePriceBasketReference): self.strikePriceBasketReference = strikePriceBasketReference
    def get_strikePricePerUnit(self): return self.strikePricePerUnit
    def set_strikePricePerUnit(self, strikePricePerUnit): self.strikePricePerUnit = strikePricePerUnit
    def get_strikePricePerUnitSchedule(self): return self.strikePricePerUnitSchedule
    def set_strikePricePerUnitSchedule(self, strikePricePerUnitSchedule): self.strikePricePerUnitSchedule = strikePricePerUnitSchedule
    def get_floatingStrikePricePerUnit(self): return self.floatingStrikePricePerUnit
    def set_floatingStrikePricePerUnit(self, floatingStrikePricePerUnit): self.floatingStrikePricePerUnit = floatingStrikePricePerUnit
    def get_floatingStrikePricePerUnitSchedule(self): return self.floatingStrikePricePerUnitSchedule
    def set_floatingStrikePricePerUnitSchedule(self, floatingStrikePricePerUnitSchedule): self.floatingStrikePricePerUnitSchedule = floatingStrikePricePerUnitSchedule
    def get_exercise(self): return self.exercise
    def set_exercise(self, exercise): self.exercise = exercise
    def get_premium(self): return self.premium
    def set_premium(self, premium): self.premium = premium
    def add_premium(self, value): self.premium.append(value)
    def insert_premium_at(self, index, value): self.premium.insert(index, value)
    def replace_premium_at(self, index, value): self.premium[index] = value
    def get_commonPricing(self): return self.commonPricing
    def set_commonPricing(self, commonPricing): self.commonPricing = commonPricing
    def get_marketDisruption(self): return self.marketDisruption
    def set_marketDisruption(self, marketDisruption): self.marketDisruption = marketDisruption
    def get_settlementDisruption(self): return self.settlementDisruption
    def set_settlementDisruption(self, settlementDisruption): self.settlementDisruption = settlementDisruption
    def get_rounding(self): return self.rounding
    def set_rounding(self, rounding): self.rounding = rounding
    def validate_PutCallEnum(self, value):
        # Validate type PutCallEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Put', 'Call']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PutCallEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on PutCallEnum' % {"value" : value} )
    def validate_CommodityBullionSettlementDisruptionEnum(self, value):
        # Validate type CommodityBullionSettlementDisruptionEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Negotiation', 'Cancellation and Payment']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CommodityBullionSettlementDisruptionEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on CommodityBullionSettlementDisruptionEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.optionType is not None or
            self.effectiveDate is not None or
            self.terminationDate is not None or
            self.calculationPeriodsSchedule is not None or
            self.calculationPeriods is not None or
            self.notionalQuantityBasket is not None or
            self.notionalAmountBasket is not None or
            self.strikePriceUnderlyingReference is not None or
            self.strikePriceBasketReference is not None or
            self.strikePricePerUnit is not None or
            self.strikePricePerUnitSchedule is not None or
            self.floatingStrikePricePerUnit is not None or
            self.floatingStrikePricePerUnitSchedule is not None or
            self.exercise is not None or
            self.premium or
            self.commonPricing is not None or
            self.marketDisruption is not None or
            self.settlementDisruption is not None or
            self.rounding is not None or
            super(CommodityBasketOption, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityBasketOption', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityBasketOption')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityBasketOption', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityBasketOption'):
        super(CommodityBasketOption, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityBasketOption')
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityBasketOption', fromsubclass_=False, pretty_print=True):
        super(CommodityBasketOption, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.optionType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soptionType>%s</%soptionType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.optionType), input_name='optionType')), namespace_, eol_))
        if self.effectiveDate is not None:
            self.effectiveDate.export(outfile, level, namespace_, name_='effectiveDate', pretty_print=pretty_print)
        if self.terminationDate is not None:
            self.terminationDate.export(outfile, level, namespace_, name_='terminationDate', pretty_print=pretty_print)
        if self.calculationPeriodsSchedule is not None:
            self.calculationPeriodsSchedule.export(outfile, level, namespace_, name_='calculationPeriodsSchedule', pretty_print=pretty_print)
        if self.calculationPeriods is not None:
            self.calculationPeriods.export(outfile, level, namespace_, name_='calculationPeriods', pretty_print=pretty_print)
        if self.notionalQuantityBasket is not None:
            self.notionalQuantityBasket.export(outfile, level, namespace_, name_='notionalQuantityBasket', pretty_print=pretty_print)
        if self.notionalAmountBasket is not None:
            self.notionalAmountBasket.export(outfile, level, namespace_, name_='notionalAmountBasket', pretty_print=pretty_print)
        if self.strikePriceUnderlyingReference is not None:
            self.strikePriceUnderlyingReference.export(outfile, level, namespace_, name_='strikePriceUnderlyingReference', pretty_print=pretty_print)
        if self.strikePriceBasketReference is not None:
            self.strikePriceBasketReference.export(outfile, level, namespace_, name_='strikePriceBasketReference', pretty_print=pretty_print)
        if self.strikePricePerUnit is not None:
            self.strikePricePerUnit.export(outfile, level, namespace_, name_='strikePricePerUnit', pretty_print=pretty_print)
        if self.strikePricePerUnitSchedule is not None:
            self.strikePricePerUnitSchedule.export(outfile, level, namespace_, name_='strikePricePerUnitSchedule', pretty_print=pretty_print)
        if self.floatingStrikePricePerUnit is not None:
            self.floatingStrikePricePerUnit.export(outfile, level, namespace_, name_='floatingStrikePricePerUnit', pretty_print=pretty_print)
        if self.floatingStrikePricePerUnitSchedule is not None:
            self.floatingStrikePricePerUnitSchedule.export(outfile, level, namespace_, name_='floatingStrikePricePerUnitSchedule', pretty_print=pretty_print)
        if self.exercise is not None:
            self.exercise.export(outfile, level, namespace_, name_='exercise', pretty_print=pretty_print)
        for premium_ in self.premium:
            premium_.export(outfile, level, namespace_, name_='premium', pretty_print=pretty_print)
        if self.commonPricing is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scommonPricing>%s</%scommonPricing>%s' % (namespace_, self.gds_format_boolean(self.commonPricing, input_name='commonPricing'), namespace_, eol_))
        if self.marketDisruption is not None:
            self.marketDisruption.export(outfile, level, namespace_, name_='marketDisruption', pretty_print=pretty_print)
        if self.settlementDisruption is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssettlementDisruption>%s</%ssettlementDisruption>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.settlementDisruption), input_name='settlementDisruption')), namespace_, eol_))
        if self.rounding is not None:
            self.rounding.export(outfile, level, namespace_, name_='rounding', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CommodityBasketOption, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'optionType':
            optionType_ = child_.text
            optionType_ = re_.sub(String_cleanup_pat_, " ", optionType_).strip()
            optionType_ = self.gds_validate_string(optionType_, node, 'optionType')
            self.optionType = optionType_
            # validate type PutCallEnum
            self.validate_PutCallEnum(self.optionType)
        elif nodeName_ == 'effectiveDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.effectiveDate = obj_
            obj_.original_tagname_ = 'effectiveDate'
        elif nodeName_ == 'terminationDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.terminationDate = obj_
            obj_.original_tagname_ = 'terminationDate'
        elif nodeName_ == 'calculationPeriodsSchedule':
            obj_ = CommodityCalculationPeriodsSchedule.factory()
            obj_.build(child_)
            self.calculationPeriodsSchedule = obj_
            obj_.original_tagname_ = 'calculationPeriodsSchedule'
        elif nodeName_ == 'calculationPeriods':
            obj_ = AdjustableDates.factory()
            obj_.build(child_)
            self.calculationPeriods = obj_
            obj_.original_tagname_ = 'calculationPeriods'
        elif nodeName_ == 'notionalQuantityBasket':
            obj_ = CommodityBasketByNotional.factory()
            obj_.build(child_)
            self.notionalQuantityBasket = obj_
            obj_.original_tagname_ = 'notionalQuantityBasket'
        elif nodeName_ == 'notionalAmountBasket':
            obj_ = CommodityBasketByPercentage.factory()
            obj_.build(child_)
            self.notionalAmountBasket = obj_
            obj_.original_tagname_ = 'notionalAmountBasket'
        elif nodeName_ == 'strikePriceUnderlyingReference':
            obj_ = StrikePriceUnderlyingReference.factory()
            obj_.build(child_)
            self.strikePriceUnderlyingReference = obj_
            obj_.original_tagname_ = 'strikePriceUnderlyingReference'
        elif nodeName_ == 'strikePriceBasketReference':
            obj_ = StrikePriceBasketReference.factory()
            obj_.build(child_)
            self.strikePriceBasketReference = obj_
            obj_.original_tagname_ = 'strikePriceBasketReference'
        elif nodeName_ == 'strikePricePerUnit':
            class_obj_ = self.get_class_obj_(child_, NonNegativeMoney)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.strikePricePerUnit = obj_
            obj_.original_tagname_ = 'strikePricePerUnit'
        elif nodeName_ == 'strikePricePerUnitSchedule':
            obj_ = CommodityStrikeSchedule.factory()
            obj_.build(child_)
            self.strikePricePerUnitSchedule = obj_
            obj_.original_tagname_ = 'strikePricePerUnitSchedule'
        elif nodeName_ == 'floatingStrikePricePerUnit':
            obj_ = FloatingStrikePrice.factory()
            obj_.build(child_)
            self.floatingStrikePricePerUnit = obj_
            obj_.original_tagname_ = 'floatingStrikePricePerUnit'
        elif nodeName_ == 'floatingStrikePricePerUnitSchedule':
            obj_ = CommodityCalculationPeriodsSchedule.factory()
            obj_.build(child_)
            self.floatingStrikePricePerUnitSchedule = obj_
            obj_.original_tagname_ = 'floatingStrikePricePerUnitSchedule'
        elif nodeName_ == 'exercise':
            obj_ = CommodityExerciseBasket.factory()
            obj_.build(child_)
            self.exercise = obj_
            obj_.original_tagname_ = 'exercise'
        elif nodeName_ == 'americanExercise':
            obj_ = AmericanExercise.factory()
            obj_.build(child_)
            self.exercise = obj_
            obj_.original_tagname_ = 'americanExercise'
        elif nodeName_ == 'bermudaExercise':
            obj_ = BermudaExercise.factory()
            obj_.build(child_)
            self.exercise = obj_
            obj_.original_tagname_ = 'bermudaExercise'
        elif nodeName_ == 'europeanExercise':
            obj_ = EuropeanExercise.factory()
            obj_.build(child_)
            self.exercise = obj_
            obj_.original_tagname_ = 'europeanExercise'
        elif nodeName_ == 'premium':
            obj_ = CommodityPremium.factory()
            obj_.build(child_)
            self.premium.append(obj_)
            obj_.original_tagname_ = 'premium'
        elif nodeName_ == 'commonPricing':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'commonPricing')
            self.commonPricing = ival_
        elif nodeName_ == 'marketDisruption':
            obj_ = CommodityMarketDisruption.factory()
            obj_.build(child_)
            self.marketDisruption = obj_
            obj_.original_tagname_ = 'marketDisruption'
        elif nodeName_ == 'settlementDisruption':
            settlementDisruption_ = child_.text
            settlementDisruption_ = re_.sub(String_cleanup_pat_, " ", settlementDisruption_).strip()
            settlementDisruption_ = self.gds_validate_string(settlementDisruption_, node, 'settlementDisruption')
            self.settlementDisruption = settlementDisruption_
            # validate type CommodityBullionSettlementDisruptionEnum
            self.validate_CommodityBullionSettlementDisruptionEnum(self.settlementDisruption)
        elif nodeName_ == 'rounding':
            obj_ = Rounding.factory()
            obj_.build(child_)
            self.rounding = obj_
            obj_.original_tagname_ = 'rounding'
        super(CommodityBasketOption, self).buildChildren(child_, node, nodeName_, True)
# end class CommodityBasketOption


class CommodityAmericanExercise(Exercise):
    """A type for defining exercise procedures associated with an American
    style exercise of a commodity option.Option StripChoice between
    latest exercise time expressed as literal time, or using a
    determination method."""
    member_data_items_ = {
        'exercisePeriod': MemberSpec_('exercisePeriod', 'CommodityExercisePeriods', 0),
        'exercisePeriod': MemberSpec_('exercisePeriod', 'CommodityExercisePeriods', 1),
        'exerciseFrequency': MemberSpec_('exerciseFrequency', 'Frequency', 0),
        'latestExerciseTime': MemberSpec_('latestExerciseTime', 'BusinessCenterTime', 0),
        'latestExerciseTimeDetermination': MemberSpec_('latestExerciseTimeDetermination', 'DeterminationMethod', 0),
        'expirationTime': MemberSpec_('expirationTime', 'BusinessCenterTime', 0),
        'multipleExercise': MemberSpec_('multipleExercise', 'CommodityMultipleExercise', 0),
    }
    subclass = None
    superclass = Exercise
    def __init__(self, id=None, exercisePeriod=None, exerciseFrequency=None, latestExerciseTime=None, latestExerciseTimeDetermination=None, expirationTime=None, multipleExercise=None):
        self.original_tagname_ = None
        super(CommodityAmericanExercise, self).__init__(id, )
        self.exercisePeriod = exercisePeriod
        if exercisePeriod is None:
            self.exercisePeriod = []
        else:
            self.exercisePeriod = exercisePeriod
        self.exerciseFrequency = exerciseFrequency
        self.latestExerciseTime = latestExerciseTime
        self.latestExerciseTimeDetermination = latestExerciseTimeDetermination
        self.expirationTime = expirationTime
        self.multipleExercise = multipleExercise
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityAmericanExercise)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityAmericanExercise.subclass:
            return CommodityAmericanExercise.subclass(*args_, **kwargs_)
        else:
            return CommodityAmericanExercise(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_exercisePeriod(self): return self.exercisePeriod
    def set_exercisePeriod(self, exercisePeriod): self.exercisePeriod = exercisePeriod
    def get_exercisePeriod(self): return self.exercisePeriod
    def set_exercisePeriod(self, exercisePeriod): self.exercisePeriod = exercisePeriod
    def add_exercisePeriod(self, value): self.exercisePeriod.append(value)
    def insert_exercisePeriod_at(self, index, value): self.exercisePeriod.insert(index, value)
    def replace_exercisePeriod_at(self, index, value): self.exercisePeriod[index] = value
    def get_exerciseFrequency(self): return self.exerciseFrequency
    def set_exerciseFrequency(self, exerciseFrequency): self.exerciseFrequency = exerciseFrequency
    def get_latestExerciseTime(self): return self.latestExerciseTime
    def set_latestExerciseTime(self, latestExerciseTime): self.latestExerciseTime = latestExerciseTime
    def get_latestExerciseTimeDetermination(self): return self.latestExerciseTimeDetermination
    def set_latestExerciseTimeDetermination(self, latestExerciseTimeDetermination): self.latestExerciseTimeDetermination = latestExerciseTimeDetermination
    def get_expirationTime(self): return self.expirationTime
    def set_expirationTime(self, expirationTime): self.expirationTime = expirationTime
    def get_multipleExercise(self): return self.multipleExercise
    def set_multipleExercise(self, multipleExercise): self.multipleExercise = multipleExercise
    def hasContent_(self):
        if (
            self.exercisePeriod is not None or
            self.exercisePeriod or
            self.exerciseFrequency is not None or
            self.latestExerciseTime is not None or
            self.latestExerciseTimeDetermination is not None or
            self.expirationTime is not None or
            self.multipleExercise is not None or
            super(CommodityAmericanExercise, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityAmericanExercise', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityAmericanExercise')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityAmericanExercise', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityAmericanExercise'):
        super(CommodityAmericanExercise, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityAmericanExercise')
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityAmericanExercise', fromsubclass_=False, pretty_print=True):
        super(CommodityAmericanExercise, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.exercisePeriod is not None:
            self.exercisePeriod.export(outfile, level, namespace_, name_='exercisePeriod', pretty_print=pretty_print)
        for exercisePeriod_ in self.exercisePeriod:
            exercisePeriod_.export(outfile, level, namespace_, name_='exercisePeriod', pretty_print=pretty_print)
        if self.exerciseFrequency is not None:
            self.exerciseFrequency.export(outfile, level, namespace_, name_='exerciseFrequency', pretty_print=pretty_print)
        if self.latestExerciseTime is not None:
            self.latestExerciseTime.export(outfile, level, namespace_, name_='latestExerciseTime', pretty_print=pretty_print)
        if self.latestExerciseTimeDetermination is not None:
            self.latestExerciseTimeDetermination.export(outfile, level, namespace_, name_='latestExerciseTimeDetermination', pretty_print=pretty_print)
        if self.expirationTime is not None:
            self.expirationTime.export(outfile, level, namespace_, name_='expirationTime', pretty_print=pretty_print)
        if self.multipleExercise is not None:
            self.multipleExercise.export(outfile, level, namespace_, name_='multipleExercise', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CommodityAmericanExercise, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'exercisePeriod':
            obj_ = CommodityExercisePeriods.factory()
            obj_.build(child_)
            self.exercisePeriod = obj_
            obj_.original_tagname_ = 'exercisePeriod'
        elif nodeName_ == 'exercisePeriod':
            obj_ = CommodityExercisePeriods.factory()
            obj_.build(child_)
            self.exercisePeriod.append(obj_)
            obj_.original_tagname_ = 'exercisePeriod'
        elif nodeName_ == 'exerciseFrequency':
            class_obj_ = self.get_class_obj_(child_, Frequency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.exerciseFrequency = obj_
            obj_.original_tagname_ = 'exerciseFrequency'
        elif nodeName_ == 'latestExerciseTime':
            obj_ = BusinessCenterTime.factory()
            obj_.build(child_)
            self.latestExerciseTime = obj_
            obj_.original_tagname_ = 'latestExerciseTime'
        elif nodeName_ == 'latestExerciseTimeDetermination':
            obj_ = DeterminationMethod.factory()
            obj_.build(child_)
            self.latestExerciseTimeDetermination = obj_
            obj_.original_tagname_ = 'latestExerciseTimeDetermination'
        elif nodeName_ == 'expirationTime':
            obj_ = BusinessCenterTime.factory()
            obj_.build(child_)
            self.expirationTime = obj_
            obj_.original_tagname_ = 'expirationTime'
        elif nodeName_ == 'multipleExercise':
            obj_ = CommodityMultipleExercise.factory()
            obj_.build(child_)
            self.multipleExercise = obj_
            obj_.original_tagname_ = 'multipleExercise'
        super(CommodityAmericanExercise, self).buildChildren(child_, node, nodeName_, True)
# end class CommodityAmericanExercise


class CalculationPeriodsScheduleReference(Reference):
    """A pointer style reference to a calculation periods schedule defined
    elsewhere - note that this schedule consists of a parameterised
    schedule in a calculationPeriodsSchedule container."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(CalculationPeriodsScheduleReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CalculationPeriodsScheduleReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CalculationPeriodsScheduleReference.subclass:
            return CalculationPeriodsScheduleReference.subclass(*args_, **kwargs_)
        else:
            return CalculationPeriodsScheduleReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(CalculationPeriodsScheduleReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CalculationPeriodsScheduleReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CalculationPeriodsScheduleReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CalculationPeriodsScheduleReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CalculationPeriodsScheduleReference'):
        super(CalculationPeriodsScheduleReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CalculationPeriodsScheduleReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CalculationPeriodsScheduleReference', fromsubclass_=False, pretty_print=True):
        super(CalculationPeriodsScheduleReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(CalculationPeriodsScheduleReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(CalculationPeriodsScheduleReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CalculationPeriodsScheduleReference


class CalculationPeriodsReference(Reference):
    """A pointer style reference to a calculation periods schedule defined
    elsewhere - note that this schedule consists of a series of
    actual dates in a calculationPeriods container."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(CalculationPeriodsReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CalculationPeriodsReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CalculationPeriodsReference.subclass:
            return CalculationPeriodsReference.subclass(*args_, **kwargs_)
        else:
            return CalculationPeriodsReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(CalculationPeriodsReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CalculationPeriodsReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CalculationPeriodsReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CalculationPeriodsReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CalculationPeriodsReference'):
        super(CalculationPeriodsReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CalculationPeriodsReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CalculationPeriodsReference', fromsubclass_=False, pretty_print=True):
        super(CalculationPeriodsReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(CalculationPeriodsReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(CalculationPeriodsReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CalculationPeriodsReference


class CalculationPeriodsDatesReference(Reference):
    """A pointer style reference to single-day-duration calculation periods
    defined elsewhere - note that this schedule consists of a
    parameterised schedule in a calculationPeriodsSchedule
    container."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(CalculationPeriodsDatesReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CalculationPeriodsDatesReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CalculationPeriodsDatesReference.subclass:
            return CalculationPeriodsDatesReference.subclass(*args_, **kwargs_)
        else:
            return CalculationPeriodsDatesReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(CalculationPeriodsDatesReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CalculationPeriodsDatesReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CalculationPeriodsDatesReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CalculationPeriodsDatesReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CalculationPeriodsDatesReference'):
        super(CalculationPeriodsDatesReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CalculationPeriodsDatesReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CalculationPeriodsDatesReference', fromsubclass_=False, pretty_print=True):
        super(CalculationPeriodsDatesReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(CalculationPeriodsDatesReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(CalculationPeriodsDatesReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CalculationPeriodsDatesReference


class AveragePriceLeg(CommoditySwapLeg):
    """The average price leg of an average price commodity bullion or non-
    precious metal forward transaction."""
    member_data_items_ = {
        'payerPartyReference': MemberSpec_('payerPartyReference', 'PartyReference', 0),
        'payerAccountReference': MemberSpec_('payerAccountReference', 'AccountReference', 0),
        'receiverPartyReference': MemberSpec_('receiverPartyReference', 'PartyReference', 0),
        'receiverAccountReference': MemberSpec_('receiverAccountReference', 'AccountReference', 0),
        'calculationDates': MemberSpec_('calculationDates', 'AdjustableDates', 0),
        'calculationPeriods': MemberSpec_('calculationPeriods', 'AdjustableDates', 0),
        'calculationPeriodsSchedule': MemberSpec_('calculationPeriodsSchedule', 'CommodityCalculationPeriodsSchedule', 0),
        'calculationPeriodsReference': MemberSpec_('calculationPeriodsReference', 'CalculationPeriodsReference', 0),
        'calculationPeriodsScheduleReference': MemberSpec_('calculationPeriodsScheduleReference', 'CalculationPeriodsScheduleReference', 0),
        'calculationPeriodsDatesReference': MemberSpec_('calculationPeriodsDatesReference', 'CalculationPeriodsDatesReference', 0),
        'commodity': MemberSpec_('commodity', 'Commodity', 0),
        'quantityReference': MemberSpec_('quantityReference', 'QuantityReference', 0),
        'pricingStartDate': MemberSpec_('pricingStartDate', 'AdjustableDate', 0),
        'calculation': MemberSpec_('calculation', 'FloatingLegCalculation', 0),
        'relativePaymentDates': MemberSpec_('relativePaymentDates', 'CommodityRelativePaymentDates', 0),
        'paymentDates': MemberSpec_('paymentDates', 'AdjustableDatesOrRelativeDateOffset', 0),
        'masterAgreementPaymentDates': MemberSpec_('masterAgreementPaymentDates', 'xsd:boolean', 0),
    }
    subclass = None
    superclass = CommoditySwapLeg
    def __init__(self, id=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, calculationDates=None, calculationPeriods=None, calculationPeriodsSchedule=None, calculationPeriodsReference=None, calculationPeriodsScheduleReference=None, calculationPeriodsDatesReference=None, commodity=None, quantityReference=None, pricingStartDate=None, calculation=None, relativePaymentDates=None, paymentDates=None, masterAgreementPaymentDates=None):
        self.original_tagname_ = None
        super(AveragePriceLeg, self).__init__(id, )
        self.payerPartyReference = payerPartyReference
        self.payerAccountReference = payerAccountReference
        self.receiverPartyReference = receiverPartyReference
        self.receiverAccountReference = receiverAccountReference
        self.calculationDates = calculationDates
        self.calculationPeriods = calculationPeriods
        self.calculationPeriodsSchedule = calculationPeriodsSchedule
        self.calculationPeriodsReference = calculationPeriodsReference
        self.calculationPeriodsScheduleReference = calculationPeriodsScheduleReference
        self.calculationPeriodsDatesReference = calculationPeriodsDatesReference
        self.commodity = commodity
        self.quantityReference = quantityReference
        self.pricingStartDate = pricingStartDate
        self.calculation = calculation
        self.relativePaymentDates = relativePaymentDates
        self.paymentDates = paymentDates
        self.masterAgreementPaymentDates = masterAgreementPaymentDates
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AveragePriceLeg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AveragePriceLeg.subclass:
            return AveragePriceLeg.subclass(*args_, **kwargs_)
        else:
            return AveragePriceLeg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_payerPartyReference(self): return self.payerPartyReference
    def set_payerPartyReference(self, payerPartyReference): self.payerPartyReference = payerPartyReference
    def get_payerAccountReference(self): return self.payerAccountReference
    def set_payerAccountReference(self, payerAccountReference): self.payerAccountReference = payerAccountReference
    def get_receiverPartyReference(self): return self.receiverPartyReference
    def set_receiverPartyReference(self, receiverPartyReference): self.receiverPartyReference = receiverPartyReference
    def get_receiverAccountReference(self): return self.receiverAccountReference
    def set_receiverAccountReference(self, receiverAccountReference): self.receiverAccountReference = receiverAccountReference
    def get_calculationDates(self): return self.calculationDates
    def set_calculationDates(self, calculationDates): self.calculationDates = calculationDates
    def get_calculationPeriods(self): return self.calculationPeriods
    def set_calculationPeriods(self, calculationPeriods): self.calculationPeriods = calculationPeriods
    def get_calculationPeriodsSchedule(self): return self.calculationPeriodsSchedule
    def set_calculationPeriodsSchedule(self, calculationPeriodsSchedule): self.calculationPeriodsSchedule = calculationPeriodsSchedule
    def get_calculationPeriodsReference(self): return self.calculationPeriodsReference
    def set_calculationPeriodsReference(self, calculationPeriodsReference): self.calculationPeriodsReference = calculationPeriodsReference
    def get_calculationPeriodsScheduleReference(self): return self.calculationPeriodsScheduleReference
    def set_calculationPeriodsScheduleReference(self, calculationPeriodsScheduleReference): self.calculationPeriodsScheduleReference = calculationPeriodsScheduleReference
    def get_calculationPeriodsDatesReference(self): return self.calculationPeriodsDatesReference
    def set_calculationPeriodsDatesReference(self, calculationPeriodsDatesReference): self.calculationPeriodsDatesReference = calculationPeriodsDatesReference
    def get_commodity(self): return self.commodity
    def set_commodity(self, commodity): self.commodity = commodity
    def get_quantityReference(self): return self.quantityReference
    def set_quantityReference(self, quantityReference): self.quantityReference = quantityReference
    def get_pricingStartDate(self): return self.pricingStartDate
    def set_pricingStartDate(self, pricingStartDate): self.pricingStartDate = pricingStartDate
    def get_calculation(self): return self.calculation
    def set_calculation(self, calculation): self.calculation = calculation
    def get_relativePaymentDates(self): return self.relativePaymentDates
    def set_relativePaymentDates(self, relativePaymentDates): self.relativePaymentDates = relativePaymentDates
    def get_paymentDates(self): return self.paymentDates
    def set_paymentDates(self, paymentDates): self.paymentDates = paymentDates
    def get_masterAgreementPaymentDates(self): return self.masterAgreementPaymentDates
    def set_masterAgreementPaymentDates(self, masterAgreementPaymentDates): self.masterAgreementPaymentDates = masterAgreementPaymentDates
    def hasContent_(self):
        if (
            self.payerPartyReference is not None or
            self.payerAccountReference is not None or
            self.receiverPartyReference is not None or
            self.receiverAccountReference is not None or
            self.calculationDates is not None or
            self.calculationPeriods is not None or
            self.calculationPeriodsSchedule is not None or
            self.calculationPeriodsReference is not None or
            self.calculationPeriodsScheduleReference is not None or
            self.calculationPeriodsDatesReference is not None or
            self.commodity is not None or
            self.quantityReference is not None or
            self.pricingStartDate is not None or
            self.calculation is not None or
            self.relativePaymentDates is not None or
            self.paymentDates is not None or
            self.masterAgreementPaymentDates is not None or
            super(AveragePriceLeg, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AveragePriceLeg', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AveragePriceLeg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AveragePriceLeg', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AveragePriceLeg'):
        super(AveragePriceLeg, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AveragePriceLeg')
    def exportChildren(self, outfile, level, namespace_='', name_='AveragePriceLeg', fromsubclass_=False, pretty_print=True):
        super(AveragePriceLeg, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.payerPartyReference is not None:
            self.payerPartyReference.export(outfile, level, namespace_, name_='payerPartyReference', pretty_print=pretty_print)
        if self.payerAccountReference is not None:
            self.payerAccountReference.export(outfile, level, namespace_, name_='payerAccountReference', pretty_print=pretty_print)
        if self.receiverPartyReference is not None:
            self.receiverPartyReference.export(outfile, level, namespace_, name_='receiverPartyReference', pretty_print=pretty_print)
        if self.receiverAccountReference is not None:
            self.receiverAccountReference.export(outfile, level, namespace_, name_='receiverAccountReference', pretty_print=pretty_print)
        if self.calculationDates is not None:
            self.calculationDates.export(outfile, level, namespace_, name_='calculationDates', pretty_print=pretty_print)
        if self.calculationPeriods is not None:
            self.calculationPeriods.export(outfile, level, namespace_, name_='calculationPeriods', pretty_print=pretty_print)
        if self.calculationPeriodsSchedule is not None:
            self.calculationPeriodsSchedule.export(outfile, level, namespace_, name_='calculationPeriodsSchedule', pretty_print=pretty_print)
        if self.calculationPeriodsReference is not None:
            self.calculationPeriodsReference.export(outfile, level, namespace_, name_='calculationPeriodsReference', pretty_print=pretty_print)
        if self.calculationPeriodsScheduleReference is not None:
            self.calculationPeriodsScheduleReference.export(outfile, level, namespace_, name_='calculationPeriodsScheduleReference', pretty_print=pretty_print)
        if self.calculationPeriodsDatesReference is not None:
            self.calculationPeriodsDatesReference.export(outfile, level, namespace_, name_='calculationPeriodsDatesReference', pretty_print=pretty_print)
        if self.commodity is not None:
            self.commodity.export(outfile, level, namespace_, name_='commodity', pretty_print=pretty_print)
        if self.quantityReference is not None:
            self.quantityReference.export(outfile, level, namespace_, name_='quantityReference', pretty_print=pretty_print)
        if self.pricingStartDate is not None:
            self.pricingStartDate.export(outfile, level, namespace_, name_='pricingStartDate', pretty_print=pretty_print)
        if self.calculation is not None:
            self.calculation.export(outfile, level, namespace_, name_='calculation', pretty_print=pretty_print)
        if self.relativePaymentDates is not None:
            self.relativePaymentDates.export(outfile, level, namespace_, name_='relativePaymentDates', pretty_print=pretty_print)
        if self.paymentDates is not None:
            self.paymentDates.export(outfile, level, namespace_, name_='paymentDates', pretty_print=pretty_print)
        if self.masterAgreementPaymentDates is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smasterAgreementPaymentDates>%s</%smasterAgreementPaymentDates>%s' % (namespace_, self.gds_format_boolean(self.masterAgreementPaymentDates, input_name='masterAgreementPaymentDates'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AveragePriceLeg, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'payerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.payerPartyReference = obj_
            obj_.original_tagname_ = 'payerPartyReference'
        elif nodeName_ == 'payerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.payerAccountReference = obj_
            obj_.original_tagname_ = 'payerAccountReference'
        elif nodeName_ == 'receiverPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.receiverPartyReference = obj_
            obj_.original_tagname_ = 'receiverPartyReference'
        elif nodeName_ == 'receiverAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.receiverAccountReference = obj_
            obj_.original_tagname_ = 'receiverAccountReference'
        elif nodeName_ == 'calculationDates':
            obj_ = AdjustableDates.factory()
            obj_.build(child_)
            self.calculationDates = obj_
            obj_.original_tagname_ = 'calculationDates'
        elif nodeName_ == 'calculationPeriods':
            obj_ = AdjustableDates.factory()
            obj_.build(child_)
            self.calculationPeriods = obj_
            obj_.original_tagname_ = 'calculationPeriods'
        elif nodeName_ == 'calculationPeriodsSchedule':
            obj_ = CommodityCalculationPeriodsSchedule.factory()
            obj_.build(child_)
            self.calculationPeriodsSchedule = obj_
            obj_.original_tagname_ = 'calculationPeriodsSchedule'
        elif nodeName_ == 'calculationPeriodsReference':
            obj_ = CalculationPeriodsReference.factory()
            obj_.build(child_)
            self.calculationPeriodsReference = obj_
            obj_.original_tagname_ = 'calculationPeriodsReference'
        elif nodeName_ == 'calculationPeriodsScheduleReference':
            obj_ = CalculationPeriodsScheduleReference.factory()
            obj_.build(child_)
            self.calculationPeriodsScheduleReference = obj_
            obj_.original_tagname_ = 'calculationPeriodsScheduleReference'
        elif nodeName_ == 'calculationPeriodsDatesReference':
            obj_ = CalculationPeriodsDatesReference.factory()
            obj_.build(child_)
            self.calculationPeriodsDatesReference = obj_
            obj_.original_tagname_ = 'calculationPeriodsDatesReference'
        elif nodeName_ == 'commodity':
            obj_ = Commodity.factory()
            obj_.build(child_)
            self.commodity = obj_
            obj_.original_tagname_ = 'commodity'
        elif nodeName_ == 'quantityReference':
            obj_ = QuantityReference.factory()
            obj_.build(child_)
            self.quantityReference = obj_
            obj_.original_tagname_ = 'quantityReference'
        elif nodeName_ == 'pricingStartDate':
            obj_ = AdjustableDate.factory()
            obj_.build(child_)
            self.pricingStartDate = obj_
            obj_.original_tagname_ = 'pricingStartDate'
        elif nodeName_ == 'calculation':
            class_obj_ = self.get_class_obj_(child_, FloatingLegCalculation)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.calculation = obj_
            obj_.original_tagname_ = 'calculation'
        elif nodeName_ == 'relativePaymentDates':
            obj_ = CommodityRelativePaymentDates.factory()
            obj_.build(child_)
            self.relativePaymentDates = obj_
            obj_.original_tagname_ = 'relativePaymentDates'
        elif nodeName_ == 'paymentDates':
            obj_ = AdjustableDatesOrRelativeDateOffset.factory()
            obj_.build(child_)
            self.paymentDates = obj_
            obj_.original_tagname_ = 'paymentDates'
        elif nodeName_ == 'masterAgreementPaymentDates':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'masterAgreementPaymentDates')
            self.masterAgreementPaymentDates = ival_
        super(AveragePriceLeg, self).buildChildren(child_, node, nodeName_, True)
# end class AveragePriceLeg


class UnderlyerInterestLeg(DirectionalLeg):
    """A type describing interest payments associated with and underlyer,
    such as financing"""
    member_data_items_ = {
        'fixedRate': MemberSpec_('fixedRate', 'xsd:decimal', 0),
        'spreadSchedule': MemberSpec_('spreadSchedule', 'SpreadSchedule', 1),
    }
    subclass = None
    superclass = DirectionalLeg
    def __init__(self, id=None, legIdentifier=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, effectiveDate=None, terminationDate=None, fixedRate=None, spreadSchedule=None):
        self.original_tagname_ = None
        super(UnderlyerInterestLeg, self).__init__(id, legIdentifier, payerPartyReference, payerAccountReference, receiverPartyReference, receiverAccountReference, effectiveDate, terminationDate, )
        self.fixedRate = fixedRate
        if spreadSchedule is None:
            self.spreadSchedule = []
        else:
            self.spreadSchedule = spreadSchedule
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UnderlyerInterestLeg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UnderlyerInterestLeg.subclass:
            return UnderlyerInterestLeg.subclass(*args_, **kwargs_)
        else:
            return UnderlyerInterestLeg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fixedRate(self): return self.fixedRate
    def set_fixedRate(self, fixedRate): self.fixedRate = fixedRate
    def get_spreadSchedule(self): return self.spreadSchedule
    def set_spreadSchedule(self, spreadSchedule): self.spreadSchedule = spreadSchedule
    def add_spreadSchedule(self, value): self.spreadSchedule.append(value)
    def insert_spreadSchedule_at(self, index, value): self.spreadSchedule.insert(index, value)
    def replace_spreadSchedule_at(self, index, value): self.spreadSchedule[index] = value
    def hasContent_(self):
        if (
            self.fixedRate is not None or
            self.spreadSchedule or
            super(UnderlyerInterestLeg, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='UnderlyerInterestLeg', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UnderlyerInterestLeg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='UnderlyerInterestLeg', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UnderlyerInterestLeg'):
        super(UnderlyerInterestLeg, self).exportAttributes(outfile, level, already_processed, namespace_, name_='UnderlyerInterestLeg')
    def exportChildren(self, outfile, level, namespace_='', name_='UnderlyerInterestLeg', fromsubclass_=False, pretty_print=True):
        super(UnderlyerInterestLeg, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.fixedRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfixedRate>%s</%sfixedRate>%s' % (namespace_, self.gds_format_float(self.fixedRate, input_name='fixedRate'), namespace_, eol_))
        for spreadSchedule_ in self.spreadSchedule:
            spreadSchedule_.export(outfile, level, namespace_, name_='spreadSchedule', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(UnderlyerInterestLeg, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fixedRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'fixedRate')
            self.fixedRate = fval_
        elif nodeName_ == 'spreadSchedule':
            obj_ = SpreadSchedule.factory()
            obj_.build(child_)
            self.spreadSchedule.append(obj_)
            obj_.original_tagname_ = 'spreadSchedule'
        super(UnderlyerInterestLeg, self).buildChildren(child_, node, nodeName_, True)
# end class UnderlyerInterestLeg


class RelativeDateOffset(Offset):
    """A type defining a date (referred to as the derived date) as a
    relative offset from another date (referred to as the anchor
    date). If the anchor date is itself an adjustable date then the
    offset is assumed to be calculated from the adjusted anchor
    date. A number of different scenarios can be supported, namely;
    1) the derived date may simply be a number of calendar periods
    (days, weeks, months or years) preceding or following the anchor
    date; 2) the unadjusted derived date may be a number of calendar
    periods (days, weeks, months or years) preceding or following
    the anchor date with the resulting unadjusted derived date
    subject to adjustment in accordance with a specified business
    day convention, i.e. the derived date must fall on a good
    business day; 3) the derived date may be a number of business
    days preceding or following the anchor date. Note that the
    businessDayConvention specifies any required adjustment to the
    unadjusted derived date. A negative or positive value in the
    periodMultiplier indicates whether the unadjusted derived
    precedes or follows the anchor date. The businessDayConvention
    should contain a value NONE if the day type element contains a
    value of Business (since specifying a negative or positive
    business days offset would already guarantee that the derived
    date would fall on a good business day in the specified business
    centers)."""
    member_data_items_ = {
        'businessDayConvention': MemberSpec_('businessDayConvention', ['BusinessDayConventionEnum', 'Token', 'xsd:token'], 0),
        'businessCentersReference': MemberSpec_('businessCentersReference', 'BusinessCentersReference', 0),
        'businessCenters': MemberSpec_('businessCenters', 'BusinessCenters', 0),
        'dateRelativeTo': MemberSpec_('dateRelativeTo', 'DateReference', 0),
        'adjustedDate': MemberSpec_('adjustedDate', 'IdentifiedDate', 0),
    }
    subclass = None
    superclass = Offset
    def __init__(self, id=None, periodMultiplier=None, period=None, dayType=None, businessDayConvention=None, businessCentersReference=None, businessCenters=None, dateRelativeTo=None, adjustedDate=None, extensiontype_=None):
        self.original_tagname_ = None
        super(RelativeDateOffset, self).__init__(id, periodMultiplier, period, dayType, extensiontype_, )
        self.businessDayConvention = businessDayConvention
        self.validate_BusinessDayConventionEnum(self.businessDayConvention)
        self.businessCentersReference = businessCentersReference
        self.businessCenters = businessCenters
        self.dateRelativeTo = dateRelativeTo
        self.adjustedDate = adjustedDate
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RelativeDateOffset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RelativeDateOffset.subclass:
            return RelativeDateOffset.subclass(*args_, **kwargs_)
        else:
            return RelativeDateOffset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_businessDayConvention(self): return self.businessDayConvention
    def set_businessDayConvention(self, businessDayConvention): self.businessDayConvention = businessDayConvention
    def get_businessCentersReference(self): return self.businessCentersReference
    def set_businessCentersReference(self, businessCentersReference): self.businessCentersReference = businessCentersReference
    def get_businessCenters(self): return self.businessCenters
    def set_businessCenters(self, businessCenters): self.businessCenters = businessCenters
    def get_dateRelativeTo(self): return self.dateRelativeTo
    def set_dateRelativeTo(self, dateRelativeTo): self.dateRelativeTo = dateRelativeTo
    def get_adjustedDate(self): return self.adjustedDate
    def set_adjustedDate(self, adjustedDate): self.adjustedDate = adjustedDate
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_BusinessDayConventionEnum(self, value):
        # Validate type BusinessDayConventionEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FOLLOWING', 'FRN', 'MODFOLLOWING', 'PRECEDING', 'MODPRECEDING', 'NEAREST', 'NONE', 'NotApplicable']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on BusinessDayConventionEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on BusinessDayConventionEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.businessDayConvention is not None or
            self.businessCentersReference is not None or
            self.businessCenters is not None or
            self.dateRelativeTo is not None or
            self.adjustedDate is not None or
            super(RelativeDateOffset, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RelativeDateOffset', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RelativeDateOffset')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RelativeDateOffset', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RelativeDateOffset'):
        super(RelativeDateOffset, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RelativeDateOffset')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='RelativeDateOffset', fromsubclass_=False, pretty_print=True):
        super(RelativeDateOffset, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.businessDayConvention is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbusinessDayConvention>%s</%sbusinessDayConvention>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.businessDayConvention), input_name='businessDayConvention')), namespace_, eol_))
        if self.businessCentersReference is not None:
            self.businessCentersReference.export(outfile, level, namespace_, name_='businessCentersReference', pretty_print=pretty_print)
        if self.businessCenters is not None:
            self.businessCenters.export(outfile, level, namespace_, name_='businessCenters', pretty_print=pretty_print)
        if self.dateRelativeTo is not None:
            self.dateRelativeTo.export(outfile, level, namespace_, name_='dateRelativeTo', pretty_print=pretty_print)
        if self.adjustedDate is not None:
            self.adjustedDate.export(outfile, level, namespace_, name_='adjustedDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(RelativeDateOffset, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'businessDayConvention':
            businessDayConvention_ = child_.text
            businessDayConvention_ = re_.sub(String_cleanup_pat_, " ", businessDayConvention_).strip()
            businessDayConvention_ = self.gds_validate_string(businessDayConvention_, node, 'businessDayConvention')
            self.businessDayConvention = businessDayConvention_
            # validate type BusinessDayConventionEnum
            self.validate_BusinessDayConventionEnum(self.businessDayConvention)
        elif nodeName_ == 'businessCentersReference':
            obj_ = BusinessCentersReference.factory()
            obj_.build(child_)
            self.businessCentersReference = obj_
            obj_.original_tagname_ = 'businessCentersReference'
        elif nodeName_ == 'businessCenters':
            obj_ = BusinessCenters.factory()
            obj_.build(child_)
            self.businessCenters = obj_
            obj_.original_tagname_ = 'businessCenters'
        elif nodeName_ == 'dateRelativeTo':
            obj_ = DateReference.factory()
            obj_.build(child_)
            self.dateRelativeTo = obj_
            obj_.original_tagname_ = 'dateRelativeTo'
        elif nodeName_ == 'adjustedDate':
            obj_ = IdentifiedDate.factory()
            obj_.build(child_)
            self.adjustedDate = obj_
            obj_.original_tagname_ = 'adjustedDate'
        super(RelativeDateOffset, self).buildChildren(child_, node, nodeName_, True)
# end class RelativeDateOffset


class FloatingRateCalculation(FloatingRate):
    """A type defining the floating rate and definitions relating to the
    calculation of floating rate amounts."""
    member_data_items_ = {
        'initialRate': MemberSpec_('initialRate', 'xsd:decimal', 0),
        'finalRateRounding': MemberSpec_('finalRateRounding', 'Rounding', 0),
        'averagingMethod': MemberSpec_('averagingMethod', ['AveragingMethodEnum', 'Token', 'xsd:token'], 0),
        'negativeInterestRateTreatment': MemberSpec_('negativeInterestRateTreatment', ['NegativeInterestRateTreatmentEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = FloatingRate
    def __init__(self, id=None, floatingRateIndex=None, indexTenor=None, floatingRateMultiplierSchedule=None, spreadSchedule=None, rateTreatment=None, capRateSchedule=None, floorRateSchedule=None, capFloorStraddle=None, initialRate=None, finalRateRounding=None, averagingMethod=None, negativeInterestRateTreatment=None):
        self.original_tagname_ = None
        super(FloatingRateCalculation, self).__init__(id, floatingRateIndex, indexTenor, floatingRateMultiplierSchedule, spreadSchedule, rateTreatment, capRateSchedule, floorRateSchedule, capFloorStraddle, )
        self.initialRate = initialRate
        self.finalRateRounding = finalRateRounding
        self.averagingMethod = averagingMethod
        self.validate_AveragingMethodEnum(self.averagingMethod)
        self.negativeInterestRateTreatment = negativeInterestRateTreatment
        self.validate_NegativeInterestRateTreatmentEnum(self.negativeInterestRateTreatment)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FloatingRateCalculation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FloatingRateCalculation.subclass:
            return FloatingRateCalculation.subclass(*args_, **kwargs_)
        else:
            return FloatingRateCalculation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_initialRate(self): return self.initialRate
    def set_initialRate(self, initialRate): self.initialRate = initialRate
    def get_finalRateRounding(self): return self.finalRateRounding
    def set_finalRateRounding(self, finalRateRounding): self.finalRateRounding = finalRateRounding
    def get_averagingMethod(self): return self.averagingMethod
    def set_averagingMethod(self, averagingMethod): self.averagingMethod = averagingMethod
    def get_negativeInterestRateTreatment(self): return self.negativeInterestRateTreatment
    def set_negativeInterestRateTreatment(self, negativeInterestRateTreatment): self.negativeInterestRateTreatment = negativeInterestRateTreatment
    def validate_AveragingMethodEnum(self, value):
        # Validate type AveragingMethodEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Unweighted', 'Weighted']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AveragingMethodEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on AveragingMethodEnum' % {"value" : value} )
    def validate_NegativeInterestRateTreatmentEnum(self, value):
        # Validate type NegativeInterestRateTreatmentEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NegativeInterestRateMethod', 'ZeroInterestRateMethod']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on NegativeInterestRateTreatmentEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NegativeInterestRateTreatmentEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.initialRate is not None or
            self.finalRateRounding is not None or
            self.averagingMethod is not None or
            self.negativeInterestRateTreatment is not None or
            super(FloatingRateCalculation, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FloatingRateCalculation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FloatingRateCalculation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FloatingRateCalculation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FloatingRateCalculation'):
        super(FloatingRateCalculation, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FloatingRateCalculation')
    def exportChildren(self, outfile, level, namespace_='', name_='FloatingRateCalculation', fromsubclass_=False, pretty_print=True):
        super(FloatingRateCalculation, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.initialRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinitialRate>%s</%sinitialRate>%s' % (namespace_, self.gds_format_float(self.initialRate, input_name='initialRate'), namespace_, eol_))
        if self.finalRateRounding is not None:
            self.finalRateRounding.export(outfile, level, namespace_, name_='finalRateRounding', pretty_print=pretty_print)
        if self.averagingMethod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saveragingMethod>%s</%saveragingMethod>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.averagingMethod), input_name='averagingMethod')), namespace_, eol_))
        if self.negativeInterestRateTreatment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snegativeInterestRateTreatment>%s</%snegativeInterestRateTreatment>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.negativeInterestRateTreatment), input_name='negativeInterestRateTreatment')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FloatingRateCalculation, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'initialRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'initialRate')
            self.initialRate = fval_
        elif nodeName_ == 'finalRateRounding':
            obj_ = Rounding.factory()
            obj_.build(child_)
            self.finalRateRounding = obj_
            obj_.original_tagname_ = 'finalRateRounding'
        elif nodeName_ == 'averagingMethod':
            averagingMethod_ = child_.text
            averagingMethod_ = re_.sub(String_cleanup_pat_, " ", averagingMethod_).strip()
            averagingMethod_ = self.gds_validate_string(averagingMethod_, node, 'averagingMethod')
            self.averagingMethod = averagingMethod_
            # validate type AveragingMethodEnum
            self.validate_AveragingMethodEnum(self.averagingMethod)
        elif nodeName_ == 'negativeInterestRateTreatment':
            negativeInterestRateTreatment_ = child_.text
            negativeInterestRateTreatment_ = re_.sub(String_cleanup_pat_, " ", negativeInterestRateTreatment_).strip()
            negativeInterestRateTreatment_ = self.gds_validate_string(negativeInterestRateTreatment_, node, 'negativeInterestRateTreatment')
            self.negativeInterestRateTreatment = negativeInterestRateTreatment_
            # validate type NegativeInterestRateTreatmentEnum
            self.validate_NegativeInterestRateTreatmentEnum(self.negativeInterestRateTreatment)
        super(FloatingRateCalculation, self).buildChildren(child_, node, nodeName_, True)
# end class FloatingRateCalculation


class AdjustedRelativeDateOffset(RelativeDateOffset):
    """A type defining a date (referred to as the derived date) as a
    relative offset from another date (referred to as the anchor
    date) plus optional date adjustments."""
    member_data_items_ = {
        'relativeDateAdjustments': MemberSpec_('relativeDateAdjustments', 'BusinessDayAdjustments', 0),
    }
    subclass = None
    superclass = RelativeDateOffset
    def __init__(self, id=None, periodMultiplier=None, period=None, dayType=None, businessDayConvention=None, businessCentersReference=None, businessCenters=None, dateRelativeTo=None, adjustedDate=None, relativeDateAdjustments=None):
        self.original_tagname_ = None
        super(AdjustedRelativeDateOffset, self).__init__(id, periodMultiplier, period, dayType, businessDayConvention, businessCentersReference, businessCenters, dateRelativeTo, adjustedDate, )
        self.relativeDateAdjustments = relativeDateAdjustments
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdjustedRelativeDateOffset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdjustedRelativeDateOffset.subclass:
            return AdjustedRelativeDateOffset.subclass(*args_, **kwargs_)
        else:
            return AdjustedRelativeDateOffset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_relativeDateAdjustments(self): return self.relativeDateAdjustments
    def set_relativeDateAdjustments(self, relativeDateAdjustments): self.relativeDateAdjustments = relativeDateAdjustments
    def hasContent_(self):
        if (
            self.relativeDateAdjustments is not None or
            super(AdjustedRelativeDateOffset, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AdjustedRelativeDateOffset', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdjustedRelativeDateOffset')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AdjustedRelativeDateOffset', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AdjustedRelativeDateOffset'):
        super(AdjustedRelativeDateOffset, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AdjustedRelativeDateOffset')
    def exportChildren(self, outfile, level, namespace_='', name_='AdjustedRelativeDateOffset', fromsubclass_=False, pretty_print=True):
        super(AdjustedRelativeDateOffset, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.relativeDateAdjustments is not None:
            self.relativeDateAdjustments.export(outfile, level, namespace_, name_='relativeDateAdjustments', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AdjustedRelativeDateOffset, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'relativeDateAdjustments':
            obj_ = BusinessDayAdjustments.factory()
            obj_.build(child_)
            self.relativeDateAdjustments = obj_
            obj_.original_tagname_ = 'relativeDateAdjustments'
        super(AdjustedRelativeDateOffset, self).buildChildren(child_, node, nodeName_, True)
# end class AdjustedRelativeDateOffset


class Future(ExchangeTraded):
    """An exchange traded future contract."""
    member_data_items_ = {
        'multiplier': MemberSpec_('multiplier', 'xsd:positiveInteger', 0),
        'futureContractReference': MemberSpec_('futureContractReference', ['String', 'xsd:string'], 0),
        'maturity': MemberSpec_('maturity', 'xsd:date', 0),
        'contractYearMonth': MemberSpec_('contractYearMonth', 'xsd:gYearMonth', 0),
    }
    subclass = None
    superclass = ExchangeTraded
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, relatedExchangeId=None, optionsExchangeId=None, specifiedExchangeId=None, multiplier=None, futureContractReference=None, maturity=None, contractYearMonth=None):
        self.original_tagname_ = None
        super(Future, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, relatedExchangeId, optionsExchangeId, specifiedExchangeId, )
        self.multiplier = multiplier
        self.futureContractReference = futureContractReference
        self.validate_String(self.futureContractReference)
        if isinstance(maturity, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(maturity, '%Y-%m-%d').date()
        else:
            initvalue_ = maturity
        self.maturity = initvalue_
        self.contractYearMonth = contractYearMonth
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Future)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Future.subclass:
            return Future.subclass(*args_, **kwargs_)
        else:
            return Future(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_multiplier(self): return self.multiplier
    def set_multiplier(self, multiplier): self.multiplier = multiplier
    def get_futureContractReference(self): return self.futureContractReference
    def set_futureContractReference(self, futureContractReference): self.futureContractReference = futureContractReference
    def get_maturity(self): return self.maturity
    def set_maturity(self, maturity): self.maturity = maturity
    def get_contractYearMonth(self): return self.contractYearMonth
    def set_contractYearMonth(self, contractYearMonth): self.contractYearMonth = contractYearMonth
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.multiplier is not None or
            self.futureContractReference is not None or
            self.maturity is not None or
            self.contractYearMonth is not None or
            super(Future, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Future', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Future')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Future', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Future'):
        super(Future, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Future')
    def exportChildren(self, outfile, level, namespace_='', name_='Future', fromsubclass_=False, pretty_print=True):
        super(Future, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.multiplier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smultiplier>%s</%smultiplier>%s' % (namespace_, self.gds_format_integer(self.multiplier, input_name='multiplier'), namespace_, eol_))
        if self.futureContractReference is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfutureContractReference>%s</%sfutureContractReference>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.futureContractReference), input_name='futureContractReference')), namespace_, eol_))
        if self.maturity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaturity>%s</%smaturity>%s' % (namespace_, self.gds_format_date(self.maturity, input_name='maturity'), namespace_, eol_))
        if self.contractYearMonth is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scontractYearMonth>%s</%scontractYearMonth>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.contractYearMonth), input_name='contractYearMonth')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Future, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'multiplier':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'multiplier')
            self.multiplier = ival_
        elif nodeName_ == 'futureContractReference':
            futureContractReference_ = child_.text
            futureContractReference_ = self.gds_validate_string(futureContractReference_, node, 'futureContractReference')
            self.futureContractReference = futureContractReference_
            # validate type String
            self.validate_String(self.futureContractReference)
        elif nodeName_ == 'maturity':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.maturity = dval_
        elif nodeName_ == 'contractYearMonth':
            contractYearMonth_ = child_.text
            contractYearMonth_ = self.gds_validate_string(contractYearMonth_, node, 'contractYearMonth')
            self.contractYearMonth = contractYearMonth_
        super(Future, self).buildChildren(child_, node, nodeName_, True)
# end class Future


class ExchangeTradedContract(ExchangeTraded):
    """An exchange traded derivative contract."""
    member_data_items_ = {
        'multiplier': MemberSpec_('multiplier', 'xsd:positiveInteger', 0),
        'contractReference': MemberSpec_('contractReference', ['String', 'xsd:string'], 0),
        'expirationDate': MemberSpec_('expirationDate', 'AdjustableOrRelativeDate', 0),
    }
    subclass = None
    superclass = ExchangeTraded
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, relatedExchangeId=None, optionsExchangeId=None, specifiedExchangeId=None, multiplier=None, contractReference=None, expirationDate=None, extensiontype_=None):
        self.original_tagname_ = None
        super(ExchangeTradedContract, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, relatedExchangeId, optionsExchangeId, specifiedExchangeId, extensiontype_, )
        self.multiplier = multiplier
        self.contractReference = contractReference
        self.validate_String(self.contractReference)
        self.expirationDate = expirationDate
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExchangeTradedContract)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExchangeTradedContract.subclass:
            return ExchangeTradedContract.subclass(*args_, **kwargs_)
        else:
            return ExchangeTradedContract(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_multiplier(self): return self.multiplier
    def set_multiplier(self, multiplier): self.multiplier = multiplier
    def get_contractReference(self): return self.contractReference
    def set_contractReference(self, contractReference): self.contractReference = contractReference
    def get_expirationDate(self): return self.expirationDate
    def set_expirationDate(self, expirationDate): self.expirationDate = expirationDate
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.multiplier is not None or
            self.contractReference is not None or
            self.expirationDate is not None or
            super(ExchangeTradedContract, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExchangeTradedContract', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExchangeTradedContract')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExchangeTradedContract', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExchangeTradedContract'):
        super(ExchangeTradedContract, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ExchangeTradedContract')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='ExchangeTradedContract', fromsubclass_=False, pretty_print=True):
        super(ExchangeTradedContract, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.multiplier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smultiplier>%s</%smultiplier>%s' % (namespace_, self.gds_format_integer(self.multiplier, input_name='multiplier'), namespace_, eol_))
        if self.contractReference is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scontractReference>%s</%scontractReference>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.contractReference), input_name='contractReference')), namespace_, eol_))
        if self.expirationDate is not None:
            self.expirationDate.export(outfile, level, namespace_, name_='expirationDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ExchangeTradedContract, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'multiplier':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'multiplier')
            self.multiplier = ival_
        elif nodeName_ == 'contractReference':
            contractReference_ = child_.text
            contractReference_ = self.gds_validate_string(contractReference_, node, 'contractReference')
            self.contractReference = contractReference_
            # validate type String
            self.validate_String(self.contractReference)
        elif nodeName_ == 'expirationDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.expirationDate = obj_
            obj_.original_tagname_ = 'expirationDate'
        super(ExchangeTradedContract, self).buildChildren(child_, node, nodeName_, True)
# end class ExchangeTradedContract


class ExchangeTradedCalculatedPrice(ExchangeTraded):
    """Abstract base class for all exchange traded financial products with
    a price which is calculated from exchange traded constituents."""
    member_data_items_ = {
        'constituentExchangeId': MemberSpec_('constituentExchangeId', 'ExchangeId', 1),
    }
    subclass = None
    superclass = ExchangeTraded
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, relatedExchangeId=None, optionsExchangeId=None, specifiedExchangeId=None, constituentExchangeId=None, extensiontype_=None):
        self.original_tagname_ = None
        super(ExchangeTradedCalculatedPrice, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, relatedExchangeId, optionsExchangeId, specifiedExchangeId, extensiontype_, )
        if constituentExchangeId is None:
            self.constituentExchangeId = []
        else:
            self.constituentExchangeId = constituentExchangeId
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExchangeTradedCalculatedPrice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExchangeTradedCalculatedPrice.subclass:
            return ExchangeTradedCalculatedPrice.subclass(*args_, **kwargs_)
        else:
            return ExchangeTradedCalculatedPrice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_constituentExchangeId(self): return self.constituentExchangeId
    def set_constituentExchangeId(self, constituentExchangeId): self.constituentExchangeId = constituentExchangeId
    def add_constituentExchangeId(self, value): self.constituentExchangeId.append(value)
    def insert_constituentExchangeId_at(self, index, value): self.constituentExchangeId.insert(index, value)
    def replace_constituentExchangeId_at(self, index, value): self.constituentExchangeId[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.constituentExchangeId or
            super(ExchangeTradedCalculatedPrice, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExchangeTradedCalculatedPrice', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExchangeTradedCalculatedPrice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExchangeTradedCalculatedPrice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExchangeTradedCalculatedPrice'):
        super(ExchangeTradedCalculatedPrice, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ExchangeTradedCalculatedPrice')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='ExchangeTradedCalculatedPrice', fromsubclass_=False, pretty_print=True):
        super(ExchangeTradedCalculatedPrice, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for constituentExchangeId_ in self.constituentExchangeId:
            constituentExchangeId_.export(outfile, level, namespace_, name_='constituentExchangeId', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ExchangeTradedCalculatedPrice, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'constituentExchangeId':
            obj_ = ExchangeId.factory()
            obj_.build(child_)
            self.constituentExchangeId.append(obj_)
            obj_.original_tagname_ = 'constituentExchangeId'
        super(ExchangeTradedCalculatedPrice, self).buildChildren(child_, node, nodeName_, True)
# end class ExchangeTradedCalculatedPrice


class ConvertibleBond(Bond):
    member_data_items_ = {
        'underlyingEquity': MemberSpec_('underlyingEquity', 'EquityAsset', 0),
        'redemptionDate': MemberSpec_('redemptionDate', 'xsd:date', 0),
    }
    subclass = None
    superclass = Bond
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, issuerName=None, issuerPartyReference=None, seniority=None, couponType=None, couponRate=None, maturity=None, parValue=None, faceAmount=None, paymentFrequency=None, dayCountFraction=None, underlyingEquity=None, redemptionDate=None):
        self.original_tagname_ = None
        super(ConvertibleBond, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, issuerName, issuerPartyReference, seniority, couponType, couponRate, maturity, parValue, faceAmount, paymentFrequency, dayCountFraction, )
        self.underlyingEquity = underlyingEquity
        if isinstance(redemptionDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(redemptionDate, '%Y-%m-%d').date()
        else:
            initvalue_ = redemptionDate
        self.redemptionDate = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConvertibleBond)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConvertibleBond.subclass:
            return ConvertibleBond.subclass(*args_, **kwargs_)
        else:
            return ConvertibleBond(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_underlyingEquity(self): return self.underlyingEquity
    def set_underlyingEquity(self, underlyingEquity): self.underlyingEquity = underlyingEquity
    def get_redemptionDate(self): return self.redemptionDate
    def set_redemptionDate(self, redemptionDate): self.redemptionDate = redemptionDate
    def hasContent_(self):
        if (
            self.underlyingEquity is not None or
            self.redemptionDate is not None or
            super(ConvertibleBond, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ConvertibleBond', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConvertibleBond')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ConvertibleBond', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConvertibleBond'):
        super(ConvertibleBond, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ConvertibleBond')
    def exportChildren(self, outfile, level, namespace_='', name_='ConvertibleBond', fromsubclass_=False, pretty_print=True):
        super(ConvertibleBond, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.underlyingEquity is not None:
            self.underlyingEquity.export(outfile, level, namespace_, name_='underlyingEquity', pretty_print=pretty_print)
        if self.redemptionDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sredemptionDate>%s</%sredemptionDate>%s' % (namespace_, self.gds_format_date(self.redemptionDate, input_name='redemptionDate'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ConvertibleBond, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'underlyingEquity':
            obj_ = EquityAsset.factory()
            obj_.build(child_)
            self.underlyingEquity = obj_
            obj_.original_tagname_ = 'underlyingEquity'
        elif nodeName_ == 'redemptionDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.redemptionDate = dval_
        super(ConvertibleBond, self).buildChildren(child_, node, nodeName_, True)
# end class ConvertibleBond


class OptionBase(Option):
    """A type for defining the common features of options."""
    member_data_items_ = {
        'optionType': MemberSpec_('optionType', ['OptionTypeEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = Option
    def __init__(self, id=None, primaryAssetClass=None, secondaryAssetClass=None, productType=None, productId=None, assetClass=None, embeddedOptionType=None, buyerPartyReference=None, buyerAccountReference=None, sellerPartyReference=None, sellerAccountReference=None, optionType=None, extensiontype_=None):
        self.original_tagname_ = None
        super(OptionBase, self).__init__(id, primaryAssetClass, secondaryAssetClass, productType, productId, assetClass, embeddedOptionType, buyerPartyReference, buyerAccountReference, sellerPartyReference, sellerAccountReference, extensiontype_, )
        self.optionType = optionType
        self.validate_OptionTypeEnum(self.optionType)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OptionBase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OptionBase.subclass:
            return OptionBase.subclass(*args_, **kwargs_)
        else:
            return OptionBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_optionType(self): return self.optionType
    def set_optionType(self, optionType): self.optionType = optionType
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_OptionTypeEnum(self, value):
        # Validate type OptionTypeEnum, a restriction on Token.
        pass
    def hasContent_(self):
        if (
            self.optionType is not None or
            super(OptionBase, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OptionBase', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OptionBase')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OptionBase', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OptionBase'):
        super(OptionBase, self).exportAttributes(outfile, level, already_processed, namespace_, name_='OptionBase')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='OptionBase', fromsubclass_=False, pretty_print=True):
        super(OptionBase, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.optionType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soptionType>%s</%soptionType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.optionType), input_name='optionType')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(OptionBase, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'optionType':
            optionType_ = child_.text
            optionType_ = re_.sub(String_cleanup_pat_, " ", optionType_).strip()
            optionType_ = self.gds_validate_string(optionType_, node, 'optionType')
            self.optionType = optionType_
            # validate type OptionTypeEnum
            self.validate_OptionTypeEnum(self.optionType)
        super(OptionBase, self).buildChildren(child_, node, nodeName_, True)
# end class OptionBase


class PhysicalSwapLeg(CommoditySwapLeg):
    """The common components of a physically settled leg of a Commodity
    Swap. This is an abstract type and should be extended by
    commodity-specific types."""
    member_data_items_ = {
        'payerPartyReference': MemberSpec_('payerPartyReference', 'PartyReference', 0),
        'payerAccountReference': MemberSpec_('payerAccountReference', 'AccountReference', 0),
        'receiverPartyReference': MemberSpec_('receiverPartyReference', 'PartyReference', 0),
        'receiverAccountReference': MemberSpec_('receiverAccountReference', 'AccountReference', 0),
    }
    subclass = None
    superclass = CommoditySwapLeg
    def __init__(self, id=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, extensiontype_=None):
        self.original_tagname_ = None
        super(PhysicalSwapLeg, self).__init__(id, extensiontype_, )
        self.payerPartyReference = payerPartyReference
        self.payerAccountReference = payerAccountReference
        self.receiverPartyReference = receiverPartyReference
        self.receiverAccountReference = receiverAccountReference
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalSwapLeg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalSwapLeg.subclass:
            return PhysicalSwapLeg.subclass(*args_, **kwargs_)
        else:
            return PhysicalSwapLeg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_payerPartyReference(self): return self.payerPartyReference
    def set_payerPartyReference(self, payerPartyReference): self.payerPartyReference = payerPartyReference
    def get_payerAccountReference(self): return self.payerAccountReference
    def set_payerAccountReference(self, payerAccountReference): self.payerAccountReference = payerAccountReference
    def get_receiverPartyReference(self): return self.receiverPartyReference
    def set_receiverPartyReference(self, receiverPartyReference): self.receiverPartyReference = receiverPartyReference
    def get_receiverAccountReference(self): return self.receiverAccountReference
    def set_receiverAccountReference(self, receiverAccountReference): self.receiverAccountReference = receiverAccountReference
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.payerPartyReference is not None or
            self.payerAccountReference is not None or
            self.receiverPartyReference is not None or
            self.receiverAccountReference is not None or
            super(PhysicalSwapLeg, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PhysicalSwapLeg', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PhysicalSwapLeg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PhysicalSwapLeg', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PhysicalSwapLeg'):
        super(PhysicalSwapLeg, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PhysicalSwapLeg')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='PhysicalSwapLeg', fromsubclass_=False, pretty_print=True):
        super(PhysicalSwapLeg, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.payerPartyReference is not None:
            self.payerPartyReference.export(outfile, level, namespace_, name_='payerPartyReference', pretty_print=pretty_print)
        if self.payerAccountReference is not None:
            self.payerAccountReference.export(outfile, level, namespace_, name_='payerAccountReference', pretty_print=pretty_print)
        if self.receiverPartyReference is not None:
            self.receiverPartyReference.export(outfile, level, namespace_, name_='receiverPartyReference', pretty_print=pretty_print)
        if self.receiverAccountReference is not None:
            self.receiverAccountReference.export(outfile, level, namespace_, name_='receiverAccountReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(PhysicalSwapLeg, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'payerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.payerPartyReference = obj_
            obj_.original_tagname_ = 'payerPartyReference'
        elif nodeName_ == 'payerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.payerAccountReference = obj_
            obj_.original_tagname_ = 'payerAccountReference'
        elif nodeName_ == 'receiverPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.receiverPartyReference = obj_
            obj_.original_tagname_ = 'receiverPartyReference'
        elif nodeName_ == 'receiverAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.receiverAccountReference = obj_
            obj_.original_tagname_ = 'receiverAccountReference'
        super(PhysicalSwapLeg, self).buildChildren(child_, node, nodeName_, True)
# end class PhysicalSwapLeg


class PhysicalForwardLeg(CommodityForwardLeg):
    """The common components of a physically settled leg of a Commodity
    Forward. This is an abstract type and should be extended by
    commodity-specific types."""
    member_data_items_ = {
        'payerPartyReference': MemberSpec_('payerPartyReference', 'PartyReference', 0),
        'payerAccountReference': MemberSpec_('payerAccountReference', 'AccountReference', 0),
        'receiverPartyReference': MemberSpec_('receiverPartyReference', 'PartyReference', 0),
        'receiverAccountReference': MemberSpec_('receiverAccountReference', 'AccountReference', 0),
    }
    subclass = None
    superclass = CommodityForwardLeg
    def __init__(self, id=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, extensiontype_=None):
        self.original_tagname_ = None
        super(PhysicalForwardLeg, self).__init__(id, extensiontype_, )
        self.payerPartyReference = payerPartyReference
        self.payerAccountReference = payerAccountReference
        self.receiverPartyReference = receiverPartyReference
        self.receiverAccountReference = receiverAccountReference
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalForwardLeg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalForwardLeg.subclass:
            return PhysicalForwardLeg.subclass(*args_, **kwargs_)
        else:
            return PhysicalForwardLeg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_payerPartyReference(self): return self.payerPartyReference
    def set_payerPartyReference(self, payerPartyReference): self.payerPartyReference = payerPartyReference
    def get_payerAccountReference(self): return self.payerAccountReference
    def set_payerAccountReference(self, payerAccountReference): self.payerAccountReference = payerAccountReference
    def get_receiverPartyReference(self): return self.receiverPartyReference
    def set_receiverPartyReference(self, receiverPartyReference): self.receiverPartyReference = receiverPartyReference
    def get_receiverAccountReference(self): return self.receiverAccountReference
    def set_receiverAccountReference(self, receiverAccountReference): self.receiverAccountReference = receiverAccountReference
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.payerPartyReference is not None or
            self.payerAccountReference is not None or
            self.receiverPartyReference is not None or
            self.receiverAccountReference is not None or
            super(PhysicalForwardLeg, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PhysicalForwardLeg', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PhysicalForwardLeg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PhysicalForwardLeg', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PhysicalForwardLeg'):
        super(PhysicalForwardLeg, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PhysicalForwardLeg')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='PhysicalForwardLeg', fromsubclass_=False, pretty_print=True):
        super(PhysicalForwardLeg, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.payerPartyReference is not None:
            self.payerPartyReference.export(outfile, level, namespace_, name_='payerPartyReference', pretty_print=pretty_print)
        if self.payerAccountReference is not None:
            self.payerAccountReference.export(outfile, level, namespace_, name_='payerAccountReference', pretty_print=pretty_print)
        if self.receiverPartyReference is not None:
            self.receiverPartyReference.export(outfile, level, namespace_, name_='receiverPartyReference', pretty_print=pretty_print)
        if self.receiverAccountReference is not None:
            self.receiverAccountReference.export(outfile, level, namespace_, name_='receiverAccountReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(PhysicalForwardLeg, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'payerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.payerPartyReference = obj_
            obj_.original_tagname_ = 'payerPartyReference'
        elif nodeName_ == 'payerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.payerAccountReference = obj_
            obj_.original_tagname_ = 'payerAccountReference'
        elif nodeName_ == 'receiverPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.receiverPartyReference = obj_
            obj_.original_tagname_ = 'receiverPartyReference'
        elif nodeName_ == 'receiverAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.receiverAccountReference = obj_
            obj_.original_tagname_ = 'receiverAccountReference'
        super(PhysicalForwardLeg, self).buildChildren(child_, node, nodeName_, True)
# end class PhysicalForwardLeg


class OilPhysicalLeg(PhysicalSwapLeg):
    """Physically settled leg of a physically settled oil product
    transaction."""
    member_data_items_ = {
        'deliveryPeriods': MemberSpec_('deliveryPeriods', 'CommodityDeliveryPeriods', 0),
        'oil': MemberSpec_('oil', 'OilProduct', 0),
        'deliveryConditions': MemberSpec_('deliveryConditions', 'OilDelivery', 0),
        'deliveryQuantity': MemberSpec_('deliveryQuantity', 'CommodityPhysicalQuantity', 0),
    }
    subclass = None
    superclass = PhysicalSwapLeg
    def __init__(self, id=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, deliveryPeriods=None, oil=None, deliveryConditions=None, deliveryQuantity=None):
        self.original_tagname_ = None
        super(OilPhysicalLeg, self).__init__(id, payerPartyReference, payerAccountReference, receiverPartyReference, receiverAccountReference, )
        self.deliveryPeriods = deliveryPeriods
        self.oil = oil
        self.deliveryConditions = deliveryConditions
        self.deliveryQuantity = deliveryQuantity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OilPhysicalLeg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OilPhysicalLeg.subclass:
            return OilPhysicalLeg.subclass(*args_, **kwargs_)
        else:
            return OilPhysicalLeg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_deliveryPeriods(self): return self.deliveryPeriods
    def set_deliveryPeriods(self, deliveryPeriods): self.deliveryPeriods = deliveryPeriods
    def get_oil(self): return self.oil
    def set_oil(self, oil): self.oil = oil
    def get_deliveryConditions(self): return self.deliveryConditions
    def set_deliveryConditions(self, deliveryConditions): self.deliveryConditions = deliveryConditions
    def get_deliveryQuantity(self): return self.deliveryQuantity
    def set_deliveryQuantity(self, deliveryQuantity): self.deliveryQuantity = deliveryQuantity
    def hasContent_(self):
        if (
            self.deliveryPeriods is not None or
            self.oil is not None or
            self.deliveryConditions is not None or
            self.deliveryQuantity is not None or
            super(OilPhysicalLeg, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OilPhysicalLeg', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OilPhysicalLeg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OilPhysicalLeg', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OilPhysicalLeg'):
        super(OilPhysicalLeg, self).exportAttributes(outfile, level, already_processed, namespace_, name_='OilPhysicalLeg')
    def exportChildren(self, outfile, level, namespace_='', name_='OilPhysicalLeg', fromsubclass_=False, pretty_print=True):
        super(OilPhysicalLeg, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.deliveryPeriods is not None:
            self.deliveryPeriods.export(outfile, level, namespace_, name_='deliveryPeriods', pretty_print=pretty_print)
        if self.oil is not None:
            self.oil.export(outfile, level, namespace_, name_='oil', pretty_print=pretty_print)
        if self.deliveryConditions is not None:
            self.deliveryConditions.export(outfile, level, namespace_, name_='deliveryConditions', pretty_print=pretty_print)
        if self.deliveryQuantity is not None:
            self.deliveryQuantity.export(outfile, level, namespace_, name_='deliveryQuantity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(OilPhysicalLeg, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'deliveryPeriods':
            class_obj_ = self.get_class_obj_(child_, CommodityDeliveryPeriods)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.deliveryPeriods = obj_
            obj_.original_tagname_ = 'deliveryPeriods'
        elif nodeName_ == 'oil':
            obj_ = OilProduct.factory()
            obj_.build(child_)
            self.oil = obj_
            obj_.original_tagname_ = 'oil'
        elif nodeName_ == 'deliveryConditions':
            obj_ = OilDelivery.factory()
            obj_.build(child_)
            self.deliveryConditions = obj_
            obj_.original_tagname_ = 'deliveryConditions'
        elif nodeName_ == 'deliveryQuantity':
            obj_ = CommodityPhysicalQuantity.factory()
            obj_.build(child_)
            self.deliveryQuantity = obj_
            obj_.original_tagname_ = 'deliveryQuantity'
        super(OilPhysicalLeg, self).buildChildren(child_, node, nodeName_, True)
# end class OilPhysicalLeg


class NonPeriodicFixedPriceLeg(CommoditySwapLeg):
    """The details of a fixed payment. Can be used for a forward
    transaction or as the base for a more complex fixed leg
    component such as the fixed leg of a swap."""
    member_data_items_ = {
        'payerPartyReference': MemberSpec_('payerPartyReference', 'PartyReference', 0),
        'payerAccountReference': MemberSpec_('payerAccountReference', 'AccountReference', 0),
        'receiverPartyReference': MemberSpec_('receiverPartyReference', 'PartyReference', 0),
        'receiverAccountReference': MemberSpec_('receiverAccountReference', 'AccountReference', 0),
        'fixedPrice': MemberSpec_('fixedPrice', 'FixedPrice', 0),
        'totalPrice': MemberSpec_('totalPrice', 'NonNegativeMoney', 0),
        'quantityReference': MemberSpec_('quantityReference', 'QuantityReference', 0),
        'relativePaymentDates': MemberSpec_('relativePaymentDates', 'CommodityRelativePaymentDates', 0),
        'paymentDates': MemberSpec_('paymentDates', 'AdjustableDatesOrRelativeDateOffset', 0),
        'masterAgreementPaymentDates': MemberSpec_('masterAgreementPaymentDates', 'xsd:boolean', 0),
    }
    subclass = None
    superclass = CommoditySwapLeg
    def __init__(self, id=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, fixedPrice=None, totalPrice=None, quantityReference=None, relativePaymentDates=None, paymentDates=None, masterAgreementPaymentDates=None):
        self.original_tagname_ = None
        super(NonPeriodicFixedPriceLeg, self).__init__(id, )
        self.payerPartyReference = payerPartyReference
        self.payerAccountReference = payerAccountReference
        self.receiverPartyReference = receiverPartyReference
        self.receiverAccountReference = receiverAccountReference
        self.fixedPrice = fixedPrice
        self.totalPrice = totalPrice
        self.quantityReference = quantityReference
        self.relativePaymentDates = relativePaymentDates
        self.paymentDates = paymentDates
        self.masterAgreementPaymentDates = masterAgreementPaymentDates
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NonPeriodicFixedPriceLeg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NonPeriodicFixedPriceLeg.subclass:
            return NonPeriodicFixedPriceLeg.subclass(*args_, **kwargs_)
        else:
            return NonPeriodicFixedPriceLeg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_payerPartyReference(self): return self.payerPartyReference
    def set_payerPartyReference(self, payerPartyReference): self.payerPartyReference = payerPartyReference
    def get_payerAccountReference(self): return self.payerAccountReference
    def set_payerAccountReference(self, payerAccountReference): self.payerAccountReference = payerAccountReference
    def get_receiverPartyReference(self): return self.receiverPartyReference
    def set_receiverPartyReference(self, receiverPartyReference): self.receiverPartyReference = receiverPartyReference
    def get_receiverAccountReference(self): return self.receiverAccountReference
    def set_receiverAccountReference(self, receiverAccountReference): self.receiverAccountReference = receiverAccountReference
    def get_fixedPrice(self): return self.fixedPrice
    def set_fixedPrice(self, fixedPrice): self.fixedPrice = fixedPrice
    def get_totalPrice(self): return self.totalPrice
    def set_totalPrice(self, totalPrice): self.totalPrice = totalPrice
    def get_quantityReference(self): return self.quantityReference
    def set_quantityReference(self, quantityReference): self.quantityReference = quantityReference
    def get_relativePaymentDates(self): return self.relativePaymentDates
    def set_relativePaymentDates(self, relativePaymentDates): self.relativePaymentDates = relativePaymentDates
    def get_paymentDates(self): return self.paymentDates
    def set_paymentDates(self, paymentDates): self.paymentDates = paymentDates
    def get_masterAgreementPaymentDates(self): return self.masterAgreementPaymentDates
    def set_masterAgreementPaymentDates(self, masterAgreementPaymentDates): self.masterAgreementPaymentDates = masterAgreementPaymentDates
    def hasContent_(self):
        if (
            self.payerPartyReference is not None or
            self.payerAccountReference is not None or
            self.receiverPartyReference is not None or
            self.receiverAccountReference is not None or
            self.fixedPrice is not None or
            self.totalPrice is not None or
            self.quantityReference is not None or
            self.relativePaymentDates is not None or
            self.paymentDates is not None or
            self.masterAgreementPaymentDates is not None or
            super(NonPeriodicFixedPriceLeg, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NonPeriodicFixedPriceLeg', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NonPeriodicFixedPriceLeg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NonPeriodicFixedPriceLeg', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NonPeriodicFixedPriceLeg'):
        super(NonPeriodicFixedPriceLeg, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NonPeriodicFixedPriceLeg')
    def exportChildren(self, outfile, level, namespace_='', name_='NonPeriodicFixedPriceLeg', fromsubclass_=False, pretty_print=True):
        super(NonPeriodicFixedPriceLeg, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.payerPartyReference is not None:
            self.payerPartyReference.export(outfile, level, namespace_, name_='payerPartyReference', pretty_print=pretty_print)
        if self.payerAccountReference is not None:
            self.payerAccountReference.export(outfile, level, namespace_, name_='payerAccountReference', pretty_print=pretty_print)
        if self.receiverPartyReference is not None:
            self.receiverPartyReference.export(outfile, level, namespace_, name_='receiverPartyReference', pretty_print=pretty_print)
        if self.receiverAccountReference is not None:
            self.receiverAccountReference.export(outfile, level, namespace_, name_='receiverAccountReference', pretty_print=pretty_print)
        if self.fixedPrice is not None:
            self.fixedPrice.export(outfile, level, namespace_, name_='fixedPrice', pretty_print=pretty_print)
        if self.totalPrice is not None:
            self.totalPrice.export(outfile, level, namespace_, name_='totalPrice', pretty_print=pretty_print)
        if self.quantityReference is not None:
            self.quantityReference.export(outfile, level, namespace_, name_='quantityReference', pretty_print=pretty_print)
        if self.relativePaymentDates is not None:
            self.relativePaymentDates.export(outfile, level, namespace_, name_='relativePaymentDates', pretty_print=pretty_print)
        if self.paymentDates is not None:
            self.paymentDates.export(outfile, level, namespace_, name_='paymentDates', pretty_print=pretty_print)
        if self.masterAgreementPaymentDates is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smasterAgreementPaymentDates>%s</%smasterAgreementPaymentDates>%s' % (namespace_, self.gds_format_boolean(self.masterAgreementPaymentDates, input_name='masterAgreementPaymentDates'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NonPeriodicFixedPriceLeg, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'payerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.payerPartyReference = obj_
            obj_.original_tagname_ = 'payerPartyReference'
        elif nodeName_ == 'payerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.payerAccountReference = obj_
            obj_.original_tagname_ = 'payerAccountReference'
        elif nodeName_ == 'receiverPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.receiverPartyReference = obj_
            obj_.original_tagname_ = 'receiverPartyReference'
        elif nodeName_ == 'receiverAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.receiverAccountReference = obj_
            obj_.original_tagname_ = 'receiverAccountReference'
        elif nodeName_ == 'fixedPrice':
            class_obj_ = self.get_class_obj_(child_, FixedPrice)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.fixedPrice = obj_
            obj_.original_tagname_ = 'fixedPrice'
        elif nodeName_ == 'totalPrice':
            class_obj_ = self.get_class_obj_(child_, NonNegativeMoney)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.totalPrice = obj_
            obj_.original_tagname_ = 'totalPrice'
        elif nodeName_ == 'quantityReference':
            obj_ = QuantityReference.factory()
            obj_.build(child_)
            self.quantityReference = obj_
            obj_.original_tagname_ = 'quantityReference'
        elif nodeName_ == 'relativePaymentDates':
            obj_ = CommodityRelativePaymentDates.factory()
            obj_.build(child_)
            self.relativePaymentDates = obj_
            obj_.original_tagname_ = 'relativePaymentDates'
        elif nodeName_ == 'paymentDates':
            obj_ = AdjustableDatesOrRelativeDateOffset.factory()
            obj_.build(child_)
            self.paymentDates = obj_
            obj_.original_tagname_ = 'paymentDates'
        elif nodeName_ == 'masterAgreementPaymentDates':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'masterAgreementPaymentDates')
            self.masterAgreementPaymentDates = ival_
        super(NonPeriodicFixedPriceLeg, self).buildChildren(child_, node, nodeName_, True)
# end class NonPeriodicFixedPriceLeg


class MetalPhysicalLeg(PhysicalForwardLeg):
    """Physically settled leg of a physically settled Metal transaction."""
    member_data_items_ = {
        'metal': MemberSpec_('metal', 'Metal', 0),
        'deliveryPeriods': MemberSpec_('deliveryPeriods', 'CommodityDeliveryPeriods', 0),
        'deliveryConditions': MemberSpec_('deliveryConditions', 'MetalDelivery', 0),
        'physicalQuantity': MemberSpec_('physicalQuantity', 'CommodityNotionalQuantity', 0),
        'physicalQuantitySchedule': MemberSpec_('physicalQuantitySchedule', 'CommodityPhysicalQuantitySchedule', 0),
        'totalPhysicalQuantity': MemberSpec_('totalPhysicalQuantity', 'UnitQuantity', 0),
        'conversionFactor': MemberSpec_('conversionFactor', 'xsd:decimal', 0),
    }
    subclass = None
    superclass = PhysicalForwardLeg
    def __init__(self, id=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, metal=None, deliveryPeriods=None, deliveryConditions=None, physicalQuantity=None, physicalQuantitySchedule=None, totalPhysicalQuantity=None, conversionFactor=None):
        self.original_tagname_ = None
        super(MetalPhysicalLeg, self).__init__(id, payerPartyReference, payerAccountReference, receiverPartyReference, receiverAccountReference, )
        self.metal = metal
        self.deliveryPeriods = deliveryPeriods
        self.deliveryConditions = deliveryConditions
        self.physicalQuantity = physicalQuantity
        self.physicalQuantitySchedule = physicalQuantitySchedule
        self.totalPhysicalQuantity = totalPhysicalQuantity
        self.conversionFactor = conversionFactor
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MetalPhysicalLeg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MetalPhysicalLeg.subclass:
            return MetalPhysicalLeg.subclass(*args_, **kwargs_)
        else:
            return MetalPhysicalLeg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_metal(self): return self.metal
    def set_metal(self, metal): self.metal = metal
    def get_deliveryPeriods(self): return self.deliveryPeriods
    def set_deliveryPeriods(self, deliveryPeriods): self.deliveryPeriods = deliveryPeriods
    def get_deliveryConditions(self): return self.deliveryConditions
    def set_deliveryConditions(self, deliveryConditions): self.deliveryConditions = deliveryConditions
    def get_physicalQuantity(self): return self.physicalQuantity
    def set_physicalQuantity(self, physicalQuantity): self.physicalQuantity = physicalQuantity
    def get_physicalQuantitySchedule(self): return self.physicalQuantitySchedule
    def set_physicalQuantitySchedule(self, physicalQuantitySchedule): self.physicalQuantitySchedule = physicalQuantitySchedule
    def get_totalPhysicalQuantity(self): return self.totalPhysicalQuantity
    def set_totalPhysicalQuantity(self, totalPhysicalQuantity): self.totalPhysicalQuantity = totalPhysicalQuantity
    def get_conversionFactor(self): return self.conversionFactor
    def set_conversionFactor(self, conversionFactor): self.conversionFactor = conversionFactor
    def hasContent_(self):
        if (
            self.metal is not None or
            self.deliveryPeriods is not None or
            self.deliveryConditions is not None or
            self.physicalQuantity is not None or
            self.physicalQuantitySchedule is not None or
            self.totalPhysicalQuantity is not None or
            self.conversionFactor is not None or
            super(MetalPhysicalLeg, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MetalPhysicalLeg', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MetalPhysicalLeg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MetalPhysicalLeg', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MetalPhysicalLeg'):
        super(MetalPhysicalLeg, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MetalPhysicalLeg')
    def exportChildren(self, outfile, level, namespace_='', name_='MetalPhysicalLeg', fromsubclass_=False, pretty_print=True):
        super(MetalPhysicalLeg, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.metal is not None:
            self.metal.export(outfile, level, namespace_, name_='metal', pretty_print=pretty_print)
        if self.deliveryPeriods is not None:
            self.deliveryPeriods.export(outfile, level, namespace_, name_='deliveryPeriods', pretty_print=pretty_print)
        if self.deliveryConditions is not None:
            self.deliveryConditions.export(outfile, level, namespace_, name_='deliveryConditions', pretty_print=pretty_print)
        if self.physicalQuantity is not None:
            self.physicalQuantity.export(outfile, level, namespace_, name_='physicalQuantity', pretty_print=pretty_print)
        if self.physicalQuantitySchedule is not None:
            self.physicalQuantitySchedule.export(outfile, level, namespace_, name_='physicalQuantitySchedule', pretty_print=pretty_print)
        if self.totalPhysicalQuantity is not None:
            self.totalPhysicalQuantity.export(outfile, level, namespace_, name_='totalPhysicalQuantity', pretty_print=pretty_print)
        if self.conversionFactor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sconversionFactor>%s</%sconversionFactor>%s' % (namespace_, self.gds_format_float(self.conversionFactor, input_name='conversionFactor'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MetalPhysicalLeg, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'metal':
            obj_ = Metal.factory()
            obj_.build(child_)
            self.metal = obj_
            obj_.original_tagname_ = 'metal'
        elif nodeName_ == 'deliveryPeriods':
            class_obj_ = self.get_class_obj_(child_, CommodityDeliveryPeriods)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.deliveryPeriods = obj_
            obj_.original_tagname_ = 'deliveryPeriods'
        elif nodeName_ == 'deliveryConditions':
            obj_ = MetalDelivery.factory()
            obj_.build(child_)
            self.deliveryConditions = obj_
            obj_.original_tagname_ = 'deliveryConditions'
        elif nodeName_ == 'physicalQuantity':
            class_obj_ = self.get_class_obj_(child_, CommodityNotionalQuantity)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.physicalQuantity = obj_
            obj_.original_tagname_ = 'physicalQuantity'
        elif nodeName_ == 'physicalQuantitySchedule':
            class_obj_ = self.get_class_obj_(child_, CommodityPhysicalQuantitySchedule)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.physicalQuantitySchedule = obj_
            obj_.original_tagname_ = 'physicalQuantitySchedule'
        elif nodeName_ == 'totalPhysicalQuantity':
            obj_ = UnitQuantity.factory()
            obj_.build(child_)
            self.totalPhysicalQuantity = obj_
            obj_.original_tagname_ = 'totalPhysicalQuantity'
        elif nodeName_ == 'conversionFactor':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'conversionFactor')
            self.conversionFactor = fval_
        super(MetalPhysicalLeg, self).buildChildren(child_, node, nodeName_, True)
# end class MetalPhysicalLeg


class GasPhysicalLeg(PhysicalSwapLeg):
    """Physically settled leg of a physically settled gas transaction."""
    member_data_items_ = {
        'deliveryPeriods': MemberSpec_('deliveryPeriods', 'GasDeliveryPeriods', 0),
        'gas': MemberSpec_('gas', 'GasProduct', 0),
        'deliveryConditions': MemberSpec_('deliveryConditions', 'GasDelivery', 0),
        'deliveryQuantity': MemberSpec_('deliveryQuantity', 'GasPhysicalQuantity', 0),
    }
    subclass = None
    superclass = PhysicalSwapLeg
    def __init__(self, id=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, deliveryPeriods=None, gas=None, deliveryConditions=None, deliveryQuantity=None):
        self.original_tagname_ = None
        super(GasPhysicalLeg, self).__init__(id, payerPartyReference, payerAccountReference, receiverPartyReference, receiverAccountReference, )
        self.deliveryPeriods = deliveryPeriods
        self.gas = gas
        self.deliveryConditions = deliveryConditions
        self.deliveryQuantity = deliveryQuantity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GasPhysicalLeg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GasPhysicalLeg.subclass:
            return GasPhysicalLeg.subclass(*args_, **kwargs_)
        else:
            return GasPhysicalLeg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_deliveryPeriods(self): return self.deliveryPeriods
    def set_deliveryPeriods(self, deliveryPeriods): self.deliveryPeriods = deliveryPeriods
    def get_gas(self): return self.gas
    def set_gas(self, gas): self.gas = gas
    def get_deliveryConditions(self): return self.deliveryConditions
    def set_deliveryConditions(self, deliveryConditions): self.deliveryConditions = deliveryConditions
    def get_deliveryQuantity(self): return self.deliveryQuantity
    def set_deliveryQuantity(self, deliveryQuantity): self.deliveryQuantity = deliveryQuantity
    def hasContent_(self):
        if (
            self.deliveryPeriods is not None or
            self.gas is not None or
            self.deliveryConditions is not None or
            self.deliveryQuantity is not None or
            super(GasPhysicalLeg, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GasPhysicalLeg', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GasPhysicalLeg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GasPhysicalLeg', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GasPhysicalLeg'):
        super(GasPhysicalLeg, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GasPhysicalLeg')
    def exportChildren(self, outfile, level, namespace_='', name_='GasPhysicalLeg', fromsubclass_=False, pretty_print=True):
        super(GasPhysicalLeg, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.deliveryPeriods is not None:
            self.deliveryPeriods.export(outfile, level, namespace_, name_='deliveryPeriods', pretty_print=pretty_print)
        if self.gas is not None:
            self.gas.export(outfile, level, namespace_, name_='gas', pretty_print=pretty_print)
        if self.deliveryConditions is not None:
            self.deliveryConditions.export(outfile, level, namespace_, name_='deliveryConditions', pretty_print=pretty_print)
        if self.deliveryQuantity is not None:
            self.deliveryQuantity.export(outfile, level, namespace_, name_='deliveryQuantity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GasPhysicalLeg, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'deliveryPeriods':
            obj_ = GasDeliveryPeriods.factory()
            obj_.build(child_)
            self.deliveryPeriods = obj_
            obj_.original_tagname_ = 'deliveryPeriods'
        elif nodeName_ == 'gas':
            obj_ = GasProduct.factory()
            obj_.build(child_)
            self.gas = obj_
            obj_.original_tagname_ = 'gas'
        elif nodeName_ == 'deliveryConditions':
            obj_ = GasDelivery.factory()
            obj_.build(child_)
            self.deliveryConditions = obj_
            obj_.original_tagname_ = 'deliveryConditions'
        elif nodeName_ == 'deliveryQuantity':
            obj_ = GasPhysicalQuantity.factory()
            obj_.build(child_)
            self.deliveryQuantity = obj_
            obj_.original_tagname_ = 'deliveryQuantity'
        super(GasPhysicalLeg, self).buildChildren(child_, node, nodeName_, True)
# end class GasPhysicalLeg


class FinancialSwapLeg(CommoditySwapLeg):
    """The common components of a financially settled leg of a Commodity
    Swap. This is an abstract type and should be extended by
    commodity-specific types."""
    member_data_items_ = {
        'payerPartyReference': MemberSpec_('payerPartyReference', 'PartyReference', 0),
        'payerAccountReference': MemberSpec_('payerAccountReference', 'AccountReference', 0),
        'receiverPartyReference': MemberSpec_('receiverPartyReference', 'PartyReference', 0),
        'receiverAccountReference': MemberSpec_('receiverAccountReference', 'AccountReference', 0),
    }
    subclass = None
    superclass = CommoditySwapLeg
    def __init__(self, id=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, extensiontype_=None):
        self.original_tagname_ = None
        super(FinancialSwapLeg, self).__init__(id, extensiontype_, )
        self.payerPartyReference = payerPartyReference
        self.payerAccountReference = payerAccountReference
        self.receiverPartyReference = receiverPartyReference
        self.receiverAccountReference = receiverAccountReference
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FinancialSwapLeg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FinancialSwapLeg.subclass:
            return FinancialSwapLeg.subclass(*args_, **kwargs_)
        else:
            return FinancialSwapLeg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_payerPartyReference(self): return self.payerPartyReference
    def set_payerPartyReference(self, payerPartyReference): self.payerPartyReference = payerPartyReference
    def get_payerAccountReference(self): return self.payerAccountReference
    def set_payerAccountReference(self, payerAccountReference): self.payerAccountReference = payerAccountReference
    def get_receiverPartyReference(self): return self.receiverPartyReference
    def set_receiverPartyReference(self, receiverPartyReference): self.receiverPartyReference = receiverPartyReference
    def get_receiverAccountReference(self): return self.receiverAccountReference
    def set_receiverAccountReference(self, receiverAccountReference): self.receiverAccountReference = receiverAccountReference
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.payerPartyReference is not None or
            self.payerAccountReference is not None or
            self.receiverPartyReference is not None or
            self.receiverAccountReference is not None or
            super(FinancialSwapLeg, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FinancialSwapLeg', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FinancialSwapLeg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FinancialSwapLeg', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FinancialSwapLeg'):
        super(FinancialSwapLeg, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FinancialSwapLeg')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='FinancialSwapLeg', fromsubclass_=False, pretty_print=True):
        super(FinancialSwapLeg, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.payerPartyReference is not None:
            self.payerPartyReference.export(outfile, level, namespace_, name_='payerPartyReference', pretty_print=pretty_print)
        if self.payerAccountReference is not None:
            self.payerAccountReference.export(outfile, level, namespace_, name_='payerAccountReference', pretty_print=pretty_print)
        if self.receiverPartyReference is not None:
            self.receiverPartyReference.export(outfile, level, namespace_, name_='receiverPartyReference', pretty_print=pretty_print)
        if self.receiverAccountReference is not None:
            self.receiverAccountReference.export(outfile, level, namespace_, name_='receiverAccountReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(FinancialSwapLeg, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'payerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.payerPartyReference = obj_
            obj_.original_tagname_ = 'payerPartyReference'
        elif nodeName_ == 'payerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.payerAccountReference = obj_
            obj_.original_tagname_ = 'payerAccountReference'
        elif nodeName_ == 'receiverPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.receiverPartyReference = obj_
            obj_.original_tagname_ = 'receiverPartyReference'
        elif nodeName_ == 'receiverAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.receiverAccountReference = obj_
            obj_.original_tagname_ = 'receiverAccountReference'
        super(FinancialSwapLeg, self).buildChildren(child_, node, nodeName_, True)
# end class FinancialSwapLeg


class EnvironmentalPhysicalLeg(PhysicalSwapLeg):
    """The environmental physical leg describes the nature of the physical
    underlying, quantities and delivery conditions relating to
    environmental allowances and certificates such as EU emissions
    allowances, water pollution credits and the like."""
    member_data_items_ = {
        'numberOfAllowances': MemberSpec_('numberOfAllowances', 'UnitQuantity', 0),
        'environmental': MemberSpec_('environmental', 'EnvironmentalProduct', 0),
        'abandonmentOfScheme': MemberSpec_('abandonmentOfScheme', ['EnvironmentalAbandonmentOfSchemeEnum', 'Token', 'xsd:token'], 0),
        'deliveryDate': MemberSpec_('deliveryDate', 'AdjustableOrRelativeDate', 0),
        'paymentDate': MemberSpec_('paymentDate', 'DateOffset', 0),
        'businessCentersReference': MemberSpec_('businessCentersReference', 'BusinessCentersReference', 0),
        'businessCenters': MemberSpec_('businessCenters', 'BusinessCenters', 0),
        'failureToDeliverApplicable': MemberSpec_('failureToDeliverApplicable', 'xsd:boolean', 0),
        'eEPParameters': MemberSpec_('eEPParameters', 'EEPParameters', 0),
    }
    subclass = None
    superclass = PhysicalSwapLeg
    def __init__(self, id=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, numberOfAllowances=None, environmental=None, abandonmentOfScheme=None, deliveryDate=None, paymentDate=None, businessCentersReference=None, businessCenters=None, failureToDeliverApplicable=None, eEPParameters=None):
        self.original_tagname_ = None
        super(EnvironmentalPhysicalLeg, self).__init__(id, payerPartyReference, payerAccountReference, receiverPartyReference, receiverAccountReference, )
        self.numberOfAllowances = numberOfAllowances
        self.environmental = environmental
        self.abandonmentOfScheme = abandonmentOfScheme
        self.validate_EnvironmentalAbandonmentOfSchemeEnum(self.abandonmentOfScheme)
        self.deliveryDate = deliveryDate
        self.paymentDate = paymentDate
        self.businessCentersReference = businessCentersReference
        self.businessCenters = businessCenters
        self.failureToDeliverApplicable = failureToDeliverApplicable
        self.eEPParameters = eEPParameters
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnvironmentalPhysicalLeg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnvironmentalPhysicalLeg.subclass:
            return EnvironmentalPhysicalLeg.subclass(*args_, **kwargs_)
        else:
            return EnvironmentalPhysicalLeg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_numberOfAllowances(self): return self.numberOfAllowances
    def set_numberOfAllowances(self, numberOfAllowances): self.numberOfAllowances = numberOfAllowances
    def get_environmental(self): return self.environmental
    def set_environmental(self, environmental): self.environmental = environmental
    def get_abandonmentOfScheme(self): return self.abandonmentOfScheme
    def set_abandonmentOfScheme(self, abandonmentOfScheme): self.abandonmentOfScheme = abandonmentOfScheme
    def get_deliveryDate(self): return self.deliveryDate
    def set_deliveryDate(self, deliveryDate): self.deliveryDate = deliveryDate
    def get_paymentDate(self): return self.paymentDate
    def set_paymentDate(self, paymentDate): self.paymentDate = paymentDate
    def get_businessCentersReference(self): return self.businessCentersReference
    def set_businessCentersReference(self, businessCentersReference): self.businessCentersReference = businessCentersReference
    def get_businessCenters(self): return self.businessCenters
    def set_businessCenters(self, businessCenters): self.businessCenters = businessCenters
    def get_failureToDeliverApplicable(self): return self.failureToDeliverApplicable
    def set_failureToDeliverApplicable(self, failureToDeliverApplicable): self.failureToDeliverApplicable = failureToDeliverApplicable
    def get_eEPParameters(self): return self.eEPParameters
    def set_eEPParameters(self, eEPParameters): self.eEPParameters = eEPParameters
    def validate_EnvironmentalAbandonmentOfSchemeEnum(self, value):
        # Validate type EnvironmentalAbandonmentOfSchemeEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['OptionA(1)', 'OptionA(2)', 'OptionB', 'OptionC']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on EnvironmentalAbandonmentOfSchemeEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on EnvironmentalAbandonmentOfSchemeEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.numberOfAllowances is not None or
            self.environmental is not None or
            self.abandonmentOfScheme is not None or
            self.deliveryDate is not None or
            self.paymentDate is not None or
            self.businessCentersReference is not None or
            self.businessCenters is not None or
            self.failureToDeliverApplicable is not None or
            self.eEPParameters is not None or
            super(EnvironmentalPhysicalLeg, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EnvironmentalPhysicalLeg', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnvironmentalPhysicalLeg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EnvironmentalPhysicalLeg', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EnvironmentalPhysicalLeg'):
        super(EnvironmentalPhysicalLeg, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EnvironmentalPhysicalLeg')
    def exportChildren(self, outfile, level, namespace_='', name_='EnvironmentalPhysicalLeg', fromsubclass_=False, pretty_print=True):
        super(EnvironmentalPhysicalLeg, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.numberOfAllowances is not None:
            self.numberOfAllowances.export(outfile, level, namespace_, name_='numberOfAllowances', pretty_print=pretty_print)
        if self.environmental is not None:
            self.environmental.export(outfile, level, namespace_, name_='environmental', pretty_print=pretty_print)
        if self.abandonmentOfScheme is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sabandonmentOfScheme>%s</%sabandonmentOfScheme>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.abandonmentOfScheme), input_name='abandonmentOfScheme')), namespace_, eol_))
        if self.deliveryDate is not None:
            self.deliveryDate.export(outfile, level, namespace_, name_='deliveryDate', pretty_print=pretty_print)
        if self.paymentDate is not None:
            self.paymentDate.export(outfile, level, namespace_, name_='paymentDate', pretty_print=pretty_print)
        if self.businessCentersReference is not None:
            self.businessCentersReference.export(outfile, level, namespace_, name_='businessCentersReference', pretty_print=pretty_print)
        if self.businessCenters is not None:
            self.businessCenters.export(outfile, level, namespace_, name_='businessCenters', pretty_print=pretty_print)
        if self.failureToDeliverApplicable is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfailureToDeliverApplicable>%s</%sfailureToDeliverApplicable>%s' % (namespace_, self.gds_format_boolean(self.failureToDeliverApplicable, input_name='failureToDeliverApplicable'), namespace_, eol_))
        if self.eEPParameters is not None:
            self.eEPParameters.export(outfile, level, namespace_, name_='eEPParameters', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EnvironmentalPhysicalLeg, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'numberOfAllowances':
            obj_ = UnitQuantity.factory()
            obj_.build(child_)
            self.numberOfAllowances = obj_
            obj_.original_tagname_ = 'numberOfAllowances'
        elif nodeName_ == 'environmental':
            obj_ = EnvironmentalProduct.factory()
            obj_.build(child_)
            self.environmental = obj_
            obj_.original_tagname_ = 'environmental'
        elif nodeName_ == 'abandonmentOfScheme':
            abandonmentOfScheme_ = child_.text
            abandonmentOfScheme_ = re_.sub(String_cleanup_pat_, " ", abandonmentOfScheme_).strip()
            abandonmentOfScheme_ = self.gds_validate_string(abandonmentOfScheme_, node, 'abandonmentOfScheme')
            self.abandonmentOfScheme = abandonmentOfScheme_
            # validate type EnvironmentalAbandonmentOfSchemeEnum
            self.validate_EnvironmentalAbandonmentOfSchemeEnum(self.abandonmentOfScheme)
        elif nodeName_ == 'deliveryDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.deliveryDate = obj_
            obj_.original_tagname_ = 'deliveryDate'
        elif nodeName_ == 'paymentDate':
            obj_ = DateOffset.factory()
            obj_.build(child_)
            self.paymentDate = obj_
            obj_.original_tagname_ = 'paymentDate'
        elif nodeName_ == 'businessCentersReference':
            obj_ = BusinessCentersReference.factory()
            obj_.build(child_)
            self.businessCentersReference = obj_
            obj_.original_tagname_ = 'businessCentersReference'
        elif nodeName_ == 'businessCenters':
            obj_ = BusinessCenters.factory()
            obj_.build(child_)
            self.businessCenters = obj_
            obj_.original_tagname_ = 'businessCenters'
        elif nodeName_ == 'failureToDeliverApplicable':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'failureToDeliverApplicable')
            self.failureToDeliverApplicable = ival_
        elif nodeName_ == 'eEPParameters':
            obj_ = EEPParameters.factory()
            obj_.build(child_)
            self.eEPParameters = obj_
            obj_.original_tagname_ = 'eEPParameters'
        super(EnvironmentalPhysicalLeg, self).buildChildren(child_, node, nodeName_, True)
# end class EnvironmentalPhysicalLeg


class ElectricityPhysicalLeg(PhysicalSwapLeg):
    """Physically settled leg of a physically settled electricity
    transaction."""
    member_data_items_ = {
        'deliveryPeriods': MemberSpec_('deliveryPeriods', 'CommodityDeliveryPeriods', 0),
        'settlementPeriods': MemberSpec_('settlementPeriods', 'SettlementPeriods', 1),
        'settlementPeriodsSchedule': MemberSpec_('settlementPeriodsSchedule', 'SettlementPeriodsSchedule', 0),
        'loadType': MemberSpec_('loadType', ['LoadTypeEnum', 'Token', 'xsd:token'], 0),
        'electricity': MemberSpec_('electricity', 'ElectricityProduct', 0),
        'deliveryConditions': MemberSpec_('deliveryConditions', 'ElectricityDelivery', 0),
        'deliveryQuantity': MemberSpec_('deliveryQuantity', 'ElectricityPhysicalQuantity', 0),
    }
    subclass = None
    superclass = PhysicalSwapLeg
    def __init__(self, id=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, deliveryPeriods=None, settlementPeriods=None, settlementPeriodsSchedule=None, loadType=None, electricity=None, deliveryConditions=None, deliveryQuantity=None):
        self.original_tagname_ = None
        super(ElectricityPhysicalLeg, self).__init__(id, payerPartyReference, payerAccountReference, receiverPartyReference, receiverAccountReference, )
        self.deliveryPeriods = deliveryPeriods
        if settlementPeriods is None:
            self.settlementPeriods = []
        else:
            self.settlementPeriods = settlementPeriods
        self.settlementPeriodsSchedule = settlementPeriodsSchedule
        self.loadType = loadType
        self.validate_LoadTypeEnum(self.loadType)
        self.electricity = electricity
        self.deliveryConditions = deliveryConditions
        self.deliveryQuantity = deliveryQuantity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricityPhysicalLeg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricityPhysicalLeg.subclass:
            return ElectricityPhysicalLeg.subclass(*args_, **kwargs_)
        else:
            return ElectricityPhysicalLeg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_deliveryPeriods(self): return self.deliveryPeriods
    def set_deliveryPeriods(self, deliveryPeriods): self.deliveryPeriods = deliveryPeriods
    def get_settlementPeriods(self): return self.settlementPeriods
    def set_settlementPeriods(self, settlementPeriods): self.settlementPeriods = settlementPeriods
    def add_settlementPeriods(self, value): self.settlementPeriods.append(value)
    def insert_settlementPeriods_at(self, index, value): self.settlementPeriods.insert(index, value)
    def replace_settlementPeriods_at(self, index, value): self.settlementPeriods[index] = value
    def get_settlementPeriodsSchedule(self): return self.settlementPeriodsSchedule
    def set_settlementPeriodsSchedule(self, settlementPeriodsSchedule): self.settlementPeriodsSchedule = settlementPeriodsSchedule
    def get_loadType(self): return self.loadType
    def set_loadType(self, loadType): self.loadType = loadType
    def get_electricity(self): return self.electricity
    def set_electricity(self, electricity): self.electricity = electricity
    def get_deliveryConditions(self): return self.deliveryConditions
    def set_deliveryConditions(self, deliveryConditions): self.deliveryConditions = deliveryConditions
    def get_deliveryQuantity(self): return self.deliveryQuantity
    def set_deliveryQuantity(self, deliveryQuantity): self.deliveryQuantity = deliveryQuantity
    def validate_LoadTypeEnum(self, value):
        # Validate type LoadTypeEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Base', 'Peak', 'OffPeak', 'BlockHours', 'Custom']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on LoadTypeEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on LoadTypeEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.deliveryPeriods is not None or
            self.settlementPeriods or
            self.settlementPeriodsSchedule is not None or
            self.loadType is not None or
            self.electricity is not None or
            self.deliveryConditions is not None or
            self.deliveryQuantity is not None or
            super(ElectricityPhysicalLeg, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ElectricityPhysicalLeg', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricityPhysicalLeg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ElectricityPhysicalLeg', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ElectricityPhysicalLeg'):
        super(ElectricityPhysicalLeg, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricityPhysicalLeg')
    def exportChildren(self, outfile, level, namespace_='', name_='ElectricityPhysicalLeg', fromsubclass_=False, pretty_print=True):
        super(ElectricityPhysicalLeg, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.deliveryPeriods is not None:
            self.deliveryPeriods.export(outfile, level, namespace_, name_='deliveryPeriods', pretty_print=pretty_print)
        for settlementPeriods_ in self.settlementPeriods:
            settlementPeriods_.export(outfile, level, namespace_, name_='settlementPeriods', pretty_print=pretty_print)
        if self.settlementPeriodsSchedule is not None:
            self.settlementPeriodsSchedule.export(outfile, level, namespace_, name_='settlementPeriodsSchedule', pretty_print=pretty_print)
        if self.loadType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sloadType>%s</%sloadType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.loadType), input_name='loadType')), namespace_, eol_))
        if self.electricity is not None:
            self.electricity.export(outfile, level, namespace_, name_='electricity', pretty_print=pretty_print)
        if self.deliveryConditions is not None:
            self.deliveryConditions.export(outfile, level, namespace_, name_='deliveryConditions', pretty_print=pretty_print)
        if self.deliveryQuantity is not None:
            self.deliveryQuantity.export(outfile, level, namespace_, name_='deliveryQuantity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ElectricityPhysicalLeg, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'deliveryPeriods':
            class_obj_ = self.get_class_obj_(child_, CommodityDeliveryPeriods)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.deliveryPeriods = obj_
            obj_.original_tagname_ = 'deliveryPeriods'
        elif nodeName_ == 'settlementPeriods':
            obj_ = SettlementPeriods.factory()
            obj_.build(child_)
            self.settlementPeriods.append(obj_)
            obj_.original_tagname_ = 'settlementPeriods'
        elif nodeName_ == 'settlementPeriodsSchedule':
            obj_ = SettlementPeriodsSchedule.factory()
            obj_.build(child_)
            self.settlementPeriodsSchedule = obj_
            obj_.original_tagname_ = 'settlementPeriodsSchedule'
        elif nodeName_ == 'loadType':
            loadType_ = child_.text
            loadType_ = re_.sub(String_cleanup_pat_, " ", loadType_).strip()
            loadType_ = self.gds_validate_string(loadType_, node, 'loadType')
            self.loadType = loadType_
            # validate type LoadTypeEnum
            self.validate_LoadTypeEnum(self.loadType)
        elif nodeName_ == 'electricity':
            obj_ = ElectricityProduct.factory()
            obj_.build(child_)
            self.electricity = obj_
            obj_.original_tagname_ = 'electricity'
        elif nodeName_ == 'deliveryConditions':
            obj_ = ElectricityDelivery.factory()
            obj_.build(child_)
            self.deliveryConditions = obj_
            obj_.original_tagname_ = 'deliveryConditions'
        elif nodeName_ == 'deliveryQuantity':
            obj_ = ElectricityPhysicalQuantity.factory()
            obj_.build(child_)
            self.deliveryQuantity = obj_
            obj_.original_tagname_ = 'deliveryQuantity'
        super(ElectricityPhysicalLeg, self).buildChildren(child_, node, nodeName_, True)
# end class ElectricityPhysicalLeg


class CommodityVarianceLeg(CommodityPerformanceSwapLeg):
    """A type describing the variance leg of a commodity variance swap."""
    member_data_items_ = {
        'calculationDates': MemberSpec_('calculationDates', 'AdjustableDates', 0),
        'calculationPeriods': MemberSpec_('calculationPeriods', 'AdjustableDates', 0),
        'calculationPeriodsSchedule': MemberSpec_('calculationPeriodsSchedule', 'CommodityCalculationPeriodsSchedule', 0),
        'calculationPeriodsReference': MemberSpec_('calculationPeriodsReference', 'CalculationPeriodsReference', 0),
        'calculationPeriodsScheduleReference': MemberSpec_('calculationPeriodsScheduleReference', 'CalculationPeriodsScheduleReference', 0),
        'calculationPeriodsDatesReference': MemberSpec_('calculationPeriodsDatesReference', 'CalculationPeriodsDatesReference', 0),
        'relativePaymentDates': MemberSpec_('relativePaymentDates', 'CommodityRelativePaymentDates', 0),
        'paymentDates': MemberSpec_('paymentDates', 'AdjustableDatesOrRelativeDateOffset', 0),
        'masterAgreementPaymentDates': MemberSpec_('masterAgreementPaymentDates', 'xsd:boolean', 0),
        'commodity': MemberSpec_('commodity', 'Commodity', 0),
        'commodityBasket': MemberSpec_('commodityBasket', 'CommodityBasket', 0),
        'notionalAmount': MemberSpec_('notionalAmount', 'CommodityNotionalAmount', 0),
        'notionalAmountReference': MemberSpec_('notionalAmountReference', 'CommodityNotionalAmountReference', 0),
        'varianceStrikePrice': MemberSpec_('varianceStrikePrice', 'xsd:decimal', 0),
        'volatilityStrikePrice': MemberSpec_('volatilityStrikePrice', 'xsd:decimal', 0),
        'varianceCalculation': MemberSpec_('varianceCalculation', 'CommodityVarianceCalculation', 0),
    }
    subclass = None
    superclass = CommodityPerformanceSwapLeg
    def __init__(self, id=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, calculationDates=None, calculationPeriods=None, calculationPeriodsSchedule=None, calculationPeriodsReference=None, calculationPeriodsScheduleReference=None, calculationPeriodsDatesReference=None, relativePaymentDates=None, paymentDates=None, masterAgreementPaymentDates=None, commodity=None, commodityBasket=None, notionalAmount=None, notionalAmountReference=None, varianceStrikePrice=None, volatilityStrikePrice=None, varianceCalculation=None):
        self.original_tagname_ = None
        super(CommodityVarianceLeg, self).__init__(id, payerPartyReference, payerAccountReference, receiverPartyReference, receiverAccountReference, )
        self.calculationDates = calculationDates
        self.calculationPeriods = calculationPeriods
        self.calculationPeriodsSchedule = calculationPeriodsSchedule
        self.calculationPeriodsReference = calculationPeriodsReference
        self.calculationPeriodsScheduleReference = calculationPeriodsScheduleReference
        self.calculationPeriodsDatesReference = calculationPeriodsDatesReference
        self.relativePaymentDates = relativePaymentDates
        self.paymentDates = paymentDates
        self.masterAgreementPaymentDates = masterAgreementPaymentDates
        self.commodity = commodity
        self.commodityBasket = commodityBasket
        self.notionalAmount = notionalAmount
        self.notionalAmountReference = notionalAmountReference
        self.varianceStrikePrice = varianceStrikePrice
        self.volatilityStrikePrice = volatilityStrikePrice
        self.varianceCalculation = varianceCalculation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityVarianceLeg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityVarianceLeg.subclass:
            return CommodityVarianceLeg.subclass(*args_, **kwargs_)
        else:
            return CommodityVarianceLeg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_calculationDates(self): return self.calculationDates
    def set_calculationDates(self, calculationDates): self.calculationDates = calculationDates
    def get_calculationPeriods(self): return self.calculationPeriods
    def set_calculationPeriods(self, calculationPeriods): self.calculationPeriods = calculationPeriods
    def get_calculationPeriodsSchedule(self): return self.calculationPeriodsSchedule
    def set_calculationPeriodsSchedule(self, calculationPeriodsSchedule): self.calculationPeriodsSchedule = calculationPeriodsSchedule
    def get_calculationPeriodsReference(self): return self.calculationPeriodsReference
    def set_calculationPeriodsReference(self, calculationPeriodsReference): self.calculationPeriodsReference = calculationPeriodsReference
    def get_calculationPeriodsScheduleReference(self): return self.calculationPeriodsScheduleReference
    def set_calculationPeriodsScheduleReference(self, calculationPeriodsScheduleReference): self.calculationPeriodsScheduleReference = calculationPeriodsScheduleReference
    def get_calculationPeriodsDatesReference(self): return self.calculationPeriodsDatesReference
    def set_calculationPeriodsDatesReference(self, calculationPeriodsDatesReference): self.calculationPeriodsDatesReference = calculationPeriodsDatesReference
    def get_relativePaymentDates(self): return self.relativePaymentDates
    def set_relativePaymentDates(self, relativePaymentDates): self.relativePaymentDates = relativePaymentDates
    def get_paymentDates(self): return self.paymentDates
    def set_paymentDates(self, paymentDates): self.paymentDates = paymentDates
    def get_masterAgreementPaymentDates(self): return self.masterAgreementPaymentDates
    def set_masterAgreementPaymentDates(self, masterAgreementPaymentDates): self.masterAgreementPaymentDates = masterAgreementPaymentDates
    def get_commodity(self): return self.commodity
    def set_commodity(self, commodity): self.commodity = commodity
    def get_commodityBasket(self): return self.commodityBasket
    def set_commodityBasket(self, commodityBasket): self.commodityBasket = commodityBasket
    def get_notionalAmount(self): return self.notionalAmount
    def set_notionalAmount(self, notionalAmount): self.notionalAmount = notionalAmount
    def get_notionalAmountReference(self): return self.notionalAmountReference
    def set_notionalAmountReference(self, notionalAmountReference): self.notionalAmountReference = notionalAmountReference
    def get_varianceStrikePrice(self): return self.varianceStrikePrice
    def set_varianceStrikePrice(self, varianceStrikePrice): self.varianceStrikePrice = varianceStrikePrice
    def get_volatilityStrikePrice(self): return self.volatilityStrikePrice
    def set_volatilityStrikePrice(self, volatilityStrikePrice): self.volatilityStrikePrice = volatilityStrikePrice
    def get_varianceCalculation(self): return self.varianceCalculation
    def set_varianceCalculation(self, varianceCalculation): self.varianceCalculation = varianceCalculation
    def hasContent_(self):
        if (
            self.calculationDates is not None or
            self.calculationPeriods is not None or
            self.calculationPeriodsSchedule is not None or
            self.calculationPeriodsReference is not None or
            self.calculationPeriodsScheduleReference is not None or
            self.calculationPeriodsDatesReference is not None or
            self.relativePaymentDates is not None or
            self.paymentDates is not None or
            self.masterAgreementPaymentDates is not None or
            self.commodity is not None or
            self.commodityBasket is not None or
            self.notionalAmount is not None or
            self.notionalAmountReference is not None or
            self.varianceStrikePrice is not None or
            self.volatilityStrikePrice is not None or
            self.varianceCalculation is not None or
            super(CommodityVarianceLeg, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityVarianceLeg', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityVarianceLeg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityVarianceLeg', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityVarianceLeg'):
        super(CommodityVarianceLeg, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityVarianceLeg')
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityVarianceLeg', fromsubclass_=False, pretty_print=True):
        super(CommodityVarianceLeg, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.calculationDates is not None:
            self.calculationDates.export(outfile, level, namespace_, name_='calculationDates', pretty_print=pretty_print)
        if self.calculationPeriods is not None:
            self.calculationPeriods.export(outfile, level, namespace_, name_='calculationPeriods', pretty_print=pretty_print)
        if self.calculationPeriodsSchedule is not None:
            self.calculationPeriodsSchedule.export(outfile, level, namespace_, name_='calculationPeriodsSchedule', pretty_print=pretty_print)
        if self.calculationPeriodsReference is not None:
            self.calculationPeriodsReference.export(outfile, level, namespace_, name_='calculationPeriodsReference', pretty_print=pretty_print)
        if self.calculationPeriodsScheduleReference is not None:
            self.calculationPeriodsScheduleReference.export(outfile, level, namespace_, name_='calculationPeriodsScheduleReference', pretty_print=pretty_print)
        if self.calculationPeriodsDatesReference is not None:
            self.calculationPeriodsDatesReference.export(outfile, level, namespace_, name_='calculationPeriodsDatesReference', pretty_print=pretty_print)
        if self.relativePaymentDates is not None:
            self.relativePaymentDates.export(outfile, level, namespace_, name_='relativePaymentDates', pretty_print=pretty_print)
        if self.paymentDates is not None:
            self.paymentDates.export(outfile, level, namespace_, name_='paymentDates', pretty_print=pretty_print)
        if self.masterAgreementPaymentDates is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smasterAgreementPaymentDates>%s</%smasterAgreementPaymentDates>%s' % (namespace_, self.gds_format_boolean(self.masterAgreementPaymentDates, input_name='masterAgreementPaymentDates'), namespace_, eol_))
        if self.commodity is not None:
            self.commodity.export(outfile, level, namespace_, name_='commodity', pretty_print=pretty_print)
        if self.commodityBasket is not None:
            self.commodityBasket.export(outfile, level, namespace_, name_='commodityBasket', pretty_print=pretty_print)
        if self.notionalAmount is not None:
            self.notionalAmount.export(outfile, level, namespace_, name_='notionalAmount', pretty_print=pretty_print)
        if self.notionalAmountReference is not None:
            self.notionalAmountReference.export(outfile, level, namespace_, name_='notionalAmountReference', pretty_print=pretty_print)
        if self.varianceStrikePrice is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svarianceStrikePrice>%s</%svarianceStrikePrice>%s' % (namespace_, self.gds_format_float(self.varianceStrikePrice, input_name='varianceStrikePrice'), namespace_, eol_))
        if self.volatilityStrikePrice is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svolatilityStrikePrice>%s</%svolatilityStrikePrice>%s' % (namespace_, self.gds_format_float(self.volatilityStrikePrice, input_name='volatilityStrikePrice'), namespace_, eol_))
        if self.varianceCalculation is not None:
            self.varianceCalculation.export(outfile, level, namespace_, name_='varianceCalculation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CommodityVarianceLeg, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'calculationDates':
            obj_ = AdjustableDates.factory()
            obj_.build(child_)
            self.calculationDates = obj_
            obj_.original_tagname_ = 'calculationDates'
        elif nodeName_ == 'calculationPeriods':
            obj_ = AdjustableDates.factory()
            obj_.build(child_)
            self.calculationPeriods = obj_
            obj_.original_tagname_ = 'calculationPeriods'
        elif nodeName_ == 'calculationPeriodsSchedule':
            obj_ = CommodityCalculationPeriodsSchedule.factory()
            obj_.build(child_)
            self.calculationPeriodsSchedule = obj_
            obj_.original_tagname_ = 'calculationPeriodsSchedule'
        elif nodeName_ == 'calculationPeriodsReference':
            obj_ = CalculationPeriodsReference.factory()
            obj_.build(child_)
            self.calculationPeriodsReference = obj_
            obj_.original_tagname_ = 'calculationPeriodsReference'
        elif nodeName_ == 'calculationPeriodsScheduleReference':
            obj_ = CalculationPeriodsScheduleReference.factory()
            obj_.build(child_)
            self.calculationPeriodsScheduleReference = obj_
            obj_.original_tagname_ = 'calculationPeriodsScheduleReference'
        elif nodeName_ == 'calculationPeriodsDatesReference':
            obj_ = CalculationPeriodsDatesReference.factory()
            obj_.build(child_)
            self.calculationPeriodsDatesReference = obj_
            obj_.original_tagname_ = 'calculationPeriodsDatesReference'
        elif nodeName_ == 'relativePaymentDates':
            obj_ = CommodityRelativePaymentDates.factory()
            obj_.build(child_)
            self.relativePaymentDates = obj_
            obj_.original_tagname_ = 'relativePaymentDates'
        elif nodeName_ == 'paymentDates':
            obj_ = AdjustableDatesOrRelativeDateOffset.factory()
            obj_.build(child_)
            self.paymentDates = obj_
            obj_.original_tagname_ = 'paymentDates'
        elif nodeName_ == 'masterAgreementPaymentDates':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'masterAgreementPaymentDates')
            self.masterAgreementPaymentDates = ival_
        elif nodeName_ == 'commodity':
            obj_ = Commodity.factory()
            obj_.build(child_)
            self.commodity = obj_
            obj_.original_tagname_ = 'commodity'
        elif nodeName_ == 'commodityBasket':
            obj_ = CommodityBasket.factory()
            obj_.build(child_)
            self.commodityBasket = obj_
            obj_.original_tagname_ = 'commodityBasket'
        elif nodeName_ == 'notionalAmount':
            obj_ = CommodityNotionalAmount.factory()
            obj_.build(child_)
            self.notionalAmount = obj_
            obj_.original_tagname_ = 'notionalAmount'
        elif nodeName_ == 'notionalAmountReference':
            obj_ = CommodityNotionalAmountReference.factory()
            obj_.build(child_)
            self.notionalAmountReference = obj_
            obj_.original_tagname_ = 'notionalAmountReference'
        elif nodeName_ == 'varianceStrikePrice':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'varianceStrikePrice')
            self.varianceStrikePrice = fval_
        elif nodeName_ == 'volatilityStrikePrice':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'volatilityStrikePrice')
            self.volatilityStrikePrice = fval_
        elif nodeName_ == 'varianceCalculation':
            obj_ = CommodityVarianceCalculation.factory()
            obj_.build(child_)
            self.varianceCalculation = obj_
            obj_.original_tagname_ = 'varianceCalculation'
        super(CommodityVarianceLeg, self).buildChildren(child_, node, nodeName_, True)
# end class CommodityVarianceLeg


class CommodityReturnLeg(CommodityPerformanceSwapLeg):
    """A type describing the return leg of a commodity return swap."""
    member_data_items_ = {
        'calculationDates': MemberSpec_('calculationDates', 'AdjustableDates', 0),
        'calculationPeriods': MemberSpec_('calculationPeriods', 'AdjustableDates', 0),
        'calculationPeriodsSchedule': MemberSpec_('calculationPeriodsSchedule', 'CommodityCalculationPeriodsSchedule', 0),
        'calculationPeriodsReference': MemberSpec_('calculationPeriodsReference', 'CalculationPeriodsReference', 0),
        'calculationPeriodsScheduleReference': MemberSpec_('calculationPeriodsScheduleReference', 'CalculationPeriodsScheduleReference', 0),
        'calculationPeriodsDatesReference': MemberSpec_('calculationPeriodsDatesReference', 'CalculationPeriodsDatesReference', 0),
        'relativePaymentDates': MemberSpec_('relativePaymentDates', 'CommodityRelativePaymentDates', 0),
        'paymentDates': MemberSpec_('paymentDates', 'AdjustableDatesOrRelativeDateOffset', 0),
        'masterAgreementPaymentDates': MemberSpec_('masterAgreementPaymentDates', 'xsd:boolean', 0),
        'commodity': MemberSpec_('commodity', 'Commodity', 0),
        'commodityBasket': MemberSpec_('commodityBasket', 'CommodityBasket', 0),
        'notionalAmount': MemberSpec_('notionalAmount', 'CommodityNotionalAmount', 0),
        'notionalAmountReference': MemberSpec_('notionalAmountReference', 'CommodityNotionalAmountReference', 0),
        'commodityReturnCalculation': MemberSpec_('commodityReturnCalculation', 'CommodityReturnCalculation', 0),
    }
    subclass = None
    superclass = CommodityPerformanceSwapLeg
    def __init__(self, id=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, calculationDates=None, calculationPeriods=None, calculationPeriodsSchedule=None, calculationPeriodsReference=None, calculationPeriodsScheduleReference=None, calculationPeriodsDatesReference=None, relativePaymentDates=None, paymentDates=None, masterAgreementPaymentDates=None, commodity=None, commodityBasket=None, notionalAmount=None, notionalAmountReference=None, commodityReturnCalculation=None):
        self.original_tagname_ = None
        super(CommodityReturnLeg, self).__init__(id, payerPartyReference, payerAccountReference, receiverPartyReference, receiverAccountReference, )
        self.calculationDates = calculationDates
        self.calculationPeriods = calculationPeriods
        self.calculationPeriodsSchedule = calculationPeriodsSchedule
        self.calculationPeriodsReference = calculationPeriodsReference
        self.calculationPeriodsScheduleReference = calculationPeriodsScheduleReference
        self.calculationPeriodsDatesReference = calculationPeriodsDatesReference
        self.relativePaymentDates = relativePaymentDates
        self.paymentDates = paymentDates
        self.masterAgreementPaymentDates = masterAgreementPaymentDates
        self.commodity = commodity
        self.commodityBasket = commodityBasket
        self.notionalAmount = notionalAmount
        self.notionalAmountReference = notionalAmountReference
        self.commodityReturnCalculation = commodityReturnCalculation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityReturnLeg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityReturnLeg.subclass:
            return CommodityReturnLeg.subclass(*args_, **kwargs_)
        else:
            return CommodityReturnLeg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_calculationDates(self): return self.calculationDates
    def set_calculationDates(self, calculationDates): self.calculationDates = calculationDates
    def get_calculationPeriods(self): return self.calculationPeriods
    def set_calculationPeriods(self, calculationPeriods): self.calculationPeriods = calculationPeriods
    def get_calculationPeriodsSchedule(self): return self.calculationPeriodsSchedule
    def set_calculationPeriodsSchedule(self, calculationPeriodsSchedule): self.calculationPeriodsSchedule = calculationPeriodsSchedule
    def get_calculationPeriodsReference(self): return self.calculationPeriodsReference
    def set_calculationPeriodsReference(self, calculationPeriodsReference): self.calculationPeriodsReference = calculationPeriodsReference
    def get_calculationPeriodsScheduleReference(self): return self.calculationPeriodsScheduleReference
    def set_calculationPeriodsScheduleReference(self, calculationPeriodsScheduleReference): self.calculationPeriodsScheduleReference = calculationPeriodsScheduleReference
    def get_calculationPeriodsDatesReference(self): return self.calculationPeriodsDatesReference
    def set_calculationPeriodsDatesReference(self, calculationPeriodsDatesReference): self.calculationPeriodsDatesReference = calculationPeriodsDatesReference
    def get_relativePaymentDates(self): return self.relativePaymentDates
    def set_relativePaymentDates(self, relativePaymentDates): self.relativePaymentDates = relativePaymentDates
    def get_paymentDates(self): return self.paymentDates
    def set_paymentDates(self, paymentDates): self.paymentDates = paymentDates
    def get_masterAgreementPaymentDates(self): return self.masterAgreementPaymentDates
    def set_masterAgreementPaymentDates(self, masterAgreementPaymentDates): self.masterAgreementPaymentDates = masterAgreementPaymentDates
    def get_commodity(self): return self.commodity
    def set_commodity(self, commodity): self.commodity = commodity
    def get_commodityBasket(self): return self.commodityBasket
    def set_commodityBasket(self, commodityBasket): self.commodityBasket = commodityBasket
    def get_notionalAmount(self): return self.notionalAmount
    def set_notionalAmount(self, notionalAmount): self.notionalAmount = notionalAmount
    def get_notionalAmountReference(self): return self.notionalAmountReference
    def set_notionalAmountReference(self, notionalAmountReference): self.notionalAmountReference = notionalAmountReference
    def get_commodityReturnCalculation(self): return self.commodityReturnCalculation
    def set_commodityReturnCalculation(self, commodityReturnCalculation): self.commodityReturnCalculation = commodityReturnCalculation
    def hasContent_(self):
        if (
            self.calculationDates is not None or
            self.calculationPeriods is not None or
            self.calculationPeriodsSchedule is not None or
            self.calculationPeriodsReference is not None or
            self.calculationPeriodsScheduleReference is not None or
            self.calculationPeriodsDatesReference is not None or
            self.relativePaymentDates is not None or
            self.paymentDates is not None or
            self.masterAgreementPaymentDates is not None or
            self.commodity is not None or
            self.commodityBasket is not None or
            self.notionalAmount is not None or
            self.notionalAmountReference is not None or
            self.commodityReturnCalculation is not None or
            super(CommodityReturnLeg, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityReturnLeg', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityReturnLeg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityReturnLeg', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityReturnLeg'):
        super(CommodityReturnLeg, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityReturnLeg')
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityReturnLeg', fromsubclass_=False, pretty_print=True):
        super(CommodityReturnLeg, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.calculationDates is not None:
            self.calculationDates.export(outfile, level, namespace_, name_='calculationDates', pretty_print=pretty_print)
        if self.calculationPeriods is not None:
            self.calculationPeriods.export(outfile, level, namespace_, name_='calculationPeriods', pretty_print=pretty_print)
        if self.calculationPeriodsSchedule is not None:
            self.calculationPeriodsSchedule.export(outfile, level, namespace_, name_='calculationPeriodsSchedule', pretty_print=pretty_print)
        if self.calculationPeriodsReference is not None:
            self.calculationPeriodsReference.export(outfile, level, namespace_, name_='calculationPeriodsReference', pretty_print=pretty_print)
        if self.calculationPeriodsScheduleReference is not None:
            self.calculationPeriodsScheduleReference.export(outfile, level, namespace_, name_='calculationPeriodsScheduleReference', pretty_print=pretty_print)
        if self.calculationPeriodsDatesReference is not None:
            self.calculationPeriodsDatesReference.export(outfile, level, namespace_, name_='calculationPeriodsDatesReference', pretty_print=pretty_print)
        if self.relativePaymentDates is not None:
            self.relativePaymentDates.export(outfile, level, namespace_, name_='relativePaymentDates', pretty_print=pretty_print)
        if self.paymentDates is not None:
            self.paymentDates.export(outfile, level, namespace_, name_='paymentDates', pretty_print=pretty_print)
        if self.masterAgreementPaymentDates is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smasterAgreementPaymentDates>%s</%smasterAgreementPaymentDates>%s' % (namespace_, self.gds_format_boolean(self.masterAgreementPaymentDates, input_name='masterAgreementPaymentDates'), namespace_, eol_))
        if self.commodity is not None:
            self.commodity.export(outfile, level, namespace_, name_='commodity', pretty_print=pretty_print)
        if self.commodityBasket is not None:
            self.commodityBasket.export(outfile, level, namespace_, name_='commodityBasket', pretty_print=pretty_print)
        if self.notionalAmount is not None:
            self.notionalAmount.export(outfile, level, namespace_, name_='notionalAmount', pretty_print=pretty_print)
        if self.notionalAmountReference is not None:
            self.notionalAmountReference.export(outfile, level, namespace_, name_='notionalAmountReference', pretty_print=pretty_print)
        if self.commodityReturnCalculation is not None:
            self.commodityReturnCalculation.export(outfile, level, namespace_, name_='commodityReturnCalculation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CommodityReturnLeg, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'calculationDates':
            obj_ = AdjustableDates.factory()
            obj_.build(child_)
            self.calculationDates = obj_
            obj_.original_tagname_ = 'calculationDates'
        elif nodeName_ == 'calculationPeriods':
            obj_ = AdjustableDates.factory()
            obj_.build(child_)
            self.calculationPeriods = obj_
            obj_.original_tagname_ = 'calculationPeriods'
        elif nodeName_ == 'calculationPeriodsSchedule':
            obj_ = CommodityCalculationPeriodsSchedule.factory()
            obj_.build(child_)
            self.calculationPeriodsSchedule = obj_
            obj_.original_tagname_ = 'calculationPeriodsSchedule'
        elif nodeName_ == 'calculationPeriodsReference':
            obj_ = CalculationPeriodsReference.factory()
            obj_.build(child_)
            self.calculationPeriodsReference = obj_
            obj_.original_tagname_ = 'calculationPeriodsReference'
        elif nodeName_ == 'calculationPeriodsScheduleReference':
            obj_ = CalculationPeriodsScheduleReference.factory()
            obj_.build(child_)
            self.calculationPeriodsScheduleReference = obj_
            obj_.original_tagname_ = 'calculationPeriodsScheduleReference'
        elif nodeName_ == 'calculationPeriodsDatesReference':
            obj_ = CalculationPeriodsDatesReference.factory()
            obj_.build(child_)
            self.calculationPeriodsDatesReference = obj_
            obj_.original_tagname_ = 'calculationPeriodsDatesReference'
        elif nodeName_ == 'relativePaymentDates':
            obj_ = CommodityRelativePaymentDates.factory()
            obj_.build(child_)
            self.relativePaymentDates = obj_
            obj_.original_tagname_ = 'relativePaymentDates'
        elif nodeName_ == 'paymentDates':
            obj_ = AdjustableDatesOrRelativeDateOffset.factory()
            obj_.build(child_)
            self.paymentDates = obj_
            obj_.original_tagname_ = 'paymentDates'
        elif nodeName_ == 'masterAgreementPaymentDates':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'masterAgreementPaymentDates')
            self.masterAgreementPaymentDates = ival_
        elif nodeName_ == 'commodity':
            obj_ = Commodity.factory()
            obj_.build(child_)
            self.commodity = obj_
            obj_.original_tagname_ = 'commodity'
        elif nodeName_ == 'commodityBasket':
            obj_ = CommodityBasket.factory()
            obj_.build(child_)
            self.commodityBasket = obj_
            obj_.original_tagname_ = 'commodityBasket'
        elif nodeName_ == 'notionalAmount':
            obj_ = CommodityNotionalAmount.factory()
            obj_.build(child_)
            self.notionalAmount = obj_
            obj_.original_tagname_ = 'notionalAmount'
        elif nodeName_ == 'notionalAmountReference':
            obj_ = CommodityNotionalAmountReference.factory()
            obj_.build(child_)
            self.notionalAmountReference = obj_
            obj_.original_tagname_ = 'notionalAmountReference'
        elif nodeName_ == 'commodityReturnCalculation':
            obj_ = CommodityReturnCalculation.factory()
            obj_.build(child_)
            self.commodityReturnCalculation = obj_
            obj_.original_tagname_ = 'commodityReturnCalculation'
        super(CommodityReturnLeg, self).buildChildren(child_, node, nodeName_, True)
# end class CommodityReturnLeg


class CoalPhysicalLeg(PhysicalSwapLeg):
    """Physically settled leg of a physically settled coal transaction."""
    member_data_items_ = {
        'deliveryPeriods': MemberSpec_('deliveryPeriods', 'CommodityDeliveryPeriods', 0),
        'coal': MemberSpec_('coal', 'CoalProduct', 0),
        'deliveryConditions': MemberSpec_('deliveryConditions', 'CoalDelivery', 0),
        'deliveryQuantity': MemberSpec_('deliveryQuantity', 'CommodityPhysicalQuantity', 0),
    }
    subclass = None
    superclass = PhysicalSwapLeg
    def __init__(self, id=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, deliveryPeriods=None, coal=None, deliveryConditions=None, deliveryQuantity=None):
        self.original_tagname_ = None
        super(CoalPhysicalLeg, self).__init__(id, payerPartyReference, payerAccountReference, receiverPartyReference, receiverAccountReference, )
        self.deliveryPeriods = deliveryPeriods
        self.coal = coal
        self.deliveryConditions = deliveryConditions
        self.deliveryQuantity = deliveryQuantity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CoalPhysicalLeg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoalPhysicalLeg.subclass:
            return CoalPhysicalLeg.subclass(*args_, **kwargs_)
        else:
            return CoalPhysicalLeg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_deliveryPeriods(self): return self.deliveryPeriods
    def set_deliveryPeriods(self, deliveryPeriods): self.deliveryPeriods = deliveryPeriods
    def get_coal(self): return self.coal
    def set_coal(self, coal): self.coal = coal
    def get_deliveryConditions(self): return self.deliveryConditions
    def set_deliveryConditions(self, deliveryConditions): self.deliveryConditions = deliveryConditions
    def get_deliveryQuantity(self): return self.deliveryQuantity
    def set_deliveryQuantity(self, deliveryQuantity): self.deliveryQuantity = deliveryQuantity
    def hasContent_(self):
        if (
            self.deliveryPeriods is not None or
            self.coal is not None or
            self.deliveryConditions is not None or
            self.deliveryQuantity is not None or
            super(CoalPhysicalLeg, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CoalPhysicalLeg', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CoalPhysicalLeg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CoalPhysicalLeg', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CoalPhysicalLeg'):
        super(CoalPhysicalLeg, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CoalPhysicalLeg')
    def exportChildren(self, outfile, level, namespace_='', name_='CoalPhysicalLeg', fromsubclass_=False, pretty_print=True):
        super(CoalPhysicalLeg, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.deliveryPeriods is not None:
            self.deliveryPeriods.export(outfile, level, namespace_, name_='deliveryPeriods', pretty_print=pretty_print)
        if self.coal is not None:
            self.coal.export(outfile, level, namespace_, name_='coal', pretty_print=pretty_print)
        if self.deliveryConditions is not None:
            self.deliveryConditions.export(outfile, level, namespace_, name_='deliveryConditions', pretty_print=pretty_print)
        if self.deliveryQuantity is not None:
            self.deliveryQuantity.export(outfile, level, namespace_, name_='deliveryQuantity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CoalPhysicalLeg, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'deliveryPeriods':
            class_obj_ = self.get_class_obj_(child_, CommodityDeliveryPeriods)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.deliveryPeriods = obj_
            obj_.original_tagname_ = 'deliveryPeriods'
        elif nodeName_ == 'coal':
            obj_ = CoalProduct.factory()
            obj_.build(child_)
            self.coal = obj_
            obj_.original_tagname_ = 'coal'
        elif nodeName_ == 'deliveryConditions':
            obj_ = CoalDelivery.factory()
            obj_.build(child_)
            self.deliveryConditions = obj_
            obj_.original_tagname_ = 'deliveryConditions'
        elif nodeName_ == 'deliveryQuantity':
            obj_ = CommodityPhysicalQuantity.factory()
            obj_.build(child_)
            self.deliveryQuantity = obj_
            obj_.original_tagname_ = 'deliveryQuantity'
        super(CoalPhysicalLeg, self).buildChildren(child_, node, nodeName_, True)
# end class CoalPhysicalLeg


class BullionPhysicalLeg(PhysicalForwardLeg):
    """Physically settled leg of a physically settled Bullion Transaction."""
    member_data_items_ = {
        'bullionType': MemberSpec_('bullionType', ['BullionTypeEnum', 'Token', 'xsd:token'], 0),
        'deliveryLocation': MemberSpec_('deliveryLocation', 'BullionDeliveryLocation', 0),
        'physicalQuantity': MemberSpec_('physicalQuantity', 'CommodityNotionalQuantity', 0),
        'physicalQuantitySchedule': MemberSpec_('physicalQuantitySchedule', 'CommodityPhysicalQuantitySchedule', 0),
        'totalPhysicalQuantity': MemberSpec_('totalPhysicalQuantity', 'UnitQuantity', 0),
        'settlementDate': MemberSpec_('settlementDate', 'AdjustableOrRelativeDate', 0),
    }
    subclass = None
    superclass = PhysicalForwardLeg
    def __init__(self, id=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, bullionType=None, deliveryLocation=None, physicalQuantity=None, physicalQuantitySchedule=None, totalPhysicalQuantity=None, settlementDate=None):
        self.original_tagname_ = None
        super(BullionPhysicalLeg, self).__init__(id, payerPartyReference, payerAccountReference, receiverPartyReference, receiverAccountReference, )
        self.bullionType = bullionType
        self.validate_BullionTypeEnum(self.bullionType)
        self.deliveryLocation = deliveryLocation
        self.physicalQuantity = physicalQuantity
        self.physicalQuantitySchedule = physicalQuantitySchedule
        self.totalPhysicalQuantity = totalPhysicalQuantity
        self.settlementDate = settlementDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BullionPhysicalLeg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BullionPhysicalLeg.subclass:
            return BullionPhysicalLeg.subclass(*args_, **kwargs_)
        else:
            return BullionPhysicalLeg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_bullionType(self): return self.bullionType
    def set_bullionType(self, bullionType): self.bullionType = bullionType
    def get_deliveryLocation(self): return self.deliveryLocation
    def set_deliveryLocation(self, deliveryLocation): self.deliveryLocation = deliveryLocation
    def get_physicalQuantity(self): return self.physicalQuantity
    def set_physicalQuantity(self, physicalQuantity): self.physicalQuantity = physicalQuantity
    def get_physicalQuantitySchedule(self): return self.physicalQuantitySchedule
    def set_physicalQuantitySchedule(self, physicalQuantitySchedule): self.physicalQuantitySchedule = physicalQuantitySchedule
    def get_totalPhysicalQuantity(self): return self.totalPhysicalQuantity
    def set_totalPhysicalQuantity(self, totalPhysicalQuantity): self.totalPhysicalQuantity = totalPhysicalQuantity
    def get_settlementDate(self): return self.settlementDate
    def set_settlementDate(self, settlementDate): self.settlementDate = settlementDate
    def validate_BullionTypeEnum(self, value):
        # Validate type BullionTypeEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Gold', 'Palladium', 'Platinum', 'Silver', 'Rhodium', 'RhodiumSponge', 'Iridium', 'Ruthenium', 'Osmium']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on BullionTypeEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on BullionTypeEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.bullionType is not None or
            self.deliveryLocation is not None or
            self.physicalQuantity is not None or
            self.physicalQuantitySchedule is not None or
            self.totalPhysicalQuantity is not None or
            self.settlementDate is not None or
            super(BullionPhysicalLeg, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BullionPhysicalLeg', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BullionPhysicalLeg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BullionPhysicalLeg', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BullionPhysicalLeg'):
        super(BullionPhysicalLeg, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BullionPhysicalLeg')
    def exportChildren(self, outfile, level, namespace_='', name_='BullionPhysicalLeg', fromsubclass_=False, pretty_print=True):
        super(BullionPhysicalLeg, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.bullionType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbullionType>%s</%sbullionType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.bullionType), input_name='bullionType')), namespace_, eol_))
        if self.deliveryLocation is not None:
            self.deliveryLocation.export(outfile, level, namespace_, name_='deliveryLocation', pretty_print=pretty_print)
        if self.physicalQuantity is not None:
            self.physicalQuantity.export(outfile, level, namespace_, name_='physicalQuantity', pretty_print=pretty_print)
        if self.physicalQuantitySchedule is not None:
            self.physicalQuantitySchedule.export(outfile, level, namespace_, name_='physicalQuantitySchedule', pretty_print=pretty_print)
        if self.totalPhysicalQuantity is not None:
            self.totalPhysicalQuantity.export(outfile, level, namespace_, name_='totalPhysicalQuantity', pretty_print=pretty_print)
        if self.settlementDate is not None:
            self.settlementDate.export(outfile, level, namespace_, name_='settlementDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(BullionPhysicalLeg, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'bullionType':
            bullionType_ = child_.text
            bullionType_ = re_.sub(String_cleanup_pat_, " ", bullionType_).strip()
            bullionType_ = self.gds_validate_string(bullionType_, node, 'bullionType')
            self.bullionType = bullionType_
            # validate type BullionTypeEnum
            self.validate_BullionTypeEnum(self.bullionType)
        elif nodeName_ == 'deliveryLocation':
            obj_ = BullionDeliveryLocation.factory()
            obj_.build(child_)
            self.deliveryLocation = obj_
            obj_.original_tagname_ = 'deliveryLocation'
        elif nodeName_ == 'physicalQuantity':
            class_obj_ = self.get_class_obj_(child_, CommodityNotionalQuantity)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.physicalQuantity = obj_
            obj_.original_tagname_ = 'physicalQuantity'
        elif nodeName_ == 'physicalQuantitySchedule':
            class_obj_ = self.get_class_obj_(child_, CommodityPhysicalQuantitySchedule)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.physicalQuantitySchedule = obj_
            obj_.original_tagname_ = 'physicalQuantitySchedule'
        elif nodeName_ == 'totalPhysicalQuantity':
            obj_ = UnitQuantity.factory()
            obj_.build(child_)
            self.totalPhysicalQuantity = obj_
            obj_.original_tagname_ = 'totalPhysicalQuantity'
        elif nodeName_ == 'settlementDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.settlementDate = obj_
            obj_.original_tagname_ = 'settlementDate'
        super(BullionPhysicalLeg, self).buildChildren(child_, node, nodeName_, True)
# end class BullionPhysicalLeg


class RelativeDates(RelativeDateOffset):
    """A type describing a set of dates defined as relative to another set
    of dates."""
    member_data_items_ = {
        'periodSkip': MemberSpec_('periodSkip', 'xsd:positiveInteger', 0),
        'scheduleBounds': MemberSpec_('scheduleBounds', 'DateRange', 0),
    }
    subclass = None
    superclass = RelativeDateOffset
    def __init__(self, id=None, periodMultiplier=None, period=None, dayType=None, businessDayConvention=None, businessCentersReference=None, businessCenters=None, dateRelativeTo=None, adjustedDate=None, periodSkip=None, scheduleBounds=None):
        self.original_tagname_ = None
        super(RelativeDates, self).__init__(id, periodMultiplier, period, dayType, businessDayConvention, businessCentersReference, businessCenters, dateRelativeTo, adjustedDate, )
        self.periodSkip = periodSkip
        self.scheduleBounds = scheduleBounds
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RelativeDates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RelativeDates.subclass:
            return RelativeDates.subclass(*args_, **kwargs_)
        else:
            return RelativeDates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_periodSkip(self): return self.periodSkip
    def set_periodSkip(self, periodSkip): self.periodSkip = periodSkip
    def get_scheduleBounds(self): return self.scheduleBounds
    def set_scheduleBounds(self, scheduleBounds): self.scheduleBounds = scheduleBounds
    def hasContent_(self):
        if (
            self.periodSkip is not None or
            self.scheduleBounds is not None or
            super(RelativeDates, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RelativeDates', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RelativeDates')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RelativeDates', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RelativeDates'):
        super(RelativeDates, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RelativeDates')
    def exportChildren(self, outfile, level, namespace_='', name_='RelativeDates', fromsubclass_=False, pretty_print=True):
        super(RelativeDates, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.periodSkip is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%speriodSkip>%s</%speriodSkip>%s' % (namespace_, self.gds_format_integer(self.periodSkip, input_name='periodSkip'), namespace_, eol_))
        if self.scheduleBounds is not None:
            self.scheduleBounds.export(outfile, level, namespace_, name_='scheduleBounds', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RelativeDates, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'periodSkip':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'periodSkip')
            self.periodSkip = ival_
        elif nodeName_ == 'scheduleBounds':
            class_obj_ = self.get_class_obj_(child_, DateRange)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.scheduleBounds = obj_
            obj_.original_tagname_ = 'scheduleBounds'
        super(RelativeDates, self).buildChildren(child_, node, nodeName_, True)
# end class RelativeDates


class Index(ExchangeTradedCalculatedPrice):
    """A published index whose price depends on exchange traded
    constituents."""
    member_data_items_ = {
        'futureId': MemberSpec_('futureId', 'FutureId', 0),
    }
    subclass = None
    superclass = ExchangeTradedCalculatedPrice
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, relatedExchangeId=None, optionsExchangeId=None, specifiedExchangeId=None, constituentExchangeId=None, futureId=None):
        self.original_tagname_ = None
        super(Index, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, relatedExchangeId, optionsExchangeId, specifiedExchangeId, constituentExchangeId, )
        self.futureId = futureId
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Index)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Index.subclass:
            return Index.subclass(*args_, **kwargs_)
        else:
            return Index(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_futureId(self): return self.futureId
    def set_futureId(self, futureId): self.futureId = futureId
    def hasContent_(self):
        if (
            self.futureId is not None or
            super(Index, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Index', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Index')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Index', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Index'):
        super(Index, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Index')
    def exportChildren(self, outfile, level, namespace_='', name_='Index', fromsubclass_=False, pretty_print=True):
        super(Index, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.futureId is not None:
            self.futureId.export(outfile, level, namespace_, name_='futureId', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Index, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'futureId':
            obj_ = FutureId.factory()
            obj_.build(child_)
            self.futureId = obj_
            obj_.original_tagname_ = 'futureId'
        super(Index, self).buildChildren(child_, node, nodeName_, True)
# end class Index


class ExchangeTradedOption(ExchangeTradedContract):
    """An exchange traded option."""
    member_data_items_ = {
        'strike': MemberSpec_('strike', 'xsd:decimal', 0),
        'optionType': MemberSpec_('optionType', ['PutCallEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = ExchangeTradedContract
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, relatedExchangeId=None, optionsExchangeId=None, specifiedExchangeId=None, multiplier=None, contractReference=None, expirationDate=None, strike=None, optionType=None):
        self.original_tagname_ = None
        super(ExchangeTradedOption, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, relatedExchangeId, optionsExchangeId, specifiedExchangeId, multiplier, contractReference, expirationDate, )
        self.strike = strike
        self.optionType = optionType
        self.validate_PutCallEnum(self.optionType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExchangeTradedOption)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExchangeTradedOption.subclass:
            return ExchangeTradedOption.subclass(*args_, **kwargs_)
        else:
            return ExchangeTradedOption(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_strike(self): return self.strike
    def set_strike(self, strike): self.strike = strike
    def get_optionType(self): return self.optionType
    def set_optionType(self, optionType): self.optionType = optionType
    def validate_PutCallEnum(self, value):
        # Validate type PutCallEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Put', 'Call']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PutCallEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on PutCallEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.strike is not None or
            self.optionType is not None or
            super(ExchangeTradedOption, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExchangeTradedOption', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExchangeTradedOption')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExchangeTradedOption', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExchangeTradedOption'):
        super(ExchangeTradedOption, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ExchangeTradedOption')
    def exportChildren(self, outfile, level, namespace_='', name_='ExchangeTradedOption', fromsubclass_=False, pretty_print=True):
        super(ExchangeTradedOption, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.strike is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstrike>%s</%sstrike>%s' % (namespace_, self.gds_format_float(self.strike, input_name='strike'), namespace_, eol_))
        if self.optionType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soptionType>%s</%soptionType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.optionType), input_name='optionType')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ExchangeTradedOption, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'strike':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'strike')
            self.strike = fval_
        elif nodeName_ == 'optionType':
            optionType_ = child_.text
            optionType_ = re_.sub(String_cleanup_pat_, " ", optionType_).strip()
            optionType_ = self.gds_validate_string(optionType_, node, 'optionType')
            self.optionType = optionType_
            # validate type PutCallEnum
            self.validate_PutCallEnum(self.optionType)
        super(ExchangeTradedOption, self).buildChildren(child_, node, nodeName_, True)
# end class ExchangeTradedOption


class ExchangeTradedFund(ExchangeTradedCalculatedPrice):
    """An exchange traded fund whose price depends on exchange traded
    constituents."""
    member_data_items_ = {
        'fundManager': MemberSpec_('fundManager', ['String', 'xsd:string'], 0),
    }
    subclass = None
    superclass = ExchangeTradedCalculatedPrice
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, relatedExchangeId=None, optionsExchangeId=None, specifiedExchangeId=None, constituentExchangeId=None, fundManager=None):
        self.original_tagname_ = None
        super(ExchangeTradedFund, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, relatedExchangeId, optionsExchangeId, specifiedExchangeId, constituentExchangeId, )
        self.fundManager = fundManager
        self.validate_String(self.fundManager)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExchangeTradedFund)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExchangeTradedFund.subclass:
            return ExchangeTradedFund.subclass(*args_, **kwargs_)
        else:
            return ExchangeTradedFund(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fundManager(self): return self.fundManager
    def set_fundManager(self, fundManager): self.fundManager = fundManager
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.fundManager is not None or
            super(ExchangeTradedFund, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExchangeTradedFund', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExchangeTradedFund')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExchangeTradedFund', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExchangeTradedFund'):
        super(ExchangeTradedFund, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ExchangeTradedFund')
    def exportChildren(self, outfile, level, namespace_='', name_='ExchangeTradedFund', fromsubclass_=False, pretty_print=True):
        super(ExchangeTradedFund, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.fundManager is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfundManager>%s</%sfundManager>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.fundManager), input_name='fundManager')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ExchangeTradedFund, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fundManager':
            fundManager_ = child_.text
            fundManager_ = self.gds_validate_string(fundManager_, node, 'fundManager')
            self.fundManager = fundManager_
            # validate type String
            self.validate_String(self.fundManager)
        super(ExchangeTradedFund, self).buildChildren(child_, node, nodeName_, True)
# end class ExchangeTradedFund


class OptionBaseExtended(OptionBase):
    """Base type for options starting with the 4-3 release, until we
    refactor the schema as part of the 5-0 release series.A choice
    between an explicit representation of the notional amount, or a
    reference to a notional amount defined elsewhere in this
    document."""
    member_data_items_ = {
        'premium': MemberSpec_('premium', 'Premium', 0),
        'exercise': MemberSpec_('exercise', 'Exercise', 0),
        'exerciseProcedure': MemberSpec_('exerciseProcedure', 'ExerciseProcedure', 0),
        'feature': MemberSpec_('feature', 'OptionFeature', 0),
        'notionalReference': MemberSpec_('notionalReference', 'NotionalAmountReference', 0),
        'notionalAmount': MemberSpec_('notionalAmount', 'Money', 0),
        'optionEntitlement': MemberSpec_('optionEntitlement', ['PositiveDecimal', 'xsd:decimal'], 0),
        'entitlementCurrency': MemberSpec_('entitlementCurrency', 'Currency', 0),
        'numberOfOptions': MemberSpec_('numberOfOptions', ['PositiveDecimal', 'xsd:decimal'], 0),
        'settlementType': MemberSpec_('settlementType', ['SettlementTypeEnum', 'Token', 'xsd:token'], 0),
        'settlementDate': MemberSpec_('settlementDate', 'AdjustableOrRelativeDate', 0),
        'settlementAmount': MemberSpec_('settlementAmount', 'Money', 0),
        'settlementCurrency': MemberSpec_('settlementCurrency', 'Currency', 0),
    }
    subclass = None
    superclass = OptionBase
    def __init__(self, id=None, primaryAssetClass=None, secondaryAssetClass=None, productType=None, productId=None, assetClass=None, embeddedOptionType=None, buyerPartyReference=None, buyerAccountReference=None, sellerPartyReference=None, sellerAccountReference=None, optionType=None, premium=None, exercise=None, exerciseProcedure=None, feature=None, notionalReference=None, notionalAmount=None, optionEntitlement=None, entitlementCurrency=None, numberOfOptions=None, settlementType=None, settlementDate=None, settlementAmount=None, settlementCurrency=None):
        self.original_tagname_ = None
        super(OptionBaseExtended, self).__init__(id, primaryAssetClass, secondaryAssetClass, productType, productId, assetClass, embeddedOptionType, buyerPartyReference, buyerAccountReference, sellerPartyReference, sellerAccountReference, optionType, )
        self.premium = premium
        self.exercise = exercise
        self.exerciseProcedure = exerciseProcedure
        self.feature = feature
        self.notionalReference = notionalReference
        self.notionalAmount = notionalAmount
        self.optionEntitlement = optionEntitlement
        self.validate_PositiveDecimal(self.optionEntitlement)
        self.entitlementCurrency = entitlementCurrency
        self.numberOfOptions = numberOfOptions
        self.validate_PositiveDecimal(self.numberOfOptions)
        self.settlementType = settlementType
        self.validate_SettlementTypeEnum(self.settlementType)
        self.settlementDate = settlementDate
        self.settlementAmount = settlementAmount
        self.settlementCurrency = settlementCurrency
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OptionBaseExtended)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OptionBaseExtended.subclass:
            return OptionBaseExtended.subclass(*args_, **kwargs_)
        else:
            return OptionBaseExtended(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_premium(self): return self.premium
    def set_premium(self, premium): self.premium = premium
    def get_exercise(self): return self.exercise
    def set_exercise(self, exercise): self.exercise = exercise
    def get_exerciseProcedure(self): return self.exerciseProcedure
    def set_exerciseProcedure(self, exerciseProcedure): self.exerciseProcedure = exerciseProcedure
    def get_feature(self): return self.feature
    def set_feature(self, feature): self.feature = feature
    def get_notionalReference(self): return self.notionalReference
    def set_notionalReference(self, notionalReference): self.notionalReference = notionalReference
    def get_notionalAmount(self): return self.notionalAmount
    def set_notionalAmount(self, notionalAmount): self.notionalAmount = notionalAmount
    def get_optionEntitlement(self): return self.optionEntitlement
    def set_optionEntitlement(self, optionEntitlement): self.optionEntitlement = optionEntitlement
    def get_entitlementCurrency(self): return self.entitlementCurrency
    def set_entitlementCurrency(self, entitlementCurrency): self.entitlementCurrency = entitlementCurrency
    def get_numberOfOptions(self): return self.numberOfOptions
    def set_numberOfOptions(self, numberOfOptions): self.numberOfOptions = numberOfOptions
    def get_settlementType(self): return self.settlementType
    def set_settlementType(self, settlementType): self.settlementType = settlementType
    def get_settlementDate(self): return self.settlementDate
    def set_settlementDate(self, settlementDate): self.settlementDate = settlementDate
    def get_settlementAmount(self): return self.settlementAmount
    def set_settlementAmount(self, settlementAmount): self.settlementAmount = settlementAmount
    def get_settlementCurrency(self): return self.settlementCurrency
    def set_settlementCurrency(self, settlementCurrency): self.settlementCurrency = settlementCurrency
    def validate_PositiveDecimal(self, value):
        # Validate type PositiveDecimal, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value <= 0:
                warnings_.warn('Value "%(value)s" does not match xsd minExclusive restriction on PositiveDecimal' % {"value" : value} )
    def validate_SettlementTypeEnum(self, value):
        # Validate type SettlementTypeEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Cash', 'Physical', 'Election', 'CashOrPhysical']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SettlementTypeEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on SettlementTypeEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.premium is not None or
            self.exercise is not None or
            self.exerciseProcedure is not None or
            self.feature is not None or
            self.notionalReference is not None or
            self.notionalAmount is not None or
            self.optionEntitlement is not None or
            self.entitlementCurrency is not None or
            self.numberOfOptions is not None or
            self.settlementType is not None or
            self.settlementDate is not None or
            self.settlementAmount is not None or
            self.settlementCurrency is not None or
            super(OptionBaseExtended, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OptionBaseExtended', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OptionBaseExtended')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OptionBaseExtended', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OptionBaseExtended'):
        super(OptionBaseExtended, self).exportAttributes(outfile, level, already_processed, namespace_, name_='OptionBaseExtended')
    def exportChildren(self, outfile, level, namespace_='', name_='OptionBaseExtended', fromsubclass_=False, pretty_print=True):
        super(OptionBaseExtended, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.premium is not None:
            self.premium.export(outfile, level, namespace_, name_='premium', pretty_print=pretty_print)
        if self.exercise is not None:
            self.exercise.export(outfile, level, namespace_, name_='exercise', pretty_print=pretty_print)
        if self.exerciseProcedure is not None:
            self.exerciseProcedure.export(outfile, level, namespace_, name_='exerciseProcedure', pretty_print=pretty_print)
        if self.feature is not None:
            self.feature.export(outfile, level, namespace_, name_='feature', pretty_print=pretty_print)
        if self.notionalReference is not None:
            self.notionalReference.export(outfile, level, namespace_, name_='notionalReference', pretty_print=pretty_print)
        if self.notionalAmount is not None:
            self.notionalAmount.export(outfile, level, namespace_, name_='notionalAmount', pretty_print=pretty_print)
        if self.optionEntitlement is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soptionEntitlement>%s</%soptionEntitlement>%s' % (namespace_, self.gds_format_float(self.optionEntitlement, input_name='optionEntitlement'), namespace_, eol_))
        if self.entitlementCurrency is not None:
            self.entitlementCurrency.export(outfile, level, namespace_, name_='entitlementCurrency', pretty_print=pretty_print)
        if self.numberOfOptions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumberOfOptions>%s</%snumberOfOptions>%s' % (namespace_, self.gds_format_float(self.numberOfOptions, input_name='numberOfOptions'), namespace_, eol_))
        if self.settlementType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssettlementType>%s</%ssettlementType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.settlementType), input_name='settlementType')), namespace_, eol_))
        if self.settlementDate is not None:
            self.settlementDate.export(outfile, level, namespace_, name_='settlementDate', pretty_print=pretty_print)
        if self.settlementAmount is not None:
            self.settlementAmount.export(outfile, level, namespace_, name_='settlementAmount', pretty_print=pretty_print)
        if self.settlementCurrency is not None:
            self.settlementCurrency.export(outfile, level, namespace_, name_='settlementCurrency', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(OptionBaseExtended, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'premium':
            obj_ = Premium.factory()
            obj_.build(child_)
            self.premium = obj_
            obj_.original_tagname_ = 'premium'
        elif nodeName_ == 'exercise':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <exercise> element')
            self.exercise = obj_
            obj_.original_tagname_ = 'exercise'
        elif nodeName_ == 'americanExercise':
            obj_ = AmericanExercise.factory()
            obj_.build(child_)
            self.exercise = obj_
            obj_.original_tagname_ = 'americanExercise'
        elif nodeName_ == 'bermudaExercise':
            obj_ = BermudaExercise.factory()
            obj_.build(child_)
            self.exercise = obj_
            obj_.original_tagname_ = 'bermudaExercise'
        elif nodeName_ == 'europeanExercise':
            obj_ = EuropeanExercise.factory()
            obj_.build(child_)
            self.exercise = obj_
            obj_.original_tagname_ = 'europeanExercise'
        elif nodeName_ == 'exerciseProcedure':
            obj_ = ExerciseProcedure.factory()
            obj_.build(child_)
            self.exerciseProcedure = obj_
            obj_.original_tagname_ = 'exerciseProcedure'
        elif nodeName_ == 'feature':
            obj_ = OptionFeature.factory()
            obj_.build(child_)
            self.feature = obj_
            obj_.original_tagname_ = 'feature'
        elif nodeName_ == 'notionalReference':
            obj_ = NotionalAmountReference.factory()
            obj_.build(child_)
            self.notionalReference = obj_
            obj_.original_tagname_ = 'notionalReference'
        elif nodeName_ == 'notionalAmount':
            class_obj_ = self.get_class_obj_(child_, Money)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.notionalAmount = obj_
            obj_.original_tagname_ = 'notionalAmount'
        elif nodeName_ == 'optionEntitlement':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'optionEntitlement')
            self.optionEntitlement = fval_
            # validate type PositiveDecimal
            self.validate_PositiveDecimal(self.optionEntitlement)
        elif nodeName_ == 'entitlementCurrency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.entitlementCurrency = obj_
            obj_.original_tagname_ = 'entitlementCurrency'
        elif nodeName_ == 'numberOfOptions':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'numberOfOptions')
            self.numberOfOptions = fval_
            # validate type PositiveDecimal
            self.validate_PositiveDecimal(self.numberOfOptions)
        elif nodeName_ == 'settlementType':
            settlementType_ = child_.text
            settlementType_ = re_.sub(String_cleanup_pat_, " ", settlementType_).strip()
            settlementType_ = self.gds_validate_string(settlementType_, node, 'settlementType')
            self.settlementType = settlementType_
            # validate type SettlementTypeEnum
            self.validate_SettlementTypeEnum(self.settlementType)
        elif nodeName_ == 'settlementDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.settlementDate = obj_
            obj_.original_tagname_ = 'settlementDate'
        elif nodeName_ == 'settlementAmount':
            class_obj_ = self.get_class_obj_(child_, Money)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.settlementAmount = obj_
            obj_.original_tagname_ = 'settlementAmount'
        elif nodeName_ == 'settlementCurrency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.settlementCurrency = obj_
            obj_.original_tagname_ = 'settlementCurrency'
        super(OptionBaseExtended, self).buildChildren(child_, node, nodeName_, True)
# end class OptionBaseExtended


class WeatherLeg(FinancialSwapLeg):
    """A weather leg of a Commodity Swap defines Weather Index Swap
    transactions. Weather Index Swap transactions are OTC derivative
    transactions which settle financially based on an index
    calculated from observations of temperature, precipitation and
    other weather-related measurements at weather stations
    throughout the world. Sub-Annex C of the 2005 ISDA Commodity
    Definitions provides definitions and terms for a number of types
    of weather indices. These indices include: HDD (heating degree
    days), CDD (cooling degree days), CPD (critical precipitation
    days). Weather Index Swap transactions result in a cash flow to
    one of the two counterparties each Calculation Period depending
    on the relationship between the Settlement Level and the Weather
    Index Level. A Weather Index swap transaction always consists of
    a commodity swap element as a parent to two weatherLeg elements."""
    member_data_items_ = {
        'weatherIndexLevel': MemberSpec_('weatherIndexLevel', 'WeatherIndex', 0),
        'weatherCalculationPeriods': MemberSpec_('weatherCalculationPeriods', 'WeatherCalculationPeriods', 0),
        'weatherCalculationPeriodsReference': MemberSpec_('weatherCalculationPeriodsReference', 'CalculationPeriodsReference', 0),
        'weatherNotionalAmount': MemberSpec_('weatherNotionalAmount', 'NonNegativeMoney', 0),
        'calculation': MemberSpec_('calculation', 'WeatherLegCalculation', 0),
        'paymentDates': MemberSpec_('paymentDates', 'CommodityRelativePaymentDates', 0),
        'weatherIndexData': MemberSpec_('weatherIndexData', 'WeatherIndexData', 0),
    }
    subclass = None
    superclass = FinancialSwapLeg
    def __init__(self, id=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, weatherIndexLevel=None, weatherCalculationPeriods=None, weatherCalculationPeriodsReference=None, weatherNotionalAmount=None, calculation=None, paymentDates=None, weatherIndexData=None):
        self.original_tagname_ = None
        super(WeatherLeg, self).__init__(id, payerPartyReference, payerAccountReference, receiverPartyReference, receiverAccountReference, )
        self.weatherIndexLevel = weatherIndexLevel
        self.weatherCalculationPeriods = weatherCalculationPeriods
        self.weatherCalculationPeriodsReference = weatherCalculationPeriodsReference
        self.weatherNotionalAmount = weatherNotionalAmount
        self.calculation = calculation
        self.paymentDates = paymentDates
        self.weatherIndexData = weatherIndexData
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WeatherLeg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WeatherLeg.subclass:
            return WeatherLeg.subclass(*args_, **kwargs_)
        else:
            return WeatherLeg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_weatherIndexLevel(self): return self.weatherIndexLevel
    def set_weatherIndexLevel(self, weatherIndexLevel): self.weatherIndexLevel = weatherIndexLevel
    def get_weatherCalculationPeriods(self): return self.weatherCalculationPeriods
    def set_weatherCalculationPeriods(self, weatherCalculationPeriods): self.weatherCalculationPeriods = weatherCalculationPeriods
    def get_weatherCalculationPeriodsReference(self): return self.weatherCalculationPeriodsReference
    def set_weatherCalculationPeriodsReference(self, weatherCalculationPeriodsReference): self.weatherCalculationPeriodsReference = weatherCalculationPeriodsReference
    def get_weatherNotionalAmount(self): return self.weatherNotionalAmount
    def set_weatherNotionalAmount(self, weatherNotionalAmount): self.weatherNotionalAmount = weatherNotionalAmount
    def get_calculation(self): return self.calculation
    def set_calculation(self, calculation): self.calculation = calculation
    def get_paymentDates(self): return self.paymentDates
    def set_paymentDates(self, paymentDates): self.paymentDates = paymentDates
    def get_weatherIndexData(self): return self.weatherIndexData
    def set_weatherIndexData(self, weatherIndexData): self.weatherIndexData = weatherIndexData
    def hasContent_(self):
        if (
            self.weatherIndexLevel is not None or
            self.weatherCalculationPeriods is not None or
            self.weatherCalculationPeriodsReference is not None or
            self.weatherNotionalAmount is not None or
            self.calculation is not None or
            self.paymentDates is not None or
            self.weatherIndexData is not None or
            super(WeatherLeg, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='WeatherLeg', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WeatherLeg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='WeatherLeg', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='WeatherLeg'):
        super(WeatherLeg, self).exportAttributes(outfile, level, already_processed, namespace_, name_='WeatherLeg')
    def exportChildren(self, outfile, level, namespace_='', name_='WeatherLeg', fromsubclass_=False, pretty_print=True):
        super(WeatherLeg, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.weatherIndexLevel is not None:
            self.weatherIndexLevel.export(outfile, level, namespace_, name_='weatherIndexLevel', pretty_print=pretty_print)
        if self.weatherCalculationPeriods is not None:
            self.weatherCalculationPeriods.export(outfile, level, namespace_, name_='weatherCalculationPeriods', pretty_print=pretty_print)
        if self.weatherCalculationPeriodsReference is not None:
            self.weatherCalculationPeriodsReference.export(outfile, level, namespace_, name_='weatherCalculationPeriodsReference', pretty_print=pretty_print)
        if self.weatherNotionalAmount is not None:
            self.weatherNotionalAmount.export(outfile, level, namespace_, name_='weatherNotionalAmount', pretty_print=pretty_print)
        if self.calculation is not None:
            self.calculation.export(outfile, level, namespace_, name_='calculation', pretty_print=pretty_print)
        if self.paymentDates is not None:
            self.paymentDates.export(outfile, level, namespace_, name_='paymentDates', pretty_print=pretty_print)
        if self.weatherIndexData is not None:
            self.weatherIndexData.export(outfile, level, namespace_, name_='weatherIndexData', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(WeatherLeg, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'weatherIndexLevel':
            obj_ = WeatherIndex.factory()
            obj_.build(child_)
            self.weatherIndexLevel = obj_
            obj_.original_tagname_ = 'weatherIndexLevel'
        elif nodeName_ == 'weatherCalculationPeriods':
            obj_ = WeatherCalculationPeriods.factory()
            obj_.build(child_)
            self.weatherCalculationPeriods = obj_
            obj_.original_tagname_ = 'weatherCalculationPeriods'
        elif nodeName_ == 'weatherCalculationPeriodsReference':
            obj_ = CalculationPeriodsReference.factory()
            obj_.build(child_)
            self.weatherCalculationPeriodsReference = obj_
            obj_.original_tagname_ = 'weatherCalculationPeriodsReference'
        elif nodeName_ == 'weatherNotionalAmount':
            class_obj_ = self.get_class_obj_(child_, NonNegativeMoney)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.weatherNotionalAmount = obj_
            obj_.original_tagname_ = 'weatherNotionalAmount'
        elif nodeName_ == 'calculation':
            obj_ = WeatherLegCalculation.factory()
            obj_.build(child_)
            self.calculation = obj_
            obj_.original_tagname_ = 'calculation'
        elif nodeName_ == 'paymentDates':
            obj_ = CommodityRelativePaymentDates.factory()
            obj_.build(child_)
            self.paymentDates = obj_
            obj_.original_tagname_ = 'paymentDates'
        elif nodeName_ == 'weatherIndexData':
            obj_ = WeatherIndexData.factory()
            obj_.build(child_)
            self.weatherIndexData = obj_
            obj_.original_tagname_ = 'weatherIndexData'
        super(WeatherLeg, self).buildChildren(child_, node, nodeName_, True)
# end class WeatherLeg


class FloatingPriceLeg(FinancialSwapLeg):
    """Floating Price Leg of a Commodity Swap. Each 'floatingLeg' defines a
    series of financial payments for a commodity the value of which
    is derived from a floating price such as an exchange or an index
    publication."""
    member_data_items_ = {
        'calculationDates': MemberSpec_('calculationDates', 'AdjustableDates', 0),
        'calculationPeriods': MemberSpec_('calculationPeriods', 'AdjustableDates', 0),
        'calculationPeriodsSchedule': MemberSpec_('calculationPeriodsSchedule', 'CommodityCalculationPeriodsSchedule', 0),
        'calculationPeriodsReference': MemberSpec_('calculationPeriodsReference', 'CalculationPeriodsReference', 0),
        'calculationPeriodsScheduleReference': MemberSpec_('calculationPeriodsScheduleReference', 'CalculationPeriodsScheduleReference', 0),
        'calculationPeriodsDatesReference': MemberSpec_('calculationPeriodsDatesReference', 'CalculationPeriodsDatesReference', 0),
        'commodity': MemberSpec_('commodity', 'Commodity', 0),
        'notionalQuantitySchedule': MemberSpec_('notionalQuantitySchedule', 'CommodityNotionalQuantitySchedule', 0),
        'notionalQuantity': MemberSpec_('notionalQuantity', 'CommodityNotionalQuantity', 0),
        'settlementPeriodsNotionalQuantity': MemberSpec_('settlementPeriodsNotionalQuantity', 'CommoditySettlementPeriodsNotionalQuantity', 1),
        'totalNotionalQuantity': MemberSpec_('totalNotionalQuantity', 'xsd:decimal', 0),
        'quantityReference': MemberSpec_('quantityReference', 'QuantityReference', 0),
        'calculation': MemberSpec_('calculation', 'FloatingLegCalculation', 0),
        'relativePaymentDates': MemberSpec_('relativePaymentDates', 'CommodityRelativePaymentDates', 0),
        'paymentDates': MemberSpec_('paymentDates', 'AdjustableDatesOrRelativeDateOffset', 0),
        'masterAgreementPaymentDates': MemberSpec_('masterAgreementPaymentDates', 'xsd:boolean', 0),
        'flatRate': MemberSpec_('flatRate', ['FlatRateEnum', 'Token', 'xsd:token'], 0),
        'flatRateAmount': MemberSpec_('flatRateAmount', 'NonNegativeMoney', 0),
    }
    subclass = None
    superclass = FinancialSwapLeg
    def __init__(self, id=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, calculationDates=None, calculationPeriods=None, calculationPeriodsSchedule=None, calculationPeriodsReference=None, calculationPeriodsScheduleReference=None, calculationPeriodsDatesReference=None, commodity=None, notionalQuantitySchedule=None, notionalQuantity=None, settlementPeriodsNotionalQuantity=None, totalNotionalQuantity=None, quantityReference=None, calculation=None, relativePaymentDates=None, paymentDates=None, masterAgreementPaymentDates=None, flatRate=None, flatRateAmount=None):
        self.original_tagname_ = None
        super(FloatingPriceLeg, self).__init__(id, payerPartyReference, payerAccountReference, receiverPartyReference, receiverAccountReference, )
        self.calculationDates = calculationDates
        self.calculationPeriods = calculationPeriods
        self.calculationPeriodsSchedule = calculationPeriodsSchedule
        self.calculationPeriodsReference = calculationPeriodsReference
        self.calculationPeriodsScheduleReference = calculationPeriodsScheduleReference
        self.calculationPeriodsDatesReference = calculationPeriodsDatesReference
        self.commodity = commodity
        self.notionalQuantitySchedule = notionalQuantitySchedule
        self.notionalQuantity = notionalQuantity
        if settlementPeriodsNotionalQuantity is None:
            self.settlementPeriodsNotionalQuantity = []
        else:
            self.settlementPeriodsNotionalQuantity = settlementPeriodsNotionalQuantity
        self.totalNotionalQuantity = totalNotionalQuantity
        self.quantityReference = quantityReference
        self.calculation = calculation
        self.relativePaymentDates = relativePaymentDates
        self.paymentDates = paymentDates
        self.masterAgreementPaymentDates = masterAgreementPaymentDates
        self.flatRate = flatRate
        self.validate_FlatRateEnum(self.flatRate)
        self.flatRateAmount = flatRateAmount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FloatingPriceLeg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FloatingPriceLeg.subclass:
            return FloatingPriceLeg.subclass(*args_, **kwargs_)
        else:
            return FloatingPriceLeg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_calculationDates(self): return self.calculationDates
    def set_calculationDates(self, calculationDates): self.calculationDates = calculationDates
    def get_calculationPeriods(self): return self.calculationPeriods
    def set_calculationPeriods(self, calculationPeriods): self.calculationPeriods = calculationPeriods
    def get_calculationPeriodsSchedule(self): return self.calculationPeriodsSchedule
    def set_calculationPeriodsSchedule(self, calculationPeriodsSchedule): self.calculationPeriodsSchedule = calculationPeriodsSchedule
    def get_calculationPeriodsReference(self): return self.calculationPeriodsReference
    def set_calculationPeriodsReference(self, calculationPeriodsReference): self.calculationPeriodsReference = calculationPeriodsReference
    def get_calculationPeriodsScheduleReference(self): return self.calculationPeriodsScheduleReference
    def set_calculationPeriodsScheduleReference(self, calculationPeriodsScheduleReference): self.calculationPeriodsScheduleReference = calculationPeriodsScheduleReference
    def get_calculationPeriodsDatesReference(self): return self.calculationPeriodsDatesReference
    def set_calculationPeriodsDatesReference(self, calculationPeriodsDatesReference): self.calculationPeriodsDatesReference = calculationPeriodsDatesReference
    def get_commodity(self): return self.commodity
    def set_commodity(self, commodity): self.commodity = commodity
    def get_notionalQuantitySchedule(self): return self.notionalQuantitySchedule
    def set_notionalQuantitySchedule(self, notionalQuantitySchedule): self.notionalQuantitySchedule = notionalQuantitySchedule
    def get_notionalQuantity(self): return self.notionalQuantity
    def set_notionalQuantity(self, notionalQuantity): self.notionalQuantity = notionalQuantity
    def get_settlementPeriodsNotionalQuantity(self): return self.settlementPeriodsNotionalQuantity
    def set_settlementPeriodsNotionalQuantity(self, settlementPeriodsNotionalQuantity): self.settlementPeriodsNotionalQuantity = settlementPeriodsNotionalQuantity
    def add_settlementPeriodsNotionalQuantity(self, value): self.settlementPeriodsNotionalQuantity.append(value)
    def insert_settlementPeriodsNotionalQuantity_at(self, index, value): self.settlementPeriodsNotionalQuantity.insert(index, value)
    def replace_settlementPeriodsNotionalQuantity_at(self, index, value): self.settlementPeriodsNotionalQuantity[index] = value
    def get_totalNotionalQuantity(self): return self.totalNotionalQuantity
    def set_totalNotionalQuantity(self, totalNotionalQuantity): self.totalNotionalQuantity = totalNotionalQuantity
    def get_quantityReference(self): return self.quantityReference
    def set_quantityReference(self, quantityReference): self.quantityReference = quantityReference
    def get_calculation(self): return self.calculation
    def set_calculation(self, calculation): self.calculation = calculation
    def get_relativePaymentDates(self): return self.relativePaymentDates
    def set_relativePaymentDates(self, relativePaymentDates): self.relativePaymentDates = relativePaymentDates
    def get_paymentDates(self): return self.paymentDates
    def set_paymentDates(self, paymentDates): self.paymentDates = paymentDates
    def get_masterAgreementPaymentDates(self): return self.masterAgreementPaymentDates
    def set_masterAgreementPaymentDates(self, masterAgreementPaymentDates): self.masterAgreementPaymentDates = masterAgreementPaymentDates
    def get_flatRate(self): return self.flatRate
    def set_flatRate(self, flatRate): self.flatRate = flatRate
    def get_flatRateAmount(self): return self.flatRateAmount
    def set_flatRateAmount(self, flatRateAmount): self.flatRateAmount = flatRateAmount
    def validate_FlatRateEnum(self, value):
        # Validate type FlatRateEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Fixed', 'Floating']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FlatRateEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on FlatRateEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.calculationDates is not None or
            self.calculationPeriods is not None or
            self.calculationPeriodsSchedule is not None or
            self.calculationPeriodsReference is not None or
            self.calculationPeriodsScheduleReference is not None or
            self.calculationPeriodsDatesReference is not None or
            self.commodity is not None or
            self.notionalQuantitySchedule is not None or
            self.notionalQuantity is not None or
            self.settlementPeriodsNotionalQuantity or
            self.totalNotionalQuantity is not None or
            self.quantityReference is not None or
            self.calculation is not None or
            self.relativePaymentDates is not None or
            self.paymentDates is not None or
            self.masterAgreementPaymentDates is not None or
            self.flatRate is not None or
            self.flatRateAmount is not None or
            super(FloatingPriceLeg, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FloatingPriceLeg', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FloatingPriceLeg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FloatingPriceLeg', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FloatingPriceLeg'):
        super(FloatingPriceLeg, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FloatingPriceLeg')
    def exportChildren(self, outfile, level, namespace_='', name_='FloatingPriceLeg', fromsubclass_=False, pretty_print=True):
        super(FloatingPriceLeg, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.calculationDates is not None:
            self.calculationDates.export(outfile, level, namespace_, name_='calculationDates', pretty_print=pretty_print)
        if self.calculationPeriods is not None:
            self.calculationPeriods.export(outfile, level, namespace_, name_='calculationPeriods', pretty_print=pretty_print)
        if self.calculationPeriodsSchedule is not None:
            self.calculationPeriodsSchedule.export(outfile, level, namespace_, name_='calculationPeriodsSchedule', pretty_print=pretty_print)
        if self.calculationPeriodsReference is not None:
            self.calculationPeriodsReference.export(outfile, level, namespace_, name_='calculationPeriodsReference', pretty_print=pretty_print)
        if self.calculationPeriodsScheduleReference is not None:
            self.calculationPeriodsScheduleReference.export(outfile, level, namespace_, name_='calculationPeriodsScheduleReference', pretty_print=pretty_print)
        if self.calculationPeriodsDatesReference is not None:
            self.calculationPeriodsDatesReference.export(outfile, level, namespace_, name_='calculationPeriodsDatesReference', pretty_print=pretty_print)
        if self.commodity is not None:
            self.commodity.export(outfile, level, namespace_, name_='commodity', pretty_print=pretty_print)
        if self.notionalQuantitySchedule is not None:
            self.notionalQuantitySchedule.export(outfile, level, namespace_, name_='notionalQuantitySchedule', pretty_print=pretty_print)
        if self.notionalQuantity is not None:
            self.notionalQuantity.export(outfile, level, namespace_, name_='notionalQuantity', pretty_print=pretty_print)
        for settlementPeriodsNotionalQuantity_ in self.settlementPeriodsNotionalQuantity:
            settlementPeriodsNotionalQuantity_.export(outfile, level, namespace_, name_='settlementPeriodsNotionalQuantity', pretty_print=pretty_print)
        if self.totalNotionalQuantity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalNotionalQuantity>%s</%stotalNotionalQuantity>%s' % (namespace_, self.gds_format_float(self.totalNotionalQuantity, input_name='totalNotionalQuantity'), namespace_, eol_))
        if self.quantityReference is not None:
            self.quantityReference.export(outfile, level, namespace_, name_='quantityReference', pretty_print=pretty_print)
        if self.calculation is not None:
            self.calculation.export(outfile, level, namespace_, name_='calculation', pretty_print=pretty_print)
        if self.relativePaymentDates is not None:
            self.relativePaymentDates.export(outfile, level, namespace_, name_='relativePaymentDates', pretty_print=pretty_print)
        if self.paymentDates is not None:
            self.paymentDates.export(outfile, level, namespace_, name_='paymentDates', pretty_print=pretty_print)
        if self.masterAgreementPaymentDates is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smasterAgreementPaymentDates>%s</%smasterAgreementPaymentDates>%s' % (namespace_, self.gds_format_boolean(self.masterAgreementPaymentDates, input_name='masterAgreementPaymentDates'), namespace_, eol_))
        if self.flatRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sflatRate>%s</%sflatRate>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.flatRate), input_name='flatRate')), namespace_, eol_))
        if self.flatRateAmount is not None:
            self.flatRateAmount.export(outfile, level, namespace_, name_='flatRateAmount', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FloatingPriceLeg, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'calculationDates':
            obj_ = AdjustableDates.factory()
            obj_.build(child_)
            self.calculationDates = obj_
            obj_.original_tagname_ = 'calculationDates'
        elif nodeName_ == 'calculationPeriods':
            obj_ = AdjustableDates.factory()
            obj_.build(child_)
            self.calculationPeriods = obj_
            obj_.original_tagname_ = 'calculationPeriods'
        elif nodeName_ == 'calculationPeriodsSchedule':
            obj_ = CommodityCalculationPeriodsSchedule.factory()
            obj_.build(child_)
            self.calculationPeriodsSchedule = obj_
            obj_.original_tagname_ = 'calculationPeriodsSchedule'
        elif nodeName_ == 'calculationPeriodsReference':
            obj_ = CalculationPeriodsReference.factory()
            obj_.build(child_)
            self.calculationPeriodsReference = obj_
            obj_.original_tagname_ = 'calculationPeriodsReference'
        elif nodeName_ == 'calculationPeriodsScheduleReference':
            obj_ = CalculationPeriodsScheduleReference.factory()
            obj_.build(child_)
            self.calculationPeriodsScheduleReference = obj_
            obj_.original_tagname_ = 'calculationPeriodsScheduleReference'
        elif nodeName_ == 'calculationPeriodsDatesReference':
            obj_ = CalculationPeriodsDatesReference.factory()
            obj_.build(child_)
            self.calculationPeriodsDatesReference = obj_
            obj_.original_tagname_ = 'calculationPeriodsDatesReference'
        elif nodeName_ == 'commodity':
            obj_ = Commodity.factory()
            obj_.build(child_)
            self.commodity = obj_
            obj_.original_tagname_ = 'commodity'
        elif nodeName_ == 'notionalQuantitySchedule':
            obj_ = CommodityNotionalQuantitySchedule.factory()
            obj_.build(child_)
            self.notionalQuantitySchedule = obj_
            obj_.original_tagname_ = 'notionalQuantitySchedule'
        elif nodeName_ == 'notionalQuantity':
            class_obj_ = self.get_class_obj_(child_, CommodityNotionalQuantity)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.notionalQuantity = obj_
            obj_.original_tagname_ = 'notionalQuantity'
        elif nodeName_ == 'settlementPeriodsNotionalQuantity':
            obj_ = CommoditySettlementPeriodsNotionalQuantity.factory()
            obj_.build(child_)
            self.settlementPeriodsNotionalQuantity.append(obj_)
            obj_.original_tagname_ = 'settlementPeriodsNotionalQuantity'
        elif nodeName_ == 'totalNotionalQuantity':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'totalNotionalQuantity')
            self.totalNotionalQuantity = fval_
        elif nodeName_ == 'quantityReference':
            obj_ = QuantityReference.factory()
            obj_.build(child_)
            self.quantityReference = obj_
            obj_.original_tagname_ = 'quantityReference'
        elif nodeName_ == 'calculation':
            class_obj_ = self.get_class_obj_(child_, FloatingLegCalculation)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.calculation = obj_
            obj_.original_tagname_ = 'calculation'
        elif nodeName_ == 'relativePaymentDates':
            obj_ = CommodityRelativePaymentDates.factory()
            obj_.build(child_)
            self.relativePaymentDates = obj_
            obj_.original_tagname_ = 'relativePaymentDates'
        elif nodeName_ == 'paymentDates':
            obj_ = AdjustableDatesOrRelativeDateOffset.factory()
            obj_.build(child_)
            self.paymentDates = obj_
            obj_.original_tagname_ = 'paymentDates'
        elif nodeName_ == 'masterAgreementPaymentDates':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'masterAgreementPaymentDates')
            self.masterAgreementPaymentDates = ival_
        elif nodeName_ == 'flatRate':
            flatRate_ = child_.text
            flatRate_ = re_.sub(String_cleanup_pat_, " ", flatRate_).strip()
            flatRate_ = self.gds_validate_string(flatRate_, node, 'flatRate')
            self.flatRate = flatRate_
            # validate type FlatRateEnum
            self.validate_FlatRateEnum(self.flatRate)
        elif nodeName_ == 'flatRateAmount':
            class_obj_ = self.get_class_obj_(child_, NonNegativeMoney)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.flatRateAmount = obj_
            obj_.original_tagname_ = 'flatRateAmount'
        super(FloatingPriceLeg, self).buildChildren(child_, node, nodeName_, True)
# end class FloatingPriceLeg


class FixedPriceLeg(FinancialSwapLeg):
    """Fixed Price Leg of a Commodity Swap. It defines schedule of fixed
    payments associated with a commodity swap."""
    member_data_items_ = {
        'calculationDates': MemberSpec_('calculationDates', 'AdjustableDates', 0),
        'calculationPeriods': MemberSpec_('calculationPeriods', 'AdjustableDates', 0),
        'calculationPeriodsSchedule': MemberSpec_('calculationPeriodsSchedule', 'CommodityCalculationPeriodsSchedule', 0),
        'calculationPeriodsReference': MemberSpec_('calculationPeriodsReference', 'CalculationPeriodsReference', 0),
        'calculationPeriodsScheduleReference': MemberSpec_('calculationPeriodsScheduleReference', 'CalculationPeriodsScheduleReference', 0),
        'calculationPeriodsDatesReference': MemberSpec_('calculationPeriodsDatesReference', 'CalculationPeriodsDatesReference', 0),
        'fixedPriceSchedule': MemberSpec_('fixedPriceSchedule', 'CommodityFixedPriceSchedule', 0),
        'fixedPrice': MemberSpec_('fixedPrice', 'FixedPrice', 0),
        'worldscaleRate': MemberSpec_('worldscaleRate', 'xsd:decimal', 0),
        'contractRate': MemberSpec_('contractRate', 'NonNegativeMoney', 0),
        'settlementPeriodsPrice': MemberSpec_('settlementPeriodsPrice', 'SettlementPeriodsFixedPrice', 1),
        'totalPrice': MemberSpec_('totalPrice', 'NonNegativeMoney', 0),
        'notionalQuantitySchedule': MemberSpec_('notionalQuantitySchedule', 'CommodityNotionalQuantitySchedule', 0),
        'notionalQuantity': MemberSpec_('notionalQuantity', 'CommodityNotionalQuantity', 0),
        'settlementPeriodsNotionalQuantity': MemberSpec_('settlementPeriodsNotionalQuantity', 'CommoditySettlementPeriodsNotionalQuantity', 1),
        'totalNotionalQuantity': MemberSpec_('totalNotionalQuantity', 'xsd:decimal', 0),
        'quantityReference': MemberSpec_('quantityReference', 'QuantityReference', 0),
        'relativePaymentDates': MemberSpec_('relativePaymentDates', 'CommodityRelativePaymentDates', 0),
        'paymentDates': MemberSpec_('paymentDates', 'AdjustableDatesOrRelativeDateOffset', 0),
        'masterAgreementPaymentDates': MemberSpec_('masterAgreementPaymentDates', 'xsd:boolean', 0),
        'flatRate': MemberSpec_('flatRate', ['FlatRateEnum', 'Token', 'xsd:token'], 0),
        'flatRateAmount': MemberSpec_('flatRateAmount', 'NonNegativeMoney', 0),
    }
    subclass = None
    superclass = FinancialSwapLeg
    def __init__(self, id=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, calculationDates=None, calculationPeriods=None, calculationPeriodsSchedule=None, calculationPeriodsReference=None, calculationPeriodsScheduleReference=None, calculationPeriodsDatesReference=None, fixedPriceSchedule=None, fixedPrice=None, worldscaleRate=None, contractRate=None, settlementPeriodsPrice=None, totalPrice=None, notionalQuantitySchedule=None, notionalQuantity=None, settlementPeriodsNotionalQuantity=None, totalNotionalQuantity=None, quantityReference=None, relativePaymentDates=None, paymentDates=None, masterAgreementPaymentDates=None, flatRate=None, flatRateAmount=None):
        self.original_tagname_ = None
        super(FixedPriceLeg, self).__init__(id, payerPartyReference, payerAccountReference, receiverPartyReference, receiverAccountReference, )
        self.calculationDates = calculationDates
        self.calculationPeriods = calculationPeriods
        self.calculationPeriodsSchedule = calculationPeriodsSchedule
        self.calculationPeriodsReference = calculationPeriodsReference
        self.calculationPeriodsScheduleReference = calculationPeriodsScheduleReference
        self.calculationPeriodsDatesReference = calculationPeriodsDatesReference
        self.fixedPriceSchedule = fixedPriceSchedule
        self.fixedPrice = fixedPrice
        self.worldscaleRate = worldscaleRate
        self.contractRate = contractRate
        if settlementPeriodsPrice is None:
            self.settlementPeriodsPrice = []
        else:
            self.settlementPeriodsPrice = settlementPeriodsPrice
        self.totalPrice = totalPrice
        self.notionalQuantitySchedule = notionalQuantitySchedule
        self.notionalQuantity = notionalQuantity
        if settlementPeriodsNotionalQuantity is None:
            self.settlementPeriodsNotionalQuantity = []
        else:
            self.settlementPeriodsNotionalQuantity = settlementPeriodsNotionalQuantity
        self.totalNotionalQuantity = totalNotionalQuantity
        self.quantityReference = quantityReference
        self.relativePaymentDates = relativePaymentDates
        self.paymentDates = paymentDates
        self.masterAgreementPaymentDates = masterAgreementPaymentDates
        self.flatRate = flatRate
        self.validate_FlatRateEnum(self.flatRate)
        self.flatRateAmount = flatRateAmount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FixedPriceLeg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FixedPriceLeg.subclass:
            return FixedPriceLeg.subclass(*args_, **kwargs_)
        else:
            return FixedPriceLeg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_calculationDates(self): return self.calculationDates
    def set_calculationDates(self, calculationDates): self.calculationDates = calculationDates
    def get_calculationPeriods(self): return self.calculationPeriods
    def set_calculationPeriods(self, calculationPeriods): self.calculationPeriods = calculationPeriods
    def get_calculationPeriodsSchedule(self): return self.calculationPeriodsSchedule
    def set_calculationPeriodsSchedule(self, calculationPeriodsSchedule): self.calculationPeriodsSchedule = calculationPeriodsSchedule
    def get_calculationPeriodsReference(self): return self.calculationPeriodsReference
    def set_calculationPeriodsReference(self, calculationPeriodsReference): self.calculationPeriodsReference = calculationPeriodsReference
    def get_calculationPeriodsScheduleReference(self): return self.calculationPeriodsScheduleReference
    def set_calculationPeriodsScheduleReference(self, calculationPeriodsScheduleReference): self.calculationPeriodsScheduleReference = calculationPeriodsScheduleReference
    def get_calculationPeriodsDatesReference(self): return self.calculationPeriodsDatesReference
    def set_calculationPeriodsDatesReference(self, calculationPeriodsDatesReference): self.calculationPeriodsDatesReference = calculationPeriodsDatesReference
    def get_fixedPriceSchedule(self): return self.fixedPriceSchedule
    def set_fixedPriceSchedule(self, fixedPriceSchedule): self.fixedPriceSchedule = fixedPriceSchedule
    def get_fixedPrice(self): return self.fixedPrice
    def set_fixedPrice(self, fixedPrice): self.fixedPrice = fixedPrice
    def get_worldscaleRate(self): return self.worldscaleRate
    def set_worldscaleRate(self, worldscaleRate): self.worldscaleRate = worldscaleRate
    def get_contractRate(self): return self.contractRate
    def set_contractRate(self, contractRate): self.contractRate = contractRate
    def get_settlementPeriodsPrice(self): return self.settlementPeriodsPrice
    def set_settlementPeriodsPrice(self, settlementPeriodsPrice): self.settlementPeriodsPrice = settlementPeriodsPrice
    def add_settlementPeriodsPrice(self, value): self.settlementPeriodsPrice.append(value)
    def insert_settlementPeriodsPrice_at(self, index, value): self.settlementPeriodsPrice.insert(index, value)
    def replace_settlementPeriodsPrice_at(self, index, value): self.settlementPeriodsPrice[index] = value
    def get_totalPrice(self): return self.totalPrice
    def set_totalPrice(self, totalPrice): self.totalPrice = totalPrice
    def get_notionalQuantitySchedule(self): return self.notionalQuantitySchedule
    def set_notionalQuantitySchedule(self, notionalQuantitySchedule): self.notionalQuantitySchedule = notionalQuantitySchedule
    def get_notionalQuantity(self): return self.notionalQuantity
    def set_notionalQuantity(self, notionalQuantity): self.notionalQuantity = notionalQuantity
    def get_settlementPeriodsNotionalQuantity(self): return self.settlementPeriodsNotionalQuantity
    def set_settlementPeriodsNotionalQuantity(self, settlementPeriodsNotionalQuantity): self.settlementPeriodsNotionalQuantity = settlementPeriodsNotionalQuantity
    def add_settlementPeriodsNotionalQuantity(self, value): self.settlementPeriodsNotionalQuantity.append(value)
    def insert_settlementPeriodsNotionalQuantity_at(self, index, value): self.settlementPeriodsNotionalQuantity.insert(index, value)
    def replace_settlementPeriodsNotionalQuantity_at(self, index, value): self.settlementPeriodsNotionalQuantity[index] = value
    def get_totalNotionalQuantity(self): return self.totalNotionalQuantity
    def set_totalNotionalQuantity(self, totalNotionalQuantity): self.totalNotionalQuantity = totalNotionalQuantity
    def get_quantityReference(self): return self.quantityReference
    def set_quantityReference(self, quantityReference): self.quantityReference = quantityReference
    def get_relativePaymentDates(self): return self.relativePaymentDates
    def set_relativePaymentDates(self, relativePaymentDates): self.relativePaymentDates = relativePaymentDates
    def get_paymentDates(self): return self.paymentDates
    def set_paymentDates(self, paymentDates): self.paymentDates = paymentDates
    def get_masterAgreementPaymentDates(self): return self.masterAgreementPaymentDates
    def set_masterAgreementPaymentDates(self, masterAgreementPaymentDates): self.masterAgreementPaymentDates = masterAgreementPaymentDates
    def get_flatRate(self): return self.flatRate
    def set_flatRate(self, flatRate): self.flatRate = flatRate
    def get_flatRateAmount(self): return self.flatRateAmount
    def set_flatRateAmount(self, flatRateAmount): self.flatRateAmount = flatRateAmount
    def validate_FlatRateEnum(self, value):
        # Validate type FlatRateEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Fixed', 'Floating']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FlatRateEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on FlatRateEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.calculationDates is not None or
            self.calculationPeriods is not None or
            self.calculationPeriodsSchedule is not None or
            self.calculationPeriodsReference is not None or
            self.calculationPeriodsScheduleReference is not None or
            self.calculationPeriodsDatesReference is not None or
            self.fixedPriceSchedule is not None or
            self.fixedPrice is not None or
            self.worldscaleRate is not None or
            self.contractRate is not None or
            self.settlementPeriodsPrice or
            self.totalPrice is not None or
            self.notionalQuantitySchedule is not None or
            self.notionalQuantity is not None or
            self.settlementPeriodsNotionalQuantity or
            self.totalNotionalQuantity is not None or
            self.quantityReference is not None or
            self.relativePaymentDates is not None or
            self.paymentDates is not None or
            self.masterAgreementPaymentDates is not None or
            self.flatRate is not None or
            self.flatRateAmount is not None or
            super(FixedPriceLeg, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FixedPriceLeg', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FixedPriceLeg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FixedPriceLeg', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FixedPriceLeg'):
        super(FixedPriceLeg, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FixedPriceLeg')
    def exportChildren(self, outfile, level, namespace_='', name_='FixedPriceLeg', fromsubclass_=False, pretty_print=True):
        super(FixedPriceLeg, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.calculationDates is not None:
            self.calculationDates.export(outfile, level, namespace_, name_='calculationDates', pretty_print=pretty_print)
        if self.calculationPeriods is not None:
            self.calculationPeriods.export(outfile, level, namespace_, name_='calculationPeriods', pretty_print=pretty_print)
        if self.calculationPeriodsSchedule is not None:
            self.calculationPeriodsSchedule.export(outfile, level, namespace_, name_='calculationPeriodsSchedule', pretty_print=pretty_print)
        if self.calculationPeriodsReference is not None:
            self.calculationPeriodsReference.export(outfile, level, namespace_, name_='calculationPeriodsReference', pretty_print=pretty_print)
        if self.calculationPeriodsScheduleReference is not None:
            self.calculationPeriodsScheduleReference.export(outfile, level, namespace_, name_='calculationPeriodsScheduleReference', pretty_print=pretty_print)
        if self.calculationPeriodsDatesReference is not None:
            self.calculationPeriodsDatesReference.export(outfile, level, namespace_, name_='calculationPeriodsDatesReference', pretty_print=pretty_print)
        if self.fixedPriceSchedule is not None:
            self.fixedPriceSchedule.export(outfile, level, namespace_, name_='fixedPriceSchedule', pretty_print=pretty_print)
        if self.fixedPrice is not None:
            self.fixedPrice.export(outfile, level, namespace_, name_='fixedPrice', pretty_print=pretty_print)
        if self.worldscaleRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sworldscaleRate>%s</%sworldscaleRate>%s' % (namespace_, self.gds_format_float(self.worldscaleRate, input_name='worldscaleRate'), namespace_, eol_))
        if self.contractRate is not None:
            self.contractRate.export(outfile, level, namespace_, name_='contractRate', pretty_print=pretty_print)
        for settlementPeriodsPrice_ in self.settlementPeriodsPrice:
            settlementPeriodsPrice_.export(outfile, level, namespace_, name_='settlementPeriodsPrice', pretty_print=pretty_print)
        if self.totalPrice is not None:
            self.totalPrice.export(outfile, level, namespace_, name_='totalPrice', pretty_print=pretty_print)
        if self.notionalQuantitySchedule is not None:
            self.notionalQuantitySchedule.export(outfile, level, namespace_, name_='notionalQuantitySchedule', pretty_print=pretty_print)
        if self.notionalQuantity is not None:
            self.notionalQuantity.export(outfile, level, namespace_, name_='notionalQuantity', pretty_print=pretty_print)
        for settlementPeriodsNotionalQuantity_ in self.settlementPeriodsNotionalQuantity:
            settlementPeriodsNotionalQuantity_.export(outfile, level, namespace_, name_='settlementPeriodsNotionalQuantity', pretty_print=pretty_print)
        if self.totalNotionalQuantity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalNotionalQuantity>%s</%stotalNotionalQuantity>%s' % (namespace_, self.gds_format_float(self.totalNotionalQuantity, input_name='totalNotionalQuantity'), namespace_, eol_))
        if self.quantityReference is not None:
            self.quantityReference.export(outfile, level, namespace_, name_='quantityReference', pretty_print=pretty_print)
        if self.relativePaymentDates is not None:
            self.relativePaymentDates.export(outfile, level, namespace_, name_='relativePaymentDates', pretty_print=pretty_print)
        if self.paymentDates is not None:
            self.paymentDates.export(outfile, level, namespace_, name_='paymentDates', pretty_print=pretty_print)
        if self.masterAgreementPaymentDates is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smasterAgreementPaymentDates>%s</%smasterAgreementPaymentDates>%s' % (namespace_, self.gds_format_boolean(self.masterAgreementPaymentDates, input_name='masterAgreementPaymentDates'), namespace_, eol_))
        if self.flatRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sflatRate>%s</%sflatRate>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.flatRate), input_name='flatRate')), namespace_, eol_))
        if self.flatRateAmount is not None:
            self.flatRateAmount.export(outfile, level, namespace_, name_='flatRateAmount', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FixedPriceLeg, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'calculationDates':
            obj_ = AdjustableDates.factory()
            obj_.build(child_)
            self.calculationDates = obj_
            obj_.original_tagname_ = 'calculationDates'
        elif nodeName_ == 'calculationPeriods':
            obj_ = AdjustableDates.factory()
            obj_.build(child_)
            self.calculationPeriods = obj_
            obj_.original_tagname_ = 'calculationPeriods'
        elif nodeName_ == 'calculationPeriodsSchedule':
            obj_ = CommodityCalculationPeriodsSchedule.factory()
            obj_.build(child_)
            self.calculationPeriodsSchedule = obj_
            obj_.original_tagname_ = 'calculationPeriodsSchedule'
        elif nodeName_ == 'calculationPeriodsReference':
            obj_ = CalculationPeriodsReference.factory()
            obj_.build(child_)
            self.calculationPeriodsReference = obj_
            obj_.original_tagname_ = 'calculationPeriodsReference'
        elif nodeName_ == 'calculationPeriodsScheduleReference':
            obj_ = CalculationPeriodsScheduleReference.factory()
            obj_.build(child_)
            self.calculationPeriodsScheduleReference = obj_
            obj_.original_tagname_ = 'calculationPeriodsScheduleReference'
        elif nodeName_ == 'calculationPeriodsDatesReference':
            obj_ = CalculationPeriodsDatesReference.factory()
            obj_.build(child_)
            self.calculationPeriodsDatesReference = obj_
            obj_.original_tagname_ = 'calculationPeriodsDatesReference'
        elif nodeName_ == 'fixedPriceSchedule':
            obj_ = CommodityFixedPriceSchedule.factory()
            obj_.build(child_)
            self.fixedPriceSchedule = obj_
            obj_.original_tagname_ = 'fixedPriceSchedule'
        elif nodeName_ == 'fixedPrice':
            class_obj_ = self.get_class_obj_(child_, FixedPrice)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.fixedPrice = obj_
            obj_.original_tagname_ = 'fixedPrice'
        elif nodeName_ == 'worldscaleRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'worldscaleRate')
            self.worldscaleRate = fval_
        elif nodeName_ == 'contractRate':
            class_obj_ = self.get_class_obj_(child_, NonNegativeMoney)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.contractRate = obj_
            obj_.original_tagname_ = 'contractRate'
        elif nodeName_ == 'settlementPeriodsPrice':
            obj_ = SettlementPeriodsFixedPrice.factory()
            obj_.build(child_)
            self.settlementPeriodsPrice.append(obj_)
            obj_.original_tagname_ = 'settlementPeriodsPrice'
        elif nodeName_ == 'totalPrice':
            class_obj_ = self.get_class_obj_(child_, NonNegativeMoney)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.totalPrice = obj_
            obj_.original_tagname_ = 'totalPrice'
        elif nodeName_ == 'notionalQuantitySchedule':
            obj_ = CommodityNotionalQuantitySchedule.factory()
            obj_.build(child_)
            self.notionalQuantitySchedule = obj_
            obj_.original_tagname_ = 'notionalQuantitySchedule'
        elif nodeName_ == 'notionalQuantity':
            class_obj_ = self.get_class_obj_(child_, CommodityNotionalQuantity)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.notionalQuantity = obj_
            obj_.original_tagname_ = 'notionalQuantity'
        elif nodeName_ == 'settlementPeriodsNotionalQuantity':
            obj_ = CommoditySettlementPeriodsNotionalQuantity.factory()
            obj_.build(child_)
            self.settlementPeriodsNotionalQuantity.append(obj_)
            obj_.original_tagname_ = 'settlementPeriodsNotionalQuantity'
        elif nodeName_ == 'totalNotionalQuantity':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'totalNotionalQuantity')
            self.totalNotionalQuantity = fval_
        elif nodeName_ == 'quantityReference':
            obj_ = QuantityReference.factory()
            obj_.build(child_)
            self.quantityReference = obj_
            obj_.original_tagname_ = 'quantityReference'
        elif nodeName_ == 'relativePaymentDates':
            obj_ = CommodityRelativePaymentDates.factory()
            obj_.build(child_)
            self.relativePaymentDates = obj_
            obj_.original_tagname_ = 'relativePaymentDates'
        elif nodeName_ == 'paymentDates':
            obj_ = AdjustableDatesOrRelativeDateOffset.factory()
            obj_.build(child_)
            self.paymentDates = obj_
            obj_.original_tagname_ = 'paymentDates'
        elif nodeName_ == 'masterAgreementPaymentDates':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'masterAgreementPaymentDates')
            self.masterAgreementPaymentDates = ival_
        elif nodeName_ == 'flatRate':
            flatRate_ = child_.text
            flatRate_ = re_.sub(String_cleanup_pat_, " ", flatRate_).strip()
            flatRate_ = self.gds_validate_string(flatRate_, node, 'flatRate')
            self.flatRate = flatRate_
            # validate type FlatRateEnum
            self.validate_FlatRateEnum(self.flatRate)
        elif nodeName_ == 'flatRateAmount':
            class_obj_ = self.get_class_obj_(child_, NonNegativeMoney)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.flatRateAmount = obj_
            obj_.original_tagname_ = 'flatRateAmount'
        super(FixedPriceLeg, self).buildChildren(child_, node, nodeName_, True)
# end class FixedPriceLeg


GDSClassesMapping = {
    'BTUperLB': CoalAttributeDecimal,
    'SO2': CoalAttributePercentage,
    'StandardQualityStep': CoalStandardQuality,
    'absoluteTolerance': AbsoluteTolerance,
    'accountBeneficiary': PartyReference,
    'accountId': AccountId,
    'accountName': AccountName,
    'accountReference': AccountReference,
    'accountType': AccountType,
    'accruedInterest': Money,
    'additionalMarketDisruptionEvent': MarketDisruptionEvent,
    'address': Address,
    'adjustableDate': AdjustableDate,
    'adjustableDates': AdjustableDates,
    'adjustedDate': IdentifiedDate,
    'agreement': GenericAgreement,
    'allocationAccountReference': AccountReference,
    'allocationPartyReference': PartyReference,
    'americanExercise': AmericanExercise,
    'amount': Money,
    'amountRelativeTo': AmountReference,
    'applicableLaw': EnvironmentalProductApplicableLaw,
    'ash': CoalAttributePercentage,
    'ashFusionTemperature': CoalAttributeDecimal,
    'asian': Asian,
    'assetClass': AssetClass,
    'attachment': Resource,
    'automaticExercise': Empty,
    'averageDailyTradingVolume': AverageDailyTradingVolumeLimit,
    'averagePriceLeg': AveragePriceLeg,
    'averagingDateTimes': DateTimeList,
    'averagingObservation': WeightedAveragingObservation,
    'averagingObservations': AveragingObservationList,
    'averagingPeriodFrequency': CalculationPeriodFrequency,
    'averagingPeriodIn': AveragingPeriod,
    'averagingPeriodOut': AveragingPeriod,
    'barrier': Barrier,
    'barrierCap': TriggerEvent,
    'barrierFloor': TriggerEvent,
    'basket': Basket,
    'basketAmount': Money,
    'basketConstituent': BasketConstituent,
    'basketCurrency': Currency,
    'basketId': BasketId,
    'basketName': BasketName,
    'beneficiary': Routing,
    'beneficiaryBank': Routing,
    'beneficiaryPartyReference': PartyReference,
    'bermudaExercise': BermudaExercise,
    'bermudaExerciseDates': AdjustableOrRelativeDates,
    'bond': Bond,
    'borrower': LegalEntity,
    'borrowerReference': LegalEntityReference,
    'brand': CommodityMetalBrand,
    'brandManager': CommodityMetalBrandManager,
    'brokerConfirmation': BrokerConfirmation,
    'brokerConfirmationType': BrokerConfirmationType,
    'btuQualityAdjustment': CoalQualityAdjustments,
    'bullionPhysicalLeg': BullionPhysicalLeg,
    'businessCalendar': CommodityBusinessCalendar,
    'businessCenter': BusinessCenter,
    'businessCenters': BusinessCenters,
    'businessCentersReference': BusinessCentersReference,
    'businessDays': BusinessCenter,
    'businessUnit': BusinessUnit,
    'businessUnitId': Unit,
    'businessUnitReference': BusinessUnitReference,
    'buyer': IdentifiedPayerReceiver,
    'buyerAccountReference': AccountReference,
    'buyerHub': CommodityHub,
    'buyerPartyReference': PartyReference,
    'calculation': WeatherLegCalculation,
    'calculationAgentPartyReference': PartyReference,
    'calculationDate': Period,
    'calculationDates': AdjustableDates,
    'calculationEndDate': AdjustableOrRelativeDate,
    'calculationPeriod': WeatherCalculationPeriod,
    'calculationPeriodDatesAdjustments': BusinessDayAdjustments,
    'calculationPeriodEndDay': IdentifiedDate,
    'calculationPeriodFirstDay': IdentifiedDate,
    'calculationPeriodFrequency': CalculationPeriodFrequency,
    'calculationPeriods': AdjustableDates,
    'calculationPeriodsDatesReference': CalculationPeriodsDatesReference,
    'calculationPeriodsReference': CalculationPeriodsReference,
    'calculationPeriodsSchedule': CommodityCalculationPeriodsSchedule,
    'calculationPeriodsScheduleReference': CalculationPeriodsScheduleReference,
    'calculationStartDate': AdjustableOrRelativeDate,
    'calendarSpread': CalendarSpread,
    'capRateSchedule': StrikeSchedule,
    'cash': Cash,
    'cashSettlementReferenceBanks': CashSettlementReferenceBanks,
    'cashflowAmount': Money,
    'cashflowId': CashflowId,
    'cashflowType': CashflowType,
    'classification': IndustryClassification,
    'clearanceSystem': ClearanceSystem,
    'clearingInstructions': SwaptionPhysicalSettlement,
    'coal': CoalProduct,
    'coalPhysicalLeg': CoalPhysicalLeg,
    'coalProductSpecifications': CoalProductSpecifications,
    'collateralValueAllocation': CollateralValueAllocation,
    'commencementDate': AdjustableOrRelativeDate,
    'commencementDates': AdjustableOrRelativeDates,
    'commission': Commission,
    'commodity': Commodity,
    'commodityBase': CommodityBase,
    'commodityBasket': CommodityBasket,
    'commodityBasketOption': CommodityBasketOption,
    'commodityDetails': CommodityDetails,
    'commodityDigitalOption': CommodityDigitalOption,
    'commodityFixedInterestCalculation': CommodityFixedInterestCalculation,
    'commodityForward': CommodityForward,
    'commodityForwardLeg': CommodityForwardLeg,
    'commodityInterestLeg': CommodityInterestLeg,
    'commodityOption': CommodityOption,
    'commodityPerformanceSwap': CommodityPerformanceSwap,
    'commodityPerformanceSwapLeg': CommodityPerformanceSwapLeg,
    'commodityReturnCalculation': CommodityReturnCalculation,
    'commodityReturnLeg': CommodityReturnLeg,
    'commoditySwap': CommoditySwap,
    'commoditySwapLeg': CommoditySwapLeg,
    'commoditySwaption': CommoditySwaption,
    'commodityVarianceLeg': CommodityVarianceLeg,
    'compliancePeriod': EnvironmentalProductComplaincePeriod,
    'composite': Composite,
    'constituentExchangeId': ExchangeId,
    'constituentWeight': ConstituentWeight,
    'contactInfo': ContactInformation,
    'contingency': ElectricityTransmissionContingencyType,
    'contingentParty': PartyReference,
    'contractRate': NonNegativeMoney,
    'contractRateStep': NonNegativeMoney,
    'contractualDefinitions': ContractualDefinitions,
    'contractualMatrix': ContractualMatrix,
    'contractualTermsSupplement': ContractualTermsSupplement,
    'convertibleBond': ConvertibleBond,
    'correctionPeriod': Period,
    'correspondentInformation': CorrespondentInformation,
    'correspondentPartyReference': PartyReference,
    'country': CountryCode,
    'couponPayment': PendingPayment,
    'couponType': CouponType,
    'creditEntityReference': LegalEntityReference,
    'creditEventNotice': CreditEventNotice,
    'creditEvents': CreditEvents,
    'creditEventsReference': CreditEventsReference,
    'creditRating': CreditRating,
    'creditSupportAgreement': CreditSupportAgreement,
    'crossCurrency': Composite,
    'currency': Currency,
    'currency1': Currency,
    'currency2': Currency,
    'currencyType': ReportingCurrencyType,
    'curveInstrument': Asset,
    'cycle': CommodityPipelineCycle,
    'dataProvider': DataProvider,
    'dateAdjustments': BusinessDayAdjustments,
    'dateAdjustmentsReference': BusinessDayAdjustmentsReference,
    'dateOffset': DateOffset,
    'dateRelativeTo': DateReference,
    'dayCountFraction': DayCountFraction,
    'dayDistribution': CommodityFrequencyType,
    'defaultRequirement': Money,
    'definition': ProductReference,
    'deliveryConditions': OilDelivery,
    'deliveryDate': AdjustableDate,
    'deliveryDateExpirationConvention': Offset,
    'deliveryDateRollConvention': Offset,
    'deliveryLocation': CommodityDeliveryPoint,
    'deliveryNearby': DeliveryNearby,
    'deliveryPeriods': CommodityDeliveryPeriods,
    'deliveryPeriodsReference': CalculationPeriodsReference,
    'deliveryPeriodsScheduleReference': CalculationPeriodsScheduleReference,
    'deliveryPoint': GasDeliveryPoint,
    'deliveryQuantity': CommodityPhysicalQuantity,
    'deliveryType': ElectricityDeliveryType,
    'deliveryZone': CommodityDeliveryPoint,
    'deposit': Deposit,
    'depositoryPartyReference': PartyReference,
    'determinationMethod': DeterminationMethod,
    'digital': CommodityDigital,
    'disruptionFallback': SequencedDisruptionFallback,
    'dividendPayment': PendingPayment,
    'dividendPayout': DividendPayout,
    'documentation': PartyRelationshipDocumentation,
    'eEPParameters': EEPParameters,
    'earliestExerciseTime': BusinessCenterTime,
    'earlyTermination': CommodityPerformanceSwapEarlyTermination,
    'effectiveDate': IdentifiedDate,
    'electingParty': PartyReference,
    'electingPartyReference': PartyReference,
    'electricity': ElectricityProduct,
    'electricityPhysicalLeg': ElectricityPhysicalLeg,
    'embeddedOptionType': EmbeddedOptionType,
    'endTerm': Period,
    'endTime': OffsetPrevailingTime,
    'entitlementCurrency': Currency,
    'entityId': EntityId,
    'entityName': EntityName,
    'entryPoint': CommodityDeliveryPoint,
    'environmental': EnvironmentalProduct,
    'environmentalPhysicalLeg': EnvironmentalPhysicalLeg,
    'equity': EquityAsset,
    'europeanExercise': EuropeanExercise,
    'exchangeId': ExchangeId,
    'exchangeTradedFund': ExchangeTradedFund,
    'excludeHolidays': CommodityBusinessCalendar,
    'exercise': Exercise,
    'exerciseFee': ExerciseFee,
    'exerciseFeeSchedule': ExerciseFeeSchedule,
    'exerciseFrequency': Frequency,
    'exerciseNotice': ExerciseNotice,
    'exerciseNoticePartyReference': PartyReference,
    'exercisePeriod': CommodityExercisePeriods,
    'exerciseProcedure': ExerciseProcedure,
    'expirationDate': AdjustableOrRelativeDate,
    'expirationDateOffset': DateOffset,
    'expirationDateTwo': AdjustableOrRelativeDate,
    'expirationDates': AdjustableRelativeOrPeriodicDates2,
    'expirationTime': BusinessCenterTime,
    'expireRelativeToEvent': CommodityExpireRelativeToEvent,
    'facilityType': FacilityType,
    'failureToPay': FailureToPay,
    'fallback': DisruptionFallback,
    'fallbackReferencePrice': Underlyer,
    'feature': OptionFeature,
    'featurePayment': FeaturePayment,
    'featurePaymentAmount': PositiveMoney,
    'featurePaymentDate': AdjustableOrRelativeDate,
    'feeAmountSchedule': AmountSchedule,
    'feePaymentDate': RelativeDateOffset,
    'feeRateSchedule': Schedule,
    'finalRateRounding': Rounding,
    'finesPassingScreen': CoalAttributeDecimal,
    'firm': ElectricityDeliveryFirm,
    'firstObservationDateOffset': Period,
    'fixedLeg': FixedPriceLeg,
    'fixedPrice': FixedPrice,
    'fixedPriceSchedule': CommodityFixedPriceSchedule,
    'fixedPriceStep': FixedPrice,
    'fixedRate': IdentifiedRate,
    'fixing': FxFixing,
    'fixingDate': AdjustableDate,
    'fixingTime': BusinessCenterTime,
    'flatRateAmount': NonNegativeMoney,
    'floatingLeg': FloatingPriceLeg,
    'floatingRate': StubFloatingRate,
    'floatingRateCalculation': FloatingRateCalculation,
    'floatingRateIndex': FloatingRateIndex,
    'floatingRateMultiplierSchedule': Schedule,
    'floatingStrikePricePerUnit': FloatingStrikePrice,
    'floatingStrikePricePerUnitSchedule': CommodityCalculationPeriodsSchedule,
    'floorRateSchedule': StrikeSchedule,
    'fluid': CoalAttributeDecimal,
    'formula': Formula,
    'formulaComponent': FormulaComponent,
    'future': Future,
    'futureId': FutureId,
    'fx': FxRateAsset,
    'fxConversion': FxConversion,
    'fxFeature': FxFeature,
    'fxObservationDates': AdjustableDates,
    'fxRate': FxRate,
    'fxSpotRateSource': FxSpotRateSource,
    'fxType': CommodityFxType,
    'gas': GasProduct,
    'gasPhysicalLeg': GasPhysicalLeg,
    'generationAsset': CommodityDeliveryPoint,
    'governingLaw': GoverningLaw,
    'gracePeriod': Offset,
    'gracePeriodExtension': GracePeriodExtension,
    'grade': CommodityProductGrade,
    'grindability': CoalAttributeDecimal,
    'grossCashflow': GrossCashflow,
    'grossPrice': ActualPrice,
    'groupType': PartyGroupType,
    'hubCode': CommodityHubCode,
    'identifier': CreditSupportAgreementIdentifier,
    'importerOfRecord': PartyReference,
    'includeHolidays': CommodityBusinessCalendar,
    'independentAmount': IndependentAmount,
    'index': Index,
    'indexTenor': Period,
    'informationSource': InformationSource,
    'initialDeformation': CoalAttributeDecimal,
    'instrumentId': InstrumentId,
    'insurer': LegalEntity,
    'insurerReference': LegalEntityReference,
    'integralMultipleQuantity': CommodityNotionalQuantity,
    'interconnectionPoint': InterconnectionPoint,
    'intermediaryInformation': IntermediaryInformation,
    'intermediaryPartyReference': PartyReference,
    'issuer': IssuerId,
    'issuerPartyReference': PartyReference,
    'jurisdiction': GoverningLaw,
    'knock': Knock,
    'knockIn': TriggerEvent,
    'knockOut': TriggerEvent,
    'lag': Lag,
    'lagDuration': Period,
    'lagReference': LagReference,
    'language': Language,
    'latestExerciseTime': BusinessCenterTime,
    'latestExerciseTimeDetermination': DeterminationMethod,
    'legId': LegId,
    'legIdentifier': LegIdentifier,
    'length': ResourceLength,
    'levelPrice': FixedPrice,
    'levelUnit': QuantityUnit,
    'lien': Lien,
    'loan': Loan,
    'location': TimezoneLocation,
    'manualExercise': Empty,
    'marketDisruption': MarketDisruption,
    'marketDisruptionEvent': MarketDisruptionEvent,
    'masterAgreement': MasterAgreement,
    'masterAgreementId': MasterAgreementId,
    'masterAgreementType': MasterAgreementType,
    'masterAgreementVersion': MasterAgreementVersion,
    'masterConfirmation': MasterConfirmation,
    'masterConfirmationAnnexType': MasterConfirmationAnnexType,
    'masterConfirmationType': MasterConfirmationType,
    'material': Material,
    'math': Math,
    'matrixTerm': MatrixTerm,
    'matrixType': MatrixType,
    'maxPhysicalQuantity': CommodityNotionalQuantity,
    'maximumPaymentAmount': NonNegativeMoney,
    'maximumTransactionPaymentAmount': NonNegativeMoney,
    'measureType': AssetMeasureType,
    'metal': Metal,
    'metalPhysicalLeg': MetalPhysicalLeg,
    'mimeType': MimeType,
    'minPhysicalQuantity': CommodityNotionalQuantity,
    'minimumNotionalQuantity': CommodityNotionalQuantity,
    'moisture': CoalAttributePercentage,
    'mortgage': Mortgage,
    'multipleExercise': MultipleExercise,
    'mutualFund': MutualFund,
    'name': CommodityMetalBrandName,
    'netPrice': ActualPrice,
    'nonstandardSettlementRate': FxInformationSource,
    'notifyingParty': NotifyingParty,
    'notionalAmount': PositiveMoney,
    'notionalAmountBasket': CommodityBasketByPercentage,
    'notionalAmountReference': CommodityNotionalAmountReference,
    'notionalQuantity': CommodityNotionalQuantity,
    'notionalQuantityBasket': CommodityBasketByNotional,
    'notionalQuantitySchedule': CommodityNotionalQuantitySchedule,
    'notionalReference': NotionalReference,
    'notionalStep': CommodityNotionalQuantity,
    'numberOfAllowances': UnitQuantity,
    'offset': Offset,
    'oil': OilProduct,
    'oilPhysicalLeg': OilPhysicalLeg,
    'option': ExchangeTradedOption,
    'optionOwnerPartyReference': PartyReference,
    'optionsExchangeId': ExchangeId,
    'organizationType': OrganizationType,
    'partialExercise': PartialExercise,
    'partyId': PartyId,
    'partyName': PartyName,
    'partyReference': PartyReference,
    'partyTradeIdentifierReference': PartyTradeIdentifierReference,
    'passThrough': PassThrough,
    'passThroughItem': PassThroughItem,
    'payRelativeToEvent': CommodityPayRelativeToEvent,
    'payerAccountReference': AccountReference,
    'payerPartyReference': PartyReference,
    'paymentAmount': NonNegativeMoney,
    'paymentDate': AdjustableOrRelativeDate,
    'paymentDates': CommodityRelativePaymentDates,
    'paymentDaysOffset': DateOffset,
    'paymentDetail': PaymentDetail,
    'paymentFrequency': Period,
    'paymentReference': PaymentReference,
    'paymentRequirement': Money,
    'paymentRule': PaymentRule,
    'paymentType': PaymentType,
    'percentageTolerance': PercentageTolerance,
    'periodicDates': PeriodicDates,
    'periods': AdjustableDates,
    'periodsSchedule': CommodityCalculationPeriodsSchedule,
    'person': Person,
    'personId': PersonId,
    'personReference': PersonReference,
    'physicalExercise': CommodityPhysicalExercise,
    'physicalQuantity': CommodityNotionalQuantity,
    'physicalQuantitySchedule': CommodityPhysicalQuantitySchedule,
    'pipeline': OilPipelineDelivery,
    'pipelineName': CommodityPipeline,
    'pool': AssetPool,
    'predeterminedClearingOrganizationPartyReference': PartyReference,
    'premium': Premium,
    'premiumPerUnit': NonNegativeMoney,
    'presentValueAmount': Money,
    'priceCurrency': Currency,
    'pricePerOption': Money,
    'priceUnit': QuantityUnit,
    'pricingDates': CommodityPricingDates,
    'pricingModel': PricingModel,
    'pricingStartDate': AdjustableDate,
    'primaryAssetClass': AssetClass,
    'primaryDisruptionFallbacks': DisruptionFallback,
    'primaryRateSource': InformationSource,
    'producer': CommodityMetalProducer,
    'product': Product,
    'productId': ProductId,
    'productType': ProductType,
    'publication': CommodityInformationSource,
    'publiclyAvailableInformation': PubliclyAvailableInformation,
    'quality': GasQuality,
    'quantityFrequency': CommodityQuantityFrequency,
    'quantityReference': QuantityReference,
    'quantityStep': CommodityNotionalQuantity,
    'quantityUnit': QuantityUnit,
    'quanto': Quanto,
    'quotationCharacteristics': QuotationCharacteristics,
    'quoteUnits': PriceQuoteUnits,
    'quotedCurrencyPair': QuotedCurrencyPair,
    'rateIndex': RateIndex,
    'rateReference': RateReference,
    'rateSource': InformationProvider,
    'rateSourceFixing': FxRateSourceFixing,
    'rateSourcePage': RateSourcePage,
    'receiverAccountReference': AccountReference,
    'receiverPartyReference': PartyReference,
    'referenceBank': ReferenceBank,
    'referenceBankId': ReferenceBankId,
    'referenceCurrency': Currency,
    'referenceEntity': LegalEntity,
    'referenceLevel': ReferenceLevel,
    'referenceLevelUnit': ReferenceLevelUnit,
    'region': Region,
    'relatedExchangeId': ExchangeId,
    'relatedParty': PartyRelationship,
    'relativeCommencementDates': CommodityRelativeExpirationDates,
    'relativeDate': RelativeDateOffset,
    'relativeDateAdjustments': BusinessDayAdjustments,
    'relativeDateSequence': RelativeDateSequence,
    'relativeDates': RelativeDates,
    'relativeExpirationDates': CommodityRelativeExpirationDates,
    'relativePaymentDates': CommodityRelativePaymentDates,
    'relevantUnderlyingDate': AdjustableOrRelativeDates,
    'resourceId': ResourceId,
    'resourceType': ResourceType,
    'restructuring': Restructuring,
    'restructuringType': RestructuringType,
    'risk': CommodityDeliveryRisk,
    'riskPeriod': EEPRiskPeriod,
    'role': PersonRole,
    'rounding': Rounding,
    'routingAddress': Address,
    'routingExplicitDetails': RoutingExplicitDetails,
    'routingId': RoutingId,
    'routingIds': RoutingIds,
    'routingIdsAndExplicitDetails': RoutingIdsAndExplicitDetails,
    'schedule': AveragingSchedule,
    'scheduleBounds': DateRange,
    'secondaryAssetClass': AssetClass,
    'secondaryDisruptionFallbacks': DisruptionFallback,
    'secondaryRateSource': InformationSource,
    'sector': MortgageSector,
    'seller': IdentifiedPayerReceiver,
    'sellerAccountReference': AccountReference,
    'sellerHub': CommodityHub,
    'sellerPartyReference': PartyReference,
    'seniority': CreditSeniority,
    'servicingParty': PartyReference,
    'settlementAmount': Money,
    'settlementCurrency': Currency,
    'settlementDate': AdjustableDate,
    'settlementInformation': SettlementInformation,
    'settlementInstruction': SettlementInstruction,
    'settlementMethod': SettlementMethod,
    'settlementPeriods': SettlementPeriods,
    'settlementPeriodsNotionalQuantity': CommoditySettlementPeriodsNotionalQuantity,
    'settlementPeriodsNotionalQuantitySchedule': CommoditySettlementPeriodsNotionalQuantitySchedule,
    'settlementPeriodsNotionalQuantityStep': CommodityNotionalQuantity,
    'settlementPeriodsPrice': SettlementPeriodsFixedPrice,
    'settlementPeriodsPriceSchedule': CommoditySettlementPeriodsPriceSchedule,
    'settlementPeriodsPriceStep': FixedPrice,
    'settlementPeriodsReference': SettlementPeriodsReference,
    'settlementPeriodsSchedule': SettlementPeriodsSchedule,
    'settlementPeriodsStep': SettlementPeriodsStep,
    'settlementRateOption': SettlementRateOption,
    'settlementRateSource': FxSettlementRateSource,
    'shape': CommodityMetalShape,
    'simpleCreditDefaultSwap': SimpleCreditDefaultSwap,
    'simpleFra': SimpleFra,
    'simpleIrSwap': SimpleIRSwap,
    'singleUnderlyer': SingleUnderlyer,
    'so2QualityAdjustment': CoalQualityAdjustments,
    'softeningHeightHalfWidth': CoalAttributeDecimal,
    'softeningHeightWidth': CoalAttributeDecimal,
    'source': CoalProductSource,
    'specifiedExchangeId': ExchangeId,
    'splitSettlement': SplitSettlement,
    'splitSettlementAmount': Money,
    'spread': CommoditySpread,
    'spreadSchedule': SpreadSchedule,
    'spreadStep': CommoditySpread,
    'spreadUnit': QuantityUnit,
    'standardQuality': CoalStandardQuality,
    'standardQualitySchedule': CoalStandardQualitySchedule,
    'startTerm': Period,
    'startTime': OffsetPrevailingTime,
    'startingDate': CommodityStartingDate,
    'step': Step,
    'strategyFeature': StrategyFeature,
    'streetAddress': StreetAddress,
    'strikePriceBasketReference': StrikePriceBasketReference,
    'strikePricePerUnit': NonNegativeMoney,
    'strikePricePerUnitSchedule': CommodityStrikeSchedule,
    'strikePricePerUnitStep': NonNegativeMoney,
    'strikePriceUnderlyingReference': StrikePriceUnderlyingReference,
    'strikeSpread': StrikeSpread,
    'stubAmount': Money,
    'stubEndDate': AdjustableOrRelativeDate,
    'stubStartDate': AdjustableOrRelativeDate,
    'sulfur': CoalAttributePercentage,
    'supplyEndTime': PrevailingTime,
    'supplyStartTime': PrevailingTime,
    'system': CommodityDeliveryPoint,
    'systemFirm': ElectricityDeliverySystemFirm,
    'telephone': TelephoneNumber,
    'term': Period,
    'terminationDate': AdjustableOrRelativeDate,
    'time': PrevailingTime,
    'timing': QuoteTiming,
    'topSize': CoalAttributeDecimal,
    'totalPhysicalQuantity': UnitQuantity,
    'totalPrice': NonNegativeMoney,
    'trackingSystem': EnvironmentalTrackingSystem,
    'tradeId': TradeId,
    'tranche': UnderlyingAssetTranche,
    'transfer': OilTransferDelivery,
    'transmissionContingency': ElectricityTransmissionContingency,
    'transportationEquipment': CoalTransportationEquipment,
    'trigger': Trigger,
    'triggerDates': DateList,
    'type': SpreadScheduleType,
    'unadjustedDate': IdentifiedDate,
    'underlyerCollateral': Collateral,
    'underlyerFinancing': UnderlyerInterestLeg,
    'underlyerLoanRate': UnderlyerLoanRate,
    'underlyerNotional': Money,
    'underlyerPrice': Price,
    'underlyerReference': AssetReference,
    'underlyerSpread': SpreadScheduleReference,
    'underlying': CommodityBasketUnderlyingByPercentage,
    'underlyingAsset': Asset,
    'underlyingEquity': EquityAsset,
    'unit': QuantityUnit,
    'unitFirm': ElectricityDeliveryUnitFirm,
    'upperStrike': OptionStrike,
    'valuationDates': CommodityValuationDates,
    'value': Money,
    'valueDate': AdjustableOrRelativeDate,
    'varianceCalculation': CommodityVarianceCalculation,
    'version': AgreementVersion,
    'volatile': CoalAttributePercentage,
    'weatherCalculationPeriods': WeatherCalculationPeriods,
    'weatherCalculationPeriodsReference': CalculationPeriodsReference,
    'weatherIndexData': WeatherIndexData,
    'weatherIndexLevel': WeatherIndex,
    'weatherIndexStrikeLevel': WeatherIndex,
    'weatherLeg': WeatherLeg,
    'weatherNotionalAmount': NonNegativeMoney,
    'weatherStation': WeatherStation,
    'weatherStationAirport': WeatherStationAirport,
    'weatherStationCity': BusinessCenter,
    'weatherStationFallback': WeatherStation,
    'weatherStationSecondFallback': WeatherStation,
    'weatherStationWBAN': WeatherStationWBAN,
    'weatherStationWMO': WeatherStationWMO,
    'withdrawalPoint': CommodityDeliveryPoint,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'AbsoluteTolerance'
        rootClass = AbsoluteTolerance
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'AbsoluteTolerance'
        rootClass = AbsoluteTolerance
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from StringIO import StringIO
    parser = None
    doc = parsexml_(StringIO(inString), parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'AbsoluteTolerance'
        rootClass = AbsoluteTolerance
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'AbsoluteTolerance'
        rootClass = AbsoluteTolerance
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from fpml_comlib import *\n\n')
        sys.stdout.write('import fpml_comlib as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "AbsoluteTolerance",
    "Account",
    "AccountId",
    "AccountName",
    "AccountReference",
    "AccountType",
    "ActionType",
    "ActualPrice",
    "Address",
    "AdjustableDate",
    "AdjustableDate2",
    "AdjustableDates",
    "AdjustableDatesOrRelativeDateOffset",
    "AdjustableOrAdjustedDate",
    "AdjustableOrRelativeDate",
    "AdjustableOrRelativeDates",
    "AdjustableRelativeOrPeriodicDates",
    "AdjustableRelativeOrPeriodicDates2",
    "AdjustedRelativeDateOffset",
    "AgreementType",
    "AgreementVersion",
    "AmericanExercise",
    "AmountReference",
    "AmountSchedule",
    "AnyAssetReference",
    "Asian",
    "Asset",
    "AssetClass",
    "AssetMeasureType",
    "AssetPool",
    "AssetReference",
    "AutomaticExercise",
    "AverageDailyTradingVolumeLimit",
    "AveragePriceLeg",
    "AveragingObservationList",
    "AveragingPeriod",
    "AveragingSchedule",
    "Barrier",
    "BasicQuotation",
    "Basket",
    "BasketConstituent",
    "BasketId",
    "BasketName",
    "Beneficiary",
    "BermudaExercise",
    "Bond",
    "BrokerConfirmation",
    "BrokerConfirmationType",
    "BullionDeliveryLocation",
    "BullionPhysicalLeg",
    "BusinessCenter",
    "BusinessCenterTime",
    "BusinessCenters",
    "BusinessCentersReference",
    "BusinessDateRange",
    "BusinessDayAdjustments",
    "BusinessDayAdjustmentsReference",
    "BusinessUnit",
    "BusinessUnitReference",
    "BusinessUnitRole",
    "CalculationAgent",
    "CalculationPeriodFrequency",
    "CalculationPeriodsDatesReference",
    "CalculationPeriodsReference",
    "CalculationPeriodsScheduleReference",
    "CalendarSpread",
    "Cash",
    "CashSettlementReferenceBanks",
    "CashflowId",
    "CashflowNotional",
    "CashflowType",
    "ClassifiablePayment",
    "ClearanceSystem",
    "CoalAttributeDecimal",
    "CoalAttributePercentage",
    "CoalDelivery",
    "CoalDeliveryPoint",
    "CoalPhysicalLeg",
    "CoalProduct",
    "CoalProductSource",
    "CoalProductSpecifications",
    "CoalProductType",
    "CoalQualityAdjustments",
    "CoalStandardQuality",
    "CoalStandardQualitySchedule",
    "CoalTransportationEquipment",
    "Collateral",
    "CollateralValueAllocation",
    "Commission",
    "Commodity",
    "CommodityAmericanExercise",
    "CommodityBarrier",
    "CommodityBase",
    "CommodityBasket",
    "CommodityBasketBase",
    "CommodityBasketByNotional",
    "CommodityBasketByPercentage",
    "CommodityBasketOption",
    "CommodityBasketUnderlyingBase",
    "CommodityBasketUnderlyingByNotional",
    "CommodityBasketUnderlyingByPercentage",
    "CommodityBusinessCalendar",
    "CommodityCalculationPeriodsSchedule",
    "CommodityDeliveryPeriods",
    "CommodityDeliveryPoint",
    "CommodityDeliveryRisk",
    "CommodityDetails",
    "CommodityDigital",
    "CommodityDigitalExercise",
    "CommodityDigitalOption",
    "CommodityEuropeanExercise",
    "CommodityExercise",
    "CommodityExerciseBasket",
    "CommodityExercisePeriods",
    "CommodityExpireRelativeToEvent",
    "CommodityFixedInterestCalculation",
    "CommodityFixedPriceSchedule",
    "CommodityForward",
    "CommodityForwardLeg",
    "CommodityFrequencyType",
    "CommodityFx",
    "CommodityFxType",
    "CommodityHub",
    "CommodityHubCode",
    "CommodityInformationProvider",
    "CommodityInformationSource",
    "CommodityInterestLeg",
    "CommodityMarketDisruption",
    "CommodityMetalBrand",
    "CommodityMetalBrandManager",
    "CommodityMetalBrandName",
    "CommodityMetalGrade",
    "CommodityMetalProducer",
    "CommodityMetalShape",
    "CommodityMultipleExercise",
    "CommodityNotionalAmount",
    "CommodityNotionalAmountReference",
    "CommodityNotionalQuantity",
    "CommodityNotionalQuantitySchedule",
    "CommodityOption",
    "CommodityPayRelativeToEvent",
    "CommodityPerformanceSwap",
    "CommodityPerformanceSwapBase",
    "CommodityPerformanceSwapEarlyTermination",
    "CommodityPerformanceSwapLeg",
    "CommodityPhysicalAmericanExercise",
    "CommodityPhysicalEuropeanExercise",
    "CommodityPhysicalExercise",
    "CommodityPhysicalQuantity",
    "CommodityPhysicalQuantityBase",
    "CommodityPhysicalQuantitySchedule",
    "CommodityPipeline",
    "CommodityPipelineCycle",
    "CommodityPremium",
    "CommodityPricingDates",
    "CommodityProductGrade",
    "CommodityQuantityFrequency",
    "CommodityRelativeExpirationDates",
    "CommodityRelativePaymentDates",
    "CommodityReturnCalculation",
    "CommodityReturnLeg",
    "CommoditySettlementPeriodsNotionalQuantity",
    "CommoditySettlementPeriodsNotionalQuantitySchedule",
    "CommoditySettlementPeriodsPriceSchedule",
    "CommoditySpread",
    "CommoditySpreadSchedule",
    "CommodityStartingDate",
    "CommodityStrikeSchedule",
    "CommoditySwap",
    "CommoditySwapLeg",
    "CommoditySwaption",
    "CommoditySwaptionUnderlying",
    "CommodityTrigger",
    "CommodityValuationDates",
    "CommodityVarianceCalculation",
    "CommodityVarianceLeg",
    "Composite",
    "ConstituentWeight",
    "ContactInformation",
    "ContractualDefinitions",
    "ContractualMatrix",
    "ContractualSupplement",
    "ContractualTermsSupplement",
    "ConvertibleBond",
    "CorrespondentInformation",
    "CountryCode",
    "CouponType",
    "CreditEventNotice",
    "CreditEvents",
    "CreditEventsReference",
    "CreditRating",
    "CreditSeniority",
    "CreditSupportAgreement",
    "CreditSupportAgreementIdentifier",
    "CreditSupportAgreementType",
    "Currency",
    "DataProvider",
    "DateList",
    "DateOffset",
    "DateRange",
    "DateReference",
    "DateTimeList",
    "DayCountFraction",
    "DeliveryNearby",
    "Deposit",
    "DeterminationMethod",
    "DeterminationMethodReference",
    "DirectionalLeg",
    "DisruptionFallback",
    "DividendPayout",
    "Documentation",
    "EEPParameters",
    "EEPRiskPeriod",
    "ElectricityDelivery",
    "ElectricityDeliveryFirm",
    "ElectricityDeliveryPoint",
    "ElectricityDeliverySystemFirm",
    "ElectricityDeliveryType",
    "ElectricityDeliveryUnitFirm",
    "ElectricityPhysicalDeliveryQuantity",
    "ElectricityPhysicalDeliveryQuantitySchedule",
    "ElectricityPhysicalLeg",
    "ElectricityPhysicalQuantity",
    "ElectricityProduct",
    "ElectricityTransmissionContingency",
    "ElectricityTransmissionContingencyType",
    "EmbeddedOptionType",
    "Empty",
    "EntityId",
    "EntityName",
    "EnvironmentalPhysicalLeg",
    "EnvironmentalProduct",
    "EnvironmentalProductApplicableLaw",
    "EnvironmentalProductComplaincePeriod",
    "EnvironmentalTrackingSystem",
    "EquityAsset",
    "EuropeanExercise",
    "ExchangeId",
    "ExchangeTraded",
    "ExchangeTradedCalculatedPrice",
    "ExchangeTradedContract",
    "ExchangeTradedFund",
    "ExchangeTradedOption",
    "Exercise",
    "ExerciseFee",
    "ExerciseFeeSchedule",
    "ExerciseNotice",
    "ExerciseProcedure",
    "ExerciseProcedureOption",
    "FacilityType",
    "FailureToPay",
    "FeaturePayment",
    "FinancialSwapLeg",
    "FixedPrice",
    "FixedPriceLeg",
    "FloatingLegCalculation",
    "FloatingPriceLeg",
    "FloatingRate",
    "FloatingRateCalculation",
    "FloatingRateIndex",
    "FloatingStrikePrice",
    "ForecastRateIndex",
    "Formula",
    "FormulaComponent",
    "Frequency",
    "Future",
    "FutureId",
    "FutureValueAmount",
    "FxCashSettlement",
    "FxCashSettlementSimple",
    "FxConversion",
    "FxFeature",
    "FxFixing",
    "FxInformationSource",
    "FxRate",
    "FxRateAsset",
    "FxRateSourceFixing",
    "FxSettlementRateSource",
    "FxSpotRateSource",
    "GasDelivery",
    "GasDeliveryPeriods",
    "GasDeliveryPoint",
    "GasPhysicalLeg",
    "GasPhysicalQuantity",
    "GasProduct",
    "GasQuality",
    "GenericAgreement",
    "GoverningLaw",
    "GracePeriodExtension",
    "GrossCashflow",
    "IdentifiedAsset",
    "IdentifiedCurrency",
    "IdentifiedCurrencyReference",
    "IdentifiedDate",
    "IdentifiedPayerReceiver",
    "IdentifiedRate",
    "IndependentAmount",
    "Index",
    "IndustryClassification",
    "InformationProvider",
    "InformationSource",
    "InstrumentId",
    "InterconnectionPoint",
    "InterestAccrualsCompoundingMethod",
    "InterestAccrualsMethod",
    "IntermediaryInformation",
    "InterpolationMethod",
    "IssuerId",
    "IssuerTradeId",
    "Knock",
    "Lag",
    "LagReference",
    "Language",
    "Leg",
    "LegId",
    "LegIdentifier",
    "LegalEntity",
    "LegalEntityReference",
    "Lien",
    "Loan",
    "MainPublication",
    "ManualExercise",
    "MarketDisruption",
    "MarketDisruptionEvent",
    "MasterAgreement",
    "MasterAgreementId",
    "MasterAgreementType",
    "MasterAgreementVersion",
    "MasterConfirmation",
    "MasterConfirmationAnnexType",
    "MasterConfirmationType",
    "MatchId",
    "Material",
    "Math",
    "MatrixTerm",
    "MatrixType",
    "Metal",
    "MetalDelivery",
    "MetalPhysicalLeg",
    "MimeType",
    "Money",
    "MoneyBase",
    "Mortgage",
    "MortgageSector",
    "MultipleExercise",
    "MutualFund",
    "NonNegativeAmountSchedule",
    "NonNegativeMoney",
    "NonNegativePayment",
    "NonNegativeSchedule",
    "NonNegativeStep",
    "NonPeriodicFixedPriceLeg",
    "NotifyingParty",
    "NotionalAmount",
    "NotionalAmountReference",
    "NotionalReference",
    "NumberOfOptionsReference",
    "NumberOfUnitsReference",
    "ObservationFrequency",
    "Offset",
    "OffsetPrevailingTime",
    "OilDelivery",
    "OilPhysicalLeg",
    "OilPipelineDelivery",
    "OilProduct",
    "OilProductType",
    "OilTransferDelivery",
    "OnBehalfOf",
    "Option",
    "OptionBase",
    "OptionBaseExtended",
    "OptionFeature",
    "OptionNumericStrike",
    "OptionStrike",
    "OrganizationType",
    "OriginatingEvent",
    "PartialExercise",
    "Party",
    "PartyContactInformation",
    "PartyGroupType",
    "PartyId",
    "PartyName",
    "PartyReference",
    "PartyRelationship",
    "PartyRelationshipDocumentation",
    "PartyRole",
    "PartyRoleType",
    "PartyTradeIdentifierReference",
    "PassThrough",
    "PassThroughItem",
    "Payment",
    "PaymentBase",
    "PaymentBaseExtended",
    "PaymentDetail",
    "PaymentDetails",
    "PaymentId",
    "PaymentReference",
    "PaymentRule",
    "PaymentType",
    "PendingPayment",
    "PercentageTolerance",
    "Period",
    "PeriodicDates",
    "Person",
    "PersonId",
    "PersonReference",
    "PersonRole",
    "PhysicalForwardLeg",
    "PhysicalSwapLeg",
    "PositiveMoney",
    "Premium",
    "PrevailingTime",
    "Price",
    "PriceQuoteUnits",
    "PricingModel",
    "PricingStructure",
    "PricingStructureReference",
    "PrincipalExchanges",
    "Product",
    "ProductId",
    "ProductReference",
    "ProductType",
    "ProposedCollateralAllocation",
    "PubliclyAvailableInformation",
    "QuantityReference",
    "QuantityUnit",
    "Quanto",
    "QuotationCharacteristics",
    "QuoteTiming",
    "QuotedCurrencyPair",
    "Rate",
    "RateIndex",
    "RateObservation",
    "RateReference",
    "RateSourcePage",
    "Reference",
    "ReferenceAmount",
    "ReferenceBank",
    "ReferenceBankId",
    "ReferenceLevel",
    "ReferenceLevelUnit",
    "Region",
    "RelatedBusinessUnit",
    "RelatedParty",
    "RelatedPerson",
    "RelativeDateOffset",
    "RelativeDateSequence",
    "RelativeDates",
    "ReportingCurrencyType",
    "ReportingRegimeName",
    "RequestedAction",
    "RequiredIdentifierDate",
    "ResetFrequency",
    "Resource",
    "ResourceId",
    "ResourceLength",
    "ResourceType",
    "Restructuring",
    "RestructuringType",
    "ReturnSwapNotionalAmountReference",
    "Rounding",
    "Routing",
    "RoutingExplicitDetails",
    "RoutingId",
    "RoutingIds",
    "RoutingIdsAndExplicitDetails",
    "Schedule",
    "ScheduleReference",
    "SequencedDisruptionFallback",
    "SettlementInformation",
    "SettlementInstruction",
    "SettlementMethod",
    "SettlementPeriods",
    "SettlementPeriodsFixedPrice",
    "SettlementPeriodsReference",
    "SettlementPeriodsSchedule",
    "SettlementPeriodsStep",
    "SettlementPriceDefaultElection",
    "SettlementPriceSource",
    "SettlementRateOption",
    "SettlementRateSource",
    "SettlementTerms",
    "SharedAmericanExercise",
    "SimpleCreditDefaultSwap",
    "SimpleFra",
    "SimpleIRSwap",
    "SimplePayment",
    "SingleUnderlyer",
    "SplitSettlement",
    "SpreadSchedule",
    "SpreadScheduleReference",
    "SpreadScheduleType",
    "Step",
    "StepBase",
    "StrategyFeature",
    "StreetAddress",
    "Strike",
    "StrikePriceBasketReference",
    "StrikePriceUnderlyingReference",
    "StrikeSchedule",
    "StrikeSpread",
    "Stub",
    "StubFloatingRate",
    "StubValue",
    "SupervisoryBody",
    "SwaptionPhysicalSettlement",
    "TelephoneNumber",
    "TimezoneLocation",
    "TradeId",
    "Trigger",
    "TriggerEvent",
    "Underlyer",
    "UnderlyerInterestLeg",
    "UnderlyerLoanRate",
    "UnderlyingAsset",
    "UnderlyingAssetTranche",
    "Unit",
    "UnitQuantity",
    "WeatherCalculationPeriod",
    "WeatherCalculationPeriods",
    "WeatherIndex",
    "WeatherIndexData",
    "WeatherLeg",
    "WeatherLegCalculation",
    "WeatherStation",
    "WeatherStationAirport",
    "WeatherStationWBAN",
    "WeatherStationWMO",
    "WeightedAveragingObservation"
]
