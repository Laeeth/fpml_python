#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Tue Feb 23 09:02:55 2016 by generateDS.py version 2.19b.
#
# Command line options:
#   ('-f', '')
#   ('-o', 'fpml01/fpml_option_sharedlib.py')
#   ('-s', 'fpml01/fpml_option_sharedapp.py')
#   ('--super', 'fpml01/fpml_option_sharedlib')
#   ('--member-specs', 'dict')
#   ('--export', 'write')
#
# Command line arguments:
#   fpml-master-schema-and-key-gen-scripts/src/schema/fpml-option-shared.xsd
#
# Command line:
#   ./generateDS.py -f -o "fpml01/fpml_option_sharedlib.py" -s "fpml01/fpml_option_sharedapp.py" --super="fpml01/fpml_option_sharedlib" --member-specs="dict" --export="write" fpml-master-schema-and-key-gen-scripts/src/schema/fpml-option-shared.xsd
#
# Current working directory (os.getcwd()):
#   Test02
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
from lxml import etree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        parser = etree_.ETCompatXMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                return instring.encode(ExternalEncoding)
            else:
                return instring

    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class Asian(GeneratedsSuper):
    """As per ISDA 2002 Definitions."""
    member_data_items_ = {
        'averagingInOut': MemberSpec_('averagingInOut', ['AveragingInOutEnum', 'Token', 'xsd:token'], 0),
        'strikeFactor': MemberSpec_('strikeFactor', 'xsd:decimal', 0),
        'averagingPeriodIn': MemberSpec_('averagingPeriodIn', 'AveragingPeriod', 0),
        'averagingPeriodOut': MemberSpec_('averagingPeriodOut', 'AveragingPeriod', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, averagingInOut=None, strikeFactor=None, averagingPeriodIn=None, averagingPeriodOut=None):
        self.original_tagname_ = None
        self.averagingInOut = averagingInOut
        self.validate_AveragingInOutEnum(self.averagingInOut)
        self.strikeFactor = strikeFactor
        self.averagingPeriodIn = averagingPeriodIn
        self.averagingPeriodOut = averagingPeriodOut
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Asian)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Asian.subclass:
            return Asian.subclass(*args_, **kwargs_)
        else:
            return Asian(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_averagingInOut(self): return self.averagingInOut
    def set_averagingInOut(self, averagingInOut): self.averagingInOut = averagingInOut
    def get_strikeFactor(self): return self.strikeFactor
    def set_strikeFactor(self, strikeFactor): self.strikeFactor = strikeFactor
    def get_averagingPeriodIn(self): return self.averagingPeriodIn
    def set_averagingPeriodIn(self, averagingPeriodIn): self.averagingPeriodIn = averagingPeriodIn
    def get_averagingPeriodOut(self): return self.averagingPeriodOut
    def set_averagingPeriodOut(self, averagingPeriodOut): self.averagingPeriodOut = averagingPeriodOut
    def validate_AveragingInOutEnum(self, value):
        # Validate type AveragingInOutEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['In', 'Out', 'Both']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AveragingInOutEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on AveragingInOutEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.averagingInOut is not None or
            self.strikeFactor is not None or
            self.averagingPeriodIn is not None or
            self.averagingPeriodOut is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Asian', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Asian')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Asian', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Asian'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Asian', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.averagingInOut is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saveragingInOut>%s</%saveragingInOut>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.averagingInOut), input_name='averagingInOut')), namespace_, eol_))
        if self.strikeFactor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstrikeFactor>%s</%sstrikeFactor>%s' % (namespace_, self.gds_format_float(self.strikeFactor, input_name='strikeFactor'), namespace_, eol_))
        if self.averagingPeriodIn is not None:
            self.averagingPeriodIn.export(outfile, level, namespace_, name_='averagingPeriodIn', pretty_print=pretty_print)
        if self.averagingPeriodOut is not None:
            self.averagingPeriodOut.export(outfile, level, namespace_, name_='averagingPeriodOut', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'averagingInOut':
            averagingInOut_ = child_.text
            averagingInOut_ = re_.sub(String_cleanup_pat_, " ", averagingInOut_).strip()
            averagingInOut_ = self.gds_validate_string(averagingInOut_, node, 'averagingInOut')
            self.averagingInOut = averagingInOut_
            # validate type AveragingInOutEnum
            self.validate_AveragingInOutEnum(self.averagingInOut)
        elif nodeName_ == 'strikeFactor':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'strikeFactor')
            self.strikeFactor = fval_
        elif nodeName_ == 'averagingPeriodIn':
            obj_ = AveragingPeriod.factory()
            obj_.build(child_)
            self.averagingPeriodIn = obj_
            obj_.original_tagname_ = 'averagingPeriodIn'
        elif nodeName_ == 'averagingPeriodOut':
            obj_ = AveragingPeriod.factory()
            obj_.build(child_)
            self.averagingPeriodOut = obj_
            obj_.original_tagname_ = 'averagingPeriodOut'
# end class Asian


class AveragingObservationList(GeneratedsSuper):
    """An un ordered list of weighted averaging observations."""
    member_data_items_ = {
        'averagingObservation': MemberSpec_('averagingObservation', 'WeightedAveragingObservation', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, averagingObservation=None):
        self.original_tagname_ = None
        if averagingObservation is None:
            self.averagingObservation = []
        else:
            self.averagingObservation = averagingObservation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AveragingObservationList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AveragingObservationList.subclass:
            return AveragingObservationList.subclass(*args_, **kwargs_)
        else:
            return AveragingObservationList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_averagingObservation(self): return self.averagingObservation
    def set_averagingObservation(self, averagingObservation): self.averagingObservation = averagingObservation
    def add_averagingObservation(self, value): self.averagingObservation.append(value)
    def insert_averagingObservation_at(self, index, value): self.averagingObservation.insert(index, value)
    def replace_averagingObservation_at(self, index, value): self.averagingObservation[index] = value
    def hasContent_(self):
        if (
            self.averagingObservation
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AveragingObservationList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AveragingObservationList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AveragingObservationList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AveragingObservationList'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AveragingObservationList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for averagingObservation_ in self.averagingObservation:
            averagingObservation_.export(outfile, level, namespace_, name_='averagingObservation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'averagingObservation':
            obj_ = WeightedAveragingObservation.factory()
            obj_.build(child_)
            self.averagingObservation.append(obj_)
            obj_.original_tagname_ = 'averagingObservation'
# end class AveragingObservationList


class AveragingPeriod(GeneratedsSuper):
    """Period over which an average value is taken.A choice between
    unweighted and weighted averaging date and times."""
    member_data_items_ = {
        'schedule': MemberSpec_('schedule', 'AveragingSchedule', 1),
        'averagingDateTimes': MemberSpec_('averagingDateTimes', 'DateTimeList', 0),
        'averagingObservations': MemberSpec_('averagingObservations', 'AveragingObservationList', 0),
        'marketDisruption': MemberSpec_('marketDisruption', 'MarketDisruption', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, schedule=None, averagingDateTimes=None, averagingObservations=None, marketDisruption=None):
        self.original_tagname_ = None
        if schedule is None:
            self.schedule = []
        else:
            self.schedule = schedule
        self.averagingDateTimes = averagingDateTimes
        self.averagingObservations = averagingObservations
        self.marketDisruption = marketDisruption
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AveragingPeriod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AveragingPeriod.subclass:
            return AveragingPeriod.subclass(*args_, **kwargs_)
        else:
            return AveragingPeriod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_schedule(self): return self.schedule
    def set_schedule(self, schedule): self.schedule = schedule
    def add_schedule(self, value): self.schedule.append(value)
    def insert_schedule_at(self, index, value): self.schedule.insert(index, value)
    def replace_schedule_at(self, index, value): self.schedule[index] = value
    def get_averagingDateTimes(self): return self.averagingDateTimes
    def set_averagingDateTimes(self, averagingDateTimes): self.averagingDateTimes = averagingDateTimes
    def get_averagingObservations(self): return self.averagingObservations
    def set_averagingObservations(self, averagingObservations): self.averagingObservations = averagingObservations
    def get_marketDisruption(self): return self.marketDisruption
    def set_marketDisruption(self, marketDisruption): self.marketDisruption = marketDisruption
    def hasContent_(self):
        if (
            self.schedule or
            self.averagingDateTimes is not None or
            self.averagingObservations is not None or
            self.marketDisruption is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AveragingPeriod', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AveragingPeriod')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AveragingPeriod', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AveragingPeriod'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AveragingPeriod', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for schedule_ in self.schedule:
            schedule_.export(outfile, level, namespace_, name_='schedule', pretty_print=pretty_print)
        if self.averagingDateTimes is not None:
            self.averagingDateTimes.export(outfile, level, namespace_, name_='averagingDateTimes', pretty_print=pretty_print)
        if self.averagingObservations is not None:
            self.averagingObservations.export(outfile, level, namespace_, name_='averagingObservations', pretty_print=pretty_print)
        if self.marketDisruption is not None:
            self.marketDisruption.export(outfile, level, namespace_, name_='marketDisruption', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'schedule':
            obj_ = AveragingSchedule.factory()
            obj_.build(child_)
            self.schedule.append(obj_)
            obj_.original_tagname_ = 'schedule'
        elif nodeName_ == 'averagingDateTimes':
            obj_ = DateTimeList.factory()
            obj_.build(child_)
            self.averagingDateTimes = obj_
            obj_.original_tagname_ = 'averagingDateTimes'
        elif nodeName_ == 'averagingObservations':
            obj_ = AveragingObservationList.factory()
            obj_.build(child_)
            self.averagingObservations = obj_
            obj_.original_tagname_ = 'averagingObservations'
        elif nodeName_ == 'marketDisruption':
            obj_ = MarketDisruption.factory()
            obj_.build(child_)
            self.marketDisruption = obj_
            obj_.original_tagname_ = 'marketDisruption'
# end class AveragingPeriod


class AveragingSchedule(GeneratedsSuper):
    """Method of generating a series of dates."""
    member_data_items_ = {
        'startDate': MemberSpec_('startDate', 'xsd:date', 0),
        'endDate': MemberSpec_('endDate', 'xsd:date', 0),
        'averagingPeriodFrequency': MemberSpec_('averagingPeriodFrequency', 'CalculationPeriodFrequency', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, startDate=None, endDate=None, averagingPeriodFrequency=None):
        self.original_tagname_ = None
        if isinstance(startDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(startDate, '%Y-%m-%d').date()
        else:
            initvalue_ = startDate
        self.startDate = initvalue_
        if isinstance(endDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(endDate, '%Y-%m-%d').date()
        else:
            initvalue_ = endDate
        self.endDate = initvalue_
        self.averagingPeriodFrequency = averagingPeriodFrequency
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AveragingSchedule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AveragingSchedule.subclass:
            return AveragingSchedule.subclass(*args_, **kwargs_)
        else:
            return AveragingSchedule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_startDate(self): return self.startDate
    def set_startDate(self, startDate): self.startDate = startDate
    def get_endDate(self): return self.endDate
    def set_endDate(self, endDate): self.endDate = endDate
    def get_averagingPeriodFrequency(self): return self.averagingPeriodFrequency
    def set_averagingPeriodFrequency(self, averagingPeriodFrequency): self.averagingPeriodFrequency = averagingPeriodFrequency
    def hasContent_(self):
        if (
            self.startDate is not None or
            self.endDate is not None or
            self.averagingPeriodFrequency is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AveragingSchedule', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AveragingSchedule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AveragingSchedule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AveragingSchedule'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AveragingSchedule', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.startDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstartDate>%s</%sstartDate>%s' % (namespace_, self.gds_format_date(self.startDate, input_name='startDate'), namespace_, eol_))
        if self.endDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sendDate>%s</%sendDate>%s' % (namespace_, self.gds_format_date(self.endDate, input_name='endDate'), namespace_, eol_))
        if self.averagingPeriodFrequency is not None:
            self.averagingPeriodFrequency.export(outfile, level, namespace_, name_='averagingPeriodFrequency', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'startDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.startDate = dval_
        elif nodeName_ == 'endDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.endDate = dval_
        elif nodeName_ == 'averagingPeriodFrequency':
            obj_ = CalculationPeriodFrequency.factory()
            obj_.build(child_)
            self.averagingPeriodFrequency = obj_
            obj_.original_tagname_ = 'averagingPeriodFrequency'
# end class AveragingSchedule


class Barrier(GeneratedsSuper):
    """As per ISDA 2002 Definitions."""
    member_data_items_ = {
        'barrierCap': MemberSpec_('barrierCap', 'TriggerEvent', 0),
        'barrierFloor': MemberSpec_('barrierFloor', 'TriggerEvent', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, barrierCap=None, barrierFloor=None):
        self.original_tagname_ = None
        self.barrierCap = barrierCap
        self.barrierFloor = barrierFloor
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Barrier)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Barrier.subclass:
            return Barrier.subclass(*args_, **kwargs_)
        else:
            return Barrier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_barrierCap(self): return self.barrierCap
    def set_barrierCap(self, barrierCap): self.barrierCap = barrierCap
    def get_barrierFloor(self): return self.barrierFloor
    def set_barrierFloor(self, barrierFloor): self.barrierFloor = barrierFloor
    def hasContent_(self):
        if (
            self.barrierCap is not None or
            self.barrierFloor is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Barrier', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Barrier')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Barrier', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Barrier'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Barrier', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.barrierCap is not None:
            self.barrierCap.export(outfile, level, namespace_, name_='barrierCap', pretty_print=pretty_print)
        if self.barrierFloor is not None:
            self.barrierFloor.export(outfile, level, namespace_, name_='barrierFloor', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'barrierCap':
            obj_ = TriggerEvent.factory()
            obj_.build(child_)
            self.barrierCap = obj_
            obj_.original_tagname_ = 'barrierCap'
        elif nodeName_ == 'barrierFloor':
            obj_ = TriggerEvent.factory()
            obj_.build(child_)
            self.barrierFloor = obj_
            obj_.original_tagname_ = 'barrierFloor'
# end class Barrier


class CalendarSpread(GeneratedsSuper):
    """A type for defining a calendar spread feature."""
    member_data_items_ = {
        'expirationDateTwo': MemberSpec_('expirationDateTwo', 'AdjustableOrRelativeDate', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, expirationDateTwo=None):
        self.original_tagname_ = None
        self.expirationDateTwo = expirationDateTwo
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CalendarSpread)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CalendarSpread.subclass:
            return CalendarSpread.subclass(*args_, **kwargs_)
        else:
            return CalendarSpread(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_expirationDateTwo(self): return self.expirationDateTwo
    def set_expirationDateTwo(self, expirationDateTwo): self.expirationDateTwo = expirationDateTwo
    def hasContent_(self):
        if (
            self.expirationDateTwo is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CalendarSpread', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CalendarSpread')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CalendarSpread', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CalendarSpread'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CalendarSpread', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.expirationDateTwo is not None:
            self.expirationDateTwo.export(outfile, level, namespace_, name_='expirationDateTwo', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'expirationDateTwo':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.expirationDateTwo = obj_
            obj_.original_tagname_ = 'expirationDateTwo'
# end class CalendarSpread


class Composite(GeneratedsSuper):
    """Specifies the conditions to be applied for converting into a
    reference currency when the actual currency rate is not
    determined upfront."""
    member_data_items_ = {
        'determinationMethod': MemberSpec_('determinationMethod', 'DeterminationMethod', 0),
        'relativeDate': MemberSpec_('relativeDate', 'RelativeDateOffset', 0),
        'fxSpotRateSource': MemberSpec_('fxSpotRateSource', 'FxSpotRateSource', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, determinationMethod=None, relativeDate=None, fxSpotRateSource=None):
        self.original_tagname_ = None
        self.determinationMethod = determinationMethod
        self.relativeDate = relativeDate
        self.fxSpotRateSource = fxSpotRateSource
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Composite)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Composite.subclass:
            return Composite.subclass(*args_, **kwargs_)
        else:
            return Composite(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_determinationMethod(self): return self.determinationMethod
    def set_determinationMethod(self, determinationMethod): self.determinationMethod = determinationMethod
    def get_relativeDate(self): return self.relativeDate
    def set_relativeDate(self, relativeDate): self.relativeDate = relativeDate
    def get_fxSpotRateSource(self): return self.fxSpotRateSource
    def set_fxSpotRateSource(self, fxSpotRateSource): self.fxSpotRateSource = fxSpotRateSource
    def hasContent_(self):
        if (
            self.determinationMethod is not None or
            self.relativeDate is not None or
            self.fxSpotRateSource is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Composite', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Composite')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Composite', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Composite'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Composite', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.determinationMethod is not None:
            self.determinationMethod.export(outfile, level, namespace_, name_='determinationMethod', pretty_print=pretty_print)
        if self.relativeDate is not None:
            self.relativeDate.export(outfile, level, namespace_, name_='relativeDate', pretty_print=pretty_print)
        if self.fxSpotRateSource is not None:
            self.fxSpotRateSource.export(outfile, level, namespace_, name_='fxSpotRateSource', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'determinationMethod':
            obj_ = DeterminationMethod.factory()
            obj_.build(child_)
            self.determinationMethod = obj_
            obj_.original_tagname_ = 'determinationMethod'
        elif nodeName_ == 'relativeDate':
            class_obj_ = self.get_class_obj_(child_, RelativeDateOffset)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.relativeDate = obj_
            obj_.original_tagname_ = 'relativeDate'
        elif nodeName_ == 'fxSpotRateSource':
            obj_ = FxSpotRateSource.factory()
            obj_.build(child_)
            self.fxSpotRateSource = obj_
            obj_.original_tagname_ = 'fxSpotRateSource'
# end class Composite


class CreditEventNotice(GeneratedsSuper):
    member_data_items_ = {
        'notifyingParty': MemberSpec_('notifyingParty', 'NotifyingParty', 0),
        'businessCenter': MemberSpec_('businessCenter', 'BusinessCenter', 0),
        'publiclyAvailableInformation': MemberSpec_('publiclyAvailableInformation', 'PubliclyAvailableInformation', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, notifyingParty=None, businessCenter=None, publiclyAvailableInformation=None):
        self.original_tagname_ = None
        self.notifyingParty = notifyingParty
        self.businessCenter = businessCenter
        self.publiclyAvailableInformation = publiclyAvailableInformation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditEventNotice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditEventNotice.subclass:
            return CreditEventNotice.subclass(*args_, **kwargs_)
        else:
            return CreditEventNotice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_notifyingParty(self): return self.notifyingParty
    def set_notifyingParty(self, notifyingParty): self.notifyingParty = notifyingParty
    def get_businessCenter(self): return self.businessCenter
    def set_businessCenter(self, businessCenter): self.businessCenter = businessCenter
    def get_publiclyAvailableInformation(self): return self.publiclyAvailableInformation
    def set_publiclyAvailableInformation(self, publiclyAvailableInformation): self.publiclyAvailableInformation = publiclyAvailableInformation
    def hasContent_(self):
        if (
            self.notifyingParty is not None or
            self.businessCenter is not None or
            self.publiclyAvailableInformation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditEventNotice', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditEventNotice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditEventNotice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditEventNotice'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CreditEventNotice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.notifyingParty is not None:
            self.notifyingParty.export(outfile, level, namespace_, name_='notifyingParty', pretty_print=pretty_print)
        if self.businessCenter is not None:
            self.businessCenter.export(outfile, level, namespace_, name_='businessCenter', pretty_print=pretty_print)
        if self.publiclyAvailableInformation is not None:
            self.publiclyAvailableInformation.export(outfile, level, namespace_, name_='publiclyAvailableInformation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'notifyingParty':
            obj_ = NotifyingParty.factory()
            obj_.build(child_)
            self.notifyingParty = obj_
            obj_.original_tagname_ = 'notifyingParty'
        elif nodeName_ == 'businessCenter':
            obj_ = BusinessCenter.factory()
            obj_.build(child_)
            self.businessCenter = obj_
            obj_.original_tagname_ = 'businessCenter'
        elif nodeName_ == 'publiclyAvailableInformation':
            obj_ = PubliclyAvailableInformation.factory()
            obj_.build(child_)
            self.publiclyAvailableInformation = obj_
            obj_.original_tagname_ = 'publiclyAvailableInformation'
# end class CreditEventNotice


class CreditEvents(GeneratedsSuper):
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'bankruptcy': MemberSpec_('bankruptcy', 'xsd:boolean', 0),
        'failureToPay': MemberSpec_('failureToPay', 'FailureToPay', 0),
        'failureToPayPrincipal': MemberSpec_('failureToPayPrincipal', 'xsd:boolean', 0),
        'failureToPayInterest': MemberSpec_('failureToPayInterest', 'xsd:boolean', 0),
        'obligationDefault': MemberSpec_('obligationDefault', 'xsd:boolean', 0),
        'obligationAcceleration': MemberSpec_('obligationAcceleration', 'xsd:boolean', 0),
        'repudiationMoratorium': MemberSpec_('repudiationMoratorium', 'xsd:boolean', 0),
        'restructuring': MemberSpec_('restructuring', 'Restructuring', 0),
        'governmentalIntervention': MemberSpec_('governmentalIntervention', 'xsd:boolean', 0),
        'distressedRatingsDowngrade': MemberSpec_('distressedRatingsDowngrade', 'xsd:boolean', 0),
        'maturityExtension': MemberSpec_('maturityExtension', 'xsd:boolean', 0),
        'writedown': MemberSpec_('writedown', 'xsd:boolean', 0),
        'impliedWritedown': MemberSpec_('impliedWritedown', 'xsd:boolean', 0),
        'defaultRequirement': MemberSpec_('defaultRequirement', 'Money', 0),
        'creditEventNotice': MemberSpec_('creditEventNotice', 'CreditEventNotice', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, bankruptcy=None, failureToPay=None, failureToPayPrincipal=None, failureToPayInterest=None, obligationDefault=None, obligationAcceleration=None, repudiationMoratorium=None, restructuring=None, governmentalIntervention=None, distressedRatingsDowngrade=None, maturityExtension=None, writedown=None, impliedWritedown=None, defaultRequirement=None, creditEventNotice=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.bankruptcy = bankruptcy
        self.failureToPay = failureToPay
        self.failureToPayPrincipal = failureToPayPrincipal
        self.failureToPayInterest = failureToPayInterest
        self.obligationDefault = obligationDefault
        self.obligationAcceleration = obligationAcceleration
        self.repudiationMoratorium = repudiationMoratorium
        self.restructuring = restructuring
        self.governmentalIntervention = governmentalIntervention
        self.distressedRatingsDowngrade = distressedRatingsDowngrade
        self.maturityExtension = maturityExtension
        self.writedown = writedown
        self.impliedWritedown = impliedWritedown
        self.defaultRequirement = defaultRequirement
        self.creditEventNotice = creditEventNotice
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditEvents)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditEvents.subclass:
            return CreditEvents.subclass(*args_, **kwargs_)
        else:
            return CreditEvents(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_bankruptcy(self): return self.bankruptcy
    def set_bankruptcy(self, bankruptcy): self.bankruptcy = bankruptcy
    def get_failureToPay(self): return self.failureToPay
    def set_failureToPay(self, failureToPay): self.failureToPay = failureToPay
    def get_failureToPayPrincipal(self): return self.failureToPayPrincipal
    def set_failureToPayPrincipal(self, failureToPayPrincipal): self.failureToPayPrincipal = failureToPayPrincipal
    def get_failureToPayInterest(self): return self.failureToPayInterest
    def set_failureToPayInterest(self, failureToPayInterest): self.failureToPayInterest = failureToPayInterest
    def get_obligationDefault(self): return self.obligationDefault
    def set_obligationDefault(self, obligationDefault): self.obligationDefault = obligationDefault
    def get_obligationAcceleration(self): return self.obligationAcceleration
    def set_obligationAcceleration(self, obligationAcceleration): self.obligationAcceleration = obligationAcceleration
    def get_repudiationMoratorium(self): return self.repudiationMoratorium
    def set_repudiationMoratorium(self, repudiationMoratorium): self.repudiationMoratorium = repudiationMoratorium
    def get_restructuring(self): return self.restructuring
    def set_restructuring(self, restructuring): self.restructuring = restructuring
    def get_governmentalIntervention(self): return self.governmentalIntervention
    def set_governmentalIntervention(self, governmentalIntervention): self.governmentalIntervention = governmentalIntervention
    def get_distressedRatingsDowngrade(self): return self.distressedRatingsDowngrade
    def set_distressedRatingsDowngrade(self, distressedRatingsDowngrade): self.distressedRatingsDowngrade = distressedRatingsDowngrade
    def get_maturityExtension(self): return self.maturityExtension
    def set_maturityExtension(self, maturityExtension): self.maturityExtension = maturityExtension
    def get_writedown(self): return self.writedown
    def set_writedown(self, writedown): self.writedown = writedown
    def get_impliedWritedown(self): return self.impliedWritedown
    def set_impliedWritedown(self, impliedWritedown): self.impliedWritedown = impliedWritedown
    def get_defaultRequirement(self): return self.defaultRequirement
    def set_defaultRequirement(self, defaultRequirement): self.defaultRequirement = defaultRequirement
    def get_creditEventNotice(self): return self.creditEventNotice
    def set_creditEventNotice(self, creditEventNotice): self.creditEventNotice = creditEventNotice
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.bankruptcy is not None or
            self.failureToPay is not None or
            self.failureToPayPrincipal is not None or
            self.failureToPayInterest is not None or
            self.obligationDefault is not None or
            self.obligationAcceleration is not None or
            self.repudiationMoratorium is not None or
            self.restructuring is not None or
            self.governmentalIntervention is not None or
            self.distressedRatingsDowngrade is not None or
            self.maturityExtension is not None or
            self.writedown is not None or
            self.impliedWritedown is not None or
            self.defaultRequirement is not None or
            self.creditEventNotice is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditEvents', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditEvents')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditEvents', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditEvents'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CreditEvents', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.bankruptcy is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbankruptcy>%s</%sbankruptcy>%s' % (namespace_, self.gds_format_boolean(self.bankruptcy, input_name='bankruptcy'), namespace_, eol_))
        if self.failureToPay is not None:
            self.failureToPay.export(outfile, level, namespace_, name_='failureToPay', pretty_print=pretty_print)
        if self.failureToPayPrincipal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfailureToPayPrincipal>%s</%sfailureToPayPrincipal>%s' % (namespace_, self.gds_format_boolean(self.failureToPayPrincipal, input_name='failureToPayPrincipal'), namespace_, eol_))
        if self.failureToPayInterest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfailureToPayInterest>%s</%sfailureToPayInterest>%s' % (namespace_, self.gds_format_boolean(self.failureToPayInterest, input_name='failureToPayInterest'), namespace_, eol_))
        if self.obligationDefault is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sobligationDefault>%s</%sobligationDefault>%s' % (namespace_, self.gds_format_boolean(self.obligationDefault, input_name='obligationDefault'), namespace_, eol_))
        if self.obligationAcceleration is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sobligationAcceleration>%s</%sobligationAcceleration>%s' % (namespace_, self.gds_format_boolean(self.obligationAcceleration, input_name='obligationAcceleration'), namespace_, eol_))
        if self.repudiationMoratorium is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srepudiationMoratorium>%s</%srepudiationMoratorium>%s' % (namespace_, self.gds_format_boolean(self.repudiationMoratorium, input_name='repudiationMoratorium'), namespace_, eol_))
        if self.restructuring is not None:
            self.restructuring.export(outfile, level, namespace_, name_='restructuring', pretty_print=pretty_print)
        if self.governmentalIntervention is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgovernmentalIntervention>%s</%sgovernmentalIntervention>%s' % (namespace_, self.gds_format_boolean(self.governmentalIntervention, input_name='governmentalIntervention'), namespace_, eol_))
        if self.distressedRatingsDowngrade is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdistressedRatingsDowngrade>%s</%sdistressedRatingsDowngrade>%s' % (namespace_, self.gds_format_boolean(self.distressedRatingsDowngrade, input_name='distressedRatingsDowngrade'), namespace_, eol_))
        if self.maturityExtension is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaturityExtension>%s</%smaturityExtension>%s' % (namespace_, self.gds_format_boolean(self.maturityExtension, input_name='maturityExtension'), namespace_, eol_))
        if self.writedown is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%swritedown>%s</%swritedown>%s' % (namespace_, self.gds_format_boolean(self.writedown, input_name='writedown'), namespace_, eol_))
        if self.impliedWritedown is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%simpliedWritedown>%s</%simpliedWritedown>%s' % (namespace_, self.gds_format_boolean(self.impliedWritedown, input_name='impliedWritedown'), namespace_, eol_))
        if self.defaultRequirement is not None:
            self.defaultRequirement.export(outfile, level, namespace_, name_='defaultRequirement', pretty_print=pretty_print)
        if self.creditEventNotice is not None:
            self.creditEventNotice.export(outfile, level, namespace_, name_='creditEventNotice', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'bankruptcy':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'bankruptcy')
            self.bankruptcy = ival_
        elif nodeName_ == 'failureToPay':
            obj_ = FailureToPay.factory()
            obj_.build(child_)
            self.failureToPay = obj_
            obj_.original_tagname_ = 'failureToPay'
        elif nodeName_ == 'failureToPayPrincipal':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'failureToPayPrincipal')
            self.failureToPayPrincipal = ival_
        elif nodeName_ == 'failureToPayInterest':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'failureToPayInterest')
            self.failureToPayInterest = ival_
        elif nodeName_ == 'obligationDefault':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'obligationDefault')
            self.obligationDefault = ival_
        elif nodeName_ == 'obligationAcceleration':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'obligationAcceleration')
            self.obligationAcceleration = ival_
        elif nodeName_ == 'repudiationMoratorium':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'repudiationMoratorium')
            self.repudiationMoratorium = ival_
        elif nodeName_ == 'restructuring':
            obj_ = Restructuring.factory()
            obj_.build(child_)
            self.restructuring = obj_
            obj_.original_tagname_ = 'restructuring'
        elif nodeName_ == 'governmentalIntervention':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'governmentalIntervention')
            self.governmentalIntervention = ival_
        elif nodeName_ == 'distressedRatingsDowngrade':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'distressedRatingsDowngrade')
            self.distressedRatingsDowngrade = ival_
        elif nodeName_ == 'maturityExtension':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'maturityExtension')
            self.maturityExtension = ival_
        elif nodeName_ == 'writedown':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'writedown')
            self.writedown = ival_
        elif nodeName_ == 'impliedWritedown':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'impliedWritedown')
            self.impliedWritedown = ival_
        elif nodeName_ == 'defaultRequirement':
            obj_ = Money.factory()
            obj_.build(child_)
            self.defaultRequirement = obj_
            obj_.original_tagname_ = 'defaultRequirement'
        elif nodeName_ == 'creditEventNotice':
            obj_ = CreditEventNotice.factory()
            obj_.build(child_)
            self.creditEventNotice = obj_
            obj_.original_tagname_ = 'creditEventNotice'
# end class CreditEvents


class FailureToPay(GeneratedsSuper):
    member_data_items_ = {
        'applicable': MemberSpec_('applicable', 'xsd:boolean', 0),
        'gracePeriodExtension': MemberSpec_('gracePeriodExtension', 'GracePeriodExtension', 0),
        'paymentRequirement': MemberSpec_('paymentRequirement', 'Money', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, applicable=None, gracePeriodExtension=None, paymentRequirement=None):
        self.original_tagname_ = None
        self.applicable = applicable
        self.gracePeriodExtension = gracePeriodExtension
        self.paymentRequirement = paymentRequirement
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FailureToPay)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FailureToPay.subclass:
            return FailureToPay.subclass(*args_, **kwargs_)
        else:
            return FailureToPay(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_applicable(self): return self.applicable
    def set_applicable(self, applicable): self.applicable = applicable
    def get_gracePeriodExtension(self): return self.gracePeriodExtension
    def set_gracePeriodExtension(self, gracePeriodExtension): self.gracePeriodExtension = gracePeriodExtension
    def get_paymentRequirement(self): return self.paymentRequirement
    def set_paymentRequirement(self, paymentRequirement): self.paymentRequirement = paymentRequirement
    def hasContent_(self):
        if (
            self.applicable is not None or
            self.gracePeriodExtension is not None or
            self.paymentRequirement is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FailureToPay', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FailureToPay')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FailureToPay', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FailureToPay'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FailureToPay', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.applicable is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sapplicable>%s</%sapplicable>%s' % (namespace_, self.gds_format_boolean(self.applicable, input_name='applicable'), namespace_, eol_))
        if self.gracePeriodExtension is not None:
            self.gracePeriodExtension.export(outfile, level, namespace_, name_='gracePeriodExtension', pretty_print=pretty_print)
        if self.paymentRequirement is not None:
            self.paymentRequirement.export(outfile, level, namespace_, name_='paymentRequirement', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'applicable':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'applicable')
            self.applicable = ival_
        elif nodeName_ == 'gracePeriodExtension':
            obj_ = GracePeriodExtension.factory()
            obj_.build(child_)
            self.gracePeriodExtension = obj_
            obj_.original_tagname_ = 'gracePeriodExtension'
        elif nodeName_ == 'paymentRequirement':
            obj_ = Money.factory()
            obj_.build(child_)
            self.paymentRequirement = obj_
            obj_.original_tagname_ = 'paymentRequirement'
# end class FailureToPay


class FxFeature(GeneratedsSuper):
    """A type for defining Fx Features."""
    member_data_items_ = {
        'referenceCurrency': MemberSpec_('referenceCurrency', 'IdentifiedCurrency', 0),
        'composite': MemberSpec_('composite', 'Composite', 0),
        'quanto': MemberSpec_('quanto', 'Quanto', 0),
        'crossCurrency': MemberSpec_('crossCurrency', 'Composite', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, referenceCurrency=None, composite=None, quanto=None, crossCurrency=None):
        self.original_tagname_ = None
        self.referenceCurrency = referenceCurrency
        self.composite = composite
        self.quanto = quanto
        self.crossCurrency = crossCurrency
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FxFeature)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FxFeature.subclass:
            return FxFeature.subclass(*args_, **kwargs_)
        else:
            return FxFeature(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_referenceCurrency(self): return self.referenceCurrency
    def set_referenceCurrency(self, referenceCurrency): self.referenceCurrency = referenceCurrency
    def get_composite(self): return self.composite
    def set_composite(self, composite): self.composite = composite
    def get_quanto(self): return self.quanto
    def set_quanto(self, quanto): self.quanto = quanto
    def get_crossCurrency(self): return self.crossCurrency
    def set_crossCurrency(self, crossCurrency): self.crossCurrency = crossCurrency
    def hasContent_(self):
        if (
            self.referenceCurrency is not None or
            self.composite is not None or
            self.quanto is not None or
            self.crossCurrency is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FxFeature', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FxFeature')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FxFeature', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FxFeature'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FxFeature', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.referenceCurrency is not None:
            self.referenceCurrency.export(outfile, level, namespace_, name_='referenceCurrency', pretty_print=pretty_print)
        if self.composite is not None:
            self.composite.export(outfile, level, namespace_, name_='composite', pretty_print=pretty_print)
        if self.quanto is not None:
            self.quanto.export(outfile, level, namespace_, name_='quanto', pretty_print=pretty_print)
        if self.crossCurrency is not None:
            self.crossCurrency.export(outfile, level, namespace_, name_='crossCurrency', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'referenceCurrency':
            obj_ = IdentifiedCurrency.factory()
            obj_.build(child_)
            self.referenceCurrency = obj_
            obj_.original_tagname_ = 'referenceCurrency'
        elif nodeName_ == 'composite':
            obj_ = Composite.factory()
            obj_.build(child_)
            self.composite = obj_
            obj_.original_tagname_ = 'composite'
        elif nodeName_ == 'quanto':
            obj_ = Quanto.factory()
            obj_.build(child_)
            self.quanto = obj_
            obj_.original_tagname_ = 'quanto'
        elif nodeName_ == 'crossCurrency':
            obj_ = Composite.factory()
            obj_.build(child_)
            self.crossCurrency = obj_
            obj_.original_tagname_ = 'crossCurrency'
# end class FxFeature


class GracePeriodExtension(GeneratedsSuper):
    member_data_items_ = {
        'applicable': MemberSpec_('applicable', 'xsd:boolean', 0),
        'gracePeriod': MemberSpec_('gracePeriod', 'Offset', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, applicable=None, gracePeriod=None):
        self.original_tagname_ = None
        self.applicable = applicable
        self.gracePeriod = gracePeriod
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GracePeriodExtension)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GracePeriodExtension.subclass:
            return GracePeriodExtension.subclass(*args_, **kwargs_)
        else:
            return GracePeriodExtension(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_applicable(self): return self.applicable
    def set_applicable(self, applicable): self.applicable = applicable
    def get_gracePeriod(self): return self.gracePeriod
    def set_gracePeriod(self, gracePeriod): self.gracePeriod = gracePeriod
    def hasContent_(self):
        if (
            self.applicable is not None or
            self.gracePeriod is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GracePeriodExtension', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GracePeriodExtension')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GracePeriodExtension', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GracePeriodExtension'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GracePeriodExtension', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.applicable is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sapplicable>%s</%sapplicable>%s' % (namespace_, self.gds_format_boolean(self.applicable, input_name='applicable'), namespace_, eol_))
        if self.gracePeriod is not None:
            self.gracePeriod.export(outfile, level, namespace_, name_='gracePeriod', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'applicable':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'applicable')
            self.applicable = ival_
        elif nodeName_ == 'gracePeriod':
            class_obj_ = self.get_class_obj_(child_, Offset)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.gracePeriod = obj_
            obj_.original_tagname_ = 'gracePeriod'
# end class GracePeriodExtension


class Knock(GeneratedsSuper):
    """Knock In means option to exercise comes into existence. Knock Out
    means option to exercise goes out of existence."""
    member_data_items_ = {
        'knockIn': MemberSpec_('knockIn', 'TriggerEvent', 0),
        'knockOut': MemberSpec_('knockOut', 'TriggerEvent', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, knockIn=None, knockOut=None):
        self.original_tagname_ = None
        self.knockIn = knockIn
        self.knockOut = knockOut
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Knock)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Knock.subclass:
            return Knock.subclass(*args_, **kwargs_)
        else:
            return Knock(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_knockIn(self): return self.knockIn
    def set_knockIn(self, knockIn): self.knockIn = knockIn
    def get_knockOut(self): return self.knockOut
    def set_knockOut(self, knockOut): self.knockOut = knockOut
    def hasContent_(self):
        if (
            self.knockIn is not None or
            self.knockOut is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Knock', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Knock')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Knock', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Knock'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Knock', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.knockIn is not None:
            self.knockIn.export(outfile, level, namespace_, name_='knockIn', pretty_print=pretty_print)
        if self.knockOut is not None:
            self.knockOut.export(outfile, level, namespace_, name_='knockOut', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'knockIn':
            obj_ = TriggerEvent.factory()
            obj_.build(child_)
            self.knockIn = obj_
            obj_.original_tagname_ = 'knockIn'
        elif nodeName_ == 'knockOut':
            obj_ = TriggerEvent.factory()
            obj_.build(child_)
            self.knockOut = obj_
            obj_.original_tagname_ = 'knockOut'
# end class Knock


class MarketDisruption(GeneratedsSuper):
    """Defines the handling of an averaging date market disruption for an
    equity derivative transaction."""
    member_data_items_ = {
        'marketDisruptionScheme': MemberSpec_('marketDisruptionScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, marketDisruptionScheme='http://www.fpml.org/coding-scheme/market-disruption', valueOf_=None):
        self.original_tagname_ = None
        self.marketDisruptionScheme = _cast(None, marketDisruptionScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MarketDisruption)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MarketDisruption.subclass:
            return MarketDisruption.subclass(*args_, **kwargs_)
        else:
            return MarketDisruption(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_marketDisruptionScheme(self): return self.marketDisruptionScheme
    def set_marketDisruptionScheme(self, marketDisruptionScheme): self.marketDisruptionScheme = marketDisruptionScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MarketDisruption', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MarketDisruption')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MarketDisruption', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MarketDisruption'):
        if self.marketDisruptionScheme != "http://www.fpml.org/coding-scheme/market-disruption" and 'marketDisruptionScheme' not in already_processed:
            already_processed.add('marketDisruptionScheme')
            outfile.write(' marketDisruptionScheme=%s' % (quote_attrib(self.marketDisruptionScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MarketDisruption', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('marketDisruptionScheme', node)
        if value is not None and 'marketDisruptionScheme' not in already_processed:
            already_processed.add('marketDisruptionScheme')
            self.marketDisruptionScheme = value
            self.validate_NonEmptyURI(self.marketDisruptionScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MarketDisruption


class NotifyingParty(GeneratedsSuper):
    member_data_items_ = {
        'buyerPartyReference': MemberSpec_('buyerPartyReference', 'PartyReference', 0),
        'sellerPartyReference': MemberSpec_('sellerPartyReference', 'PartyReference', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, buyerPartyReference=None, sellerPartyReference=None):
        self.original_tagname_ = None
        self.buyerPartyReference = buyerPartyReference
        self.sellerPartyReference = sellerPartyReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NotifyingParty)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NotifyingParty.subclass:
            return NotifyingParty.subclass(*args_, **kwargs_)
        else:
            return NotifyingParty(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_buyerPartyReference(self): return self.buyerPartyReference
    def set_buyerPartyReference(self, buyerPartyReference): self.buyerPartyReference = buyerPartyReference
    def get_sellerPartyReference(self): return self.sellerPartyReference
    def set_sellerPartyReference(self, sellerPartyReference): self.sellerPartyReference = sellerPartyReference
    def hasContent_(self):
        if (
            self.buyerPartyReference is not None or
            self.sellerPartyReference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NotifyingParty', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NotifyingParty')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NotifyingParty', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NotifyingParty'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NotifyingParty', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.buyerPartyReference is not None:
            self.buyerPartyReference.export(outfile, level, namespace_, name_='buyerPartyReference', pretty_print=pretty_print)
        if self.sellerPartyReference is not None:
            self.sellerPartyReference.export(outfile, level, namespace_, name_='sellerPartyReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'buyerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.buyerPartyReference = obj_
            obj_.original_tagname_ = 'buyerPartyReference'
        elif nodeName_ == 'sellerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.sellerPartyReference = obj_
            obj_.original_tagname_ = 'sellerPartyReference'
# end class NotifyingParty


class OptionFeature(GeneratedsSuper):
    """A type for defining option features."""
    member_data_items_ = {
        'fxFeature': MemberSpec_('fxFeature', 'FxFeature', 0),
        'strategyFeature': MemberSpec_('strategyFeature', 'StrategyFeature', 0),
        'asian': MemberSpec_('asian', 'Asian', 0),
        'barrier': MemberSpec_('barrier', 'Barrier', 0),
        'knock': MemberSpec_('knock', 'Knock', 0),
        'passThrough': MemberSpec_('passThrough', 'PassThrough', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, fxFeature=None, strategyFeature=None, asian=None, barrier=None, knock=None, passThrough=None):
        self.original_tagname_ = None
        self.fxFeature = fxFeature
        self.strategyFeature = strategyFeature
        self.asian = asian
        self.barrier = barrier
        self.knock = knock
        self.passThrough = passThrough
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OptionFeature)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OptionFeature.subclass:
            return OptionFeature.subclass(*args_, **kwargs_)
        else:
            return OptionFeature(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fxFeature(self): return self.fxFeature
    def set_fxFeature(self, fxFeature): self.fxFeature = fxFeature
    def get_strategyFeature(self): return self.strategyFeature
    def set_strategyFeature(self, strategyFeature): self.strategyFeature = strategyFeature
    def get_asian(self): return self.asian
    def set_asian(self, asian): self.asian = asian
    def get_barrier(self): return self.barrier
    def set_barrier(self, barrier): self.barrier = barrier
    def get_knock(self): return self.knock
    def set_knock(self, knock): self.knock = knock
    def get_passThrough(self): return self.passThrough
    def set_passThrough(self, passThrough): self.passThrough = passThrough
    def hasContent_(self):
        if (
            self.fxFeature is not None or
            self.strategyFeature is not None or
            self.asian is not None or
            self.barrier is not None or
            self.knock is not None or
            self.passThrough is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OptionFeature', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OptionFeature')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OptionFeature', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OptionFeature'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OptionFeature', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.fxFeature is not None:
            self.fxFeature.export(outfile, level, namespace_, name_='fxFeature', pretty_print=pretty_print)
        if self.strategyFeature is not None:
            self.strategyFeature.export(outfile, level, namespace_, name_='strategyFeature', pretty_print=pretty_print)
        if self.asian is not None:
            self.asian.export(outfile, level, namespace_, name_='asian', pretty_print=pretty_print)
        if self.barrier is not None:
            self.barrier.export(outfile, level, namespace_, name_='barrier', pretty_print=pretty_print)
        if self.knock is not None:
            self.knock.export(outfile, level, namespace_, name_='knock', pretty_print=pretty_print)
        if self.passThrough is not None:
            self.passThrough.export(outfile, level, namespace_, name_='passThrough', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fxFeature':
            obj_ = FxFeature.factory()
            obj_.build(child_)
            self.fxFeature = obj_
            obj_.original_tagname_ = 'fxFeature'
        elif nodeName_ == 'strategyFeature':
            obj_ = StrategyFeature.factory()
            obj_.build(child_)
            self.strategyFeature = obj_
            obj_.original_tagname_ = 'strategyFeature'
        elif nodeName_ == 'asian':
            obj_ = Asian.factory()
            obj_.build(child_)
            self.asian = obj_
            obj_.original_tagname_ = 'asian'
        elif nodeName_ == 'barrier':
            obj_ = Barrier.factory()
            obj_.build(child_)
            self.barrier = obj_
            obj_.original_tagname_ = 'barrier'
        elif nodeName_ == 'knock':
            obj_ = Knock.factory()
            obj_.build(child_)
            self.knock = obj_
            obj_.original_tagname_ = 'knock'
        elif nodeName_ == 'passThrough':
            obj_ = PassThrough.factory()
            obj_.build(child_)
            self.passThrough = obj_
            obj_.original_tagname_ = 'passThrough'
# end class OptionFeature


class OptionNumericStrike(GeneratedsSuper):
    """A type for defining the strike price for an option as a numeric
    value without currency."""
    member_data_items_ = {
        'strikePrice': MemberSpec_('strikePrice', 'xsd:decimal', 0),
        'strikePercentage': MemberSpec_('strikePercentage', 'xsd:decimal', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, strikePrice=None, strikePercentage=None, extensiontype_=None):
        self.original_tagname_ = None
        self.strikePrice = strikePrice
        self.strikePercentage = strikePercentage
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OptionNumericStrike)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OptionNumericStrike.subclass:
            return OptionNumericStrike.subclass(*args_, **kwargs_)
        else:
            return OptionNumericStrike(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_strikePrice(self): return self.strikePrice
    def set_strikePrice(self, strikePrice): self.strikePrice = strikePrice
    def get_strikePercentage(self): return self.strikePercentage
    def set_strikePercentage(self, strikePercentage): self.strikePercentage = strikePercentage
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.strikePrice is not None or
            self.strikePercentage is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OptionNumericStrike', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OptionNumericStrike')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OptionNumericStrike', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OptionNumericStrike'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OptionNumericStrike', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.strikePrice is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstrikePrice>%s</%sstrikePrice>%s' % (namespace_, self.gds_format_float(self.strikePrice, input_name='strikePrice'), namespace_, eol_))
        if self.strikePercentage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstrikePercentage>%s</%sstrikePercentage>%s' % (namespace_, self.gds_format_float(self.strikePercentage, input_name='strikePercentage'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'strikePrice':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'strikePrice')
            self.strikePrice = fval_
        elif nodeName_ == 'strikePercentage':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'strikePercentage')
            self.strikePercentage = fval_
# end class OptionNumericStrike


class OptionStrike(OptionNumericStrike):
    """A type for defining the strike price for an equity option. The
    strike price is either: (i) in respect of an index option
    transaction, the level of the relevant index specified or
    otherwise determined in the transaction; or (ii) in respect of a
    share option transaction, the price per share specified or
    otherwise determined in the transaction. This can be expressed
    either as a percentage of notional amount or as an absolute
    value."""
    member_data_items_ = {
        'currency': MemberSpec_('currency', 'Currency', 0),
    }
    subclass = None
    superclass = OptionNumericStrike
    def __init__(self, strikePrice=None, strikePercentage=None, currency=None):
        self.original_tagname_ = None
        super(OptionStrike, self).__init__(strikePrice, strikePercentage, )
        self.currency = currency
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OptionStrike)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OptionStrike.subclass:
            return OptionStrike.subclass(*args_, **kwargs_)
        else:
            return OptionStrike(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def hasContent_(self):
        if (
            self.currency is not None or
            super(OptionStrike, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OptionStrike', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OptionStrike')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OptionStrike', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OptionStrike'):
        super(OptionStrike, self).exportAttributes(outfile, level, already_processed, namespace_, name_='OptionStrike')
    def exportChildren(self, outfile, level, namespace_='', name_='OptionStrike', fromsubclass_=False, pretty_print=True):
        super(OptionStrike, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.currency is not None:
            self.currency.export(outfile, level, namespace_, name_='currency', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(OptionStrike, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'currency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        super(OptionStrike, self).buildChildren(child_, node, nodeName_, True)
# end class OptionStrike


class PassThrough(GeneratedsSuper):
    """Type which contains pass through payments."""
    member_data_items_ = {
        'passThroughItem': MemberSpec_('passThroughItem', 'PassThroughItem', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, passThroughItem=None):
        self.original_tagname_ = None
        if passThroughItem is None:
            self.passThroughItem = []
        else:
            self.passThroughItem = passThroughItem
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PassThrough)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PassThrough.subclass:
            return PassThrough.subclass(*args_, **kwargs_)
        else:
            return PassThrough(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_passThroughItem(self): return self.passThroughItem
    def set_passThroughItem(self, passThroughItem): self.passThroughItem = passThroughItem
    def add_passThroughItem(self, value): self.passThroughItem.append(value)
    def insert_passThroughItem_at(self, index, value): self.passThroughItem.insert(index, value)
    def replace_passThroughItem_at(self, index, value): self.passThroughItem[index] = value
    def hasContent_(self):
        if (
            self.passThroughItem
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PassThrough', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PassThrough')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PassThrough', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PassThrough'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PassThrough', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for passThroughItem_ in self.passThroughItem:
            passThroughItem_.export(outfile, level, namespace_, name_='passThroughItem', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'passThroughItem':
            obj_ = PassThroughItem.factory()
            obj_.build(child_)
            self.passThroughItem.append(obj_)
            obj_.original_tagname_ = 'passThroughItem'
# end class PassThrough


class PassThroughItem(GeneratedsSuper):
    """Type to represent a single pass through payment."""
    member_data_items_ = {
        'payerPartyReference': MemberSpec_('payerPartyReference', 'PartyReference', 0),
        'payerAccountReference': MemberSpec_('payerAccountReference', 'AccountReference', 0),
        'receiverPartyReference': MemberSpec_('receiverPartyReference', 'PartyReference', 0),
        'receiverAccountReference': MemberSpec_('receiverAccountReference', 'AccountReference', 0),
        'underlyerReference': MemberSpec_('underlyerReference', 'AssetReference', 0),
        'passThroughPercentage': MemberSpec_('passThroughPercentage', 'xsd:decimal', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, underlyerReference=None, passThroughPercentage=None):
        self.original_tagname_ = None
        self.payerPartyReference = payerPartyReference
        self.payerAccountReference = payerAccountReference
        self.receiverPartyReference = receiverPartyReference
        self.receiverAccountReference = receiverAccountReference
        self.underlyerReference = underlyerReference
        self.passThroughPercentage = passThroughPercentage
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PassThroughItem)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PassThroughItem.subclass:
            return PassThroughItem.subclass(*args_, **kwargs_)
        else:
            return PassThroughItem(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_payerPartyReference(self): return self.payerPartyReference
    def set_payerPartyReference(self, payerPartyReference): self.payerPartyReference = payerPartyReference
    def get_payerAccountReference(self): return self.payerAccountReference
    def set_payerAccountReference(self, payerAccountReference): self.payerAccountReference = payerAccountReference
    def get_receiverPartyReference(self): return self.receiverPartyReference
    def set_receiverPartyReference(self, receiverPartyReference): self.receiverPartyReference = receiverPartyReference
    def get_receiverAccountReference(self): return self.receiverAccountReference
    def set_receiverAccountReference(self, receiverAccountReference): self.receiverAccountReference = receiverAccountReference
    def get_underlyerReference(self): return self.underlyerReference
    def set_underlyerReference(self, underlyerReference): self.underlyerReference = underlyerReference
    def get_passThroughPercentage(self): return self.passThroughPercentage
    def set_passThroughPercentage(self, passThroughPercentage): self.passThroughPercentage = passThroughPercentage
    def hasContent_(self):
        if (
            self.payerPartyReference is not None or
            self.payerAccountReference is not None or
            self.receiverPartyReference is not None or
            self.receiverAccountReference is not None or
            self.underlyerReference is not None or
            self.passThroughPercentage is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PassThroughItem', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PassThroughItem')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PassThroughItem', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PassThroughItem'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PassThroughItem', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.payerPartyReference is not None:
            self.payerPartyReference.export(outfile, level, namespace_, name_='payerPartyReference', pretty_print=pretty_print)
        if self.payerAccountReference is not None:
            self.payerAccountReference.export(outfile, level, namespace_, name_='payerAccountReference', pretty_print=pretty_print)
        if self.receiverPartyReference is not None:
            self.receiverPartyReference.export(outfile, level, namespace_, name_='receiverPartyReference', pretty_print=pretty_print)
        if self.receiverAccountReference is not None:
            self.receiverAccountReference.export(outfile, level, namespace_, name_='receiverAccountReference', pretty_print=pretty_print)
        if self.underlyerReference is not None:
            self.underlyerReference.export(outfile, level, namespace_, name_='underlyerReference', pretty_print=pretty_print)
        if self.passThroughPercentage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spassThroughPercentage>%s</%spassThroughPercentage>%s' % (namespace_, self.gds_format_float(self.passThroughPercentage, input_name='passThroughPercentage'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'payerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.payerPartyReference = obj_
            obj_.original_tagname_ = 'payerPartyReference'
        elif nodeName_ == 'payerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.payerAccountReference = obj_
            obj_.original_tagname_ = 'payerAccountReference'
        elif nodeName_ == 'receiverPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.receiverPartyReference = obj_
            obj_.original_tagname_ = 'receiverPartyReference'
        elif nodeName_ == 'receiverAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.receiverAccountReference = obj_
            obj_.original_tagname_ = 'receiverAccountReference'
        elif nodeName_ == 'underlyerReference':
            obj_ = AssetReference.factory()
            obj_.build(child_)
            self.underlyerReference = obj_
            obj_.original_tagname_ = 'underlyerReference'
        elif nodeName_ == 'passThroughPercentage':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'passThroughPercentage')
            self.passThroughPercentage = fval_
# end class PassThroughItem


class PubliclyAvailableInformation(GeneratedsSuper):
    member_data_items_ = {
        'standardPublicSources': MemberSpec_('standardPublicSources', 'xsd:boolean', 0),
        'publicSource': MemberSpec_('publicSource', ['String', 'xsd:string'], 1),
        'specifiedNumber': MemberSpec_('specifiedNumber', 'xsd:positiveInteger', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, standardPublicSources=None, publicSource=None, specifiedNumber=None):
        self.original_tagname_ = None
        self.standardPublicSources = standardPublicSources
        if publicSource is None:
            self.publicSource = []
        else:
            self.publicSource = publicSource
        self.specifiedNumber = specifiedNumber
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PubliclyAvailableInformation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PubliclyAvailableInformation.subclass:
            return PubliclyAvailableInformation.subclass(*args_, **kwargs_)
        else:
            return PubliclyAvailableInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_standardPublicSources(self): return self.standardPublicSources
    def set_standardPublicSources(self, standardPublicSources): self.standardPublicSources = standardPublicSources
    def get_publicSource(self): return self.publicSource
    def set_publicSource(self, publicSource): self.publicSource = publicSource
    def add_publicSource(self, value): self.publicSource.append(value)
    def insert_publicSource_at(self, index, value): self.publicSource.insert(index, value)
    def replace_publicSource_at(self, index, value): self.publicSource[index] = value
    def get_specifiedNumber(self): return self.specifiedNumber
    def set_specifiedNumber(self, specifiedNumber): self.specifiedNumber = specifiedNumber
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.standardPublicSources is not None or
            self.publicSource or
            self.specifiedNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PubliclyAvailableInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PubliclyAvailableInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PubliclyAvailableInformation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PubliclyAvailableInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PubliclyAvailableInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.standardPublicSources is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstandardPublicSources>%s</%sstandardPublicSources>%s' % (namespace_, self.gds_format_boolean(self.standardPublicSources, input_name='standardPublicSources'), namespace_, eol_))
        for publicSource_ in self.publicSource:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spublicSource>%s</%spublicSource>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(publicSource_), input_name='publicSource')), namespace_, eol_))
        if self.specifiedNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sspecifiedNumber>%s</%sspecifiedNumber>%s' % (namespace_, self.gds_format_integer(self.specifiedNumber, input_name='specifiedNumber'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'standardPublicSources':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'standardPublicSources')
            self.standardPublicSources = ival_
        elif nodeName_ == 'publicSource':
            publicSource_ = child_.text
            publicSource_ = self.gds_validate_string(publicSource_, node, 'publicSource')
            self.publicSource.append(publicSource_)
            # validate type String
            self.validate_String(self.publicSource[-1])
        elif nodeName_ == 'specifiedNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'specifiedNumber')
            self.specifiedNumber = ival_
# end class PubliclyAvailableInformation


class Quanto(GeneratedsSuper):
    """Determines the currency rate that the seller of the equity amounts
    will apply at each valuation date for converting the respective
    amounts into a currency that is different from the currency
    denomination of the underlyer."""
    member_data_items_ = {
        'fxRate': MemberSpec_('fxRate', 'FxRate', 1),
        'fxSpotRateSource': MemberSpec_('fxSpotRateSource', 'FxSpotRateSource', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, fxRate=None, fxSpotRateSource=None):
        self.original_tagname_ = None
        if fxRate is None:
            self.fxRate = []
        else:
            self.fxRate = fxRate
        self.fxSpotRateSource = fxSpotRateSource
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Quanto)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Quanto.subclass:
            return Quanto.subclass(*args_, **kwargs_)
        else:
            return Quanto(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fxRate(self): return self.fxRate
    def set_fxRate(self, fxRate): self.fxRate = fxRate
    def add_fxRate(self, value): self.fxRate.append(value)
    def insert_fxRate_at(self, index, value): self.fxRate.insert(index, value)
    def replace_fxRate_at(self, index, value): self.fxRate[index] = value
    def get_fxSpotRateSource(self): return self.fxSpotRateSource
    def set_fxSpotRateSource(self, fxSpotRateSource): self.fxSpotRateSource = fxSpotRateSource
    def hasContent_(self):
        if (
            self.fxRate or
            self.fxSpotRateSource is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Quanto', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Quanto')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Quanto', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Quanto'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Quanto', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for fxRate_ in self.fxRate:
            fxRate_.export(outfile, level, namespace_, name_='fxRate', pretty_print=pretty_print)
        if self.fxSpotRateSource is not None:
            self.fxSpotRateSource.export(outfile, level, namespace_, name_='fxSpotRateSource', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fxRate':
            obj_ = FxRate.factory()
            obj_.build(child_)
            self.fxRate.append(obj_)
            obj_.original_tagname_ = 'fxRate'
        elif nodeName_ == 'fxSpotRateSource':
            obj_ = FxSpotRateSource.factory()
            obj_.build(child_)
            self.fxSpotRateSource = obj_
            obj_.original_tagname_ = 'fxSpotRateSource'
# end class Quanto


class Restructuring(GeneratedsSuper):
    member_data_items_ = {
        'applicable': MemberSpec_('applicable', 'xsd:boolean', 0),
        'restructuringType': MemberSpec_('restructuringType', 'RestructuringType', 0),
        'multipleHolderObligation': MemberSpec_('multipleHolderObligation', 'xsd:boolean', 0),
        'multipleCreditEventNotices': MemberSpec_('multipleCreditEventNotices', 'xsd:boolean', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, applicable=None, restructuringType=None, multipleHolderObligation=None, multipleCreditEventNotices=None):
        self.original_tagname_ = None
        self.applicable = applicable
        self.restructuringType = restructuringType
        self.multipleHolderObligation = multipleHolderObligation
        self.multipleCreditEventNotices = multipleCreditEventNotices
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Restructuring)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Restructuring.subclass:
            return Restructuring.subclass(*args_, **kwargs_)
        else:
            return Restructuring(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_applicable(self): return self.applicable
    def set_applicable(self, applicable): self.applicable = applicable
    def get_restructuringType(self): return self.restructuringType
    def set_restructuringType(self, restructuringType): self.restructuringType = restructuringType
    def get_multipleHolderObligation(self): return self.multipleHolderObligation
    def set_multipleHolderObligation(self, multipleHolderObligation): self.multipleHolderObligation = multipleHolderObligation
    def get_multipleCreditEventNotices(self): return self.multipleCreditEventNotices
    def set_multipleCreditEventNotices(self, multipleCreditEventNotices): self.multipleCreditEventNotices = multipleCreditEventNotices
    def hasContent_(self):
        if (
            self.applicable is not None or
            self.restructuringType is not None or
            self.multipleHolderObligation is not None or
            self.multipleCreditEventNotices is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Restructuring', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Restructuring')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Restructuring', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Restructuring'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Restructuring', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.applicable is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sapplicable>%s</%sapplicable>%s' % (namespace_, self.gds_format_boolean(self.applicable, input_name='applicable'), namespace_, eol_))
        if self.restructuringType is not None:
            self.restructuringType.export(outfile, level, namespace_, name_='restructuringType', pretty_print=pretty_print)
        if self.multipleHolderObligation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smultipleHolderObligation>%s</%smultipleHolderObligation>%s' % (namespace_, self.gds_format_boolean(self.multipleHolderObligation, input_name='multipleHolderObligation'), namespace_, eol_))
        if self.multipleCreditEventNotices is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smultipleCreditEventNotices>%s</%smultipleCreditEventNotices>%s' % (namespace_, self.gds_format_boolean(self.multipleCreditEventNotices, input_name='multipleCreditEventNotices'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'applicable':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'applicable')
            self.applicable = ival_
        elif nodeName_ == 'restructuringType':
            obj_ = RestructuringType.factory()
            obj_.build(child_)
            self.restructuringType = obj_
            obj_.original_tagname_ = 'restructuringType'
        elif nodeName_ == 'multipleHolderObligation':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'multipleHolderObligation')
            self.multipleHolderObligation = ival_
        elif nodeName_ == 'multipleCreditEventNotices':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'multipleCreditEventNotices')
            self.multipleCreditEventNotices = ival_
# end class Restructuring


class RestructuringType(GeneratedsSuper):
    member_data_items_ = {
        'restructuringScheme': MemberSpec_('restructuringScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, restructuringScheme='http://www.fpml.org/coding-scheme/restructuring', valueOf_=None):
        self.original_tagname_ = None
        self.restructuringScheme = _cast(None, restructuringScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RestructuringType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RestructuringType.subclass:
            return RestructuringType.subclass(*args_, **kwargs_)
        else:
            return RestructuringType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_restructuringScheme(self): return self.restructuringScheme
    def set_restructuringScheme(self, restructuringScheme): self.restructuringScheme = restructuringScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RestructuringType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RestructuringType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RestructuringType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RestructuringType'):
        if self.restructuringScheme != "http://www.fpml.org/coding-scheme/restructuring" and 'restructuringScheme' not in already_processed:
            already_processed.add('restructuringScheme')
            outfile.write(' restructuringScheme=%s' % (quote_attrib(self.restructuringScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RestructuringType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('restructuringScheme', node)
        if value is not None and 'restructuringScheme' not in already_processed:
            already_processed.add('restructuringScheme')
            self.restructuringScheme = value
            self.validate_NonEmptyURI(self.restructuringScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RestructuringType


class SettlementTerms(GeneratedsSuper):
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'settlementCurrency': MemberSpec_('settlementCurrency', 'Currency', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, settlementCurrency=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.settlementCurrency = settlementCurrency
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SettlementTerms)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SettlementTerms.subclass:
            return SettlementTerms.subclass(*args_, **kwargs_)
        else:
            return SettlementTerms(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_settlementCurrency(self): return self.settlementCurrency
    def set_settlementCurrency(self, settlementCurrency): self.settlementCurrency = settlementCurrency
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.settlementCurrency is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SettlementTerms', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SettlementTerms')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SettlementTerms', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SettlementTerms'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SettlementTerms', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.settlementCurrency is not None:
            self.settlementCurrency.export(outfile, level, namespace_, name_='settlementCurrency', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'settlementCurrency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.settlementCurrency = obj_
            obj_.original_tagname_ = 'settlementCurrency'
# end class SettlementTerms


class StrategyFeature(GeneratedsSuper):
    """A type for definining equity option simple strike or calendar spread
    strategy features."""
    member_data_items_ = {
        'strikeSpread': MemberSpec_('strikeSpread', 'StrikeSpread', 0),
        'calendarSpread': MemberSpec_('calendarSpread', 'CalendarSpread', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, strikeSpread=None, calendarSpread=None):
        self.original_tagname_ = None
        self.strikeSpread = strikeSpread
        self.calendarSpread = calendarSpread
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrategyFeature)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrategyFeature.subclass:
            return StrategyFeature.subclass(*args_, **kwargs_)
        else:
            return StrategyFeature(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_strikeSpread(self): return self.strikeSpread
    def set_strikeSpread(self, strikeSpread): self.strikeSpread = strikeSpread
    def get_calendarSpread(self): return self.calendarSpread
    def set_calendarSpread(self, calendarSpread): self.calendarSpread = calendarSpread
    def hasContent_(self):
        if (
            self.strikeSpread is not None or
            self.calendarSpread is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StrategyFeature', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StrategyFeature')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StrategyFeature', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StrategyFeature'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StrategyFeature', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.strikeSpread is not None:
            self.strikeSpread.export(outfile, level, namespace_, name_='strikeSpread', pretty_print=pretty_print)
        if self.calendarSpread is not None:
            self.calendarSpread.export(outfile, level, namespace_, name_='calendarSpread', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'strikeSpread':
            obj_ = StrikeSpread.factory()
            obj_.build(child_)
            self.strikeSpread = obj_
            obj_.original_tagname_ = 'strikeSpread'
        elif nodeName_ == 'calendarSpread':
            obj_ = CalendarSpread.factory()
            obj_.build(child_)
            self.calendarSpread = obj_
            obj_.original_tagname_ = 'calendarSpread'
# end class StrategyFeature


class StrikeSpread(GeneratedsSuper):
    """A type for defining a strike spread feature."""
    member_data_items_ = {
        'upperStrike': MemberSpec_('upperStrike', 'OptionStrike', 0),
        'upperStrikeNumberOfOptions': MemberSpec_('upperStrikeNumberOfOptions', ['PositiveDecimal', 'xsd:decimal'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, upperStrike=None, upperStrikeNumberOfOptions=None):
        self.original_tagname_ = None
        self.upperStrike = upperStrike
        self.upperStrikeNumberOfOptions = upperStrikeNumberOfOptions
        self.validate_PositiveDecimal(self.upperStrikeNumberOfOptions)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrikeSpread)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrikeSpread.subclass:
            return StrikeSpread.subclass(*args_, **kwargs_)
        else:
            return StrikeSpread(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_upperStrike(self): return self.upperStrike
    def set_upperStrike(self, upperStrike): self.upperStrike = upperStrike
    def get_upperStrikeNumberOfOptions(self): return self.upperStrikeNumberOfOptions
    def set_upperStrikeNumberOfOptions(self, upperStrikeNumberOfOptions): self.upperStrikeNumberOfOptions = upperStrikeNumberOfOptions
    def validate_PositiveDecimal(self, value):
        # Validate type PositiveDecimal, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value <= 0:
                warnings_.warn('Value "%(value)s" does not match xsd minExclusive restriction on PositiveDecimal' % {"value" : value} )
    def hasContent_(self):
        if (
            self.upperStrike is not None or
            self.upperStrikeNumberOfOptions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StrikeSpread', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StrikeSpread')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StrikeSpread', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StrikeSpread'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StrikeSpread', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.upperStrike is not None:
            self.upperStrike.export(outfile, level, namespace_, name_='upperStrike', pretty_print=pretty_print)
        if self.upperStrikeNumberOfOptions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%supperStrikeNumberOfOptions>%s</%supperStrikeNumberOfOptions>%s' % (namespace_, self.gds_format_float(self.upperStrikeNumberOfOptions, input_name='upperStrikeNumberOfOptions'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'upperStrike':
            obj_ = OptionStrike.factory()
            obj_.build(child_)
            self.upperStrike = obj_
            obj_.original_tagname_ = 'upperStrike'
        elif nodeName_ == 'upperStrikeNumberOfOptions':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'upperStrikeNumberOfOptions')
            self.upperStrikeNumberOfOptions = fval_
            # validate type PositiveDecimal
            self.validate_PositiveDecimal(self.upperStrikeNumberOfOptions)
# end class StrikeSpread


class Trigger(GeneratedsSuper):
    """Trigger point at which feature is effective.Choice between either an
    explicit representation of Credit Events, or Credit Events
    defined elsewhere in the document."""
    member_data_items_ = {
        'level': MemberSpec_('level', 'xsd:decimal', 0),
        'levelPercentage': MemberSpec_('levelPercentage', 'xsd:decimal', 0),
        'creditEvents': MemberSpec_('creditEvents', 'CreditEvents', 0),
        'creditEventsReference': MemberSpec_('creditEventsReference', 'CreditEventsReference', 0),
        'triggerType': MemberSpec_('triggerType', ['TriggerTypeEnum', 'Token', 'xsd:token'], 0),
        'triggerTimeType': MemberSpec_('triggerTimeType', ['TriggerTimeTypeEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, level=None, levelPercentage=None, creditEvents=None, creditEventsReference=None, triggerType=None, triggerTimeType=None):
        self.original_tagname_ = None
        self.level = level
        self.levelPercentage = levelPercentage
        self.creditEvents = creditEvents
        self.creditEventsReference = creditEventsReference
        self.triggerType = triggerType
        self.validate_TriggerTypeEnum(self.triggerType)
        self.triggerTimeType = triggerTimeType
        self.validate_TriggerTimeTypeEnum(self.triggerTimeType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Trigger)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Trigger.subclass:
            return Trigger.subclass(*args_, **kwargs_)
        else:
            return Trigger(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_level(self): return self.level
    def set_level(self, level): self.level = level
    def get_levelPercentage(self): return self.levelPercentage
    def set_levelPercentage(self, levelPercentage): self.levelPercentage = levelPercentage
    def get_creditEvents(self): return self.creditEvents
    def set_creditEvents(self, creditEvents): self.creditEvents = creditEvents
    def get_creditEventsReference(self): return self.creditEventsReference
    def set_creditEventsReference(self, creditEventsReference): self.creditEventsReference = creditEventsReference
    def get_triggerType(self): return self.triggerType
    def set_triggerType(self, triggerType): self.triggerType = triggerType
    def get_triggerTimeType(self): return self.triggerTimeType
    def set_triggerTimeType(self, triggerTimeType): self.triggerTimeType = triggerTimeType
    def validate_TriggerTypeEnum(self, value):
        # Validate type TriggerTypeEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['EqualOrLess', 'EqualOrGreater', 'Equal', 'Less', 'Greater']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TriggerTypeEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on TriggerTypeEnum' % {"value" : value} )
    def validate_TriggerTimeTypeEnum(self, value):
        # Validate type TriggerTimeTypeEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Closing', 'Anytime']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TriggerTimeTypeEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on TriggerTimeTypeEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.level is not None or
            self.levelPercentage is not None or
            self.creditEvents is not None or
            self.creditEventsReference is not None or
            self.triggerType is not None or
            self.triggerTimeType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Trigger', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Trigger')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Trigger', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Trigger'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Trigger', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.level is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slevel>%s</%slevel>%s' % (namespace_, self.gds_format_float(self.level, input_name='level'), namespace_, eol_))
        if self.levelPercentage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slevelPercentage>%s</%slevelPercentage>%s' % (namespace_, self.gds_format_float(self.levelPercentage, input_name='levelPercentage'), namespace_, eol_))
        if self.creditEvents is not None:
            self.creditEvents.export(outfile, level, namespace_, name_='creditEvents', pretty_print=pretty_print)
        if self.creditEventsReference is not None:
            self.creditEventsReference.export(outfile, level, namespace_, name_='creditEventsReference', pretty_print=pretty_print)
        if self.triggerType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%striggerType>%s</%striggerType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.triggerType), input_name='triggerType')), namespace_, eol_))
        if self.triggerTimeType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%striggerTimeType>%s</%striggerTimeType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.triggerTimeType), input_name='triggerTimeType')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'level':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'level')
            self.level = fval_
        elif nodeName_ == 'levelPercentage':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'levelPercentage')
            self.levelPercentage = fval_
        elif nodeName_ == 'creditEvents':
            obj_ = CreditEvents.factory()
            obj_.build(child_)
            self.creditEvents = obj_
            obj_.original_tagname_ = 'creditEvents'
        elif nodeName_ == 'creditEventsReference':
            obj_ = CreditEventsReference.factory()
            obj_.build(child_)
            self.creditEventsReference = obj_
            obj_.original_tagname_ = 'creditEventsReference'
        elif nodeName_ == 'triggerType':
            triggerType_ = child_.text
            triggerType_ = re_.sub(String_cleanup_pat_, " ", triggerType_).strip()
            triggerType_ = self.gds_validate_string(triggerType_, node, 'triggerType')
            self.triggerType = triggerType_
            # validate type TriggerTypeEnum
            self.validate_TriggerTypeEnum(self.triggerType)
        elif nodeName_ == 'triggerTimeType':
            triggerTimeType_ = child_.text
            triggerTimeType_ = re_.sub(String_cleanup_pat_, " ", triggerTimeType_).strip()
            triggerTimeType_ = self.gds_validate_string(triggerTimeType_, node, 'triggerTimeType')
            self.triggerTimeType = triggerTimeType_
            # validate type TriggerTimeTypeEnum
            self.validate_TriggerTimeTypeEnum(self.triggerTimeType)
# end class Trigger


class TriggerEvent(GeneratedsSuper):
    """Observation point for trigger."""
    member_data_items_ = {
        'schedule': MemberSpec_('schedule', 'AveragingSchedule', 1),
        'triggerDates': MemberSpec_('triggerDates', 'DateList', 0),
        'trigger': MemberSpec_('trigger', 'Trigger', 0),
        'featurePayment': MemberSpec_('featurePayment', 'FeaturePayment', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, schedule=None, triggerDates=None, trigger=None, featurePayment=None):
        self.original_tagname_ = None
        if schedule is None:
            self.schedule = []
        else:
            self.schedule = schedule
        self.triggerDates = triggerDates
        self.trigger = trigger
        self.featurePayment = featurePayment
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TriggerEvent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TriggerEvent.subclass:
            return TriggerEvent.subclass(*args_, **kwargs_)
        else:
            return TriggerEvent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_schedule(self): return self.schedule
    def set_schedule(self, schedule): self.schedule = schedule
    def add_schedule(self, value): self.schedule.append(value)
    def insert_schedule_at(self, index, value): self.schedule.insert(index, value)
    def replace_schedule_at(self, index, value): self.schedule[index] = value
    def get_triggerDates(self): return self.triggerDates
    def set_triggerDates(self, triggerDates): self.triggerDates = triggerDates
    def get_trigger(self): return self.trigger
    def set_trigger(self, trigger): self.trigger = trigger
    def get_featurePayment(self): return self.featurePayment
    def set_featurePayment(self, featurePayment): self.featurePayment = featurePayment
    def hasContent_(self):
        if (
            self.schedule or
            self.triggerDates is not None or
            self.trigger is not None or
            self.featurePayment is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TriggerEvent', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TriggerEvent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TriggerEvent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TriggerEvent'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TriggerEvent', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for schedule_ in self.schedule:
            schedule_.export(outfile, level, namespace_, name_='schedule', pretty_print=pretty_print)
        if self.triggerDates is not None:
            self.triggerDates.export(outfile, level, namespace_, name_='triggerDates', pretty_print=pretty_print)
        if self.trigger is not None:
            self.trigger.export(outfile, level, namespace_, name_='trigger', pretty_print=pretty_print)
        if self.featurePayment is not None:
            self.featurePayment.export(outfile, level, namespace_, name_='featurePayment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'schedule':
            obj_ = AveragingSchedule.factory()
            obj_.build(child_)
            self.schedule.append(obj_)
            obj_.original_tagname_ = 'schedule'
        elif nodeName_ == 'triggerDates':
            obj_ = DateList.factory()
            obj_.build(child_)
            self.triggerDates = obj_
            obj_.original_tagname_ = 'triggerDates'
        elif nodeName_ == 'trigger':
            obj_ = Trigger.factory()
            obj_.build(child_)
            self.trigger = obj_
            obj_.original_tagname_ = 'trigger'
        elif nodeName_ == 'featurePayment':
            obj_ = FeaturePayment.factory()
            obj_.build(child_)
            self.featurePayment = obj_
            obj_.original_tagname_ = 'featurePayment'
# end class TriggerEvent


class WeightedAveragingObservation(GeneratedsSuper):
    """A single weighted averaging observation.Choice between date times
    for literal date values, and observation numbers for schedule
    generated observations."""
    member_data_items_ = {
        'dateTime': MemberSpec_('dateTime', 'xsd:dateTime', 0),
        'observationNumber': MemberSpec_('observationNumber', 'xsd:positiveInteger', 0),
        'weight': MemberSpec_('weight', ['NonNegativeDecimal', 'xsd:decimal'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, dateTime=None, observationNumber=None, weight=None):
        self.original_tagname_ = None
        if isinstance(dateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(dateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = dateTime
        self.dateTime = initvalue_
        self.observationNumber = observationNumber
        self.weight = weight
        self.validate_NonNegativeDecimal(self.weight)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WeightedAveragingObservation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WeightedAveragingObservation.subclass:
            return WeightedAveragingObservation.subclass(*args_, **kwargs_)
        else:
            return WeightedAveragingObservation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dateTime(self): return self.dateTime
    def set_dateTime(self, dateTime): self.dateTime = dateTime
    def get_observationNumber(self): return self.observationNumber
    def set_observationNumber(self, observationNumber): self.observationNumber = observationNumber
    def get_weight(self): return self.weight
    def set_weight(self, weight): self.weight = weight
    def validate_NonNegativeDecimal(self, value):
        # Validate type NonNegativeDecimal, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on NonNegativeDecimal' % {"value" : value} )
    def hasContent_(self):
        if (
            self.dateTime is not None or
            self.observationNumber is not None or
            self.weight is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='WeightedAveragingObservation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WeightedAveragingObservation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='WeightedAveragingObservation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='WeightedAveragingObservation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='WeightedAveragingObservation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dateTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdateTime>%s</%sdateTime>%s' % (namespace_, self.gds_format_datetime(self.dateTime, input_name='dateTime'), namespace_, eol_))
        if self.observationNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sobservationNumber>%s</%sobservationNumber>%s' % (namespace_, self.gds_format_integer(self.observationNumber, input_name='observationNumber'), namespace_, eol_))
        if self.weight is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sweight>%s</%sweight>%s' % (namespace_, self.gds_format_float(self.weight, input_name='weight'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.dateTime = dval_
        elif nodeName_ == 'observationNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'observationNumber')
            self.observationNumber = ival_
        elif nodeName_ == 'weight':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'weight')
            self.weight = fval_
            # validate type NonNegativeDecimal
            self.validate_NonNegativeDecimal(self.weight)
# end class WeightedAveragingObservation


class ActualPrice(GeneratedsSuper):
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'currency': MemberSpec_('currency', 'Currency', 0),
        'amount': MemberSpec_('amount', 'xsd:decimal', 0),
        'priceExpression': MemberSpec_('priceExpression', ['PriceExpressionEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, currency=None, amount=None, priceExpression=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.currency = currency
        self.amount = amount
        self.priceExpression = priceExpression
        self.validate_PriceExpressionEnum(self.priceExpression)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ActualPrice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ActualPrice.subclass:
            return ActualPrice.subclass(*args_, **kwargs_)
        else:
            return ActualPrice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_amount(self): return self.amount
    def set_amount(self, amount): self.amount = amount
    def get_priceExpression(self): return self.priceExpression
    def set_priceExpression(self, priceExpression): self.priceExpression = priceExpression
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_PriceExpressionEnum(self, value):
        # Validate type PriceExpressionEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AbsoluteTerms', 'PercentageOfNotional']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PriceExpressionEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on PriceExpressionEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.currency is not None or
            self.amount is not None or
            self.priceExpression is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ActualPrice', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActualPrice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ActualPrice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ActualPrice'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ActualPrice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.currency is not None:
            self.currency.export(outfile, level, namespace_, name_='currency', pretty_print=pretty_print)
        if self.amount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%samount>%s</%samount>%s' % (namespace_, self.gds_format_float(self.amount, input_name='amount'), namespace_, eol_))
        if self.priceExpression is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spriceExpression>%s</%spriceExpression>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.priceExpression), input_name='priceExpression')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'currency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'amount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'amount')
            self.amount = fval_
        elif nodeName_ == 'priceExpression':
            priceExpression_ = child_.text
            priceExpression_ = re_.sub(String_cleanup_pat_, " ", priceExpression_).strip()
            priceExpression_ = self.gds_validate_string(priceExpression_, node, 'priceExpression')
            self.priceExpression = priceExpression_
            # validate type PriceExpressionEnum
            self.validate_PriceExpressionEnum(self.priceExpression)
# end class ActualPrice


class Asset(GeneratedsSuper):
    """Abstract base class for all underlying assets."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Asset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Asset.subclass:
            return Asset.subclass(*args_, **kwargs_)
        else:
            return Asset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Asset', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Asset')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Asset', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Asset'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Asset', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Asset


class AssetMeasureType(GeneratedsSuper):
    """A scheme identifying the types of measures that can be used to
    describe an asset."""
    member_data_items_ = {
        'assetMeasureScheme': MemberSpec_('assetMeasureScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, assetMeasureScheme='http://www.fpml.org/coding-scheme/asset-measure', valueOf_=None):
        self.original_tagname_ = None
        self.assetMeasureScheme = _cast(None, assetMeasureScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AssetMeasureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AssetMeasureType.subclass:
            return AssetMeasureType.subclass(*args_, **kwargs_)
        else:
            return AssetMeasureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_assetMeasureScheme(self): return self.assetMeasureScheme
    def set_assetMeasureScheme(self, assetMeasureScheme): self.assetMeasureScheme = assetMeasureScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AssetMeasureType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AssetMeasureType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AssetMeasureType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AssetMeasureType'):
        if self.assetMeasureScheme != "http://www.fpml.org/coding-scheme/asset-measure" and 'assetMeasureScheme' not in already_processed:
            already_processed.add('assetMeasureScheme')
            outfile.write(' assetMeasureScheme=%s' % (quote_attrib(self.assetMeasureScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AssetMeasureType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('assetMeasureScheme', node)
        if value is not None and 'assetMeasureScheme' not in already_processed:
            already_processed.add('assetMeasureScheme')
            self.assetMeasureScheme = value
            self.validate_NonEmptyURI(self.assetMeasureScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AssetMeasureType


class AssetPool(GeneratedsSuper):
    """Characterise the asset pool behind an asset backed bond."""
    member_data_items_ = {
        'version': MemberSpec_('version', 'xsd:nonNegativeInteger', 0),
        'effectiveDate': MemberSpec_('effectiveDate', 'IdentifiedDate', 0),
        'initialFactor': MemberSpec_('initialFactor', 'xsd:decimal', 0),
        'currentFactor': MemberSpec_('currentFactor', 'xsd:decimal', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, version=None, effectiveDate=None, initialFactor=None, currentFactor=None):
        self.original_tagname_ = None
        self.version = version
        self.effectiveDate = effectiveDate
        self.initialFactor = initialFactor
        self.currentFactor = currentFactor
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AssetPool)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AssetPool.subclass:
            return AssetPool.subclass(*args_, **kwargs_)
        else:
            return AssetPool(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_effectiveDate(self): return self.effectiveDate
    def set_effectiveDate(self, effectiveDate): self.effectiveDate = effectiveDate
    def get_initialFactor(self): return self.initialFactor
    def set_initialFactor(self, initialFactor): self.initialFactor = initialFactor
    def get_currentFactor(self): return self.currentFactor
    def set_currentFactor(self, currentFactor): self.currentFactor = currentFactor
    def hasContent_(self):
        if (
            self.version is not None or
            self.effectiveDate is not None or
            self.initialFactor is not None or
            self.currentFactor is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AssetPool', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AssetPool')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AssetPool', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AssetPool'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AssetPool', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sversion>%s</%sversion>%s' % (namespace_, self.gds_format_integer(self.version, input_name='version'), namespace_, eol_))
        if self.effectiveDate is not None:
            self.effectiveDate.export(outfile, level, namespace_, name_='effectiveDate', pretty_print=pretty_print)
        if self.initialFactor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinitialFactor>%s</%sinitialFactor>%s' % (namespace_, self.gds_format_float(self.initialFactor, input_name='initialFactor'), namespace_, eol_))
        if self.currentFactor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scurrentFactor>%s</%scurrentFactor>%s' % (namespace_, self.gds_format_float(self.currentFactor, input_name='currentFactor'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'version':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'version')
            self.version = ival_
        elif nodeName_ == 'effectiveDate':
            obj_ = IdentifiedDate.factory()
            obj_.build(child_)
            self.effectiveDate = obj_
            obj_.original_tagname_ = 'effectiveDate'
        elif nodeName_ == 'initialFactor':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'initialFactor')
            self.initialFactor = fval_
        elif nodeName_ == 'currentFactor':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'currentFactor')
            self.currentFactor = fval_
# end class AssetPool


class BasicQuotation(GeneratedsSuper):
    """Some kind of numerical measure about an asset, eg. its NPV, together
    with characteristics of that measure."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'value': MemberSpec_('value', 'xsd:decimal', 0),
        'measureType': MemberSpec_('measureType', 'AssetMeasureType', 0),
        'quoteUnits': MemberSpec_('quoteUnits', 'PriceQuoteUnits', 0),
        'side': MemberSpec_('side', ['QuotationSideEnum', 'Token', 'xsd:token'], 0),
        'currency': MemberSpec_('currency', 'Currency', 0),
        'currencyType': MemberSpec_('currencyType', 'ReportingCurrencyType', 0),
        'timing': MemberSpec_('timing', 'QuoteTiming', 0),
        'businessCenter': MemberSpec_('businessCenter', 'BusinessCenter', 0),
        'exchangeId': MemberSpec_('exchangeId', 'ExchangeId', 0),
        'informationSource': MemberSpec_('informationSource', 'InformationSource', 1),
        'pricingModel': MemberSpec_('pricingModel', 'PricingModel', 0),
        'time': MemberSpec_('time', 'xsd:dateTime', 0),
        'valuationDate': MemberSpec_('valuationDate', 'xsd:date', 0),
        'expiryTime': MemberSpec_('expiryTime', 'xsd:dateTime', 0),
        'cashflowType': MemberSpec_('cashflowType', 'CashflowType', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, value=None, measureType=None, quoteUnits=None, side=None, currency=None, currencyType=None, timing=None, businessCenter=None, exchangeId=None, informationSource=None, pricingModel=None, time=None, valuationDate=None, expiryTime=None, cashflowType=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.value = value
        self.measureType = measureType
        self.quoteUnits = quoteUnits
        self.side = side
        self.validate_QuotationSideEnum(self.side)
        self.currency = currency
        self.currencyType = currencyType
        self.timing = timing
        self.businessCenter = businessCenter
        self.exchangeId = exchangeId
        if informationSource is None:
            self.informationSource = []
        else:
            self.informationSource = informationSource
        self.pricingModel = pricingModel
        if isinstance(time, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(time, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = time
        self.time = initvalue_
        if isinstance(valuationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(valuationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = valuationDate
        self.valuationDate = initvalue_
        if isinstance(expiryTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(expiryTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = expiryTime
        self.expiryTime = initvalue_
        self.cashflowType = cashflowType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BasicQuotation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BasicQuotation.subclass:
            return BasicQuotation.subclass(*args_, **kwargs_)
        else:
            return BasicQuotation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_measureType(self): return self.measureType
    def set_measureType(self, measureType): self.measureType = measureType
    def get_quoteUnits(self): return self.quoteUnits
    def set_quoteUnits(self, quoteUnits): self.quoteUnits = quoteUnits
    def get_side(self): return self.side
    def set_side(self, side): self.side = side
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_currencyType(self): return self.currencyType
    def set_currencyType(self, currencyType): self.currencyType = currencyType
    def get_timing(self): return self.timing
    def set_timing(self, timing): self.timing = timing
    def get_businessCenter(self): return self.businessCenter
    def set_businessCenter(self, businessCenter): self.businessCenter = businessCenter
    def get_exchangeId(self): return self.exchangeId
    def set_exchangeId(self, exchangeId): self.exchangeId = exchangeId
    def get_informationSource(self): return self.informationSource
    def set_informationSource(self, informationSource): self.informationSource = informationSource
    def add_informationSource(self, value): self.informationSource.append(value)
    def insert_informationSource_at(self, index, value): self.informationSource.insert(index, value)
    def replace_informationSource_at(self, index, value): self.informationSource[index] = value
    def get_pricingModel(self): return self.pricingModel
    def set_pricingModel(self, pricingModel): self.pricingModel = pricingModel
    def get_time(self): return self.time
    def set_time(self, time): self.time = time
    def get_valuationDate(self): return self.valuationDate
    def set_valuationDate(self, valuationDate): self.valuationDate = valuationDate
    def get_expiryTime(self): return self.expiryTime
    def set_expiryTime(self, expiryTime): self.expiryTime = expiryTime
    def get_cashflowType(self): return self.cashflowType
    def set_cashflowType(self, cashflowType): self.cashflowType = cashflowType
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_QuotationSideEnum(self, value):
        # Validate type QuotationSideEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Bid', 'Ask', 'Mid']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on QuotationSideEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on QuotationSideEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.value is not None or
            self.measureType is not None or
            self.quoteUnits is not None or
            self.side is not None or
            self.currency is not None or
            self.currencyType is not None or
            self.timing is not None or
            self.businessCenter is not None or
            self.exchangeId is not None or
            self.informationSource or
            self.pricingModel is not None or
            self.time is not None or
            self.valuationDate is not None or
            self.expiryTime is not None or
            self.cashflowType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BasicQuotation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BasicQuotation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BasicQuotation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BasicQuotation'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BasicQuotation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_float(self.value, input_name='value'), namespace_, eol_))
        if self.measureType is not None:
            self.measureType.export(outfile, level, namespace_, name_='measureType', pretty_print=pretty_print)
        if self.quoteUnits is not None:
            self.quoteUnits.export(outfile, level, namespace_, name_='quoteUnits', pretty_print=pretty_print)
        if self.side is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sside>%s</%sside>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.side), input_name='side')), namespace_, eol_))
        if self.currency is not None:
            self.currency.export(outfile, level, namespace_, name_='currency', pretty_print=pretty_print)
        if self.currencyType is not None:
            self.currencyType.export(outfile, level, namespace_, name_='currencyType', pretty_print=pretty_print)
        if self.timing is not None:
            self.timing.export(outfile, level, namespace_, name_='timing', pretty_print=pretty_print)
        if self.businessCenter is not None:
            self.businessCenter.export(outfile, level, namespace_, name_='businessCenter', pretty_print=pretty_print)
        if self.exchangeId is not None:
            self.exchangeId.export(outfile, level, namespace_, name_='exchangeId', pretty_print=pretty_print)
        for informationSource_ in self.informationSource:
            informationSource_.export(outfile, level, namespace_, name_='informationSource', pretty_print=pretty_print)
        if self.pricingModel is not None:
            self.pricingModel.export(outfile, level, namespace_, name_='pricingModel', pretty_print=pretty_print)
        if self.time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stime>%s</%stime>%s' % (namespace_, self.gds_format_datetime(self.time, input_name='time'), namespace_, eol_))
        if self.valuationDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svaluationDate>%s</%svaluationDate>%s' % (namespace_, self.gds_format_date(self.valuationDate, input_name='valuationDate'), namespace_, eol_))
        if self.expiryTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexpiryTime>%s</%sexpiryTime>%s' % (namespace_, self.gds_format_datetime(self.expiryTime, input_name='expiryTime'), namespace_, eol_))
        if self.cashflowType is not None:
            self.cashflowType.export(outfile, level, namespace_, name_='cashflowType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'value':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'value')
            self.value = fval_
        elif nodeName_ == 'measureType':
            obj_ = AssetMeasureType.factory()
            obj_.build(child_)
            self.measureType = obj_
            obj_.original_tagname_ = 'measureType'
        elif nodeName_ == 'quoteUnits':
            obj_ = PriceQuoteUnits.factory()
            obj_.build(child_)
            self.quoteUnits = obj_
            obj_.original_tagname_ = 'quoteUnits'
        elif nodeName_ == 'side':
            side_ = child_.text
            side_ = re_.sub(String_cleanup_pat_, " ", side_).strip()
            side_ = self.gds_validate_string(side_, node, 'side')
            self.side = side_
            # validate type QuotationSideEnum
            self.validate_QuotationSideEnum(self.side)
        elif nodeName_ == 'currency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'currencyType':
            obj_ = ReportingCurrencyType.factory()
            obj_.build(child_)
            self.currencyType = obj_
            obj_.original_tagname_ = 'currencyType'
        elif nodeName_ == 'timing':
            obj_ = QuoteTiming.factory()
            obj_.build(child_)
            self.timing = obj_
            obj_.original_tagname_ = 'timing'
        elif nodeName_ == 'businessCenter':
            obj_ = BusinessCenter.factory()
            obj_.build(child_)
            self.businessCenter = obj_
            obj_.original_tagname_ = 'businessCenter'
        elif nodeName_ == 'exchangeId':
            obj_ = ExchangeId.factory()
            obj_.build(child_)
            self.exchangeId = obj_
            obj_.original_tagname_ = 'exchangeId'
        elif nodeName_ == 'informationSource':
            class_obj_ = self.get_class_obj_(child_, InformationSource)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.informationSource.append(obj_)
            obj_.original_tagname_ = 'informationSource'
        elif nodeName_ == 'pricingModel':
            obj_ = PricingModel.factory()
            obj_.build(child_)
            self.pricingModel = obj_
            obj_.original_tagname_ = 'pricingModel'
        elif nodeName_ == 'time':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.time = dval_
        elif nodeName_ == 'valuationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.valuationDate = dval_
        elif nodeName_ == 'expiryTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.expiryTime = dval_
        elif nodeName_ == 'cashflowType':
            obj_ = CashflowType.factory()
            obj_.build(child_)
            self.cashflowType = obj_
            obj_.original_tagname_ = 'cashflowType'
# end class BasicQuotation


class Basket(Asset):
    """A type describing the underlyer features of a basket swap. Each of
    the basket constituents are described through an embedded
    component, the basketConstituentsType."""
    member_data_items_ = {
        'openUnits': MemberSpec_('openUnits', 'xsd:decimal', 0),
        'basketConstituent': MemberSpec_('basketConstituent', 'BasketConstituent', 1),
        'basketDivisor': MemberSpec_('basketDivisor', 'xsd:decimal', 0),
        'basketVersion': MemberSpec_('basketVersion', 'xsd:nonNegativeInteger', 0),
        'basketName': MemberSpec_('basketName', 'BasketName', 0),
        'basketId': MemberSpec_('basketId', 'BasketId', 1),
        'basketId': MemberSpec_('basketId', 'BasketId', 1),
        'basketCurrency': MemberSpec_('basketCurrency', 'Currency', 0),
    }
    subclass = None
    superclass = Asset
    def __init__(self, id=None, openUnits=None, basketConstituent=None, basketDivisor=None, basketVersion=None, basketName=None, basketId=None, basketCurrency=None):
        self.original_tagname_ = None
        super(Basket, self).__init__(id, )
        self.openUnits = openUnits
        if basketConstituent is None:
            self.basketConstituent = []
        else:
            self.basketConstituent = basketConstituent
        self.basketDivisor = basketDivisor
        self.basketVersion = basketVersion
        self.basketName = basketName
        if basketId is None:
            self.basketId = []
        else:
            self.basketId = basketId
        if basketId is None:
            self.basketId = []
        else:
            self.basketId = basketId
        self.basketCurrency = basketCurrency
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Basket)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Basket.subclass:
            return Basket.subclass(*args_, **kwargs_)
        else:
            return Basket(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_openUnits(self): return self.openUnits
    def set_openUnits(self, openUnits): self.openUnits = openUnits
    def get_basketConstituent(self): return self.basketConstituent
    def set_basketConstituent(self, basketConstituent): self.basketConstituent = basketConstituent
    def add_basketConstituent(self, value): self.basketConstituent.append(value)
    def insert_basketConstituent_at(self, index, value): self.basketConstituent.insert(index, value)
    def replace_basketConstituent_at(self, index, value): self.basketConstituent[index] = value
    def get_basketDivisor(self): return self.basketDivisor
    def set_basketDivisor(self, basketDivisor): self.basketDivisor = basketDivisor
    def get_basketVersion(self): return self.basketVersion
    def set_basketVersion(self, basketVersion): self.basketVersion = basketVersion
    def get_basketName(self): return self.basketName
    def set_basketName(self, basketName): self.basketName = basketName
    def get_basketId(self): return self.basketId
    def set_basketId(self, basketId): self.basketId = basketId
    def add_basketId(self, value): self.basketId.append(value)
    def insert_basketId_at(self, index, value): self.basketId.insert(index, value)
    def replace_basketId_at(self, index, value): self.basketId[index] = value
    def get_basketId(self): return self.basketId
    def set_basketId(self, basketId): self.basketId = basketId
    def add_basketId(self, value): self.basketId.append(value)
    def insert_basketId_at(self, index, value): self.basketId.insert(index, value)
    def replace_basketId_at(self, index, value): self.basketId[index] = value
    def get_basketCurrency(self): return self.basketCurrency
    def set_basketCurrency(self, basketCurrency): self.basketCurrency = basketCurrency
    def hasContent_(self):
        if (
            self.openUnits is not None or
            self.basketConstituent or
            self.basketDivisor is not None or
            self.basketVersion is not None or
            self.basketName is not None or
            self.basketId or
            self.basketId or
            self.basketCurrency is not None or
            super(Basket, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Basket', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Basket')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Basket', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Basket'):
        super(Basket, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Basket')
    def exportChildren(self, outfile, level, namespace_='', name_='Basket', fromsubclass_=False, pretty_print=True):
        super(Basket, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.openUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sopenUnits>%s</%sopenUnits>%s' % (namespace_, self.gds_format_float(self.openUnits, input_name='openUnits'), namespace_, eol_))
        for basketConstituent_ in self.basketConstituent:
            basketConstituent_.export(outfile, level, namespace_, name_='basketConstituent', pretty_print=pretty_print)
        if self.basketDivisor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbasketDivisor>%s</%sbasketDivisor>%s' % (namespace_, self.gds_format_float(self.basketDivisor, input_name='basketDivisor'), namespace_, eol_))
        if self.basketVersion is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbasketVersion>%s</%sbasketVersion>%s' % (namespace_, self.gds_format_integer(self.basketVersion, input_name='basketVersion'), namespace_, eol_))
        if self.basketName is not None:
            self.basketName.export(outfile, level, namespace_, name_='basketName', pretty_print=pretty_print)
        for basketId_ in self.basketId:
            basketId_.export(outfile, level, namespace_, name_='basketId', pretty_print=pretty_print)
        for basketId_ in self.basketId:
            basketId_.export(outfile, level, namespace_, name_='basketId', pretty_print=pretty_print)
        if self.basketCurrency is not None:
            self.basketCurrency.export(outfile, level, namespace_, name_='basketCurrency', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Basket, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'openUnits':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'openUnits')
            self.openUnits = fval_
        elif nodeName_ == 'basketConstituent':
            obj_ = BasketConstituent.factory()
            obj_.build(child_)
            self.basketConstituent.append(obj_)
            obj_.original_tagname_ = 'basketConstituent'
        elif nodeName_ == 'basketDivisor':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'basketDivisor')
            self.basketDivisor = fval_
        elif nodeName_ == 'basketVersion':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'basketVersion')
            self.basketVersion = ival_
        elif nodeName_ == 'basketName':
            obj_ = BasketName.factory()
            obj_.build(child_)
            self.basketName = obj_
            obj_.original_tagname_ = 'basketName'
        elif nodeName_ == 'basketId':
            obj_ = BasketId.factory()
            obj_.build(child_)
            self.basketId.append(obj_)
            obj_.original_tagname_ = 'basketId'
        elif nodeName_ == 'basketId':
            obj_ = BasketId.factory()
            obj_.build(child_)
            self.basketId.append(obj_)
            obj_.original_tagname_ = 'basketId'
        elif nodeName_ == 'basketCurrency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.basketCurrency = obj_
            obj_.original_tagname_ = 'basketCurrency'
        super(Basket, self).buildChildren(child_, node, nodeName_, True)
# end class Basket


class BasketConstituent(GeneratedsSuper):
    """A type describing each of the constituents of a basket."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'payerPartyReference': MemberSpec_('payerPartyReference', 'PartyReference', 0),
        'payerAccountReference': MemberSpec_('payerAccountReference', 'AccountReference', 0),
        'receiverPartyReference': MemberSpec_('receiverPartyReference', 'PartyReference', 0),
        'receiverAccountReference': MemberSpec_('receiverAccountReference', 'AccountReference', 0),
        'underlyingAsset': MemberSpec_('underlyingAsset', 'Asset', 0),
        'constituentWeight': MemberSpec_('constituentWeight', 'ConstituentWeight', 0),
        'dividendPayout': MemberSpec_('dividendPayout', 'DividendPayout', 0),
        'underlyerPrice': MemberSpec_('underlyerPrice', 'Price', 0),
        'underlyerNotional': MemberSpec_('underlyerNotional', 'Money', 0),
        'underlyerSpread': MemberSpec_('underlyerSpread', 'SpreadScheduleReference', 0),
        'couponPayment': MemberSpec_('couponPayment', 'PendingPayment', 0),
        'underlyerFinancing': MemberSpec_('underlyerFinancing', 'UnderlyerInterestLeg', 0),
        'underlyerLoanRate': MemberSpec_('underlyerLoanRate', 'UnderlyerLoanRate', 0),
        'underlyerCollateral': MemberSpec_('underlyerCollateral', 'Collateral', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, underlyingAsset=None, constituentWeight=None, dividendPayout=None, underlyerPrice=None, underlyerNotional=None, underlyerSpread=None, couponPayment=None, underlyerFinancing=None, underlyerLoanRate=None, underlyerCollateral=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.payerPartyReference = payerPartyReference
        self.payerAccountReference = payerAccountReference
        self.receiverPartyReference = receiverPartyReference
        self.receiverAccountReference = receiverAccountReference
        self.underlyingAsset = underlyingAsset
        self.constituentWeight = constituentWeight
        self.dividendPayout = dividendPayout
        self.underlyerPrice = underlyerPrice
        self.underlyerNotional = underlyerNotional
        self.underlyerSpread = underlyerSpread
        self.couponPayment = couponPayment
        self.underlyerFinancing = underlyerFinancing
        self.underlyerLoanRate = underlyerLoanRate
        self.underlyerCollateral = underlyerCollateral
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BasketConstituent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BasketConstituent.subclass:
            return BasketConstituent.subclass(*args_, **kwargs_)
        else:
            return BasketConstituent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_payerPartyReference(self): return self.payerPartyReference
    def set_payerPartyReference(self, payerPartyReference): self.payerPartyReference = payerPartyReference
    def get_payerAccountReference(self): return self.payerAccountReference
    def set_payerAccountReference(self, payerAccountReference): self.payerAccountReference = payerAccountReference
    def get_receiverPartyReference(self): return self.receiverPartyReference
    def set_receiverPartyReference(self, receiverPartyReference): self.receiverPartyReference = receiverPartyReference
    def get_receiverAccountReference(self): return self.receiverAccountReference
    def set_receiverAccountReference(self, receiverAccountReference): self.receiverAccountReference = receiverAccountReference
    def get_underlyingAsset(self): return self.underlyingAsset
    def set_underlyingAsset(self, underlyingAsset): self.underlyingAsset = underlyingAsset
    def get_constituentWeight(self): return self.constituentWeight
    def set_constituentWeight(self, constituentWeight): self.constituentWeight = constituentWeight
    def get_dividendPayout(self): return self.dividendPayout
    def set_dividendPayout(self, dividendPayout): self.dividendPayout = dividendPayout
    def get_underlyerPrice(self): return self.underlyerPrice
    def set_underlyerPrice(self, underlyerPrice): self.underlyerPrice = underlyerPrice
    def get_underlyerNotional(self): return self.underlyerNotional
    def set_underlyerNotional(self, underlyerNotional): self.underlyerNotional = underlyerNotional
    def get_underlyerSpread(self): return self.underlyerSpread
    def set_underlyerSpread(self, underlyerSpread): self.underlyerSpread = underlyerSpread
    def get_couponPayment(self): return self.couponPayment
    def set_couponPayment(self, couponPayment): self.couponPayment = couponPayment
    def get_underlyerFinancing(self): return self.underlyerFinancing
    def set_underlyerFinancing(self, underlyerFinancing): self.underlyerFinancing = underlyerFinancing
    def get_underlyerLoanRate(self): return self.underlyerLoanRate
    def set_underlyerLoanRate(self, underlyerLoanRate): self.underlyerLoanRate = underlyerLoanRate
    def get_underlyerCollateral(self): return self.underlyerCollateral
    def set_underlyerCollateral(self, underlyerCollateral): self.underlyerCollateral = underlyerCollateral
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.payerPartyReference is not None or
            self.payerAccountReference is not None or
            self.receiverPartyReference is not None or
            self.receiverAccountReference is not None or
            self.underlyingAsset is not None or
            self.constituentWeight is not None or
            self.dividendPayout is not None or
            self.underlyerPrice is not None or
            self.underlyerNotional is not None or
            self.underlyerSpread is not None or
            self.couponPayment is not None or
            self.underlyerFinancing is not None or
            self.underlyerLoanRate is not None or
            self.underlyerCollateral is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BasketConstituent', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BasketConstituent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BasketConstituent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BasketConstituent'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BasketConstituent', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.payerPartyReference is not None:
            self.payerPartyReference.export(outfile, level, namespace_, name_='payerPartyReference', pretty_print=pretty_print)
        if self.payerAccountReference is not None:
            self.payerAccountReference.export(outfile, level, namespace_, name_='payerAccountReference', pretty_print=pretty_print)
        if self.receiverPartyReference is not None:
            self.receiverPartyReference.export(outfile, level, namespace_, name_='receiverPartyReference', pretty_print=pretty_print)
        if self.receiverAccountReference is not None:
            self.receiverAccountReference.export(outfile, level, namespace_, name_='receiverAccountReference', pretty_print=pretty_print)
        if self.underlyingAsset is not None:
            self.underlyingAsset.export(outfile, level, namespace_, name_='underlyingAsset', pretty_print=pretty_print)
        if self.constituentWeight is not None:
            self.constituentWeight.export(outfile, level, namespace_, name_='constituentWeight', pretty_print=pretty_print)
        if self.dividendPayout is not None:
            self.dividendPayout.export(outfile, level, namespace_, name_='dividendPayout', pretty_print=pretty_print)
        if self.underlyerPrice is not None:
            self.underlyerPrice.export(outfile, level, namespace_, name_='underlyerPrice', pretty_print=pretty_print)
        if self.underlyerNotional is not None:
            self.underlyerNotional.export(outfile, level, namespace_, name_='underlyerNotional', pretty_print=pretty_print)
        if self.underlyerSpread is not None:
            self.underlyerSpread.export(outfile, level, namespace_, name_='underlyerSpread', pretty_print=pretty_print)
        if self.couponPayment is not None:
            self.couponPayment.export(outfile, level, namespace_, name_='couponPayment', pretty_print=pretty_print)
        if self.underlyerFinancing is not None:
            self.underlyerFinancing.export(outfile, level, namespace_, name_='underlyerFinancing', pretty_print=pretty_print)
        if self.underlyerLoanRate is not None:
            self.underlyerLoanRate.export(outfile, level, namespace_, name_='underlyerLoanRate', pretty_print=pretty_print)
        if self.underlyerCollateral is not None:
            self.underlyerCollateral.export(outfile, level, namespace_, name_='underlyerCollateral', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'payerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.payerPartyReference = obj_
            obj_.original_tagname_ = 'payerPartyReference'
        elif nodeName_ == 'payerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.payerAccountReference = obj_
            obj_.original_tagname_ = 'payerAccountReference'
        elif nodeName_ == 'receiverPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.receiverPartyReference = obj_
            obj_.original_tagname_ = 'receiverPartyReference'
        elif nodeName_ == 'receiverAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.receiverAccountReference = obj_
            obj_.original_tagname_ = 'receiverAccountReference'
        elif nodeName_ == 'underlyingAsset':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <underlyingAsset> element')
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'underlyingAsset'
        elif nodeName_ == 'basket':
            obj_ = Basket.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'basket'
        elif nodeName_ == 'bond':
            class_obj_ = self.get_class_obj_(child_, Bond)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'bond'
        elif nodeName_ == 'cash':
            obj_ = Cash.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'cash'
        elif nodeName_ == 'commodity':
            obj_ = Commodity.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'commodity'
        elif nodeName_ == 'convertibleBond':
            obj_ = ConvertibleBond.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'convertibleBond'
        elif nodeName_ == 'equity':
            obj_ = EquityAsset.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'equity'
        elif nodeName_ == 'exchangeTradedFund':
            obj_ = ExchangeTradedFund.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'exchangeTradedFund'
        elif nodeName_ == 'future':
            obj_ = Future.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'future'
        elif nodeName_ == 'index':
            obj_ = Index.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'index'
        elif nodeName_ == 'loan':
            obj_ = Loan.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'loan'
        elif nodeName_ == 'mortgage':
            obj_ = Mortgage.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'mortgage'
        elif nodeName_ == 'mutualFund':
            obj_ = MutualFund.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'mutualFund'
        elif nodeName_ == 'option':
            obj_ = ExchangeTradedOption.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'option'
        elif nodeName_ == 'constituentWeight':
            obj_ = ConstituentWeight.factory()
            obj_.build(child_)
            self.constituentWeight = obj_
            obj_.original_tagname_ = 'constituentWeight'
        elif nodeName_ == 'dividendPayout':
            obj_ = DividendPayout.factory()
            obj_.build(child_)
            self.dividendPayout = obj_
            obj_.original_tagname_ = 'dividendPayout'
        elif nodeName_ == 'underlyerPrice':
            obj_ = Price.factory()
            obj_.build(child_)
            self.underlyerPrice = obj_
            obj_.original_tagname_ = 'underlyerPrice'
        elif nodeName_ == 'underlyerNotional':
            obj_ = Money.factory()
            obj_.build(child_)
            self.underlyerNotional = obj_
            obj_.original_tagname_ = 'underlyerNotional'
        elif nodeName_ == 'underlyerSpread':
            obj_ = SpreadScheduleReference.factory()
            obj_.build(child_)
            self.underlyerSpread = obj_
            obj_.original_tagname_ = 'underlyerSpread'
        elif nodeName_ == 'couponPayment':
            obj_ = PendingPayment.factory()
            obj_.build(child_)
            self.couponPayment = obj_
            obj_.original_tagname_ = 'couponPayment'
        elif nodeName_ == 'underlyerFinancing':
            obj_ = UnderlyerInterestLeg.factory()
            obj_.build(child_)
            self.underlyerFinancing = obj_
            obj_.original_tagname_ = 'underlyerFinancing'
        elif nodeName_ == 'underlyerLoanRate':
            obj_ = UnderlyerLoanRate.factory()
            obj_.build(child_)
            self.underlyerLoanRate = obj_
            obj_.original_tagname_ = 'underlyerLoanRate'
        elif nodeName_ == 'underlyerCollateral':
            obj_ = Collateral.factory()
            obj_.build(child_)
            self.underlyerCollateral = obj_
            obj_.original_tagname_ = 'underlyerCollateral'
# end class BasketConstituent


class BasketId(GeneratedsSuper):
    member_data_items_ = {
        'basketIdScheme': MemberSpec_('basketIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, basketIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.basketIdScheme = _cast(None, basketIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BasketId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BasketId.subclass:
            return BasketId.subclass(*args_, **kwargs_)
        else:
            return BasketId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_basketIdScheme(self): return self.basketIdScheme
    def set_basketIdScheme(self, basketIdScheme): self.basketIdScheme = basketIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BasketId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BasketId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BasketId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BasketId'):
        if self.basketIdScheme is not None and 'basketIdScheme' not in already_processed:
            already_processed.add('basketIdScheme')
            outfile.write(' basketIdScheme=%s' % (quote_attrib(self.basketIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BasketId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('basketIdScheme', node)
        if value is not None and 'basketIdScheme' not in already_processed:
            already_processed.add('basketIdScheme')
            self.basketIdScheme = value
            self.validate_NonEmptyURI(self.basketIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BasketId


class BasketName(GeneratedsSuper):
    member_data_items_ = {
        'basketNameScheme': MemberSpec_('basketNameScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, basketNameScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.basketNameScheme = _cast(None, basketNameScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BasketName)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BasketName.subclass:
            return BasketName.subclass(*args_, **kwargs_)
        else:
            return BasketName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_basketNameScheme(self): return self.basketNameScheme
    def set_basketNameScheme(self, basketNameScheme): self.basketNameScheme = basketNameScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BasketName', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BasketName')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BasketName', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BasketName'):
        if self.basketNameScheme is not None and 'basketNameScheme' not in already_processed:
            already_processed.add('basketNameScheme')
            outfile.write(' basketNameScheme=%s' % (quote_attrib(self.basketNameScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BasketName', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('basketNameScheme', node)
        if value is not None and 'basketNameScheme' not in already_processed:
            already_processed.add('basketNameScheme')
            self.basketNameScheme = value
            self.validate_NonEmptyURI(self.basketNameScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BasketName


class Cash(Asset):
    member_data_items_ = {
        'instrumentId': MemberSpec_('instrumentId', 'InstrumentId', 1),
        'description': MemberSpec_('description', ['String', 'xsd:string'], 0),
        'currency': MemberSpec_('currency', 'Currency', 0),
    }
    subclass = None
    superclass = Asset
    def __init__(self, id=None, instrumentId=None, description=None, currency=None):
        self.original_tagname_ = None
        super(Cash, self).__init__(id, )
        if instrumentId is None:
            self.instrumentId = []
        else:
            self.instrumentId = instrumentId
        self.description = description
        self.validate_String(self.description)
        self.currency = currency
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Cash)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Cash.subclass:
            return Cash.subclass(*args_, **kwargs_)
        else:
            return Cash(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_instrumentId(self): return self.instrumentId
    def set_instrumentId(self, instrumentId): self.instrumentId = instrumentId
    def add_instrumentId(self, value): self.instrumentId.append(value)
    def insert_instrumentId_at(self, index, value): self.instrumentId.insert(index, value)
    def replace_instrumentId_at(self, index, value): self.instrumentId[index] = value
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.instrumentId or
            self.description is not None or
            self.currency is not None or
            super(Cash, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Cash', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Cash')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Cash', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Cash'):
        super(Cash, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Cash')
    def exportChildren(self, outfile, level, namespace_='', name_='Cash', fromsubclass_=False, pretty_print=True):
        super(Cash, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for instrumentId_ in self.instrumentId:
            instrumentId_.export(outfile, level, namespace_, name_='instrumentId', pretty_print=pretty_print)
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespace_, eol_))
        if self.currency is not None:
            self.currency.export(outfile, level, namespace_, name_='currency', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Cash, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'instrumentId':
            obj_ = InstrumentId.factory()
            obj_.build(child_)
            self.instrumentId.append(obj_)
            obj_.original_tagname_ = 'instrumentId'
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
            # validate type String
            self.validate_String(self.description)
        elif nodeName_ == 'currency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        super(Cash, self).buildChildren(child_, node, nodeName_, True)
# end class Cash


class Commission(GeneratedsSuper):
    """A type describing the commission that will be charged for each of
    the hedge transactions."""
    member_data_items_ = {
        'commissionDenomination': MemberSpec_('commissionDenomination', ['CommissionDenominationEnum', 'Token', 'xsd:token'], 0),
        'commissionAmount': MemberSpec_('commissionAmount', 'xsd:decimal', 0),
        'currency': MemberSpec_('currency', 'Currency', 0),
        'commissionPerTrade': MemberSpec_('commissionPerTrade', 'xsd:decimal', 0),
        'fxRate': MemberSpec_('fxRate', 'FxRate', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, commissionDenomination=None, commissionAmount=None, currency=None, commissionPerTrade=None, fxRate=None):
        self.original_tagname_ = None
        self.commissionDenomination = commissionDenomination
        self.validate_CommissionDenominationEnum(self.commissionDenomination)
        self.commissionAmount = commissionAmount
        self.currency = currency
        self.commissionPerTrade = commissionPerTrade
        if fxRate is None:
            self.fxRate = []
        else:
            self.fxRate = fxRate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Commission)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Commission.subclass:
            return Commission.subclass(*args_, **kwargs_)
        else:
            return Commission(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commissionDenomination(self): return self.commissionDenomination
    def set_commissionDenomination(self, commissionDenomination): self.commissionDenomination = commissionDenomination
    def get_commissionAmount(self): return self.commissionAmount
    def set_commissionAmount(self, commissionAmount): self.commissionAmount = commissionAmount
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_commissionPerTrade(self): return self.commissionPerTrade
    def set_commissionPerTrade(self, commissionPerTrade): self.commissionPerTrade = commissionPerTrade
    def get_fxRate(self): return self.fxRate
    def set_fxRate(self, fxRate): self.fxRate = fxRate
    def add_fxRate(self, value): self.fxRate.append(value)
    def insert_fxRate_at(self, index, value): self.fxRate.insert(index, value)
    def replace_fxRate_at(self, index, value): self.fxRate[index] = value
    def validate_CommissionDenominationEnum(self, value):
        # Validate type CommissionDenominationEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['BPS', 'Percentage', 'CentsPerShare', 'FixedAmount']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CommissionDenominationEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on CommissionDenominationEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.commissionDenomination is not None or
            self.commissionAmount is not None or
            self.currency is not None or
            self.commissionPerTrade is not None or
            self.fxRate
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Commission', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Commission')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Commission', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Commission'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Commission', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.commissionDenomination is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scommissionDenomination>%s</%scommissionDenomination>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.commissionDenomination), input_name='commissionDenomination')), namespace_, eol_))
        if self.commissionAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scommissionAmount>%s</%scommissionAmount>%s' % (namespace_, self.gds_format_float(self.commissionAmount, input_name='commissionAmount'), namespace_, eol_))
        if self.currency is not None:
            self.currency.export(outfile, level, namespace_, name_='currency', pretty_print=pretty_print)
        if self.commissionPerTrade is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scommissionPerTrade>%s</%scommissionPerTrade>%s' % (namespace_, self.gds_format_float(self.commissionPerTrade, input_name='commissionPerTrade'), namespace_, eol_))
        for fxRate_ in self.fxRate:
            fxRate_.export(outfile, level, namespace_, name_='fxRate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'commissionDenomination':
            commissionDenomination_ = child_.text
            commissionDenomination_ = re_.sub(String_cleanup_pat_, " ", commissionDenomination_).strip()
            commissionDenomination_ = self.gds_validate_string(commissionDenomination_, node, 'commissionDenomination')
            self.commissionDenomination = commissionDenomination_
            # validate type CommissionDenominationEnum
            self.validate_CommissionDenominationEnum(self.commissionDenomination)
        elif nodeName_ == 'commissionAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'commissionAmount')
            self.commissionAmount = fval_
        elif nodeName_ == 'currency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'commissionPerTrade':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'commissionPerTrade')
            self.commissionPerTrade = fval_
        elif nodeName_ == 'fxRate':
            obj_ = FxRate.factory()
            obj_.build(child_)
            self.fxRate.append(obj_)
            obj_.original_tagname_ = 'fxRate'
# end class Commission


class CommodityBase(GeneratedsSuper):
    member_data_items_ = {
        'commodityBaseScheme': MemberSpec_('commodityBaseScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, commodityBaseScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.commodityBaseScheme = _cast(None, commodityBaseScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityBase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityBase.subclass:
            return CommodityBase.subclass(*args_, **kwargs_)
        else:
            return CommodityBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commodityBaseScheme(self): return self.commodityBaseScheme
    def set_commodityBaseScheme(self, commodityBaseScheme): self.commodityBaseScheme = commodityBaseScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityBase', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityBase')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityBase', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityBase'):
        if self.commodityBaseScheme is not None and 'commodityBaseScheme' not in already_processed:
            already_processed.add('commodityBaseScheme')
            outfile.write(' commodityBaseScheme=%s' % (quote_attrib(self.commodityBaseScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityBase', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('commodityBaseScheme', node)
        if value is not None and 'commodityBaseScheme' not in already_processed:
            already_processed.add('commodityBaseScheme')
            self.commodityBaseScheme = value
            self.validate_NonEmptyURI(self.commodityBaseScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CommodityBase


class CommodityBusinessCalendar(GeneratedsSuper):
    """Defines a commodity business day calendar."""
    member_data_items_ = {
        'commodityBusinessCalendarScheme': MemberSpec_('commodityBusinessCalendarScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, commodityBusinessCalendarScheme='http://www.fpml.org/coding-scheme/commodity-business-calendar', valueOf_=None):
        self.original_tagname_ = None
        self.commodityBusinessCalendarScheme = _cast(None, commodityBusinessCalendarScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityBusinessCalendar)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityBusinessCalendar.subclass:
            return CommodityBusinessCalendar.subclass(*args_, **kwargs_)
        else:
            return CommodityBusinessCalendar(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commodityBusinessCalendarScheme(self): return self.commodityBusinessCalendarScheme
    def set_commodityBusinessCalendarScheme(self, commodityBusinessCalendarScheme): self.commodityBusinessCalendarScheme = commodityBusinessCalendarScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityBusinessCalendar', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityBusinessCalendar')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityBusinessCalendar', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityBusinessCalendar'):
        if self.commodityBusinessCalendarScheme != "http://www.fpml.org/coding-scheme/commodity-business-calendar" and 'commodityBusinessCalendarScheme' not in already_processed:
            already_processed.add('commodityBusinessCalendarScheme')
            outfile.write(' commodityBusinessCalendarScheme=%s' % (quote_attrib(self.commodityBusinessCalendarScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityBusinessCalendar', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('commodityBusinessCalendarScheme', node)
        if value is not None and 'commodityBusinessCalendarScheme' not in already_processed:
            already_processed.add('commodityBusinessCalendarScheme')
            self.commodityBusinessCalendarScheme = value
            self.validate_NonEmptyURI(self.commodityBusinessCalendarScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CommodityBusinessCalendar


class CommodityDetails(GeneratedsSuper):
    member_data_items_ = {
        'commodityDetailsScheme': MemberSpec_('commodityDetailsScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, commodityDetailsScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.commodityDetailsScheme = _cast(None, commodityDetailsScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityDetails)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityDetails.subclass:
            return CommodityDetails.subclass(*args_, **kwargs_)
        else:
            return CommodityDetails(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commodityDetailsScheme(self): return self.commodityDetailsScheme
    def set_commodityDetailsScheme(self, commodityDetailsScheme): self.commodityDetailsScheme = commodityDetailsScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityDetails', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityDetails')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityDetails', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityDetails'):
        if self.commodityDetailsScheme is not None and 'commodityDetailsScheme' not in already_processed:
            already_processed.add('commodityDetailsScheme')
            outfile.write(' commodityDetailsScheme=%s' % (quote_attrib(self.commodityDetailsScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityDetails', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('commodityDetailsScheme', node)
        if value is not None and 'commodityDetailsScheme' not in already_processed:
            already_processed.add('commodityDetailsScheme')
            self.commodityDetailsScheme = value
            self.validate_NonEmptyURI(self.commodityDetailsScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CommodityDetails


class CommodityInformationProvider(GeneratedsSuper):
    """The publication in which the rate, price, index or factor is to be
    found. (e.g Gas Daily, Platts Bloomberg.)"""
    member_data_items_ = {
        'informationProviderScheme': MemberSpec_('informationProviderScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, informationProviderScheme='http://www.fpml.org/coding-scheme/commodity-information-provider', valueOf_=None):
        self.original_tagname_ = None
        self.informationProviderScheme = _cast(None, informationProviderScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityInformationProvider)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityInformationProvider.subclass:
            return CommodityInformationProvider.subclass(*args_, **kwargs_)
        else:
            return CommodityInformationProvider(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_informationProviderScheme(self): return self.informationProviderScheme
    def set_informationProviderScheme(self, informationProviderScheme): self.informationProviderScheme = informationProviderScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityInformationProvider', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityInformationProvider')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityInformationProvider', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityInformationProvider'):
        if self.informationProviderScheme != "http://www.fpml.org/coding-scheme/commodity-information-provider" and 'informationProviderScheme' not in already_processed:
            already_processed.add('informationProviderScheme')
            outfile.write(' informationProviderScheme=%s' % (quote_attrib(self.informationProviderScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityInformationProvider', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('informationProviderScheme', node)
        if value is not None and 'informationProviderScheme' not in already_processed:
            already_processed.add('informationProviderScheme')
            self.informationProviderScheme = value
            self.validate_NonEmptyURI(self.informationProviderScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CommodityInformationProvider


class CommodityInformationSource(GeneratedsSuper):
    """A type defining the source of a commodity rate, price or index or of
    a market rate or of a conversion factor (e.g. a fx conversion
    factor)."""
    member_data_items_ = {
        'rateSource': MemberSpec_('rateSource', 'CommodityInformationProvider', 0),
        'rateSourcePage': MemberSpec_('rateSourcePage', 'RateSourcePage', 0),
        'rateSourcePageHeading': MemberSpec_('rateSourcePageHeading', ['String', 'xsd:string'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, rateSource=None, rateSourcePage=None, rateSourcePageHeading=None):
        self.original_tagname_ = None
        self.rateSource = rateSource
        self.rateSourcePage = rateSourcePage
        self.rateSourcePageHeading = rateSourcePageHeading
        self.validate_String(self.rateSourcePageHeading)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityInformationSource)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityInformationSource.subclass:
            return CommodityInformationSource.subclass(*args_, **kwargs_)
        else:
            return CommodityInformationSource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rateSource(self): return self.rateSource
    def set_rateSource(self, rateSource): self.rateSource = rateSource
    def get_rateSourcePage(self): return self.rateSourcePage
    def set_rateSourcePage(self, rateSourcePage): self.rateSourcePage = rateSourcePage
    def get_rateSourcePageHeading(self): return self.rateSourcePageHeading
    def set_rateSourcePageHeading(self, rateSourcePageHeading): self.rateSourcePageHeading = rateSourcePageHeading
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.rateSource is not None or
            self.rateSourcePage is not None or
            self.rateSourcePageHeading is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityInformationSource', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityInformationSource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityInformationSource', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityInformationSource'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityInformationSource', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.rateSource is not None:
            self.rateSource.export(outfile, level, namespace_, name_='rateSource', pretty_print=pretty_print)
        if self.rateSourcePage is not None:
            self.rateSourcePage.export(outfile, level, namespace_, name_='rateSourcePage', pretty_print=pretty_print)
        if self.rateSourcePageHeading is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srateSourcePageHeading>%s</%srateSourcePageHeading>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.rateSourcePageHeading), input_name='rateSourcePageHeading')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'rateSource':
            obj_ = CommodityInformationProvider.factory()
            obj_.build(child_)
            self.rateSource = obj_
            obj_.original_tagname_ = 'rateSource'
        elif nodeName_ == 'rateSourcePage':
            obj_ = RateSourcePage.factory()
            obj_.build(child_)
            self.rateSourcePage = obj_
            obj_.original_tagname_ = 'rateSourcePage'
        elif nodeName_ == 'rateSourcePageHeading':
            rateSourcePageHeading_ = child_.text
            rateSourcePageHeading_ = self.gds_validate_string(rateSourcePageHeading_, node, 'rateSourcePageHeading')
            self.rateSourcePageHeading = rateSourcePageHeading_
            # validate type String
            self.validate_String(self.rateSourcePageHeading)
# end class CommodityInformationSource


class ConstituentWeight(GeneratedsSuper):
    """A type describing the weight of each of the underlyer constituent
    within the basket, either in absolute or relative terms."""
    member_data_items_ = {
        'openUnits': MemberSpec_('openUnits', 'xsd:decimal', 0),
        'basketPercentage': MemberSpec_('basketPercentage', ['RestrictedPercentage', 'xsd:decimal'], 0),
        'basketAmount': MemberSpec_('basketAmount', 'Money', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, openUnits=None, basketPercentage=None, basketAmount=None):
        self.original_tagname_ = None
        self.openUnits = openUnits
        self.basketPercentage = basketPercentage
        self.validate_RestrictedPercentage(self.basketPercentage)
        self.basketAmount = basketAmount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConstituentWeight)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConstituentWeight.subclass:
            return ConstituentWeight.subclass(*args_, **kwargs_)
        else:
            return ConstituentWeight(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_openUnits(self): return self.openUnits
    def set_openUnits(self, openUnits): self.openUnits = openUnits
    def get_basketPercentage(self): return self.basketPercentage
    def set_basketPercentage(self, basketPercentage): self.basketPercentage = basketPercentage
    def get_basketAmount(self): return self.basketAmount
    def set_basketAmount(self, basketAmount): self.basketAmount = basketAmount
    def validate_RestrictedPercentage(self, value):
        # Validate type RestrictedPercentage, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on RestrictedPercentage' % {"value" : value} )
            if value > 1:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on RestrictedPercentage' % {"value" : value} )
    def hasContent_(self):
        if (
            self.openUnits is not None or
            self.basketPercentage is not None or
            self.basketAmount is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ConstituentWeight', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConstituentWeight')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ConstituentWeight', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConstituentWeight'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ConstituentWeight', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.openUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sopenUnits>%s</%sopenUnits>%s' % (namespace_, self.gds_format_float(self.openUnits, input_name='openUnits'), namespace_, eol_))
        if self.basketPercentage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbasketPercentage>%s</%sbasketPercentage>%s' % (namespace_, self.gds_format_float(self.basketPercentage, input_name='basketPercentage'), namespace_, eol_))
        if self.basketAmount is not None:
            self.basketAmount.export(outfile, level, namespace_, name_='basketAmount', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'openUnits':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'openUnits')
            self.openUnits = fval_
        elif nodeName_ == 'basketPercentage':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'basketPercentage')
            self.basketPercentage = fval_
            # validate type RestrictedPercentage
            self.validate_RestrictedPercentage(self.basketPercentage)
        elif nodeName_ == 'basketAmount':
            obj_ = Money.factory()
            obj_.build(child_)
            self.basketAmount = obj_
            obj_.original_tagname_ = 'basketAmount'
# end class ConstituentWeight


class CouponType(GeneratedsSuper):
    """Defines a scheme of values for specifiying if the bond has a
    variable coupon, step-up/down coupon or a zero-coupon."""
    member_data_items_ = {
        'couponTypeScheme': MemberSpec_('couponTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, couponTypeScheme='http://www.fpml.org/coding-scheme/coupon-type', valueOf_=None):
        self.original_tagname_ = None
        self.couponTypeScheme = _cast(None, couponTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CouponType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CouponType.subclass:
            return CouponType.subclass(*args_, **kwargs_)
        else:
            return CouponType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_couponTypeScheme(self): return self.couponTypeScheme
    def set_couponTypeScheme(self, couponTypeScheme): self.couponTypeScheme = couponTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CouponType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CouponType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CouponType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CouponType'):
        if self.couponTypeScheme != "http://www.fpml.org/coding-scheme/coupon-type" and 'couponTypeScheme' not in already_processed:
            already_processed.add('couponTypeScheme')
            outfile.write(' couponTypeScheme=%s' % (quote_attrib(self.couponTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CouponType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('couponTypeScheme', node)
        if value is not None and 'couponTypeScheme' not in already_processed:
            already_processed.add('couponTypeScheme')
            self.couponTypeScheme = value
            self.validate_NonEmptyURI(self.couponTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CouponType


class DeliveryNearby(GeneratedsSuper):
    """A type defines nearest Delivery Date of the underlying Commodity of
    expiration of the futures contract."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'deliveryNearbyMultiplier': MemberSpec_('deliveryNearbyMultiplier', 'xsd:positiveInteger', 0),
        'deliveryNearbyType': MemberSpec_('deliveryNearbyType', ['DeliveryNearbyTypeEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, deliveryNearbyMultiplier=None, deliveryNearbyType=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.deliveryNearbyMultiplier = deliveryNearbyMultiplier
        self.deliveryNearbyType = deliveryNearbyType
        self.validate_DeliveryNearbyTypeEnum(self.deliveryNearbyType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DeliveryNearby)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DeliveryNearby.subclass:
            return DeliveryNearby.subclass(*args_, **kwargs_)
        else:
            return DeliveryNearby(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_deliveryNearbyMultiplier(self): return self.deliveryNearbyMultiplier
    def set_deliveryNearbyMultiplier(self, deliveryNearbyMultiplier): self.deliveryNearbyMultiplier = deliveryNearbyMultiplier
    def get_deliveryNearbyType(self): return self.deliveryNearbyType
    def set_deliveryNearbyType(self, deliveryNearbyType): self.deliveryNearbyType = deliveryNearbyType
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_DeliveryNearbyTypeEnum(self, value):
        # Validate type DeliveryNearbyTypeEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CalculationPeriod', 'NearbyMonth', 'NearbyWeek']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeliveryNearbyTypeEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on DeliveryNearbyTypeEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.deliveryNearbyMultiplier is not None or
            self.deliveryNearbyType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DeliveryNearby', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeliveryNearby')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DeliveryNearby', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DeliveryNearby'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DeliveryNearby', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.deliveryNearbyMultiplier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdeliveryNearbyMultiplier>%s</%sdeliveryNearbyMultiplier>%s' % (namespace_, self.gds_format_integer(self.deliveryNearbyMultiplier, input_name='deliveryNearbyMultiplier'), namespace_, eol_))
        if self.deliveryNearbyType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdeliveryNearbyType>%s</%sdeliveryNearbyType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.deliveryNearbyType), input_name='deliveryNearbyType')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'deliveryNearbyMultiplier':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'deliveryNearbyMultiplier')
            self.deliveryNearbyMultiplier = ival_
        elif nodeName_ == 'deliveryNearbyType':
            deliveryNearbyType_ = child_.text
            deliveryNearbyType_ = re_.sub(String_cleanup_pat_, " ", deliveryNearbyType_).strip()
            deliveryNearbyType_ = self.gds_validate_string(deliveryNearbyType_, node, 'deliveryNearbyType')
            self.deliveryNearbyType = deliveryNearbyType_
            # validate type DeliveryNearbyTypeEnum
            self.validate_DeliveryNearbyTypeEnum(self.deliveryNearbyType)
# end class DeliveryNearby


class DividendPayout(GeneratedsSuper):
    """A type describing the dividend payout ratio associated with an
    equity underlyer. In certain cases the actual ratio is not known
    on trade inception, and only general conditions are then
    specified.A sequence group to describe the total, cash, and non
    cash dividend payout ratio associated with an equity underlyer.
    In certain cases the actual ratio is not known on trade
    inception, and only general conditions are then specified. Good
    practice is to specify only two of the three values, to avoid
    any inconsistency"""
    member_data_items_ = {
        'dividendPayoutRatio': MemberSpec_('dividendPayoutRatio', 'xsd:decimal', 0),
        'dividendPayoutRatioCash': MemberSpec_('dividendPayoutRatioCash', 'xsd:decimal', 0),
        'dividendPayoutRatioNonCash': MemberSpec_('dividendPayoutRatioNonCash', 'xsd:decimal', 0),
        'dividendPayoutConditions': MemberSpec_('dividendPayoutConditions', ['String', 'xsd:string'], 0),
        'dividendPayment': MemberSpec_('dividendPayment', 'PendingPayment', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, dividendPayoutRatio=None, dividendPayoutRatioCash=None, dividendPayoutRatioNonCash=None, dividendPayoutConditions=None, dividendPayment=None):
        self.original_tagname_ = None
        self.dividendPayoutRatio = dividendPayoutRatio
        self.dividendPayoutRatioCash = dividendPayoutRatioCash
        self.dividendPayoutRatioNonCash = dividendPayoutRatioNonCash
        self.dividendPayoutConditions = dividendPayoutConditions
        self.validate_String(self.dividendPayoutConditions)
        if dividendPayment is None:
            self.dividendPayment = []
        else:
            self.dividendPayment = dividendPayment
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DividendPayout)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DividendPayout.subclass:
            return DividendPayout.subclass(*args_, **kwargs_)
        else:
            return DividendPayout(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dividendPayoutRatio(self): return self.dividendPayoutRatio
    def set_dividendPayoutRatio(self, dividendPayoutRatio): self.dividendPayoutRatio = dividendPayoutRatio
    def get_dividendPayoutRatioCash(self): return self.dividendPayoutRatioCash
    def set_dividendPayoutRatioCash(self, dividendPayoutRatioCash): self.dividendPayoutRatioCash = dividendPayoutRatioCash
    def get_dividendPayoutRatioNonCash(self): return self.dividendPayoutRatioNonCash
    def set_dividendPayoutRatioNonCash(self, dividendPayoutRatioNonCash): self.dividendPayoutRatioNonCash = dividendPayoutRatioNonCash
    def get_dividendPayoutConditions(self): return self.dividendPayoutConditions
    def set_dividendPayoutConditions(self, dividendPayoutConditions): self.dividendPayoutConditions = dividendPayoutConditions
    def get_dividendPayment(self): return self.dividendPayment
    def set_dividendPayment(self, dividendPayment): self.dividendPayment = dividendPayment
    def add_dividendPayment(self, value): self.dividendPayment.append(value)
    def insert_dividendPayment_at(self, index, value): self.dividendPayment.insert(index, value)
    def replace_dividendPayment_at(self, index, value): self.dividendPayment[index] = value
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.dividendPayoutRatio is not None or
            self.dividendPayoutRatioCash is not None or
            self.dividendPayoutRatioNonCash is not None or
            self.dividendPayoutConditions is not None or
            self.dividendPayment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DividendPayout', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DividendPayout')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DividendPayout', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DividendPayout'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DividendPayout', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dividendPayoutRatio is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdividendPayoutRatio>%s</%sdividendPayoutRatio>%s' % (namespace_, self.gds_format_float(self.dividendPayoutRatio, input_name='dividendPayoutRatio'), namespace_, eol_))
        if self.dividendPayoutRatioCash is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdividendPayoutRatioCash>%s</%sdividendPayoutRatioCash>%s' % (namespace_, self.gds_format_float(self.dividendPayoutRatioCash, input_name='dividendPayoutRatioCash'), namespace_, eol_))
        if self.dividendPayoutRatioNonCash is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdividendPayoutRatioNonCash>%s</%sdividendPayoutRatioNonCash>%s' % (namespace_, self.gds_format_float(self.dividendPayoutRatioNonCash, input_name='dividendPayoutRatioNonCash'), namespace_, eol_))
        if self.dividendPayoutConditions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdividendPayoutConditions>%s</%sdividendPayoutConditions>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.dividendPayoutConditions), input_name='dividendPayoutConditions')), namespace_, eol_))
        for dividendPayment_ in self.dividendPayment:
            dividendPayment_.export(outfile, level, namespace_, name_='dividendPayment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dividendPayoutRatio':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'dividendPayoutRatio')
            self.dividendPayoutRatio = fval_
        elif nodeName_ == 'dividendPayoutRatioCash':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'dividendPayoutRatioCash')
            self.dividendPayoutRatioCash = fval_
        elif nodeName_ == 'dividendPayoutRatioNonCash':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'dividendPayoutRatioNonCash')
            self.dividendPayoutRatioNonCash = fval_
        elif nodeName_ == 'dividendPayoutConditions':
            dividendPayoutConditions_ = child_.text
            dividendPayoutConditions_ = self.gds_validate_string(dividendPayoutConditions_, node, 'dividendPayoutConditions')
            self.dividendPayoutConditions = dividendPayoutConditions_
            # validate type String
            self.validate_String(self.dividendPayoutConditions)
        elif nodeName_ == 'dividendPayment':
            obj_ = PendingPayment.factory()
            obj_.build(child_)
            self.dividendPayment.append(obj_)
            obj_.original_tagname_ = 'dividendPayment'
# end class DividendPayout


class FacilityType(GeneratedsSuper):
    """A type describing the type of loan facility."""
    member_data_items_ = {
        'facilityTypeScheme': MemberSpec_('facilityTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, facilityTypeScheme='http://www.fpml.org/coding-scheme/facility-type', valueOf_=None):
        self.original_tagname_ = None
        self.facilityTypeScheme = _cast(None, facilityTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FacilityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FacilityType.subclass:
            return FacilityType.subclass(*args_, **kwargs_)
        else:
            return FacilityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_facilityTypeScheme(self): return self.facilityTypeScheme
    def set_facilityTypeScheme(self, facilityTypeScheme): self.facilityTypeScheme = facilityTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FacilityType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FacilityType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FacilityType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FacilityType'):
        if self.facilityTypeScheme != "http://www.fpml.org/coding-scheme/facility-type" and 'facilityTypeScheme' not in already_processed:
            already_processed.add('facilityTypeScheme')
            outfile.write(' facilityTypeScheme=%s' % (quote_attrib(self.facilityTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='FacilityType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('facilityTypeScheme', node)
        if value is not None and 'facilityTypeScheme' not in already_processed:
            already_processed.add('facilityTypeScheme')
            self.facilityTypeScheme = value
            self.validate_NonEmptyURI(self.facilityTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FacilityType


class FutureId(GeneratedsSuper):
    """A type defining a short form unique identifier for a future
    contract."""
    member_data_items_ = {
        'futureIdScheme': MemberSpec_('futureIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, futureIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.futureIdScheme = _cast(None, futureIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FutureId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FutureId.subclass:
            return FutureId.subclass(*args_, **kwargs_)
        else:
            return FutureId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_futureIdScheme(self): return self.futureIdScheme
    def set_futureIdScheme(self, futureIdScheme): self.futureIdScheme = futureIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FutureId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FutureId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FutureId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FutureId'):
        if self.futureIdScheme is not None and 'futureIdScheme' not in already_processed:
            already_processed.add('futureIdScheme')
            outfile.write(' futureIdScheme=%s' % (quote_attrib(self.futureIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='FutureId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('futureIdScheme', node)
        if value is not None and 'futureIdScheme' not in already_processed:
            already_processed.add('futureIdScheme')
            self.futureIdScheme = value
            self.validate_NonEmptyURI(self.futureIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FutureId


class FxConversion(GeneratedsSuper):
    member_data_items_ = {
        'amountRelativeTo': MemberSpec_('amountRelativeTo', 'AmountReference', 0),
        'fxRate': MemberSpec_('fxRate', 'FxRate', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, amountRelativeTo=None, fxRate=None):
        self.original_tagname_ = None
        self.amountRelativeTo = amountRelativeTo
        if fxRate is None:
            self.fxRate = []
        else:
            self.fxRate = fxRate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FxConversion)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FxConversion.subclass:
            return FxConversion.subclass(*args_, **kwargs_)
        else:
            return FxConversion(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_amountRelativeTo(self): return self.amountRelativeTo
    def set_amountRelativeTo(self, amountRelativeTo): self.amountRelativeTo = amountRelativeTo
    def get_fxRate(self): return self.fxRate
    def set_fxRate(self, fxRate): self.fxRate = fxRate
    def add_fxRate(self, value): self.fxRate.append(value)
    def insert_fxRate_at(self, index, value): self.fxRate.insert(index, value)
    def replace_fxRate_at(self, index, value): self.fxRate[index] = value
    def hasContent_(self):
        if (
            self.amountRelativeTo is not None or
            self.fxRate
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FxConversion', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FxConversion')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FxConversion', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FxConversion'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FxConversion', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.amountRelativeTo is not None:
            self.amountRelativeTo.export(outfile, level, namespace_, name_='amountRelativeTo', pretty_print=pretty_print)
        for fxRate_ in self.fxRate:
            fxRate_.export(outfile, level, namespace_, name_='fxRate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'amountRelativeTo':
            obj_ = AmountReference.factory()
            obj_.build(child_)
            self.amountRelativeTo = obj_
            obj_.original_tagname_ = 'amountRelativeTo'
        elif nodeName_ == 'fxRate':
            obj_ = FxRate.factory()
            obj_.build(child_)
            self.fxRate.append(obj_)
            obj_.original_tagname_ = 'fxRate'
# end class FxConversion


class IdentifiedAsset(Asset):
    """A generic type describing an identified asset."""
    member_data_items_ = {
        'instrumentId': MemberSpec_('instrumentId', 'InstrumentId', 1),
        'description': MemberSpec_('description', ['String', 'xsd:string'], 0),
    }
    subclass = None
    superclass = Asset
    def __init__(self, id=None, instrumentId=None, description=None, extensiontype_=None):
        self.original_tagname_ = None
        super(IdentifiedAsset, self).__init__(id, extensiontype_, )
        if instrumentId is None:
            self.instrumentId = []
        else:
            self.instrumentId = instrumentId
        self.description = description
        self.validate_String(self.description)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IdentifiedAsset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IdentifiedAsset.subclass:
            return IdentifiedAsset.subclass(*args_, **kwargs_)
        else:
            return IdentifiedAsset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_instrumentId(self): return self.instrumentId
    def set_instrumentId(self, instrumentId): self.instrumentId = instrumentId
    def add_instrumentId(self, value): self.instrumentId.append(value)
    def insert_instrumentId_at(self, index, value): self.instrumentId.insert(index, value)
    def replace_instrumentId_at(self, index, value): self.instrumentId[index] = value
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.instrumentId or
            self.description is not None or
            super(IdentifiedAsset, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IdentifiedAsset', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifiedAsset')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IdentifiedAsset', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IdentifiedAsset'):
        super(IdentifiedAsset, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifiedAsset')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='IdentifiedAsset', fromsubclass_=False, pretty_print=True):
        super(IdentifiedAsset, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for instrumentId_ in self.instrumentId:
            instrumentId_.export(outfile, level, namespace_, name_='instrumentId', pretty_print=pretty_print)
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(IdentifiedAsset, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'instrumentId':
            obj_ = InstrumentId.factory()
            obj_.build(child_)
            self.instrumentId.append(obj_)
            obj_.original_tagname_ = 'instrumentId'
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
            # validate type String
            self.validate_String(self.description)
        super(IdentifiedAsset, self).buildChildren(child_, node, nodeName_, True)
# end class IdentifiedAsset


class Lien(GeneratedsSuper):
    """A type describing the liens associated with a loan facility."""
    member_data_items_ = {
        'lienScheme': MemberSpec_('lienScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, lienScheme='http://www.fpml.org/coding-scheme/designated-priority', valueOf_=None):
        self.original_tagname_ = None
        self.lienScheme = _cast(None, lienScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Lien)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Lien.subclass:
            return Lien.subclass(*args_, **kwargs_)
        else:
            return Lien(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lienScheme(self): return self.lienScheme
    def set_lienScheme(self, lienScheme): self.lienScheme = lienScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Lien', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Lien')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Lien', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Lien'):
        if self.lienScheme != "http://www.fpml.org/coding-scheme/designated-priority" and 'lienScheme' not in already_processed:
            already_processed.add('lienScheme')
            outfile.write(' lienScheme=%s' % (quote_attrib(self.lienScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Lien', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lienScheme', node)
        if value is not None and 'lienScheme' not in already_processed:
            already_processed.add('lienScheme')
            self.lienScheme = value
            self.validate_NonEmptyURI(self.lienScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Lien


class MortgageSector(GeneratedsSuper):
    """A type describing the typology of mortgage obligations."""
    member_data_items_ = {
        'mortgageSectorScheme': MemberSpec_('mortgageSectorScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, mortgageSectorScheme='http://www.fpml.org/coding-scheme/mortgage-sector', valueOf_=None):
        self.original_tagname_ = None
        self.mortgageSectorScheme = _cast(None, mortgageSectorScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MortgageSector)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MortgageSector.subclass:
            return MortgageSector.subclass(*args_, **kwargs_)
        else:
            return MortgageSector(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mortgageSectorScheme(self): return self.mortgageSectorScheme
    def set_mortgageSectorScheme(self, mortgageSectorScheme): self.mortgageSectorScheme = mortgageSectorScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MortgageSector', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MortgageSector')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MortgageSector', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MortgageSector'):
        if self.mortgageSectorScheme != "http://www.fpml.org/coding-scheme/mortgage-sector" and 'mortgageSectorScheme' not in already_processed:
            already_processed.add('mortgageSectorScheme')
            outfile.write(' mortgageSectorScheme=%s' % (quote_attrib(self.mortgageSectorScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MortgageSector', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mortgageSectorScheme', node)
        if value is not None and 'mortgageSectorScheme' not in already_processed:
            already_processed.add('mortgageSectorScheme')
            self.mortgageSectorScheme = value
            self.validate_NonEmptyURI(self.mortgageSectorScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MortgageSector


class Price(GeneratedsSuper):
    """A type describing the strike price."""
    member_data_items_ = {
        'commission': MemberSpec_('commission', 'Commission', 0),
        'determinationMethod': MemberSpec_('determinationMethod', 'DeterminationMethod', 0),
        'grossPrice': MemberSpec_('grossPrice', 'ActualPrice', 0),
        'netPrice': MemberSpec_('netPrice', 'ActualPrice', 0),
        'accruedInterestPrice': MemberSpec_('accruedInterestPrice', 'xsd:decimal', 0),
        'fxConversion': MemberSpec_('fxConversion', 'FxConversion', 0),
        'amountRelativeTo': MemberSpec_('amountRelativeTo', 'AmountReference', 0),
        'grossPrice': MemberSpec_('grossPrice', 'ActualPrice', 0),
        'netPrice': MemberSpec_('netPrice', 'ActualPrice', 0),
        'accruedInterestPrice': MemberSpec_('accruedInterestPrice', 'xsd:decimal', 0),
        'fxConversion': MemberSpec_('fxConversion', 'FxConversion', 0),
        'cleanNetPrice': MemberSpec_('cleanNetPrice', 'xsd:decimal', 0),
        'quotationCharacteristics': MemberSpec_('quotationCharacteristics', 'QuotationCharacteristics', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, commission=None, determinationMethod=None, grossPrice=None, netPrice=None, accruedInterestPrice=None, fxConversion=None, amountRelativeTo=None, cleanNetPrice=None, quotationCharacteristics=None):
        self.original_tagname_ = None
        self.commission = commission
        self.determinationMethod = determinationMethod
        self.grossPrice = grossPrice
        self.netPrice = netPrice
        self.accruedInterestPrice = accruedInterestPrice
        self.fxConversion = fxConversion
        self.amountRelativeTo = amountRelativeTo
        self.grossPrice = grossPrice
        self.netPrice = netPrice
        self.accruedInterestPrice = accruedInterestPrice
        self.fxConversion = fxConversion
        self.cleanNetPrice = cleanNetPrice
        self.quotationCharacteristics = quotationCharacteristics
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Price)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Price.subclass:
            return Price.subclass(*args_, **kwargs_)
        else:
            return Price(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commission(self): return self.commission
    def set_commission(self, commission): self.commission = commission
    def get_determinationMethod(self): return self.determinationMethod
    def set_determinationMethod(self, determinationMethod): self.determinationMethod = determinationMethod
    def get_grossPrice(self): return self.grossPrice
    def set_grossPrice(self, grossPrice): self.grossPrice = grossPrice
    def get_netPrice(self): return self.netPrice
    def set_netPrice(self, netPrice): self.netPrice = netPrice
    def get_accruedInterestPrice(self): return self.accruedInterestPrice
    def set_accruedInterestPrice(self, accruedInterestPrice): self.accruedInterestPrice = accruedInterestPrice
    def get_fxConversion(self): return self.fxConversion
    def set_fxConversion(self, fxConversion): self.fxConversion = fxConversion
    def get_amountRelativeTo(self): return self.amountRelativeTo
    def set_amountRelativeTo(self, amountRelativeTo): self.amountRelativeTo = amountRelativeTo
    def get_grossPrice(self): return self.grossPrice
    def set_grossPrice(self, grossPrice): self.grossPrice = grossPrice
    def get_netPrice(self): return self.netPrice
    def set_netPrice(self, netPrice): self.netPrice = netPrice
    def get_accruedInterestPrice(self): return self.accruedInterestPrice
    def set_accruedInterestPrice(self, accruedInterestPrice): self.accruedInterestPrice = accruedInterestPrice
    def get_fxConversion(self): return self.fxConversion
    def set_fxConversion(self, fxConversion): self.fxConversion = fxConversion
    def get_cleanNetPrice(self): return self.cleanNetPrice
    def set_cleanNetPrice(self, cleanNetPrice): self.cleanNetPrice = cleanNetPrice
    def get_quotationCharacteristics(self): return self.quotationCharacteristics
    def set_quotationCharacteristics(self, quotationCharacteristics): self.quotationCharacteristics = quotationCharacteristics
    def hasContent_(self):
        if (
            self.commission is not None or
            self.determinationMethod is not None or
            self.grossPrice is not None or
            self.netPrice is not None or
            self.accruedInterestPrice is not None or
            self.fxConversion is not None or
            self.amountRelativeTo is not None or
            self.grossPrice is not None or
            self.netPrice is not None or
            self.accruedInterestPrice is not None or
            self.fxConversion is not None or
            self.cleanNetPrice is not None or
            self.quotationCharacteristics is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Price', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Price')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Price', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Price'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Price', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.commission is not None:
            self.commission.export(outfile, level, namespace_, name_='commission', pretty_print=pretty_print)
        if self.determinationMethod is not None:
            self.determinationMethod.export(outfile, level, namespace_, name_='determinationMethod', pretty_print=pretty_print)
        if self.grossPrice is not None:
            self.grossPrice.export(outfile, level, namespace_, name_='grossPrice', pretty_print=pretty_print)
        if self.netPrice is not None:
            self.netPrice.export(outfile, level, namespace_, name_='netPrice', pretty_print=pretty_print)
        if self.accruedInterestPrice is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saccruedInterestPrice>%s</%saccruedInterestPrice>%s' % (namespace_, self.gds_format_float(self.accruedInterestPrice, input_name='accruedInterestPrice'), namespace_, eol_))
        if self.fxConversion is not None:
            self.fxConversion.export(outfile, level, namespace_, name_='fxConversion', pretty_print=pretty_print)
        if self.amountRelativeTo is not None:
            self.amountRelativeTo.export(outfile, level, namespace_, name_='amountRelativeTo', pretty_print=pretty_print)
        if self.grossPrice is not None:
            self.grossPrice.export(outfile, level, namespace_, name_='grossPrice', pretty_print=pretty_print)
        if self.netPrice is not None:
            self.netPrice.export(outfile, level, namespace_, name_='netPrice', pretty_print=pretty_print)
        if self.accruedInterestPrice is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saccruedInterestPrice>%s</%saccruedInterestPrice>%s' % (namespace_, self.gds_format_float(self.accruedInterestPrice, input_name='accruedInterestPrice'), namespace_, eol_))
        if self.fxConversion is not None:
            self.fxConversion.export(outfile, level, namespace_, name_='fxConversion', pretty_print=pretty_print)
        if self.cleanNetPrice is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scleanNetPrice>%s</%scleanNetPrice>%s' % (namespace_, self.gds_format_float(self.cleanNetPrice, input_name='cleanNetPrice'), namespace_, eol_))
        if self.quotationCharacteristics is not None:
            self.quotationCharacteristics.export(outfile, level, namespace_, name_='quotationCharacteristics', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'commission':
            obj_ = Commission.factory()
            obj_.build(child_)
            self.commission = obj_
            obj_.original_tagname_ = 'commission'
        elif nodeName_ == 'determinationMethod':
            obj_ = DeterminationMethod.factory()
            obj_.build(child_)
            self.determinationMethod = obj_
            obj_.original_tagname_ = 'determinationMethod'
        elif nodeName_ == 'grossPrice':
            obj_ = ActualPrice.factory()
            obj_.build(child_)
            self.grossPrice = obj_
            obj_.original_tagname_ = 'grossPrice'
        elif nodeName_ == 'netPrice':
            obj_ = ActualPrice.factory()
            obj_.build(child_)
            self.netPrice = obj_
            obj_.original_tagname_ = 'netPrice'
        elif nodeName_ == 'accruedInterestPrice':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'accruedInterestPrice')
            self.accruedInterestPrice = fval_
        elif nodeName_ == 'fxConversion':
            obj_ = FxConversion.factory()
            obj_.build(child_)
            self.fxConversion = obj_
            obj_.original_tagname_ = 'fxConversion'
        elif nodeName_ == 'amountRelativeTo':
            obj_ = AmountReference.factory()
            obj_.build(child_)
            self.amountRelativeTo = obj_
            obj_.original_tagname_ = 'amountRelativeTo'
        elif nodeName_ == 'grossPrice':
            obj_ = ActualPrice.factory()
            obj_.build(child_)
            self.grossPrice = obj_
            obj_.original_tagname_ = 'grossPrice'
        elif nodeName_ == 'netPrice':
            obj_ = ActualPrice.factory()
            obj_.build(child_)
            self.netPrice = obj_
            obj_.original_tagname_ = 'netPrice'
        elif nodeName_ == 'accruedInterestPrice':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'accruedInterestPrice')
            self.accruedInterestPrice = fval_
        elif nodeName_ == 'fxConversion':
            obj_ = FxConversion.factory()
            obj_.build(child_)
            self.fxConversion = obj_
            obj_.original_tagname_ = 'fxConversion'
        elif nodeName_ == 'cleanNetPrice':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'cleanNetPrice')
            self.cleanNetPrice = fval_
        elif nodeName_ == 'quotationCharacteristics':
            obj_ = QuotationCharacteristics.factory()
            obj_.build(child_)
            self.quotationCharacteristics = obj_
            obj_.original_tagname_ = 'quotationCharacteristics'
# end class Price


class PriceQuoteUnits(GeneratedsSuper):
    """The units in which a price is quoted."""
    member_data_items_ = {
        'priceQuoteUnitsScheme': MemberSpec_('priceQuoteUnitsScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, priceQuoteUnitsScheme='http://www.fpml.org/coding-scheme/price-quote-units', valueOf_=None):
        self.original_tagname_ = None
        self.priceQuoteUnitsScheme = _cast(None, priceQuoteUnitsScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PriceQuoteUnits)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PriceQuoteUnits.subclass:
            return PriceQuoteUnits.subclass(*args_, **kwargs_)
        else:
            return PriceQuoteUnits(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_priceQuoteUnitsScheme(self): return self.priceQuoteUnitsScheme
    def set_priceQuoteUnitsScheme(self, priceQuoteUnitsScheme): self.priceQuoteUnitsScheme = priceQuoteUnitsScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PriceQuoteUnits', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PriceQuoteUnits')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PriceQuoteUnits', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PriceQuoteUnits'):
        if self.priceQuoteUnitsScheme != "http://www.fpml.org/coding-scheme/price-quote-units" and 'priceQuoteUnitsScheme' not in already_processed:
            already_processed.add('priceQuoteUnitsScheme')
            outfile.write(' priceQuoteUnitsScheme=%s' % (quote_attrib(self.priceQuoteUnitsScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PriceQuoteUnits', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('priceQuoteUnitsScheme', node)
        if value is not None and 'priceQuoteUnitsScheme' not in already_processed:
            already_processed.add('priceQuoteUnitsScheme')
            self.priceQuoteUnitsScheme = value
            self.validate_NonEmptyURI(self.priceQuoteUnitsScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PriceQuoteUnits


class PricingModel(GeneratedsSuper):
    """A scheme identifying the types of pricing model used to evaluate the
    price of an asset. Examples include Intrinsic, ClosedForm,
    MonteCarlo, BackwardInduction."""
    member_data_items_ = {
        'pricingModelScheme': MemberSpec_('pricingModelScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, pricingModelScheme='http://www.fpml.org/coding-scheme/pricing-model', valueOf_=None):
        self.original_tagname_ = None
        self.pricingModelScheme = _cast(None, pricingModelScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PricingModel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PricingModel.subclass:
            return PricingModel.subclass(*args_, **kwargs_)
        else:
            return PricingModel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pricingModelScheme(self): return self.pricingModelScheme
    def set_pricingModelScheme(self, pricingModelScheme): self.pricingModelScheme = pricingModelScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PricingModel', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PricingModel')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PricingModel', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PricingModel'):
        if self.pricingModelScheme != "http://www.fpml.org/coding-scheme/pricing-model" and 'pricingModelScheme' not in already_processed:
            already_processed.add('pricingModelScheme')
            outfile.write(' pricingModelScheme=%s' % (quote_attrib(self.pricingModelScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PricingModel', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pricingModelScheme', node)
        if value is not None and 'pricingModelScheme' not in already_processed:
            already_processed.add('pricingModelScheme')
            self.pricingModelScheme = value
            self.validate_NonEmptyURI(self.pricingModelScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PricingModel


class QuantityUnit(GeneratedsSuper):
    member_data_items_ = {
        'quantityUnitScheme': MemberSpec_('quantityUnitScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, quantityUnitScheme='http://www.fpml.org/coding-scheme/price-quote-units', valueOf_=None):
        self.original_tagname_ = None
        self.quantityUnitScheme = _cast(None, quantityUnitScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QuantityUnit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QuantityUnit.subclass:
            return QuantityUnit.subclass(*args_, **kwargs_)
        else:
            return QuantityUnit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_quantityUnitScheme(self): return self.quantityUnitScheme
    def set_quantityUnitScheme(self, quantityUnitScheme): self.quantityUnitScheme = quantityUnitScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QuantityUnit', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QuantityUnit')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QuantityUnit', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QuantityUnit'):
        if self.quantityUnitScheme != "http://www.fpml.org/coding-scheme/price-quote-units" and 'quantityUnitScheme' not in already_processed:
            already_processed.add('quantityUnitScheme')
            outfile.write(' quantityUnitScheme=%s' % (quote_attrib(self.quantityUnitScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QuantityUnit', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('quantityUnitScheme', node)
        if value is not None and 'quantityUnitScheme' not in already_processed:
            already_processed.add('quantityUnitScheme')
            self.quantityUnitScheme = value
            self.validate_NonEmptyURI(self.quantityUnitScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class QuantityUnit


class QuotationCharacteristics(GeneratedsSuper):
    """A type representing a set of characteristics that describe a
    quotation."""
    member_data_items_ = {
        'measureType': MemberSpec_('measureType', 'AssetMeasureType', 0),
        'quoteUnits': MemberSpec_('quoteUnits', 'PriceQuoteUnits', 0),
        'side': MemberSpec_('side', ['QuotationSideEnum', 'Token', 'xsd:token'], 0),
        'currency': MemberSpec_('currency', 'Currency', 0),
        'currencyType': MemberSpec_('currencyType', 'ReportingCurrencyType', 0),
        'timing': MemberSpec_('timing', 'QuoteTiming', 0),
        'businessCenter': MemberSpec_('businessCenter', 'BusinessCenter', 0),
        'exchangeId': MemberSpec_('exchangeId', 'ExchangeId', 0),
        'informationSource': MemberSpec_('informationSource', 'InformationSource', 1),
        'pricingModel': MemberSpec_('pricingModel', 'PricingModel', 0),
        'time': MemberSpec_('time', 'xsd:dateTime', 0),
        'valuationDate': MemberSpec_('valuationDate', 'xsd:date', 0),
        'expiryTime': MemberSpec_('expiryTime', 'xsd:dateTime', 0),
        'cashflowType': MemberSpec_('cashflowType', 'CashflowType', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, measureType=None, quoteUnits=None, side=None, currency=None, currencyType=None, timing=None, businessCenter=None, exchangeId=None, informationSource=None, pricingModel=None, time=None, valuationDate=None, expiryTime=None, cashflowType=None):
        self.original_tagname_ = None
        self.measureType = measureType
        self.quoteUnits = quoteUnits
        self.side = side
        self.validate_QuotationSideEnum(self.side)
        self.currency = currency
        self.currencyType = currencyType
        self.timing = timing
        self.businessCenter = businessCenter
        self.exchangeId = exchangeId
        if informationSource is None:
            self.informationSource = []
        else:
            self.informationSource = informationSource
        self.pricingModel = pricingModel
        if isinstance(time, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(time, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = time
        self.time = initvalue_
        if isinstance(valuationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(valuationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = valuationDate
        self.valuationDate = initvalue_
        if isinstance(expiryTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(expiryTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = expiryTime
        self.expiryTime = initvalue_
        self.cashflowType = cashflowType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QuotationCharacteristics)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QuotationCharacteristics.subclass:
            return QuotationCharacteristics.subclass(*args_, **kwargs_)
        else:
            return QuotationCharacteristics(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_measureType(self): return self.measureType
    def set_measureType(self, measureType): self.measureType = measureType
    def get_quoteUnits(self): return self.quoteUnits
    def set_quoteUnits(self, quoteUnits): self.quoteUnits = quoteUnits
    def get_side(self): return self.side
    def set_side(self, side): self.side = side
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_currencyType(self): return self.currencyType
    def set_currencyType(self, currencyType): self.currencyType = currencyType
    def get_timing(self): return self.timing
    def set_timing(self, timing): self.timing = timing
    def get_businessCenter(self): return self.businessCenter
    def set_businessCenter(self, businessCenter): self.businessCenter = businessCenter
    def get_exchangeId(self): return self.exchangeId
    def set_exchangeId(self, exchangeId): self.exchangeId = exchangeId
    def get_informationSource(self): return self.informationSource
    def set_informationSource(self, informationSource): self.informationSource = informationSource
    def add_informationSource(self, value): self.informationSource.append(value)
    def insert_informationSource_at(self, index, value): self.informationSource.insert(index, value)
    def replace_informationSource_at(self, index, value): self.informationSource[index] = value
    def get_pricingModel(self): return self.pricingModel
    def set_pricingModel(self, pricingModel): self.pricingModel = pricingModel
    def get_time(self): return self.time
    def set_time(self, time): self.time = time
    def get_valuationDate(self): return self.valuationDate
    def set_valuationDate(self, valuationDate): self.valuationDate = valuationDate
    def get_expiryTime(self): return self.expiryTime
    def set_expiryTime(self, expiryTime): self.expiryTime = expiryTime
    def get_cashflowType(self): return self.cashflowType
    def set_cashflowType(self, cashflowType): self.cashflowType = cashflowType
    def validate_QuotationSideEnum(self, value):
        # Validate type QuotationSideEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Bid', 'Ask', 'Mid']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on QuotationSideEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on QuotationSideEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.measureType is not None or
            self.quoteUnits is not None or
            self.side is not None or
            self.currency is not None or
            self.currencyType is not None or
            self.timing is not None or
            self.businessCenter is not None or
            self.exchangeId is not None or
            self.informationSource or
            self.pricingModel is not None or
            self.time is not None or
            self.valuationDate is not None or
            self.expiryTime is not None or
            self.cashflowType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QuotationCharacteristics', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QuotationCharacteristics')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QuotationCharacteristics', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QuotationCharacteristics'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='QuotationCharacteristics', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.measureType is not None:
            self.measureType.export(outfile, level, namespace_, name_='measureType', pretty_print=pretty_print)
        if self.quoteUnits is not None:
            self.quoteUnits.export(outfile, level, namespace_, name_='quoteUnits', pretty_print=pretty_print)
        if self.side is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sside>%s</%sside>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.side), input_name='side')), namespace_, eol_))
        if self.currency is not None:
            self.currency.export(outfile, level, namespace_, name_='currency', pretty_print=pretty_print)
        if self.currencyType is not None:
            self.currencyType.export(outfile, level, namespace_, name_='currencyType', pretty_print=pretty_print)
        if self.timing is not None:
            self.timing.export(outfile, level, namespace_, name_='timing', pretty_print=pretty_print)
        if self.businessCenter is not None:
            self.businessCenter.export(outfile, level, namespace_, name_='businessCenter', pretty_print=pretty_print)
        if self.exchangeId is not None:
            self.exchangeId.export(outfile, level, namespace_, name_='exchangeId', pretty_print=pretty_print)
        for informationSource_ in self.informationSource:
            informationSource_.export(outfile, level, namespace_, name_='informationSource', pretty_print=pretty_print)
        if self.pricingModel is not None:
            self.pricingModel.export(outfile, level, namespace_, name_='pricingModel', pretty_print=pretty_print)
        if self.time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stime>%s</%stime>%s' % (namespace_, self.gds_format_datetime(self.time, input_name='time'), namespace_, eol_))
        if self.valuationDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svaluationDate>%s</%svaluationDate>%s' % (namespace_, self.gds_format_date(self.valuationDate, input_name='valuationDate'), namespace_, eol_))
        if self.expiryTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexpiryTime>%s</%sexpiryTime>%s' % (namespace_, self.gds_format_datetime(self.expiryTime, input_name='expiryTime'), namespace_, eol_))
        if self.cashflowType is not None:
            self.cashflowType.export(outfile, level, namespace_, name_='cashflowType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'measureType':
            obj_ = AssetMeasureType.factory()
            obj_.build(child_)
            self.measureType = obj_
            obj_.original_tagname_ = 'measureType'
        elif nodeName_ == 'quoteUnits':
            obj_ = PriceQuoteUnits.factory()
            obj_.build(child_)
            self.quoteUnits = obj_
            obj_.original_tagname_ = 'quoteUnits'
        elif nodeName_ == 'side':
            side_ = child_.text
            side_ = re_.sub(String_cleanup_pat_, " ", side_).strip()
            side_ = self.gds_validate_string(side_, node, 'side')
            self.side = side_
            # validate type QuotationSideEnum
            self.validate_QuotationSideEnum(self.side)
        elif nodeName_ == 'currency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'currencyType':
            obj_ = ReportingCurrencyType.factory()
            obj_.build(child_)
            self.currencyType = obj_
            obj_.original_tagname_ = 'currencyType'
        elif nodeName_ == 'timing':
            obj_ = QuoteTiming.factory()
            obj_.build(child_)
            self.timing = obj_
            obj_.original_tagname_ = 'timing'
        elif nodeName_ == 'businessCenter':
            obj_ = BusinessCenter.factory()
            obj_.build(child_)
            self.businessCenter = obj_
            obj_.original_tagname_ = 'businessCenter'
        elif nodeName_ == 'exchangeId':
            obj_ = ExchangeId.factory()
            obj_.build(child_)
            self.exchangeId = obj_
            obj_.original_tagname_ = 'exchangeId'
        elif nodeName_ == 'informationSource':
            class_obj_ = self.get_class_obj_(child_, InformationSource)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.informationSource.append(obj_)
            obj_.original_tagname_ = 'informationSource'
        elif nodeName_ == 'pricingModel':
            obj_ = PricingModel.factory()
            obj_.build(child_)
            self.pricingModel = obj_
            obj_.original_tagname_ = 'pricingModel'
        elif nodeName_ == 'time':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.time = dval_
        elif nodeName_ == 'valuationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.valuationDate = dval_
        elif nodeName_ == 'expiryTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.expiryTime = dval_
        elif nodeName_ == 'cashflowType':
            obj_ = CashflowType.factory()
            obj_.build(child_)
            self.cashflowType = obj_
            obj_.original_tagname_ = 'cashflowType'
# end class QuotationCharacteristics


class QuoteTiming(GeneratedsSuper):
    """The type of the time of the quote."""
    member_data_items_ = {
        'quoteTimingScheme': MemberSpec_('quoteTimingScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, quoteTimingScheme='http://www.fpml.org/coding-scheme/quote-timing', valueOf_=None):
        self.original_tagname_ = None
        self.quoteTimingScheme = _cast(None, quoteTimingScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QuoteTiming)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QuoteTiming.subclass:
            return QuoteTiming.subclass(*args_, **kwargs_)
        else:
            return QuoteTiming(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_quoteTimingScheme(self): return self.quoteTimingScheme
    def set_quoteTimingScheme(self, quoteTimingScheme): self.quoteTimingScheme = quoteTimingScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QuoteTiming', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QuoteTiming')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QuoteTiming', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QuoteTiming'):
        if self.quoteTimingScheme != "http://www.fpml.org/coding-scheme/quote-timing" and 'quoteTimingScheme' not in already_processed:
            already_processed.add('quoteTimingScheme')
            outfile.write(' quoteTimingScheme=%s' % (quote_attrib(self.quoteTimingScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QuoteTiming', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('quoteTimingScheme', node)
        if value is not None and 'quoteTimingScheme' not in already_processed:
            already_processed.add('quoteTimingScheme')
            self.quoteTimingScheme = value
            self.validate_NonEmptyURI(self.quoteTimingScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class QuoteTiming


class ReportingCurrencyType(GeneratedsSuper):
    """A scheme identifying the type of currency that was used to report
    the value of an asset. For example, this could contain values
    like SettlementCurrency, QuoteCurrency, UnitCurrency, etc."""
    member_data_items_ = {
        'reportingCurrencyTypeScheme': MemberSpec_('reportingCurrencyTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, reportingCurrencyTypeScheme='http://www.fpml.org/coding-scheme/reporting-currency-type', valueOf_=None):
        self.original_tagname_ = None
        self.reportingCurrencyTypeScheme = _cast(None, reportingCurrencyTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReportingCurrencyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReportingCurrencyType.subclass:
            return ReportingCurrencyType.subclass(*args_, **kwargs_)
        else:
            return ReportingCurrencyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_reportingCurrencyTypeScheme(self): return self.reportingCurrencyTypeScheme
    def set_reportingCurrencyTypeScheme(self, reportingCurrencyTypeScheme): self.reportingCurrencyTypeScheme = reportingCurrencyTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReportingCurrencyType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReportingCurrencyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReportingCurrencyType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReportingCurrencyType'):
        if self.reportingCurrencyTypeScheme != "http://www.fpml.org/coding-scheme/reporting-currency-type" and 'reportingCurrencyTypeScheme' not in already_processed:
            already_processed.add('reportingCurrencyTypeScheme')
            outfile.write(' reportingCurrencyTypeScheme=%s' % (quote_attrib(self.reportingCurrencyTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ReportingCurrencyType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('reportingCurrencyTypeScheme', node)
        if value is not None and 'reportingCurrencyTypeScheme' not in already_processed:
            already_processed.add('reportingCurrencyTypeScheme')
            self.reportingCurrencyTypeScheme = value
            self.validate_NonEmptyURI(self.reportingCurrencyTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReportingCurrencyType


class SingleUnderlyer(GeneratedsSuper):
    """A type describing a single underlyer"""
    member_data_items_ = {
        'underlyingAsset': MemberSpec_('underlyingAsset', 'Asset', 0),
        'openUnits': MemberSpec_('openUnits', 'xsd:decimal', 0),
        'dividendPayout': MemberSpec_('dividendPayout', 'DividendPayout', 0),
        'couponPayment': MemberSpec_('couponPayment', 'PendingPayment', 0),
        'averageDailyTradingVolume': MemberSpec_('averageDailyTradingVolume', 'AverageDailyTradingVolumeLimit', 0),
        'depositoryReceipt': MemberSpec_('depositoryReceipt', 'xsd:boolean', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, underlyingAsset=None, openUnits=None, dividendPayout=None, couponPayment=None, averageDailyTradingVolume=None, depositoryReceipt=None):
        self.original_tagname_ = None
        self.underlyingAsset = underlyingAsset
        self.openUnits = openUnits
        self.dividendPayout = dividendPayout
        self.couponPayment = couponPayment
        self.averageDailyTradingVolume = averageDailyTradingVolume
        self.depositoryReceipt = depositoryReceipt
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SingleUnderlyer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SingleUnderlyer.subclass:
            return SingleUnderlyer.subclass(*args_, **kwargs_)
        else:
            return SingleUnderlyer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_underlyingAsset(self): return self.underlyingAsset
    def set_underlyingAsset(self, underlyingAsset): self.underlyingAsset = underlyingAsset
    def get_openUnits(self): return self.openUnits
    def set_openUnits(self, openUnits): self.openUnits = openUnits
    def get_dividendPayout(self): return self.dividendPayout
    def set_dividendPayout(self, dividendPayout): self.dividendPayout = dividendPayout
    def get_couponPayment(self): return self.couponPayment
    def set_couponPayment(self, couponPayment): self.couponPayment = couponPayment
    def get_averageDailyTradingVolume(self): return self.averageDailyTradingVolume
    def set_averageDailyTradingVolume(self, averageDailyTradingVolume): self.averageDailyTradingVolume = averageDailyTradingVolume
    def get_depositoryReceipt(self): return self.depositoryReceipt
    def set_depositoryReceipt(self, depositoryReceipt): self.depositoryReceipt = depositoryReceipt
    def hasContent_(self):
        if (
            self.underlyingAsset is not None or
            self.openUnits is not None or
            self.dividendPayout is not None or
            self.couponPayment is not None or
            self.averageDailyTradingVolume is not None or
            self.depositoryReceipt is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SingleUnderlyer', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SingleUnderlyer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SingleUnderlyer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SingleUnderlyer'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SingleUnderlyer', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.underlyingAsset is not None:
            self.underlyingAsset.export(outfile, level, namespace_, name_='underlyingAsset', pretty_print=pretty_print)
        if self.openUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sopenUnits>%s</%sopenUnits>%s' % (namespace_, self.gds_format_float(self.openUnits, input_name='openUnits'), namespace_, eol_))
        if self.dividendPayout is not None:
            self.dividendPayout.export(outfile, level, namespace_, name_='dividendPayout', pretty_print=pretty_print)
        if self.couponPayment is not None:
            self.couponPayment.export(outfile, level, namespace_, name_='couponPayment', pretty_print=pretty_print)
        if self.averageDailyTradingVolume is not None:
            self.averageDailyTradingVolume.export(outfile, level, namespace_, name_='averageDailyTradingVolume', pretty_print=pretty_print)
        if self.depositoryReceipt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdepositoryReceipt>%s</%sdepositoryReceipt>%s' % (namespace_, self.gds_format_boolean(self.depositoryReceipt, input_name='depositoryReceipt'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'underlyingAsset':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <underlyingAsset> element')
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'underlyingAsset'
        elif nodeName_ == 'basket':
            obj_ = Basket.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'basket'
        elif nodeName_ == 'bond':
            class_obj_ = self.get_class_obj_(child_, Bond)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'bond'
        elif nodeName_ == 'cash':
            obj_ = Cash.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'cash'
        elif nodeName_ == 'commodity':
            obj_ = Commodity.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'commodity'
        elif nodeName_ == 'convertibleBond':
            obj_ = ConvertibleBond.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'convertibleBond'
        elif nodeName_ == 'equity':
            obj_ = EquityAsset.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'equity'
        elif nodeName_ == 'exchangeTradedFund':
            obj_ = ExchangeTradedFund.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'exchangeTradedFund'
        elif nodeName_ == 'future':
            obj_ = Future.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'future'
        elif nodeName_ == 'index':
            obj_ = Index.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'index'
        elif nodeName_ == 'loan':
            obj_ = Loan.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'loan'
        elif nodeName_ == 'mortgage':
            obj_ = Mortgage.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'mortgage'
        elif nodeName_ == 'mutualFund':
            obj_ = MutualFund.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'mutualFund'
        elif nodeName_ == 'option':
            obj_ = ExchangeTradedOption.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'option'
        elif nodeName_ == 'openUnits':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'openUnits')
            self.openUnits = fval_
        elif nodeName_ == 'dividendPayout':
            obj_ = DividendPayout.factory()
            obj_.build(child_)
            self.dividendPayout = obj_
            obj_.original_tagname_ = 'dividendPayout'
        elif nodeName_ == 'couponPayment':
            obj_ = PendingPayment.factory()
            obj_.build(child_)
            self.couponPayment = obj_
            obj_.original_tagname_ = 'couponPayment'
        elif nodeName_ == 'averageDailyTradingVolume':
            obj_ = AverageDailyTradingVolumeLimit.factory()
            obj_.build(child_)
            self.averageDailyTradingVolume = obj_
            obj_.original_tagname_ = 'averageDailyTradingVolume'
        elif nodeName_ == 'depositoryReceipt':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'depositoryReceipt')
            self.depositoryReceipt = ival_
# end class SingleUnderlyer


class Underlyer(GeneratedsSuper):
    """A type describing the whole set of possible underlyers: single
    underlyers or multiple underlyers, each of these having either
    security or index components."""
    member_data_items_ = {
        'singleUnderlyer': MemberSpec_('singleUnderlyer', 'SingleUnderlyer', 0),
        'basket': MemberSpec_('basket', 'Basket', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, singleUnderlyer=None, basket=None):
        self.original_tagname_ = None
        self.singleUnderlyer = singleUnderlyer
        self.basket = basket
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Underlyer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Underlyer.subclass:
            return Underlyer.subclass(*args_, **kwargs_)
        else:
            return Underlyer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_singleUnderlyer(self): return self.singleUnderlyer
    def set_singleUnderlyer(self, singleUnderlyer): self.singleUnderlyer = singleUnderlyer
    def get_basket(self): return self.basket
    def set_basket(self, basket): self.basket = basket
    def hasContent_(self):
        if (
            self.singleUnderlyer is not None or
            self.basket is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Underlyer', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Underlyer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Underlyer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Underlyer'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Underlyer', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.singleUnderlyer is not None:
            self.singleUnderlyer.export(outfile, level, namespace_, name_='singleUnderlyer', pretty_print=pretty_print)
        if self.basket is not None:
            self.basket.export(outfile, level, namespace_, name_='basket', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'singleUnderlyer':
            obj_ = SingleUnderlyer.factory()
            obj_.build(child_)
            self.singleUnderlyer = obj_
            obj_.original_tagname_ = 'singleUnderlyer'
        elif nodeName_ == 'basket':
            obj_ = Basket.factory()
            obj_.build(child_)
            self.basket = obj_
            obj_.original_tagname_ = 'basket'
# end class Underlyer


class UnderlyingAsset(IdentifiedAsset):
    """Abstract base class for all underlying assets."""
    member_data_items_ = {
        'currency': MemberSpec_('currency', 'IdentifiedCurrency', 0),
        'exchangeId': MemberSpec_('exchangeId', 'ExchangeId', 0),
        'clearanceSystem': MemberSpec_('clearanceSystem', 'ClearanceSystem', 0),
        'definition': MemberSpec_('definition', 'ProductReference', 0),
    }
    subclass = None
    superclass = IdentifiedAsset
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, extensiontype_=None):
        self.original_tagname_ = None
        super(UnderlyingAsset, self).__init__(id, instrumentId, description, extensiontype_, )
        self.currency = currency
        self.exchangeId = exchangeId
        self.clearanceSystem = clearanceSystem
        self.definition = definition
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UnderlyingAsset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UnderlyingAsset.subclass:
            return UnderlyingAsset.subclass(*args_, **kwargs_)
        else:
            return UnderlyingAsset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_exchangeId(self): return self.exchangeId
    def set_exchangeId(self, exchangeId): self.exchangeId = exchangeId
    def get_clearanceSystem(self): return self.clearanceSystem
    def set_clearanceSystem(self, clearanceSystem): self.clearanceSystem = clearanceSystem
    def get_definition(self): return self.definition
    def set_definition(self, definition): self.definition = definition
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.currency is not None or
            self.exchangeId is not None or
            self.clearanceSystem is not None or
            self.definition is not None or
            super(UnderlyingAsset, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='UnderlyingAsset', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UnderlyingAsset')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='UnderlyingAsset', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UnderlyingAsset'):
        super(UnderlyingAsset, self).exportAttributes(outfile, level, already_processed, namespace_, name_='UnderlyingAsset')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='UnderlyingAsset', fromsubclass_=False, pretty_print=True):
        super(UnderlyingAsset, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.currency is not None:
            self.currency.export(outfile, level, namespace_, name_='currency', pretty_print=pretty_print)
        if self.exchangeId is not None:
            self.exchangeId.export(outfile, level, namespace_, name_='exchangeId', pretty_print=pretty_print)
        if self.clearanceSystem is not None:
            self.clearanceSystem.export(outfile, level, namespace_, name_='clearanceSystem', pretty_print=pretty_print)
        if self.definition is not None:
            self.definition.export(outfile, level, namespace_, name_='definition', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(UnderlyingAsset, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'currency':
            obj_ = IdentifiedCurrency.factory()
            obj_.build(child_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'exchangeId':
            obj_ = ExchangeId.factory()
            obj_.build(child_)
            self.exchangeId = obj_
            obj_.original_tagname_ = 'exchangeId'
        elif nodeName_ == 'clearanceSystem':
            obj_ = ClearanceSystem.factory()
            obj_.build(child_)
            self.clearanceSystem = obj_
            obj_.original_tagname_ = 'clearanceSystem'
        elif nodeName_ == 'definition':
            obj_ = ProductReference.factory()
            obj_.build(child_)
            self.definition = obj_
            obj_.original_tagname_ = 'definition'
        super(UnderlyingAsset, self).buildChildren(child_, node, nodeName_, True)
# end class UnderlyingAsset


class UnderlyingAssetTranche(GeneratedsSuper):
    member_data_items_ = {
        'loanTrancheScheme': MemberSpec_('loanTrancheScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, loanTrancheScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.loanTrancheScheme = _cast(None, loanTrancheScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UnderlyingAssetTranche)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UnderlyingAssetTranche.subclass:
            return UnderlyingAssetTranche.subclass(*args_, **kwargs_)
        else:
            return UnderlyingAssetTranche(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_loanTrancheScheme(self): return self.loanTrancheScheme
    def set_loanTrancheScheme(self, loanTrancheScheme): self.loanTrancheScheme = loanTrancheScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='UnderlyingAssetTranche', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UnderlyingAssetTranche')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='UnderlyingAssetTranche', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UnderlyingAssetTranche'):
        if self.loanTrancheScheme is not None and 'loanTrancheScheme' not in already_processed:
            already_processed.add('loanTrancheScheme')
            outfile.write(' loanTrancheScheme=%s' % (quote_attrib(self.loanTrancheScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='UnderlyingAssetTranche', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('loanTrancheScheme', node)
        if value is not None and 'loanTrancheScheme' not in already_processed:
            already_processed.add('loanTrancheScheme')
            self.loanTrancheScheme = value
            self.validate_NonEmptyURI(self.loanTrancheScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class UnderlyingAssetTranche


class UnderlyerLoanRate(GeneratedsSuper):
    """Defines stock loan information where this is required per underlyer.
    You must not duplicate infromation within dividend conditions at
    transaction level"""
    member_data_items_ = {
        'lossOfStockBorrow': MemberSpec_('lossOfStockBorrow', 'xsd:boolean', 0),
        'maximumStockLoanRate': MemberSpec_('maximumStockLoanRate', ['RestrictedPercentage', 'xsd:decimal'], 0),
        'increasedCostOfStockBorrow': MemberSpec_('increasedCostOfStockBorrow', 'xsd:boolean', 0),
        'initialStockLoanRate': MemberSpec_('initialStockLoanRate', ['RestrictedPercentage', 'xsd:decimal'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, lossOfStockBorrow=None, maximumStockLoanRate=None, increasedCostOfStockBorrow=None, initialStockLoanRate=None):
        self.original_tagname_ = None
        self.lossOfStockBorrow = lossOfStockBorrow
        self.maximumStockLoanRate = maximumStockLoanRate
        self.validate_RestrictedPercentage(self.maximumStockLoanRate)
        self.increasedCostOfStockBorrow = increasedCostOfStockBorrow
        self.initialStockLoanRate = initialStockLoanRate
        self.validate_RestrictedPercentage(self.initialStockLoanRate)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UnderlyerLoanRate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UnderlyerLoanRate.subclass:
            return UnderlyerLoanRate.subclass(*args_, **kwargs_)
        else:
            return UnderlyerLoanRate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lossOfStockBorrow(self): return self.lossOfStockBorrow
    def set_lossOfStockBorrow(self, lossOfStockBorrow): self.lossOfStockBorrow = lossOfStockBorrow
    def get_maximumStockLoanRate(self): return self.maximumStockLoanRate
    def set_maximumStockLoanRate(self, maximumStockLoanRate): self.maximumStockLoanRate = maximumStockLoanRate
    def get_increasedCostOfStockBorrow(self): return self.increasedCostOfStockBorrow
    def set_increasedCostOfStockBorrow(self, increasedCostOfStockBorrow): self.increasedCostOfStockBorrow = increasedCostOfStockBorrow
    def get_initialStockLoanRate(self): return self.initialStockLoanRate
    def set_initialStockLoanRate(self, initialStockLoanRate): self.initialStockLoanRate = initialStockLoanRate
    def validate_RestrictedPercentage(self, value):
        # Validate type RestrictedPercentage, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on RestrictedPercentage' % {"value" : value} )
            if value > 1:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on RestrictedPercentage' % {"value" : value} )
    def hasContent_(self):
        if (
            self.lossOfStockBorrow is not None or
            self.maximumStockLoanRate is not None or
            self.increasedCostOfStockBorrow is not None or
            self.initialStockLoanRate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='UnderlyerLoanRate', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UnderlyerLoanRate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='UnderlyerLoanRate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UnderlyerLoanRate'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='UnderlyerLoanRate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.lossOfStockBorrow is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slossOfStockBorrow>%s</%slossOfStockBorrow>%s' % (namespace_, self.gds_format_boolean(self.lossOfStockBorrow, input_name='lossOfStockBorrow'), namespace_, eol_))
        if self.maximumStockLoanRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaximumStockLoanRate>%s</%smaximumStockLoanRate>%s' % (namespace_, self.gds_format_float(self.maximumStockLoanRate, input_name='maximumStockLoanRate'), namespace_, eol_))
        if self.increasedCostOfStockBorrow is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sincreasedCostOfStockBorrow>%s</%sincreasedCostOfStockBorrow>%s' % (namespace_, self.gds_format_boolean(self.increasedCostOfStockBorrow, input_name='increasedCostOfStockBorrow'), namespace_, eol_))
        if self.initialStockLoanRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinitialStockLoanRate>%s</%sinitialStockLoanRate>%s' % (namespace_, self.gds_format_float(self.initialStockLoanRate, input_name='initialStockLoanRate'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'lossOfStockBorrow':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'lossOfStockBorrow')
            self.lossOfStockBorrow = ival_
        elif nodeName_ == 'maximumStockLoanRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'maximumStockLoanRate')
            self.maximumStockLoanRate = fval_
            # validate type RestrictedPercentage
            self.validate_RestrictedPercentage(self.maximumStockLoanRate)
        elif nodeName_ == 'increasedCostOfStockBorrow':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'increasedCostOfStockBorrow')
            self.increasedCostOfStockBorrow = ival_
        elif nodeName_ == 'initialStockLoanRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'initialStockLoanRate')
            self.initialStockLoanRate = fval_
            # validate type RestrictedPercentage
            self.validate_RestrictedPercentage(self.initialStockLoanRate)
# end class UnderlyerLoanRate


class Account(GeneratedsSuper):
    """A generic account that represents any party's account at another
    party. Parties may be identified by the account at another
    party.The unique identifier for the account within the document."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'accountId': MemberSpec_('accountId', 'AccountId', 1),
        'accountName': MemberSpec_('accountName', 'AccountName', 0),
        'accountType': MemberSpec_('accountType', 'AccountType', 0),
        'accountBeneficiary': MemberSpec_('accountBeneficiary', 'PartyReference', 0),
        'servicingParty': MemberSpec_('servicingParty', 'PartyReference', 0),
        'servicingParty': MemberSpec_('servicingParty', 'PartyReference', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, accountId=None, accountName=None, accountType=None, accountBeneficiary=None, servicingParty=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if accountId is None:
            self.accountId = []
        else:
            self.accountId = accountId
        self.accountName = accountName
        self.accountType = accountType
        self.accountBeneficiary = accountBeneficiary
        self.servicingParty = servicingParty
        self.servicingParty = servicingParty
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Account)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Account.subclass:
            return Account.subclass(*args_, **kwargs_)
        else:
            return Account(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_accountId(self): return self.accountId
    def set_accountId(self, accountId): self.accountId = accountId
    def add_accountId(self, value): self.accountId.append(value)
    def insert_accountId_at(self, index, value): self.accountId.insert(index, value)
    def replace_accountId_at(self, index, value): self.accountId[index] = value
    def get_accountName(self): return self.accountName
    def set_accountName(self, accountName): self.accountName = accountName
    def get_accountType(self): return self.accountType
    def set_accountType(self, accountType): self.accountType = accountType
    def get_accountBeneficiary(self): return self.accountBeneficiary
    def set_accountBeneficiary(self, accountBeneficiary): self.accountBeneficiary = accountBeneficiary
    def get_servicingParty(self): return self.servicingParty
    def set_servicingParty(self, servicingParty): self.servicingParty = servicingParty
    def get_servicingParty(self): return self.servicingParty
    def set_servicingParty(self, servicingParty): self.servicingParty = servicingParty
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.accountId or
            self.accountName is not None or
            self.accountType is not None or
            self.accountBeneficiary is not None or
            self.servicingParty is not None or
            self.servicingParty is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Account', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Account')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Account', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Account'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Account', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for accountId_ in self.accountId:
            accountId_.export(outfile, level, namespace_, name_='accountId', pretty_print=pretty_print)
        if self.accountName is not None:
            self.accountName.export(outfile, level, namespace_, name_='accountName', pretty_print=pretty_print)
        if self.accountType is not None:
            self.accountType.export(outfile, level, namespace_, name_='accountType', pretty_print=pretty_print)
        if self.accountBeneficiary is not None:
            self.accountBeneficiary.export(outfile, level, namespace_, name_='accountBeneficiary', pretty_print=pretty_print)
        if self.servicingParty is not None:
            self.servicingParty.export(outfile, level, namespace_, name_='servicingParty', pretty_print=pretty_print)
        if self.servicingParty is not None:
            self.servicingParty.export(outfile, level, namespace_, name_='servicingParty', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'accountId':
            obj_ = AccountId.factory()
            obj_.build(child_)
            self.accountId.append(obj_)
            obj_.original_tagname_ = 'accountId'
        elif nodeName_ == 'accountName':
            obj_ = AccountName.factory()
            obj_.build(child_)
            self.accountName = obj_
            obj_.original_tagname_ = 'accountName'
        elif nodeName_ == 'accountType':
            obj_ = AccountType.factory()
            obj_.build(child_)
            self.accountType = obj_
            obj_.original_tagname_ = 'accountType'
        elif nodeName_ == 'accountBeneficiary':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.accountBeneficiary = obj_
            obj_.original_tagname_ = 'accountBeneficiary'
        elif nodeName_ == 'servicingParty':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.servicingParty = obj_
            obj_.original_tagname_ = 'servicingParty'
        elif nodeName_ == 'servicingParty':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.servicingParty = obj_
            obj_.original_tagname_ = 'servicingParty'
# end class Account


class AccountId(GeneratedsSuper):
    """The data type used for account identifiers.The identifier scheme
    used with this accountId. A unique URI to determine the
    authoritative issuer of these identifiers."""
    member_data_items_ = {
        'accountIdScheme': MemberSpec_('accountIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, accountIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.accountIdScheme = _cast(None, accountIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AccountId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AccountId.subclass:
            return AccountId.subclass(*args_, **kwargs_)
        else:
            return AccountId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_accountIdScheme(self): return self.accountIdScheme
    def set_accountIdScheme(self, accountIdScheme): self.accountIdScheme = accountIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AccountId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AccountId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AccountId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AccountId'):
        if self.accountIdScheme is not None and 'accountIdScheme' not in already_processed:
            already_processed.add('accountIdScheme')
            outfile.write(' accountIdScheme=%s' % (quote_attrib(self.accountIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AccountId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('accountIdScheme', node)
        if value is not None and 'accountIdScheme' not in already_processed:
            already_processed.add('accountIdScheme')
            self.accountIdScheme = value
            self.validate_NonEmptyURI(self.accountIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AccountId


class AccountName(GeneratedsSuper):
    """The data type used for the name of the account.The identifier scheme
    used with this accountName. A unique URI to determine the source
    of the account name."""
    member_data_items_ = {
        'accountNameScheme': MemberSpec_('accountNameScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, accountNameScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.accountNameScheme = _cast(None, accountNameScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AccountName)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AccountName.subclass:
            return AccountName.subclass(*args_, **kwargs_)
        else:
            return AccountName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_accountNameScheme(self): return self.accountNameScheme
    def set_accountNameScheme(self, accountNameScheme): self.accountNameScheme = accountNameScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AccountName', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AccountName')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AccountName', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AccountName'):
        if self.accountNameScheme is not None and 'accountNameScheme' not in already_processed:
            already_processed.add('accountNameScheme')
            outfile.write(' accountNameScheme=%s' % (quote_attrib(self.accountNameScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AccountName', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('accountNameScheme', node)
        if value is not None and 'accountNameScheme' not in already_processed:
            already_processed.add('accountNameScheme')
            self.accountNameScheme = value
            self.validate_NonEmptyURI(self.accountNameScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AccountName


class AccountType(GeneratedsSuper):
    """The data type used for account type.The identifier scheme used with
    this accountType. A unique URI to determine the the type of
    account."""
    member_data_items_ = {
        'accountTypeScheme': MemberSpec_('accountTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, accountTypeScheme='http://www.fpml.org/coding-scheme/account-type', valueOf_=None):
        self.original_tagname_ = None
        self.accountTypeScheme = _cast(None, accountTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AccountType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AccountType.subclass:
            return AccountType.subclass(*args_, **kwargs_)
        else:
            return AccountType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_accountTypeScheme(self): return self.accountTypeScheme
    def set_accountTypeScheme(self, accountTypeScheme): self.accountTypeScheme = accountTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AccountType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AccountType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AccountType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AccountType'):
        if self.accountTypeScheme != "http://www.fpml.org/coding-scheme/account-type" and 'accountTypeScheme' not in already_processed:
            already_processed.add('accountTypeScheme')
            outfile.write(' accountTypeScheme=%s' % (quote_attrib(self.accountTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AccountType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('accountTypeScheme', node)
        if value is not None and 'accountTypeScheme' not in already_processed:
            already_processed.add('accountTypeScheme')
            self.accountTypeScheme = value
            self.validate_NonEmptyURI(self.accountTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AccountType


class ActionType(GeneratedsSuper):
    """The data type used for ESMA action type.The identifier scheme used
    with this actionType. A unique URI to determine the the type of
    action."""
    member_data_items_ = {
        'actionTypeScheme': MemberSpec_('actionTypeScheme', 'xsd:anyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, actionTypeScheme='http://www.fpml.org/coding-scheme/action-type', valueOf_=None):
        self.original_tagname_ = None
        self.actionTypeScheme = _cast(None, actionTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ActionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ActionType.subclass:
            return ActionType.subclass(*args_, **kwargs_)
        else:
            return ActionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_actionTypeScheme(self): return self.actionTypeScheme
    def set_actionTypeScheme(self, actionTypeScheme): self.actionTypeScheme = actionTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ActionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ActionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ActionType'):
        if self.actionTypeScheme != "http://www.fpml.org/coding-scheme/action-type" and 'actionTypeScheme' not in already_processed:
            already_processed.add('actionTypeScheme')
            outfile.write(' actionTypeScheme=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actionTypeScheme), input_name='actionTypeScheme')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ActionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('actionTypeScheme', node)
        if value is not None and 'actionTypeScheme' not in already_processed:
            already_processed.add('actionTypeScheme')
            self.actionTypeScheme = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ActionType


class Address(GeneratedsSuper):
    """A type that represents a physical postal address."""
    member_data_items_ = {
        'streetAddress': MemberSpec_('streetAddress', 'StreetAddress', 0),
        'city': MemberSpec_('city', ['String', 'xsd:string'], 0),
        'state': MemberSpec_('state', ['String', 'xsd:string'], 0),
        'country': MemberSpec_('country', 'CountryCode', 0),
        'postalCode': MemberSpec_('postalCode', ['String', 'xsd:string'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, streetAddress=None, city=None, state=None, country=None, postalCode=None):
        self.original_tagname_ = None
        self.streetAddress = streetAddress
        self.city = city
        self.validate_String(self.city)
        self.state = state
        self.validate_String(self.state)
        self.country = country
        self.postalCode = postalCode
        self.validate_String(self.postalCode)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Address)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Address.subclass:
            return Address.subclass(*args_, **kwargs_)
        else:
            return Address(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_streetAddress(self): return self.streetAddress
    def set_streetAddress(self, streetAddress): self.streetAddress = streetAddress
    def get_city(self): return self.city
    def set_city(self, city): self.city = city
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def get_country(self): return self.country
    def set_country(self, country): self.country = country
    def get_postalCode(self): return self.postalCode
    def set_postalCode(self, postalCode): self.postalCode = postalCode
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.streetAddress is not None or
            self.city is not None or
            self.state is not None or
            self.country is not None or
            self.postalCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Address', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Address')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Address', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Address'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Address', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.streetAddress is not None:
            self.streetAddress.export(outfile, level, namespace_, name_='streetAddress', pretty_print=pretty_print)
        if self.city is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scity>%s</%scity>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.city), input_name='city')), namespace_, eol_))
        if self.state is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstate>%s</%sstate>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.state), input_name='state')), namespace_, eol_))
        if self.country is not None:
            self.country.export(outfile, level, namespace_, name_='country', pretty_print=pretty_print)
        if self.postalCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spostalCode>%s</%spostalCode>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.postalCode), input_name='postalCode')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'streetAddress':
            obj_ = StreetAddress.factory()
            obj_.build(child_)
            self.streetAddress = obj_
            obj_.original_tagname_ = 'streetAddress'
        elif nodeName_ == 'city':
            city_ = child_.text
            city_ = self.gds_validate_string(city_, node, 'city')
            self.city = city_
            # validate type String
            self.validate_String(self.city)
        elif nodeName_ == 'state':
            state_ = child_.text
            state_ = self.gds_validate_string(state_, node, 'state')
            self.state = state_
            # validate type String
            self.validate_String(self.state)
        elif nodeName_ == 'country':
            obj_ = CountryCode.factory()
            obj_.build(child_)
            self.country = obj_
            obj_.original_tagname_ = 'country'
        elif nodeName_ == 'postalCode':
            postalCode_ = child_.text
            postalCode_ = self.gds_validate_string(postalCode_, node, 'postalCode')
            self.postalCode = postalCode_
            # validate type String
            self.validate_String(self.postalCode)
# end class Address


class AdjustableDate(GeneratedsSuper):
    """A type for defining a date that shall be subject to adjustment if it
    would otherwise fall on a day that is not a business day in the
    specified business centers, together with the convention for
    adjusting the date."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'unadjustedDate': MemberSpec_('unadjustedDate', 'IdentifiedDate', 0),
        'dateAdjustments': MemberSpec_('dateAdjustments', 'BusinessDayAdjustments', 0),
        'adjustedDate': MemberSpec_('adjustedDate', 'IdentifiedDate', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, unadjustedDate=None, dateAdjustments=None, adjustedDate=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.unadjustedDate = unadjustedDate
        self.dateAdjustments = dateAdjustments
        self.adjustedDate = adjustedDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdjustableDate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdjustableDate.subclass:
            return AdjustableDate.subclass(*args_, **kwargs_)
        else:
            return AdjustableDate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unadjustedDate(self): return self.unadjustedDate
    def set_unadjustedDate(self, unadjustedDate): self.unadjustedDate = unadjustedDate
    def get_dateAdjustments(self): return self.dateAdjustments
    def set_dateAdjustments(self, dateAdjustments): self.dateAdjustments = dateAdjustments
    def get_adjustedDate(self): return self.adjustedDate
    def set_adjustedDate(self, adjustedDate): self.adjustedDate = adjustedDate
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.unadjustedDate is not None or
            self.dateAdjustments is not None or
            self.adjustedDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AdjustableDate', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdjustableDate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AdjustableDate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AdjustableDate'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AdjustableDate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.unadjustedDate is not None:
            self.unadjustedDate.export(outfile, level, namespace_, name_='unadjustedDate', pretty_print=pretty_print)
        if self.dateAdjustments is not None:
            self.dateAdjustments.export(outfile, level, namespace_, name_='dateAdjustments', pretty_print=pretty_print)
        if self.adjustedDate is not None:
            self.adjustedDate.export(outfile, level, namespace_, name_='adjustedDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'unadjustedDate':
            obj_ = IdentifiedDate.factory()
            obj_.build(child_)
            self.unadjustedDate = obj_
            obj_.original_tagname_ = 'unadjustedDate'
        elif nodeName_ == 'dateAdjustments':
            obj_ = BusinessDayAdjustments.factory()
            obj_.build(child_)
            self.dateAdjustments = obj_
            obj_.original_tagname_ = 'dateAdjustments'
        elif nodeName_ == 'adjustedDate':
            obj_ = IdentifiedDate.factory()
            obj_.build(child_)
            self.adjustedDate = obj_
            obj_.original_tagname_ = 'adjustedDate'
# end class AdjustableDate


class AdjustableDate2(GeneratedsSuper):
    """A type that is different from AdjustableDate in two regards. First,
    date adjustments can be specified with either a dateAdjustments
    element or a reference to an existing dateAdjustments element.
    Second, it does not require the specification of date
    adjustments."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'unadjustedDate': MemberSpec_('unadjustedDate', 'IdentifiedDate', 0),
        'dateAdjustments': MemberSpec_('dateAdjustments', 'BusinessDayAdjustments', 0),
        'dateAdjustmentsReference': MemberSpec_('dateAdjustmentsReference', 'BusinessDayAdjustmentsReference', 0),
        'adjustedDate': MemberSpec_('adjustedDate', 'IdentifiedDate', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, unadjustedDate=None, dateAdjustments=None, dateAdjustmentsReference=None, adjustedDate=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.unadjustedDate = unadjustedDate
        self.dateAdjustments = dateAdjustments
        self.dateAdjustmentsReference = dateAdjustmentsReference
        self.adjustedDate = adjustedDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdjustableDate2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdjustableDate2.subclass:
            return AdjustableDate2.subclass(*args_, **kwargs_)
        else:
            return AdjustableDate2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unadjustedDate(self): return self.unadjustedDate
    def set_unadjustedDate(self, unadjustedDate): self.unadjustedDate = unadjustedDate
    def get_dateAdjustments(self): return self.dateAdjustments
    def set_dateAdjustments(self, dateAdjustments): self.dateAdjustments = dateAdjustments
    def get_dateAdjustmentsReference(self): return self.dateAdjustmentsReference
    def set_dateAdjustmentsReference(self, dateAdjustmentsReference): self.dateAdjustmentsReference = dateAdjustmentsReference
    def get_adjustedDate(self): return self.adjustedDate
    def set_adjustedDate(self, adjustedDate): self.adjustedDate = adjustedDate
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.unadjustedDate is not None or
            self.dateAdjustments is not None or
            self.dateAdjustmentsReference is not None or
            self.adjustedDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AdjustableDate2', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdjustableDate2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AdjustableDate2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AdjustableDate2'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AdjustableDate2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.unadjustedDate is not None:
            self.unadjustedDate.export(outfile, level, namespace_, name_='unadjustedDate', pretty_print=pretty_print)
        if self.dateAdjustments is not None:
            self.dateAdjustments.export(outfile, level, namespace_, name_='dateAdjustments', pretty_print=pretty_print)
        if self.dateAdjustmentsReference is not None:
            self.dateAdjustmentsReference.export(outfile, level, namespace_, name_='dateAdjustmentsReference', pretty_print=pretty_print)
        if self.adjustedDate is not None:
            self.adjustedDate.export(outfile, level, namespace_, name_='adjustedDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'unadjustedDate':
            obj_ = IdentifiedDate.factory()
            obj_.build(child_)
            self.unadjustedDate = obj_
            obj_.original_tagname_ = 'unadjustedDate'
        elif nodeName_ == 'dateAdjustments':
            obj_ = BusinessDayAdjustments.factory()
            obj_.build(child_)
            self.dateAdjustments = obj_
            obj_.original_tagname_ = 'dateAdjustments'
        elif nodeName_ == 'dateAdjustmentsReference':
            obj_ = BusinessDayAdjustmentsReference.factory()
            obj_.build(child_)
            self.dateAdjustmentsReference = obj_
            obj_.original_tagname_ = 'dateAdjustmentsReference'
        elif nodeName_ == 'adjustedDate':
            obj_ = IdentifiedDate.factory()
            obj_.build(child_)
            self.adjustedDate = obj_
            obj_.original_tagname_ = 'adjustedDate'
# end class AdjustableDate2


class AdjustableDates(GeneratedsSuper):
    """A type for defining a series of dates that shall be subject to
    adjustment if they would otherwise fall on a day that is not a
    business day in the specified business centers, together with
    the convention for adjusting the dates."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'unadjustedDate': MemberSpec_('unadjustedDate', 'IdentifiedDate', 1),
        'dateAdjustments': MemberSpec_('dateAdjustments', 'BusinessDayAdjustments', 0),
        'adjustedDate': MemberSpec_('adjustedDate', 'IdentifiedDate', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, unadjustedDate=None, dateAdjustments=None, adjustedDate=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if unadjustedDate is None:
            self.unadjustedDate = []
        else:
            self.unadjustedDate = unadjustedDate
        self.dateAdjustments = dateAdjustments
        if adjustedDate is None:
            self.adjustedDate = []
        else:
            self.adjustedDate = adjustedDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdjustableDates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdjustableDates.subclass:
            return AdjustableDates.subclass(*args_, **kwargs_)
        else:
            return AdjustableDates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unadjustedDate(self): return self.unadjustedDate
    def set_unadjustedDate(self, unadjustedDate): self.unadjustedDate = unadjustedDate
    def add_unadjustedDate(self, value): self.unadjustedDate.append(value)
    def insert_unadjustedDate_at(self, index, value): self.unadjustedDate.insert(index, value)
    def replace_unadjustedDate_at(self, index, value): self.unadjustedDate[index] = value
    def get_dateAdjustments(self): return self.dateAdjustments
    def set_dateAdjustments(self, dateAdjustments): self.dateAdjustments = dateAdjustments
    def get_adjustedDate(self): return self.adjustedDate
    def set_adjustedDate(self, adjustedDate): self.adjustedDate = adjustedDate
    def add_adjustedDate(self, value): self.adjustedDate.append(value)
    def insert_adjustedDate_at(self, index, value): self.adjustedDate.insert(index, value)
    def replace_adjustedDate_at(self, index, value): self.adjustedDate[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.unadjustedDate or
            self.dateAdjustments is not None or
            self.adjustedDate
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AdjustableDates', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdjustableDates')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AdjustableDates', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AdjustableDates'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AdjustableDates', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for unadjustedDate_ in self.unadjustedDate:
            unadjustedDate_.export(outfile, level, namespace_, name_='unadjustedDate', pretty_print=pretty_print)
        if self.dateAdjustments is not None:
            self.dateAdjustments.export(outfile, level, namespace_, name_='dateAdjustments', pretty_print=pretty_print)
        for adjustedDate_ in self.adjustedDate:
            adjustedDate_.export(outfile, level, namespace_, name_='adjustedDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'unadjustedDate':
            obj_ = IdentifiedDate.factory()
            obj_.build(child_)
            self.unadjustedDate.append(obj_)
            obj_.original_tagname_ = 'unadjustedDate'
        elif nodeName_ == 'dateAdjustments':
            obj_ = BusinessDayAdjustments.factory()
            obj_.build(child_)
            self.dateAdjustments = obj_
            obj_.original_tagname_ = 'dateAdjustments'
        elif nodeName_ == 'adjustedDate':
            obj_ = IdentifiedDate.factory()
            obj_.build(child_)
            self.adjustedDate.append(obj_)
            obj_.original_tagname_ = 'adjustedDate'
# end class AdjustableDates


class AdjustableDatesOrRelativeDateOffset(GeneratedsSuper):
    """A type for defining a series of dates, either as a list of
    adjustable dates, or a as a repeating sequence from a base date"""
    member_data_items_ = {
        'adjustableDates': MemberSpec_('adjustableDates', 'AdjustableDates', 0),
        'relativeDate': MemberSpec_('relativeDate', 'RelativeDateOffset', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, adjustableDates=None, relativeDate=None):
        self.original_tagname_ = None
        self.adjustableDates = adjustableDates
        self.relativeDate = relativeDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdjustableDatesOrRelativeDateOffset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdjustableDatesOrRelativeDateOffset.subclass:
            return AdjustableDatesOrRelativeDateOffset.subclass(*args_, **kwargs_)
        else:
            return AdjustableDatesOrRelativeDateOffset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_adjustableDates(self): return self.adjustableDates
    def set_adjustableDates(self, adjustableDates): self.adjustableDates = adjustableDates
    def get_relativeDate(self): return self.relativeDate
    def set_relativeDate(self, relativeDate): self.relativeDate = relativeDate
    def hasContent_(self):
        if (
            self.adjustableDates is not None or
            self.relativeDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AdjustableDatesOrRelativeDateOffset', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdjustableDatesOrRelativeDateOffset')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AdjustableDatesOrRelativeDateOffset', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AdjustableDatesOrRelativeDateOffset'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AdjustableDatesOrRelativeDateOffset', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.adjustableDates is not None:
            self.adjustableDates.export(outfile, level, namespace_, name_='adjustableDates', pretty_print=pretty_print)
        if self.relativeDate is not None:
            self.relativeDate.export(outfile, level, namespace_, name_='relativeDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'adjustableDates':
            obj_ = AdjustableDates.factory()
            obj_.build(child_)
            self.adjustableDates = obj_
            obj_.original_tagname_ = 'adjustableDates'
        elif nodeName_ == 'relativeDate':
            class_obj_ = self.get_class_obj_(child_, RelativeDateOffset)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.relativeDate = obj_
            obj_.original_tagname_ = 'relativeDate'
# end class AdjustableDatesOrRelativeDateOffset


class AdjustableOrAdjustedDate(GeneratedsSuper):
    """A type for defining a date that shall be subject to adjustment if it
    would otherwise fall on a day that is not a business day in the
    specified business centers, together with the convention for
    adjusting the date."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'unadjustedDate': MemberSpec_('unadjustedDate', 'IdentifiedDate', 0),
        'dateAdjustments': MemberSpec_('dateAdjustments', 'BusinessDayAdjustments', 0),
        'adjustedDate': MemberSpec_('adjustedDate', 'IdentifiedDate', 0),
        'adjustedDate': MemberSpec_('adjustedDate', 'IdentifiedDate', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, unadjustedDate=None, dateAdjustments=None, adjustedDate=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.unadjustedDate = unadjustedDate
        self.dateAdjustments = dateAdjustments
        self.adjustedDate = adjustedDate
        self.adjustedDate = adjustedDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdjustableOrAdjustedDate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdjustableOrAdjustedDate.subclass:
            return AdjustableOrAdjustedDate.subclass(*args_, **kwargs_)
        else:
            return AdjustableOrAdjustedDate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unadjustedDate(self): return self.unadjustedDate
    def set_unadjustedDate(self, unadjustedDate): self.unadjustedDate = unadjustedDate
    def get_dateAdjustments(self): return self.dateAdjustments
    def set_dateAdjustments(self, dateAdjustments): self.dateAdjustments = dateAdjustments
    def get_adjustedDate(self): return self.adjustedDate
    def set_adjustedDate(self, adjustedDate): self.adjustedDate = adjustedDate
    def get_adjustedDate(self): return self.adjustedDate
    def set_adjustedDate(self, adjustedDate): self.adjustedDate = adjustedDate
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.unadjustedDate is not None or
            self.dateAdjustments is not None or
            self.adjustedDate is not None or
            self.adjustedDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AdjustableOrAdjustedDate', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdjustableOrAdjustedDate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AdjustableOrAdjustedDate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AdjustableOrAdjustedDate'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AdjustableOrAdjustedDate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.unadjustedDate is not None:
            self.unadjustedDate.export(outfile, level, namespace_, name_='unadjustedDate', pretty_print=pretty_print)
        if self.dateAdjustments is not None:
            self.dateAdjustments.export(outfile, level, namespace_, name_='dateAdjustments', pretty_print=pretty_print)
        if self.adjustedDate is not None:
            self.adjustedDate.export(outfile, level, namespace_, name_='adjustedDate', pretty_print=pretty_print)
        if self.adjustedDate is not None:
            self.adjustedDate.export(outfile, level, namespace_, name_='adjustedDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'unadjustedDate':
            obj_ = IdentifiedDate.factory()
            obj_.build(child_)
            self.unadjustedDate = obj_
            obj_.original_tagname_ = 'unadjustedDate'
        elif nodeName_ == 'dateAdjustments':
            obj_ = BusinessDayAdjustments.factory()
            obj_.build(child_)
            self.dateAdjustments = obj_
            obj_.original_tagname_ = 'dateAdjustments'
        elif nodeName_ == 'adjustedDate':
            obj_ = IdentifiedDate.factory()
            obj_.build(child_)
            self.adjustedDate = obj_
            obj_.original_tagname_ = 'adjustedDate'
        elif nodeName_ == 'adjustedDate':
            obj_ = IdentifiedDate.factory()
            obj_.build(child_)
            self.adjustedDate = obj_
            obj_.original_tagname_ = 'adjustedDate'
# end class AdjustableOrAdjustedDate


class AdjustableOrRelativeDate(GeneratedsSuper):
    """A type giving the choice between defining a date as an explicit date
    together with applicable adjustments or as relative to some
    other (anchor) date."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'adjustableDate': MemberSpec_('adjustableDate', 'AdjustableDate', 0),
        'relativeDate': MemberSpec_('relativeDate', 'RelativeDateOffset', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, adjustableDate=None, relativeDate=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.adjustableDate = adjustableDate
        self.relativeDate = relativeDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdjustableOrRelativeDate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdjustableOrRelativeDate.subclass:
            return AdjustableOrRelativeDate.subclass(*args_, **kwargs_)
        else:
            return AdjustableOrRelativeDate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_adjustableDate(self): return self.adjustableDate
    def set_adjustableDate(self, adjustableDate): self.adjustableDate = adjustableDate
    def get_relativeDate(self): return self.relativeDate
    def set_relativeDate(self, relativeDate): self.relativeDate = relativeDate
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.adjustableDate is not None or
            self.relativeDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AdjustableOrRelativeDate', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdjustableOrRelativeDate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AdjustableOrRelativeDate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AdjustableOrRelativeDate'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AdjustableOrRelativeDate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.adjustableDate is not None:
            self.adjustableDate.export(outfile, level, namespace_, name_='adjustableDate', pretty_print=pretty_print)
        if self.relativeDate is not None:
            self.relativeDate.export(outfile, level, namespace_, name_='relativeDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'adjustableDate':
            obj_ = AdjustableDate.factory()
            obj_.build(child_)
            self.adjustableDate = obj_
            obj_.original_tagname_ = 'adjustableDate'
        elif nodeName_ == 'relativeDate':
            class_obj_ = self.get_class_obj_(child_, RelativeDateOffset)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.relativeDate = obj_
            obj_.original_tagname_ = 'relativeDate'
# end class AdjustableOrRelativeDate


class AdjustableOrRelativeDates(GeneratedsSuper):
    """A type giving the choice between defining a series of dates as an
    explicit list of dates together with applicable adjustments or
    as relative to some other series of (anchor) dates."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'adjustableDates': MemberSpec_('adjustableDates', 'AdjustableDates', 0),
        'relativeDates': MemberSpec_('relativeDates', 'RelativeDates', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, adjustableDates=None, relativeDates=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.adjustableDates = adjustableDates
        self.relativeDates = relativeDates
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdjustableOrRelativeDates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdjustableOrRelativeDates.subclass:
            return AdjustableOrRelativeDates.subclass(*args_, **kwargs_)
        else:
            return AdjustableOrRelativeDates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_adjustableDates(self): return self.adjustableDates
    def set_adjustableDates(self, adjustableDates): self.adjustableDates = adjustableDates
    def get_relativeDates(self): return self.relativeDates
    def set_relativeDates(self, relativeDates): self.relativeDates = relativeDates
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.adjustableDates is not None or
            self.relativeDates is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AdjustableOrRelativeDates', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdjustableOrRelativeDates')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AdjustableOrRelativeDates', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AdjustableOrRelativeDates'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AdjustableOrRelativeDates', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.adjustableDates is not None:
            self.adjustableDates.export(outfile, level, namespace_, name_='adjustableDates', pretty_print=pretty_print)
        if self.relativeDates is not None:
            self.relativeDates.export(outfile, level, namespace_, name_='relativeDates', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'adjustableDates':
            obj_ = AdjustableDates.factory()
            obj_.build(child_)
            self.adjustableDates = obj_
            obj_.original_tagname_ = 'adjustableDates'
        elif nodeName_ == 'relativeDates':
            obj_ = RelativeDates.factory()
            obj_.build(child_)
            self.relativeDates = obj_
            obj_.original_tagname_ = 'relativeDates'
# end class AdjustableOrRelativeDates


class AdjustableRelativeOrPeriodicDates(GeneratedsSuper):
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'adjustableDates': MemberSpec_('adjustableDates', 'AdjustableDates', 0),
        'relativeDates': MemberSpec_('relativeDates', 'RelativeDates', 0),
        'relativeDateSequence': MemberSpec_('relativeDateSequence', 'RelativeDateSequence', 0),
        'periodicDates': MemberSpec_('periodicDates', 'PeriodicDates', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, adjustableDates=None, relativeDates=None, relativeDateSequence=None, periodicDates=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.adjustableDates = adjustableDates
        self.relativeDates = relativeDates
        self.relativeDateSequence = relativeDateSequence
        self.periodicDates = periodicDates
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdjustableRelativeOrPeriodicDates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdjustableRelativeOrPeriodicDates.subclass:
            return AdjustableRelativeOrPeriodicDates.subclass(*args_, **kwargs_)
        else:
            return AdjustableRelativeOrPeriodicDates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_adjustableDates(self): return self.adjustableDates
    def set_adjustableDates(self, adjustableDates): self.adjustableDates = adjustableDates
    def get_relativeDates(self): return self.relativeDates
    def set_relativeDates(self, relativeDates): self.relativeDates = relativeDates
    def get_relativeDateSequence(self): return self.relativeDateSequence
    def set_relativeDateSequence(self, relativeDateSequence): self.relativeDateSequence = relativeDateSequence
    def get_periodicDates(self): return self.periodicDates
    def set_periodicDates(self, periodicDates): self.periodicDates = periodicDates
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.adjustableDates is not None or
            self.relativeDates is not None or
            self.relativeDateSequence is not None or
            self.periodicDates is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AdjustableRelativeOrPeriodicDates', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdjustableRelativeOrPeriodicDates')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AdjustableRelativeOrPeriodicDates', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AdjustableRelativeOrPeriodicDates'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AdjustableRelativeOrPeriodicDates', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.adjustableDates is not None:
            self.adjustableDates.export(outfile, level, namespace_, name_='adjustableDates', pretty_print=pretty_print)
        if self.relativeDates is not None:
            self.relativeDates.export(outfile, level, namespace_, name_='relativeDates', pretty_print=pretty_print)
        if self.relativeDateSequence is not None:
            self.relativeDateSequence.export(outfile, level, namespace_, name_='relativeDateSequence', pretty_print=pretty_print)
        if self.periodicDates is not None:
            self.periodicDates.export(outfile, level, namespace_, name_='periodicDates', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'adjustableDates':
            obj_ = AdjustableDates.factory()
            obj_.build(child_)
            self.adjustableDates = obj_
            obj_.original_tagname_ = 'adjustableDates'
        elif nodeName_ == 'relativeDates':
            obj_ = RelativeDates.factory()
            obj_.build(child_)
            self.relativeDates = obj_
            obj_.original_tagname_ = 'relativeDates'
        elif nodeName_ == 'relativeDateSequence':
            obj_ = RelativeDateSequence.factory()
            obj_.build(child_)
            self.relativeDateSequence = obj_
            obj_.original_tagname_ = 'relativeDateSequence'
        elif nodeName_ == 'periodicDates':
            obj_ = PeriodicDates.factory()
            obj_.build(child_)
            self.periodicDates = obj_
            obj_.original_tagname_ = 'periodicDates'
# end class AdjustableRelativeOrPeriodicDates


class AdjustableRelativeOrPeriodicDates2(GeneratedsSuper):
    """A type giving the choice between defining a series of dates as an
    explicit list of dates together with applicable adjustments, or
    as relative to some other series of (anchor) dates, or as a set
    of factors to specify periodic occurences."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'adjustableDates': MemberSpec_('adjustableDates', 'AdjustableDates', 0),
        'relativeDates': MemberSpec_('relativeDates', 'RelativeDates', 0),
        'periodicDates': MemberSpec_('periodicDates', 'PeriodicDates', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, adjustableDates=None, relativeDates=None, periodicDates=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.adjustableDates = adjustableDates
        self.relativeDates = relativeDates
        self.periodicDates = periodicDates
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdjustableRelativeOrPeriodicDates2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdjustableRelativeOrPeriodicDates2.subclass:
            return AdjustableRelativeOrPeriodicDates2.subclass(*args_, **kwargs_)
        else:
            return AdjustableRelativeOrPeriodicDates2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_adjustableDates(self): return self.adjustableDates
    def set_adjustableDates(self, adjustableDates): self.adjustableDates = adjustableDates
    def get_relativeDates(self): return self.relativeDates
    def set_relativeDates(self, relativeDates): self.relativeDates = relativeDates
    def get_periodicDates(self): return self.periodicDates
    def set_periodicDates(self, periodicDates): self.periodicDates = periodicDates
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.adjustableDates is not None or
            self.relativeDates is not None or
            self.periodicDates is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AdjustableRelativeOrPeriodicDates2', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdjustableRelativeOrPeriodicDates2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AdjustableRelativeOrPeriodicDates2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AdjustableRelativeOrPeriodicDates2'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AdjustableRelativeOrPeriodicDates2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.adjustableDates is not None:
            self.adjustableDates.export(outfile, level, namespace_, name_='adjustableDates', pretty_print=pretty_print)
        if self.relativeDates is not None:
            self.relativeDates.export(outfile, level, namespace_, name_='relativeDates', pretty_print=pretty_print)
        if self.periodicDates is not None:
            self.periodicDates.export(outfile, level, namespace_, name_='periodicDates', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'adjustableDates':
            obj_ = AdjustableDates.factory()
            obj_.build(child_)
            self.adjustableDates = obj_
            obj_.original_tagname_ = 'adjustableDates'
        elif nodeName_ == 'relativeDates':
            obj_ = RelativeDates.factory()
            obj_.build(child_)
            self.relativeDates = obj_
            obj_.original_tagname_ = 'relativeDates'
        elif nodeName_ == 'periodicDates':
            obj_ = PeriodicDates.factory()
            obj_.build(child_)
            self.periodicDates = obj_
            obj_.original_tagname_ = 'periodicDates'
# end class AdjustableRelativeOrPeriodicDates2


class AgreementType(GeneratedsSuper):
    member_data_items_ = {
        'agreementTypeScheme': MemberSpec_('agreementTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, agreementTypeScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.agreementTypeScheme = _cast(None, agreementTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AgreementType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AgreementType.subclass:
            return AgreementType.subclass(*args_, **kwargs_)
        else:
            return AgreementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_agreementTypeScheme(self): return self.agreementTypeScheme
    def set_agreementTypeScheme(self, agreementTypeScheme): self.agreementTypeScheme = agreementTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AgreementType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AgreementType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AgreementType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AgreementType'):
        if self.agreementTypeScheme is not None and 'agreementTypeScheme' not in already_processed:
            already_processed.add('agreementTypeScheme')
            outfile.write(' agreementTypeScheme=%s' % (quote_attrib(self.agreementTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AgreementType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('agreementTypeScheme', node)
        if value is not None and 'agreementTypeScheme' not in already_processed:
            already_processed.add('agreementTypeScheme')
            self.agreementTypeScheme = value
            self.validate_NonEmptyURI(self.agreementTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AgreementType


class AgreementVersion(GeneratedsSuper):
    member_data_items_ = {
        'agreementVersionScheme': MemberSpec_('agreementVersionScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, agreementVersionScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.agreementVersionScheme = _cast(None, agreementVersionScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AgreementVersion)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AgreementVersion.subclass:
            return AgreementVersion.subclass(*args_, **kwargs_)
        else:
            return AgreementVersion(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_agreementVersionScheme(self): return self.agreementVersionScheme
    def set_agreementVersionScheme(self, agreementVersionScheme): self.agreementVersionScheme = agreementVersionScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AgreementVersion', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AgreementVersion')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AgreementVersion', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AgreementVersion'):
        if self.agreementVersionScheme is not None and 'agreementVersionScheme' not in already_processed:
            already_processed.add('agreementVersionScheme')
            outfile.write(' agreementVersionScheme=%s' % (quote_attrib(self.agreementVersionScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AgreementVersion', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('agreementVersionScheme', node)
        if value is not None and 'agreementVersionScheme' not in already_processed:
            already_processed.add('agreementVersionScheme')
            self.agreementVersionScheme = value
            self.validate_NonEmptyURI(self.agreementVersionScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AgreementVersion


class AssetClass(GeneratedsSuper):
    member_data_items_ = {
        'assetClassScheme': MemberSpec_('assetClassScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, assetClassScheme='http://www.fpml.org/coding-scheme/asset-class', valueOf_=None):
        self.original_tagname_ = None
        self.assetClassScheme = _cast(None, assetClassScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AssetClass)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AssetClass.subclass:
            return AssetClass.subclass(*args_, **kwargs_)
        else:
            return AssetClass(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_assetClassScheme(self): return self.assetClassScheme
    def set_assetClassScheme(self, assetClassScheme): self.assetClassScheme = assetClassScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AssetClass', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AssetClass')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AssetClass', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AssetClass'):
        if self.assetClassScheme != "http://www.fpml.org/coding-scheme/asset-class" and 'assetClassScheme' not in already_processed:
            already_processed.add('assetClassScheme')
            outfile.write(' assetClassScheme=%s' % (quote_attrib(self.assetClassScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AssetClass', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('assetClassScheme', node)
        if value is not None and 'assetClassScheme' not in already_processed:
            already_processed.add('assetClassScheme')
            self.assetClassScheme = value
            self.validate_NonEmptyURI(self.assetClassScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AssetClass


class AutomaticExercise(GeneratedsSuper):
    """A type to define automatic exercise of a swaption. With automatic
    exercise the option is deemed to have exercised if it is in the
    money by more than the threshold amount on the exercise date."""
    member_data_items_ = {
        'thresholdRate': MemberSpec_('thresholdRate', 'xsd:decimal', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, thresholdRate=None):
        self.original_tagname_ = None
        self.thresholdRate = thresholdRate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AutomaticExercise)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AutomaticExercise.subclass:
            return AutomaticExercise.subclass(*args_, **kwargs_)
        else:
            return AutomaticExercise(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_thresholdRate(self): return self.thresholdRate
    def set_thresholdRate(self, thresholdRate): self.thresholdRate = thresholdRate
    def hasContent_(self):
        if (
            self.thresholdRate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AutomaticExercise', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AutomaticExercise')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AutomaticExercise', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AutomaticExercise'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AutomaticExercise', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.thresholdRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sthresholdRate>%s</%sthresholdRate>%s' % (namespace_, self.gds_format_float(self.thresholdRate, input_name='thresholdRate'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'thresholdRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'thresholdRate')
            self.thresholdRate = fval_
# end class AutomaticExercise


class AverageDailyTradingVolumeLimit(GeneratedsSuper):
    """To indicate the limitation percentage and limitation period."""
    member_data_items_ = {
        'limitationPercentage': MemberSpec_('limitationPercentage', ['RestrictedPercentage', 'xsd:decimal'], 0),
        'limitationPeriod': MemberSpec_('limitationPeriod', 'xsd:nonNegativeInteger', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, limitationPercentage=None, limitationPeriod=None):
        self.original_tagname_ = None
        self.limitationPercentage = limitationPercentage
        self.validate_RestrictedPercentage(self.limitationPercentage)
        self.limitationPeriod = limitationPeriod
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AverageDailyTradingVolumeLimit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AverageDailyTradingVolumeLimit.subclass:
            return AverageDailyTradingVolumeLimit.subclass(*args_, **kwargs_)
        else:
            return AverageDailyTradingVolumeLimit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_limitationPercentage(self): return self.limitationPercentage
    def set_limitationPercentage(self, limitationPercentage): self.limitationPercentage = limitationPercentage
    def get_limitationPeriod(self): return self.limitationPeriod
    def set_limitationPeriod(self, limitationPeriod): self.limitationPeriod = limitationPeriod
    def validate_RestrictedPercentage(self, value):
        # Validate type RestrictedPercentage, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on RestrictedPercentage' % {"value" : value} )
            if value > 1:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on RestrictedPercentage' % {"value" : value} )
    def hasContent_(self):
        if (
            self.limitationPercentage is not None or
            self.limitationPeriod is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AverageDailyTradingVolumeLimit', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AverageDailyTradingVolumeLimit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AverageDailyTradingVolumeLimit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AverageDailyTradingVolumeLimit'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AverageDailyTradingVolumeLimit', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.limitationPercentage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slimitationPercentage>%s</%slimitationPercentage>%s' % (namespace_, self.gds_format_float(self.limitationPercentage, input_name='limitationPercentage'), namespace_, eol_))
        if self.limitationPeriod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slimitationPeriod>%s</%slimitationPeriod>%s' % (namespace_, self.gds_format_integer(self.limitationPeriod, input_name='limitationPeriod'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'limitationPercentage':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'limitationPercentage')
            self.limitationPercentage = fval_
            # validate type RestrictedPercentage
            self.validate_RestrictedPercentage(self.limitationPercentage)
        elif nodeName_ == 'limitationPeriod':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'limitationPeriod')
            self.limitationPeriod = ival_
# end class AverageDailyTradingVolumeLimit


class Beneficiary(GeneratedsSuper):
    """A type defining the beneficiary of the funds."""
    member_data_items_ = {
        'routingIds': MemberSpec_('routingIds', 'RoutingIds', 0),
        'routingExplicitDetails': MemberSpec_('routingExplicitDetails', 'RoutingExplicitDetails', 0),
        'routingIdsAndExplicitDetails': MemberSpec_('routingIdsAndExplicitDetails', 'RoutingIdsAndExplicitDetails', 0),
        'beneficiaryPartyReference': MemberSpec_('beneficiaryPartyReference', 'PartyReference', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, routingIds=None, routingExplicitDetails=None, routingIdsAndExplicitDetails=None, beneficiaryPartyReference=None):
        self.original_tagname_ = None
        self.routingIds = routingIds
        self.routingExplicitDetails = routingExplicitDetails
        self.routingIdsAndExplicitDetails = routingIdsAndExplicitDetails
        self.beneficiaryPartyReference = beneficiaryPartyReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Beneficiary)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Beneficiary.subclass:
            return Beneficiary.subclass(*args_, **kwargs_)
        else:
            return Beneficiary(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_routingIds(self): return self.routingIds
    def set_routingIds(self, routingIds): self.routingIds = routingIds
    def get_routingExplicitDetails(self): return self.routingExplicitDetails
    def set_routingExplicitDetails(self, routingExplicitDetails): self.routingExplicitDetails = routingExplicitDetails
    def get_routingIdsAndExplicitDetails(self): return self.routingIdsAndExplicitDetails
    def set_routingIdsAndExplicitDetails(self, routingIdsAndExplicitDetails): self.routingIdsAndExplicitDetails = routingIdsAndExplicitDetails
    def get_beneficiaryPartyReference(self): return self.beneficiaryPartyReference
    def set_beneficiaryPartyReference(self, beneficiaryPartyReference): self.beneficiaryPartyReference = beneficiaryPartyReference
    def hasContent_(self):
        if (
            self.routingIds is not None or
            self.routingExplicitDetails is not None or
            self.routingIdsAndExplicitDetails is not None or
            self.beneficiaryPartyReference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Beneficiary', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Beneficiary')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Beneficiary', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Beneficiary'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Beneficiary', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.routingIds is not None:
            self.routingIds.export(outfile, level, namespace_, name_='routingIds', pretty_print=pretty_print)
        if self.routingExplicitDetails is not None:
            self.routingExplicitDetails.export(outfile, level, namespace_, name_='routingExplicitDetails', pretty_print=pretty_print)
        if self.routingIdsAndExplicitDetails is not None:
            self.routingIdsAndExplicitDetails.export(outfile, level, namespace_, name_='routingIdsAndExplicitDetails', pretty_print=pretty_print)
        if self.beneficiaryPartyReference is not None:
            self.beneficiaryPartyReference.export(outfile, level, namespace_, name_='beneficiaryPartyReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'routingIds':
            obj_ = RoutingIds.factory()
            obj_.build(child_)
            self.routingIds = obj_
            obj_.original_tagname_ = 'routingIds'
        elif nodeName_ == 'routingExplicitDetails':
            obj_ = RoutingExplicitDetails.factory()
            obj_.build(child_)
            self.routingExplicitDetails = obj_
            obj_.original_tagname_ = 'routingExplicitDetails'
        elif nodeName_ == 'routingIdsAndExplicitDetails':
            obj_ = RoutingIdsAndExplicitDetails.factory()
            obj_.build(child_)
            self.routingIdsAndExplicitDetails = obj_
            obj_.original_tagname_ = 'routingIdsAndExplicitDetails'
        elif nodeName_ == 'beneficiaryPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.beneficiaryPartyReference = obj_
            obj_.original_tagname_ = 'beneficiaryPartyReference'
# end class Beneficiary


class BrokerConfirmation(GeneratedsSuper):
    """Identifies the market sector in which the trade has been arranged."""
    member_data_items_ = {
        'brokerConfirmationType': MemberSpec_('brokerConfirmationType', 'BrokerConfirmationType', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, brokerConfirmationType=None):
        self.original_tagname_ = None
        self.brokerConfirmationType = brokerConfirmationType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BrokerConfirmation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BrokerConfirmation.subclass:
            return BrokerConfirmation.subclass(*args_, **kwargs_)
        else:
            return BrokerConfirmation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_brokerConfirmationType(self): return self.brokerConfirmationType
    def set_brokerConfirmationType(self, brokerConfirmationType): self.brokerConfirmationType = brokerConfirmationType
    def hasContent_(self):
        if (
            self.brokerConfirmationType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BrokerConfirmation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BrokerConfirmation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BrokerConfirmation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BrokerConfirmation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BrokerConfirmation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.brokerConfirmationType is not None:
            self.brokerConfirmationType.export(outfile, level, namespace_, name_='brokerConfirmationType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'brokerConfirmationType':
            obj_ = BrokerConfirmationType.factory()
            obj_.build(child_)
            self.brokerConfirmationType = obj_
            obj_.original_tagname_ = 'brokerConfirmationType'
# end class BrokerConfirmation


class BrokerConfirmationType(GeneratedsSuper):
    """Identifies the market sector in which the trade has been arranged."""
    member_data_items_ = {
        'brokerConfirmationTypeScheme': MemberSpec_('brokerConfirmationTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, brokerConfirmationTypeScheme='http://www.fpml.org/coding-scheme/broker-confirmation-type', valueOf_=None):
        self.original_tagname_ = None
        self.brokerConfirmationTypeScheme = _cast(None, brokerConfirmationTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BrokerConfirmationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BrokerConfirmationType.subclass:
            return BrokerConfirmationType.subclass(*args_, **kwargs_)
        else:
            return BrokerConfirmationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_brokerConfirmationTypeScheme(self): return self.brokerConfirmationTypeScheme
    def set_brokerConfirmationTypeScheme(self, brokerConfirmationTypeScheme): self.brokerConfirmationTypeScheme = brokerConfirmationTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BrokerConfirmationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BrokerConfirmationType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BrokerConfirmationType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BrokerConfirmationType'):
        if self.brokerConfirmationTypeScheme != "http://www.fpml.org/coding-scheme/broker-confirmation-type" and 'brokerConfirmationTypeScheme' not in already_processed:
            already_processed.add('brokerConfirmationTypeScheme')
            outfile.write(' brokerConfirmationTypeScheme=%s' % (quote_attrib(self.brokerConfirmationTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BrokerConfirmationType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('brokerConfirmationTypeScheme', node)
        if value is not None and 'brokerConfirmationTypeScheme' not in already_processed:
            already_processed.add('brokerConfirmationTypeScheme')
            self.brokerConfirmationTypeScheme = value
            self.validate_NonEmptyURI(self.brokerConfirmationTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BrokerConfirmationType


class BusinessCenter(GeneratedsSuper):
    """A code identifying a business day calendar location. A business day
    calendar location is drawn from the list identified by the
    business day calendar location scheme."""
    member_data_items_ = {
        'businessCenterScheme': MemberSpec_('businessCenterScheme', 'NonEmptyURI', 0),
        'id': MemberSpec_('id', 'xsd:string', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, businessCenterScheme='http://www.fpml.org/coding-scheme/business-center', id=None, valueOf_=None):
        self.original_tagname_ = None
        self.businessCenterScheme = _cast(None, businessCenterScheme)
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BusinessCenter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BusinessCenter.subclass:
            return BusinessCenter.subclass(*args_, **kwargs_)
        else:
            return BusinessCenter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_businessCenterScheme(self): return self.businessCenterScheme
    def set_businessCenterScheme(self, businessCenterScheme): self.businessCenterScheme = businessCenterScheme
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BusinessCenter', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BusinessCenter')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BusinessCenter', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BusinessCenter'):
        if self.businessCenterScheme != "http://www.fpml.org/coding-scheme/business-center" and 'businessCenterScheme' not in already_processed:
            already_processed.add('businessCenterScheme')
            outfile.write(' businessCenterScheme=%s' % (quote_attrib(self.businessCenterScheme), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BusinessCenter', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('businessCenterScheme', node)
        if value is not None and 'businessCenterScheme' not in already_processed:
            already_processed.add('businessCenterScheme')
            self.businessCenterScheme = value
            self.validate_NonEmptyURI(self.businessCenterScheme)    # validate type NonEmptyURI
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BusinessCenter


class BusinessCenters(GeneratedsSuper):
    """A type for defining business day calendar used in determining
    whether a day is a business day or not. A list of business day
    calendar locations may be ordered in the document alphabetically
    based on business day calendar location code. An FpML document
    containing an unordered business day calendar location list is
    still regarded as a conformant document."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'businessCenter': MemberSpec_('businessCenter', 'BusinessCenter', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, businessCenter=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if businessCenter is None:
            self.businessCenter = []
        else:
            self.businessCenter = businessCenter
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BusinessCenters)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BusinessCenters.subclass:
            return BusinessCenters.subclass(*args_, **kwargs_)
        else:
            return BusinessCenters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_businessCenter(self): return self.businessCenter
    def set_businessCenter(self, businessCenter): self.businessCenter = businessCenter
    def add_businessCenter(self, value): self.businessCenter.append(value)
    def insert_businessCenter_at(self, index, value): self.businessCenter.insert(index, value)
    def replace_businessCenter_at(self, index, value): self.businessCenter[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.businessCenter
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BusinessCenters', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BusinessCenters')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BusinessCenters', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BusinessCenters'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BusinessCenters', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for businessCenter_ in self.businessCenter:
            businessCenter_.export(outfile, level, namespace_, name_='businessCenter', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'businessCenter':
            obj_ = BusinessCenter.factory()
            obj_.build(child_)
            self.businessCenter.append(obj_)
            obj_.original_tagname_ = 'businessCenter'
# end class BusinessCenters


class BusinessCenterTime(GeneratedsSuper):
    """A type for defining a time with respect to a business day calendar
    location. For example, 11:00am London time."""
    member_data_items_ = {
        'hourMinuteTime': MemberSpec_('hourMinuteTime', ['HourMinuteTime', 'xsd:time'], 0),
        'businessCenter': MemberSpec_('businessCenter', 'BusinessCenter', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, hourMinuteTime=None, businessCenter=None):
        self.original_tagname_ = None
        if isinstance(hourMinuteTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(hourMinuteTime, '%H:%M:%S').time()
        else:
            initvalue_ = hourMinuteTime
        self.hourMinuteTime = initvalue_
        self.businessCenter = businessCenter
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BusinessCenterTime)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BusinessCenterTime.subclass:
            return BusinessCenterTime.subclass(*args_, **kwargs_)
        else:
            return BusinessCenterTime(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_hourMinuteTime(self): return self.hourMinuteTime
    def set_hourMinuteTime(self, hourMinuteTime): self.hourMinuteTime = hourMinuteTime
    def get_businessCenter(self): return self.businessCenter
    def set_businessCenter(self, businessCenter): self.businessCenter = businessCenter
    def validate_HourMinuteTime(self, value):
        # Validate type HourMinuteTime, a restriction on xsd:time.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_HourMinuteTime_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_HourMinuteTime_patterns_, ))
    validate_HourMinuteTime_patterns_ = [['^[0-2][0-9]:[0-5][0-9]:00$']]
    def hasContent_(self):
        if (
            self.hourMinuteTime is not None or
            self.businessCenter is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BusinessCenterTime', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BusinessCenterTime')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BusinessCenterTime', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BusinessCenterTime'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BusinessCenterTime', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.hourMinuteTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shourMinuteTime>%s</%shourMinuteTime>%s' % (namespace_, self.gds_format_time(self.hourMinuteTime, input_name='hourMinuteTime'), namespace_, eol_))
        if self.businessCenter is not None:
            self.businessCenter.export(outfile, level, namespace_, name_='businessCenter', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'hourMinuteTime':
            sval_ = child_.text
            dval_ = self.gds_parse_time(sval_)
            self.hourMinuteTime = dval_
            # validate type HourMinuteTime
            self.validate_HourMinuteTime(self.hourMinuteTime)
        elif nodeName_ == 'businessCenter':
            obj_ = BusinessCenter.factory()
            obj_.build(child_)
            self.businessCenter = obj_
            obj_.original_tagname_ = 'businessCenter'
# end class BusinessCenterTime


class BusinessDayAdjustments(GeneratedsSuper):
    """A type defining the business day convention and financial business
    centers used for adjusting any relevant date if it would
    otherwise fall on a day that is not a business day in the
    specified business centers."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'businessDayConvention': MemberSpec_('businessDayConvention', ['BusinessDayConventionEnum', 'Token', 'xsd:token'], 0),
        'businessCentersReference': MemberSpec_('businessCentersReference', 'BusinessCentersReference', 0),
        'businessCenters': MemberSpec_('businessCenters', 'BusinessCenters', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, businessDayConvention=None, businessCentersReference=None, businessCenters=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.businessDayConvention = businessDayConvention
        self.validate_BusinessDayConventionEnum(self.businessDayConvention)
        self.businessCentersReference = businessCentersReference
        self.businessCenters = businessCenters
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BusinessDayAdjustments)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BusinessDayAdjustments.subclass:
            return BusinessDayAdjustments.subclass(*args_, **kwargs_)
        else:
            return BusinessDayAdjustments(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_businessDayConvention(self): return self.businessDayConvention
    def set_businessDayConvention(self, businessDayConvention): self.businessDayConvention = businessDayConvention
    def get_businessCentersReference(self): return self.businessCentersReference
    def set_businessCentersReference(self, businessCentersReference): self.businessCentersReference = businessCentersReference
    def get_businessCenters(self): return self.businessCenters
    def set_businessCenters(self, businessCenters): self.businessCenters = businessCenters
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_BusinessDayConventionEnum(self, value):
        # Validate type BusinessDayConventionEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FOLLOWING', 'FRN', 'MODFOLLOWING', 'PRECEDING', 'MODPRECEDING', 'NEAREST', 'NONE', 'NotApplicable']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on BusinessDayConventionEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on BusinessDayConventionEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.businessDayConvention is not None or
            self.businessCentersReference is not None or
            self.businessCenters is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BusinessDayAdjustments', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BusinessDayAdjustments')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BusinessDayAdjustments', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BusinessDayAdjustments'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BusinessDayAdjustments', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.businessDayConvention is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbusinessDayConvention>%s</%sbusinessDayConvention>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.businessDayConvention), input_name='businessDayConvention')), namespace_, eol_))
        if self.businessCentersReference is not None:
            self.businessCentersReference.export(outfile, level, namespace_, name_='businessCentersReference', pretty_print=pretty_print)
        if self.businessCenters is not None:
            self.businessCenters.export(outfile, level, namespace_, name_='businessCenters', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'businessDayConvention':
            businessDayConvention_ = child_.text
            businessDayConvention_ = re_.sub(String_cleanup_pat_, " ", businessDayConvention_).strip()
            businessDayConvention_ = self.gds_validate_string(businessDayConvention_, node, 'businessDayConvention')
            self.businessDayConvention = businessDayConvention_
            # validate type BusinessDayConventionEnum
            self.validate_BusinessDayConventionEnum(self.businessDayConvention)
        elif nodeName_ == 'businessCentersReference':
            obj_ = BusinessCentersReference.factory()
            obj_.build(child_)
            self.businessCentersReference = obj_
            obj_.original_tagname_ = 'businessCentersReference'
        elif nodeName_ == 'businessCenters':
            obj_ = BusinessCenters.factory()
            obj_.build(child_)
            self.businessCenters = obj_
            obj_.original_tagname_ = 'businessCenters'
# end class BusinessDayAdjustments


class BusinessUnit(GeneratedsSuper):
    """A type that represents information about a unit within an
    organization."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'name': MemberSpec_('name', ['String', 'xsd:string'], 0),
        'businessUnitId': MemberSpec_('businessUnitId', 'Unit', 0),
        'contactInfo': MemberSpec_('contactInfo', 'ContactInformation', 0),
        'country': MemberSpec_('country', 'CountryCode', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, businessUnitId=None, contactInfo=None, country=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.name = name
        self.validate_String(self.name)
        self.businessUnitId = businessUnitId
        self.contactInfo = contactInfo
        self.country = country
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BusinessUnit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BusinessUnit.subclass:
            return BusinessUnit.subclass(*args_, **kwargs_)
        else:
            return BusinessUnit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_businessUnitId(self): return self.businessUnitId
    def set_businessUnitId(self, businessUnitId): self.businessUnitId = businessUnitId
    def get_contactInfo(self): return self.contactInfo
    def set_contactInfo(self, contactInfo): self.contactInfo = contactInfo
    def get_country(self): return self.country
    def set_country(self, country): self.country = country
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.name is not None or
            self.businessUnitId is not None or
            self.contactInfo is not None or
            self.country is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BusinessUnit', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BusinessUnit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BusinessUnit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BusinessUnit'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BusinessUnit', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespace_, eol_))
        if self.businessUnitId is not None:
            self.businessUnitId.export(outfile, level, namespace_, name_='businessUnitId', pretty_print=pretty_print)
        if self.contactInfo is not None:
            self.contactInfo.export(outfile, level, namespace_, name_='contactInfo', pretty_print=pretty_print)
        if self.country is not None:
            self.country.export(outfile, level, namespace_, name_='country', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
            # validate type String
            self.validate_String(self.name)
        elif nodeName_ == 'businessUnitId':
            obj_ = Unit.factory()
            obj_.build(child_)
            self.businessUnitId = obj_
            obj_.original_tagname_ = 'businessUnitId'
        elif nodeName_ == 'contactInfo':
            obj_ = ContactInformation.factory()
            obj_.build(child_)
            self.contactInfo = obj_
            obj_.original_tagname_ = 'contactInfo'
        elif nodeName_ == 'country':
            obj_ = CountryCode.factory()
            obj_.build(child_)
            self.country = obj_
            obj_.original_tagname_ = 'country'
# end class BusinessUnit


class BusinessUnitRole(GeneratedsSuper):
    """A type describing a role played by a unit in one or more
    transactions. Examples include roles such as Trader, Collateral,
    Confirmation, Settlement, etc. This can be extended to provide
    custom roles."""
    member_data_items_ = {
        'unitRoleScheme': MemberSpec_('unitRoleScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, unitRoleScheme='http://www.fpml.org/coding-scheme/unit-role', valueOf_=None):
        self.original_tagname_ = None
        self.unitRoleScheme = _cast(None, unitRoleScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BusinessUnitRole)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BusinessUnitRole.subclass:
            return BusinessUnitRole.subclass(*args_, **kwargs_)
        else:
            return BusinessUnitRole(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unitRoleScheme(self): return self.unitRoleScheme
    def set_unitRoleScheme(self, unitRoleScheme): self.unitRoleScheme = unitRoleScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BusinessUnitRole', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BusinessUnitRole')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BusinessUnitRole', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BusinessUnitRole'):
        if self.unitRoleScheme != "http://www.fpml.org/coding-scheme/unit-role" and 'unitRoleScheme' not in already_processed:
            already_processed.add('unitRoleScheme')
            outfile.write(' unitRoleScheme=%s' % (quote_attrib(self.unitRoleScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BusinessUnitRole', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unitRoleScheme', node)
        if value is not None and 'unitRoleScheme' not in already_processed:
            already_processed.add('unitRoleScheme')
            self.unitRoleScheme = value
            self.validate_NonEmptyURI(self.unitRoleScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BusinessUnitRole


class CalculationAgent(GeneratedsSuper):
    """A type defining the ISDA calculation agent responsible for
    performing duties as defined in the applicable product
    definitions."""
    member_data_items_ = {
        'calculationAgentPartyReference': MemberSpec_('calculationAgentPartyReference', 'PartyReference', 1),
        'calculationAgentParty': MemberSpec_('calculationAgentParty', ['CalculationAgentPartyEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, calculationAgentPartyReference=None, calculationAgentParty=None):
        self.original_tagname_ = None
        if calculationAgentPartyReference is None:
            self.calculationAgentPartyReference = []
        else:
            self.calculationAgentPartyReference = calculationAgentPartyReference
        self.calculationAgentParty = calculationAgentParty
        self.validate_CalculationAgentPartyEnum(self.calculationAgentParty)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CalculationAgent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CalculationAgent.subclass:
            return CalculationAgent.subclass(*args_, **kwargs_)
        else:
            return CalculationAgent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_calculationAgentPartyReference(self): return self.calculationAgentPartyReference
    def set_calculationAgentPartyReference(self, calculationAgentPartyReference): self.calculationAgentPartyReference = calculationAgentPartyReference
    def add_calculationAgentPartyReference(self, value): self.calculationAgentPartyReference.append(value)
    def insert_calculationAgentPartyReference_at(self, index, value): self.calculationAgentPartyReference.insert(index, value)
    def replace_calculationAgentPartyReference_at(self, index, value): self.calculationAgentPartyReference[index] = value
    def get_calculationAgentParty(self): return self.calculationAgentParty
    def set_calculationAgentParty(self, calculationAgentParty): self.calculationAgentParty = calculationAgentParty
    def validate_CalculationAgentPartyEnum(self, value):
        # Validate type CalculationAgentPartyEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ExercisingParty', 'NonExercisingParty', 'AsSpecifiedInMasterAgreement', 'AsSpecifiedInStandardTermsSupplement', 'Both']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CalculationAgentPartyEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on CalculationAgentPartyEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.calculationAgentPartyReference or
            self.calculationAgentParty is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CalculationAgent', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CalculationAgent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CalculationAgent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CalculationAgent'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CalculationAgent', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for calculationAgentPartyReference_ in self.calculationAgentPartyReference:
            calculationAgentPartyReference_.export(outfile, level, namespace_, name_='calculationAgentPartyReference', pretty_print=pretty_print)
        if self.calculationAgentParty is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scalculationAgentParty>%s</%scalculationAgentParty>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.calculationAgentParty), input_name='calculationAgentParty')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'calculationAgentPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.calculationAgentPartyReference.append(obj_)
            obj_.original_tagname_ = 'calculationAgentPartyReference'
        elif nodeName_ == 'calculationAgentParty':
            calculationAgentParty_ = child_.text
            calculationAgentParty_ = re_.sub(String_cleanup_pat_, " ", calculationAgentParty_).strip()
            calculationAgentParty_ = self.gds_validate_string(calculationAgentParty_, node, 'calculationAgentParty')
            self.calculationAgentParty = calculationAgentParty_
            # validate type CalculationAgentPartyEnum
            self.validate_CalculationAgentPartyEnum(self.calculationAgentParty)
# end class CalculationAgent


class CashflowId(GeneratedsSuper):
    """An identifier used to identify a single component cashflow."""
    member_data_items_ = {
        'cashflowIdScheme': MemberSpec_('cashflowIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, cashflowIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.cashflowIdScheme = _cast(None, cashflowIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CashflowId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CashflowId.subclass:
            return CashflowId.subclass(*args_, **kwargs_)
        else:
            return CashflowId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cashflowIdScheme(self): return self.cashflowIdScheme
    def set_cashflowIdScheme(self, cashflowIdScheme): self.cashflowIdScheme = cashflowIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CashflowId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CashflowId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CashflowId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CashflowId'):
        if self.cashflowIdScheme is not None and 'cashflowIdScheme' not in already_processed:
            already_processed.add('cashflowIdScheme')
            outfile.write(' cashflowIdScheme=%s' % (quote_attrib(self.cashflowIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CashflowId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('cashflowIdScheme', node)
        if value is not None and 'cashflowIdScheme' not in already_processed:
            already_processed.add('cashflowIdScheme')
            self.cashflowIdScheme = value
            self.validate_NonEmptyURI(self.cashflowIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CashflowId


class CashflowNotional(GeneratedsSuper):
    """The notional/principal value/quantity/volume used to compute the
    cashflow."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'currency': MemberSpec_('currency', 'Currency', 0),
        'units': MemberSpec_('units', ['NormalizedString', 'xsd:normalizedString'], 0),
        'amount': MemberSpec_('amount', 'xsd:decimal', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, currency=None, units=None, amount=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.currency = currency
        self.units = units
        self.validate_NormalizedString(self.units)
        self.amount = amount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CashflowNotional)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CashflowNotional.subclass:
            return CashflowNotional.subclass(*args_, **kwargs_)
        else:
            return CashflowNotional(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_units(self): return self.units
    def set_units(self, units): self.units = units
    def get_amount(self): return self.amount
    def set_amount(self, amount): self.amount = amount
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_NormalizedString(self, value):
        # Validate type NormalizedString, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NormalizedString' % {"value" : value} )
    def hasContent_(self):
        if (
            self.currency is not None or
            self.units is not None or
            self.amount is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CashflowNotional', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CashflowNotional')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CashflowNotional', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CashflowNotional'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CashflowNotional', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.currency is not None:
            self.currency.export(outfile, level, namespace_, name_='currency', pretty_print=pretty_print)
        if self.units is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sunits>%s</%sunits>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.units), input_name='units')), namespace_, eol_))
        if self.amount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%samount>%s</%samount>%s' % (namespace_, self.gds_format_float(self.amount, input_name='amount'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'currency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'units':
            units_ = child_.text
            units_ = self.gds_validate_string(units_, node, 'units')
            self.units = units_
            # validate type NormalizedString
            self.validate_NormalizedString(self.units)
        elif nodeName_ == 'amount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'amount')
            self.amount = fval_
# end class CashflowNotional


class CashflowType(GeneratedsSuper):
    """A coding scheme used to describe the type or purpose of a cash flow
    or cash flow component."""
    member_data_items_ = {
        'cashflowTypeScheme': MemberSpec_('cashflowTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, cashflowTypeScheme='http://www.fpml.org/coding-scheme/cashflow-type', valueOf_=None):
        self.original_tagname_ = None
        self.cashflowTypeScheme = _cast(None, cashflowTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CashflowType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CashflowType.subclass:
            return CashflowType.subclass(*args_, **kwargs_)
        else:
            return CashflowType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cashflowTypeScheme(self): return self.cashflowTypeScheme
    def set_cashflowTypeScheme(self, cashflowTypeScheme): self.cashflowTypeScheme = cashflowTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CashflowType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CashflowType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CashflowType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CashflowType'):
        if self.cashflowTypeScheme != "http://www.fpml.org/coding-scheme/cashflow-type" and 'cashflowTypeScheme' not in already_processed:
            already_processed.add('cashflowTypeScheme')
            outfile.write(' cashflowTypeScheme=%s' % (quote_attrib(self.cashflowTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CashflowType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('cashflowTypeScheme', node)
        if value is not None and 'cashflowTypeScheme' not in already_processed:
            already_processed.add('cashflowTypeScheme')
            self.cashflowTypeScheme = value
            self.validate_NonEmptyURI(self.cashflowTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CashflowType


class CashSettlementReferenceBanks(GeneratedsSuper):
    """A type defining the list of reference institutions polled for
    relevant rates or prices when determining the cash settlement
    amount for a product where cash settlement is applicable."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'referenceBank': MemberSpec_('referenceBank', 'ReferenceBank', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, referenceBank=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if referenceBank is None:
            self.referenceBank = []
        else:
            self.referenceBank = referenceBank
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CashSettlementReferenceBanks)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CashSettlementReferenceBanks.subclass:
            return CashSettlementReferenceBanks.subclass(*args_, **kwargs_)
        else:
            return CashSettlementReferenceBanks(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_referenceBank(self): return self.referenceBank
    def set_referenceBank(self, referenceBank): self.referenceBank = referenceBank
    def add_referenceBank(self, value): self.referenceBank.append(value)
    def insert_referenceBank_at(self, index, value): self.referenceBank.insert(index, value)
    def replace_referenceBank_at(self, index, value): self.referenceBank[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.referenceBank
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CashSettlementReferenceBanks', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CashSettlementReferenceBanks')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CashSettlementReferenceBanks', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CashSettlementReferenceBanks'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CashSettlementReferenceBanks', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for referenceBank_ in self.referenceBank:
            referenceBank_.export(outfile, level, namespace_, name_='referenceBank', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'referenceBank':
            obj_ = ReferenceBank.factory()
            obj_.build(child_)
            self.referenceBank.append(obj_)
            obj_.original_tagname_ = 'referenceBank'
# end class CashSettlementReferenceBanks


class ClearanceSystem(GeneratedsSuper):
    """Unless otherwise specified, the principal clearance system
    customarily used for settling trades in the relevant underlying."""
    member_data_items_ = {
        'clearanceSystemScheme': MemberSpec_('clearanceSystemScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, clearanceSystemScheme='http://www.fpml.org/coding-scheme/clearance-system', valueOf_=None):
        self.original_tagname_ = None
        self.clearanceSystemScheme = _cast(None, clearanceSystemScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClearanceSystem)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClearanceSystem.subclass:
            return ClearanceSystem.subclass(*args_, **kwargs_)
        else:
            return ClearanceSystem(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_clearanceSystemScheme(self): return self.clearanceSystemScheme
    def set_clearanceSystemScheme(self, clearanceSystemScheme): self.clearanceSystemScheme = clearanceSystemScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ClearanceSystem', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ClearanceSystem')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ClearanceSystem', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ClearanceSystem'):
        if self.clearanceSystemScheme != "http://www.fpml.org/coding-scheme/clearance-system" and 'clearanceSystemScheme' not in already_processed:
            already_processed.add('clearanceSystemScheme')
            outfile.write(' clearanceSystemScheme=%s' % (quote_attrib(self.clearanceSystemScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ClearanceSystem', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('clearanceSystemScheme', node)
        if value is not None and 'clearanceSystemScheme' not in already_processed:
            already_processed.add('clearanceSystemScheme')
            self.clearanceSystemScheme = value
            self.validate_NonEmptyURI(self.clearanceSystemScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ClearanceSystem


class SwaptionPhysicalSettlement(GeneratedsSuper):
    member_data_items_ = {
        'clearedPhysicalSettlement': MemberSpec_('clearedPhysicalSettlement', 'xsd:boolean', 0),
        'predeterminedClearingOrganizationPartyReference': MemberSpec_('predeterminedClearingOrganizationPartyReference', 'PartyReference', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, clearedPhysicalSettlement=None, predeterminedClearingOrganizationPartyReference=None):
        self.original_tagname_ = None
        self.clearedPhysicalSettlement = clearedPhysicalSettlement
        self.predeterminedClearingOrganizationPartyReference = predeterminedClearingOrganizationPartyReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SwaptionPhysicalSettlement)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SwaptionPhysicalSettlement.subclass:
            return SwaptionPhysicalSettlement.subclass(*args_, **kwargs_)
        else:
            return SwaptionPhysicalSettlement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_clearedPhysicalSettlement(self): return self.clearedPhysicalSettlement
    def set_clearedPhysicalSettlement(self, clearedPhysicalSettlement): self.clearedPhysicalSettlement = clearedPhysicalSettlement
    def get_predeterminedClearingOrganizationPartyReference(self): return self.predeterminedClearingOrganizationPartyReference
    def set_predeterminedClearingOrganizationPartyReference(self, predeterminedClearingOrganizationPartyReference): self.predeterminedClearingOrganizationPartyReference = predeterminedClearingOrganizationPartyReference
    def hasContent_(self):
        if (
            self.clearedPhysicalSettlement is not None or
            self.predeterminedClearingOrganizationPartyReference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SwaptionPhysicalSettlement', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SwaptionPhysicalSettlement')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SwaptionPhysicalSettlement', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SwaptionPhysicalSettlement'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SwaptionPhysicalSettlement', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.clearedPhysicalSettlement is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sclearedPhysicalSettlement>%s</%sclearedPhysicalSettlement>%s' % (namespace_, self.gds_format_boolean(self.clearedPhysicalSettlement, input_name='clearedPhysicalSettlement'), namespace_, eol_))
        if self.predeterminedClearingOrganizationPartyReference is not None:
            self.predeterminedClearingOrganizationPartyReference.export(outfile, level, namespace_, name_='predeterminedClearingOrganizationPartyReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'clearedPhysicalSettlement':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'clearedPhysicalSettlement')
            self.clearedPhysicalSettlement = ival_
        elif nodeName_ == 'predeterminedClearingOrganizationPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.predeterminedClearingOrganizationPartyReference = obj_
            obj_.original_tagname_ = 'predeterminedClearingOrganizationPartyReference'
# end class SwaptionPhysicalSettlement


class Collateral(GeneratedsSuper):
    """A type for defining the obligations of the counterparty subject to
    credit support requirements."""
    member_data_items_ = {
        'independentAmount': MemberSpec_('independentAmount', 'IndependentAmount', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, independentAmount=None):
        self.original_tagname_ = None
        self.independentAmount = independentAmount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Collateral)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Collateral.subclass:
            return Collateral.subclass(*args_, **kwargs_)
        else:
            return Collateral(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_independentAmount(self): return self.independentAmount
    def set_independentAmount(self, independentAmount): self.independentAmount = independentAmount
    def hasContent_(self):
        if (
            self.independentAmount is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Collateral', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Collateral')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Collateral', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Collateral'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Collateral', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.independentAmount is not None:
            self.independentAmount.export(outfile, level, namespace_, name_='independentAmount', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'independentAmount':
            obj_ = IndependentAmount.factory()
            obj_.build(child_)
            self.independentAmount = obj_
            obj_.original_tagname_ = 'independentAmount'
# end class Collateral


class CollateralValueAllocation(GeneratedsSuper):
    member_data_items_ = {
        'type_': MemberSpec_('type_', ['CollateralValueAllocationEnum', 'Token', 'xsd:token'], 0),
        'value': MemberSpec_('value', 'Money', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, type_=None, value=None):
        self.original_tagname_ = None
        self.type_ = type_
        self.validate_CollateralValueAllocationEnum(self.type_)
        if value is None:
            self.value = []
        else:
            self.value = value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CollateralValueAllocation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CollateralValueAllocation.subclass:
            return CollateralValueAllocation.subclass(*args_, **kwargs_)
        else:
            return CollateralValueAllocation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value_at(self, index, value): self.value.insert(index, value)
    def replace_value_at(self, index, value): self.value[index] = value
    def validate_CollateralValueAllocationEnum(self, value):
        # Validate type CollateralValueAllocationEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Buffer', 'Full', 'ExcessOverMargin', 'Margin']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CollateralValueAllocationEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on CollateralValueAllocationEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.type_ is not None or
            self.value
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CollateralValueAllocation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CollateralValueAllocation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CollateralValueAllocation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CollateralValueAllocation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CollateralValueAllocation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stype>%s</%stype>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.type_), input_name='type')), namespace_, eol_))
        for value_ in self.value:
            value_.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            type_ = child_.text
            type_ = re_.sub(String_cleanup_pat_, " ", type_).strip()
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
            # validate type CollateralValueAllocationEnum
            self.validate_CollateralValueAllocationEnum(self.type_)
        elif nodeName_ == 'value':
            obj_ = Money.factory()
            obj_.build(child_)
            self.value.append(obj_)
            obj_.original_tagname_ = 'value'
# end class CollateralValueAllocation


class ContactInformation(GeneratedsSuper):
    """A type that represents how to contact an individual or organization."""
    member_data_items_ = {
        'telephone': MemberSpec_('telephone', 'TelephoneNumber', 1),
        'email': MemberSpec_('email', ['NormalizedString', 'xsd:normalizedString'], 1),
        'address': MemberSpec_('address', 'Address', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, telephone=None, email=None, address=None):
        self.original_tagname_ = None
        if telephone is None:
            self.telephone = []
        else:
            self.telephone = telephone
        if email is None:
            self.email = []
        else:
            self.email = email
        self.address = address
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContactInformation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContactInformation.subclass:
            return ContactInformation.subclass(*args_, **kwargs_)
        else:
            return ContactInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_telephone(self): return self.telephone
    def set_telephone(self, telephone): self.telephone = telephone
    def add_telephone(self, value): self.telephone.append(value)
    def insert_telephone_at(self, index, value): self.telephone.insert(index, value)
    def replace_telephone_at(self, index, value): self.telephone[index] = value
    def get_email(self): return self.email
    def set_email(self, email): self.email = email
    def add_email(self, value): self.email.append(value)
    def insert_email_at(self, index, value): self.email.insert(index, value)
    def replace_email_at(self, index, value): self.email[index] = value
    def get_address(self): return self.address
    def set_address(self, address): self.address = address
    def validate_NormalizedString(self, value):
        # Validate type NormalizedString, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NormalizedString' % {"value" : value} )
    def hasContent_(self):
        if (
            self.telephone or
            self.email or
            self.address is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ContactInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContactInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ContactInformation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContactInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ContactInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for telephone_ in self.telephone:
            telephone_.export(outfile, level, namespace_, name_='telephone', pretty_print=pretty_print)
        for email_ in self.email:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%semail>%s</%semail>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(email_), input_name='email')), namespace_, eol_))
        if self.address is not None:
            self.address.export(outfile, level, namespace_, name_='address', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'telephone':
            obj_ = TelephoneNumber.factory()
            obj_.build(child_)
            self.telephone.append(obj_)
            obj_.original_tagname_ = 'telephone'
        elif nodeName_ == 'email':
            email_ = child_.text
            email_ = self.gds_validate_string(email_, node, 'email')
            self.email.append(email_)
            # validate type NormalizedString
            self.validate_NormalizedString(self.email[-1])
        elif nodeName_ == 'address':
            obj_ = Address.factory()
            obj_.build(child_)
            self.address = obj_
            obj_.original_tagname_ = 'address'
# end class ContactInformation


class ContractualDefinitions(GeneratedsSuper):
    """The definitions, such as those published by ISDA, that will define
    the terms of the trade."""
    member_data_items_ = {
        'contractualDefinitionsScheme': MemberSpec_('contractualDefinitionsScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, contractualDefinitionsScheme='http://www.fpml.org/coding-scheme/contractual-definitions', valueOf_=None):
        self.original_tagname_ = None
        self.contractualDefinitionsScheme = _cast(None, contractualDefinitionsScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContractualDefinitions)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContractualDefinitions.subclass:
            return ContractualDefinitions.subclass(*args_, **kwargs_)
        else:
            return ContractualDefinitions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_contractualDefinitionsScheme(self): return self.contractualDefinitionsScheme
    def set_contractualDefinitionsScheme(self, contractualDefinitionsScheme): self.contractualDefinitionsScheme = contractualDefinitionsScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ContractualDefinitions', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContractualDefinitions')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ContractualDefinitions', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContractualDefinitions'):
        if self.contractualDefinitionsScheme != "http://www.fpml.org/coding-scheme/contractual-definitions" and 'contractualDefinitionsScheme' not in already_processed:
            already_processed.add('contractualDefinitionsScheme')
            outfile.write(' contractualDefinitionsScheme=%s' % (quote_attrib(self.contractualDefinitionsScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ContractualDefinitions', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('contractualDefinitionsScheme', node)
        if value is not None and 'contractualDefinitionsScheme' not in already_processed:
            already_processed.add('contractualDefinitionsScheme')
            self.contractualDefinitionsScheme = value
            self.validate_NonEmptyURI(self.contractualDefinitionsScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ContractualDefinitions


class ContractualMatrix(GeneratedsSuper):
    member_data_items_ = {
        'matrixType': MemberSpec_('matrixType', 'MatrixType', 0),
        'publicationDate': MemberSpec_('publicationDate', 'xsd:date', 0),
        'matrixTerm': MemberSpec_('matrixTerm', 'MatrixTerm', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, matrixType=None, publicationDate=None, matrixTerm=None):
        self.original_tagname_ = None
        self.matrixType = matrixType
        if isinstance(publicationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(publicationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = publicationDate
        self.publicationDate = initvalue_
        self.matrixTerm = matrixTerm
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContractualMatrix)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContractualMatrix.subclass:
            return ContractualMatrix.subclass(*args_, **kwargs_)
        else:
            return ContractualMatrix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_matrixType(self): return self.matrixType
    def set_matrixType(self, matrixType): self.matrixType = matrixType
    def get_publicationDate(self): return self.publicationDate
    def set_publicationDate(self, publicationDate): self.publicationDate = publicationDate
    def get_matrixTerm(self): return self.matrixTerm
    def set_matrixTerm(self, matrixTerm): self.matrixTerm = matrixTerm
    def hasContent_(self):
        if (
            self.matrixType is not None or
            self.publicationDate is not None or
            self.matrixTerm is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ContractualMatrix', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContractualMatrix')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ContractualMatrix', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContractualMatrix'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ContractualMatrix', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.matrixType is not None:
            self.matrixType.export(outfile, level, namespace_, name_='matrixType', pretty_print=pretty_print)
        if self.publicationDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spublicationDate>%s</%spublicationDate>%s' % (namespace_, self.gds_format_date(self.publicationDate, input_name='publicationDate'), namespace_, eol_))
        if self.matrixTerm is not None:
            self.matrixTerm.export(outfile, level, namespace_, name_='matrixTerm', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'matrixType':
            obj_ = MatrixType.factory()
            obj_.build(child_)
            self.matrixType = obj_
            obj_.original_tagname_ = 'matrixType'
        elif nodeName_ == 'publicationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.publicationDate = dval_
        elif nodeName_ == 'matrixTerm':
            obj_ = MatrixTerm.factory()
            obj_.build(child_)
            self.matrixTerm = obj_
            obj_.original_tagname_ = 'matrixTerm'
# end class ContractualMatrix


class ContractualSupplement(GeneratedsSuper):
    """A contractual supplement (such as those published by ISDA) that will
    apply to the trade."""
    member_data_items_ = {
        'contractualSupplementScheme': MemberSpec_('contractualSupplementScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, contractualSupplementScheme='http://www.fpml.org/coding-scheme/contractual-supplement', valueOf_=None):
        self.original_tagname_ = None
        self.contractualSupplementScheme = _cast(None, contractualSupplementScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContractualSupplement)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContractualSupplement.subclass:
            return ContractualSupplement.subclass(*args_, **kwargs_)
        else:
            return ContractualSupplement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_contractualSupplementScheme(self): return self.contractualSupplementScheme
    def set_contractualSupplementScheme(self, contractualSupplementScheme): self.contractualSupplementScheme = contractualSupplementScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ContractualSupplement', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContractualSupplement')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ContractualSupplement', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContractualSupplement'):
        if self.contractualSupplementScheme != "http://www.fpml.org/coding-scheme/contractual-supplement" and 'contractualSupplementScheme' not in already_processed:
            already_processed.add('contractualSupplementScheme')
            outfile.write(' contractualSupplementScheme=%s' % (quote_attrib(self.contractualSupplementScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ContractualSupplement', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('contractualSupplementScheme', node)
        if value is not None and 'contractualSupplementScheme' not in already_processed:
            already_processed.add('contractualSupplementScheme')
            self.contractualSupplementScheme = value
            self.validate_NonEmptyURI(self.contractualSupplementScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ContractualSupplement


class ContractualTermsSupplement(GeneratedsSuper):
    """A contractual supplement (such as those published by ISDA) and its
    publication date that will apply to the trade."""
    member_data_items_ = {
        'type_': MemberSpec_('type_', 'ContractualSupplement', 0),
        'publicationDate': MemberSpec_('publicationDate', 'xsd:date', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, type_=None, publicationDate=None):
        self.original_tagname_ = None
        self.type_ = type_
        if isinstance(publicationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(publicationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = publicationDate
        self.publicationDate = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContractualTermsSupplement)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContractualTermsSupplement.subclass:
            return ContractualTermsSupplement.subclass(*args_, **kwargs_)
        else:
            return ContractualTermsSupplement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_publicationDate(self): return self.publicationDate
    def set_publicationDate(self, publicationDate): self.publicationDate = publicationDate
    def hasContent_(self):
        if (
            self.type_ is not None or
            self.publicationDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ContractualTermsSupplement', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContractualTermsSupplement')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ContractualTermsSupplement', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContractualTermsSupplement'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ContractualTermsSupplement', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            self.type_.export(outfile, level, namespace_, name_='type', pretty_print=pretty_print)
        if self.publicationDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spublicationDate>%s</%spublicationDate>%s' % (namespace_, self.gds_format_date(self.publicationDate, input_name='publicationDate'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            obj_ = ContractualSupplement.factory()
            obj_.build(child_)
            self.type_ = obj_
            obj_.original_tagname_ = 'type'
        elif nodeName_ == 'publicationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.publicationDate = dval_
# end class ContractualTermsSupplement


class CorrespondentInformation(GeneratedsSuper):
    """A type that describes the information to identify a correspondent
    bank that will make delivery of the funds on the paying bank's
    behalf in the country where the payment is to be made."""
    member_data_items_ = {
        'routingIds': MemberSpec_('routingIds', 'RoutingIds', 0),
        'routingExplicitDetails': MemberSpec_('routingExplicitDetails', 'RoutingExplicitDetails', 0),
        'routingIdsAndExplicitDetails': MemberSpec_('routingIdsAndExplicitDetails', 'RoutingIdsAndExplicitDetails', 0),
        'correspondentPartyReference': MemberSpec_('correspondentPartyReference', 'PartyReference', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, routingIds=None, routingExplicitDetails=None, routingIdsAndExplicitDetails=None, correspondentPartyReference=None):
        self.original_tagname_ = None
        self.routingIds = routingIds
        self.routingExplicitDetails = routingExplicitDetails
        self.routingIdsAndExplicitDetails = routingIdsAndExplicitDetails
        self.correspondentPartyReference = correspondentPartyReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CorrespondentInformation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CorrespondentInformation.subclass:
            return CorrespondentInformation.subclass(*args_, **kwargs_)
        else:
            return CorrespondentInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_routingIds(self): return self.routingIds
    def set_routingIds(self, routingIds): self.routingIds = routingIds
    def get_routingExplicitDetails(self): return self.routingExplicitDetails
    def set_routingExplicitDetails(self, routingExplicitDetails): self.routingExplicitDetails = routingExplicitDetails
    def get_routingIdsAndExplicitDetails(self): return self.routingIdsAndExplicitDetails
    def set_routingIdsAndExplicitDetails(self, routingIdsAndExplicitDetails): self.routingIdsAndExplicitDetails = routingIdsAndExplicitDetails
    def get_correspondentPartyReference(self): return self.correspondentPartyReference
    def set_correspondentPartyReference(self, correspondentPartyReference): self.correspondentPartyReference = correspondentPartyReference
    def hasContent_(self):
        if (
            self.routingIds is not None or
            self.routingExplicitDetails is not None or
            self.routingIdsAndExplicitDetails is not None or
            self.correspondentPartyReference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CorrespondentInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CorrespondentInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CorrespondentInformation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CorrespondentInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CorrespondentInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.routingIds is not None:
            self.routingIds.export(outfile, level, namespace_, name_='routingIds', pretty_print=pretty_print)
        if self.routingExplicitDetails is not None:
            self.routingExplicitDetails.export(outfile, level, namespace_, name_='routingExplicitDetails', pretty_print=pretty_print)
        if self.routingIdsAndExplicitDetails is not None:
            self.routingIdsAndExplicitDetails.export(outfile, level, namespace_, name_='routingIdsAndExplicitDetails', pretty_print=pretty_print)
        if self.correspondentPartyReference is not None:
            self.correspondentPartyReference.export(outfile, level, namespace_, name_='correspondentPartyReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'routingIds':
            obj_ = RoutingIds.factory()
            obj_.build(child_)
            self.routingIds = obj_
            obj_.original_tagname_ = 'routingIds'
        elif nodeName_ == 'routingExplicitDetails':
            obj_ = RoutingExplicitDetails.factory()
            obj_.build(child_)
            self.routingExplicitDetails = obj_
            obj_.original_tagname_ = 'routingExplicitDetails'
        elif nodeName_ == 'routingIdsAndExplicitDetails':
            obj_ = RoutingIdsAndExplicitDetails.factory()
            obj_.build(child_)
            self.routingIdsAndExplicitDetails = obj_
            obj_.original_tagname_ = 'routingIdsAndExplicitDetails'
        elif nodeName_ == 'correspondentPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.correspondentPartyReference = obj_
            obj_.original_tagname_ = 'correspondentPartyReference'
# end class CorrespondentInformation


class CountryCode(GeneratedsSuper):
    """The code representation of a country or an area of special
    sovereignty. By default it is a valid 2 character country code
    as defined by the ISO standard 3166-1 alpha-2 - Codes for
    representation of countries
    http://www.niso.org/standards/resources/3166.html."""
    member_data_items_ = {
        'countryScheme': MemberSpec_('countryScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, countryScheme='http://www.fpml.org/coding-scheme/external/iso3166', valueOf_=None):
        self.original_tagname_ = None
        self.countryScheme = _cast(None, countryScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CountryCode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CountryCode.subclass:
            return CountryCode.subclass(*args_, **kwargs_)
        else:
            return CountryCode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_countryScheme(self): return self.countryScheme
    def set_countryScheme(self, countryScheme): self.countryScheme = countryScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CountryCode', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CountryCode')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CountryCode', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CountryCode'):
        if self.countryScheme != "http://www.fpml.org/coding-scheme/external/iso3166" and 'countryScheme' not in already_processed:
            already_processed.add('countryScheme')
            outfile.write(' countryScheme=%s' % (quote_attrib(self.countryScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CountryCode', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('countryScheme', node)
        if value is not None and 'countryScheme' not in already_processed:
            already_processed.add('countryScheme')
            self.countryScheme = value
            self.validate_NonEmptyURI(self.countryScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CountryCode


class CreditSeniority(GeneratedsSuper):
    """The repayment precedence of a debt
    instrument.creditSeniorityTradingScheme overrides
    creditSeniorityScheme when the underlyer defines the reference
    obligation used in a single name credit default swap trade."""
    member_data_items_ = {
        'creditSeniorityScheme': MemberSpec_('creditSeniorityScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, creditSeniorityScheme='http://www.fpml.org/coding-scheme/credit-seniority', valueOf_=None):
        self.original_tagname_ = None
        self.creditSeniorityScheme = _cast(None, creditSeniorityScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditSeniority)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditSeniority.subclass:
            return CreditSeniority.subclass(*args_, **kwargs_)
        else:
            return CreditSeniority(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_creditSeniorityScheme(self): return self.creditSeniorityScheme
    def set_creditSeniorityScheme(self, creditSeniorityScheme): self.creditSeniorityScheme = creditSeniorityScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditSeniority', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditSeniority')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditSeniority', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditSeniority'):
        if self.creditSeniorityScheme != "http://www.fpml.org/coding-scheme/credit-seniority" and 'creditSeniorityScheme' not in already_processed:
            already_processed.add('creditSeniorityScheme')
            outfile.write(' creditSeniorityScheme=%s' % (quote_attrib(self.creditSeniorityScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CreditSeniority', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('creditSeniorityScheme', node)
        if value is not None and 'creditSeniorityScheme' not in already_processed:
            already_processed.add('creditSeniorityScheme')
            self.creditSeniorityScheme = value
            self.validate_NonEmptyURI(self.creditSeniorityScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CreditSeniority


class CreditSupportAgreement(GeneratedsSuper):
    """The agreement executed between the parties and intended to govern
    collateral arrangement for all OTC derivatives transactions
    between those parties."""
    member_data_items_ = {
        'type_': MemberSpec_('type_', 'CreditSupportAgreementType', 0),
        'date': MemberSpec_('date', 'xsd:date', 0),
        'identifier': MemberSpec_('identifier', 'CreditSupportAgreementIdentifier', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, type_=None, date=None, identifier=None):
        self.original_tagname_ = None
        self.type_ = type_
        if isinstance(date, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(date, '%Y-%m-%d').date()
        else:
            initvalue_ = date
        self.date = initvalue_
        self.identifier = identifier
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditSupportAgreement)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditSupportAgreement.subclass:
            return CreditSupportAgreement.subclass(*args_, **kwargs_)
        else:
            return CreditSupportAgreement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_date(self): return self.date
    def set_date(self, date): self.date = date
    def get_identifier(self): return self.identifier
    def set_identifier(self, identifier): self.identifier = identifier
    def hasContent_(self):
        if (
            self.type_ is not None or
            self.date is not None or
            self.identifier is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditSupportAgreement', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditSupportAgreement')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditSupportAgreement', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditSupportAgreement'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CreditSupportAgreement', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            self.type_.export(outfile, level, namespace_, name_='type', pretty_print=pretty_print)
        if self.date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdate>%s</%sdate>%s' % (namespace_, self.gds_format_date(self.date, input_name='date'), namespace_, eol_))
        if self.identifier is not None:
            self.identifier.export(outfile, level, namespace_, name_='identifier', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            obj_ = CreditSupportAgreementType.factory()
            obj_.build(child_)
            self.type_ = obj_
            obj_.original_tagname_ = 'type'
        elif nodeName_ == 'date':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.date = dval_
        elif nodeName_ == 'identifier':
            obj_ = CreditSupportAgreementIdentifier.factory()
            obj_.build(child_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
# end class CreditSupportAgreement


class CreditSupportAgreementIdentifier(GeneratedsSuper):
    member_data_items_ = {
        'creditSupportAgreementIdScheme': MemberSpec_('creditSupportAgreementIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, creditSupportAgreementIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.creditSupportAgreementIdScheme = _cast(None, creditSupportAgreementIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditSupportAgreementIdentifier)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditSupportAgreementIdentifier.subclass:
            return CreditSupportAgreementIdentifier.subclass(*args_, **kwargs_)
        else:
            return CreditSupportAgreementIdentifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_creditSupportAgreementIdScheme(self): return self.creditSupportAgreementIdScheme
    def set_creditSupportAgreementIdScheme(self, creditSupportAgreementIdScheme): self.creditSupportAgreementIdScheme = creditSupportAgreementIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditSupportAgreementIdentifier', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditSupportAgreementIdentifier')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditSupportAgreementIdentifier', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditSupportAgreementIdentifier'):
        if self.creditSupportAgreementIdScheme is not None and 'creditSupportAgreementIdScheme' not in already_processed:
            already_processed.add('creditSupportAgreementIdScheme')
            outfile.write(' creditSupportAgreementIdScheme=%s' % (quote_attrib(self.creditSupportAgreementIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CreditSupportAgreementIdentifier', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('creditSupportAgreementIdScheme', node)
        if value is not None and 'creditSupportAgreementIdScheme' not in already_processed:
            already_processed.add('creditSupportAgreementIdScheme')
            self.creditSupportAgreementIdScheme = value
            self.validate_NonEmptyURI(self.creditSupportAgreementIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CreditSupportAgreementIdentifier


class CreditSupportAgreementType(GeneratedsSuper):
    member_data_items_ = {
        'creditSupportAgreementTypeScheme': MemberSpec_('creditSupportAgreementTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, creditSupportAgreementTypeScheme='http://www.fpml.org/coding-scheme/credit-support-agreement-type', valueOf_=None):
        self.original_tagname_ = None
        self.creditSupportAgreementTypeScheme = _cast(None, creditSupportAgreementTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditSupportAgreementType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditSupportAgreementType.subclass:
            return CreditSupportAgreementType.subclass(*args_, **kwargs_)
        else:
            return CreditSupportAgreementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_creditSupportAgreementTypeScheme(self): return self.creditSupportAgreementTypeScheme
    def set_creditSupportAgreementTypeScheme(self, creditSupportAgreementTypeScheme): self.creditSupportAgreementTypeScheme = creditSupportAgreementTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditSupportAgreementType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditSupportAgreementType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditSupportAgreementType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditSupportAgreementType'):
        if self.creditSupportAgreementTypeScheme != "http://www.fpml.org/coding-scheme/credit-support-agreement-type" and 'creditSupportAgreementTypeScheme' not in already_processed:
            already_processed.add('creditSupportAgreementTypeScheme')
            outfile.write(' creditSupportAgreementTypeScheme=%s' % (quote_attrib(self.creditSupportAgreementTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CreditSupportAgreementType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('creditSupportAgreementTypeScheme', node)
        if value is not None and 'creditSupportAgreementTypeScheme' not in already_processed:
            already_processed.add('creditSupportAgreementTypeScheme')
            self.creditSupportAgreementTypeScheme = value
            self.validate_NonEmptyURI(self.creditSupportAgreementTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CreditSupportAgreementType


class CreditRating(GeneratedsSuper):
    """A party's credit rating."""
    member_data_items_ = {
        'creditRatingScheme': MemberSpec_('creditRatingScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, creditRatingScheme='http://www.fpml.org/coding-scheme/external/moodys', valueOf_=None):
        self.original_tagname_ = None
        self.creditRatingScheme = _cast(None, creditRatingScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditRating)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditRating.subclass:
            return CreditRating.subclass(*args_, **kwargs_)
        else:
            return CreditRating(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_creditRatingScheme(self): return self.creditRatingScheme
    def set_creditRatingScheme(self, creditRatingScheme): self.creditRatingScheme = creditRatingScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditRating', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditRating')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditRating', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditRating'):
        if self.creditRatingScheme != "http://www.fpml.org/coding-scheme/external/moodys" and 'creditRatingScheme' not in already_processed:
            already_processed.add('creditRatingScheme')
            outfile.write(' creditRatingScheme=%s' % (quote_attrib(self.creditRatingScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CreditRating', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('creditRatingScheme', node)
        if value is not None and 'creditRatingScheme' not in already_processed:
            already_processed.add('creditRatingScheme')
            self.creditRatingScheme = value
            self.validate_NonEmptyURI(self.creditRatingScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CreditRating


class Currency(GeneratedsSuper):
    """The code representation of a currency or fund. By default it is a
    valid currency code as defined by the ISO standard 4217 - Codes
    for representation of currencies and funds
    http://www.iso.org/iso/en/prods-
    services/popstds/currencycodeslist.html."""
    member_data_items_ = {
        'currencyScheme': MemberSpec_('currencyScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, currencyScheme='http://www.fpml.org/coding-scheme/external/iso4217-2001-08-15', valueOf_=None, extensiontype_=None):
        self.original_tagname_ = None
        self.currencyScheme = _cast(None, currencyScheme)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Currency)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Currency.subclass:
            return Currency.subclass(*args_, **kwargs_)
        else:
            return Currency(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_currencyScheme(self): return self.currencyScheme
    def set_currencyScheme(self, currencyScheme): self.currencyScheme = currencyScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Currency', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Currency')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Currency', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Currency'):
        if self.currencyScheme != "http://www.fpml.org/coding-scheme/external/iso4217-2001-08-15" and 'currencyScheme' not in already_processed:
            already_processed.add('currencyScheme')
            outfile.write(' currencyScheme=%s' % (quote_attrib(self.currencyScheme), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Currency', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('currencyScheme', node)
        if value is not None and 'currencyScheme' not in already_processed:
            already_processed.add('currencyScheme')
            self.currencyScheme = value
            self.validate_NonEmptyURI(self.currencyScheme)    # validate type NonEmptyURI
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Currency


class DateList(GeneratedsSuper):
    """List of Dates"""
    member_data_items_ = {
        'date': MemberSpec_('date', 'xsd:date', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, date=None):
        self.original_tagname_ = None
        if date is None:
            self.date = []
        else:
            self.date = date
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DateList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DateList.subclass:
            return DateList.subclass(*args_, **kwargs_)
        else:
            return DateList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_date(self): return self.date
    def set_date(self, date): self.date = date
    def add_date(self, value): self.date.append(value)
    def insert_date_at(self, index, value): self.date.insert(index, value)
    def replace_date_at(self, index, value): self.date[index] = value
    def hasContent_(self):
        if (
            self.date
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DateList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DateList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DateList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DateList'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DateList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for date_ in self.date:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdate>%s</%sdate>%s' % (namespace_, self.gds_format_date(date_, input_name='date'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'date':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.date.append(dval_)
# end class DateList


class DateRange(GeneratedsSuper):
    """A type defining a contiguous series of calendar dates. The date
    range is defined as all the dates between and including the
    first and the last date. The first date must fall before the
    last date."""
    member_data_items_ = {
        'unadjustedFirstDate': MemberSpec_('unadjustedFirstDate', 'xsd:date', 0),
        'unadjustedLastDate': MemberSpec_('unadjustedLastDate', 'xsd:date', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, unadjustedFirstDate=None, unadjustedLastDate=None, extensiontype_=None):
        self.original_tagname_ = None
        if isinstance(unadjustedFirstDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(unadjustedFirstDate, '%Y-%m-%d').date()
        else:
            initvalue_ = unadjustedFirstDate
        self.unadjustedFirstDate = initvalue_
        if isinstance(unadjustedLastDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(unadjustedLastDate, '%Y-%m-%d').date()
        else:
            initvalue_ = unadjustedLastDate
        self.unadjustedLastDate = initvalue_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DateRange)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DateRange.subclass:
            return DateRange.subclass(*args_, **kwargs_)
        else:
            return DateRange(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unadjustedFirstDate(self): return self.unadjustedFirstDate
    def set_unadjustedFirstDate(self, unadjustedFirstDate): self.unadjustedFirstDate = unadjustedFirstDate
    def get_unadjustedLastDate(self): return self.unadjustedLastDate
    def set_unadjustedLastDate(self, unadjustedLastDate): self.unadjustedLastDate = unadjustedLastDate
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.unadjustedFirstDate is not None or
            self.unadjustedLastDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DateRange', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DateRange')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DateRange', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DateRange'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DateRange', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.unadjustedFirstDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sunadjustedFirstDate>%s</%sunadjustedFirstDate>%s' % (namespace_, self.gds_format_date(self.unadjustedFirstDate, input_name='unadjustedFirstDate'), namespace_, eol_))
        if self.unadjustedLastDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sunadjustedLastDate>%s</%sunadjustedLastDate>%s' % (namespace_, self.gds_format_date(self.unadjustedLastDate, input_name='unadjustedLastDate'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'unadjustedFirstDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.unadjustedFirstDate = dval_
        elif nodeName_ == 'unadjustedLastDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.unadjustedLastDate = dval_
# end class DateRange


class DateTimeList(GeneratedsSuper):
    """List of DateTimes"""
    member_data_items_ = {
        'dateTime': MemberSpec_('dateTime', 'xsd:dateTime', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, dateTime=None):
        self.original_tagname_ = None
        if dateTime is None:
            self.dateTime = []
        else:
            self.dateTime = dateTime
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DateTimeList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DateTimeList.subclass:
            return DateTimeList.subclass(*args_, **kwargs_)
        else:
            return DateTimeList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dateTime(self): return self.dateTime
    def set_dateTime(self, dateTime): self.dateTime = dateTime
    def add_dateTime(self, value): self.dateTime.append(value)
    def insert_dateTime_at(self, index, value): self.dateTime.insert(index, value)
    def replace_dateTime_at(self, index, value): self.dateTime[index] = value
    def hasContent_(self):
        if (
            self.dateTime
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DateTimeList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DateTimeList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DateTimeList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DateTimeList'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DateTimeList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for dateTime_ in self.dateTime:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdateTime>%s</%sdateTime>%s' % (namespace_, self.gds_format_datetime(dateTime_, input_name='dateTime'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.dateTime.append(dval_)
# end class DateTimeList


class DayCountFraction(GeneratedsSuper):
    """The specification for how the number of days between two dates is
    calculated for purposes of calculation of a fixed or floating
    payment amount and the basis for how many days are assumed to be
    in a year. Day Count Fraction is an ISDA term. The equivalent
    AFB (Association Francaise de Banques) term is Calculation
    Basis."""
    member_data_items_ = {
        'dayCountFractionScheme': MemberSpec_('dayCountFractionScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, dayCountFractionScheme='http://www.fpml.org/coding-scheme/day-count-fraction', valueOf_=None):
        self.original_tagname_ = None
        self.dayCountFractionScheme = _cast(None, dayCountFractionScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DayCountFraction)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DayCountFraction.subclass:
            return DayCountFraction.subclass(*args_, **kwargs_)
        else:
            return DayCountFraction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dayCountFractionScheme(self): return self.dayCountFractionScheme
    def set_dayCountFractionScheme(self, dayCountFractionScheme): self.dayCountFractionScheme = dayCountFractionScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DayCountFraction', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DayCountFraction')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DayCountFraction', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DayCountFraction'):
        if self.dayCountFractionScheme != "http://www.fpml.org/coding-scheme/day-count-fraction" and 'dayCountFractionScheme' not in already_processed:
            already_processed.add('dayCountFractionScheme')
            outfile.write(' dayCountFractionScheme=%s' % (quote_attrib(self.dayCountFractionScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DayCountFraction', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dayCountFractionScheme', node)
        if value is not None and 'dayCountFractionScheme' not in already_processed:
            already_processed.add('dayCountFractionScheme')
            self.dayCountFractionScheme = value
            self.validate_NonEmptyURI(self.dayCountFractionScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DayCountFraction


class DeterminationMethod(GeneratedsSuper):
    """Coding scheme that specifies the method according to which an amount
    or a date is determined."""
    member_data_items_ = {
        'determinationMethodScheme': MemberSpec_('determinationMethodScheme', 'NonEmptyURI', 0),
        'id': MemberSpec_('id', 'xsd:string', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, determinationMethodScheme='http://www.fpml.org/coding-scheme/determination-method', id=None, valueOf_=None):
        self.original_tagname_ = None
        self.determinationMethodScheme = _cast(None, determinationMethodScheme)
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DeterminationMethod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DeterminationMethod.subclass:
            return DeterminationMethod.subclass(*args_, **kwargs_)
        else:
            return DeterminationMethod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_determinationMethodScheme(self): return self.determinationMethodScheme
    def set_determinationMethodScheme(self, determinationMethodScheme): self.determinationMethodScheme = determinationMethodScheme
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DeterminationMethod', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeterminationMethod')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DeterminationMethod', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DeterminationMethod'):
        if self.determinationMethodScheme != "http://www.fpml.org/coding-scheme/determination-method" and 'determinationMethodScheme' not in already_processed:
            already_processed.add('determinationMethodScheme')
            outfile.write(' determinationMethodScheme=%s' % (quote_attrib(self.determinationMethodScheme), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DeterminationMethod', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('determinationMethodScheme', node)
        if value is not None and 'determinationMethodScheme' not in already_processed:
            already_processed.add('determinationMethodScheme')
            self.determinationMethodScheme = value
            self.validate_NonEmptyURI(self.determinationMethodScheme)    # validate type NonEmptyURI
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DeterminationMethod


class Documentation(GeneratedsSuper):
    """An entity for defining the definitions that govern the document and
    should include the year and type of definitions referenced,
    along with any relevant documentation (such as master agreement)
    and the date it was signed."""
    member_data_items_ = {
        'masterAgreement': MemberSpec_('masterAgreement', 'MasterAgreement', 0),
        'masterConfirmation': MemberSpec_('masterConfirmation', 'MasterConfirmation', 0),
        'brokerConfirmation': MemberSpec_('brokerConfirmation', 'BrokerConfirmation', 0),
        'contractualDefinitions': MemberSpec_('contractualDefinitions', 'ContractualDefinitions', 1),
        'contractualTermsSupplement': MemberSpec_('contractualTermsSupplement', 'ContractualTermsSupplement', 1),
        'contractualMatrix': MemberSpec_('contractualMatrix', 'ContractualMatrix', 1),
        'creditSupportAgreement': MemberSpec_('creditSupportAgreement', 'CreditSupportAgreement', 0),
        'attachment': MemberSpec_('attachment', 'Resource', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, masterAgreement=None, masterConfirmation=None, brokerConfirmation=None, contractualDefinitions=None, contractualTermsSupplement=None, contractualMatrix=None, creditSupportAgreement=None, attachment=None):
        self.original_tagname_ = None
        self.masterAgreement = masterAgreement
        self.masterConfirmation = masterConfirmation
        self.brokerConfirmation = brokerConfirmation
        if contractualDefinitions is None:
            self.contractualDefinitions = []
        else:
            self.contractualDefinitions = contractualDefinitions
        if contractualTermsSupplement is None:
            self.contractualTermsSupplement = []
        else:
            self.contractualTermsSupplement = contractualTermsSupplement
        if contractualMatrix is None:
            self.contractualMatrix = []
        else:
            self.contractualMatrix = contractualMatrix
        self.creditSupportAgreement = creditSupportAgreement
        if attachment is None:
            self.attachment = []
        else:
            self.attachment = attachment
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Documentation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Documentation.subclass:
            return Documentation.subclass(*args_, **kwargs_)
        else:
            return Documentation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_masterAgreement(self): return self.masterAgreement
    def set_masterAgreement(self, masterAgreement): self.masterAgreement = masterAgreement
    def get_masterConfirmation(self): return self.masterConfirmation
    def set_masterConfirmation(self, masterConfirmation): self.masterConfirmation = masterConfirmation
    def get_brokerConfirmation(self): return self.brokerConfirmation
    def set_brokerConfirmation(self, brokerConfirmation): self.brokerConfirmation = brokerConfirmation
    def get_contractualDefinitions(self): return self.contractualDefinitions
    def set_contractualDefinitions(self, contractualDefinitions): self.contractualDefinitions = contractualDefinitions
    def add_contractualDefinitions(self, value): self.contractualDefinitions.append(value)
    def insert_contractualDefinitions_at(self, index, value): self.contractualDefinitions.insert(index, value)
    def replace_contractualDefinitions_at(self, index, value): self.contractualDefinitions[index] = value
    def get_contractualTermsSupplement(self): return self.contractualTermsSupplement
    def set_contractualTermsSupplement(self, contractualTermsSupplement): self.contractualTermsSupplement = contractualTermsSupplement
    def add_contractualTermsSupplement(self, value): self.contractualTermsSupplement.append(value)
    def insert_contractualTermsSupplement_at(self, index, value): self.contractualTermsSupplement.insert(index, value)
    def replace_contractualTermsSupplement_at(self, index, value): self.contractualTermsSupplement[index] = value
    def get_contractualMatrix(self): return self.contractualMatrix
    def set_contractualMatrix(self, contractualMatrix): self.contractualMatrix = contractualMatrix
    def add_contractualMatrix(self, value): self.contractualMatrix.append(value)
    def insert_contractualMatrix_at(self, index, value): self.contractualMatrix.insert(index, value)
    def replace_contractualMatrix_at(self, index, value): self.contractualMatrix[index] = value
    def get_creditSupportAgreement(self): return self.creditSupportAgreement
    def set_creditSupportAgreement(self, creditSupportAgreement): self.creditSupportAgreement = creditSupportAgreement
    def get_attachment(self): return self.attachment
    def set_attachment(self, attachment): self.attachment = attachment
    def add_attachment(self, value): self.attachment.append(value)
    def insert_attachment_at(self, index, value): self.attachment.insert(index, value)
    def replace_attachment_at(self, index, value): self.attachment[index] = value
    def hasContent_(self):
        if (
            self.masterAgreement is not None or
            self.masterConfirmation is not None or
            self.brokerConfirmation is not None or
            self.contractualDefinitions or
            self.contractualTermsSupplement or
            self.contractualMatrix or
            self.creditSupportAgreement is not None or
            self.attachment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Documentation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Documentation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Documentation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Documentation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Documentation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.masterAgreement is not None:
            self.masterAgreement.export(outfile, level, namespace_, name_='masterAgreement', pretty_print=pretty_print)
        if self.masterConfirmation is not None:
            self.masterConfirmation.export(outfile, level, namespace_, name_='masterConfirmation', pretty_print=pretty_print)
        if self.brokerConfirmation is not None:
            self.brokerConfirmation.export(outfile, level, namespace_, name_='brokerConfirmation', pretty_print=pretty_print)
        for contractualDefinitions_ in self.contractualDefinitions:
            contractualDefinitions_.export(outfile, level, namespace_, name_='contractualDefinitions', pretty_print=pretty_print)
        for contractualTermsSupplement_ in self.contractualTermsSupplement:
            contractualTermsSupplement_.export(outfile, level, namespace_, name_='contractualTermsSupplement', pretty_print=pretty_print)
        for contractualMatrix_ in self.contractualMatrix:
            contractualMatrix_.export(outfile, level, namespace_, name_='contractualMatrix', pretty_print=pretty_print)
        if self.creditSupportAgreement is not None:
            self.creditSupportAgreement.export(outfile, level, namespace_, name_='creditSupportAgreement', pretty_print=pretty_print)
        for attachment_ in self.attachment:
            attachment_.export(outfile, level, namespace_, name_='attachment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'masterAgreement':
            obj_ = MasterAgreement.factory()
            obj_.build(child_)
            self.masterAgreement = obj_
            obj_.original_tagname_ = 'masterAgreement'
        elif nodeName_ == 'masterConfirmation':
            obj_ = MasterConfirmation.factory()
            obj_.build(child_)
            self.masterConfirmation = obj_
            obj_.original_tagname_ = 'masterConfirmation'
        elif nodeName_ == 'brokerConfirmation':
            obj_ = BrokerConfirmation.factory()
            obj_.build(child_)
            self.brokerConfirmation = obj_
            obj_.original_tagname_ = 'brokerConfirmation'
        elif nodeName_ == 'contractualDefinitions':
            obj_ = ContractualDefinitions.factory()
            obj_.build(child_)
            self.contractualDefinitions.append(obj_)
            obj_.original_tagname_ = 'contractualDefinitions'
        elif nodeName_ == 'contractualTermsSupplement':
            obj_ = ContractualTermsSupplement.factory()
            obj_.build(child_)
            self.contractualTermsSupplement.append(obj_)
            obj_.original_tagname_ = 'contractualTermsSupplement'
        elif nodeName_ == 'contractualMatrix':
            obj_ = ContractualMatrix.factory()
            obj_.build(child_)
            self.contractualMatrix.append(obj_)
            obj_.original_tagname_ = 'contractualMatrix'
        elif nodeName_ == 'creditSupportAgreement':
            obj_ = CreditSupportAgreement.factory()
            obj_.build(child_)
            self.creditSupportAgreement = obj_
            obj_.original_tagname_ = 'creditSupportAgreement'
        elif nodeName_ == 'attachment':
            obj_ = Resource.factory()
            obj_.build(child_)
            self.attachment.append(obj_)
            obj_.original_tagname_ = 'attachment'
# end class Documentation


class EmbeddedOptionType(GeneratedsSuper):
    """A flexible description of the type or characteristics of an option
    embbedded within another product. For example, a cancelable
    provision or an optional early termination provision.The type
    scheme used with this option type."""
    member_data_items_ = {
        'embeddedOptionTypeScheme': MemberSpec_('embeddedOptionTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, embeddedOptionTypeScheme='http://www.fpml.org/coding-scheme/embedded-option-type', valueOf_=None):
        self.original_tagname_ = None
        self.embeddedOptionTypeScheme = _cast(None, embeddedOptionTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EmbeddedOptionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EmbeddedOptionType.subclass:
            return EmbeddedOptionType.subclass(*args_, **kwargs_)
        else:
            return EmbeddedOptionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_embeddedOptionTypeScheme(self): return self.embeddedOptionTypeScheme
    def set_embeddedOptionTypeScheme(self, embeddedOptionTypeScheme): self.embeddedOptionTypeScheme = embeddedOptionTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EmbeddedOptionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EmbeddedOptionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EmbeddedOptionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EmbeddedOptionType'):
        if self.embeddedOptionTypeScheme != "http://www.fpml.org/coding-scheme/embedded-option-type" and 'embeddedOptionTypeScheme' not in already_processed:
            already_processed.add('embeddedOptionTypeScheme')
            outfile.write(' embeddedOptionTypeScheme=%s' % (quote_attrib(self.embeddedOptionTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EmbeddedOptionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('embeddedOptionTypeScheme', node)
        if value is not None and 'embeddedOptionTypeScheme' not in already_processed:
            already_processed.add('embeddedOptionTypeScheme')
            self.embeddedOptionTypeScheme = value
            self.validate_NonEmptyURI(self.embeddedOptionTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EmbeddedOptionType


class Empty(GeneratedsSuper):
    """A special type meant to be used for elements with no content and no
    attributes."""
    member_data_items_ = {
    }
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Empty)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Empty.subclass:
            return Empty.subclass(*args_, **kwargs_)
        else:
            return Empty(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Empty', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Empty')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Empty', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Empty'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Empty', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Empty


class EntityId(GeneratedsSuper):
    """A legal entity identifier (e.g. RED entity code)."""
    member_data_items_ = {
        'entityIdScheme': MemberSpec_('entityIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, entityIdScheme='http://www.fpml.org/coding-scheme/external/entity-id-RED-1-0', valueOf_=None):
        self.original_tagname_ = None
        self.entityIdScheme = _cast(None, entityIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntityId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntityId.subclass:
            return EntityId.subclass(*args_, **kwargs_)
        else:
            return EntityId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_entityIdScheme(self): return self.entityIdScheme
    def set_entityIdScheme(self, entityIdScheme): self.entityIdScheme = entityIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EntityId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EntityId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EntityId'):
        if self.entityIdScheme != "http://www.fpml.org/coding-scheme/external/entity-id-RED-1-0" and 'entityIdScheme' not in already_processed:
            already_processed.add('entityIdScheme')
            outfile.write(' entityIdScheme=%s' % (quote_attrib(self.entityIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EntityId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('entityIdScheme', node)
        if value is not None and 'entityIdScheme' not in already_processed:
            already_processed.add('entityIdScheme')
            self.entityIdScheme = value
            self.validate_NonEmptyURI(self.entityIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntityId


class EntityName(GeneratedsSuper):
    """The name of the reference entity. A free format string. FpML does
    not define usage rules for this element."""
    member_data_items_ = {
        'entityNameScheme': MemberSpec_('entityNameScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, entityNameScheme='http://www.fpml.org/coding-scheme/external/entity-name-RED-1-0', valueOf_=None):
        self.original_tagname_ = None
        self.entityNameScheme = _cast(None, entityNameScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntityName)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntityName.subclass:
            return EntityName.subclass(*args_, **kwargs_)
        else:
            return EntityName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_entityNameScheme(self): return self.entityNameScheme
    def set_entityNameScheme(self, entityNameScheme): self.entityNameScheme = entityNameScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EntityName', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityName')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EntityName', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EntityName'):
        if self.entityNameScheme != "http://www.fpml.org/coding-scheme/external/entity-name-RED-1-0" and 'entityNameScheme' not in already_processed:
            already_processed.add('entityNameScheme')
            outfile.write(' entityNameScheme=%s' % (quote_attrib(self.entityNameScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EntityName', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('entityNameScheme', node)
        if value is not None and 'entityNameScheme' not in already_processed:
            already_processed.add('entityNameScheme')
            self.entityNameScheme = value
            self.validate_NonEmptyURI(self.entityNameScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntityName


class ExchangeId(GeneratedsSuper):
    """A short form unique identifier for an exchange. If the element is
    not present then the exchange shall be the primary exchange on
    which the underlying is listed. The term "Exchange" is assumed
    to have the meaning as defined in the ISDA 2002 Equity
    Derivatives Definitions."""
    member_data_items_ = {
        'exchangeIdScheme': MemberSpec_('exchangeIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, exchangeIdScheme='http://www.fpml.org/coding-scheme/external/exchange-id-MIC-1-0', valueOf_=None):
        self.original_tagname_ = None
        self.exchangeIdScheme = _cast(None, exchangeIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExchangeId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExchangeId.subclass:
            return ExchangeId.subclass(*args_, **kwargs_)
        else:
            return ExchangeId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_exchangeIdScheme(self): return self.exchangeIdScheme
    def set_exchangeIdScheme(self, exchangeIdScheme): self.exchangeIdScheme = exchangeIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExchangeId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExchangeId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExchangeId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExchangeId'):
        if self.exchangeIdScheme != "http://www.fpml.org/coding-scheme/external/exchange-id-MIC-1-0" and 'exchangeIdScheme' not in already_processed:
            already_processed.add('exchangeIdScheme')
            outfile.write(' exchangeIdScheme=%s' % (quote_attrib(self.exchangeIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ExchangeId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('exchangeIdScheme', node)
        if value is not None and 'exchangeIdScheme' not in already_processed:
            already_processed.add('exchangeIdScheme')
            self.exchangeIdScheme = value
            self.validate_NonEmptyURI(self.exchangeIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ExchangeId


class Exercise(GeneratedsSuper):
    """The abstract base class for all types which define way in which
    options may be exercised."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Exercise)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Exercise.subclass:
            return Exercise.subclass(*args_, **kwargs_)
        else:
            return Exercise(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Exercise', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Exercise')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Exercise', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Exercise'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Exercise', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Exercise


class ExerciseFee(GeneratedsSuper):
    """A type defining the fee payable on exercise of an option. This fee
    may be defined as an amount or a percentage of the notional
    exercised."""
    member_data_items_ = {
        'payerPartyReference': MemberSpec_('payerPartyReference', 'PartyReference', 0),
        'payerAccountReference': MemberSpec_('payerAccountReference', 'AccountReference', 0),
        'receiverPartyReference': MemberSpec_('receiverPartyReference', 'PartyReference', 0),
        'receiverAccountReference': MemberSpec_('receiverAccountReference', 'AccountReference', 0),
        'notionalReference': MemberSpec_('notionalReference', 'NotionalReference', 0),
        'feeAmount': MemberSpec_('feeAmount', 'xsd:decimal', 0),
        'feeRate': MemberSpec_('feeRate', 'xsd:decimal', 0),
        'feePaymentDate': MemberSpec_('feePaymentDate', 'RelativeDateOffset', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, notionalReference=None, feeAmount=None, feeRate=None, feePaymentDate=None):
        self.original_tagname_ = None
        self.payerPartyReference = payerPartyReference
        self.payerAccountReference = payerAccountReference
        self.receiverPartyReference = receiverPartyReference
        self.receiverAccountReference = receiverAccountReference
        self.notionalReference = notionalReference
        self.feeAmount = feeAmount
        self.feeRate = feeRate
        self.feePaymentDate = feePaymentDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExerciseFee)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExerciseFee.subclass:
            return ExerciseFee.subclass(*args_, **kwargs_)
        else:
            return ExerciseFee(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_payerPartyReference(self): return self.payerPartyReference
    def set_payerPartyReference(self, payerPartyReference): self.payerPartyReference = payerPartyReference
    def get_payerAccountReference(self): return self.payerAccountReference
    def set_payerAccountReference(self, payerAccountReference): self.payerAccountReference = payerAccountReference
    def get_receiverPartyReference(self): return self.receiverPartyReference
    def set_receiverPartyReference(self, receiverPartyReference): self.receiverPartyReference = receiverPartyReference
    def get_receiverAccountReference(self): return self.receiverAccountReference
    def set_receiverAccountReference(self, receiverAccountReference): self.receiverAccountReference = receiverAccountReference
    def get_notionalReference(self): return self.notionalReference
    def set_notionalReference(self, notionalReference): self.notionalReference = notionalReference
    def get_feeAmount(self): return self.feeAmount
    def set_feeAmount(self, feeAmount): self.feeAmount = feeAmount
    def get_feeRate(self): return self.feeRate
    def set_feeRate(self, feeRate): self.feeRate = feeRate
    def get_feePaymentDate(self): return self.feePaymentDate
    def set_feePaymentDate(self, feePaymentDate): self.feePaymentDate = feePaymentDate
    def hasContent_(self):
        if (
            self.payerPartyReference is not None or
            self.payerAccountReference is not None or
            self.receiverPartyReference is not None or
            self.receiverAccountReference is not None or
            self.notionalReference is not None or
            self.feeAmount is not None or
            self.feeRate is not None or
            self.feePaymentDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExerciseFee', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExerciseFee')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExerciseFee', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExerciseFee'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ExerciseFee', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.payerPartyReference is not None:
            self.payerPartyReference.export(outfile, level, namespace_, name_='payerPartyReference', pretty_print=pretty_print)
        if self.payerAccountReference is not None:
            self.payerAccountReference.export(outfile, level, namespace_, name_='payerAccountReference', pretty_print=pretty_print)
        if self.receiverPartyReference is not None:
            self.receiverPartyReference.export(outfile, level, namespace_, name_='receiverPartyReference', pretty_print=pretty_print)
        if self.receiverAccountReference is not None:
            self.receiverAccountReference.export(outfile, level, namespace_, name_='receiverAccountReference', pretty_print=pretty_print)
        if self.notionalReference is not None:
            self.notionalReference.export(outfile, level, namespace_, name_='notionalReference', pretty_print=pretty_print)
        if self.feeAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfeeAmount>%s</%sfeeAmount>%s' % (namespace_, self.gds_format_float(self.feeAmount, input_name='feeAmount'), namespace_, eol_))
        if self.feeRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfeeRate>%s</%sfeeRate>%s' % (namespace_, self.gds_format_float(self.feeRate, input_name='feeRate'), namespace_, eol_))
        if self.feePaymentDate is not None:
            self.feePaymentDate.export(outfile, level, namespace_, name_='feePaymentDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'payerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.payerPartyReference = obj_
            obj_.original_tagname_ = 'payerPartyReference'
        elif nodeName_ == 'payerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.payerAccountReference = obj_
            obj_.original_tagname_ = 'payerAccountReference'
        elif nodeName_ == 'receiverPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.receiverPartyReference = obj_
            obj_.original_tagname_ = 'receiverPartyReference'
        elif nodeName_ == 'receiverAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.receiverAccountReference = obj_
            obj_.original_tagname_ = 'receiverAccountReference'
        elif nodeName_ == 'notionalReference':
            obj_ = NotionalReference.factory()
            obj_.build(child_)
            self.notionalReference = obj_
            obj_.original_tagname_ = 'notionalReference'
        elif nodeName_ == 'feeAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'feeAmount')
            self.feeAmount = fval_
        elif nodeName_ == 'feeRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'feeRate')
            self.feeRate = fval_
        elif nodeName_ == 'feePaymentDate':
            class_obj_ = self.get_class_obj_(child_, RelativeDateOffset)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.feePaymentDate = obj_
            obj_.original_tagname_ = 'feePaymentDate'
# end class ExerciseFee


class ExerciseFeeSchedule(GeneratedsSuper):
    """A type to define a fee or schedule of fees to be payable on the
    exercise of an option. This fee may be defined as an amount or a
    percentage of the notional exercised."""
    member_data_items_ = {
        'payerPartyReference': MemberSpec_('payerPartyReference', 'PartyReference', 0),
        'payerAccountReference': MemberSpec_('payerAccountReference', 'AccountReference', 0),
        'receiverPartyReference': MemberSpec_('receiverPartyReference', 'PartyReference', 0),
        'receiverAccountReference': MemberSpec_('receiverAccountReference', 'AccountReference', 0),
        'notionalReference': MemberSpec_('notionalReference', 'ScheduleReference', 0),
        'feeAmountSchedule': MemberSpec_('feeAmountSchedule', 'AmountSchedule', 0),
        'feeRateSchedule': MemberSpec_('feeRateSchedule', 'Schedule', 0),
        'feePaymentDate': MemberSpec_('feePaymentDate', 'RelativeDateOffset', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, notionalReference=None, feeAmountSchedule=None, feeRateSchedule=None, feePaymentDate=None):
        self.original_tagname_ = None
        self.payerPartyReference = payerPartyReference
        self.payerAccountReference = payerAccountReference
        self.receiverPartyReference = receiverPartyReference
        self.receiverAccountReference = receiverAccountReference
        self.notionalReference = notionalReference
        self.feeAmountSchedule = feeAmountSchedule
        self.feeRateSchedule = feeRateSchedule
        self.feePaymentDate = feePaymentDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExerciseFeeSchedule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExerciseFeeSchedule.subclass:
            return ExerciseFeeSchedule.subclass(*args_, **kwargs_)
        else:
            return ExerciseFeeSchedule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_payerPartyReference(self): return self.payerPartyReference
    def set_payerPartyReference(self, payerPartyReference): self.payerPartyReference = payerPartyReference
    def get_payerAccountReference(self): return self.payerAccountReference
    def set_payerAccountReference(self, payerAccountReference): self.payerAccountReference = payerAccountReference
    def get_receiverPartyReference(self): return self.receiverPartyReference
    def set_receiverPartyReference(self, receiverPartyReference): self.receiverPartyReference = receiverPartyReference
    def get_receiverAccountReference(self): return self.receiverAccountReference
    def set_receiverAccountReference(self, receiverAccountReference): self.receiverAccountReference = receiverAccountReference
    def get_notionalReference(self): return self.notionalReference
    def set_notionalReference(self, notionalReference): self.notionalReference = notionalReference
    def get_feeAmountSchedule(self): return self.feeAmountSchedule
    def set_feeAmountSchedule(self, feeAmountSchedule): self.feeAmountSchedule = feeAmountSchedule
    def get_feeRateSchedule(self): return self.feeRateSchedule
    def set_feeRateSchedule(self, feeRateSchedule): self.feeRateSchedule = feeRateSchedule
    def get_feePaymentDate(self): return self.feePaymentDate
    def set_feePaymentDate(self, feePaymentDate): self.feePaymentDate = feePaymentDate
    def hasContent_(self):
        if (
            self.payerPartyReference is not None or
            self.payerAccountReference is not None or
            self.receiverPartyReference is not None or
            self.receiverAccountReference is not None or
            self.notionalReference is not None or
            self.feeAmountSchedule is not None or
            self.feeRateSchedule is not None or
            self.feePaymentDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExerciseFeeSchedule', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExerciseFeeSchedule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExerciseFeeSchedule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExerciseFeeSchedule'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ExerciseFeeSchedule', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.payerPartyReference is not None:
            self.payerPartyReference.export(outfile, level, namespace_, name_='payerPartyReference', pretty_print=pretty_print)
        if self.payerAccountReference is not None:
            self.payerAccountReference.export(outfile, level, namespace_, name_='payerAccountReference', pretty_print=pretty_print)
        if self.receiverPartyReference is not None:
            self.receiverPartyReference.export(outfile, level, namespace_, name_='receiverPartyReference', pretty_print=pretty_print)
        if self.receiverAccountReference is not None:
            self.receiverAccountReference.export(outfile, level, namespace_, name_='receiverAccountReference', pretty_print=pretty_print)
        if self.notionalReference is not None:
            self.notionalReference.export(outfile, level, namespace_, name_='notionalReference', pretty_print=pretty_print)
        if self.feeAmountSchedule is not None:
            self.feeAmountSchedule.export(outfile, level, namespace_, name_='feeAmountSchedule', pretty_print=pretty_print)
        if self.feeRateSchedule is not None:
            self.feeRateSchedule.export(outfile, level, namespace_, name_='feeRateSchedule', pretty_print=pretty_print)
        if self.feePaymentDate is not None:
            self.feePaymentDate.export(outfile, level, namespace_, name_='feePaymentDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'payerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.payerPartyReference = obj_
            obj_.original_tagname_ = 'payerPartyReference'
        elif nodeName_ == 'payerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.payerAccountReference = obj_
            obj_.original_tagname_ = 'payerAccountReference'
        elif nodeName_ == 'receiverPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.receiverPartyReference = obj_
            obj_.original_tagname_ = 'receiverPartyReference'
        elif nodeName_ == 'receiverAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.receiverAccountReference = obj_
            obj_.original_tagname_ = 'receiverAccountReference'
        elif nodeName_ == 'notionalReference':
            obj_ = ScheduleReference.factory()
            obj_.build(child_)
            self.notionalReference = obj_
            obj_.original_tagname_ = 'notionalReference'
        elif nodeName_ == 'feeAmountSchedule':
            obj_ = AmountSchedule.factory()
            obj_.build(child_)
            self.feeAmountSchedule = obj_
            obj_.original_tagname_ = 'feeAmountSchedule'
        elif nodeName_ == 'feeRateSchedule':
            class_obj_ = self.get_class_obj_(child_, Schedule)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.feeRateSchedule = obj_
            obj_.original_tagname_ = 'feeRateSchedule'
        elif nodeName_ == 'feePaymentDate':
            class_obj_ = self.get_class_obj_(child_, RelativeDateOffset)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.feePaymentDate = obj_
            obj_.original_tagname_ = 'feePaymentDate'
# end class ExerciseFeeSchedule


class ExerciseNotice(GeneratedsSuper):
    """A type defining to whom and where notice of execution should be
    given. The partyReference refers to one of the principal parties
    of the trade. If present the exerciseNoticePartyReference refers
    to a party, other than the principal party, to whome notice
    should be given."""
    member_data_items_ = {
        'partyReference': MemberSpec_('partyReference', 'PartyReference', 0),
        'exerciseNoticePartyReference': MemberSpec_('exerciseNoticePartyReference', 'PartyReference', 0),
        'businessCenter': MemberSpec_('businessCenter', 'BusinessCenter', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, partyReference=None, exerciseNoticePartyReference=None, businessCenter=None):
        self.original_tagname_ = None
        self.partyReference = partyReference
        self.exerciseNoticePartyReference = exerciseNoticePartyReference
        self.businessCenter = businessCenter
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExerciseNotice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExerciseNotice.subclass:
            return ExerciseNotice.subclass(*args_, **kwargs_)
        else:
            return ExerciseNotice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyReference(self): return self.partyReference
    def set_partyReference(self, partyReference): self.partyReference = partyReference
    def get_exerciseNoticePartyReference(self): return self.exerciseNoticePartyReference
    def set_exerciseNoticePartyReference(self, exerciseNoticePartyReference): self.exerciseNoticePartyReference = exerciseNoticePartyReference
    def get_businessCenter(self): return self.businessCenter
    def set_businessCenter(self, businessCenter): self.businessCenter = businessCenter
    def hasContent_(self):
        if (
            self.partyReference is not None or
            self.exerciseNoticePartyReference is not None or
            self.businessCenter is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExerciseNotice', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExerciseNotice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExerciseNotice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExerciseNotice'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ExerciseNotice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.partyReference is not None:
            self.partyReference.export(outfile, level, namespace_, name_='partyReference', pretty_print=pretty_print)
        if self.exerciseNoticePartyReference is not None:
            self.exerciseNoticePartyReference.export(outfile, level, namespace_, name_='exerciseNoticePartyReference', pretty_print=pretty_print)
        if self.businessCenter is not None:
            self.businessCenter.export(outfile, level, namespace_, name_='businessCenter', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'partyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.partyReference = obj_
            obj_.original_tagname_ = 'partyReference'
        elif nodeName_ == 'exerciseNoticePartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.exerciseNoticePartyReference = obj_
            obj_.original_tagname_ = 'exerciseNoticePartyReference'
        elif nodeName_ == 'businessCenter':
            obj_ = BusinessCenter.factory()
            obj_.build(child_)
            self.businessCenter = obj_
            obj_.original_tagname_ = 'businessCenter'
# end class ExerciseNotice


class ExerciseProcedure(GeneratedsSuper):
    """A type describing how notice of exercise should be given. This can
    be either manual or automatic."""
    member_data_items_ = {
        'manualExercise': MemberSpec_('manualExercise', 'ManualExercise', 0),
        'automaticExercise': MemberSpec_('automaticExercise', 'AutomaticExercise', 0),
        'followUpConfirmation': MemberSpec_('followUpConfirmation', 'xsd:boolean', 0),
        'limitedRightToConfirm': MemberSpec_('limitedRightToConfirm', 'xsd:boolean', 0),
        'splitTicket': MemberSpec_('splitTicket', 'xsd:boolean', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, manualExercise=None, automaticExercise=None, followUpConfirmation=None, limitedRightToConfirm=None, splitTicket=None):
        self.original_tagname_ = None
        self.manualExercise = manualExercise
        self.automaticExercise = automaticExercise
        self.followUpConfirmation = followUpConfirmation
        self.limitedRightToConfirm = limitedRightToConfirm
        self.splitTicket = splitTicket
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExerciseProcedure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExerciseProcedure.subclass:
            return ExerciseProcedure.subclass(*args_, **kwargs_)
        else:
            return ExerciseProcedure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_manualExercise(self): return self.manualExercise
    def set_manualExercise(self, manualExercise): self.manualExercise = manualExercise
    def get_automaticExercise(self): return self.automaticExercise
    def set_automaticExercise(self, automaticExercise): self.automaticExercise = automaticExercise
    def get_followUpConfirmation(self): return self.followUpConfirmation
    def set_followUpConfirmation(self, followUpConfirmation): self.followUpConfirmation = followUpConfirmation
    def get_limitedRightToConfirm(self): return self.limitedRightToConfirm
    def set_limitedRightToConfirm(self, limitedRightToConfirm): self.limitedRightToConfirm = limitedRightToConfirm
    def get_splitTicket(self): return self.splitTicket
    def set_splitTicket(self, splitTicket): self.splitTicket = splitTicket
    def hasContent_(self):
        if (
            self.manualExercise is not None or
            self.automaticExercise is not None or
            self.followUpConfirmation is not None or
            self.limitedRightToConfirm is not None or
            self.splitTicket is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExerciseProcedure', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExerciseProcedure')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExerciseProcedure', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExerciseProcedure'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ExerciseProcedure', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.manualExercise is not None:
            self.manualExercise.export(outfile, level, namespace_, name_='manualExercise', pretty_print=pretty_print)
        if self.automaticExercise is not None:
            self.automaticExercise.export(outfile, level, namespace_, name_='automaticExercise', pretty_print=pretty_print)
        if self.followUpConfirmation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfollowUpConfirmation>%s</%sfollowUpConfirmation>%s' % (namespace_, self.gds_format_boolean(self.followUpConfirmation, input_name='followUpConfirmation'), namespace_, eol_))
        if self.limitedRightToConfirm is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slimitedRightToConfirm>%s</%slimitedRightToConfirm>%s' % (namespace_, self.gds_format_boolean(self.limitedRightToConfirm, input_name='limitedRightToConfirm'), namespace_, eol_))
        if self.splitTicket is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssplitTicket>%s</%ssplitTicket>%s' % (namespace_, self.gds_format_boolean(self.splitTicket, input_name='splitTicket'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'manualExercise':
            obj_ = ManualExercise.factory()
            obj_.build(child_)
            self.manualExercise = obj_
            obj_.original_tagname_ = 'manualExercise'
        elif nodeName_ == 'automaticExercise':
            obj_ = AutomaticExercise.factory()
            obj_.build(child_)
            self.automaticExercise = obj_
            obj_.original_tagname_ = 'automaticExercise'
        elif nodeName_ == 'followUpConfirmation':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'followUpConfirmation')
            self.followUpConfirmation = ival_
        elif nodeName_ == 'limitedRightToConfirm':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'limitedRightToConfirm')
            self.limitedRightToConfirm = ival_
        elif nodeName_ == 'splitTicket':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'splitTicket')
            self.splitTicket = ival_
# end class ExerciseProcedure


class ExerciseProcedureOption(GeneratedsSuper):
    """A type describing how notice of exercise should be given. This can
    be either manual or automatic."""
    member_data_items_ = {
        'manualExercise': MemberSpec_('manualExercise', 'Empty', 0),
        'automaticExercise': MemberSpec_('automaticExercise', 'Empty', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, manualExercise=None, automaticExercise=None):
        self.original_tagname_ = None
        self.manualExercise = manualExercise
        self.automaticExercise = automaticExercise
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExerciseProcedureOption)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExerciseProcedureOption.subclass:
            return ExerciseProcedureOption.subclass(*args_, **kwargs_)
        else:
            return ExerciseProcedureOption(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_manualExercise(self): return self.manualExercise
    def set_manualExercise(self, manualExercise): self.manualExercise = manualExercise
    def get_automaticExercise(self): return self.automaticExercise
    def set_automaticExercise(self, automaticExercise): self.automaticExercise = automaticExercise
    def hasContent_(self):
        if (
            self.manualExercise is not None or
            self.automaticExercise is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExerciseProcedureOption', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExerciseProcedureOption')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExerciseProcedureOption', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExerciseProcedureOption'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ExerciseProcedureOption', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.manualExercise is not None:
            self.manualExercise.export(outfile, level, namespace_, name_='manualExercise', pretty_print=pretty_print)
        if self.automaticExercise is not None:
            self.automaticExercise.export(outfile, level, namespace_, name_='automaticExercise', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'manualExercise':
            obj_ = Empty.factory()
            obj_.build(child_)
            self.manualExercise = obj_
            obj_.original_tagname_ = 'manualExercise'
        elif nodeName_ == 'automaticExercise':
            obj_ = Empty.factory()
            obj_.build(child_)
            self.automaticExercise = obj_
            obj_.original_tagname_ = 'automaticExercise'
# end class ExerciseProcedureOption


class FloatingRateIndex(GeneratedsSuper):
    """The ISDA Floating Rate Option, i.e. the floating rate index."""
    member_data_items_ = {
        'floatingRateIndexScheme': MemberSpec_('floatingRateIndexScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, floatingRateIndexScheme='http://www.fpml.org/coding-scheme/floating-rate-index', valueOf_=None):
        self.original_tagname_ = None
        self.floatingRateIndexScheme = _cast(None, floatingRateIndexScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FloatingRateIndex)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FloatingRateIndex.subclass:
            return FloatingRateIndex.subclass(*args_, **kwargs_)
        else:
            return FloatingRateIndex(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_floatingRateIndexScheme(self): return self.floatingRateIndexScheme
    def set_floatingRateIndexScheme(self, floatingRateIndexScheme): self.floatingRateIndexScheme = floatingRateIndexScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FloatingRateIndex', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FloatingRateIndex')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FloatingRateIndex', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FloatingRateIndex'):
        if self.floatingRateIndexScheme != "http://www.fpml.org/coding-scheme/floating-rate-index" and 'floatingRateIndexScheme' not in already_processed:
            already_processed.add('floatingRateIndexScheme')
            outfile.write(' floatingRateIndexScheme=%s' % (quote_attrib(self.floatingRateIndexScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='FloatingRateIndex', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('floatingRateIndexScheme', node)
        if value is not None and 'floatingRateIndexScheme' not in already_processed:
            already_processed.add('floatingRateIndexScheme')
            self.floatingRateIndexScheme = value
            self.validate_NonEmptyURI(self.floatingRateIndexScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FloatingRateIndex


class ForecastRateIndex(GeneratedsSuper):
    """A type defining a rate index."""
    member_data_items_ = {
        'floatingRateIndex': MemberSpec_('floatingRateIndex', 'FloatingRateIndex', 0),
        'indexTenor': MemberSpec_('indexTenor', 'Period', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, floatingRateIndex=None, indexTenor=None):
        self.original_tagname_ = None
        self.floatingRateIndex = floatingRateIndex
        self.indexTenor = indexTenor
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ForecastRateIndex)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ForecastRateIndex.subclass:
            return ForecastRateIndex.subclass(*args_, **kwargs_)
        else:
            return ForecastRateIndex(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_floatingRateIndex(self): return self.floatingRateIndex
    def set_floatingRateIndex(self, floatingRateIndex): self.floatingRateIndex = floatingRateIndex
    def get_indexTenor(self): return self.indexTenor
    def set_indexTenor(self, indexTenor): self.indexTenor = indexTenor
    def hasContent_(self):
        if (
            self.floatingRateIndex is not None or
            self.indexTenor is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ForecastRateIndex', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ForecastRateIndex')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ForecastRateIndex', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ForecastRateIndex'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ForecastRateIndex', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.floatingRateIndex is not None:
            self.floatingRateIndex.export(outfile, level, namespace_, name_='floatingRateIndex', pretty_print=pretty_print)
        if self.indexTenor is not None:
            self.indexTenor.export(outfile, level, namespace_, name_='indexTenor', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'floatingRateIndex':
            obj_ = FloatingRateIndex.factory()
            obj_.build(child_)
            self.floatingRateIndex = obj_
            obj_.original_tagname_ = 'floatingRateIndex'
        elif nodeName_ == 'indexTenor':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.indexTenor = obj_
            obj_.original_tagname_ = 'indexTenor'
# end class ForecastRateIndex


class Formula(GeneratedsSuper):
    """A type describing a financial formula, with its description and
    components."""
    member_data_items_ = {
        'formulaDescription': MemberSpec_('formulaDescription', ['String', 'xsd:string'], 0),
        'math': MemberSpec_('math', 'Math', 0),
        'formulaComponent': MemberSpec_('formulaComponent', 'FormulaComponent', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, formulaDescription=None, math=None, formulaComponent=None):
        self.original_tagname_ = None
        self.formulaDescription = formulaDescription
        self.validate_String(self.formulaDescription)
        self.math = math
        if formulaComponent is None:
            self.formulaComponent = []
        else:
            self.formulaComponent = formulaComponent
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Formula)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Formula.subclass:
            return Formula.subclass(*args_, **kwargs_)
        else:
            return Formula(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_formulaDescription(self): return self.formulaDescription
    def set_formulaDescription(self, formulaDescription): self.formulaDescription = formulaDescription
    def get_math(self): return self.math
    def set_math(self, math): self.math = math
    def get_formulaComponent(self): return self.formulaComponent
    def set_formulaComponent(self, formulaComponent): self.formulaComponent = formulaComponent
    def add_formulaComponent(self, value): self.formulaComponent.append(value)
    def insert_formulaComponent_at(self, index, value): self.formulaComponent.insert(index, value)
    def replace_formulaComponent_at(self, index, value): self.formulaComponent[index] = value
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.formulaDescription is not None or
            self.math is not None or
            self.formulaComponent
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Formula', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Formula')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Formula', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Formula'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Formula', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.formulaDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sformulaDescription>%s</%sformulaDescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.formulaDescription), input_name='formulaDescription')), namespace_, eol_))
        if self.math is not None:
            self.math.export(outfile, level, namespace_, name_='math', pretty_print=pretty_print)
        for formulaComponent_ in self.formulaComponent:
            formulaComponent_.export(outfile, level, namespace_, name_='formulaComponent', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'formulaDescription':
            formulaDescription_ = child_.text
            formulaDescription_ = self.gds_validate_string(formulaDescription_, node, 'formulaDescription')
            self.formulaDescription = formulaDescription_
            # validate type String
            self.validate_String(self.formulaDescription)
        elif nodeName_ == 'math':
            obj_ = Math.factory()
            obj_.build(child_)
            self.math = obj_
            obj_.original_tagname_ = 'math'
        elif nodeName_ == 'formulaComponent':
            obj_ = FormulaComponent.factory()
            obj_.build(child_)
            self.formulaComponent.append(obj_)
            obj_.original_tagname_ = 'formulaComponent'
# end class Formula


class FormulaComponent(GeneratedsSuper):
    """Elements describing the components of the formula. The name
    attribute points to a value used in the math element. The href
    attribute points to a numeric value defined elsewhere in the
    document that is used by the formula component."""
    member_data_items_ = {
        'name': MemberSpec_('name', 'NormalizedString', 0),
        'componentDescription': MemberSpec_('componentDescription', ['String', 'xsd:string'], 0),
        'formula': MemberSpec_('formula', 'Formula', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, name=None, componentDescription=None, formula=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.componentDescription = componentDescription
        self.validate_String(self.componentDescription)
        self.formula = formula
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FormulaComponent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FormulaComponent.subclass:
            return FormulaComponent.subclass(*args_, **kwargs_)
        else:
            return FormulaComponent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_componentDescription(self): return self.componentDescription
    def set_componentDescription(self, componentDescription): self.componentDescription = componentDescription
    def get_formula(self): return self.formula
    def set_formula(self, formula): self.formula = formula
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def validate_NormalizedString(self, value):
        # Validate type NormalizedString, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NormalizedString' % {"value" : value} )
    def hasContent_(self):
        if (
            self.componentDescription is not None or
            self.formula is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FormulaComponent', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FormulaComponent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FormulaComponent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FormulaComponent'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (quote_attrib(self.name), ))
    def exportChildren(self, outfile, level, namespace_='', name_='FormulaComponent', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.componentDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomponentDescription>%s</%scomponentDescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.componentDescription), input_name='componentDescription')), namespace_, eol_))
        if self.formula is not None:
            self.formula.export(outfile, level, namespace_, name_='formula', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_NormalizedString(self.name)    # validate type NormalizedString
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'componentDescription':
            componentDescription_ = child_.text
            componentDescription_ = self.gds_validate_string(componentDescription_, node, 'componentDescription')
            self.componentDescription = componentDescription_
            # validate type String
            self.validate_String(self.componentDescription)
        elif nodeName_ == 'formula':
            obj_ = Formula.factory()
            obj_.build(child_)
            self.formula = obj_
            obj_.original_tagname_ = 'formula'
# end class FormulaComponent


class Frequency(GeneratedsSuper):
    """A type defining a time frequency, e.g. one day, three months. Used
    for specifying payment or calculation frequencies at which the
    value T (Term) is applicable."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'periodMultiplier': MemberSpec_('periodMultiplier', 'xsd:positiveInteger', 0),
        'period': MemberSpec_('period', ['PeriodExtendedEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, periodMultiplier=None, period=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.periodMultiplier = periodMultiplier
        self.period = period
        self.validate_PeriodExtendedEnum(self.period)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Frequency)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Frequency.subclass:
            return Frequency.subclass(*args_, **kwargs_)
        else:
            return Frequency(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_periodMultiplier(self): return self.periodMultiplier
    def set_periodMultiplier(self, periodMultiplier): self.periodMultiplier = periodMultiplier
    def get_period(self): return self.period
    def set_period(self, period): self.period = period
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_PeriodExtendedEnum(self, value):
        # Validate type PeriodExtendedEnum, a restriction on Token.
        pass
    def hasContent_(self):
        if (
            self.periodMultiplier is not None or
            self.period is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Frequency', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Frequency')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Frequency', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Frequency'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Frequency', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.periodMultiplier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%speriodMultiplier>%s</%speriodMultiplier>%s' % (namespace_, self.gds_format_integer(self.periodMultiplier, input_name='periodMultiplier'), namespace_, eol_))
        if self.period is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%speriod>%s</%speriod>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.period), input_name='period')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'periodMultiplier':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'periodMultiplier')
            self.periodMultiplier = ival_
        elif nodeName_ == 'period':
            period_ = child_.text
            period_ = re_.sub(String_cleanup_pat_, " ", period_).strip()
            period_ = self.gds_validate_string(period_, node, 'period')
            self.period = period_
            # validate type PeriodExtendedEnum
            self.validate_PeriodExtendedEnum(self.period)
# end class Frequency


class FxCashSettlement(GeneratedsSuper):
    """A type that is used for describing cash settlement of an option /
    non deliverable forward. It includes the currency to settle into
    together with the fixings required to calculate the currency
    amount."""
    member_data_items_ = {
        'settlementCurrency': MemberSpec_('settlementCurrency', 'Currency', 0),
        'referenceCurrency': MemberSpec_('referenceCurrency', 'Currency', 0),
        'notionalAmount': MemberSpec_('notionalAmount', 'PositiveMoney', 0),
        'fixing': MemberSpec_('fixing', 'FxFixing', 1),
        'rateSourceFixing': MemberSpec_('rateSourceFixing', 'FxRateSourceFixing', 1),
        'settlementDate': MemberSpec_('settlementDate', 'AdjustableDate', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, settlementCurrency=None, referenceCurrency=None, notionalAmount=None, fixing=None, rateSourceFixing=None, settlementDate=None):
        self.original_tagname_ = None
        self.settlementCurrency = settlementCurrency
        self.referenceCurrency = referenceCurrency
        self.notionalAmount = notionalAmount
        if fixing is None:
            self.fixing = []
        else:
            self.fixing = fixing
        if rateSourceFixing is None:
            self.rateSourceFixing = []
        else:
            self.rateSourceFixing = rateSourceFixing
        self.settlementDate = settlementDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FxCashSettlement)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FxCashSettlement.subclass:
            return FxCashSettlement.subclass(*args_, **kwargs_)
        else:
            return FxCashSettlement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_settlementCurrency(self): return self.settlementCurrency
    def set_settlementCurrency(self, settlementCurrency): self.settlementCurrency = settlementCurrency
    def get_referenceCurrency(self): return self.referenceCurrency
    def set_referenceCurrency(self, referenceCurrency): self.referenceCurrency = referenceCurrency
    def get_notionalAmount(self): return self.notionalAmount
    def set_notionalAmount(self, notionalAmount): self.notionalAmount = notionalAmount
    def get_fixing(self): return self.fixing
    def set_fixing(self, fixing): self.fixing = fixing
    def add_fixing(self, value): self.fixing.append(value)
    def insert_fixing_at(self, index, value): self.fixing.insert(index, value)
    def replace_fixing_at(self, index, value): self.fixing[index] = value
    def get_rateSourceFixing(self): return self.rateSourceFixing
    def set_rateSourceFixing(self, rateSourceFixing): self.rateSourceFixing = rateSourceFixing
    def add_rateSourceFixing(self, value): self.rateSourceFixing.append(value)
    def insert_rateSourceFixing_at(self, index, value): self.rateSourceFixing.insert(index, value)
    def replace_rateSourceFixing_at(self, index, value): self.rateSourceFixing[index] = value
    def get_settlementDate(self): return self.settlementDate
    def set_settlementDate(self, settlementDate): self.settlementDate = settlementDate
    def hasContent_(self):
        if (
            self.settlementCurrency is not None or
            self.referenceCurrency is not None or
            self.notionalAmount is not None or
            self.fixing or
            self.rateSourceFixing or
            self.settlementDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FxCashSettlement', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FxCashSettlement')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FxCashSettlement', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FxCashSettlement'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FxCashSettlement', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.settlementCurrency is not None:
            self.settlementCurrency.export(outfile, level, namespace_, name_='settlementCurrency', pretty_print=pretty_print)
        if self.referenceCurrency is not None:
            self.referenceCurrency.export(outfile, level, namespace_, name_='referenceCurrency', pretty_print=pretty_print)
        if self.notionalAmount is not None:
            self.notionalAmount.export(outfile, level, namespace_, name_='notionalAmount', pretty_print=pretty_print)
        for fixing_ in self.fixing:
            fixing_.export(outfile, level, namespace_, name_='fixing', pretty_print=pretty_print)
        for rateSourceFixing_ in self.rateSourceFixing:
            rateSourceFixing_.export(outfile, level, namespace_, name_='rateSourceFixing', pretty_print=pretty_print)
        if self.settlementDate is not None:
            self.settlementDate.export(outfile, level, namespace_, name_='settlementDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'settlementCurrency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.settlementCurrency = obj_
            obj_.original_tagname_ = 'settlementCurrency'
        elif nodeName_ == 'referenceCurrency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.referenceCurrency = obj_
            obj_.original_tagname_ = 'referenceCurrency'
        elif nodeName_ == 'notionalAmount':
            obj_ = PositiveMoney.factory()
            obj_.build(child_)
            self.notionalAmount = obj_
            obj_.original_tagname_ = 'notionalAmount'
        elif nodeName_ == 'fixing':
            obj_ = FxFixing.factory()
            obj_.build(child_)
            self.fixing.append(obj_)
            obj_.original_tagname_ = 'fixing'
        elif nodeName_ == 'rateSourceFixing':
            obj_ = FxRateSourceFixing.factory()
            obj_.build(child_)
            self.rateSourceFixing.append(obj_)
            obj_.original_tagname_ = 'rateSourceFixing'
        elif nodeName_ == 'settlementDate':
            obj_ = AdjustableDate.factory()
            obj_.build(child_)
            self.settlementDate = obj_
            obj_.original_tagname_ = 'settlementDate'
# end class FxCashSettlement


class FxCashSettlementSimple(GeneratedsSuper):
    """A type that is used for describing cash settlement of a variance or
    volatility swap option. It includes the settlement currency
    together with the spot currency exchange required to calculate
    the settlement currency amount."""
    member_data_items_ = {
        'settlementCurrency': MemberSpec_('settlementCurrency', 'Currency', 0),
        'referenceCurrency': MemberSpec_('referenceCurrency', 'Currency', 0),
        'fixing': MemberSpec_('fixing', 'FxFixing', 1),
        'rateSourceFixing': MemberSpec_('rateSourceFixing', 'FxRateSourceFixing', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, settlementCurrency=None, referenceCurrency=None, fixing=None, rateSourceFixing=None):
        self.original_tagname_ = None
        self.settlementCurrency = settlementCurrency
        self.referenceCurrency = referenceCurrency
        if fixing is None:
            self.fixing = []
        else:
            self.fixing = fixing
        if rateSourceFixing is None:
            self.rateSourceFixing = []
        else:
            self.rateSourceFixing = rateSourceFixing
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FxCashSettlementSimple)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FxCashSettlementSimple.subclass:
            return FxCashSettlementSimple.subclass(*args_, **kwargs_)
        else:
            return FxCashSettlementSimple(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_settlementCurrency(self): return self.settlementCurrency
    def set_settlementCurrency(self, settlementCurrency): self.settlementCurrency = settlementCurrency
    def get_referenceCurrency(self): return self.referenceCurrency
    def set_referenceCurrency(self, referenceCurrency): self.referenceCurrency = referenceCurrency
    def get_fixing(self): return self.fixing
    def set_fixing(self, fixing): self.fixing = fixing
    def add_fixing(self, value): self.fixing.append(value)
    def insert_fixing_at(self, index, value): self.fixing.insert(index, value)
    def replace_fixing_at(self, index, value): self.fixing[index] = value
    def get_rateSourceFixing(self): return self.rateSourceFixing
    def set_rateSourceFixing(self, rateSourceFixing): self.rateSourceFixing = rateSourceFixing
    def add_rateSourceFixing(self, value): self.rateSourceFixing.append(value)
    def insert_rateSourceFixing_at(self, index, value): self.rateSourceFixing.insert(index, value)
    def replace_rateSourceFixing_at(self, index, value): self.rateSourceFixing[index] = value
    def hasContent_(self):
        if (
            self.settlementCurrency is not None or
            self.referenceCurrency is not None or
            self.fixing or
            self.rateSourceFixing
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FxCashSettlementSimple', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FxCashSettlementSimple')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FxCashSettlementSimple', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FxCashSettlementSimple'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FxCashSettlementSimple', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.settlementCurrency is not None:
            self.settlementCurrency.export(outfile, level, namespace_, name_='settlementCurrency', pretty_print=pretty_print)
        if self.referenceCurrency is not None:
            self.referenceCurrency.export(outfile, level, namespace_, name_='referenceCurrency', pretty_print=pretty_print)
        for fixing_ in self.fixing:
            fixing_.export(outfile, level, namespace_, name_='fixing', pretty_print=pretty_print)
        for rateSourceFixing_ in self.rateSourceFixing:
            rateSourceFixing_.export(outfile, level, namespace_, name_='rateSourceFixing', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'settlementCurrency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.settlementCurrency = obj_
            obj_.original_tagname_ = 'settlementCurrency'
        elif nodeName_ == 'referenceCurrency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.referenceCurrency = obj_
            obj_.original_tagname_ = 'referenceCurrency'
        elif nodeName_ == 'fixing':
            obj_ = FxFixing.factory()
            obj_.build(child_)
            self.fixing.append(obj_)
            obj_.original_tagname_ = 'fixing'
        elif nodeName_ == 'rateSourceFixing':
            obj_ = FxRateSourceFixing.factory()
            obj_.build(child_)
            self.rateSourceFixing.append(obj_)
            obj_.original_tagname_ = 'rateSourceFixing'
# end class FxCashSettlementSimple


class FxFixing(GeneratedsSuper):
    """A type that specifies the source for and timing of a fixing of an
    exchange rate. This is used in the agreement of non-deliverable
    forward trades as well as various types of FX OTC options that
    require observations against a particular rate."""
    member_data_items_ = {
        'quotedCurrencyPair': MemberSpec_('quotedCurrencyPair', 'QuotedCurrencyPair', 0),
        'fixingDate': MemberSpec_('fixingDate', 'xsd:date', 0),
        'fxSpotRateSource': MemberSpec_('fxSpotRateSource', 'FxSpotRateSource', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, quotedCurrencyPair=None, fixingDate=None, fxSpotRateSource=None):
        self.original_tagname_ = None
        self.quotedCurrencyPair = quotedCurrencyPair
        if isinstance(fixingDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(fixingDate, '%Y-%m-%d').date()
        else:
            initvalue_ = fixingDate
        self.fixingDate = initvalue_
        self.fxSpotRateSource = fxSpotRateSource
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FxFixing)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FxFixing.subclass:
            return FxFixing.subclass(*args_, **kwargs_)
        else:
            return FxFixing(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_quotedCurrencyPair(self): return self.quotedCurrencyPair
    def set_quotedCurrencyPair(self, quotedCurrencyPair): self.quotedCurrencyPair = quotedCurrencyPair
    def get_fixingDate(self): return self.fixingDate
    def set_fixingDate(self, fixingDate): self.fixingDate = fixingDate
    def get_fxSpotRateSource(self): return self.fxSpotRateSource
    def set_fxSpotRateSource(self, fxSpotRateSource): self.fxSpotRateSource = fxSpotRateSource
    def hasContent_(self):
        if (
            self.quotedCurrencyPair is not None or
            self.fixingDate is not None or
            self.fxSpotRateSource is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FxFixing', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FxFixing')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FxFixing', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FxFixing'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FxFixing', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.quotedCurrencyPair is not None:
            self.quotedCurrencyPair.export(outfile, level, namespace_, name_='quotedCurrencyPair', pretty_print=pretty_print)
        if self.fixingDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfixingDate>%s</%sfixingDate>%s' % (namespace_, self.gds_format_date(self.fixingDate, input_name='fixingDate'), namespace_, eol_))
        if self.fxSpotRateSource is not None:
            self.fxSpotRateSource.export(outfile, level, namespace_, name_='fxSpotRateSource', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'quotedCurrencyPair':
            obj_ = QuotedCurrencyPair.factory()
            obj_.build(child_)
            self.quotedCurrencyPair = obj_
            obj_.original_tagname_ = 'quotedCurrencyPair'
        elif nodeName_ == 'fixingDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.fixingDate = dval_
        elif nodeName_ == 'fxSpotRateSource':
            obj_ = FxSpotRateSource.factory()
            obj_.build(child_)
            self.fxSpotRateSource = obj_
            obj_.original_tagname_ = 'fxSpotRateSource'
# end class FxFixing


class FxRate(GeneratedsSuper):
    """A type describing the rate of a currency conversion: pair of
    currency, quotation mode and exchange rate."""
    member_data_items_ = {
        'quotedCurrencyPair': MemberSpec_('quotedCurrencyPair', 'QuotedCurrencyPair', 0),
        'rate': MemberSpec_('rate', 'xsd:decimal', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, quotedCurrencyPair=None, rate=None):
        self.original_tagname_ = None
        self.quotedCurrencyPair = quotedCurrencyPair
        self.rate = rate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FxRate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FxRate.subclass:
            return FxRate.subclass(*args_, **kwargs_)
        else:
            return FxRate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_quotedCurrencyPair(self): return self.quotedCurrencyPair
    def set_quotedCurrencyPair(self, quotedCurrencyPair): self.quotedCurrencyPair = quotedCurrencyPair
    def get_rate(self): return self.rate
    def set_rate(self, rate): self.rate = rate
    def hasContent_(self):
        if (
            self.quotedCurrencyPair is not None or
            self.rate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FxRate', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FxRate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FxRate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FxRate'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FxRate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.quotedCurrencyPair is not None:
            self.quotedCurrencyPair.export(outfile, level, namespace_, name_='quotedCurrencyPair', pretty_print=pretty_print)
        if self.rate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srate>%s</%srate>%s' % (namespace_, self.gds_format_float(self.rate, input_name='rate'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'quotedCurrencyPair':
            obj_ = QuotedCurrencyPair.factory()
            obj_.build(child_)
            self.quotedCurrencyPair = obj_
            obj_.original_tagname_ = 'quotedCurrencyPair'
        elif nodeName_ == 'rate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'rate')
            self.rate = fval_
# end class FxRate


class FxRateSourceFixing(GeneratedsSuper):
    """Describes a rate source to be fixed and the date the fixing occurs"""
    member_data_items_ = {
        'settlementRateSource': MemberSpec_('settlementRateSource', 'FxSettlementRateSource', 0),
        'fixingDate': MemberSpec_('fixingDate', 'AdjustableDate', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, settlementRateSource=None, fixingDate=None):
        self.original_tagname_ = None
        self.settlementRateSource = settlementRateSource
        self.fixingDate = fixingDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FxRateSourceFixing)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FxRateSourceFixing.subclass:
            return FxRateSourceFixing.subclass(*args_, **kwargs_)
        else:
            return FxRateSourceFixing(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_settlementRateSource(self): return self.settlementRateSource
    def set_settlementRateSource(self, settlementRateSource): self.settlementRateSource = settlementRateSource
    def get_fixingDate(self): return self.fixingDate
    def set_fixingDate(self, fixingDate): self.fixingDate = fixingDate
    def hasContent_(self):
        if (
            self.settlementRateSource is not None or
            self.fixingDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FxRateSourceFixing', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FxRateSourceFixing')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FxRateSourceFixing', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FxRateSourceFixing'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FxRateSourceFixing', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.settlementRateSource is not None:
            self.settlementRateSource.export(outfile, level, namespace_, name_='settlementRateSource', pretty_print=pretty_print)
        if self.fixingDate is not None:
            self.fixingDate.export(outfile, level, namespace_, name_='fixingDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'settlementRateSource':
            obj_ = FxSettlementRateSource.factory()
            obj_.build(child_)
            self.settlementRateSource = obj_
            obj_.original_tagname_ = 'settlementRateSource'
        elif nodeName_ == 'fixingDate':
            obj_ = AdjustableDate.factory()
            obj_.build(child_)
            self.fixingDate = obj_
            obj_.original_tagname_ = 'fixingDate'
# end class FxRateSourceFixing


class FxSettlementRateSource(GeneratedsSuper):
    member_data_items_ = {
        'settlementRateOption': MemberSpec_('settlementRateOption', 'SettlementRateOption', 0),
        'nonstandardSettlementRate': MemberSpec_('nonstandardSettlementRate', 'FxInformationSource', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, settlementRateOption=None, nonstandardSettlementRate=None):
        self.original_tagname_ = None
        self.settlementRateOption = settlementRateOption
        self.nonstandardSettlementRate = nonstandardSettlementRate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FxSettlementRateSource)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FxSettlementRateSource.subclass:
            return FxSettlementRateSource.subclass(*args_, **kwargs_)
        else:
            return FxSettlementRateSource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_settlementRateOption(self): return self.settlementRateOption
    def set_settlementRateOption(self, settlementRateOption): self.settlementRateOption = settlementRateOption
    def get_nonstandardSettlementRate(self): return self.nonstandardSettlementRate
    def set_nonstandardSettlementRate(self, nonstandardSettlementRate): self.nonstandardSettlementRate = nonstandardSettlementRate
    def hasContent_(self):
        if (
            self.settlementRateOption is not None or
            self.nonstandardSettlementRate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FxSettlementRateSource', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FxSettlementRateSource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FxSettlementRateSource', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FxSettlementRateSource'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FxSettlementRateSource', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.settlementRateOption is not None:
            self.settlementRateOption.export(outfile, level, namespace_, name_='settlementRateOption', pretty_print=pretty_print)
        if self.nonstandardSettlementRate is not None:
            self.nonstandardSettlementRate.export(outfile, level, namespace_, name_='nonstandardSettlementRate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'settlementRateOption':
            obj_ = SettlementRateOption.factory()
            obj_.build(child_)
            self.settlementRateOption = obj_
            obj_.original_tagname_ = 'settlementRateOption'
        elif nodeName_ == 'nonstandardSettlementRate':
            obj_ = FxInformationSource.factory()
            obj_.build(child_)
            self.nonstandardSettlementRate = obj_
            obj_.original_tagname_ = 'nonstandardSettlementRate'
# end class FxSettlementRateSource


class FxSpotRateSource(GeneratedsSuper):
    """A type defining the rate source and fixing time for an fx rate."""
    member_data_items_ = {
        'primaryRateSource': MemberSpec_('primaryRateSource', 'InformationSource', 0),
        'secondaryRateSource': MemberSpec_('secondaryRateSource', 'InformationSource', 0),
        'fixingTime': MemberSpec_('fixingTime', 'BusinessCenterTime', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, primaryRateSource=None, secondaryRateSource=None, fixingTime=None):
        self.original_tagname_ = None
        self.primaryRateSource = primaryRateSource
        self.secondaryRateSource = secondaryRateSource
        self.fixingTime = fixingTime
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FxSpotRateSource)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FxSpotRateSource.subclass:
            return FxSpotRateSource.subclass(*args_, **kwargs_)
        else:
            return FxSpotRateSource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_primaryRateSource(self): return self.primaryRateSource
    def set_primaryRateSource(self, primaryRateSource): self.primaryRateSource = primaryRateSource
    def get_secondaryRateSource(self): return self.secondaryRateSource
    def set_secondaryRateSource(self, secondaryRateSource): self.secondaryRateSource = secondaryRateSource
    def get_fixingTime(self): return self.fixingTime
    def set_fixingTime(self, fixingTime): self.fixingTime = fixingTime
    def hasContent_(self):
        if (
            self.primaryRateSource is not None or
            self.secondaryRateSource is not None or
            self.fixingTime is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FxSpotRateSource', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FxSpotRateSource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FxSpotRateSource', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FxSpotRateSource'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FxSpotRateSource', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.primaryRateSource is not None:
            self.primaryRateSource.export(outfile, level, namespace_, name_='primaryRateSource', pretty_print=pretty_print)
        if self.secondaryRateSource is not None:
            self.secondaryRateSource.export(outfile, level, namespace_, name_='secondaryRateSource', pretty_print=pretty_print)
        if self.fixingTime is not None:
            self.fixingTime.export(outfile, level, namespace_, name_='fixingTime', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'primaryRateSource':
            class_obj_ = self.get_class_obj_(child_, InformationSource)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.primaryRateSource = obj_
            obj_.original_tagname_ = 'primaryRateSource'
        elif nodeName_ == 'secondaryRateSource':
            class_obj_ = self.get_class_obj_(child_, InformationSource)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.secondaryRateSource = obj_
            obj_.original_tagname_ = 'secondaryRateSource'
        elif nodeName_ == 'fixingTime':
            obj_ = BusinessCenterTime.factory()
            obj_.build(child_)
            self.fixingTime = obj_
            obj_.original_tagname_ = 'fixingTime'
# end class FxSpotRateSource


class GenericAgreement(GeneratedsSuper):
    """An entity for defining a generic agreement executed between two
    parties for any purpose."""
    member_data_items_ = {
        'type_': MemberSpec_('type_', 'AgreementType', 0),
        'version': MemberSpec_('version', 'AgreementVersion', 0),
        'date': MemberSpec_('date', 'xsd:date', 0),
        'amendmentDate': MemberSpec_('amendmentDate', 'xsd:date', 1),
        'governingLaw': MemberSpec_('governingLaw', 'GoverningLaw', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, type_=None, version=None, date=None, amendmentDate=None, governingLaw=None):
        self.original_tagname_ = None
        self.type_ = type_
        self.version = version
        if isinstance(date, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(date, '%Y-%m-%d').date()
        else:
            initvalue_ = date
        self.date = initvalue_
        if amendmentDate is None:
            self.amendmentDate = []
        else:
            self.amendmentDate = amendmentDate
        self.governingLaw = governingLaw
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GenericAgreement)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GenericAgreement.subclass:
            return GenericAgreement.subclass(*args_, **kwargs_)
        else:
            return GenericAgreement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_date(self): return self.date
    def set_date(self, date): self.date = date
    def get_amendmentDate(self): return self.amendmentDate
    def set_amendmentDate(self, amendmentDate): self.amendmentDate = amendmentDate
    def add_amendmentDate(self, value): self.amendmentDate.append(value)
    def insert_amendmentDate_at(self, index, value): self.amendmentDate.insert(index, value)
    def replace_amendmentDate_at(self, index, value): self.amendmentDate[index] = value
    def get_governingLaw(self): return self.governingLaw
    def set_governingLaw(self, governingLaw): self.governingLaw = governingLaw
    def hasContent_(self):
        if (
            self.type_ is not None or
            self.version is not None or
            self.date is not None or
            self.amendmentDate or
            self.governingLaw is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GenericAgreement', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GenericAgreement')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GenericAgreement', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GenericAgreement'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GenericAgreement', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            self.type_.export(outfile, level, namespace_, name_='type', pretty_print=pretty_print)
        if self.version is not None:
            self.version.export(outfile, level, namespace_, name_='version', pretty_print=pretty_print)
        if self.date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdate>%s</%sdate>%s' % (namespace_, self.gds_format_date(self.date, input_name='date'), namespace_, eol_))
        for amendmentDate_ in self.amendmentDate:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%samendmentDate>%s</%samendmentDate>%s' % (namespace_, self.gds_format_date(amendmentDate_, input_name='amendmentDate'), namespace_, eol_))
        if self.governingLaw is not None:
            self.governingLaw.export(outfile, level, namespace_, name_='governingLaw', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            obj_ = AgreementType.factory()
            obj_.build(child_)
            self.type_ = obj_
            obj_.original_tagname_ = 'type'
        elif nodeName_ == 'version':
            obj_ = AgreementVersion.factory()
            obj_.build(child_)
            self.version = obj_
            obj_.original_tagname_ = 'version'
        elif nodeName_ == 'date':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.date = dval_
        elif nodeName_ == 'amendmentDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.amendmentDate.append(dval_)
        elif nodeName_ == 'governingLaw':
            obj_ = GoverningLaw.factory()
            obj_.build(child_)
            self.governingLaw = obj_
            obj_.original_tagname_ = 'governingLaw'
# end class GenericAgreement


class GoverningLaw(GeneratedsSuper):
    """Identification of the law governing the transaction."""
    member_data_items_ = {
        'governingLawScheme': MemberSpec_('governingLawScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, governingLawScheme='http://www.fpml.org/coding-scheme/governing-law', valueOf_=None):
        self.original_tagname_ = None
        self.governingLawScheme = _cast(None, governingLawScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GoverningLaw)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GoverningLaw.subclass:
            return GoverningLaw.subclass(*args_, **kwargs_)
        else:
            return GoverningLaw(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_governingLawScheme(self): return self.governingLawScheme
    def set_governingLawScheme(self, governingLawScheme): self.governingLawScheme = governingLawScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GoverningLaw', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GoverningLaw')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GoverningLaw', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GoverningLaw'):
        if self.governingLawScheme != "http://www.fpml.org/coding-scheme/governing-law" and 'governingLawScheme' not in already_processed:
            already_processed.add('governingLawScheme')
            outfile.write(' governingLawScheme=%s' % (quote_attrib(self.governingLawScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='GoverningLaw', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('governingLawScheme', node)
        if value is not None and 'governingLawScheme' not in already_processed:
            already_processed.add('governingLawScheme')
            self.governingLawScheme = value
            self.validate_NonEmptyURI(self.governingLawScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class GoverningLaw


class GrossCashflow(GeneratedsSuper):
    """A payment component owed from one party to the other for the cash
    flow date. This payment component should by of only a single
    type, e.g. a fee or a cashflow from a cashflow stream."""
    member_data_items_ = {
        'cashflowId': MemberSpec_('cashflowId', 'CashflowId', 0),
        'partyTradeIdentifierReference': MemberSpec_('partyTradeIdentifierReference', 'PartyTradeIdentifierReference', 0),
        'payerPartyReference': MemberSpec_('payerPartyReference', 'PartyReference', 0),
        'payerAccountReference': MemberSpec_('payerAccountReference', 'AccountReference', 0),
        'receiverPartyReference': MemberSpec_('receiverPartyReference', 'PartyReference', 0),
        'receiverAccountReference': MemberSpec_('receiverAccountReference', 'AccountReference', 0),
        'cashflowAmount': MemberSpec_('cashflowAmount', 'Money', 0),
        'cashflowType': MemberSpec_('cashflowType', 'CashflowType', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, cashflowId=None, partyTradeIdentifierReference=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, cashflowAmount=None, cashflowType=None):
        self.original_tagname_ = None
        self.cashflowId = cashflowId
        self.partyTradeIdentifierReference = partyTradeIdentifierReference
        self.payerPartyReference = payerPartyReference
        self.payerAccountReference = payerAccountReference
        self.receiverPartyReference = receiverPartyReference
        self.receiverAccountReference = receiverAccountReference
        self.cashflowAmount = cashflowAmount
        self.cashflowType = cashflowType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GrossCashflow)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GrossCashflow.subclass:
            return GrossCashflow.subclass(*args_, **kwargs_)
        else:
            return GrossCashflow(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cashflowId(self): return self.cashflowId
    def set_cashflowId(self, cashflowId): self.cashflowId = cashflowId
    def get_partyTradeIdentifierReference(self): return self.partyTradeIdentifierReference
    def set_partyTradeIdentifierReference(self, partyTradeIdentifierReference): self.partyTradeIdentifierReference = partyTradeIdentifierReference
    def get_payerPartyReference(self): return self.payerPartyReference
    def set_payerPartyReference(self, payerPartyReference): self.payerPartyReference = payerPartyReference
    def get_payerAccountReference(self): return self.payerAccountReference
    def set_payerAccountReference(self, payerAccountReference): self.payerAccountReference = payerAccountReference
    def get_receiverPartyReference(self): return self.receiverPartyReference
    def set_receiverPartyReference(self, receiverPartyReference): self.receiverPartyReference = receiverPartyReference
    def get_receiverAccountReference(self): return self.receiverAccountReference
    def set_receiverAccountReference(self, receiverAccountReference): self.receiverAccountReference = receiverAccountReference
    def get_cashflowAmount(self): return self.cashflowAmount
    def set_cashflowAmount(self, cashflowAmount): self.cashflowAmount = cashflowAmount
    def get_cashflowType(self): return self.cashflowType
    def set_cashflowType(self, cashflowType): self.cashflowType = cashflowType
    def hasContent_(self):
        if (
            self.cashflowId is not None or
            self.partyTradeIdentifierReference is not None or
            self.payerPartyReference is not None or
            self.payerAccountReference is not None or
            self.receiverPartyReference is not None or
            self.receiverAccountReference is not None or
            self.cashflowAmount is not None or
            self.cashflowType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GrossCashflow', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GrossCashflow')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GrossCashflow', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GrossCashflow'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GrossCashflow', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cashflowId is not None:
            self.cashflowId.export(outfile, level, namespace_, name_='cashflowId', pretty_print=pretty_print)
        if self.partyTradeIdentifierReference is not None:
            self.partyTradeIdentifierReference.export(outfile, level, namespace_, name_='partyTradeIdentifierReference', pretty_print=pretty_print)
        if self.payerPartyReference is not None:
            self.payerPartyReference.export(outfile, level, namespace_, name_='payerPartyReference', pretty_print=pretty_print)
        if self.payerAccountReference is not None:
            self.payerAccountReference.export(outfile, level, namespace_, name_='payerAccountReference', pretty_print=pretty_print)
        if self.receiverPartyReference is not None:
            self.receiverPartyReference.export(outfile, level, namespace_, name_='receiverPartyReference', pretty_print=pretty_print)
        if self.receiverAccountReference is not None:
            self.receiverAccountReference.export(outfile, level, namespace_, name_='receiverAccountReference', pretty_print=pretty_print)
        if self.cashflowAmount is not None:
            self.cashflowAmount.export(outfile, level, namespace_, name_='cashflowAmount', pretty_print=pretty_print)
        if self.cashflowType is not None:
            self.cashflowType.export(outfile, level, namespace_, name_='cashflowType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cashflowId':
            obj_ = CashflowId.factory()
            obj_.build(child_)
            self.cashflowId = obj_
            obj_.original_tagname_ = 'cashflowId'
        elif nodeName_ == 'partyTradeIdentifierReference':
            obj_ = PartyTradeIdentifierReference.factory()
            obj_.build(child_)
            self.partyTradeIdentifierReference = obj_
            obj_.original_tagname_ = 'partyTradeIdentifierReference'
        elif nodeName_ == 'payerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.payerPartyReference = obj_
            obj_.original_tagname_ = 'payerPartyReference'
        elif nodeName_ == 'payerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.payerAccountReference = obj_
            obj_.original_tagname_ = 'payerAccountReference'
        elif nodeName_ == 'receiverPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.receiverPartyReference = obj_
            obj_.original_tagname_ = 'receiverPartyReference'
        elif nodeName_ == 'receiverAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.receiverAccountReference = obj_
            obj_.original_tagname_ = 'receiverAccountReference'
        elif nodeName_ == 'cashflowAmount':
            obj_ = Money.factory()
            obj_.build(child_)
            self.cashflowAmount = obj_
            obj_.original_tagname_ = 'cashflowAmount'
        elif nodeName_ == 'cashflowType':
            obj_ = CashflowType.factory()
            obj_.build(child_)
            self.cashflowType = obj_
            obj_.original_tagname_ = 'cashflowType'
# end class GrossCashflow


class IdentifiedCurrency(Currency):
    """Specifies Currency with ID attribute."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'valueOf_': MemberSpec_('valueOf_', 'Currency', 0),
    }
    subclass = None
    superclass = Currency
    def __init__(self, currencyScheme='http://www.fpml.org/coding-scheme/external/iso4217-2001-08-15', id=None, valueOf_=None):
        self.original_tagname_ = None
        super(IdentifiedCurrency, self).__init__(currencyScheme, valueOf_, )
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IdentifiedCurrency)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IdentifiedCurrency.subclass:
            return IdentifiedCurrency.subclass(*args_, **kwargs_)
        else:
            return IdentifiedCurrency(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_ or
            super(IdentifiedCurrency, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IdentifiedCurrency', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifiedCurrency')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IdentifiedCurrency', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IdentifiedCurrency'):
        super(IdentifiedCurrency, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifiedCurrency')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IdentifiedCurrency', fromsubclass_=False, pretty_print=True):
        super(IdentifiedCurrency, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        super(IdentifiedCurrency, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IdentifiedCurrency


class IdentifiedDate(GeneratedsSuper):
    """A date which can be referenced elsewhere."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'valueOf_': MemberSpec_('valueOf_', 'xsd:date', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IdentifiedDate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IdentifiedDate.subclass:
            return IdentifiedDate.subclass(*args_, **kwargs_)
        else:
            return IdentifiedDate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IdentifiedDate', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifiedDate')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IdentifiedDate', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IdentifiedDate'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IdentifiedDate', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IdentifiedDate


class IdentifiedPayerReceiver(GeneratedsSuper):
    """A type extending the PayerReceiverEnum type wih an id attribute."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'valueOf_': MemberSpec_('valueOf_', ['PayerReceiverEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IdentifiedPayerReceiver)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IdentifiedPayerReceiver.subclass:
            return IdentifiedPayerReceiver.subclass(*args_, **kwargs_)
        else:
            return IdentifiedPayerReceiver(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IdentifiedPayerReceiver', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifiedPayerReceiver')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IdentifiedPayerReceiver', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IdentifiedPayerReceiver'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IdentifiedPayerReceiver', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IdentifiedPayerReceiver


class IdentifiedRate(GeneratedsSuper):
    """A rate which can be referenced elsewhere."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'valueOf_': MemberSpec_('valueOf_', 'xsd:decimal', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IdentifiedRate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IdentifiedRate.subclass:
            return IdentifiedRate.subclass(*args_, **kwargs_)
        else:
            return IdentifiedRate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IdentifiedRate', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifiedRate')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IdentifiedRate', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IdentifiedRate'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IdentifiedRate', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IdentifiedRate


class IndependentAmount(GeneratedsSuper):
    member_data_items_ = {
        'payerPartyReference': MemberSpec_('payerPartyReference', 'PartyReference', 0),
        'payerAccountReference': MemberSpec_('payerAccountReference', 'AccountReference', 0),
        'receiverPartyReference': MemberSpec_('receiverPartyReference', 'PartyReference', 0),
        'receiverAccountReference': MemberSpec_('receiverAccountReference', 'AccountReference', 0),
        'paymentDetail': MemberSpec_('paymentDetail', 'PaymentDetail', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, paymentDetail=None):
        self.original_tagname_ = None
        self.payerPartyReference = payerPartyReference
        self.payerAccountReference = payerAccountReference
        self.receiverPartyReference = receiverPartyReference
        self.receiverAccountReference = receiverAccountReference
        if paymentDetail is None:
            self.paymentDetail = []
        else:
            self.paymentDetail = paymentDetail
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IndependentAmount)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IndependentAmount.subclass:
            return IndependentAmount.subclass(*args_, **kwargs_)
        else:
            return IndependentAmount(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_payerPartyReference(self): return self.payerPartyReference
    def set_payerPartyReference(self, payerPartyReference): self.payerPartyReference = payerPartyReference
    def get_payerAccountReference(self): return self.payerAccountReference
    def set_payerAccountReference(self, payerAccountReference): self.payerAccountReference = payerAccountReference
    def get_receiverPartyReference(self): return self.receiverPartyReference
    def set_receiverPartyReference(self, receiverPartyReference): self.receiverPartyReference = receiverPartyReference
    def get_receiverAccountReference(self): return self.receiverAccountReference
    def set_receiverAccountReference(self, receiverAccountReference): self.receiverAccountReference = receiverAccountReference
    def get_paymentDetail(self): return self.paymentDetail
    def set_paymentDetail(self, paymentDetail): self.paymentDetail = paymentDetail
    def add_paymentDetail(self, value): self.paymentDetail.append(value)
    def insert_paymentDetail_at(self, index, value): self.paymentDetail.insert(index, value)
    def replace_paymentDetail_at(self, index, value): self.paymentDetail[index] = value
    def hasContent_(self):
        if (
            self.payerPartyReference is not None or
            self.payerAccountReference is not None or
            self.receiverPartyReference is not None or
            self.receiverAccountReference is not None or
            self.paymentDetail
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IndependentAmount', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IndependentAmount')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IndependentAmount', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IndependentAmount'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IndependentAmount', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.payerPartyReference is not None:
            self.payerPartyReference.export(outfile, level, namespace_, name_='payerPartyReference', pretty_print=pretty_print)
        if self.payerAccountReference is not None:
            self.payerAccountReference.export(outfile, level, namespace_, name_='payerAccountReference', pretty_print=pretty_print)
        if self.receiverPartyReference is not None:
            self.receiverPartyReference.export(outfile, level, namespace_, name_='receiverPartyReference', pretty_print=pretty_print)
        if self.receiverAccountReference is not None:
            self.receiverAccountReference.export(outfile, level, namespace_, name_='receiverAccountReference', pretty_print=pretty_print)
        for paymentDetail_ in self.paymentDetail:
            paymentDetail_.export(outfile, level, namespace_, name_='paymentDetail', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'payerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.payerPartyReference = obj_
            obj_.original_tagname_ = 'payerPartyReference'
        elif nodeName_ == 'payerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.payerAccountReference = obj_
            obj_.original_tagname_ = 'payerAccountReference'
        elif nodeName_ == 'receiverPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.receiverPartyReference = obj_
            obj_.original_tagname_ = 'receiverPartyReference'
        elif nodeName_ == 'receiverAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.receiverAccountReference = obj_
            obj_.original_tagname_ = 'receiverAccountReference'
        elif nodeName_ == 'paymentDetail':
            obj_ = PaymentDetail.factory()
            obj_.build(child_)
            self.paymentDetail.append(obj_)
            obj_.original_tagname_ = 'paymentDetail'
# end class IndependentAmount


class IndustryClassification(GeneratedsSuper):
    """A party's industry sector classification."""
    member_data_items_ = {
        'industryClassificationScheme': MemberSpec_('industryClassificationScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, industryClassificationScheme='http://www.fpml.org/coding-scheme/regulatory-corporate-sector', valueOf_=None):
        self.original_tagname_ = None
        self.industryClassificationScheme = _cast(None, industryClassificationScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IndustryClassification)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IndustryClassification.subclass:
            return IndustryClassification.subclass(*args_, **kwargs_)
        else:
            return IndustryClassification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_industryClassificationScheme(self): return self.industryClassificationScheme
    def set_industryClassificationScheme(self, industryClassificationScheme): self.industryClassificationScheme = industryClassificationScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IndustryClassification', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IndustryClassification')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IndustryClassification', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IndustryClassification'):
        if self.industryClassificationScheme != "http://www.fpml.org/coding-scheme/regulatory-corporate-sector" and 'industryClassificationScheme' not in already_processed:
            already_processed.add('industryClassificationScheme')
            outfile.write(' industryClassificationScheme=%s' % (quote_attrib(self.industryClassificationScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IndustryClassification', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('industryClassificationScheme', node)
        if value is not None and 'industryClassificationScheme' not in already_processed:
            already_processed.add('industryClassificationScheme')
            self.industryClassificationScheme = value
            self.validate_NonEmptyURI(self.industryClassificationScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IndustryClassification


class InformationProvider(GeneratedsSuper):
    member_data_items_ = {
        'informationProviderScheme': MemberSpec_('informationProviderScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, informationProviderScheme='http://www.fpml.org/coding-scheme/information-provider', valueOf_=None):
        self.original_tagname_ = None
        self.informationProviderScheme = _cast(None, informationProviderScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InformationProvider)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InformationProvider.subclass:
            return InformationProvider.subclass(*args_, **kwargs_)
        else:
            return InformationProvider(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_informationProviderScheme(self): return self.informationProviderScheme
    def set_informationProviderScheme(self, informationProviderScheme): self.informationProviderScheme = informationProviderScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InformationProvider', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InformationProvider')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InformationProvider', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InformationProvider'):
        if self.informationProviderScheme != "http://www.fpml.org/coding-scheme/information-provider" and 'informationProviderScheme' not in already_processed:
            already_processed.add('informationProviderScheme')
            outfile.write(' informationProviderScheme=%s' % (quote_attrib(self.informationProviderScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='InformationProvider', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('informationProviderScheme', node)
        if value is not None and 'informationProviderScheme' not in already_processed:
            already_processed.add('informationProviderScheme')
            self.informationProviderScheme = value
            self.validate_NonEmptyURI(self.informationProviderScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class InformationProvider


class InformationSource(GeneratedsSuper):
    """A type defining the source for a piece of information (e.g. a rate
    refix or an fx fixing)."""
    member_data_items_ = {
        'rateSource': MemberSpec_('rateSource', 'InformationProvider', 0),
        'rateSourcePage': MemberSpec_('rateSourcePage', 'RateSourcePage', 0),
        'rateSourcePageHeading': MemberSpec_('rateSourcePageHeading', ['String', 'xsd:string'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, rateSource=None, rateSourcePage=None, rateSourcePageHeading=None, extensiontype_=None):
        self.original_tagname_ = None
        self.rateSource = rateSource
        self.rateSourcePage = rateSourcePage
        self.rateSourcePageHeading = rateSourcePageHeading
        self.validate_String(self.rateSourcePageHeading)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InformationSource)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InformationSource.subclass:
            return InformationSource.subclass(*args_, **kwargs_)
        else:
            return InformationSource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rateSource(self): return self.rateSource
    def set_rateSource(self, rateSource): self.rateSource = rateSource
    def get_rateSourcePage(self): return self.rateSourcePage
    def set_rateSourcePage(self, rateSourcePage): self.rateSourcePage = rateSourcePage
    def get_rateSourcePageHeading(self): return self.rateSourcePageHeading
    def set_rateSourcePageHeading(self, rateSourcePageHeading): self.rateSourcePageHeading = rateSourcePageHeading
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.rateSource is not None or
            self.rateSourcePage is not None or
            self.rateSourcePageHeading is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InformationSource', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InformationSource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InformationSource', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InformationSource'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='InformationSource', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.rateSource is not None:
            self.rateSource.export(outfile, level, namespace_, name_='rateSource', pretty_print=pretty_print)
        if self.rateSourcePage is not None:
            self.rateSourcePage.export(outfile, level, namespace_, name_='rateSourcePage', pretty_print=pretty_print)
        if self.rateSourcePageHeading is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srateSourcePageHeading>%s</%srateSourcePageHeading>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.rateSourcePageHeading), input_name='rateSourcePageHeading')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'rateSource':
            obj_ = InformationProvider.factory()
            obj_.build(child_)
            self.rateSource = obj_
            obj_.original_tagname_ = 'rateSource'
        elif nodeName_ == 'rateSourcePage':
            obj_ = RateSourcePage.factory()
            obj_.build(child_)
            self.rateSourcePage = obj_
            obj_.original_tagname_ = 'rateSourcePage'
        elif nodeName_ == 'rateSourcePageHeading':
            rateSourcePageHeading_ = child_.text
            rateSourcePageHeading_ = self.gds_validate_string(rateSourcePageHeading_, node, 'rateSourcePageHeading')
            self.rateSourcePageHeading = rateSourcePageHeading_
            # validate type String
            self.validate_String(self.rateSourcePageHeading)
# end class InformationSource


class InstrumentId(GeneratedsSuper):
    """A short form unique identifier for a security."""
    member_data_items_ = {
        'instrumentIdScheme': MemberSpec_('instrumentIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, instrumentIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.instrumentIdScheme = _cast(None, instrumentIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InstrumentId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InstrumentId.subclass:
            return InstrumentId.subclass(*args_, **kwargs_)
        else:
            return InstrumentId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_instrumentIdScheme(self): return self.instrumentIdScheme
    def set_instrumentIdScheme(self, instrumentIdScheme): self.instrumentIdScheme = instrumentIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InstrumentId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InstrumentId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InstrumentId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InstrumentId'):
        if self.instrumentIdScheme is not None and 'instrumentIdScheme' not in already_processed:
            already_processed.add('instrumentIdScheme')
            outfile.write(' instrumentIdScheme=%s' % (quote_attrib(self.instrumentIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='InstrumentId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('instrumentIdScheme', node)
        if value is not None and 'instrumentIdScheme' not in already_processed:
            already_processed.add('instrumentIdScheme')
            self.instrumentIdScheme = value
            self.validate_NonEmptyURI(self.instrumentIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class InstrumentId


class InterestAccrualsMethod(GeneratedsSuper):
    """A type describing the method for accruing interests on dividends.
    Can be either a fixed rate reference or a floating rate
    reference."""
    member_data_items_ = {
        'floatingRateCalculation': MemberSpec_('floatingRateCalculation', 'FloatingRateCalculation', 0),
        'fixedRate': MemberSpec_('fixedRate', 'xsd:decimal', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, floatingRateCalculation=None, fixedRate=None, extensiontype_=None):
        self.original_tagname_ = None
        self.floatingRateCalculation = floatingRateCalculation
        self.fixedRate = fixedRate
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InterestAccrualsMethod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InterestAccrualsMethod.subclass:
            return InterestAccrualsMethod.subclass(*args_, **kwargs_)
        else:
            return InterestAccrualsMethod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_floatingRateCalculation(self): return self.floatingRateCalculation
    def set_floatingRateCalculation(self, floatingRateCalculation): self.floatingRateCalculation = floatingRateCalculation
    def get_fixedRate(self): return self.fixedRate
    def set_fixedRate(self, fixedRate): self.fixedRate = fixedRate
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.floatingRateCalculation is not None or
            self.fixedRate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InterestAccrualsMethod', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InterestAccrualsMethod')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InterestAccrualsMethod', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InterestAccrualsMethod'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='InterestAccrualsMethod', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.floatingRateCalculation is not None:
            self.floatingRateCalculation.export(outfile, level, namespace_, name_='floatingRateCalculation', pretty_print=pretty_print)
        if self.fixedRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfixedRate>%s</%sfixedRate>%s' % (namespace_, self.gds_format_float(self.fixedRate, input_name='fixedRate'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'floatingRateCalculation':
            obj_ = FloatingRateCalculation.factory()
            obj_.build(child_)
            self.floatingRateCalculation = obj_
            obj_.original_tagname_ = 'floatingRateCalculation'
        elif nodeName_ == 'fixedRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'fixedRate')
            self.fixedRate = fval_
# end class InterestAccrualsMethod


class IntermediaryInformation(GeneratedsSuper):
    """A type that describes the information to identify an intermediary
    through which payment will be made by the correspondent bank to
    the ultimate beneficiary of the funds."""
    member_data_items_ = {
        'routingIds': MemberSpec_('routingIds', 'RoutingIds', 0),
        'routingExplicitDetails': MemberSpec_('routingExplicitDetails', 'RoutingExplicitDetails', 0),
        'routingIdsAndExplicitDetails': MemberSpec_('routingIdsAndExplicitDetails', 'RoutingIdsAndExplicitDetails', 0),
        'intermediarySequenceNumber': MemberSpec_('intermediarySequenceNumber', 'xsd:positiveInteger', 0),
        'intermediaryPartyReference': MemberSpec_('intermediaryPartyReference', 'PartyReference', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, routingIds=None, routingExplicitDetails=None, routingIdsAndExplicitDetails=None, intermediarySequenceNumber=None, intermediaryPartyReference=None):
        self.original_tagname_ = None
        self.routingIds = routingIds
        self.routingExplicitDetails = routingExplicitDetails
        self.routingIdsAndExplicitDetails = routingIdsAndExplicitDetails
        self.intermediarySequenceNumber = intermediarySequenceNumber
        self.intermediaryPartyReference = intermediaryPartyReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IntermediaryInformation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IntermediaryInformation.subclass:
            return IntermediaryInformation.subclass(*args_, **kwargs_)
        else:
            return IntermediaryInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_routingIds(self): return self.routingIds
    def set_routingIds(self, routingIds): self.routingIds = routingIds
    def get_routingExplicitDetails(self): return self.routingExplicitDetails
    def set_routingExplicitDetails(self, routingExplicitDetails): self.routingExplicitDetails = routingExplicitDetails
    def get_routingIdsAndExplicitDetails(self): return self.routingIdsAndExplicitDetails
    def set_routingIdsAndExplicitDetails(self, routingIdsAndExplicitDetails): self.routingIdsAndExplicitDetails = routingIdsAndExplicitDetails
    def get_intermediarySequenceNumber(self): return self.intermediarySequenceNumber
    def set_intermediarySequenceNumber(self, intermediarySequenceNumber): self.intermediarySequenceNumber = intermediarySequenceNumber
    def get_intermediaryPartyReference(self): return self.intermediaryPartyReference
    def set_intermediaryPartyReference(self, intermediaryPartyReference): self.intermediaryPartyReference = intermediaryPartyReference
    def hasContent_(self):
        if (
            self.routingIds is not None or
            self.routingExplicitDetails is not None or
            self.routingIdsAndExplicitDetails is not None or
            self.intermediarySequenceNumber is not None or
            self.intermediaryPartyReference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IntermediaryInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IntermediaryInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IntermediaryInformation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IntermediaryInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IntermediaryInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.routingIds is not None:
            self.routingIds.export(outfile, level, namespace_, name_='routingIds', pretty_print=pretty_print)
        if self.routingExplicitDetails is not None:
            self.routingExplicitDetails.export(outfile, level, namespace_, name_='routingExplicitDetails', pretty_print=pretty_print)
        if self.routingIdsAndExplicitDetails is not None:
            self.routingIdsAndExplicitDetails.export(outfile, level, namespace_, name_='routingIdsAndExplicitDetails', pretty_print=pretty_print)
        if self.intermediarySequenceNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sintermediarySequenceNumber>%s</%sintermediarySequenceNumber>%s' % (namespace_, self.gds_format_integer(self.intermediarySequenceNumber, input_name='intermediarySequenceNumber'), namespace_, eol_))
        if self.intermediaryPartyReference is not None:
            self.intermediaryPartyReference.export(outfile, level, namespace_, name_='intermediaryPartyReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'routingIds':
            obj_ = RoutingIds.factory()
            obj_.build(child_)
            self.routingIds = obj_
            obj_.original_tagname_ = 'routingIds'
        elif nodeName_ == 'routingExplicitDetails':
            obj_ = RoutingExplicitDetails.factory()
            obj_.build(child_)
            self.routingExplicitDetails = obj_
            obj_.original_tagname_ = 'routingExplicitDetails'
        elif nodeName_ == 'routingIdsAndExplicitDetails':
            obj_ = RoutingIdsAndExplicitDetails.factory()
            obj_.build(child_)
            self.routingIdsAndExplicitDetails = obj_
            obj_.original_tagname_ = 'routingIdsAndExplicitDetails'
        elif nodeName_ == 'intermediarySequenceNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'intermediarySequenceNumber')
            self.intermediarySequenceNumber = ival_
        elif nodeName_ == 'intermediaryPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.intermediaryPartyReference = obj_
            obj_.original_tagname_ = 'intermediaryPartyReference'
# end class IntermediaryInformation


class InterpolationMethod(GeneratedsSuper):
    """The type of interpolation used."""
    member_data_items_ = {
        'interpolationMethodScheme': MemberSpec_('interpolationMethodScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, interpolationMethodScheme='http://www.fpml.org/coding-scheme/interpolation-method', valueOf_=None):
        self.original_tagname_ = None
        self.interpolationMethodScheme = _cast(None, interpolationMethodScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InterpolationMethod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InterpolationMethod.subclass:
            return InterpolationMethod.subclass(*args_, **kwargs_)
        else:
            return InterpolationMethod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_interpolationMethodScheme(self): return self.interpolationMethodScheme
    def set_interpolationMethodScheme(self, interpolationMethodScheme): self.interpolationMethodScheme = interpolationMethodScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InterpolationMethod', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InterpolationMethod')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InterpolationMethod', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InterpolationMethod'):
        if self.interpolationMethodScheme != "http://www.fpml.org/coding-scheme/interpolation-method" and 'interpolationMethodScheme' not in already_processed:
            already_processed.add('interpolationMethodScheme')
            outfile.write(' interpolationMethodScheme=%s' % (quote_attrib(self.interpolationMethodScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='InterpolationMethod', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('interpolationMethodScheme', node)
        if value is not None and 'interpolationMethodScheme' not in already_processed:
            already_processed.add('interpolationMethodScheme')
            self.interpolationMethodScheme = value
            self.validate_NonEmptyURI(self.interpolationMethodScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class InterpolationMethod


class Language(GeneratedsSuper):
    """The data type used for indicating the language of the resource,
    described using the ISO 639-2/T Code."""
    member_data_items_ = {
        'languageScheme': MemberSpec_('languageScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, languageScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.languageScheme = _cast(None, languageScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Language)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Language.subclass:
            return Language.subclass(*args_, **kwargs_)
        else:
            return Language(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_languageScheme(self): return self.languageScheme
    def set_languageScheme(self, languageScheme): self.languageScheme = languageScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Language', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Language')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Language', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Language'):
        if self.languageScheme is not None and 'languageScheme' not in already_processed:
            already_processed.add('languageScheme')
            outfile.write(' languageScheme=%s' % (quote_attrib(self.languageScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Language', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('languageScheme', node)
        if value is not None and 'languageScheme' not in already_processed:
            already_processed.add('languageScheme')
            self.languageScheme = value
            self.validate_NonEmptyURI(self.languageScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Language


class Leg(GeneratedsSuper):
    """A supertype of leg. All swap legs extend this type."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Leg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Leg.subclass:
            return Leg.subclass(*args_, **kwargs_)
        else:
            return Leg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Leg', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Leg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Leg', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Leg'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Leg', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Leg


class LegId(GeneratedsSuper):
    """Leg identity."""
    member_data_items_ = {
        'legIdScheme': MemberSpec_('legIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Token60', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, legIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.legIdScheme = _cast(None, legIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LegId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LegId.subclass:
            return LegId.subclass(*args_, **kwargs_)
        else:
            return LegId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_legIdScheme(self): return self.legIdScheme
    def set_legIdScheme(self, legIdScheme): self.legIdScheme = legIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LegId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LegId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LegId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LegId'):
        if self.legIdScheme is not None and 'legIdScheme' not in already_processed:
            already_processed.add('legIdScheme')
            outfile.write(' legIdScheme=%s' % (quote_attrib(self.legIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LegId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('legIdScheme', node)
        if value is not None and 'legIdScheme' not in already_processed:
            already_processed.add('legIdScheme')
            self.legIdScheme = value
            self.validate_NonEmptyURI(self.legIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LegId


class LegIdentifier(GeneratedsSuper):
    """Version aware identification of a leg."""
    member_data_items_ = {
        'legId': MemberSpec_('legId', 'LegId', 0),
        'version': MemberSpec_('version', 'xsd:nonNegativeInteger', 0),
        'effectiveDate': MemberSpec_('effectiveDate', 'IdentifiedDate', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, legId=None, version=None, effectiveDate=None):
        self.original_tagname_ = None
        self.legId = legId
        self.version = version
        self.effectiveDate = effectiveDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LegIdentifier)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LegIdentifier.subclass:
            return LegIdentifier.subclass(*args_, **kwargs_)
        else:
            return LegIdentifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_legId(self): return self.legId
    def set_legId(self, legId): self.legId = legId
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_effectiveDate(self): return self.effectiveDate
    def set_effectiveDate(self, effectiveDate): self.effectiveDate = effectiveDate
    def hasContent_(self):
        if (
            self.legId is not None or
            self.version is not None or
            self.effectiveDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LegIdentifier', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LegIdentifier')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LegIdentifier', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LegIdentifier'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LegIdentifier', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.legId is not None:
            self.legId.export(outfile, level, namespace_, name_='legId', pretty_print=pretty_print)
        if self.version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sversion>%s</%sversion>%s' % (namespace_, self.gds_format_integer(self.version, input_name='version'), namespace_, eol_))
        if self.effectiveDate is not None:
            self.effectiveDate.export(outfile, level, namespace_, name_='effectiveDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'legId':
            obj_ = LegId.factory()
            obj_.build(child_)
            self.legId = obj_
            obj_.original_tagname_ = 'legId'
        elif nodeName_ == 'version':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'version')
            self.version = ival_
        elif nodeName_ == 'effectiveDate':
            obj_ = IdentifiedDate.factory()
            obj_.build(child_)
            self.effectiveDate = obj_
            obj_.original_tagname_ = 'effectiveDate'
# end class LegIdentifier


class LegalEntity(GeneratedsSuper):
    """A type defining a legal entity."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'entityName': MemberSpec_('entityName', 'EntityName', 0),
        'entityId': MemberSpec_('entityId', 'EntityId', 1),
        'entityId': MemberSpec_('entityId', 'EntityId', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, entityName=None, entityId=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.entityName = entityName
        if entityId is None:
            self.entityId = []
        else:
            self.entityId = entityId
        if entityId is None:
            self.entityId = []
        else:
            self.entityId = entityId
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LegalEntity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LegalEntity.subclass:
            return LegalEntity.subclass(*args_, **kwargs_)
        else:
            return LegalEntity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_entityName(self): return self.entityName
    def set_entityName(self, entityName): self.entityName = entityName
    def get_entityId(self): return self.entityId
    def set_entityId(self, entityId): self.entityId = entityId
    def add_entityId(self, value): self.entityId.append(value)
    def insert_entityId_at(self, index, value): self.entityId.insert(index, value)
    def replace_entityId_at(self, index, value): self.entityId[index] = value
    def get_entityId(self): return self.entityId
    def set_entityId(self, entityId): self.entityId = entityId
    def add_entityId(self, value): self.entityId.append(value)
    def insert_entityId_at(self, index, value): self.entityId.insert(index, value)
    def replace_entityId_at(self, index, value): self.entityId[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.entityName is not None or
            self.entityId or
            self.entityId
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LegalEntity', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LegalEntity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LegalEntity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LegalEntity'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LegalEntity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.entityName is not None:
            self.entityName.export(outfile, level, namespace_, name_='entityName', pretty_print=pretty_print)
        for entityId_ in self.entityId:
            entityId_.export(outfile, level, namespace_, name_='entityId', pretty_print=pretty_print)
        for entityId_ in self.entityId:
            entityId_.export(outfile, level, namespace_, name_='entityId', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'entityName':
            obj_ = EntityName.factory()
            obj_.build(child_)
            self.entityName = obj_
            obj_.original_tagname_ = 'entityName'
        elif nodeName_ == 'entityId':
            obj_ = EntityId.factory()
            obj_.build(child_)
            self.entityId.append(obj_)
            obj_.original_tagname_ = 'entityId'
        elif nodeName_ == 'entityId':
            obj_ = EntityId.factory()
            obj_.build(child_)
            self.entityId.append(obj_)
            obj_.original_tagname_ = 'entityId'
# end class LegalEntity


class MainPublication(GeneratedsSuper):
    """A type to define the main publication source."""
    member_data_items_ = {
        'mainPublicationScheme': MemberSpec_('mainPublicationScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, mainPublicationScheme='http://www.fpml.org/coding-scheme/inflation-main-publication', valueOf_=None):
        self.original_tagname_ = None
        self.mainPublicationScheme = _cast(None, mainPublicationScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MainPublication)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MainPublication.subclass:
            return MainPublication.subclass(*args_, **kwargs_)
        else:
            return MainPublication(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mainPublicationScheme(self): return self.mainPublicationScheme
    def set_mainPublicationScheme(self, mainPublicationScheme): self.mainPublicationScheme = mainPublicationScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MainPublication', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MainPublication')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MainPublication', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MainPublication'):
        if self.mainPublicationScheme != "http://www.fpml.org/coding-scheme/inflation-main-publication" and 'mainPublicationScheme' not in already_processed:
            already_processed.add('mainPublicationScheme')
            outfile.write(' mainPublicationScheme=%s' % (quote_attrib(self.mainPublicationScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MainPublication', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mainPublicationScheme', node)
        if value is not None and 'mainPublicationScheme' not in already_processed:
            already_processed.add('mainPublicationScheme')
            self.mainPublicationScheme = value
            self.validate_NonEmptyURI(self.mainPublicationScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MainPublication


class ManualExercise(GeneratedsSuper):
    """A type defining manual exercise, i.e. that the option buyer
    counterparty must give notice to the option seller of exercise."""
    member_data_items_ = {
        'exerciseNotice': MemberSpec_('exerciseNotice', 'ExerciseNotice', 0),
        'fallbackExercise': MemberSpec_('fallbackExercise', 'xsd:boolean', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, exerciseNotice=None, fallbackExercise=None):
        self.original_tagname_ = None
        self.exerciseNotice = exerciseNotice
        self.fallbackExercise = fallbackExercise
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ManualExercise)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ManualExercise.subclass:
            return ManualExercise.subclass(*args_, **kwargs_)
        else:
            return ManualExercise(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_exerciseNotice(self): return self.exerciseNotice
    def set_exerciseNotice(self, exerciseNotice): self.exerciseNotice = exerciseNotice
    def get_fallbackExercise(self): return self.fallbackExercise
    def set_fallbackExercise(self, fallbackExercise): self.fallbackExercise = fallbackExercise
    def hasContent_(self):
        if (
            self.exerciseNotice is not None or
            self.fallbackExercise is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ManualExercise', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ManualExercise')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ManualExercise', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ManualExercise'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ManualExercise', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.exerciseNotice is not None:
            self.exerciseNotice.export(outfile, level, namespace_, name_='exerciseNotice', pretty_print=pretty_print)
        if self.fallbackExercise is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfallbackExercise>%s</%sfallbackExercise>%s' % (namespace_, self.gds_format_boolean(self.fallbackExercise, input_name='fallbackExercise'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'exerciseNotice':
            obj_ = ExerciseNotice.factory()
            obj_.build(child_)
            self.exerciseNotice = obj_
            obj_.original_tagname_ = 'exerciseNotice'
        elif nodeName_ == 'fallbackExercise':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'fallbackExercise')
            self.fallbackExercise = ival_
# end class ManualExercise


class MasterAgreement(GeneratedsSuper):
    """An entity for defining the agreement executed between the parties
    and intended to govern all OTC derivatives transactions between
    those parties."""
    member_data_items_ = {
        'masterAgreementId': MemberSpec_('masterAgreementId', 'MasterAgreementId', 1),
        'masterAgreementType': MemberSpec_('masterAgreementType', 'MasterAgreementType', 0),
        'masterAgreementVersion': MemberSpec_('masterAgreementVersion', 'MasterAgreementVersion', 0),
        'masterAgreementDate': MemberSpec_('masterAgreementDate', 'xsd:date', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, masterAgreementId=None, masterAgreementType=None, masterAgreementVersion=None, masterAgreementDate=None):
        self.original_tagname_ = None
        if masterAgreementId is None:
            self.masterAgreementId = []
        else:
            self.masterAgreementId = masterAgreementId
        self.masterAgreementType = masterAgreementType
        self.masterAgreementVersion = masterAgreementVersion
        if isinstance(masterAgreementDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(masterAgreementDate, '%Y-%m-%d').date()
        else:
            initvalue_ = masterAgreementDate
        self.masterAgreementDate = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MasterAgreement)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MasterAgreement.subclass:
            return MasterAgreement.subclass(*args_, **kwargs_)
        else:
            return MasterAgreement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_masterAgreementId(self): return self.masterAgreementId
    def set_masterAgreementId(self, masterAgreementId): self.masterAgreementId = masterAgreementId
    def add_masterAgreementId(self, value): self.masterAgreementId.append(value)
    def insert_masterAgreementId_at(self, index, value): self.masterAgreementId.insert(index, value)
    def replace_masterAgreementId_at(self, index, value): self.masterAgreementId[index] = value
    def get_masterAgreementType(self): return self.masterAgreementType
    def set_masterAgreementType(self, masterAgreementType): self.masterAgreementType = masterAgreementType
    def get_masterAgreementVersion(self): return self.masterAgreementVersion
    def set_masterAgreementVersion(self, masterAgreementVersion): self.masterAgreementVersion = masterAgreementVersion
    def get_masterAgreementDate(self): return self.masterAgreementDate
    def set_masterAgreementDate(self, masterAgreementDate): self.masterAgreementDate = masterAgreementDate
    def hasContent_(self):
        if (
            self.masterAgreementId or
            self.masterAgreementType is not None or
            self.masterAgreementVersion is not None or
            self.masterAgreementDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MasterAgreement', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MasterAgreement')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MasterAgreement', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MasterAgreement'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MasterAgreement', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for masterAgreementId_ in self.masterAgreementId:
            masterAgreementId_.export(outfile, level, namespace_, name_='masterAgreementId', pretty_print=pretty_print)
        if self.masterAgreementType is not None:
            self.masterAgreementType.export(outfile, level, namespace_, name_='masterAgreementType', pretty_print=pretty_print)
        if self.masterAgreementVersion is not None:
            self.masterAgreementVersion.export(outfile, level, namespace_, name_='masterAgreementVersion', pretty_print=pretty_print)
        if self.masterAgreementDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smasterAgreementDate>%s</%smasterAgreementDate>%s' % (namespace_, self.gds_format_date(self.masterAgreementDate, input_name='masterAgreementDate'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'masterAgreementId':
            obj_ = MasterAgreementId.factory()
            obj_.build(child_)
            self.masterAgreementId.append(obj_)
            obj_.original_tagname_ = 'masterAgreementId'
        elif nodeName_ == 'masterAgreementType':
            obj_ = MasterAgreementType.factory()
            obj_.build(child_)
            self.masterAgreementType = obj_
            obj_.original_tagname_ = 'masterAgreementType'
        elif nodeName_ == 'masterAgreementVersion':
            obj_ = MasterAgreementVersion.factory()
            obj_.build(child_)
            self.masterAgreementVersion = obj_
            obj_.original_tagname_ = 'masterAgreementVersion'
        elif nodeName_ == 'masterAgreementDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.masterAgreementDate = dval_
# end class MasterAgreement


class MasterAgreementId(GeneratedsSuper):
    """A master agreement identifier allocated by a party. FpML does not
    define the domain values associated with this element. Note that
    the domain values for this element are not strictly an
    enumerated list."""
    member_data_items_ = {
        'masterAgreementIdScheme': MemberSpec_('masterAgreementIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, masterAgreementIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.masterAgreementIdScheme = _cast(None, masterAgreementIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MasterAgreementId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MasterAgreementId.subclass:
            return MasterAgreementId.subclass(*args_, **kwargs_)
        else:
            return MasterAgreementId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_masterAgreementIdScheme(self): return self.masterAgreementIdScheme
    def set_masterAgreementIdScheme(self, masterAgreementIdScheme): self.masterAgreementIdScheme = masterAgreementIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MasterAgreementId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MasterAgreementId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MasterAgreementId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MasterAgreementId'):
        if self.masterAgreementIdScheme is not None and 'masterAgreementIdScheme' not in already_processed:
            already_processed.add('masterAgreementIdScheme')
            outfile.write(' masterAgreementIdScheme=%s' % (quote_attrib(self.masterAgreementIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MasterAgreementId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('masterAgreementIdScheme', node)
        if value is not None and 'masterAgreementIdScheme' not in already_processed:
            already_processed.add('masterAgreementIdScheme')
            self.masterAgreementIdScheme = value
            self.validate_NonEmptyURI(self.masterAgreementIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MasterAgreementId


class MasterAgreementType(GeneratedsSuper):
    member_data_items_ = {
        'masterAgreementTypeScheme': MemberSpec_('masterAgreementTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, masterAgreementTypeScheme='http://www.fpml.org/coding-scheme/master-agreement-type', valueOf_=None):
        self.original_tagname_ = None
        self.masterAgreementTypeScheme = _cast(None, masterAgreementTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MasterAgreementType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MasterAgreementType.subclass:
            return MasterAgreementType.subclass(*args_, **kwargs_)
        else:
            return MasterAgreementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_masterAgreementTypeScheme(self): return self.masterAgreementTypeScheme
    def set_masterAgreementTypeScheme(self, masterAgreementTypeScheme): self.masterAgreementTypeScheme = masterAgreementTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MasterAgreementType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MasterAgreementType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MasterAgreementType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MasterAgreementType'):
        if self.masterAgreementTypeScheme != "http://www.fpml.org/coding-scheme/master-agreement-type" and 'masterAgreementTypeScheme' not in already_processed:
            already_processed.add('masterAgreementTypeScheme')
            outfile.write(' masterAgreementTypeScheme=%s' % (quote_attrib(self.masterAgreementTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MasterAgreementType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('masterAgreementTypeScheme', node)
        if value is not None and 'masterAgreementTypeScheme' not in already_processed:
            already_processed.add('masterAgreementTypeScheme')
            self.masterAgreementTypeScheme = value
            self.validate_NonEmptyURI(self.masterAgreementTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MasterAgreementType


class MasterAgreementVersion(GeneratedsSuper):
    member_data_items_ = {
        'masterAgreementVersionScheme': MemberSpec_('masterAgreementVersionScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, masterAgreementVersionScheme='http://www.fpml.org/coding-scheme/master-agreement-version', valueOf_=None):
        self.original_tagname_ = None
        self.masterAgreementVersionScheme = _cast(None, masterAgreementVersionScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MasterAgreementVersion)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MasterAgreementVersion.subclass:
            return MasterAgreementVersion.subclass(*args_, **kwargs_)
        else:
            return MasterAgreementVersion(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_masterAgreementVersionScheme(self): return self.masterAgreementVersionScheme
    def set_masterAgreementVersionScheme(self, masterAgreementVersionScheme): self.masterAgreementVersionScheme = masterAgreementVersionScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MasterAgreementVersion', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MasterAgreementVersion')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MasterAgreementVersion', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MasterAgreementVersion'):
        if self.masterAgreementVersionScheme != "http://www.fpml.org/coding-scheme/master-agreement-version" and 'masterAgreementVersionScheme' not in already_processed:
            already_processed.add('masterAgreementVersionScheme')
            outfile.write(' masterAgreementVersionScheme=%s' % (quote_attrib(self.masterAgreementVersionScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MasterAgreementVersion', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('masterAgreementVersionScheme', node)
        if value is not None and 'masterAgreementVersionScheme' not in already_processed:
            already_processed.add('masterAgreementVersionScheme')
            self.masterAgreementVersionScheme = value
            self.validate_NonEmptyURI(self.masterAgreementVersionScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MasterAgreementVersion


class MasterConfirmation(GeneratedsSuper):
    """An entity for defining the master confirmation agreement executed
    between the parties."""
    member_data_items_ = {
        'masterConfirmationType': MemberSpec_('masterConfirmationType', 'MasterConfirmationType', 0),
        'masterConfirmationDate': MemberSpec_('masterConfirmationDate', 'xsd:date', 0),
        'masterConfirmationAnnexDate': MemberSpec_('masterConfirmationAnnexDate', 'xsd:date', 0),
        'masterConfirmationAnnexType': MemberSpec_('masterConfirmationAnnexType', 'MasterConfirmationAnnexType', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, masterConfirmationType=None, masterConfirmationDate=None, masterConfirmationAnnexDate=None, masterConfirmationAnnexType=None):
        self.original_tagname_ = None
        self.masterConfirmationType = masterConfirmationType
        if isinstance(masterConfirmationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(masterConfirmationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = masterConfirmationDate
        self.masterConfirmationDate = initvalue_
        if isinstance(masterConfirmationAnnexDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(masterConfirmationAnnexDate, '%Y-%m-%d').date()
        else:
            initvalue_ = masterConfirmationAnnexDate
        self.masterConfirmationAnnexDate = initvalue_
        self.masterConfirmationAnnexType = masterConfirmationAnnexType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MasterConfirmation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MasterConfirmation.subclass:
            return MasterConfirmation.subclass(*args_, **kwargs_)
        else:
            return MasterConfirmation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_masterConfirmationType(self): return self.masterConfirmationType
    def set_masterConfirmationType(self, masterConfirmationType): self.masterConfirmationType = masterConfirmationType
    def get_masterConfirmationDate(self): return self.masterConfirmationDate
    def set_masterConfirmationDate(self, masterConfirmationDate): self.masterConfirmationDate = masterConfirmationDate
    def get_masterConfirmationAnnexDate(self): return self.masterConfirmationAnnexDate
    def set_masterConfirmationAnnexDate(self, masterConfirmationAnnexDate): self.masterConfirmationAnnexDate = masterConfirmationAnnexDate
    def get_masterConfirmationAnnexType(self): return self.masterConfirmationAnnexType
    def set_masterConfirmationAnnexType(self, masterConfirmationAnnexType): self.masterConfirmationAnnexType = masterConfirmationAnnexType
    def hasContent_(self):
        if (
            self.masterConfirmationType is not None or
            self.masterConfirmationDate is not None or
            self.masterConfirmationAnnexDate is not None or
            self.masterConfirmationAnnexType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MasterConfirmation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MasterConfirmation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MasterConfirmation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MasterConfirmation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MasterConfirmation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.masterConfirmationType is not None:
            self.masterConfirmationType.export(outfile, level, namespace_, name_='masterConfirmationType', pretty_print=pretty_print)
        if self.masterConfirmationDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smasterConfirmationDate>%s</%smasterConfirmationDate>%s' % (namespace_, self.gds_format_date(self.masterConfirmationDate, input_name='masterConfirmationDate'), namespace_, eol_))
        if self.masterConfirmationAnnexDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smasterConfirmationAnnexDate>%s</%smasterConfirmationAnnexDate>%s' % (namespace_, self.gds_format_date(self.masterConfirmationAnnexDate, input_name='masterConfirmationAnnexDate'), namespace_, eol_))
        if self.masterConfirmationAnnexType is not None:
            self.masterConfirmationAnnexType.export(outfile, level, namespace_, name_='masterConfirmationAnnexType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'masterConfirmationType':
            obj_ = MasterConfirmationType.factory()
            obj_.build(child_)
            self.masterConfirmationType = obj_
            obj_.original_tagname_ = 'masterConfirmationType'
        elif nodeName_ == 'masterConfirmationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.masterConfirmationDate = dval_
        elif nodeName_ == 'masterConfirmationAnnexDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.masterConfirmationAnnexDate = dval_
        elif nodeName_ == 'masterConfirmationAnnexType':
            obj_ = MasterConfirmationAnnexType.factory()
            obj_.build(child_)
            self.masterConfirmationAnnexType = obj_
            obj_.original_tagname_ = 'masterConfirmationAnnexType'
# end class MasterConfirmation


class MasterConfirmationAnnexType(GeneratedsSuper):
    member_data_items_ = {
        'masterConfirmationAnnexTypeScheme': MemberSpec_('masterConfirmationAnnexTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, masterConfirmationAnnexTypeScheme='http://www.fpml.org/coding-scheme/master-confirmation-annex-type', valueOf_=None):
        self.original_tagname_ = None
        self.masterConfirmationAnnexTypeScheme = _cast(None, masterConfirmationAnnexTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MasterConfirmationAnnexType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MasterConfirmationAnnexType.subclass:
            return MasterConfirmationAnnexType.subclass(*args_, **kwargs_)
        else:
            return MasterConfirmationAnnexType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_masterConfirmationAnnexTypeScheme(self): return self.masterConfirmationAnnexTypeScheme
    def set_masterConfirmationAnnexTypeScheme(self, masterConfirmationAnnexTypeScheme): self.masterConfirmationAnnexTypeScheme = masterConfirmationAnnexTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MasterConfirmationAnnexType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MasterConfirmationAnnexType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MasterConfirmationAnnexType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MasterConfirmationAnnexType'):
        if self.masterConfirmationAnnexTypeScheme != "http://www.fpml.org/coding-scheme/master-confirmation-annex-type" and 'masterConfirmationAnnexTypeScheme' not in already_processed:
            already_processed.add('masterConfirmationAnnexTypeScheme')
            outfile.write(' masterConfirmationAnnexTypeScheme=%s' % (quote_attrib(self.masterConfirmationAnnexTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MasterConfirmationAnnexType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('masterConfirmationAnnexTypeScheme', node)
        if value is not None and 'masterConfirmationAnnexTypeScheme' not in already_processed:
            already_processed.add('masterConfirmationAnnexTypeScheme')
            self.masterConfirmationAnnexTypeScheme = value
            self.validate_NonEmptyURI(self.masterConfirmationAnnexTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MasterConfirmationAnnexType


class MasterConfirmationType(GeneratedsSuper):
    member_data_items_ = {
        'masterConfirmationTypeScheme': MemberSpec_('masterConfirmationTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, masterConfirmationTypeScheme='http://www.fpml.org/coding-scheme/master-confirmation-type', valueOf_=None):
        self.original_tagname_ = None
        self.masterConfirmationTypeScheme = _cast(None, masterConfirmationTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MasterConfirmationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MasterConfirmationType.subclass:
            return MasterConfirmationType.subclass(*args_, **kwargs_)
        else:
            return MasterConfirmationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_masterConfirmationTypeScheme(self): return self.masterConfirmationTypeScheme
    def set_masterConfirmationTypeScheme(self, masterConfirmationTypeScheme): self.masterConfirmationTypeScheme = masterConfirmationTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MasterConfirmationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MasterConfirmationType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MasterConfirmationType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MasterConfirmationType'):
        if self.masterConfirmationTypeScheme != "http://www.fpml.org/coding-scheme/master-confirmation-type" and 'masterConfirmationTypeScheme' not in already_processed:
            already_processed.add('masterConfirmationTypeScheme')
            outfile.write(' masterConfirmationTypeScheme=%s' % (quote_attrib(self.masterConfirmationTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MasterConfirmationType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('masterConfirmationTypeScheme', node)
        if value is not None and 'masterConfirmationTypeScheme' not in already_processed:
            already_processed.add('masterConfirmationTypeScheme')
            self.masterConfirmationTypeScheme = value
            self.validate_NonEmptyURI(self.masterConfirmationTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MasterConfirmationType


class MatchId(GeneratedsSuper):
    """An identifier used to identify matched cashflows."""
    member_data_items_ = {
        'matchIdScheme': MemberSpec_('matchIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, matchIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.matchIdScheme = _cast(None, matchIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MatchId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MatchId.subclass:
            return MatchId.subclass(*args_, **kwargs_)
        else:
            return MatchId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_matchIdScheme(self): return self.matchIdScheme
    def set_matchIdScheme(self, matchIdScheme): self.matchIdScheme = matchIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MatchId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MatchId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MatchId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MatchId'):
        if self.matchIdScheme is not None and 'matchIdScheme' not in already_processed:
            already_processed.add('matchIdScheme')
            outfile.write(' matchIdScheme=%s' % (quote_attrib(self.matchIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MatchId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('matchIdScheme', node)
        if value is not None and 'matchIdScheme' not in already_processed:
            already_processed.add('matchIdScheme')
            self.matchIdScheme = value
            self.validate_NonEmptyURI(self.matchIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MatchId


class Math(GeneratedsSuper):
    """A type defining a mathematical expression."""
    member_data_items_ = {
        '': MemberSpec_('', 'xsd:string', 1),
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Math)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Math.subclass:
            return Math.subclass(*args_, **kwargs_)
        else:
            return Math(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Math', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Math')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Math', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Math'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Math', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class Math


class MatrixType(GeneratedsSuper):
    member_data_items_ = {
        'matrixTypeScheme': MemberSpec_('matrixTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, matrixTypeScheme='http://www.fpml.org/coding-scheme/matrix-type', valueOf_=None):
        self.original_tagname_ = None
        self.matrixTypeScheme = _cast(None, matrixTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MatrixType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MatrixType.subclass:
            return MatrixType.subclass(*args_, **kwargs_)
        else:
            return MatrixType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_matrixTypeScheme(self): return self.matrixTypeScheme
    def set_matrixTypeScheme(self, matrixTypeScheme): self.matrixTypeScheme = matrixTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MatrixType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MatrixType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MatrixType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MatrixType'):
        if self.matrixTypeScheme != "http://www.fpml.org/coding-scheme/matrix-type" and 'matrixTypeScheme' not in already_processed:
            already_processed.add('matrixTypeScheme')
            outfile.write(' matrixTypeScheme=%s' % (quote_attrib(self.matrixTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MatrixType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('matrixTypeScheme', node)
        if value is not None and 'matrixTypeScheme' not in already_processed:
            already_processed.add('matrixTypeScheme')
            self.matrixTypeScheme = value
            self.validate_NonEmptyURI(self.matrixTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MatrixType


class MatrixTerm(GeneratedsSuper):
    member_data_items_ = {
        'matrixTermScheme': MemberSpec_('matrixTermScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, matrixTermScheme='http://www.fpml.org/coding-scheme/credit-matrix-transaction-type', valueOf_=None):
        self.original_tagname_ = None
        self.matrixTermScheme = _cast(None, matrixTermScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MatrixTerm)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MatrixTerm.subclass:
            return MatrixTerm.subclass(*args_, **kwargs_)
        else:
            return MatrixTerm(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_matrixTermScheme(self): return self.matrixTermScheme
    def set_matrixTermScheme(self, matrixTermScheme): self.matrixTermScheme = matrixTermScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MatrixTerm', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MatrixTerm')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MatrixTerm', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MatrixTerm'):
        if self.matrixTermScheme != "http://www.fpml.org/coding-scheme/credit-matrix-transaction-type" and 'matrixTermScheme' not in already_processed:
            already_processed.add('matrixTermScheme')
            outfile.write(' matrixTermScheme=%s' % (quote_attrib(self.matrixTermScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MatrixTerm', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('matrixTermScheme', node)
        if value is not None and 'matrixTermScheme' not in already_processed:
            already_processed.add('matrixTermScheme')
            self.matrixTermScheme = value
            self.validate_NonEmptyURI(self.matrixTermScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MatrixTerm


class MimeType(GeneratedsSuper):
    """The type that indicates the type of media used to store the content.
    MimeType is used to determine the software product(s) that can
    read the content. MIME types are described in RFC 2046."""
    member_data_items_ = {
        'mimeTypeScheme': MemberSpec_('mimeTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, mimeTypeScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.mimeTypeScheme = _cast(None, mimeTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MimeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MimeType.subclass:
            return MimeType.subclass(*args_, **kwargs_)
        else:
            return MimeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mimeTypeScheme(self): return self.mimeTypeScheme
    def set_mimeTypeScheme(self, mimeTypeScheme): self.mimeTypeScheme = mimeTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MimeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MimeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MimeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MimeType'):
        if self.mimeTypeScheme is not None and 'mimeTypeScheme' not in already_processed:
            already_processed.add('mimeTypeScheme')
            outfile.write(' mimeTypeScheme=%s' % (quote_attrib(self.mimeTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MimeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mimeTypeScheme', node)
        if value is not None and 'mimeTypeScheme' not in already_processed:
            already_processed.add('mimeTypeScheme')
            self.mimeTypeScheme = value
            self.validate_NonEmptyURI(self.mimeTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MimeType


class MoneyBase(GeneratedsSuper):
    """Abstract base class for all money types."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'currency': MemberSpec_('currency', 'Currency', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, currency=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.currency = currency
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MoneyBase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MoneyBase.subclass:
            return MoneyBase.subclass(*args_, **kwargs_)
        else:
            return MoneyBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.currency is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MoneyBase', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MoneyBase')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MoneyBase', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MoneyBase'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='MoneyBase', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.currency is not None:
            self.currency.export(outfile, level, namespace_, name_='currency', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'currency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
# end class MoneyBase


class MultipleExercise(GeneratedsSuper):
    """A type defining multiple exercises. As defining in the 2000 ISDA
    Definitions, Section 12.4. Multiple Exercise, the buyer of the
    option has the right to exercise all or less than all the
    unexercised notional amount of the underlying swap on one or
    more days in the exercise period, but on any such day may not
    exercise less than the minimum notional amount or more than the
    maximum notional amount, and if an integral multiple amount is
    specified, the notional exercised must be equal to or, be an
    integral multiple of, the integral multiple amount."""
    member_data_items_ = {
        'notionalReference': MemberSpec_('notionalReference', 'NotionalReference', 1),
        'integralMultipleAmount': MemberSpec_('integralMultipleAmount', 'xsd:decimal', 0),
        'minimumNotionalAmount': MemberSpec_('minimumNotionalAmount', 'xsd:decimal', 0),
        'minimumNumberOfOptions': MemberSpec_('minimumNumberOfOptions', 'xsd:nonNegativeInteger', 0),
        'maximumNotionalAmount': MemberSpec_('maximumNotionalAmount', 'xsd:decimal', 0),
        'maximumNumberOfOptions': MemberSpec_('maximumNumberOfOptions', ['NonNegativeDecimal', 'xsd:decimal'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, notionalReference=None, integralMultipleAmount=None, minimumNotionalAmount=None, minimumNumberOfOptions=None, maximumNotionalAmount=None, maximumNumberOfOptions=None):
        self.original_tagname_ = None
        if notionalReference is None:
            self.notionalReference = []
        else:
            self.notionalReference = notionalReference
        self.integralMultipleAmount = integralMultipleAmount
        self.minimumNotionalAmount = minimumNotionalAmount
        self.minimumNumberOfOptions = minimumNumberOfOptions
        self.maximumNotionalAmount = maximumNotionalAmount
        self.maximumNumberOfOptions = maximumNumberOfOptions
        self.validate_NonNegativeDecimal(self.maximumNumberOfOptions)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MultipleExercise)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MultipleExercise.subclass:
            return MultipleExercise.subclass(*args_, **kwargs_)
        else:
            return MultipleExercise(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_notionalReference(self): return self.notionalReference
    def set_notionalReference(self, notionalReference): self.notionalReference = notionalReference
    def add_notionalReference(self, value): self.notionalReference.append(value)
    def insert_notionalReference_at(self, index, value): self.notionalReference.insert(index, value)
    def replace_notionalReference_at(self, index, value): self.notionalReference[index] = value
    def get_integralMultipleAmount(self): return self.integralMultipleAmount
    def set_integralMultipleAmount(self, integralMultipleAmount): self.integralMultipleAmount = integralMultipleAmount
    def get_minimumNotionalAmount(self): return self.minimumNotionalAmount
    def set_minimumNotionalAmount(self, minimumNotionalAmount): self.minimumNotionalAmount = minimumNotionalAmount
    def get_minimumNumberOfOptions(self): return self.minimumNumberOfOptions
    def set_minimumNumberOfOptions(self, minimumNumberOfOptions): self.minimumNumberOfOptions = minimumNumberOfOptions
    def get_maximumNotionalAmount(self): return self.maximumNotionalAmount
    def set_maximumNotionalAmount(self, maximumNotionalAmount): self.maximumNotionalAmount = maximumNotionalAmount
    def get_maximumNumberOfOptions(self): return self.maximumNumberOfOptions
    def set_maximumNumberOfOptions(self, maximumNumberOfOptions): self.maximumNumberOfOptions = maximumNumberOfOptions
    def validate_NonNegativeDecimal(self, value):
        # Validate type NonNegativeDecimal, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on NonNegativeDecimal' % {"value" : value} )
    def hasContent_(self):
        if (
            self.notionalReference or
            self.integralMultipleAmount is not None or
            self.minimumNotionalAmount is not None or
            self.minimumNumberOfOptions is not None or
            self.maximumNotionalAmount is not None or
            self.maximumNumberOfOptions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MultipleExercise', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MultipleExercise')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MultipleExercise', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MultipleExercise'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MultipleExercise', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for notionalReference_ in self.notionalReference:
            notionalReference_.export(outfile, level, namespace_, name_='notionalReference', pretty_print=pretty_print)
        if self.integralMultipleAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sintegralMultipleAmount>%s</%sintegralMultipleAmount>%s' % (namespace_, self.gds_format_float(self.integralMultipleAmount, input_name='integralMultipleAmount'), namespace_, eol_))
        if self.minimumNotionalAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sminimumNotionalAmount>%s</%sminimumNotionalAmount>%s' % (namespace_, self.gds_format_float(self.minimumNotionalAmount, input_name='minimumNotionalAmount'), namespace_, eol_))
        if self.minimumNumberOfOptions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sminimumNumberOfOptions>%s</%sminimumNumberOfOptions>%s' % (namespace_, self.gds_format_integer(self.minimumNumberOfOptions, input_name='minimumNumberOfOptions'), namespace_, eol_))
        if self.maximumNotionalAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaximumNotionalAmount>%s</%smaximumNotionalAmount>%s' % (namespace_, self.gds_format_float(self.maximumNotionalAmount, input_name='maximumNotionalAmount'), namespace_, eol_))
        if self.maximumNumberOfOptions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaximumNumberOfOptions>%s</%smaximumNumberOfOptions>%s' % (namespace_, self.gds_format_float(self.maximumNumberOfOptions, input_name='maximumNumberOfOptions'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'notionalReference':
            obj_ = NotionalReference.factory()
            obj_.build(child_)
            self.notionalReference.append(obj_)
            obj_.original_tagname_ = 'notionalReference'
        elif nodeName_ == 'integralMultipleAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'integralMultipleAmount')
            self.integralMultipleAmount = fval_
        elif nodeName_ == 'minimumNotionalAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'minimumNotionalAmount')
            self.minimumNotionalAmount = fval_
        elif nodeName_ == 'minimumNumberOfOptions':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'minimumNumberOfOptions')
            self.minimumNumberOfOptions = ival_
        elif nodeName_ == 'maximumNotionalAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'maximumNotionalAmount')
            self.maximumNotionalAmount = fval_
        elif nodeName_ == 'maximumNumberOfOptions':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'maximumNumberOfOptions')
            self.maximumNumberOfOptions = fval_
            # validate type NonNegativeDecimal
            self.validate_NonNegativeDecimal(self.maximumNumberOfOptions)
# end class MultipleExercise


class NonNegativeMoney(MoneyBase):
    """A type defining a non negative money amount."""
    member_data_items_ = {
        'amount': MemberSpec_('amount', ['NonNegativeDecimal', 'xsd:decimal'], 0),
    }
    subclass = None
    superclass = MoneyBase
    def __init__(self, id=None, currency=None, amount=None, extensiontype_=None):
        self.original_tagname_ = None
        super(NonNegativeMoney, self).__init__(id, currency, extensiontype_, )
        self.amount = amount
        self.validate_NonNegativeDecimal(self.amount)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NonNegativeMoney)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NonNegativeMoney.subclass:
            return NonNegativeMoney.subclass(*args_, **kwargs_)
        else:
            return NonNegativeMoney(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_amount(self): return self.amount
    def set_amount(self, amount): self.amount = amount
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_NonNegativeDecimal(self, value):
        # Validate type NonNegativeDecimal, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on NonNegativeDecimal' % {"value" : value} )
    def hasContent_(self):
        if (
            self.amount is not None or
            super(NonNegativeMoney, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NonNegativeMoney', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NonNegativeMoney')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NonNegativeMoney', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NonNegativeMoney'):
        super(NonNegativeMoney, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NonNegativeMoney')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='NonNegativeMoney', fromsubclass_=False, pretty_print=True):
        super(NonNegativeMoney, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.amount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%samount>%s</%samount>%s' % (namespace_, self.gds_format_float(self.amount, input_name='amount'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(NonNegativeMoney, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'amount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'amount')
            self.amount = fval_
            # validate type NonNegativeDecimal
            self.validate_NonNegativeDecimal(self.amount)
        super(NonNegativeMoney, self).buildChildren(child_, node, nodeName_, True)
# end class NonNegativeMoney


class NonNegativeSchedule(GeneratedsSuper):
    """A type defining a schedule of non-negative rates or amounts in terms
    of an initial value and then a series of step date and value
    pairs. On each step date the rate or amount changes to the new
    step value. The series of step date and value pairs are
    optional. If not specified, this implies that the initial value
    remains unchanged over time."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'initialValue': MemberSpec_('initialValue', ['NonNegativeDecimal', 'xsd:decimal'], 0),
        'step': MemberSpec_('step', 'NonNegativeStep', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, initialValue=None, step=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.initialValue = initialValue
        self.validate_NonNegativeDecimal(self.initialValue)
        if step is None:
            self.step = []
        else:
            self.step = step
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NonNegativeSchedule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NonNegativeSchedule.subclass:
            return NonNegativeSchedule.subclass(*args_, **kwargs_)
        else:
            return NonNegativeSchedule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_initialValue(self): return self.initialValue
    def set_initialValue(self, initialValue): self.initialValue = initialValue
    def get_step(self): return self.step
    def set_step(self, step): self.step = step
    def add_step(self, value): self.step.append(value)
    def insert_step_at(self, index, value): self.step.insert(index, value)
    def replace_step_at(self, index, value): self.step[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_NonNegativeDecimal(self, value):
        # Validate type NonNegativeDecimal, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on NonNegativeDecimal' % {"value" : value} )
    def hasContent_(self):
        if (
            self.initialValue is not None or
            self.step
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NonNegativeSchedule', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NonNegativeSchedule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NonNegativeSchedule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NonNegativeSchedule'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='NonNegativeSchedule', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.initialValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinitialValue>%s</%sinitialValue>%s' % (namespace_, self.gds_format_float(self.initialValue, input_name='initialValue'), namespace_, eol_))
        for step_ in self.step:
            step_.export(outfile, level, namespace_, name_='step', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'initialValue':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'initialValue')
            self.initialValue = fval_
            # validate type NonNegativeDecimal
            self.validate_NonNegativeDecimal(self.initialValue)
        elif nodeName_ == 'step':
            obj_ = NonNegativeStep.factory()
            obj_.build(child_)
            self.step.append(obj_)
            obj_.original_tagname_ = 'step'
# end class NonNegativeSchedule


class NotionalAmount(NonNegativeMoney):
    """A complex type to specify the notional amount."""
    member_data_items_ = {
    }
    subclass = None
    superclass = NonNegativeMoney
    def __init__(self, id=None, currency=None, amount=None):
        self.original_tagname_ = None
        super(NotionalAmount, self).__init__(id, currency, amount, )
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NotionalAmount)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NotionalAmount.subclass:
            return NotionalAmount.subclass(*args_, **kwargs_)
        else:
            return NotionalAmount(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(NotionalAmount, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NotionalAmount', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NotionalAmount')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NotionalAmount', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NotionalAmount'):
        super(NotionalAmount, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NotionalAmount')
    def exportChildren(self, outfile, level, namespace_='', name_='NotionalAmount', fromsubclass_=False, pretty_print=True):
        super(NotionalAmount, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NotionalAmount, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(NotionalAmount, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class NotionalAmount


class OffsetPrevailingTime(GeneratedsSuper):
    """Allows the specification of a time that may be on a day prior or
    subsequent to the day in question. This type is intended for use
    with a day of the week (i.e. where no actual date is specified)
    as part of, for example, a period that runs from 23:00-07:00 on
    a series of days and where holidays on the actual days would
    affect the entire time period."""
    member_data_items_ = {
        'time': MemberSpec_('time', 'PrevailingTime', 0),
        'offset': MemberSpec_('offset', 'Offset', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, time=None, offset=None):
        self.original_tagname_ = None
        self.time = time
        self.offset = offset
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OffsetPrevailingTime)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OffsetPrevailingTime.subclass:
            return OffsetPrevailingTime.subclass(*args_, **kwargs_)
        else:
            return OffsetPrevailingTime(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_time(self): return self.time
    def set_time(self, time): self.time = time
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def hasContent_(self):
        if (
            self.time is not None or
            self.offset is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OffsetPrevailingTime', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OffsetPrevailingTime')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OffsetPrevailingTime', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OffsetPrevailingTime'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OffsetPrevailingTime', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.time is not None:
            self.time.export(outfile, level, namespace_, name_='time', pretty_print=pretty_print)
        if self.offset is not None:
            self.offset.export(outfile, level, namespace_, name_='offset', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'time':
            obj_ = PrevailingTime.factory()
            obj_.build(child_)
            self.time = obj_
            obj_.original_tagname_ = 'time'
        elif nodeName_ == 'offset':
            class_obj_ = self.get_class_obj_(child_, Offset)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.offset = obj_
            obj_.original_tagname_ = 'offset'
# end class OffsetPrevailingTime


class OnBehalfOf(GeneratedsSuper):
    member_data_items_ = {
        'partyReference': MemberSpec_('partyReference', 'PartyReference', 0),
        'accountReference': MemberSpec_('accountReference', 'AccountReference', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, partyReference=None, accountReference=None):
        self.original_tagname_ = None
        self.partyReference = partyReference
        if accountReference is None:
            self.accountReference = []
        else:
            self.accountReference = accountReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OnBehalfOf)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OnBehalfOf.subclass:
            return OnBehalfOf.subclass(*args_, **kwargs_)
        else:
            return OnBehalfOf(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyReference(self): return self.partyReference
    def set_partyReference(self, partyReference): self.partyReference = partyReference
    def get_accountReference(self): return self.accountReference
    def set_accountReference(self, accountReference): self.accountReference = accountReference
    def add_accountReference(self, value): self.accountReference.append(value)
    def insert_accountReference_at(self, index, value): self.accountReference.insert(index, value)
    def replace_accountReference_at(self, index, value): self.accountReference[index] = value
    def hasContent_(self):
        if (
            self.partyReference is not None or
            self.accountReference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OnBehalfOf', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OnBehalfOf')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OnBehalfOf', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OnBehalfOf'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OnBehalfOf', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.partyReference is not None:
            self.partyReference.export(outfile, level, namespace_, name_='partyReference', pretty_print=pretty_print)
        for accountReference_ in self.accountReference:
            accountReference_.export(outfile, level, namespace_, name_='accountReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'partyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.partyReference = obj_
            obj_.original_tagname_ = 'partyReference'
        elif nodeName_ == 'accountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.accountReference.append(obj_)
            obj_.original_tagname_ = 'accountReference'
# end class OnBehalfOf


class OrganizationType(GeneratedsSuper):
    """A code that describes what type of role an organization plays, for
    example a SwapsDealer, a Major Swaps Participant, or Other"""
    member_data_items_ = {
        'organizationTypeScheme': MemberSpec_('organizationTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, organizationTypeScheme='http://www.fpml.org/coding-scheme/organization-type', valueOf_=None):
        self.original_tagname_ = None
        self.organizationTypeScheme = _cast(None, organizationTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OrganizationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OrganizationType.subclass:
            return OrganizationType.subclass(*args_, **kwargs_)
        else:
            return OrganizationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_organizationTypeScheme(self): return self.organizationTypeScheme
    def set_organizationTypeScheme(self, organizationTypeScheme): self.organizationTypeScheme = organizationTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OrganizationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OrganizationType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OrganizationType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OrganizationType'):
        if self.organizationTypeScheme != "http://www.fpml.org/coding-scheme/organization-type" and 'organizationTypeScheme' not in already_processed:
            already_processed.add('organizationTypeScheme')
            outfile.write(' organizationTypeScheme=%s' % (quote_attrib(self.organizationTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OrganizationType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('organizationTypeScheme', node)
        if value is not None and 'organizationTypeScheme' not in already_processed:
            already_processed.add('organizationTypeScheme')
            self.organizationTypeScheme = value
            self.validate_NonEmptyURI(self.organizationTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OrganizationType


class OriginatingEvent(GeneratedsSuper):
    member_data_items_ = {
        'originatingEventScheme': MemberSpec_('originatingEventScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, originatingEventScheme='http://www.fpml.org/coding-scheme/originating-event', valueOf_=None):
        self.original_tagname_ = None
        self.originatingEventScheme = _cast(None, originatingEventScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OriginatingEvent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OriginatingEvent.subclass:
            return OriginatingEvent.subclass(*args_, **kwargs_)
        else:
            return OriginatingEvent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_originatingEventScheme(self): return self.originatingEventScheme
    def set_originatingEventScheme(self, originatingEventScheme): self.originatingEventScheme = originatingEventScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OriginatingEvent', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OriginatingEvent')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OriginatingEvent', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OriginatingEvent'):
        if self.originatingEventScheme != "http://www.fpml.org/coding-scheme/originating-event" and 'originatingEventScheme' not in already_processed:
            already_processed.add('originatingEventScheme')
            outfile.write(' originatingEventScheme=%s' % (quote_attrib(self.originatingEventScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OriginatingEvent', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('originatingEventScheme', node)
        if value is not None and 'originatingEventScheme' not in already_processed:
            already_processed.add('originatingEventScheme')
            self.originatingEventScheme = value
            self.validate_NonEmptyURI(self.originatingEventScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OriginatingEvent


class PartialExercise(GeneratedsSuper):
    """A type defining partial exercise. As defined in the 2000 ISDA
    Definitions, Section 12.3 Partial Exercise, the buyer of the
    option may exercise all or less than all the notional amount of
    the underlying swap but may not be less than the minimum
    notional amount (if specified) and must be an integral multiple
    of the integral multiple amount if specified."""
    member_data_items_ = {
        'notionalReference': MemberSpec_('notionalReference', 'NotionalReference', 1),
        'integralMultipleAmount': MemberSpec_('integralMultipleAmount', 'xsd:decimal', 0),
        'minimumNotionalAmount': MemberSpec_('minimumNotionalAmount', 'xsd:decimal', 0),
        'minimumNumberOfOptions': MemberSpec_('minimumNumberOfOptions', 'xsd:nonNegativeInteger', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, notionalReference=None, integralMultipleAmount=None, minimumNotionalAmount=None, minimumNumberOfOptions=None):
        self.original_tagname_ = None
        if notionalReference is None:
            self.notionalReference = []
        else:
            self.notionalReference = notionalReference
        self.integralMultipleAmount = integralMultipleAmount
        self.minimumNotionalAmount = minimumNotionalAmount
        self.minimumNumberOfOptions = minimumNumberOfOptions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartialExercise)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartialExercise.subclass:
            return PartialExercise.subclass(*args_, **kwargs_)
        else:
            return PartialExercise(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_notionalReference(self): return self.notionalReference
    def set_notionalReference(self, notionalReference): self.notionalReference = notionalReference
    def add_notionalReference(self, value): self.notionalReference.append(value)
    def insert_notionalReference_at(self, index, value): self.notionalReference.insert(index, value)
    def replace_notionalReference_at(self, index, value): self.notionalReference[index] = value
    def get_integralMultipleAmount(self): return self.integralMultipleAmount
    def set_integralMultipleAmount(self, integralMultipleAmount): self.integralMultipleAmount = integralMultipleAmount
    def get_minimumNotionalAmount(self): return self.minimumNotionalAmount
    def set_minimumNotionalAmount(self, minimumNotionalAmount): self.minimumNotionalAmount = minimumNotionalAmount
    def get_minimumNumberOfOptions(self): return self.minimumNumberOfOptions
    def set_minimumNumberOfOptions(self, minimumNumberOfOptions): self.minimumNumberOfOptions = minimumNumberOfOptions
    def hasContent_(self):
        if (
            self.notionalReference or
            self.integralMultipleAmount is not None or
            self.minimumNotionalAmount is not None or
            self.minimumNumberOfOptions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartialExercise', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartialExercise')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartialExercise', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartialExercise'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PartialExercise', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for notionalReference_ in self.notionalReference:
            notionalReference_.export(outfile, level, namespace_, name_='notionalReference', pretty_print=pretty_print)
        if self.integralMultipleAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sintegralMultipleAmount>%s</%sintegralMultipleAmount>%s' % (namespace_, self.gds_format_float(self.integralMultipleAmount, input_name='integralMultipleAmount'), namespace_, eol_))
        if self.minimumNotionalAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sminimumNotionalAmount>%s</%sminimumNotionalAmount>%s' % (namespace_, self.gds_format_float(self.minimumNotionalAmount, input_name='minimumNotionalAmount'), namespace_, eol_))
        if self.minimumNumberOfOptions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sminimumNumberOfOptions>%s</%sminimumNumberOfOptions>%s' % (namespace_, self.gds_format_integer(self.minimumNumberOfOptions, input_name='minimumNumberOfOptions'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'notionalReference':
            obj_ = NotionalReference.factory()
            obj_.build(child_)
            self.notionalReference.append(obj_)
            obj_.original_tagname_ = 'notionalReference'
        elif nodeName_ == 'integralMultipleAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'integralMultipleAmount')
            self.integralMultipleAmount = fval_
        elif nodeName_ == 'minimumNotionalAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'minimumNotionalAmount')
            self.minimumNotionalAmount = fval_
        elif nodeName_ == 'minimumNumberOfOptions':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'minimumNumberOfOptions')
            self.minimumNumberOfOptions = ival_
# end class PartialExercise


class Party(GeneratedsSuper):
    """A type defining a legal entity or a subdivision of a legal
    entity.Parties can perform multiple roles in a trade lifecycle.
    For example, the principal parties obligated to make payments
    from time to time during the term of the trade, but may include
    other parties involved in, or incidental to, the trade, such as
    parties acting in the role of novation transferor/transferee,
    broker, calculation agent, etc. In FpML roles are defined in
    multiple places within a document.A group of parties acting as a
    single party (e.g. joint and several).The id uniquely
    identifying the Party within the document."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'partyId': MemberSpec_('partyId', 'PartyId', 1),
        'partyName': MemberSpec_('partyName', 'PartyName', 0),
        'classification': MemberSpec_('classification', 'IndustryClassification', 1),
        'creditRating': MemberSpec_('creditRating', 'CreditRating', 1),
        'country': MemberSpec_('country', 'CountryCode', 0),
        'region': MemberSpec_('region', 'Region', 1),
        'jurisdiction': MemberSpec_('jurisdiction', 'GoverningLaw', 1),
        'organizationType': MemberSpec_('organizationType', 'OrganizationType', 0),
        'relatedParty': MemberSpec_('relatedParty', 'PartyRelationship', 1),
        'contactInfo': MemberSpec_('contactInfo', 'ContactInformation', 0),
        'businessUnit': MemberSpec_('businessUnit', 'BusinessUnit', 1),
        'person': MemberSpec_('person', 'Person', 1),
        'groupType': MemberSpec_('groupType', 'PartyGroupType', 0),
        'partyReference': MemberSpec_('partyReference', 'PartyReference', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, partyId=None, partyName=None, classification=None, creditRating=None, country=None, region=None, jurisdiction=None, organizationType=None, relatedParty=None, contactInfo=None, businessUnit=None, person=None, groupType=None, partyReference=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if partyId is None:
            self.partyId = []
        else:
            self.partyId = partyId
        self.partyName = partyName
        if classification is None:
            self.classification = []
        else:
            self.classification = classification
        if creditRating is None:
            self.creditRating = []
        else:
            self.creditRating = creditRating
        self.country = country
        if region is None:
            self.region = []
        else:
            self.region = region
        if jurisdiction is None:
            self.jurisdiction = []
        else:
            self.jurisdiction = jurisdiction
        self.organizationType = organizationType
        if relatedParty is None:
            self.relatedParty = []
        else:
            self.relatedParty = relatedParty
        self.contactInfo = contactInfo
        if businessUnit is None:
            self.businessUnit = []
        else:
            self.businessUnit = businessUnit
        if person is None:
            self.person = []
        else:
            self.person = person
        self.groupType = groupType
        if partyReference is None:
            self.partyReference = []
        else:
            self.partyReference = partyReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Party)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Party.subclass:
            return Party.subclass(*args_, **kwargs_)
        else:
            return Party(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyId(self): return self.partyId
    def set_partyId(self, partyId): self.partyId = partyId
    def add_partyId(self, value): self.partyId.append(value)
    def insert_partyId_at(self, index, value): self.partyId.insert(index, value)
    def replace_partyId_at(self, index, value): self.partyId[index] = value
    def get_partyName(self): return self.partyName
    def set_partyName(self, partyName): self.partyName = partyName
    def get_classification(self): return self.classification
    def set_classification(self, classification): self.classification = classification
    def add_classification(self, value): self.classification.append(value)
    def insert_classification_at(self, index, value): self.classification.insert(index, value)
    def replace_classification_at(self, index, value): self.classification[index] = value
    def get_creditRating(self): return self.creditRating
    def set_creditRating(self, creditRating): self.creditRating = creditRating
    def add_creditRating(self, value): self.creditRating.append(value)
    def insert_creditRating_at(self, index, value): self.creditRating.insert(index, value)
    def replace_creditRating_at(self, index, value): self.creditRating[index] = value
    def get_country(self): return self.country
    def set_country(self, country): self.country = country
    def get_region(self): return self.region
    def set_region(self, region): self.region = region
    def add_region(self, value): self.region.append(value)
    def insert_region_at(self, index, value): self.region.insert(index, value)
    def replace_region_at(self, index, value): self.region[index] = value
    def get_jurisdiction(self): return self.jurisdiction
    def set_jurisdiction(self, jurisdiction): self.jurisdiction = jurisdiction
    def add_jurisdiction(self, value): self.jurisdiction.append(value)
    def insert_jurisdiction_at(self, index, value): self.jurisdiction.insert(index, value)
    def replace_jurisdiction_at(self, index, value): self.jurisdiction[index] = value
    def get_organizationType(self): return self.organizationType
    def set_organizationType(self, organizationType): self.organizationType = organizationType
    def get_relatedParty(self): return self.relatedParty
    def set_relatedParty(self, relatedParty): self.relatedParty = relatedParty
    def add_relatedParty(self, value): self.relatedParty.append(value)
    def insert_relatedParty_at(self, index, value): self.relatedParty.insert(index, value)
    def replace_relatedParty_at(self, index, value): self.relatedParty[index] = value
    def get_contactInfo(self): return self.contactInfo
    def set_contactInfo(self, contactInfo): self.contactInfo = contactInfo
    def get_businessUnit(self): return self.businessUnit
    def set_businessUnit(self, businessUnit): self.businessUnit = businessUnit
    def add_businessUnit(self, value): self.businessUnit.append(value)
    def insert_businessUnit_at(self, index, value): self.businessUnit.insert(index, value)
    def replace_businessUnit_at(self, index, value): self.businessUnit[index] = value
    def get_person(self): return self.person
    def set_person(self, person): self.person = person
    def add_person(self, value): self.person.append(value)
    def insert_person_at(self, index, value): self.person.insert(index, value)
    def replace_person_at(self, index, value): self.person[index] = value
    def get_groupType(self): return self.groupType
    def set_groupType(self, groupType): self.groupType = groupType
    def get_partyReference(self): return self.partyReference
    def set_partyReference(self, partyReference): self.partyReference = partyReference
    def add_partyReference(self, value): self.partyReference.append(value)
    def insert_partyReference_at(self, index, value): self.partyReference.insert(index, value)
    def replace_partyReference_at(self, index, value): self.partyReference[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.partyId or
            self.partyName is not None or
            self.classification or
            self.creditRating or
            self.country is not None or
            self.region or
            self.jurisdiction or
            self.organizationType is not None or
            self.relatedParty or
            self.contactInfo is not None or
            self.businessUnit or
            self.person or
            self.groupType is not None or
            self.partyReference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Party', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Party')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Party', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Party'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Party', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for partyId_ in self.partyId:
            partyId_.export(outfile, level, namespace_, name_='partyId', pretty_print=pretty_print)
        if self.partyName is not None:
            self.partyName.export(outfile, level, namespace_, name_='partyName', pretty_print=pretty_print)
        for classification_ in self.classification:
            classification_.export(outfile, level, namespace_, name_='classification', pretty_print=pretty_print)
        for creditRating_ in self.creditRating:
            creditRating_.export(outfile, level, namespace_, name_='creditRating', pretty_print=pretty_print)
        if self.country is not None:
            self.country.export(outfile, level, namespace_, name_='country', pretty_print=pretty_print)
        for region_ in self.region:
            region_.export(outfile, level, namespace_, name_='region', pretty_print=pretty_print)
        for jurisdiction_ in self.jurisdiction:
            jurisdiction_.export(outfile, level, namespace_, name_='jurisdiction', pretty_print=pretty_print)
        if self.organizationType is not None:
            self.organizationType.export(outfile, level, namespace_, name_='organizationType', pretty_print=pretty_print)
        for relatedParty_ in self.relatedParty:
            relatedParty_.export(outfile, level, namespace_, name_='relatedParty', pretty_print=pretty_print)
        if self.contactInfo is not None:
            self.contactInfo.export(outfile, level, namespace_, name_='contactInfo', pretty_print=pretty_print)
        for businessUnit_ in self.businessUnit:
            businessUnit_.export(outfile, level, namespace_, name_='businessUnit', pretty_print=pretty_print)
        for person_ in self.person:
            person_.export(outfile, level, namespace_, name_='person', pretty_print=pretty_print)
        if self.groupType is not None:
            self.groupType.export(outfile, level, namespace_, name_='groupType', pretty_print=pretty_print)
        for partyReference_ in self.partyReference:
            partyReference_.export(outfile, level, namespace_, name_='partyReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'partyId':
            obj_ = PartyId.factory()
            obj_.build(child_)
            self.partyId.append(obj_)
            obj_.original_tagname_ = 'partyId'
        elif nodeName_ == 'partyName':
            obj_ = PartyName.factory()
            obj_.build(child_)
            self.partyName = obj_
            obj_.original_tagname_ = 'partyName'
        elif nodeName_ == 'classification':
            obj_ = IndustryClassification.factory()
            obj_.build(child_)
            self.classification.append(obj_)
            obj_.original_tagname_ = 'classification'
        elif nodeName_ == 'creditRating':
            obj_ = CreditRating.factory()
            obj_.build(child_)
            self.creditRating.append(obj_)
            obj_.original_tagname_ = 'creditRating'
        elif nodeName_ == 'country':
            obj_ = CountryCode.factory()
            obj_.build(child_)
            self.country = obj_
            obj_.original_tagname_ = 'country'
        elif nodeName_ == 'region':
            obj_ = Region.factory()
            obj_.build(child_)
            self.region.append(obj_)
            obj_.original_tagname_ = 'region'
        elif nodeName_ == 'jurisdiction':
            obj_ = GoverningLaw.factory()
            obj_.build(child_)
            self.jurisdiction.append(obj_)
            obj_.original_tagname_ = 'jurisdiction'
        elif nodeName_ == 'organizationType':
            obj_ = OrganizationType.factory()
            obj_.build(child_)
            self.organizationType = obj_
            obj_.original_tagname_ = 'organizationType'
        elif nodeName_ == 'relatedParty':
            obj_ = PartyRelationship.factory()
            obj_.build(child_)
            self.relatedParty.append(obj_)
            obj_.original_tagname_ = 'relatedParty'
        elif nodeName_ == 'contactInfo':
            obj_ = ContactInformation.factory()
            obj_.build(child_)
            self.contactInfo = obj_
            obj_.original_tagname_ = 'contactInfo'
        elif nodeName_ == 'businessUnit':
            obj_ = BusinessUnit.factory()
            obj_.build(child_)
            self.businessUnit.append(obj_)
            obj_.original_tagname_ = 'businessUnit'
        elif nodeName_ == 'person':
            obj_ = Person.factory()
            obj_.build(child_)
            self.person.append(obj_)
            obj_.original_tagname_ = 'person'
        elif nodeName_ == 'groupType':
            obj_ = PartyGroupType.factory()
            obj_.build(child_)
            self.groupType = obj_
            obj_.original_tagname_ = 'groupType'
        elif nodeName_ == 'partyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.partyReference.append(obj_)
            obj_.original_tagname_ = 'partyReference'
# end class Party


class PartyContactInformation(GeneratedsSuper):
    member_data_items_ = {
        'partyReference': MemberSpec_('partyReference', 'PartyReference', 0),
        'contactInfo': MemberSpec_('contactInfo', 'ContactInformation', 0),
        'businessUnit': MemberSpec_('businessUnit', 'BusinessUnit', 1),
        'person': MemberSpec_('person', 'Person', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, partyReference=None, contactInfo=None, businessUnit=None, person=None):
        self.original_tagname_ = None
        self.partyReference = partyReference
        self.contactInfo = contactInfo
        if businessUnit is None:
            self.businessUnit = []
        else:
            self.businessUnit = businessUnit
        if person is None:
            self.person = []
        else:
            self.person = person
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyContactInformation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyContactInformation.subclass:
            return PartyContactInformation.subclass(*args_, **kwargs_)
        else:
            return PartyContactInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyReference(self): return self.partyReference
    def set_partyReference(self, partyReference): self.partyReference = partyReference
    def get_contactInfo(self): return self.contactInfo
    def set_contactInfo(self, contactInfo): self.contactInfo = contactInfo
    def get_businessUnit(self): return self.businessUnit
    def set_businessUnit(self, businessUnit): self.businessUnit = businessUnit
    def add_businessUnit(self, value): self.businessUnit.append(value)
    def insert_businessUnit_at(self, index, value): self.businessUnit.insert(index, value)
    def replace_businessUnit_at(self, index, value): self.businessUnit[index] = value
    def get_person(self): return self.person
    def set_person(self, person): self.person = person
    def add_person(self, value): self.person.append(value)
    def insert_person_at(self, index, value): self.person.insert(index, value)
    def replace_person_at(self, index, value): self.person[index] = value
    def hasContent_(self):
        if (
            self.partyReference is not None or
            self.contactInfo is not None or
            self.businessUnit or
            self.person
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartyContactInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyContactInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartyContactInformation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyContactInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PartyContactInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.partyReference is not None:
            self.partyReference.export(outfile, level, namespace_, name_='partyReference', pretty_print=pretty_print)
        if self.contactInfo is not None:
            self.contactInfo.export(outfile, level, namespace_, name_='contactInfo', pretty_print=pretty_print)
        for businessUnit_ in self.businessUnit:
            businessUnit_.export(outfile, level, namespace_, name_='businessUnit', pretty_print=pretty_print)
        for person_ in self.person:
            person_.export(outfile, level, namespace_, name_='person', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'partyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.partyReference = obj_
            obj_.original_tagname_ = 'partyReference'
        elif nodeName_ == 'contactInfo':
            obj_ = ContactInformation.factory()
            obj_.build(child_)
            self.contactInfo = obj_
            obj_.original_tagname_ = 'contactInfo'
        elif nodeName_ == 'businessUnit':
            obj_ = BusinessUnit.factory()
            obj_.build(child_)
            self.businessUnit.append(obj_)
            obj_.original_tagname_ = 'businessUnit'
        elif nodeName_ == 'person':
            obj_ = Person.factory()
            obj_.build(child_)
            self.person.append(obj_)
            obj_.original_tagname_ = 'person'
# end class PartyContactInformation


class PartyGroupType(GeneratedsSuper):
    """The data type used for party group classification."""
    member_data_items_ = {
        'partyGroupTypeScheme': MemberSpec_('partyGroupTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, partyGroupTypeScheme='http://www.fpml.org/coding-scheme/party-group-type', valueOf_=None):
        self.original_tagname_ = None
        self.partyGroupTypeScheme = _cast(None, partyGroupTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyGroupType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyGroupType.subclass:
            return PartyGroupType.subclass(*args_, **kwargs_)
        else:
            return PartyGroupType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyGroupTypeScheme(self): return self.partyGroupTypeScheme
    def set_partyGroupTypeScheme(self, partyGroupTypeScheme): self.partyGroupTypeScheme = partyGroupTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartyGroupType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyGroupType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartyGroupType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyGroupType'):
        if self.partyGroupTypeScheme != "http://www.fpml.org/coding-scheme/party-group-type" and 'partyGroupTypeScheme' not in already_processed:
            already_processed.add('partyGroupTypeScheme')
            outfile.write(' partyGroupTypeScheme=%s' % (quote_attrib(self.partyGroupTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PartyGroupType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partyGroupTypeScheme', node)
        if value is not None and 'partyGroupTypeScheme' not in already_processed:
            already_processed.add('partyGroupTypeScheme')
            self.partyGroupTypeScheme = value
            self.validate_NonEmptyURI(self.partyGroupTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PartyGroupType


class PartyId(GeneratedsSuper):
    """The data type used for party identifiers."""
    member_data_items_ = {
        'partyIdScheme': MemberSpec_('partyIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, partyIdScheme='http://www.fpml.org/coding-scheme/external/iso9362', valueOf_=None):
        self.original_tagname_ = None
        self.partyIdScheme = _cast(None, partyIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyId.subclass:
            return PartyId.subclass(*args_, **kwargs_)
        else:
            return PartyId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyIdScheme(self): return self.partyIdScheme
    def set_partyIdScheme(self, partyIdScheme): self.partyIdScheme = partyIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartyId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartyId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyId'):
        if self.partyIdScheme != "http://www.fpml.org/coding-scheme/external/iso9362" and 'partyIdScheme' not in already_processed:
            already_processed.add('partyIdScheme')
            outfile.write(' partyIdScheme=%s' % (quote_attrib(self.partyIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PartyId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partyIdScheme', node)
        if value is not None and 'partyIdScheme' not in already_processed:
            already_processed.add('partyIdScheme')
            self.partyIdScheme = value
            self.validate_NonEmptyURI(self.partyIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PartyId


class PartyName(GeneratedsSuper):
    """The data type used for the legal name of an organization."""
    member_data_items_ = {
        'partyNameScheme': MemberSpec_('partyNameScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, partyNameScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.partyNameScheme = _cast(None, partyNameScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyName)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyName.subclass:
            return PartyName.subclass(*args_, **kwargs_)
        else:
            return PartyName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyNameScheme(self): return self.partyNameScheme
    def set_partyNameScheme(self, partyNameScheme): self.partyNameScheme = partyNameScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartyName', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyName')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartyName', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyName'):
        if self.partyNameScheme is not None and 'partyNameScheme' not in already_processed:
            already_processed.add('partyNameScheme')
            outfile.write(' partyNameScheme=%s' % (quote_attrib(self.partyNameScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PartyName', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partyNameScheme', node)
        if value is not None and 'partyNameScheme' not in already_processed:
            already_processed.add('partyNameScheme')
            self.partyNameScheme = value
            self.validate_NonEmptyURI(self.partyNameScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PartyName


class PartyRelationship(GeneratedsSuper):
    member_data_items_ = {
        'partyReference': MemberSpec_('partyReference', 'PartyReference', 0),
        'accountReference': MemberSpec_('accountReference', 'AccountReference', 0),
        'role': MemberSpec_('role', 'PartyRole', 0),
        'type_': MemberSpec_('type_', 'PartyRoleType', 0),
        'effectiveDate': MemberSpec_('effectiveDate', 'xsd:date', 0),
        'terminationDate': MemberSpec_('terminationDate', 'xsd:date', 0),
        'documentation': MemberSpec_('documentation', 'PartyRelationshipDocumentation', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, partyReference=None, accountReference=None, role=None, type_=None, effectiveDate=None, terminationDate=None, documentation=None):
        self.original_tagname_ = None
        self.partyReference = partyReference
        self.accountReference = accountReference
        self.role = role
        self.type_ = type_
        if isinstance(effectiveDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(effectiveDate, '%Y-%m-%d').date()
        else:
            initvalue_ = effectiveDate
        self.effectiveDate = initvalue_
        if isinstance(terminationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(terminationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = terminationDate
        self.terminationDate = initvalue_
        self.documentation = documentation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyRelationship)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyRelationship.subclass:
            return PartyRelationship.subclass(*args_, **kwargs_)
        else:
            return PartyRelationship(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyReference(self): return self.partyReference
    def set_partyReference(self, partyReference): self.partyReference = partyReference
    def get_accountReference(self): return self.accountReference
    def set_accountReference(self, accountReference): self.accountReference = accountReference
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_effectiveDate(self): return self.effectiveDate
    def set_effectiveDate(self, effectiveDate): self.effectiveDate = effectiveDate
    def get_terminationDate(self): return self.terminationDate
    def set_terminationDate(self, terminationDate): self.terminationDate = terminationDate
    def get_documentation(self): return self.documentation
    def set_documentation(self, documentation): self.documentation = documentation
    def hasContent_(self):
        if (
            self.partyReference is not None or
            self.accountReference is not None or
            self.role is not None or
            self.type_ is not None or
            self.effectiveDate is not None or
            self.terminationDate is not None or
            self.documentation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartyRelationship', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyRelationship')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartyRelationship', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyRelationship'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PartyRelationship', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.partyReference is not None:
            self.partyReference.export(outfile, level, namespace_, name_='partyReference', pretty_print=pretty_print)
        if self.accountReference is not None:
            self.accountReference.export(outfile, level, namespace_, name_='accountReference', pretty_print=pretty_print)
        if self.role is not None:
            self.role.export(outfile, level, namespace_, name_='role', pretty_print=pretty_print)
        if self.type_ is not None:
            self.type_.export(outfile, level, namespace_, name_='type', pretty_print=pretty_print)
        if self.effectiveDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%seffectiveDate>%s</%seffectiveDate>%s' % (namespace_, self.gds_format_date(self.effectiveDate, input_name='effectiveDate'), namespace_, eol_))
        if self.terminationDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sterminationDate>%s</%sterminationDate>%s' % (namespace_, self.gds_format_date(self.terminationDate, input_name='terminationDate'), namespace_, eol_))
        if self.documentation is not None:
            self.documentation.export(outfile, level, namespace_, name_='documentation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'partyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.partyReference = obj_
            obj_.original_tagname_ = 'partyReference'
        elif nodeName_ == 'accountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.accountReference = obj_
            obj_.original_tagname_ = 'accountReference'
        elif nodeName_ == 'role':
            obj_ = PartyRole.factory()
            obj_.build(child_)
            self.role = obj_
            obj_.original_tagname_ = 'role'
        elif nodeName_ == 'type':
            obj_ = PartyRoleType.factory()
            obj_.build(child_)
            self.type_ = obj_
            obj_.original_tagname_ = 'type'
        elif nodeName_ == 'effectiveDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.effectiveDate = dval_
        elif nodeName_ == 'terminationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.terminationDate = dval_
        elif nodeName_ == 'documentation':
            obj_ = PartyRelationshipDocumentation.factory()
            obj_.build(child_)
            self.documentation = obj_
            obj_.original_tagname_ = 'documentation'
# end class PartyRelationship


class PartyRelationshipDocumentation(GeneratedsSuper):
    """A description of the legal agreement(s) and definitions that
    document a party's relationships with other parties"""
    member_data_items_ = {
        'masterAgreement': MemberSpec_('masterAgreement', 'MasterAgreement', 1),
        'creditSupportAgreement': MemberSpec_('creditSupportAgreement', 'CreditSupportAgreement', 1),
        'agreement': MemberSpec_('agreement', 'GenericAgreement', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, masterAgreement=None, creditSupportAgreement=None, agreement=None):
        self.original_tagname_ = None
        if masterAgreement is None:
            self.masterAgreement = []
        else:
            self.masterAgreement = masterAgreement
        if creditSupportAgreement is None:
            self.creditSupportAgreement = []
        else:
            self.creditSupportAgreement = creditSupportAgreement
        if agreement is None:
            self.agreement = []
        else:
            self.agreement = agreement
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyRelationshipDocumentation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyRelationshipDocumentation.subclass:
            return PartyRelationshipDocumentation.subclass(*args_, **kwargs_)
        else:
            return PartyRelationshipDocumentation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_masterAgreement(self): return self.masterAgreement
    def set_masterAgreement(self, masterAgreement): self.masterAgreement = masterAgreement
    def add_masterAgreement(self, value): self.masterAgreement.append(value)
    def insert_masterAgreement_at(self, index, value): self.masterAgreement.insert(index, value)
    def replace_masterAgreement_at(self, index, value): self.masterAgreement[index] = value
    def get_creditSupportAgreement(self): return self.creditSupportAgreement
    def set_creditSupportAgreement(self, creditSupportAgreement): self.creditSupportAgreement = creditSupportAgreement
    def add_creditSupportAgreement(self, value): self.creditSupportAgreement.append(value)
    def insert_creditSupportAgreement_at(self, index, value): self.creditSupportAgreement.insert(index, value)
    def replace_creditSupportAgreement_at(self, index, value): self.creditSupportAgreement[index] = value
    def get_agreement(self): return self.agreement
    def set_agreement(self, agreement): self.agreement = agreement
    def add_agreement(self, value): self.agreement.append(value)
    def insert_agreement_at(self, index, value): self.agreement.insert(index, value)
    def replace_agreement_at(self, index, value): self.agreement[index] = value
    def hasContent_(self):
        if (
            self.masterAgreement or
            self.creditSupportAgreement or
            self.agreement
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartyRelationshipDocumentation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyRelationshipDocumentation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartyRelationshipDocumentation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyRelationshipDocumentation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PartyRelationshipDocumentation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for masterAgreement_ in self.masterAgreement:
            masterAgreement_.export(outfile, level, namespace_, name_='masterAgreement', pretty_print=pretty_print)
        for creditSupportAgreement_ in self.creditSupportAgreement:
            creditSupportAgreement_.export(outfile, level, namespace_, name_='creditSupportAgreement', pretty_print=pretty_print)
        for agreement_ in self.agreement:
            agreement_.export(outfile, level, namespace_, name_='agreement', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'masterAgreement':
            obj_ = MasterAgreement.factory()
            obj_.build(child_)
            self.masterAgreement.append(obj_)
            obj_.original_tagname_ = 'masterAgreement'
        elif nodeName_ == 'creditSupportAgreement':
            obj_ = CreditSupportAgreement.factory()
            obj_.build(child_)
            self.creditSupportAgreement.append(obj_)
            obj_.original_tagname_ = 'creditSupportAgreement'
        elif nodeName_ == 'agreement':
            obj_ = GenericAgreement.factory()
            obj_.build(child_)
            self.agreement.append(obj_)
            obj_.original_tagname_ = 'agreement'
# end class PartyRelationshipDocumentation


class PartyRole(GeneratedsSuper):
    """A type describing a role played by a party in one or more
    transactions. Examples include roles such as guarantor,
    custodian, confirmation service provider, etc. This can be
    extended to provide custom roles."""
    member_data_items_ = {
        'partyRoleScheme': MemberSpec_('partyRoleScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, partyRoleScheme='http://www.fpml.org/coding-scheme/party-role', valueOf_=None):
        self.original_tagname_ = None
        self.partyRoleScheme = _cast(None, partyRoleScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyRole)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyRole.subclass:
            return PartyRole.subclass(*args_, **kwargs_)
        else:
            return PartyRole(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyRoleScheme(self): return self.partyRoleScheme
    def set_partyRoleScheme(self, partyRoleScheme): self.partyRoleScheme = partyRoleScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartyRole', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyRole')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartyRole', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyRole'):
        if self.partyRoleScheme != "http://www.fpml.org/coding-scheme/party-role" and 'partyRoleScheme' not in already_processed:
            already_processed.add('partyRoleScheme')
            outfile.write(' partyRoleScheme=%s' % (quote_attrib(self.partyRoleScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PartyRole', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partyRoleScheme', node)
        if value is not None and 'partyRoleScheme' not in already_processed:
            already_processed.add('partyRoleScheme')
            self.partyRoleScheme = value
            self.validate_NonEmptyURI(self.partyRoleScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PartyRole


class PartyRoleType(GeneratedsSuper):
    """A type refining the role a role played by a party in one or more
    transactions. Examples include "AllPositions" and
    "SomePositions" for Guarantor. This can be extended to provide
    custom types."""
    member_data_items_ = {
        'partyRoleTypeScheme': MemberSpec_('partyRoleTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, partyRoleTypeScheme='http://www.fpml.org/coding-scheme/party-role-type', valueOf_=None):
        self.original_tagname_ = None
        self.partyRoleTypeScheme = _cast(None, partyRoleTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyRoleType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyRoleType.subclass:
            return PartyRoleType.subclass(*args_, **kwargs_)
        else:
            return PartyRoleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyRoleTypeScheme(self): return self.partyRoleTypeScheme
    def set_partyRoleTypeScheme(self, partyRoleTypeScheme): self.partyRoleTypeScheme = partyRoleTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartyRoleType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyRoleType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartyRoleType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyRoleType'):
        if self.partyRoleTypeScheme != "http://www.fpml.org/coding-scheme/party-role-type" and 'partyRoleTypeScheme' not in already_processed:
            already_processed.add('partyRoleTypeScheme')
            outfile.write(' partyRoleTypeScheme=%s' % (quote_attrib(self.partyRoleTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PartyRoleType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partyRoleTypeScheme', node)
        if value is not None and 'partyRoleTypeScheme' not in already_processed:
            already_processed.add('partyRoleTypeScheme')
            self.partyRoleTypeScheme = value
            self.validate_NonEmptyURI(self.partyRoleTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PartyRoleType


class PaymentBase(GeneratedsSuper):
    """An abstract base class for payment types."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PaymentBase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PaymentBase.subclass:
            return PaymentBase.subclass(*args_, **kwargs_)
        else:
            return PaymentBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PaymentBase', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentBase')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PaymentBase', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PaymentBase'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='PaymentBase', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PaymentBase


class PaymentBaseExtended(PaymentBase):
    """Base type for payments."""
    member_data_items_ = {
        'payerPartyReference': MemberSpec_('payerPartyReference', 'PartyReference', 0),
        'payerAccountReference': MemberSpec_('payerAccountReference', 'AccountReference', 0),
        'receiverPartyReference': MemberSpec_('receiverPartyReference', 'PartyReference', 0),
        'receiverAccountReference': MemberSpec_('receiverAccountReference', 'AccountReference', 0),
        'paymentDate': MemberSpec_('paymentDate', 'AdjustableOrRelativeDate', 0),
    }
    subclass = None
    superclass = PaymentBase
    def __init__(self, id=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, paymentDate=None, extensiontype_=None):
        self.original_tagname_ = None
        super(PaymentBaseExtended, self).__init__(id, extensiontype_, )
        self.payerPartyReference = payerPartyReference
        self.payerAccountReference = payerAccountReference
        self.receiverPartyReference = receiverPartyReference
        self.receiverAccountReference = receiverAccountReference
        self.paymentDate = paymentDate
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PaymentBaseExtended)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PaymentBaseExtended.subclass:
            return PaymentBaseExtended.subclass(*args_, **kwargs_)
        else:
            return PaymentBaseExtended(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_payerPartyReference(self): return self.payerPartyReference
    def set_payerPartyReference(self, payerPartyReference): self.payerPartyReference = payerPartyReference
    def get_payerAccountReference(self): return self.payerAccountReference
    def set_payerAccountReference(self, payerAccountReference): self.payerAccountReference = payerAccountReference
    def get_receiverPartyReference(self): return self.receiverPartyReference
    def set_receiverPartyReference(self, receiverPartyReference): self.receiverPartyReference = receiverPartyReference
    def get_receiverAccountReference(self): return self.receiverAccountReference
    def set_receiverAccountReference(self, receiverAccountReference): self.receiverAccountReference = receiverAccountReference
    def get_paymentDate(self): return self.paymentDate
    def set_paymentDate(self, paymentDate): self.paymentDate = paymentDate
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.payerPartyReference is not None or
            self.payerAccountReference is not None or
            self.receiverPartyReference is not None or
            self.receiverAccountReference is not None or
            self.paymentDate is not None or
            super(PaymentBaseExtended, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PaymentBaseExtended', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentBaseExtended')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PaymentBaseExtended', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PaymentBaseExtended'):
        super(PaymentBaseExtended, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentBaseExtended')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='PaymentBaseExtended', fromsubclass_=False, pretty_print=True):
        super(PaymentBaseExtended, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.payerPartyReference is not None:
            self.payerPartyReference.export(outfile, level, namespace_, name_='payerPartyReference', pretty_print=pretty_print)
        if self.payerAccountReference is not None:
            self.payerAccountReference.export(outfile, level, namespace_, name_='payerAccountReference', pretty_print=pretty_print)
        if self.receiverPartyReference is not None:
            self.receiverPartyReference.export(outfile, level, namespace_, name_='receiverPartyReference', pretty_print=pretty_print)
        if self.receiverAccountReference is not None:
            self.receiverAccountReference.export(outfile, level, namespace_, name_='receiverAccountReference', pretty_print=pretty_print)
        if self.paymentDate is not None:
            self.paymentDate.export(outfile, level, namespace_, name_='paymentDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(PaymentBaseExtended, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'payerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.payerPartyReference = obj_
            obj_.original_tagname_ = 'payerPartyReference'
        elif nodeName_ == 'payerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.payerAccountReference = obj_
            obj_.original_tagname_ = 'payerAccountReference'
        elif nodeName_ == 'receiverPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.receiverPartyReference = obj_
            obj_.original_tagname_ = 'receiverPartyReference'
        elif nodeName_ == 'receiverAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.receiverAccountReference = obj_
            obj_.original_tagname_ = 'receiverAccountReference'
        elif nodeName_ == 'paymentDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.paymentDate = obj_
            obj_.original_tagname_ = 'paymentDate'
        super(PaymentBaseExtended, self).buildChildren(child_, node, nodeName_, True)
# end class PaymentBaseExtended


class PaymentDetail(PaymentBase):
    member_data_items_ = {
        'paymentDate': MemberSpec_('paymentDate', 'AdjustableOrRelativeDate', 0),
        'paymentAmount': MemberSpec_('paymentAmount', 'Money', 0),
        'paymentRule': MemberSpec_('paymentRule', 'PaymentRule', 0),
        'paymentAmount': MemberSpec_('paymentAmount', 'Money', 0),
    }
    subclass = None
    superclass = PaymentBase
    def __init__(self, id=None, paymentDate=None, paymentAmount=None, paymentRule=None):
        self.original_tagname_ = None
        super(PaymentDetail, self).__init__(id, )
        self.paymentDate = paymentDate
        self.paymentAmount = paymentAmount
        self.paymentRule = paymentRule
        self.paymentAmount = paymentAmount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PaymentDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PaymentDetail.subclass:
            return PaymentDetail.subclass(*args_, **kwargs_)
        else:
            return PaymentDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_paymentDate(self): return self.paymentDate
    def set_paymentDate(self, paymentDate): self.paymentDate = paymentDate
    def get_paymentAmount(self): return self.paymentAmount
    def set_paymentAmount(self, paymentAmount): self.paymentAmount = paymentAmount
    def get_paymentRule(self): return self.paymentRule
    def set_paymentRule(self, paymentRule): self.paymentRule = paymentRule
    def get_paymentAmount(self): return self.paymentAmount
    def set_paymentAmount(self, paymentAmount): self.paymentAmount = paymentAmount
    def hasContent_(self):
        if (
            self.paymentDate is not None or
            self.paymentAmount is not None or
            self.paymentRule is not None or
            self.paymentAmount is not None or
            super(PaymentDetail, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PaymentDetail', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PaymentDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PaymentDetail'):
        super(PaymentDetail, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentDetail')
    def exportChildren(self, outfile, level, namespace_='', name_='PaymentDetail', fromsubclass_=False, pretty_print=True):
        super(PaymentDetail, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.paymentDate is not None:
            self.paymentDate.export(outfile, level, namespace_, name_='paymentDate', pretty_print=pretty_print)
        if self.paymentAmount is not None:
            self.paymentAmount.export(outfile, level, namespace_, name_='paymentAmount', pretty_print=pretty_print)
        if self.paymentRule is not None:
            self.paymentRule.export(outfile, level, namespace_, name_='paymentRule', pretty_print=pretty_print)
        if self.paymentAmount is not None:
            self.paymentAmount.export(outfile, level, namespace_, name_='paymentAmount', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PaymentDetail, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'paymentDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.paymentDate = obj_
            obj_.original_tagname_ = 'paymentDate'
        elif nodeName_ == 'paymentAmount':
            obj_ = Money.factory()
            obj_.build(child_)
            self.paymentAmount = obj_
            obj_.original_tagname_ = 'paymentAmount'
        elif nodeName_ == 'paymentRule':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <paymentRule> element')
            self.paymentRule = obj_
            obj_.original_tagname_ = 'paymentRule'
        elif nodeName_ == 'paymentAmount':
            obj_ = Money.factory()
            obj_.build(child_)
            self.paymentAmount = obj_
            obj_.original_tagname_ = 'paymentAmount'
        super(PaymentDetail, self).buildChildren(child_, node, nodeName_, True)
# end class PaymentDetail


class PaymentDetails(GeneratedsSuper):
    """Details on the referenced payment. e.g. Its cashflow components,
    settlement details."""
    member_data_items_ = {
        'paymentReference': MemberSpec_('paymentReference', 'PaymentReference', 0),
        'grossCashflow': MemberSpec_('grossCashflow', 'GrossCashflow', 1),
        'settlementInformation': MemberSpec_('settlementInformation', 'SettlementInformation', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, paymentReference=None, grossCashflow=None, settlementInformation=None):
        self.original_tagname_ = None
        self.paymentReference = paymentReference
        if grossCashflow is None:
            self.grossCashflow = []
        else:
            self.grossCashflow = grossCashflow
        self.settlementInformation = settlementInformation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PaymentDetails)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PaymentDetails.subclass:
            return PaymentDetails.subclass(*args_, **kwargs_)
        else:
            return PaymentDetails(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_paymentReference(self): return self.paymentReference
    def set_paymentReference(self, paymentReference): self.paymentReference = paymentReference
    def get_grossCashflow(self): return self.grossCashflow
    def set_grossCashflow(self, grossCashflow): self.grossCashflow = grossCashflow
    def add_grossCashflow(self, value): self.grossCashflow.append(value)
    def insert_grossCashflow_at(self, index, value): self.grossCashflow.insert(index, value)
    def replace_grossCashflow_at(self, index, value): self.grossCashflow[index] = value
    def get_settlementInformation(self): return self.settlementInformation
    def set_settlementInformation(self, settlementInformation): self.settlementInformation = settlementInformation
    def hasContent_(self):
        if (
            self.paymentReference is not None or
            self.grossCashflow or
            self.settlementInformation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PaymentDetails', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentDetails')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PaymentDetails', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PaymentDetails'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PaymentDetails', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.paymentReference is not None:
            self.paymentReference.export(outfile, level, namespace_, name_='paymentReference', pretty_print=pretty_print)
        for grossCashflow_ in self.grossCashflow:
            grossCashflow_.export(outfile, level, namespace_, name_='grossCashflow', pretty_print=pretty_print)
        if self.settlementInformation is not None:
            self.settlementInformation.export(outfile, level, namespace_, name_='settlementInformation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'paymentReference':
            obj_ = PaymentReference.factory()
            obj_.build(child_)
            self.paymentReference = obj_
            obj_.original_tagname_ = 'paymentReference'
        elif nodeName_ == 'grossCashflow':
            obj_ = GrossCashflow.factory()
            obj_.build(child_)
            self.grossCashflow.append(obj_)
            obj_.original_tagname_ = 'grossCashflow'
        elif nodeName_ == 'settlementInformation':
            obj_ = SettlementInformation.factory()
            obj_.build(child_)
            self.settlementInformation = obj_
            obj_.original_tagname_ = 'settlementInformation'
# end class PaymentDetails


class PaymentId(GeneratedsSuper):
    """An identifier used to identify a matchable payment."""
    member_data_items_ = {
        'paymentIdScheme': MemberSpec_('paymentIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, paymentIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.paymentIdScheme = _cast(None, paymentIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PaymentId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PaymentId.subclass:
            return PaymentId.subclass(*args_, **kwargs_)
        else:
            return PaymentId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_paymentIdScheme(self): return self.paymentIdScheme
    def set_paymentIdScheme(self, paymentIdScheme): self.paymentIdScheme = paymentIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PaymentId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PaymentId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PaymentId'):
        if self.paymentIdScheme is not None and 'paymentIdScheme' not in already_processed:
            already_processed.add('paymentIdScheme')
            outfile.write(' paymentIdScheme=%s' % (quote_attrib(self.paymentIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PaymentId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('paymentIdScheme', node)
        if value is not None and 'paymentIdScheme' not in already_processed:
            already_processed.add('paymentIdScheme')
            self.paymentIdScheme = value
            self.validate_NonEmptyURI(self.paymentIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PaymentId


class PaymentRule(GeneratedsSuper):
    """The abstract base type from which all calculation rules of the
    independent amount must be derived."""
    member_data_items_ = {
    }
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PaymentRule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PaymentRule.subclass:
            return PaymentRule.subclass(*args_, **kwargs_)
        else:
            return PaymentRule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PaymentRule', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentRule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PaymentRule', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PaymentRule'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PaymentRule', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PaymentRule


class PaymentType(GeneratedsSuper):
    member_data_items_ = {
        'paymentTypeScheme': MemberSpec_('paymentTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, paymentTypeScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.paymentTypeScheme = _cast(None, paymentTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PaymentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PaymentType.subclass:
            return PaymentType.subclass(*args_, **kwargs_)
        else:
            return PaymentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_paymentTypeScheme(self): return self.paymentTypeScheme
    def set_paymentTypeScheme(self, paymentTypeScheme): self.paymentTypeScheme = paymentTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PaymentType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PaymentType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PaymentType'):
        if self.paymentTypeScheme is not None and 'paymentTypeScheme' not in already_processed:
            already_processed.add('paymentTypeScheme')
            outfile.write(' paymentTypeScheme=%s' % (quote_attrib(self.paymentTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PaymentType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('paymentTypeScheme', node)
        if value is not None and 'paymentTypeScheme' not in already_processed:
            already_processed.add('paymentTypeScheme')
            self.paymentTypeScheme = value
            self.validate_NonEmptyURI(self.paymentTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PaymentType


class Period(GeneratedsSuper):
    """A type to define recurring periods or time offsets."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'periodMultiplier': MemberSpec_('periodMultiplier', 'xsd:integer', 0),
        'period': MemberSpec_('period', ['PeriodEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, periodMultiplier=None, period=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.periodMultiplier = periodMultiplier
        self.period = period
        self.validate_PeriodEnum(self.period)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Period)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Period.subclass:
            return Period.subclass(*args_, **kwargs_)
        else:
            return Period(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_periodMultiplier(self): return self.periodMultiplier
    def set_periodMultiplier(self, periodMultiplier): self.periodMultiplier = periodMultiplier
    def get_period(self): return self.period
    def set_period(self, period): self.period = period
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_PeriodEnum(self, value):
        # Validate type PeriodEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['D', 'W', 'M', 'Y']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PeriodEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on PeriodEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.periodMultiplier is not None or
            self.period is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Period', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Period')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Period', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Period'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Period', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.periodMultiplier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%speriodMultiplier>%s</%speriodMultiplier>%s' % (namespace_, self.gds_format_integer(self.periodMultiplier, input_name='periodMultiplier'), namespace_, eol_))
        if self.period is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%speriod>%s</%speriod>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.period), input_name='period')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'periodMultiplier':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'periodMultiplier')
            self.periodMultiplier = ival_
        elif nodeName_ == 'period':
            period_ = child_.text
            period_ = re_.sub(String_cleanup_pat_, " ", period_).strip()
            period_ = self.gds_validate_string(period_, node, 'period')
            self.period = period_
            # validate type PeriodEnum
            self.validate_PeriodEnum(self.period)
# end class Period


class PeriodicDates(GeneratedsSuper):
    member_data_items_ = {
        'calculationStartDate': MemberSpec_('calculationStartDate', 'AdjustableOrRelativeDate', 0),
        'calculationEndDate': MemberSpec_('calculationEndDate', 'AdjustableOrRelativeDate', 0),
        'calculationPeriodFrequency': MemberSpec_('calculationPeriodFrequency', 'CalculationPeriodFrequency', 0),
        'calculationPeriodDatesAdjustments': MemberSpec_('calculationPeriodDatesAdjustments', 'BusinessDayAdjustments', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, calculationStartDate=None, calculationEndDate=None, calculationPeriodFrequency=None, calculationPeriodDatesAdjustments=None):
        self.original_tagname_ = None
        self.calculationStartDate = calculationStartDate
        self.calculationEndDate = calculationEndDate
        self.calculationPeriodFrequency = calculationPeriodFrequency
        self.calculationPeriodDatesAdjustments = calculationPeriodDatesAdjustments
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PeriodicDates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PeriodicDates.subclass:
            return PeriodicDates.subclass(*args_, **kwargs_)
        else:
            return PeriodicDates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_calculationStartDate(self): return self.calculationStartDate
    def set_calculationStartDate(self, calculationStartDate): self.calculationStartDate = calculationStartDate
    def get_calculationEndDate(self): return self.calculationEndDate
    def set_calculationEndDate(self, calculationEndDate): self.calculationEndDate = calculationEndDate
    def get_calculationPeriodFrequency(self): return self.calculationPeriodFrequency
    def set_calculationPeriodFrequency(self, calculationPeriodFrequency): self.calculationPeriodFrequency = calculationPeriodFrequency
    def get_calculationPeriodDatesAdjustments(self): return self.calculationPeriodDatesAdjustments
    def set_calculationPeriodDatesAdjustments(self, calculationPeriodDatesAdjustments): self.calculationPeriodDatesAdjustments = calculationPeriodDatesAdjustments
    def hasContent_(self):
        if (
            self.calculationStartDate is not None or
            self.calculationEndDate is not None or
            self.calculationPeriodFrequency is not None or
            self.calculationPeriodDatesAdjustments is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PeriodicDates', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PeriodicDates')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PeriodicDates', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PeriodicDates'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PeriodicDates', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.calculationStartDate is not None:
            self.calculationStartDate.export(outfile, level, namespace_, name_='calculationStartDate', pretty_print=pretty_print)
        if self.calculationEndDate is not None:
            self.calculationEndDate.export(outfile, level, namespace_, name_='calculationEndDate', pretty_print=pretty_print)
        if self.calculationPeriodFrequency is not None:
            self.calculationPeriodFrequency.export(outfile, level, namespace_, name_='calculationPeriodFrequency', pretty_print=pretty_print)
        if self.calculationPeriodDatesAdjustments is not None:
            self.calculationPeriodDatesAdjustments.export(outfile, level, namespace_, name_='calculationPeriodDatesAdjustments', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'calculationStartDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.calculationStartDate = obj_
            obj_.original_tagname_ = 'calculationStartDate'
        elif nodeName_ == 'calculationEndDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.calculationEndDate = obj_
            obj_.original_tagname_ = 'calculationEndDate'
        elif nodeName_ == 'calculationPeriodFrequency':
            obj_ = CalculationPeriodFrequency.factory()
            obj_.build(child_)
            self.calculationPeriodFrequency = obj_
            obj_.original_tagname_ = 'calculationPeriodFrequency'
        elif nodeName_ == 'calculationPeriodDatesAdjustments':
            obj_ = BusinessDayAdjustments.factory()
            obj_.build(child_)
            self.calculationPeriodDatesAdjustments = obj_
            obj_.original_tagname_ = 'calculationPeriodDatesAdjustments'
# end class PeriodicDates


class Person(GeneratedsSuper):
    """A type that represents information about a person connected with a
    trade or business process."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'honorific': MemberSpec_('honorific', ['NormalizedString', 'xsd:normalizedString'], 0),
        'firstName': MemberSpec_('firstName', ['NormalizedString', 'xsd:normalizedString'], 0),
        'middleName': MemberSpec_('middleName', ['NormalizedString', 'xsd:normalizedString'], 1),
        'initial': MemberSpec_('initial', ['Initial', 'xsd:normalizedString'], 1),
        'surname': MemberSpec_('surname', ['NormalizedString', 'xsd:normalizedString'], 0),
        'suffix': MemberSpec_('suffix', ['NormalizedString', 'xsd:normalizedString'], 0),
        'personId': MemberSpec_('personId', 'PersonId', 1),
        'businessUnitReference': MemberSpec_('businessUnitReference', 'BusinessUnitReference', 0),
        'contactInfo': MemberSpec_('contactInfo', 'ContactInformation', 0),
        'dateOfBirth': MemberSpec_('dateOfBirth', 'xsd:date', 0),
        'country': MemberSpec_('country', 'CountryCode', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, honorific=None, firstName=None, middleName=None, initial=None, surname=None, suffix=None, personId=None, businessUnitReference=None, contactInfo=None, dateOfBirth=None, country=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.honorific = honorific
        self.validate_NormalizedString(self.honorific)
        self.firstName = firstName
        self.validate_NormalizedString(self.firstName)
        if middleName is None:
            self.middleName = []
        else:
            self.middleName = middleName
        if initial is None:
            self.initial = []
        else:
            self.initial = initial
        self.surname = surname
        self.validate_NormalizedString(self.surname)
        self.suffix = suffix
        self.validate_NormalizedString(self.suffix)
        if personId is None:
            self.personId = []
        else:
            self.personId = personId
        self.businessUnitReference = businessUnitReference
        self.contactInfo = contactInfo
        if isinstance(dateOfBirth, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(dateOfBirth, '%Y-%m-%d').date()
        else:
            initvalue_ = dateOfBirth
        self.dateOfBirth = initvalue_
        self.country = country
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Person)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Person.subclass:
            return Person.subclass(*args_, **kwargs_)
        else:
            return Person(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_honorific(self): return self.honorific
    def set_honorific(self, honorific): self.honorific = honorific
    def get_firstName(self): return self.firstName
    def set_firstName(self, firstName): self.firstName = firstName
    def get_middleName(self): return self.middleName
    def set_middleName(self, middleName): self.middleName = middleName
    def add_middleName(self, value): self.middleName.append(value)
    def insert_middleName_at(self, index, value): self.middleName.insert(index, value)
    def replace_middleName_at(self, index, value): self.middleName[index] = value
    def get_initial(self): return self.initial
    def set_initial(self, initial): self.initial = initial
    def add_initial(self, value): self.initial.append(value)
    def insert_initial_at(self, index, value): self.initial.insert(index, value)
    def replace_initial_at(self, index, value): self.initial[index] = value
    def get_surname(self): return self.surname
    def set_surname(self, surname): self.surname = surname
    def get_suffix(self): return self.suffix
    def set_suffix(self, suffix): self.suffix = suffix
    def get_personId(self): return self.personId
    def set_personId(self, personId): self.personId = personId
    def add_personId(self, value): self.personId.append(value)
    def insert_personId_at(self, index, value): self.personId.insert(index, value)
    def replace_personId_at(self, index, value): self.personId[index] = value
    def get_businessUnitReference(self): return self.businessUnitReference
    def set_businessUnitReference(self, businessUnitReference): self.businessUnitReference = businessUnitReference
    def get_contactInfo(self): return self.contactInfo
    def set_contactInfo(self, contactInfo): self.contactInfo = contactInfo
    def get_dateOfBirth(self): return self.dateOfBirth
    def set_dateOfBirth(self, dateOfBirth): self.dateOfBirth = dateOfBirth
    def get_country(self): return self.country
    def set_country(self, country): self.country = country
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_NormalizedString(self, value):
        # Validate type NormalizedString, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NormalizedString' % {"value" : value} )
    def validate_Initial(self, value):
        # Validate type Initial, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on Initial' % {"value" : value} )
    def hasContent_(self):
        if (
            self.honorific is not None or
            self.firstName is not None or
            self.middleName or
            self.initial or
            self.surname is not None or
            self.suffix is not None or
            self.personId or
            self.businessUnitReference is not None or
            self.contactInfo is not None or
            self.dateOfBirth is not None or
            self.country is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Person', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Person')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Person', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Person'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Person', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.honorific is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shonorific>%s</%shonorific>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.honorific), input_name='honorific')), namespace_, eol_))
        if self.firstName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfirstName>%s</%sfirstName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.firstName), input_name='firstName')), namespace_, eol_))
        for middleName_ in self.middleName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smiddleName>%s</%smiddleName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(middleName_), input_name='middleName')), namespace_, eol_))
        for initial_ in self.initial:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinitial>%s</%sinitial>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(initial_), input_name='initial')), namespace_, eol_))
        if self.surname is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssurname>%s</%ssurname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.surname), input_name='surname')), namespace_, eol_))
        if self.suffix is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssuffix>%s</%ssuffix>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.suffix), input_name='suffix')), namespace_, eol_))
        for personId_ in self.personId:
            personId_.export(outfile, level, namespace_, name_='personId', pretty_print=pretty_print)
        if self.businessUnitReference is not None:
            self.businessUnitReference.export(outfile, level, namespace_, name_='businessUnitReference', pretty_print=pretty_print)
        if self.contactInfo is not None:
            self.contactInfo.export(outfile, level, namespace_, name_='contactInfo', pretty_print=pretty_print)
        if self.dateOfBirth is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdateOfBirth>%s</%sdateOfBirth>%s' % (namespace_, self.gds_format_date(self.dateOfBirth, input_name='dateOfBirth'), namespace_, eol_))
        if self.country is not None:
            self.country.export(outfile, level, namespace_, name_='country', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'honorific':
            honorific_ = child_.text
            honorific_ = self.gds_validate_string(honorific_, node, 'honorific')
            self.honorific = honorific_
            # validate type NormalizedString
            self.validate_NormalizedString(self.honorific)
        elif nodeName_ == 'firstName':
            firstName_ = child_.text
            firstName_ = self.gds_validate_string(firstName_, node, 'firstName')
            self.firstName = firstName_
            # validate type NormalizedString
            self.validate_NormalizedString(self.firstName)
        elif nodeName_ == 'middleName':
            middleName_ = child_.text
            middleName_ = self.gds_validate_string(middleName_, node, 'middleName')
            self.middleName.append(middleName_)
            # validate type NormalizedString
            self.validate_NormalizedString(self.middleName[-1])
        elif nodeName_ == 'initial':
            initial_ = child_.text
            initial_ = self.gds_validate_string(initial_, node, 'initial')
            self.initial.append(initial_)
            # validate type Initial
            self.validate_Initial(self.initial[-1])
        elif nodeName_ == 'surname':
            surname_ = child_.text
            surname_ = self.gds_validate_string(surname_, node, 'surname')
            self.surname = surname_
            # validate type NormalizedString
            self.validate_NormalizedString(self.surname)
        elif nodeName_ == 'suffix':
            suffix_ = child_.text
            suffix_ = self.gds_validate_string(suffix_, node, 'suffix')
            self.suffix = suffix_
            # validate type NormalizedString
            self.validate_NormalizedString(self.suffix)
        elif nodeName_ == 'personId':
            obj_ = PersonId.factory()
            obj_.build(child_)
            self.personId.append(obj_)
            obj_.original_tagname_ = 'personId'
        elif nodeName_ == 'businessUnitReference':
            obj_ = BusinessUnitReference.factory()
            obj_.build(child_)
            self.businessUnitReference = obj_
            obj_.original_tagname_ = 'businessUnitReference'
        elif nodeName_ == 'contactInfo':
            obj_ = ContactInformation.factory()
            obj_.build(child_)
            self.contactInfo = obj_
            obj_.original_tagname_ = 'contactInfo'
        elif nodeName_ == 'dateOfBirth':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.dateOfBirth = dval_
        elif nodeName_ == 'country':
            obj_ = CountryCode.factory()
            obj_.build(child_)
            self.country = obj_
            obj_.original_tagname_ = 'country'
# end class Person


class PersonId(GeneratedsSuper):
    """An identifier used to identify an individual person."""
    member_data_items_ = {
        'personIdScheme': MemberSpec_('personIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, personIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.personIdScheme = _cast(None, personIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PersonId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PersonId.subclass:
            return PersonId.subclass(*args_, **kwargs_)
        else:
            return PersonId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_personIdScheme(self): return self.personIdScheme
    def set_personIdScheme(self, personIdScheme): self.personIdScheme = personIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PersonId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PersonId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PersonId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PersonId'):
        if self.personIdScheme is not None and 'personIdScheme' not in already_processed:
            already_processed.add('personIdScheme')
            outfile.write(' personIdScheme=%s' % (quote_attrib(self.personIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PersonId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('personIdScheme', node)
        if value is not None and 'personIdScheme' not in already_processed:
            already_processed.add('personIdScheme')
            self.personIdScheme = value
            self.validate_NonEmptyURI(self.personIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PersonId


class PersonRole(GeneratedsSuper):
    """A type describing a role played by a person in one or more
    transactions. Examples include roles such as Trader, Broker,
    MiddleOffice, Legal, etc. This can be extended to provide custom
    roles."""
    member_data_items_ = {
        'personRoleScheme': MemberSpec_('personRoleScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, personRoleScheme='http://www.fpml.org/coding-scheme/person-role', valueOf_=None):
        self.original_tagname_ = None
        self.personRoleScheme = _cast(None, personRoleScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PersonRole)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PersonRole.subclass:
            return PersonRole.subclass(*args_, **kwargs_)
        else:
            return PersonRole(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_personRoleScheme(self): return self.personRoleScheme
    def set_personRoleScheme(self, personRoleScheme): self.personRoleScheme = personRoleScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PersonRole', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PersonRole')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PersonRole', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PersonRole'):
        if self.personRoleScheme != "http://www.fpml.org/coding-scheme/person-role" and 'personRoleScheme' not in already_processed:
            already_processed.add('personRoleScheme')
            outfile.write(' personRoleScheme=%s' % (quote_attrib(self.personRoleScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PersonRole', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('personRoleScheme', node)
        if value is not None and 'personRoleScheme' not in already_processed:
            already_processed.add('personRoleScheme')
            self.personRoleScheme = value
            self.validate_NonEmptyURI(self.personRoleScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PersonRole


class PositiveMoney(MoneyBase):
    """A type defining a positive money amount"""
    member_data_items_ = {
        'amount': MemberSpec_('amount', ['PositiveDecimal', 'xsd:decimal'], 0),
    }
    subclass = None
    superclass = MoneyBase
    def __init__(self, id=None, currency=None, amount=None):
        self.original_tagname_ = None
        super(PositiveMoney, self).__init__(id, currency, )
        self.amount = amount
        self.validate_PositiveDecimal(self.amount)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PositiveMoney)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PositiveMoney.subclass:
            return PositiveMoney.subclass(*args_, **kwargs_)
        else:
            return PositiveMoney(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_amount(self): return self.amount
    def set_amount(self, amount): self.amount = amount
    def validate_PositiveDecimal(self, value):
        # Validate type PositiveDecimal, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value <= 0:
                warnings_.warn('Value "%(value)s" does not match xsd minExclusive restriction on PositiveDecimal' % {"value" : value} )
    def hasContent_(self):
        if (
            self.amount is not None or
            super(PositiveMoney, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PositiveMoney', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PositiveMoney')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PositiveMoney', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PositiveMoney'):
        super(PositiveMoney, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PositiveMoney')
    def exportChildren(self, outfile, level, namespace_='', name_='PositiveMoney', fromsubclass_=False, pretty_print=True):
        super(PositiveMoney, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.amount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%samount>%s</%samount>%s' % (namespace_, self.gds_format_float(self.amount, input_name='amount'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PositiveMoney, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'amount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'amount')
            self.amount = fval_
            # validate type PositiveDecimal
            self.validate_PositiveDecimal(self.amount)
        super(PositiveMoney, self).buildChildren(child_, node, nodeName_, True)
# end class PositiveMoney


class PrevailingTime(GeneratedsSuper):
    """A type for defining a time with respect to a geographic location,
    for example 11:00 Phoenix, USA. This type should be used where a
    wider range of locations than those available as business
    centres is required."""
    member_data_items_ = {
        'hourMinuteTime': MemberSpec_('hourMinuteTime', ['HourMinuteTime', 'xsd:time'], 0),
        'location': MemberSpec_('location', 'TimezoneLocation', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, hourMinuteTime=None, location=None):
        self.original_tagname_ = None
        if isinstance(hourMinuteTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(hourMinuteTime, '%H:%M:%S').time()
        else:
            initvalue_ = hourMinuteTime
        self.hourMinuteTime = initvalue_
        self.location = location
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PrevailingTime)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PrevailingTime.subclass:
            return PrevailingTime.subclass(*args_, **kwargs_)
        else:
            return PrevailingTime(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_hourMinuteTime(self): return self.hourMinuteTime
    def set_hourMinuteTime(self, hourMinuteTime): self.hourMinuteTime = hourMinuteTime
    def get_location(self): return self.location
    def set_location(self, location): self.location = location
    def validate_HourMinuteTime(self, value):
        # Validate type HourMinuteTime, a restriction on xsd:time.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_HourMinuteTime_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_HourMinuteTime_patterns_, ))
    validate_HourMinuteTime_patterns_ = [['^[0-2][0-9]:[0-5][0-9]:00$']]
    def hasContent_(self):
        if (
            self.hourMinuteTime is not None or
            self.location is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PrevailingTime', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PrevailingTime')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PrevailingTime', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PrevailingTime'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PrevailingTime', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.hourMinuteTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shourMinuteTime>%s</%shourMinuteTime>%s' % (namespace_, self.gds_format_time(self.hourMinuteTime, input_name='hourMinuteTime'), namespace_, eol_))
        if self.location is not None:
            self.location.export(outfile, level, namespace_, name_='location', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'hourMinuteTime':
            sval_ = child_.text
            dval_ = self.gds_parse_time(sval_)
            self.hourMinuteTime = dval_
            # validate type HourMinuteTime
            self.validate_HourMinuteTime(self.hourMinuteTime)
        elif nodeName_ == 'location':
            obj_ = TimezoneLocation.factory()
            obj_.build(child_)
            self.location = obj_
            obj_.original_tagname_ = 'location'
# end class PrevailingTime


class PricingStructure(GeneratedsSuper):
    """An abstract pricing structure base type. Used as a base for
    structures such as yield curves and volatility matrices."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'name': MemberSpec_('name', ['NormalizedString', 'xsd:normalizedString'], 0),
        'currency': MemberSpec_('currency', 'Currency', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, currency=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.name = name
        self.validate_NormalizedString(self.name)
        self.currency = currency
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PricingStructure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PricingStructure.subclass:
            return PricingStructure.subclass(*args_, **kwargs_)
        else:
            return PricingStructure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_NormalizedString(self, value):
        # Validate type NormalizedString, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NormalizedString' % {"value" : value} )
    def hasContent_(self):
        if (
            self.name is not None or
            self.currency is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PricingStructure', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PricingStructure')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PricingStructure', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PricingStructure'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PricingStructure', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespace_, eol_))
        if self.currency is not None:
            self.currency.export(outfile, level, namespace_, name_='currency', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
            # validate type NormalizedString
            self.validate_NormalizedString(self.name)
        elif nodeName_ == 'currency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
# end class PricingStructure


class PrincipalExchanges(GeneratedsSuper):
    """A type defining which principal exchanges occur for the stream."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'initialExchange': MemberSpec_('initialExchange', 'xsd:boolean', 0),
        'finalExchange': MemberSpec_('finalExchange', 'xsd:boolean', 0),
        'intermediateExchange': MemberSpec_('intermediateExchange', 'xsd:boolean', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, initialExchange=None, finalExchange=None, intermediateExchange=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.initialExchange = initialExchange
        self.finalExchange = finalExchange
        self.intermediateExchange = intermediateExchange
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PrincipalExchanges)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PrincipalExchanges.subclass:
            return PrincipalExchanges.subclass(*args_, **kwargs_)
        else:
            return PrincipalExchanges(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_initialExchange(self): return self.initialExchange
    def set_initialExchange(self, initialExchange): self.initialExchange = initialExchange
    def get_finalExchange(self): return self.finalExchange
    def set_finalExchange(self, finalExchange): self.finalExchange = finalExchange
    def get_intermediateExchange(self): return self.intermediateExchange
    def set_intermediateExchange(self, intermediateExchange): self.intermediateExchange = intermediateExchange
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.initialExchange is not None or
            self.finalExchange is not None or
            self.intermediateExchange is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PrincipalExchanges', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PrincipalExchanges')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PrincipalExchanges', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PrincipalExchanges'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PrincipalExchanges', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.initialExchange is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinitialExchange>%s</%sinitialExchange>%s' % (namespace_, self.gds_format_boolean(self.initialExchange, input_name='initialExchange'), namespace_, eol_))
        if self.finalExchange is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfinalExchange>%s</%sfinalExchange>%s' % (namespace_, self.gds_format_boolean(self.finalExchange, input_name='finalExchange'), namespace_, eol_))
        if self.intermediateExchange is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sintermediateExchange>%s</%sintermediateExchange>%s' % (namespace_, self.gds_format_boolean(self.intermediateExchange, input_name='intermediateExchange'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'initialExchange':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'initialExchange')
            self.initialExchange = ival_
        elif nodeName_ == 'finalExchange':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'finalExchange')
            self.finalExchange = ival_
        elif nodeName_ == 'intermediateExchange':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'intermediateExchange')
            self.intermediateExchange = ival_
# end class PrincipalExchanges


class Product(GeneratedsSuper):
    """The base type which all FpML products extend."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'primaryAssetClass': MemberSpec_('primaryAssetClass', 'AssetClass', 0),
        'secondaryAssetClass': MemberSpec_('secondaryAssetClass', 'AssetClass', 1),
        'productType': MemberSpec_('productType', 'ProductType', 1),
        'productId': MemberSpec_('productId', 'ProductId', 1),
        'productId': MemberSpec_('productId', 'ProductId', 1),
        'assetClass': MemberSpec_('assetClass', 'AssetClass', 1),
        'embeddedOptionType': MemberSpec_('embeddedOptionType', 'EmbeddedOptionType', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, primaryAssetClass=None, secondaryAssetClass=None, productType=None, productId=None, assetClass=None, embeddedOptionType=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.primaryAssetClass = primaryAssetClass
        if secondaryAssetClass is None:
            self.secondaryAssetClass = []
        else:
            self.secondaryAssetClass = secondaryAssetClass
        if productType is None:
            self.productType = []
        else:
            self.productType = productType
        if productId is None:
            self.productId = []
        else:
            self.productId = productId
        if productId is None:
            self.productId = []
        else:
            self.productId = productId
        if assetClass is None:
            self.assetClass = []
        else:
            self.assetClass = assetClass
        if embeddedOptionType is None:
            self.embeddedOptionType = []
        else:
            self.embeddedOptionType = embeddedOptionType
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Product)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Product.subclass:
            return Product.subclass(*args_, **kwargs_)
        else:
            return Product(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_primaryAssetClass(self): return self.primaryAssetClass
    def set_primaryAssetClass(self, primaryAssetClass): self.primaryAssetClass = primaryAssetClass
    def get_secondaryAssetClass(self): return self.secondaryAssetClass
    def set_secondaryAssetClass(self, secondaryAssetClass): self.secondaryAssetClass = secondaryAssetClass
    def add_secondaryAssetClass(self, value): self.secondaryAssetClass.append(value)
    def insert_secondaryAssetClass_at(self, index, value): self.secondaryAssetClass.insert(index, value)
    def replace_secondaryAssetClass_at(self, index, value): self.secondaryAssetClass[index] = value
    def get_productType(self): return self.productType
    def set_productType(self, productType): self.productType = productType
    def add_productType(self, value): self.productType.append(value)
    def insert_productType_at(self, index, value): self.productType.insert(index, value)
    def replace_productType_at(self, index, value): self.productType[index] = value
    def get_productId(self): return self.productId
    def set_productId(self, productId): self.productId = productId
    def add_productId(self, value): self.productId.append(value)
    def insert_productId_at(self, index, value): self.productId.insert(index, value)
    def replace_productId_at(self, index, value): self.productId[index] = value
    def get_productId(self): return self.productId
    def set_productId(self, productId): self.productId = productId
    def add_productId(self, value): self.productId.append(value)
    def insert_productId_at(self, index, value): self.productId.insert(index, value)
    def replace_productId_at(self, index, value): self.productId[index] = value
    def get_assetClass(self): return self.assetClass
    def set_assetClass(self, assetClass): self.assetClass = assetClass
    def add_assetClass(self, value): self.assetClass.append(value)
    def insert_assetClass_at(self, index, value): self.assetClass.insert(index, value)
    def replace_assetClass_at(self, index, value): self.assetClass[index] = value
    def get_embeddedOptionType(self): return self.embeddedOptionType
    def set_embeddedOptionType(self, embeddedOptionType): self.embeddedOptionType = embeddedOptionType
    def add_embeddedOptionType(self, value): self.embeddedOptionType.append(value)
    def insert_embeddedOptionType_at(self, index, value): self.embeddedOptionType.insert(index, value)
    def replace_embeddedOptionType_at(self, index, value): self.embeddedOptionType[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.primaryAssetClass is not None or
            self.secondaryAssetClass or
            self.productType or
            self.productId or
            self.productId or
            self.assetClass or
            self.embeddedOptionType
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Product', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Product')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Product', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Product'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Product', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.primaryAssetClass is not None:
            self.primaryAssetClass.export(outfile, level, namespace_, name_='primaryAssetClass', pretty_print=pretty_print)
        for secondaryAssetClass_ in self.secondaryAssetClass:
            secondaryAssetClass_.export(outfile, level, namespace_, name_='secondaryAssetClass', pretty_print=pretty_print)
        for productType_ in self.productType:
            productType_.export(outfile, level, namespace_, name_='productType', pretty_print=pretty_print)
        for productId_ in self.productId:
            productId_.export(outfile, level, namespace_, name_='productId', pretty_print=pretty_print)
        for productId_ in self.productId:
            productId_.export(outfile, level, namespace_, name_='productId', pretty_print=pretty_print)
        for assetClass_ in self.assetClass:
            assetClass_.export(outfile, level, namespace_, name_='assetClass', pretty_print=pretty_print)
        for embeddedOptionType_ in self.embeddedOptionType:
            embeddedOptionType_.export(outfile, level, namespace_, name_='embeddedOptionType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'primaryAssetClass':
            obj_ = AssetClass.factory()
            obj_.build(child_)
            self.primaryAssetClass = obj_
            obj_.original_tagname_ = 'primaryAssetClass'
        elif nodeName_ == 'secondaryAssetClass':
            obj_ = AssetClass.factory()
            obj_.build(child_)
            self.secondaryAssetClass.append(obj_)
            obj_.original_tagname_ = 'secondaryAssetClass'
        elif nodeName_ == 'productType':
            obj_ = ProductType.factory()
            obj_.build(child_)
            self.productType.append(obj_)
            obj_.original_tagname_ = 'productType'
        elif nodeName_ == 'productId':
            obj_ = ProductId.factory()
            obj_.build(child_)
            self.productId.append(obj_)
            obj_.original_tagname_ = 'productId'
        elif nodeName_ == 'productId':
            obj_ = ProductId.factory()
            obj_.build(child_)
            self.productId.append(obj_)
            obj_.original_tagname_ = 'productId'
        elif nodeName_ == 'assetClass':
            obj_ = AssetClass.factory()
            obj_.build(child_)
            self.assetClass.append(obj_)
            obj_.original_tagname_ = 'assetClass'
        elif nodeName_ == 'embeddedOptionType':
            obj_ = EmbeddedOptionType.factory()
            obj_.build(child_)
            self.embeddedOptionType.append(obj_)
            obj_.original_tagname_ = 'embeddedOptionType'
# end class Product


class ProductId(GeneratedsSuper):
    member_data_items_ = {
        'productIdScheme': MemberSpec_('productIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyLongScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, productIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.productIdScheme = _cast(None, productIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductId.subclass:
            return ProductId.subclass(*args_, **kwargs_)
        else:
            return ProductId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_productIdScheme(self): return self.productIdScheme
    def set_productIdScheme(self, productIdScheme): self.productIdScheme = productIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ProductId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ProductId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProductId'):
        if self.productIdScheme is not None and 'productIdScheme' not in already_processed:
            already_processed.add('productIdScheme')
            outfile.write(' productIdScheme=%s' % (quote_attrib(self.productIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ProductId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('productIdScheme', node)
        if value is not None and 'productIdScheme' not in already_processed:
            already_processed.add('productIdScheme')
            self.productIdScheme = value
            self.validate_NonEmptyURI(self.productIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ProductId


class ProductType(GeneratedsSuper):
    member_data_items_ = {
        'productTypeScheme': MemberSpec_('productTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyLongScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, productTypeScheme='http://www.fpml.org/coding-scheme/product-taxonomy', valueOf_=None):
        self.original_tagname_ = None
        self.productTypeScheme = _cast(None, productTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductType.subclass:
            return ProductType.subclass(*args_, **kwargs_)
        else:
            return ProductType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_productTypeScheme(self): return self.productTypeScheme
    def set_productTypeScheme(self, productTypeScheme): self.productTypeScheme = productTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ProductType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ProductType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProductType'):
        if self.productTypeScheme != "http://www.fpml.org/coding-scheme/product-taxonomy" and 'productTypeScheme' not in already_processed:
            already_processed.add('productTypeScheme')
            outfile.write(' productTypeScheme=%s' % (quote_attrib(self.productTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ProductType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('productTypeScheme', node)
        if value is not None and 'productTypeScheme' not in already_processed:
            already_processed.add('productTypeScheme')
            self.productTypeScheme = value
            self.validate_NonEmptyURI(self.productTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ProductType


class ProposedCollateralAllocation(GeneratedsSuper):
    """The proposed collateral allocation."""
    member_data_items_ = {
        'allocationPartyReference': MemberSpec_('allocationPartyReference', 'PartyReference', 0),
        'allocationAccountReference': MemberSpec_('allocationAccountReference', 'AccountReference', 0),
        'collateralValueAllocation': MemberSpec_('collateralValueAllocation', 'CollateralValueAllocation', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, allocationPartyReference=None, allocationAccountReference=None, collateralValueAllocation=None):
        self.original_tagname_ = None
        self.allocationPartyReference = allocationPartyReference
        self.allocationAccountReference = allocationAccountReference
        if collateralValueAllocation is None:
            self.collateralValueAllocation = []
        else:
            self.collateralValueAllocation = collateralValueAllocation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProposedCollateralAllocation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProposedCollateralAllocation.subclass:
            return ProposedCollateralAllocation.subclass(*args_, **kwargs_)
        else:
            return ProposedCollateralAllocation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_allocationPartyReference(self): return self.allocationPartyReference
    def set_allocationPartyReference(self, allocationPartyReference): self.allocationPartyReference = allocationPartyReference
    def get_allocationAccountReference(self): return self.allocationAccountReference
    def set_allocationAccountReference(self, allocationAccountReference): self.allocationAccountReference = allocationAccountReference
    def get_collateralValueAllocation(self): return self.collateralValueAllocation
    def set_collateralValueAllocation(self, collateralValueAllocation): self.collateralValueAllocation = collateralValueAllocation
    def add_collateralValueAllocation(self, value): self.collateralValueAllocation.append(value)
    def insert_collateralValueAllocation_at(self, index, value): self.collateralValueAllocation.insert(index, value)
    def replace_collateralValueAllocation_at(self, index, value): self.collateralValueAllocation[index] = value
    def hasContent_(self):
        if (
            self.allocationPartyReference is not None or
            self.allocationAccountReference is not None or
            self.collateralValueAllocation
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ProposedCollateralAllocation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProposedCollateralAllocation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ProposedCollateralAllocation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProposedCollateralAllocation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ProposedCollateralAllocation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.allocationPartyReference is not None:
            self.allocationPartyReference.export(outfile, level, namespace_, name_='allocationPartyReference', pretty_print=pretty_print)
        if self.allocationAccountReference is not None:
            self.allocationAccountReference.export(outfile, level, namespace_, name_='allocationAccountReference', pretty_print=pretty_print)
        for collateralValueAllocation_ in self.collateralValueAllocation:
            collateralValueAllocation_.export(outfile, level, namespace_, name_='collateralValueAllocation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'allocationPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.allocationPartyReference = obj_
            obj_.original_tagname_ = 'allocationPartyReference'
        elif nodeName_ == 'allocationAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.allocationAccountReference = obj_
            obj_.original_tagname_ = 'allocationAccountReference'
        elif nodeName_ == 'collateralValueAllocation':
            obj_ = CollateralValueAllocation.factory()
            obj_.build(child_)
            self.collateralValueAllocation.append(obj_)
            obj_.original_tagname_ = 'collateralValueAllocation'
# end class ProposedCollateralAllocation


class QuotedCurrencyPair(GeneratedsSuper):
    """A type that describes the composition of a rate that has been quoted
    or is to be quoted. This includes the two currencies and the
    quotation relationship between the two currencies and is used as
    a building block throughout the FX specification."""
    member_data_items_ = {
        'currency1': MemberSpec_('currency1', 'Currency', 0),
        'currency2': MemberSpec_('currency2', 'Currency', 0),
        'quoteBasis': MemberSpec_('quoteBasis', ['QuoteBasisEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, currency1=None, currency2=None, quoteBasis=None):
        self.original_tagname_ = None
        self.currency1 = currency1
        self.currency2 = currency2
        self.quoteBasis = quoteBasis
        self.validate_QuoteBasisEnum(self.quoteBasis)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QuotedCurrencyPair)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QuotedCurrencyPair.subclass:
            return QuotedCurrencyPair.subclass(*args_, **kwargs_)
        else:
            return QuotedCurrencyPair(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_currency1(self): return self.currency1
    def set_currency1(self, currency1): self.currency1 = currency1
    def get_currency2(self): return self.currency2
    def set_currency2(self, currency2): self.currency2 = currency2
    def get_quoteBasis(self): return self.quoteBasis
    def set_quoteBasis(self, quoteBasis): self.quoteBasis = quoteBasis
    def validate_QuoteBasisEnum(self, value):
        # Validate type QuoteBasisEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Currency1PerCurrency2', 'Currency2PerCurrency1']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on QuoteBasisEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on QuoteBasisEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.currency1 is not None or
            self.currency2 is not None or
            self.quoteBasis is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QuotedCurrencyPair', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QuotedCurrencyPair')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QuotedCurrencyPair', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QuotedCurrencyPair'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='QuotedCurrencyPair', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.currency1 is not None:
            self.currency1.export(outfile, level, namespace_, name_='currency1', pretty_print=pretty_print)
        if self.currency2 is not None:
            self.currency2.export(outfile, level, namespace_, name_='currency2', pretty_print=pretty_print)
        if self.quoteBasis is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%squoteBasis>%s</%squoteBasis>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.quoteBasis), input_name='quoteBasis')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'currency1':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency1 = obj_
            obj_.original_tagname_ = 'currency1'
        elif nodeName_ == 'currency2':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency2 = obj_
            obj_.original_tagname_ = 'currency2'
        elif nodeName_ == 'quoteBasis':
            quoteBasis_ = child_.text
            quoteBasis_ = re_.sub(String_cleanup_pat_, " ", quoteBasis_).strip()
            quoteBasis_ = self.gds_validate_string(quoteBasis_, node, 'quoteBasis')
            self.quoteBasis = quoteBasis_
            # validate type QuoteBasisEnum
            self.validate_QuoteBasisEnum(self.quoteBasis)
# end class QuotedCurrencyPair


class Rate(GeneratedsSuper):
    """The abstract base class for all types which define interest rate
    streams."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Rate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Rate.subclass:
            return Rate.subclass(*args_, **kwargs_)
        else:
            return Rate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Rate', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Rate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Rate', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Rate'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Rate', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Rate


class RateObservation(GeneratedsSuper):
    """A type defining parameters associated with an individual observation
    or fixing. This type forms part of the cashflow representation
    of a stream."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'resetDate': MemberSpec_('resetDate', 'xsd:date', 0),
        'adjustedFixingDate': MemberSpec_('adjustedFixingDate', 'xsd:date', 0),
        'observedRate': MemberSpec_('observedRate', 'xsd:decimal', 0),
        'treatedRate': MemberSpec_('treatedRate', 'xsd:decimal', 0),
        'observationWeight': MemberSpec_('observationWeight', 'xsd:positiveInteger', 0),
        'rateReference': MemberSpec_('rateReference', 'RateReference', 0),
        'forecastRate': MemberSpec_('forecastRate', 'xsd:decimal', 0),
        'treatedForecastRate': MemberSpec_('treatedForecastRate', 'xsd:decimal', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, resetDate=None, adjustedFixingDate=None, observedRate=None, treatedRate=None, observationWeight=None, rateReference=None, forecastRate=None, treatedForecastRate=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if isinstance(resetDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(resetDate, '%Y-%m-%d').date()
        else:
            initvalue_ = resetDate
        self.resetDate = initvalue_
        if isinstance(adjustedFixingDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(adjustedFixingDate, '%Y-%m-%d').date()
        else:
            initvalue_ = adjustedFixingDate
        self.adjustedFixingDate = initvalue_
        self.observedRate = observedRate
        self.treatedRate = treatedRate
        self.observationWeight = observationWeight
        self.rateReference = rateReference
        self.forecastRate = forecastRate
        self.treatedForecastRate = treatedForecastRate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RateObservation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RateObservation.subclass:
            return RateObservation.subclass(*args_, **kwargs_)
        else:
            return RateObservation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_resetDate(self): return self.resetDate
    def set_resetDate(self, resetDate): self.resetDate = resetDate
    def get_adjustedFixingDate(self): return self.adjustedFixingDate
    def set_adjustedFixingDate(self, adjustedFixingDate): self.adjustedFixingDate = adjustedFixingDate
    def get_observedRate(self): return self.observedRate
    def set_observedRate(self, observedRate): self.observedRate = observedRate
    def get_treatedRate(self): return self.treatedRate
    def set_treatedRate(self, treatedRate): self.treatedRate = treatedRate
    def get_observationWeight(self): return self.observationWeight
    def set_observationWeight(self, observationWeight): self.observationWeight = observationWeight
    def get_rateReference(self): return self.rateReference
    def set_rateReference(self, rateReference): self.rateReference = rateReference
    def get_forecastRate(self): return self.forecastRate
    def set_forecastRate(self, forecastRate): self.forecastRate = forecastRate
    def get_treatedForecastRate(self): return self.treatedForecastRate
    def set_treatedForecastRate(self, treatedForecastRate): self.treatedForecastRate = treatedForecastRate
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.resetDate is not None or
            self.adjustedFixingDate is not None or
            self.observedRate is not None or
            self.treatedRate is not None or
            self.observationWeight is not None or
            self.rateReference is not None or
            self.forecastRate is not None or
            self.treatedForecastRate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RateObservation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RateObservation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RateObservation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RateObservation'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RateObservation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.resetDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sresetDate>%s</%sresetDate>%s' % (namespace_, self.gds_format_date(self.resetDate, input_name='resetDate'), namespace_, eol_))
        if self.adjustedFixingDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sadjustedFixingDate>%s</%sadjustedFixingDate>%s' % (namespace_, self.gds_format_date(self.adjustedFixingDate, input_name='adjustedFixingDate'), namespace_, eol_))
        if self.observedRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sobservedRate>%s</%sobservedRate>%s' % (namespace_, self.gds_format_float(self.observedRate, input_name='observedRate'), namespace_, eol_))
        if self.treatedRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%streatedRate>%s</%streatedRate>%s' % (namespace_, self.gds_format_float(self.treatedRate, input_name='treatedRate'), namespace_, eol_))
        if self.observationWeight is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sobservationWeight>%s</%sobservationWeight>%s' % (namespace_, self.gds_format_integer(self.observationWeight, input_name='observationWeight'), namespace_, eol_))
        if self.rateReference is not None:
            self.rateReference.export(outfile, level, namespace_, name_='rateReference', pretty_print=pretty_print)
        if self.forecastRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sforecastRate>%s</%sforecastRate>%s' % (namespace_, self.gds_format_float(self.forecastRate, input_name='forecastRate'), namespace_, eol_))
        if self.treatedForecastRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%streatedForecastRate>%s</%streatedForecastRate>%s' % (namespace_, self.gds_format_float(self.treatedForecastRate, input_name='treatedForecastRate'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'resetDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.resetDate = dval_
        elif nodeName_ == 'adjustedFixingDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.adjustedFixingDate = dval_
        elif nodeName_ == 'observedRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'observedRate')
            self.observedRate = fval_
        elif nodeName_ == 'treatedRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'treatedRate')
            self.treatedRate = fval_
        elif nodeName_ == 'observationWeight':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'observationWeight')
            self.observationWeight = ival_
        elif nodeName_ == 'rateReference':
            obj_ = RateReference.factory()
            obj_.build(child_)
            self.rateReference = obj_
            obj_.original_tagname_ = 'rateReference'
        elif nodeName_ == 'forecastRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'forecastRate')
            self.forecastRate = fval_
        elif nodeName_ == 'treatedForecastRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'treatedForecastRate')
            self.treatedForecastRate = fval_
# end class RateObservation


class RateReference(GeneratedsSuper):
    """Reference to any rate (floating, inflation) derived from the
    abstract Rate component."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, href=None):
        self.original_tagname_ = None
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RateReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RateReference.subclass:
            return RateReference.subclass(*args_, **kwargs_)
        else:
            return RateReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RateReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RateReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RateReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RateReference'):
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RateReference', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RateReference


class RateSourcePage(GeneratedsSuper):
    member_data_items_ = {
        'rateSourcePageScheme': MemberSpec_('rateSourcePageScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, rateSourcePageScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.rateSourcePageScheme = _cast(None, rateSourcePageScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RateSourcePage)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RateSourcePage.subclass:
            return RateSourcePage.subclass(*args_, **kwargs_)
        else:
            return RateSourcePage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rateSourcePageScheme(self): return self.rateSourcePageScheme
    def set_rateSourcePageScheme(self, rateSourcePageScheme): self.rateSourcePageScheme = rateSourcePageScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RateSourcePage', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RateSourcePage')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RateSourcePage', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RateSourcePage'):
        if self.rateSourcePageScheme is not None and 'rateSourcePageScheme' not in already_processed:
            already_processed.add('rateSourcePageScheme')
            outfile.write(' rateSourcePageScheme=%s' % (quote_attrib(self.rateSourcePageScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RateSourcePage', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('rateSourcePageScheme', node)
        if value is not None and 'rateSourcePageScheme' not in already_processed:
            already_processed.add('rateSourcePageScheme')
            self.rateSourcePageScheme = value
            self.validate_NonEmptyURI(self.rateSourcePageScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RateSourcePage


class Reference(GeneratedsSuper):
    """The abstract base class for all types which define intra-document
    pointers."""
    member_data_items_ = {
    }
    subclass = None
    superclass = None
    def __init__(self, extensiontype_=None):
        self.original_tagname_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Reference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Reference.subclass:
            return Reference.subclass(*args_, **kwargs_)
        else:
            return Reference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Reference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Reference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Reference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Reference'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Reference', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Reference


class ReferenceAmount(GeneratedsSuper):
    """Specifies the reference amount using a scheme."""
    member_data_items_ = {
        'referenceAmountScheme': MemberSpec_('referenceAmountScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, referenceAmountScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.referenceAmountScheme = _cast(None, referenceAmountScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferenceAmount)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferenceAmount.subclass:
            return ReferenceAmount.subclass(*args_, **kwargs_)
        else:
            return ReferenceAmount(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_referenceAmountScheme(self): return self.referenceAmountScheme
    def set_referenceAmountScheme(self, referenceAmountScheme): self.referenceAmountScheme = referenceAmountScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReferenceAmount', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceAmount')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReferenceAmount', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReferenceAmount'):
        if self.referenceAmountScheme is not None and 'referenceAmountScheme' not in already_processed:
            already_processed.add('referenceAmountScheme')
            outfile.write(' referenceAmountScheme=%s' % (quote_attrib(self.referenceAmountScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ReferenceAmount', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('referenceAmountScheme', node)
        if value is not None and 'referenceAmountScheme' not in already_processed:
            already_processed.add('referenceAmountScheme')
            self.referenceAmountScheme = value
            self.validate_NonEmptyURI(self.referenceAmountScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReferenceAmount


class ReferenceBank(GeneratedsSuper):
    """A type to describe an institution (party) identified by means of a
    coding scheme and an optional name."""
    member_data_items_ = {
        'referenceBankId': MemberSpec_('referenceBankId', 'ReferenceBankId', 0),
        'referenceBankName': MemberSpec_('referenceBankName', ['String', 'xsd:string'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, referenceBankId=None, referenceBankName=None):
        self.original_tagname_ = None
        self.referenceBankId = referenceBankId
        self.referenceBankName = referenceBankName
        self.validate_String(self.referenceBankName)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferenceBank)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferenceBank.subclass:
            return ReferenceBank.subclass(*args_, **kwargs_)
        else:
            return ReferenceBank(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_referenceBankId(self): return self.referenceBankId
    def set_referenceBankId(self, referenceBankId): self.referenceBankId = referenceBankId
    def get_referenceBankName(self): return self.referenceBankName
    def set_referenceBankName(self, referenceBankName): self.referenceBankName = referenceBankName
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.referenceBankId is not None or
            self.referenceBankName is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReferenceBank', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceBank')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReferenceBank', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReferenceBank'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ReferenceBank', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.referenceBankId is not None:
            self.referenceBankId.export(outfile, level, namespace_, name_='referenceBankId', pretty_print=pretty_print)
        if self.referenceBankName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreferenceBankName>%s</%sreferenceBankName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.referenceBankName), input_name='referenceBankName')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'referenceBankId':
            obj_ = ReferenceBankId.factory()
            obj_.build(child_)
            self.referenceBankId = obj_
            obj_.original_tagname_ = 'referenceBankId'
        elif nodeName_ == 'referenceBankName':
            referenceBankName_ = child_.text
            referenceBankName_ = self.gds_validate_string(referenceBankName_, node, 'referenceBankName')
            self.referenceBankName = referenceBankName_
            # validate type String
            self.validate_String(self.referenceBankName)
# end class ReferenceBank


class ReferenceBankId(GeneratedsSuper):
    member_data_items_ = {
        'referenceBankIdScheme': MemberSpec_('referenceBankIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, referenceBankIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.referenceBankIdScheme = _cast(None, referenceBankIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferenceBankId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferenceBankId.subclass:
            return ReferenceBankId.subclass(*args_, **kwargs_)
        else:
            return ReferenceBankId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_referenceBankIdScheme(self): return self.referenceBankIdScheme
    def set_referenceBankIdScheme(self, referenceBankIdScheme): self.referenceBankIdScheme = referenceBankIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReferenceBankId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceBankId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReferenceBankId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReferenceBankId'):
        if self.referenceBankIdScheme is not None and 'referenceBankIdScheme' not in already_processed:
            already_processed.add('referenceBankIdScheme')
            outfile.write(' referenceBankIdScheme=%s' % (quote_attrib(self.referenceBankIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ReferenceBankId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('referenceBankIdScheme', node)
        if value is not None and 'referenceBankIdScheme' not in already_processed:
            already_processed.add('referenceBankIdScheme')
            self.referenceBankIdScheme = value
            self.validate_NonEmptyURI(self.referenceBankIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReferenceBankId


class Region(GeneratedsSuper):
    """A code that describes the world region of a counterparty. For
    example, NorthAmerica, Europe, Asia."""
    member_data_items_ = {
        'regionScheme': MemberSpec_('regionScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, regionScheme='http://www.fpml.org/coding-scheme/region', valueOf_=None):
        self.original_tagname_ = None
        self.regionScheme = _cast(None, regionScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Region)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Region.subclass:
            return Region.subclass(*args_, **kwargs_)
        else:
            return Region(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_regionScheme(self): return self.regionScheme
    def set_regionScheme(self, regionScheme): self.regionScheme = regionScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Region', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Region')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Region', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Region'):
        if self.regionScheme != "http://www.fpml.org/coding-scheme/region" and 'regionScheme' not in already_processed:
            already_processed.add('regionScheme')
            outfile.write(' regionScheme=%s' % (quote_attrib(self.regionScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Region', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('regionScheme', node)
        if value is not None and 'regionScheme' not in already_processed:
            already_processed.add('regionScheme')
            self.regionScheme = value
            self.validate_NonEmptyURI(self.regionScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Region


class RelatedBusinessUnit(GeneratedsSuper):
    member_data_items_ = {
        'businessUnitReference': MemberSpec_('businessUnitReference', 'BusinessUnitReference', 0),
        'role': MemberSpec_('role', 'BusinessUnitRole', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, businessUnitReference=None, role=None):
        self.original_tagname_ = None
        self.businessUnitReference = businessUnitReference
        self.role = role
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RelatedBusinessUnit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RelatedBusinessUnit.subclass:
            return RelatedBusinessUnit.subclass(*args_, **kwargs_)
        else:
            return RelatedBusinessUnit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_businessUnitReference(self): return self.businessUnitReference
    def set_businessUnitReference(self, businessUnitReference): self.businessUnitReference = businessUnitReference
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def hasContent_(self):
        if (
            self.businessUnitReference is not None or
            self.role is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RelatedBusinessUnit', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RelatedBusinessUnit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RelatedBusinessUnit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RelatedBusinessUnit'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RelatedBusinessUnit', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.businessUnitReference is not None:
            self.businessUnitReference.export(outfile, level, namespace_, name_='businessUnitReference', pretty_print=pretty_print)
        if self.role is not None:
            self.role.export(outfile, level, namespace_, name_='role', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'businessUnitReference':
            obj_ = BusinessUnitReference.factory()
            obj_.build(child_)
            self.businessUnitReference = obj_
            obj_.original_tagname_ = 'businessUnitReference'
        elif nodeName_ == 'role':
            obj_ = BusinessUnitRole.factory()
            obj_.build(child_)
            self.role = obj_
            obj_.original_tagname_ = 'role'
# end class RelatedBusinessUnit


class RelatedParty(GeneratedsSuper):
    member_data_items_ = {
        'partyReference': MemberSpec_('partyReference', 'PartyReference', 0),
        'accountReference': MemberSpec_('accountReference', 'AccountReference', 0),
        'role': MemberSpec_('role', 'PartyRole', 0),
        'type_': MemberSpec_('type_', 'PartyRoleType', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, partyReference=None, accountReference=None, role=None, type_=None):
        self.original_tagname_ = None
        self.partyReference = partyReference
        self.accountReference = accountReference
        self.role = role
        self.type_ = type_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RelatedParty)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RelatedParty.subclass:
            return RelatedParty.subclass(*args_, **kwargs_)
        else:
            return RelatedParty(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyReference(self): return self.partyReference
    def set_partyReference(self, partyReference): self.partyReference = partyReference
    def get_accountReference(self): return self.accountReference
    def set_accountReference(self, accountReference): self.accountReference = accountReference
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (
            self.partyReference is not None or
            self.accountReference is not None or
            self.role is not None or
            self.type_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RelatedParty', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RelatedParty')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RelatedParty', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RelatedParty'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RelatedParty', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.partyReference is not None:
            self.partyReference.export(outfile, level, namespace_, name_='partyReference', pretty_print=pretty_print)
        if self.accountReference is not None:
            self.accountReference.export(outfile, level, namespace_, name_='accountReference', pretty_print=pretty_print)
        if self.role is not None:
            self.role.export(outfile, level, namespace_, name_='role', pretty_print=pretty_print)
        if self.type_ is not None:
            self.type_.export(outfile, level, namespace_, name_='type', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'partyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.partyReference = obj_
            obj_.original_tagname_ = 'partyReference'
        elif nodeName_ == 'accountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.accountReference = obj_
            obj_.original_tagname_ = 'accountReference'
        elif nodeName_ == 'role':
            obj_ = PartyRole.factory()
            obj_.build(child_)
            self.role = obj_
            obj_.original_tagname_ = 'role'
        elif nodeName_ == 'type':
            obj_ = PartyRoleType.factory()
            obj_.build(child_)
            self.type_ = obj_
            obj_.original_tagname_ = 'type'
# end class RelatedParty


class RelatedPerson(GeneratedsSuper):
    member_data_items_ = {
        'personReference': MemberSpec_('personReference', 'PersonReference', 0),
        'role': MemberSpec_('role', 'PersonRole', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, personReference=None, role=None):
        self.original_tagname_ = None
        self.personReference = personReference
        self.role = role
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RelatedPerson)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RelatedPerson.subclass:
            return RelatedPerson.subclass(*args_, **kwargs_)
        else:
            return RelatedPerson(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_personReference(self): return self.personReference
    def set_personReference(self, personReference): self.personReference = personReference
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def hasContent_(self):
        if (
            self.personReference is not None or
            self.role is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RelatedPerson', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RelatedPerson')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RelatedPerson', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RelatedPerson'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RelatedPerson', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.personReference is not None:
            self.personReference.export(outfile, level, namespace_, name_='personReference', pretty_print=pretty_print)
        if self.role is not None:
            self.role.export(outfile, level, namespace_, name_='role', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'personReference':
            obj_ = PersonReference.factory()
            obj_.build(child_)
            self.personReference = obj_
            obj_.original_tagname_ = 'personReference'
        elif nodeName_ == 'role':
            obj_ = PersonRole.factory()
            obj_.build(child_)
            self.role = obj_
            obj_.original_tagname_ = 'role'
# end class RelatedPerson


class RelativeDateSequence(GeneratedsSuper):
    """A type describing a date when this date is defined in reference to
    another date through one or several date offsets."""
    member_data_items_ = {
        'dateRelativeTo': MemberSpec_('dateRelativeTo', 'DateReference', 0),
        'dateOffset': MemberSpec_('dateOffset', 'DateOffset', 1),
        'businessCentersReference': MemberSpec_('businessCentersReference', 'BusinessCentersReference', 0),
        'businessCenters': MemberSpec_('businessCenters', 'BusinessCenters', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, dateRelativeTo=None, dateOffset=None, businessCentersReference=None, businessCenters=None):
        self.original_tagname_ = None
        self.dateRelativeTo = dateRelativeTo
        if dateOffset is None:
            self.dateOffset = []
        else:
            self.dateOffset = dateOffset
        self.businessCentersReference = businessCentersReference
        self.businessCenters = businessCenters
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RelativeDateSequence)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RelativeDateSequence.subclass:
            return RelativeDateSequence.subclass(*args_, **kwargs_)
        else:
            return RelativeDateSequence(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dateRelativeTo(self): return self.dateRelativeTo
    def set_dateRelativeTo(self, dateRelativeTo): self.dateRelativeTo = dateRelativeTo
    def get_dateOffset(self): return self.dateOffset
    def set_dateOffset(self, dateOffset): self.dateOffset = dateOffset
    def add_dateOffset(self, value): self.dateOffset.append(value)
    def insert_dateOffset_at(self, index, value): self.dateOffset.insert(index, value)
    def replace_dateOffset_at(self, index, value): self.dateOffset[index] = value
    def get_businessCentersReference(self): return self.businessCentersReference
    def set_businessCentersReference(self, businessCentersReference): self.businessCentersReference = businessCentersReference
    def get_businessCenters(self): return self.businessCenters
    def set_businessCenters(self, businessCenters): self.businessCenters = businessCenters
    def hasContent_(self):
        if (
            self.dateRelativeTo is not None or
            self.dateOffset or
            self.businessCentersReference is not None or
            self.businessCenters is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RelativeDateSequence', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RelativeDateSequence')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RelativeDateSequence', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RelativeDateSequence'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RelativeDateSequence', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dateRelativeTo is not None:
            self.dateRelativeTo.export(outfile, level, namespace_, name_='dateRelativeTo', pretty_print=pretty_print)
        for dateOffset_ in self.dateOffset:
            dateOffset_.export(outfile, level, namespace_, name_='dateOffset', pretty_print=pretty_print)
        if self.businessCentersReference is not None:
            self.businessCentersReference.export(outfile, level, namespace_, name_='businessCentersReference', pretty_print=pretty_print)
        if self.businessCenters is not None:
            self.businessCenters.export(outfile, level, namespace_, name_='businessCenters', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dateRelativeTo':
            obj_ = DateReference.factory()
            obj_.build(child_)
            self.dateRelativeTo = obj_
            obj_.original_tagname_ = 'dateRelativeTo'
        elif nodeName_ == 'dateOffset':
            obj_ = DateOffset.factory()
            obj_.build(child_)
            self.dateOffset.append(obj_)
            obj_.original_tagname_ = 'dateOffset'
        elif nodeName_ == 'businessCentersReference':
            obj_ = BusinessCentersReference.factory()
            obj_.build(child_)
            self.businessCentersReference = obj_
            obj_.original_tagname_ = 'businessCentersReference'
        elif nodeName_ == 'businessCenters':
            obj_ = BusinessCenters.factory()
            obj_.build(child_)
            self.businessCenters = obj_
            obj_.original_tagname_ = 'businessCenters'
# end class RelativeDateSequence


class ReportingRegimeName(GeneratedsSuper):
    """An identifier of an reporting regime or format used for regulatory
    reporting, for example DoddFrankAct, MiFID,
    HongKongOTCDRepository, etc."""
    member_data_items_ = {
        'reportingRegimeNameScheme': MemberSpec_('reportingRegimeNameScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, reportingRegimeNameScheme='http://www.fpml.org/coding-scheme/reporting-regime', valueOf_=None):
        self.original_tagname_ = None
        self.reportingRegimeNameScheme = _cast(None, reportingRegimeNameScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReportingRegimeName)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReportingRegimeName.subclass:
            return ReportingRegimeName.subclass(*args_, **kwargs_)
        else:
            return ReportingRegimeName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_reportingRegimeNameScheme(self): return self.reportingRegimeNameScheme
    def set_reportingRegimeNameScheme(self, reportingRegimeNameScheme): self.reportingRegimeNameScheme = reportingRegimeNameScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReportingRegimeName', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReportingRegimeName')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReportingRegimeName', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReportingRegimeName'):
        if self.reportingRegimeNameScheme != "http://www.fpml.org/coding-scheme/reporting-regime" and 'reportingRegimeNameScheme' not in already_processed:
            already_processed.add('reportingRegimeNameScheme')
            outfile.write(' reportingRegimeNameScheme=%s' % (quote_attrib(self.reportingRegimeNameScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ReportingRegimeName', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('reportingRegimeNameScheme', node)
        if value is not None and 'reportingRegimeNameScheme' not in already_processed:
            already_processed.add('reportingRegimeNameScheme')
            self.reportingRegimeNameScheme = value
            self.validate_NonEmptyURI(self.reportingRegimeNameScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReportingRegimeName


class RequestedAction(GeneratedsSuper):
    member_data_items_ = {
        'requestedActionScheme': MemberSpec_('requestedActionScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, requestedActionScheme='http://www.fpml.org/coding-scheme/requested-action', valueOf_=None):
        self.original_tagname_ = None
        self.requestedActionScheme = _cast(None, requestedActionScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RequestedAction)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RequestedAction.subclass:
            return RequestedAction.subclass(*args_, **kwargs_)
        else:
            return RequestedAction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_requestedActionScheme(self): return self.requestedActionScheme
    def set_requestedActionScheme(self, requestedActionScheme): self.requestedActionScheme = requestedActionScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RequestedAction', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RequestedAction')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RequestedAction', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RequestedAction'):
        if self.requestedActionScheme != "http://www.fpml.org/coding-scheme/requested-action" and 'requestedActionScheme' not in already_processed:
            already_processed.add('requestedActionScheme')
            outfile.write(' requestedActionScheme=%s' % (quote_attrib(self.requestedActionScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RequestedAction', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('requestedActionScheme', node)
        if value is not None and 'requestedActionScheme' not in already_processed:
            already_processed.add('requestedActionScheme')
            self.requestedActionScheme = value
            self.validate_NonEmptyURI(self.requestedActionScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RequestedAction


class RequiredIdentifierDate(GeneratedsSuper):
    """A date with a required identifier which can be referenced elsewhere."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'valueOf_': MemberSpec_('valueOf_', 'xsd:date', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RequiredIdentifierDate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RequiredIdentifierDate.subclass:
            return RequiredIdentifierDate.subclass(*args_, **kwargs_)
        else:
            return RequiredIdentifierDate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RequiredIdentifierDate', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RequiredIdentifierDate')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RequiredIdentifierDate', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RequiredIdentifierDate'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RequiredIdentifierDate', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RequiredIdentifierDate


class ResetFrequency(Frequency):
    """A type defining the reset frequency. In the case of a weekly reset,
    also specifies the day of the week that the reset occurs. If the
    reset frequency is greater than the calculation period frequency
    the this implies that more or more reset dates is established
    for each calculation period and some form of rate averaginhg is
    applicable. The specific averaging method of calculation is
    specified in FloatingRateCalculation. In case the reset
    frequency is of value T (term), the period is defined by the
    swap\swapStream\calculationPerioDates\effectiveDate and the
    swap\swapStream\calculationPerioDates\terminationDate."""
    member_data_items_ = {
        'weeklyRollConvention': MemberSpec_('weeklyRollConvention', ['WeeklyRollConventionEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = Frequency
    def __init__(self, id=None, periodMultiplier=None, period=None, weeklyRollConvention=None):
        self.original_tagname_ = None
        super(ResetFrequency, self).__init__(id, periodMultiplier, period, )
        self.weeklyRollConvention = weeklyRollConvention
        self.validate_WeeklyRollConventionEnum(self.weeklyRollConvention)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResetFrequency)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResetFrequency.subclass:
            return ResetFrequency.subclass(*args_, **kwargs_)
        else:
            return ResetFrequency(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_weeklyRollConvention(self): return self.weeklyRollConvention
    def set_weeklyRollConvention(self, weeklyRollConvention): self.weeklyRollConvention = weeklyRollConvention
    def validate_WeeklyRollConventionEnum(self, value):
        # Validate type WeeklyRollConventionEnum, a restriction on Token.
        pass
    def hasContent_(self):
        if (
            self.weeklyRollConvention is not None or
            super(ResetFrequency, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ResetFrequency', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResetFrequency')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ResetFrequency', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ResetFrequency'):
        super(ResetFrequency, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ResetFrequency')
    def exportChildren(self, outfile, level, namespace_='', name_='ResetFrequency', fromsubclass_=False, pretty_print=True):
        super(ResetFrequency, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.weeklyRollConvention is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sweeklyRollConvention>%s</%sweeklyRollConvention>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.weeklyRollConvention), input_name='weeklyRollConvention')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ResetFrequency, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'weeklyRollConvention':
            weeklyRollConvention_ = child_.text
            weeklyRollConvention_ = re_.sub(String_cleanup_pat_, " ", weeklyRollConvention_).strip()
            weeklyRollConvention_ = self.gds_validate_string(weeklyRollConvention_, node, 'weeklyRollConvention')
            self.weeklyRollConvention = weeklyRollConvention_
            # validate type WeeklyRollConventionEnum
            self.validate_WeeklyRollConventionEnum(self.weeklyRollConvention)
        super(ResetFrequency, self).buildChildren(child_, node, nodeName_, True)
# end class ResetFrequency


class Resource(GeneratedsSuper):
    """Describes the resource that contains the media representation of a
    business event (i.e used for stating the Publicly Available
    Information). For example, can describe a file or a URL that
    represents the event. This type is an extended version of a type
    defined by RIXML (www.rixml.org)."""
    member_data_items_ = {
        'resourceId': MemberSpec_('resourceId', 'ResourceId', 0),
        'resourceType': MemberSpec_('resourceType', 'ResourceType', 0),
        'language': MemberSpec_('language', 'Language', 0),
        'sizeInBytes': MemberSpec_('sizeInBytes', 'xsd:decimal', 0),
        'length': MemberSpec_('length', 'ResourceLength', 0),
        'mimeType': MemberSpec_('mimeType', 'MimeType', 0),
        'name': MemberSpec_('name', ['NormalizedString', 'xsd:normalizedString'], 0),
        'comments': MemberSpec_('comments', ['String', 'xsd:string'], 0),
        'string': MemberSpec_('string', ['String', 'xsd:string'], 0),
        'hexadecimalBinary': MemberSpec_('hexadecimalBinary', 'xsd:hexBinary', 0),
        'base64Binary': MemberSpec_('base64Binary', 'xsd:base64Binary', 0),
        'url': MemberSpec_('url', ['NonEmptyURI', 'xsd:anyURI'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, resourceId=None, resourceType=None, language=None, sizeInBytes=None, length=None, mimeType=None, name=None, comments=None, string=None, hexadecimalBinary=None, base64Binary=None, url=None):
        self.original_tagname_ = None
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.language = language
        self.sizeInBytes = sizeInBytes
        self.length = length
        self.mimeType = mimeType
        self.name = name
        self.validate_NormalizedString(self.name)
        self.comments = comments
        self.validate_String(self.comments)
        self.string = string
        self.validate_String(self.string)
        self.hexadecimalBinary = hexadecimalBinary
        self.base64Binary = base64Binary
        self.url = url
        self.validate_NonEmptyURI(self.url)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Resource)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Resource.subclass:
            return Resource.subclass(*args_, **kwargs_)
        else:
            return Resource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_resourceId(self): return self.resourceId
    def set_resourceId(self, resourceId): self.resourceId = resourceId
    def get_resourceType(self): return self.resourceType
    def set_resourceType(self, resourceType): self.resourceType = resourceType
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def get_sizeInBytes(self): return self.sizeInBytes
    def set_sizeInBytes(self, sizeInBytes): self.sizeInBytes = sizeInBytes
    def get_length(self): return self.length
    def set_length(self, length): self.length = length
    def get_mimeType(self): return self.mimeType
    def set_mimeType(self, mimeType): self.mimeType = mimeType
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_comments(self): return self.comments
    def set_comments(self, comments): self.comments = comments
    def get_string(self): return self.string
    def set_string(self, string): self.string = string
    def get_hexadecimalBinary(self): return self.hexadecimalBinary
    def set_hexadecimalBinary(self, hexadecimalBinary): self.hexadecimalBinary = hexadecimalBinary
    def get_base64Binary(self): return self.base64Binary
    def set_base64Binary(self, base64Binary): self.base64Binary = base64Binary
    def get_url(self): return self.url
    def set_url(self, url): self.url = url
    def validate_NormalizedString(self, value):
        # Validate type NormalizedString, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NormalizedString' % {"value" : value} )
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            self.resourceId is not None or
            self.resourceType is not None or
            self.language is not None or
            self.sizeInBytes is not None or
            self.length is not None or
            self.mimeType is not None or
            self.name is not None or
            self.comments is not None or
            self.string is not None or
            self.hexadecimalBinary is not None or
            self.base64Binary is not None or
            self.url is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Resource', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Resource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Resource', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Resource'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Resource', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.resourceId is not None:
            self.resourceId.export(outfile, level, namespace_, name_='resourceId', pretty_print=pretty_print)
        if self.resourceType is not None:
            self.resourceType.export(outfile, level, namespace_, name_='resourceType', pretty_print=pretty_print)
        if self.language is not None:
            self.language.export(outfile, level, namespace_, name_='language', pretty_print=pretty_print)
        if self.sizeInBytes is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssizeInBytes>%s</%ssizeInBytes>%s' % (namespace_, self.gds_format_float(self.sizeInBytes, input_name='sizeInBytes'), namespace_, eol_))
        if self.length is not None:
            self.length.export(outfile, level, namespace_, name_='length', pretty_print=pretty_print)
        if self.mimeType is not None:
            self.mimeType.export(outfile, level, namespace_, name_='mimeType', pretty_print=pretty_print)
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespace_, eol_))
        if self.comments is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomments>%s</%scomments>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.comments), input_name='comments')), namespace_, eol_))
        if self.string is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstring>%s</%sstring>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.string), input_name='string')), namespace_, eol_))
        if self.hexadecimalBinary is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shexadecimalBinary>%s</%shexadecimalBinary>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.hexadecimalBinary), input_name='hexadecimalBinary')), namespace_, eol_))
        if self.base64Binary is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbase64Binary>%s</%sbase64Binary>%s' % (namespace_, self.gds_format_base64(self.base64Binary, input_name='base64Binary'), namespace_, eol_))
        if self.url is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%surl>%s</%surl>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.url), input_name='url')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'resourceId':
            obj_ = ResourceId.factory()
            obj_.build(child_)
            self.resourceId = obj_
            obj_.original_tagname_ = 'resourceId'
        elif nodeName_ == 'resourceType':
            obj_ = ResourceType.factory()
            obj_.build(child_)
            self.resourceType = obj_
            obj_.original_tagname_ = 'resourceType'
        elif nodeName_ == 'language':
            obj_ = Language.factory()
            obj_.build(child_)
            self.language = obj_
            obj_.original_tagname_ = 'language'
        elif nodeName_ == 'sizeInBytes':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'sizeInBytes')
            self.sizeInBytes = fval_
        elif nodeName_ == 'length':
            obj_ = ResourceLength.factory()
            obj_.build(child_)
            self.length = obj_
            obj_.original_tagname_ = 'length'
        elif nodeName_ == 'mimeType':
            obj_ = MimeType.factory()
            obj_.build(child_)
            self.mimeType = obj_
            obj_.original_tagname_ = 'mimeType'
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
            # validate type NormalizedString
            self.validate_NormalizedString(self.name)
        elif nodeName_ == 'comments':
            comments_ = child_.text
            comments_ = self.gds_validate_string(comments_, node, 'comments')
            self.comments = comments_
            # validate type String
            self.validate_String(self.comments)
        elif nodeName_ == 'string':
            string_ = child_.text
            string_ = self.gds_validate_string(string_, node, 'string')
            self.string = string_
            # validate type String
            self.validate_String(self.string)
        elif nodeName_ == 'hexadecimalBinary':
            hexadecimalBinary_ = child_.text
            hexadecimalBinary_ = self.gds_validate_string(hexadecimalBinary_, node, 'hexadecimalBinary')
            self.hexadecimalBinary = hexadecimalBinary_
        elif nodeName_ == 'base64Binary':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'base64Binary')
            else:
                bval_ = None
            self.base64Binary = bval_
        elif nodeName_ == 'url':
            url_ = child_.text
            url_ = self.gds_validate_string(url_, node, 'url')
            self.url = url_
            # validate type NonEmptyURI
            self.validate_NonEmptyURI(self.url)
# end class Resource


class ResourceId(GeneratedsSuper):
    """The data type used for resource identifiers."""
    member_data_items_ = {
        'resourceIdScheme': MemberSpec_('resourceIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, resourceIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.resourceIdScheme = _cast(None, resourceIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResourceId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResourceId.subclass:
            return ResourceId.subclass(*args_, **kwargs_)
        else:
            return ResourceId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_resourceIdScheme(self): return self.resourceIdScheme
    def set_resourceIdScheme(self, resourceIdScheme): self.resourceIdScheme = resourceIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ResourceId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResourceId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ResourceId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ResourceId'):
        if self.resourceIdScheme is not None and 'resourceIdScheme' not in already_processed:
            already_processed.add('resourceIdScheme')
            outfile.write(' resourceIdScheme=%s' % (quote_attrib(self.resourceIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ResourceId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('resourceIdScheme', node)
        if value is not None and 'resourceIdScheme' not in already_processed:
            already_processed.add('resourceIdScheme')
            self.resourceIdScheme = value
            self.validate_NonEmptyURI(self.resourceIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ResourceId


class ResourceLength(GeneratedsSuper):
    """The type that indicates the length of the resource."""
    member_data_items_ = {
        'lengthUnit': MemberSpec_('lengthUnit', ['LengthUnitEnum', 'Token', 'xsd:token'], 0),
        'lengthValue': MemberSpec_('lengthValue', 'xsd:decimal', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, lengthUnit=None, lengthValue=None):
        self.original_tagname_ = None
        self.lengthUnit = lengthUnit
        self.validate_LengthUnitEnum(self.lengthUnit)
        self.lengthValue = lengthValue
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResourceLength)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResourceLength.subclass:
            return ResourceLength.subclass(*args_, **kwargs_)
        else:
            return ResourceLength(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lengthUnit(self): return self.lengthUnit
    def set_lengthUnit(self, lengthUnit): self.lengthUnit = lengthUnit
    def get_lengthValue(self): return self.lengthValue
    def set_lengthValue(self, lengthValue): self.lengthValue = lengthValue
    def validate_LengthUnitEnum(self, value):
        # Validate type LengthUnitEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Pages', 'TimeUnit']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on LengthUnitEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on LengthUnitEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.lengthUnit is not None or
            self.lengthValue is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ResourceLength', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResourceLength')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ResourceLength', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ResourceLength'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ResourceLength', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.lengthUnit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slengthUnit>%s</%slengthUnit>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.lengthUnit), input_name='lengthUnit')), namespace_, eol_))
        if self.lengthValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slengthValue>%s</%slengthValue>%s' % (namespace_, self.gds_format_float(self.lengthValue, input_name='lengthValue'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'lengthUnit':
            lengthUnit_ = child_.text
            lengthUnit_ = re_.sub(String_cleanup_pat_, " ", lengthUnit_).strip()
            lengthUnit_ = self.gds_validate_string(lengthUnit_, node, 'lengthUnit')
            self.lengthUnit = lengthUnit_
            # validate type LengthUnitEnum
            self.validate_LengthUnitEnum(self.lengthUnit)
        elif nodeName_ == 'lengthValue':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'lengthValue')
            self.lengthValue = fval_
# end class ResourceLength


class ResourceType(GeneratedsSuper):
    """The data type used for describing the type or purpose of a resource,
    e.g. "Confirmation"."""
    member_data_items_ = {
        'resourceTypeScheme': MemberSpec_('resourceTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, resourceTypeScheme='http://www.fpml.org/coding-scheme/resource-type', valueOf_=None):
        self.original_tagname_ = None
        self.resourceTypeScheme = _cast(None, resourceTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResourceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResourceType.subclass:
            return ResourceType.subclass(*args_, **kwargs_)
        else:
            return ResourceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_resourceTypeScheme(self): return self.resourceTypeScheme
    def set_resourceTypeScheme(self, resourceTypeScheme): self.resourceTypeScheme = resourceTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ResourceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResourceType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ResourceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ResourceType'):
        if self.resourceTypeScheme != "http://www.fpml.org/coding-scheme/resource-type" and 'resourceTypeScheme' not in already_processed:
            already_processed.add('resourceTypeScheme')
            outfile.write(' resourceTypeScheme=%s' % (quote_attrib(self.resourceTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ResourceType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('resourceTypeScheme', node)
        if value is not None and 'resourceTypeScheme' not in already_processed:
            already_processed.add('resourceTypeScheme')
            self.resourceTypeScheme = value
            self.validate_NonEmptyURI(self.resourceTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ResourceType


class ReturnSwapNotionalAmountReference(Reference):
    """A reference to the return swap notional amount."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(ReturnSwapNotionalAmountReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReturnSwapNotionalAmountReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReturnSwapNotionalAmountReference.subclass:
            return ReturnSwapNotionalAmountReference.subclass(*args_, **kwargs_)
        else:
            return ReturnSwapNotionalAmountReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(ReturnSwapNotionalAmountReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReturnSwapNotionalAmountReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReturnSwapNotionalAmountReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReturnSwapNotionalAmountReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReturnSwapNotionalAmountReference'):
        super(ReturnSwapNotionalAmountReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ReturnSwapNotionalAmountReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ReturnSwapNotionalAmountReference', fromsubclass_=False, pretty_print=True):
        super(ReturnSwapNotionalAmountReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(ReturnSwapNotionalAmountReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ReturnSwapNotionalAmountReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ReturnSwapNotionalAmountReference


class Rounding(GeneratedsSuper):
    """A type defining a rounding direction and precision to be used in the
    rounding of a rate."""
    member_data_items_ = {
        'roundingDirection': MemberSpec_('roundingDirection', ['RoundingDirectionEnum', 'Token', 'xsd:token'], 0),
        'precision': MemberSpec_('precision', 'xsd:nonNegativeInteger', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, roundingDirection=None, precision=None):
        self.original_tagname_ = None
        self.roundingDirection = roundingDirection
        self.validate_RoundingDirectionEnum(self.roundingDirection)
        self.precision = precision
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Rounding)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Rounding.subclass:
            return Rounding.subclass(*args_, **kwargs_)
        else:
            return Rounding(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_roundingDirection(self): return self.roundingDirection
    def set_roundingDirection(self, roundingDirection): self.roundingDirection = roundingDirection
    def get_precision(self): return self.precision
    def set_precision(self, precision): self.precision = precision
    def validate_RoundingDirectionEnum(self, value):
        # Validate type RoundingDirectionEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Up', 'Down', 'Nearest']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RoundingDirectionEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on RoundingDirectionEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.roundingDirection is not None or
            self.precision is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Rounding', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Rounding')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Rounding', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Rounding'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Rounding', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.roundingDirection is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sroundingDirection>%s</%sroundingDirection>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.roundingDirection), input_name='roundingDirection')), namespace_, eol_))
        if self.precision is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprecision>%s</%sprecision>%s' % (namespace_, self.gds_format_integer(self.precision, input_name='precision'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'roundingDirection':
            roundingDirection_ = child_.text
            roundingDirection_ = re_.sub(String_cleanup_pat_, " ", roundingDirection_).strip()
            roundingDirection_ = self.gds_validate_string(roundingDirection_, node, 'roundingDirection')
            self.roundingDirection = roundingDirection_
            # validate type RoundingDirectionEnum
            self.validate_RoundingDirectionEnum(self.roundingDirection)
        elif nodeName_ == 'precision':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'precision')
            self.precision = ival_
# end class Rounding


class Routing(GeneratedsSuper):
    """A type that provides three alternative ways of identifying a party
    involved in the routing of a payment. The identification may use
    payment system identifiers only; actual name, address and other
    reference information; or a combination of both."""
    member_data_items_ = {
        'routingIds': MemberSpec_('routingIds', 'RoutingIds', 0),
        'routingExplicitDetails': MemberSpec_('routingExplicitDetails', 'RoutingExplicitDetails', 0),
        'routingIdsAndExplicitDetails': MemberSpec_('routingIdsAndExplicitDetails', 'RoutingIdsAndExplicitDetails', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, routingIds=None, routingExplicitDetails=None, routingIdsAndExplicitDetails=None):
        self.original_tagname_ = None
        self.routingIds = routingIds
        self.routingExplicitDetails = routingExplicitDetails
        self.routingIdsAndExplicitDetails = routingIdsAndExplicitDetails
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Routing)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Routing.subclass:
            return Routing.subclass(*args_, **kwargs_)
        else:
            return Routing(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_routingIds(self): return self.routingIds
    def set_routingIds(self, routingIds): self.routingIds = routingIds
    def get_routingExplicitDetails(self): return self.routingExplicitDetails
    def set_routingExplicitDetails(self, routingExplicitDetails): self.routingExplicitDetails = routingExplicitDetails
    def get_routingIdsAndExplicitDetails(self): return self.routingIdsAndExplicitDetails
    def set_routingIdsAndExplicitDetails(self, routingIdsAndExplicitDetails): self.routingIdsAndExplicitDetails = routingIdsAndExplicitDetails
    def hasContent_(self):
        if (
            self.routingIds is not None or
            self.routingExplicitDetails is not None or
            self.routingIdsAndExplicitDetails is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Routing', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Routing')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Routing', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Routing'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Routing', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.routingIds is not None:
            self.routingIds.export(outfile, level, namespace_, name_='routingIds', pretty_print=pretty_print)
        if self.routingExplicitDetails is not None:
            self.routingExplicitDetails.export(outfile, level, namespace_, name_='routingExplicitDetails', pretty_print=pretty_print)
        if self.routingIdsAndExplicitDetails is not None:
            self.routingIdsAndExplicitDetails.export(outfile, level, namespace_, name_='routingIdsAndExplicitDetails', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'routingIds':
            obj_ = RoutingIds.factory()
            obj_.build(child_)
            self.routingIds = obj_
            obj_.original_tagname_ = 'routingIds'
        elif nodeName_ == 'routingExplicitDetails':
            obj_ = RoutingExplicitDetails.factory()
            obj_.build(child_)
            self.routingExplicitDetails = obj_
            obj_.original_tagname_ = 'routingExplicitDetails'
        elif nodeName_ == 'routingIdsAndExplicitDetails':
            obj_ = RoutingIdsAndExplicitDetails.factory()
            obj_.build(child_)
            self.routingIdsAndExplicitDetails = obj_
            obj_.original_tagname_ = 'routingIdsAndExplicitDetails'
# end class Routing


class RoutingExplicitDetails(GeneratedsSuper):
    """A type that models name, address and supplementary textual
    information for the purposes of identifying a party involved in
    the routing of a payment."""
    member_data_items_ = {
        'routingName': MemberSpec_('routingName', ['String', 'xsd:string'], 0),
        'routingAddress': MemberSpec_('routingAddress', 'Address', 0),
        'routingAccountNumber': MemberSpec_('routingAccountNumber', ['String', 'xsd:string'], 0),
        'routingReferenceText': MemberSpec_('routingReferenceText', ['String', 'xsd:string'], 1),
    }
    subclass = None
    superclass = None
    def __init__(self, routingName=None, routingAddress=None, routingAccountNumber=None, routingReferenceText=None):
        self.original_tagname_ = None
        self.routingName = routingName
        self.validate_String(self.routingName)
        self.routingAddress = routingAddress
        self.routingAccountNumber = routingAccountNumber
        self.validate_String(self.routingAccountNumber)
        if routingReferenceText is None:
            self.routingReferenceText = []
        else:
            self.routingReferenceText = routingReferenceText
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RoutingExplicitDetails)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RoutingExplicitDetails.subclass:
            return RoutingExplicitDetails.subclass(*args_, **kwargs_)
        else:
            return RoutingExplicitDetails(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_routingName(self): return self.routingName
    def set_routingName(self, routingName): self.routingName = routingName
    def get_routingAddress(self): return self.routingAddress
    def set_routingAddress(self, routingAddress): self.routingAddress = routingAddress
    def get_routingAccountNumber(self): return self.routingAccountNumber
    def set_routingAccountNumber(self, routingAccountNumber): self.routingAccountNumber = routingAccountNumber
    def get_routingReferenceText(self): return self.routingReferenceText
    def set_routingReferenceText(self, routingReferenceText): self.routingReferenceText = routingReferenceText
    def add_routingReferenceText(self, value): self.routingReferenceText.append(value)
    def insert_routingReferenceText_at(self, index, value): self.routingReferenceText.insert(index, value)
    def replace_routingReferenceText_at(self, index, value): self.routingReferenceText[index] = value
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.routingName is not None or
            self.routingAddress is not None or
            self.routingAccountNumber is not None or
            self.routingReferenceText
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RoutingExplicitDetails', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RoutingExplicitDetails')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RoutingExplicitDetails', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RoutingExplicitDetails'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RoutingExplicitDetails', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.routingName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sroutingName>%s</%sroutingName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.routingName), input_name='routingName')), namespace_, eol_))
        if self.routingAddress is not None:
            self.routingAddress.export(outfile, level, namespace_, name_='routingAddress', pretty_print=pretty_print)
        if self.routingAccountNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sroutingAccountNumber>%s</%sroutingAccountNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.routingAccountNumber), input_name='routingAccountNumber')), namespace_, eol_))
        for routingReferenceText_ in self.routingReferenceText:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sroutingReferenceText>%s</%sroutingReferenceText>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(routingReferenceText_), input_name='routingReferenceText')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'routingName':
            routingName_ = child_.text
            routingName_ = self.gds_validate_string(routingName_, node, 'routingName')
            self.routingName = routingName_
            # validate type String
            self.validate_String(self.routingName)
        elif nodeName_ == 'routingAddress':
            obj_ = Address.factory()
            obj_.build(child_)
            self.routingAddress = obj_
            obj_.original_tagname_ = 'routingAddress'
        elif nodeName_ == 'routingAccountNumber':
            routingAccountNumber_ = child_.text
            routingAccountNumber_ = self.gds_validate_string(routingAccountNumber_, node, 'routingAccountNumber')
            self.routingAccountNumber = routingAccountNumber_
            # validate type String
            self.validate_String(self.routingAccountNumber)
        elif nodeName_ == 'routingReferenceText':
            routingReferenceText_ = child_.text
            routingReferenceText_ = self.gds_validate_string(routingReferenceText_, node, 'routingReferenceText')
            self.routingReferenceText.append(routingReferenceText_)
            # validate type String
            self.validate_String(self.routingReferenceText[-1])
# end class RoutingExplicitDetails


class RoutingId(GeneratedsSuper):
    member_data_items_ = {
        'routingIdCodeScheme': MemberSpec_('routingIdCodeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, routingIdCodeScheme='http://www.fpml.org/coding-scheme/external/iso9362', valueOf_=None):
        self.original_tagname_ = None
        self.routingIdCodeScheme = _cast(None, routingIdCodeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RoutingId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RoutingId.subclass:
            return RoutingId.subclass(*args_, **kwargs_)
        else:
            return RoutingId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_routingIdCodeScheme(self): return self.routingIdCodeScheme
    def set_routingIdCodeScheme(self, routingIdCodeScheme): self.routingIdCodeScheme = routingIdCodeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RoutingId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RoutingId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RoutingId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RoutingId'):
        if self.routingIdCodeScheme != "http://www.fpml.org/coding-scheme/external/iso9362" and 'routingIdCodeScheme' not in already_processed:
            already_processed.add('routingIdCodeScheme')
            outfile.write(' routingIdCodeScheme=%s' % (quote_attrib(self.routingIdCodeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RoutingId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('routingIdCodeScheme', node)
        if value is not None and 'routingIdCodeScheme' not in already_processed:
            already_processed.add('routingIdCodeScheme')
            self.routingIdCodeScheme = value
            self.validate_NonEmptyURI(self.routingIdCodeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RoutingId


class RoutingIds(GeneratedsSuper):
    """A type that provides for identifying a party involved in the routing
    of a payment by means of one or more standard identification
    codes. For example, both a SWIFT BIC code and a national bank
    identifier may be required."""
    member_data_items_ = {
        'routingId': MemberSpec_('routingId', 'RoutingId', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, routingId=None):
        self.original_tagname_ = None
        if routingId is None:
            self.routingId = []
        else:
            self.routingId = routingId
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RoutingIds)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RoutingIds.subclass:
            return RoutingIds.subclass(*args_, **kwargs_)
        else:
            return RoutingIds(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_routingId(self): return self.routingId
    def set_routingId(self, routingId): self.routingId = routingId
    def add_routingId(self, value): self.routingId.append(value)
    def insert_routingId_at(self, index, value): self.routingId.insert(index, value)
    def replace_routingId_at(self, index, value): self.routingId[index] = value
    def hasContent_(self):
        if (
            self.routingId
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RoutingIds', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RoutingIds')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RoutingIds', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RoutingIds'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RoutingIds', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for routingId_ in self.routingId:
            routingId_.export(outfile, level, namespace_, name_='routingId', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'routingId':
            obj_ = RoutingId.factory()
            obj_.build(child_)
            self.routingId.append(obj_)
            obj_.original_tagname_ = 'routingId'
# end class RoutingIds


class RoutingIdsAndExplicitDetails(GeneratedsSuper):
    """A type that provides a combination of payment system identification
    codes with physical postal address details, for the purposes of
    identifying a party involved in the routing of a payment."""
    member_data_items_ = {
        'routingIds': MemberSpec_('routingIds', 'RoutingIds', 1),
        'routingName': MemberSpec_('routingName', ['String', 'xsd:string'], 0),
        'routingAddress': MemberSpec_('routingAddress', 'Address', 0),
        'routingAccountNumber': MemberSpec_('routingAccountNumber', ['String', 'xsd:string'], 0),
        'routingReferenceText': MemberSpec_('routingReferenceText', ['String', 'xsd:string'], 1),
    }
    subclass = None
    superclass = None
    def __init__(self, routingIds=None, routingName=None, routingAddress=None, routingAccountNumber=None, routingReferenceText=None):
        self.original_tagname_ = None
        if routingIds is None:
            self.routingIds = []
        else:
            self.routingIds = routingIds
        self.routingName = routingName
        self.validate_String(self.routingName)
        self.routingAddress = routingAddress
        self.routingAccountNumber = routingAccountNumber
        self.validate_String(self.routingAccountNumber)
        if routingReferenceText is None:
            self.routingReferenceText = []
        else:
            self.routingReferenceText = routingReferenceText
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RoutingIdsAndExplicitDetails)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RoutingIdsAndExplicitDetails.subclass:
            return RoutingIdsAndExplicitDetails.subclass(*args_, **kwargs_)
        else:
            return RoutingIdsAndExplicitDetails(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_routingIds(self): return self.routingIds
    def set_routingIds(self, routingIds): self.routingIds = routingIds
    def add_routingIds(self, value): self.routingIds.append(value)
    def insert_routingIds_at(self, index, value): self.routingIds.insert(index, value)
    def replace_routingIds_at(self, index, value): self.routingIds[index] = value
    def get_routingName(self): return self.routingName
    def set_routingName(self, routingName): self.routingName = routingName
    def get_routingAddress(self): return self.routingAddress
    def set_routingAddress(self, routingAddress): self.routingAddress = routingAddress
    def get_routingAccountNumber(self): return self.routingAccountNumber
    def set_routingAccountNumber(self, routingAccountNumber): self.routingAccountNumber = routingAccountNumber
    def get_routingReferenceText(self): return self.routingReferenceText
    def set_routingReferenceText(self, routingReferenceText): self.routingReferenceText = routingReferenceText
    def add_routingReferenceText(self, value): self.routingReferenceText.append(value)
    def insert_routingReferenceText_at(self, index, value): self.routingReferenceText.insert(index, value)
    def replace_routingReferenceText_at(self, index, value): self.routingReferenceText[index] = value
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.routingIds or
            self.routingName is not None or
            self.routingAddress is not None or
            self.routingAccountNumber is not None or
            self.routingReferenceText
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RoutingIdsAndExplicitDetails', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RoutingIdsAndExplicitDetails')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RoutingIdsAndExplicitDetails', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RoutingIdsAndExplicitDetails'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RoutingIdsAndExplicitDetails', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for routingIds_ in self.routingIds:
            routingIds_.export(outfile, level, namespace_, name_='routingIds', pretty_print=pretty_print)
        if self.routingName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sroutingName>%s</%sroutingName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.routingName), input_name='routingName')), namespace_, eol_))
        if self.routingAddress is not None:
            self.routingAddress.export(outfile, level, namespace_, name_='routingAddress', pretty_print=pretty_print)
        if self.routingAccountNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sroutingAccountNumber>%s</%sroutingAccountNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.routingAccountNumber), input_name='routingAccountNumber')), namespace_, eol_))
        for routingReferenceText_ in self.routingReferenceText:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sroutingReferenceText>%s</%sroutingReferenceText>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(routingReferenceText_), input_name='routingReferenceText')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'routingIds':
            obj_ = RoutingIds.factory()
            obj_.build(child_)
            self.routingIds.append(obj_)
            obj_.original_tagname_ = 'routingIds'
        elif nodeName_ == 'routingName':
            routingName_ = child_.text
            routingName_ = self.gds_validate_string(routingName_, node, 'routingName')
            self.routingName = routingName_
            # validate type String
            self.validate_String(self.routingName)
        elif nodeName_ == 'routingAddress':
            obj_ = Address.factory()
            obj_.build(child_)
            self.routingAddress = obj_
            obj_.original_tagname_ = 'routingAddress'
        elif nodeName_ == 'routingAccountNumber':
            routingAccountNumber_ = child_.text
            routingAccountNumber_ = self.gds_validate_string(routingAccountNumber_, node, 'routingAccountNumber')
            self.routingAccountNumber = routingAccountNumber_
            # validate type String
            self.validate_String(self.routingAccountNumber)
        elif nodeName_ == 'routingReferenceText':
            routingReferenceText_ = child_.text
            routingReferenceText_ = self.gds_validate_string(routingReferenceText_, node, 'routingReferenceText')
            self.routingReferenceText.append(routingReferenceText_)
            # validate type String
            self.validate_String(self.routingReferenceText[-1])
# end class RoutingIdsAndExplicitDetails


class Schedule(GeneratedsSuper):
    """A type defining a schedule of rates or amounts in terms of an
    initial value and then a series of step date and value pairs. On
    each step date the rate or amount changes to the new step value.
    The series of step date and value pairs are optional. If not
    specified, this implies that the initial value remains unchanged
    over time."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'initialValue': MemberSpec_('initialValue', 'xsd:decimal', 0),
        'step': MemberSpec_('step', 'Step', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, initialValue=None, step=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.initialValue = initialValue
        if step is None:
            self.step = []
        else:
            self.step = step
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Schedule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Schedule.subclass:
            return Schedule.subclass(*args_, **kwargs_)
        else:
            return Schedule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_initialValue(self): return self.initialValue
    def set_initialValue(self, initialValue): self.initialValue = initialValue
    def get_step(self): return self.step
    def set_step(self, step): self.step = step
    def add_step(self, value): self.step.append(value)
    def insert_step_at(self, index, value): self.step.insert(index, value)
    def replace_step_at(self, index, value): self.step[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.initialValue is not None or
            self.step
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Schedule', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Schedule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Schedule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Schedule'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Schedule', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.initialValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinitialValue>%s</%sinitialValue>%s' % (namespace_, self.gds_format_float(self.initialValue, input_name='initialValue'), namespace_, eol_))
        for step_ in self.step:
            step_.export(outfile, level, namespace_, name_='step', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'initialValue':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'initialValue')
            self.initialValue = fval_
        elif nodeName_ == 'step':
            obj_ = Step.factory()
            obj_.build(child_)
            self.step.append(obj_)
            obj_.original_tagname_ = 'step'
# end class Schedule


class ScheduleReference(Reference):
    """Reference to a schedule of rates or amounts."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(ScheduleReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ScheduleReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ScheduleReference.subclass:
            return ScheduleReference.subclass(*args_, **kwargs_)
        else:
            return ScheduleReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(ScheduleReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ScheduleReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ScheduleReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ScheduleReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ScheduleReference'):
        super(ScheduleReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ScheduleReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ScheduleReference', fromsubclass_=False, pretty_print=True):
        super(ScheduleReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(ScheduleReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ScheduleReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ScheduleReference


class SettlementInformation(GeneratedsSuper):
    """A type that represents the choice of methods for settling a
    potential currency payment resulting from a trade: by means of a
    standard settlement instruction, by netting it out with other
    payments, or with an explicit settlement instruction."""
    member_data_items_ = {
        'standardSettlementStyle': MemberSpec_('standardSettlementStyle', ['StandardSettlementStyleEnum', 'Token', 'xsd:token'], 0),
        'settlementInstruction': MemberSpec_('settlementInstruction', 'SettlementInstruction', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, standardSettlementStyle=None, settlementInstruction=None):
        self.original_tagname_ = None
        self.standardSettlementStyle = standardSettlementStyle
        self.validate_StandardSettlementStyleEnum(self.standardSettlementStyle)
        self.settlementInstruction = settlementInstruction
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SettlementInformation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SettlementInformation.subclass:
            return SettlementInformation.subclass(*args_, **kwargs_)
        else:
            return SettlementInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_standardSettlementStyle(self): return self.standardSettlementStyle
    def set_standardSettlementStyle(self, standardSettlementStyle): self.standardSettlementStyle = standardSettlementStyle
    def get_settlementInstruction(self): return self.settlementInstruction
    def set_settlementInstruction(self, settlementInstruction): self.settlementInstruction = settlementInstruction
    def validate_StandardSettlementStyleEnum(self, value):
        # Validate type StandardSettlementStyleEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Standard', 'Net', 'StandardAndNet']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on StandardSettlementStyleEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on StandardSettlementStyleEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.standardSettlementStyle is not None or
            self.settlementInstruction is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SettlementInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SettlementInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SettlementInformation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SettlementInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SettlementInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.standardSettlementStyle is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstandardSettlementStyle>%s</%sstandardSettlementStyle>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.standardSettlementStyle), input_name='standardSettlementStyle')), namespace_, eol_))
        if self.settlementInstruction is not None:
            self.settlementInstruction.export(outfile, level, namespace_, name_='settlementInstruction', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'standardSettlementStyle':
            standardSettlementStyle_ = child_.text
            standardSettlementStyle_ = re_.sub(String_cleanup_pat_, " ", standardSettlementStyle_).strip()
            standardSettlementStyle_ = self.gds_validate_string(standardSettlementStyle_, node, 'standardSettlementStyle')
            self.standardSettlementStyle = standardSettlementStyle_
            # validate type StandardSettlementStyleEnum
            self.validate_StandardSettlementStyleEnum(self.standardSettlementStyle)
        elif nodeName_ == 'settlementInstruction':
            obj_ = SettlementInstruction.factory()
            obj_.build(child_)
            self.settlementInstruction = obj_
            obj_.original_tagname_ = 'settlementInstruction'
# end class SettlementInformation


class SettlementInstruction(GeneratedsSuper):
    """A type that models a complete instruction for settling a currency
    payment, including the settlement method to be used, the
    correspondent bank, any intermediary banks and the ultimate
    beneficary."""
    member_data_items_ = {
        'settlementMethod': MemberSpec_('settlementMethod', 'SettlementMethod', 0),
        'correspondentInformation': MemberSpec_('correspondentInformation', 'CorrespondentInformation', 0),
        'intermediaryInformation': MemberSpec_('intermediaryInformation', 'IntermediaryInformation', 1),
        'beneficiaryBank': MemberSpec_('beneficiaryBank', 'Beneficiary', 0),
        'beneficiary': MemberSpec_('beneficiary', 'Beneficiary', 0),
        'depositoryPartyReference': MemberSpec_('depositoryPartyReference', 'PartyReference', 0),
        'splitSettlement': MemberSpec_('splitSettlement', 'SplitSettlement', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, settlementMethod=None, correspondentInformation=None, intermediaryInformation=None, beneficiaryBank=None, beneficiary=None, depositoryPartyReference=None, splitSettlement=None):
        self.original_tagname_ = None
        self.settlementMethod = settlementMethod
        self.correspondentInformation = correspondentInformation
        if intermediaryInformation is None:
            self.intermediaryInformation = []
        else:
            self.intermediaryInformation = intermediaryInformation
        self.beneficiaryBank = beneficiaryBank
        self.beneficiary = beneficiary
        self.depositoryPartyReference = depositoryPartyReference
        if splitSettlement is None:
            self.splitSettlement = []
        else:
            self.splitSettlement = splitSettlement
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SettlementInstruction)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SettlementInstruction.subclass:
            return SettlementInstruction.subclass(*args_, **kwargs_)
        else:
            return SettlementInstruction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_settlementMethod(self): return self.settlementMethod
    def set_settlementMethod(self, settlementMethod): self.settlementMethod = settlementMethod
    def get_correspondentInformation(self): return self.correspondentInformation
    def set_correspondentInformation(self, correspondentInformation): self.correspondentInformation = correspondentInformation
    def get_intermediaryInformation(self): return self.intermediaryInformation
    def set_intermediaryInformation(self, intermediaryInformation): self.intermediaryInformation = intermediaryInformation
    def add_intermediaryInformation(self, value): self.intermediaryInformation.append(value)
    def insert_intermediaryInformation_at(self, index, value): self.intermediaryInformation.insert(index, value)
    def replace_intermediaryInformation_at(self, index, value): self.intermediaryInformation[index] = value
    def get_beneficiaryBank(self): return self.beneficiaryBank
    def set_beneficiaryBank(self, beneficiaryBank): self.beneficiaryBank = beneficiaryBank
    def get_beneficiary(self): return self.beneficiary
    def set_beneficiary(self, beneficiary): self.beneficiary = beneficiary
    def get_depositoryPartyReference(self): return self.depositoryPartyReference
    def set_depositoryPartyReference(self, depositoryPartyReference): self.depositoryPartyReference = depositoryPartyReference
    def get_splitSettlement(self): return self.splitSettlement
    def set_splitSettlement(self, splitSettlement): self.splitSettlement = splitSettlement
    def add_splitSettlement(self, value): self.splitSettlement.append(value)
    def insert_splitSettlement_at(self, index, value): self.splitSettlement.insert(index, value)
    def replace_splitSettlement_at(self, index, value): self.splitSettlement[index] = value
    def hasContent_(self):
        if (
            self.settlementMethod is not None or
            self.correspondentInformation is not None or
            self.intermediaryInformation or
            self.beneficiaryBank is not None or
            self.beneficiary is not None or
            self.depositoryPartyReference is not None or
            self.splitSettlement
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SettlementInstruction', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SettlementInstruction')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SettlementInstruction', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SettlementInstruction'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SettlementInstruction', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.settlementMethod is not None:
            self.settlementMethod.export(outfile, level, namespace_, name_='settlementMethod', pretty_print=pretty_print)
        if self.correspondentInformation is not None:
            self.correspondentInformation.export(outfile, level, namespace_, name_='correspondentInformation', pretty_print=pretty_print)
        for intermediaryInformation_ in self.intermediaryInformation:
            intermediaryInformation_.export(outfile, level, namespace_, name_='intermediaryInformation', pretty_print=pretty_print)
        if self.beneficiaryBank is not None:
            self.beneficiaryBank.export(outfile, level, namespace_, name_='beneficiaryBank', pretty_print=pretty_print)
        if self.beneficiary is not None:
            self.beneficiary.export(outfile, level, namespace_, name_='beneficiary', pretty_print=pretty_print)
        if self.depositoryPartyReference is not None:
            self.depositoryPartyReference.export(outfile, level, namespace_, name_='depositoryPartyReference', pretty_print=pretty_print)
        for splitSettlement_ in self.splitSettlement:
            splitSettlement_.export(outfile, level, namespace_, name_='splitSettlement', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'settlementMethod':
            obj_ = SettlementMethod.factory()
            obj_.build(child_)
            self.settlementMethod = obj_
            obj_.original_tagname_ = 'settlementMethod'
        elif nodeName_ == 'correspondentInformation':
            obj_ = CorrespondentInformation.factory()
            obj_.build(child_)
            self.correspondentInformation = obj_
            obj_.original_tagname_ = 'correspondentInformation'
        elif nodeName_ == 'intermediaryInformation':
            obj_ = IntermediaryInformation.factory()
            obj_.build(child_)
            self.intermediaryInformation.append(obj_)
            obj_.original_tagname_ = 'intermediaryInformation'
        elif nodeName_ == 'beneficiaryBank':
            obj_ = Beneficiary.factory()
            obj_.build(child_)
            self.beneficiaryBank = obj_
            obj_.original_tagname_ = 'beneficiaryBank'
        elif nodeName_ == 'beneficiary':
            obj_ = Beneficiary.factory()
            obj_.build(child_)
            self.beneficiary = obj_
            obj_.original_tagname_ = 'beneficiary'
        elif nodeName_ == 'depositoryPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.depositoryPartyReference = obj_
            obj_.original_tagname_ = 'depositoryPartyReference'
        elif nodeName_ == 'splitSettlement':
            obj_ = SplitSettlement.factory()
            obj_.build(child_)
            self.splitSettlement.append(obj_)
            obj_.original_tagname_ = 'splitSettlement'
# end class SettlementInstruction


class SettlementMethod(GeneratedsSuper):
    member_data_items_ = {
        'settlementMethodScheme': MemberSpec_('settlementMethodScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, settlementMethodScheme='http://www.fpml.org/coding-scheme/settlement-method', valueOf_=None):
        self.original_tagname_ = None
        self.settlementMethodScheme = _cast(None, settlementMethodScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SettlementMethod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SettlementMethod.subclass:
            return SettlementMethod.subclass(*args_, **kwargs_)
        else:
            return SettlementMethod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_settlementMethodScheme(self): return self.settlementMethodScheme
    def set_settlementMethodScheme(self, settlementMethodScheme): self.settlementMethodScheme = settlementMethodScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SettlementMethod', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SettlementMethod')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SettlementMethod', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SettlementMethod'):
        if self.settlementMethodScheme != "http://www.fpml.org/coding-scheme/settlement-method" and 'settlementMethodScheme' not in already_processed:
            already_processed.add('settlementMethodScheme')
            outfile.write(' settlementMethodScheme=%s' % (quote_attrib(self.settlementMethodScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SettlementMethod', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('settlementMethodScheme', node)
        if value is not None and 'settlementMethodScheme' not in already_processed:
            already_processed.add('settlementMethodScheme')
            self.settlementMethodScheme = value
            self.validate_NonEmptyURI(self.settlementMethodScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SettlementMethod


class SettlementPriceDefaultElection(GeneratedsSuper):
    """Coding scheme that specifies the settlement price default election."""
    member_data_items_ = {
        'settlementPriceDefaultElectionScheme': MemberSpec_('settlementPriceDefaultElectionScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, settlementPriceDefaultElectionScheme='http://www.fpml.org/coding-scheme/settlement-price-default-election', valueOf_=None):
        self.original_tagname_ = None
        self.settlementPriceDefaultElectionScheme = _cast(None, settlementPriceDefaultElectionScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SettlementPriceDefaultElection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SettlementPriceDefaultElection.subclass:
            return SettlementPriceDefaultElection.subclass(*args_, **kwargs_)
        else:
            return SettlementPriceDefaultElection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_settlementPriceDefaultElectionScheme(self): return self.settlementPriceDefaultElectionScheme
    def set_settlementPriceDefaultElectionScheme(self, settlementPriceDefaultElectionScheme): self.settlementPriceDefaultElectionScheme = settlementPriceDefaultElectionScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SettlementPriceDefaultElection', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SettlementPriceDefaultElection')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SettlementPriceDefaultElection', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SettlementPriceDefaultElection'):
        if self.settlementPriceDefaultElectionScheme != "http://www.fpml.org/coding-scheme/settlement-price-default-election" and 'settlementPriceDefaultElectionScheme' not in already_processed:
            already_processed.add('settlementPriceDefaultElectionScheme')
            outfile.write(' settlementPriceDefaultElectionScheme=%s' % (quote_attrib(self.settlementPriceDefaultElectionScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SettlementPriceDefaultElection', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('settlementPriceDefaultElectionScheme', node)
        if value is not None and 'settlementPriceDefaultElectionScheme' not in already_processed:
            already_processed.add('settlementPriceDefaultElectionScheme')
            self.settlementPriceDefaultElectionScheme = value
            self.validate_NonEmptyURI(self.settlementPriceDefaultElectionScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SettlementPriceDefaultElection


class SettlementPriceSource(GeneratedsSuper):
    """The source from which the settlement price is to be obtained, e.g. a
    Reuters page, Prezzo di Riferimento, etc."""
    member_data_items_ = {
        'settlementPriceSourceScheme': MemberSpec_('settlementPriceSourceScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, settlementPriceSourceScheme='http://www.fpml.org/coding-scheme/settlement-price-source', valueOf_=None):
        self.original_tagname_ = None
        self.settlementPriceSourceScheme = _cast(None, settlementPriceSourceScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SettlementPriceSource)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SettlementPriceSource.subclass:
            return SettlementPriceSource.subclass(*args_, **kwargs_)
        else:
            return SettlementPriceSource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_settlementPriceSourceScheme(self): return self.settlementPriceSourceScheme
    def set_settlementPriceSourceScheme(self, settlementPriceSourceScheme): self.settlementPriceSourceScheme = settlementPriceSourceScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SettlementPriceSource', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SettlementPriceSource')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SettlementPriceSource', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SettlementPriceSource'):
        if self.settlementPriceSourceScheme != "http://www.fpml.org/coding-scheme/settlement-price-source" and 'settlementPriceSourceScheme' not in already_processed:
            already_processed.add('settlementPriceSourceScheme')
            outfile.write(' settlementPriceSourceScheme=%s' % (quote_attrib(self.settlementPriceSourceScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SettlementPriceSource', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('settlementPriceSourceScheme', node)
        if value is not None and 'settlementPriceSourceScheme' not in already_processed:
            already_processed.add('settlementPriceSourceScheme')
            self.settlementPriceSourceScheme = value
            self.validate_NonEmptyURI(self.settlementPriceSourceScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SettlementPriceSource


class SettlementRateOption(GeneratedsSuper):
    """A type defining the settlement rate options through a scheme
    reflecting the terms of the Annex A to the 1998 FX and Currency
    Option Definitions."""
    member_data_items_ = {
        'settlementRateOptionScheme': MemberSpec_('settlementRateOptionScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, settlementRateOptionScheme='http://www.fpml.org/coding-scheme/settlement-rate-option', valueOf_=None):
        self.original_tagname_ = None
        self.settlementRateOptionScheme = _cast(None, settlementRateOptionScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SettlementRateOption)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SettlementRateOption.subclass:
            return SettlementRateOption.subclass(*args_, **kwargs_)
        else:
            return SettlementRateOption(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_settlementRateOptionScheme(self): return self.settlementRateOptionScheme
    def set_settlementRateOptionScheme(self, settlementRateOptionScheme): self.settlementRateOptionScheme = settlementRateOptionScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SettlementRateOption', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SettlementRateOption')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SettlementRateOption', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SettlementRateOption'):
        if self.settlementRateOptionScheme != "http://www.fpml.org/coding-scheme/settlement-rate-option" and 'settlementRateOptionScheme' not in already_processed:
            already_processed.add('settlementRateOptionScheme')
            outfile.write(' settlementRateOptionScheme=%s' % (quote_attrib(self.settlementRateOptionScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SettlementRateOption', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('settlementRateOptionScheme', node)
        if value is not None and 'settlementRateOptionScheme' not in already_processed:
            already_processed.add('settlementRateOptionScheme')
            self.settlementRateOptionScheme = value
            self.validate_NonEmptyURI(self.settlementRateOptionScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SettlementRateOption


class SettlementRateSource(GeneratedsSuper):
    """A type describing the method for obtaining a settlement rate."""
    member_data_items_ = {
        'informationSource': MemberSpec_('informationSource', 'InformationSource', 0),
        'cashSettlementReferenceBanks': MemberSpec_('cashSettlementReferenceBanks', 'CashSettlementReferenceBanks', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, informationSource=None, cashSettlementReferenceBanks=None):
        self.original_tagname_ = None
        self.informationSource = informationSource
        self.cashSettlementReferenceBanks = cashSettlementReferenceBanks
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SettlementRateSource)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SettlementRateSource.subclass:
            return SettlementRateSource.subclass(*args_, **kwargs_)
        else:
            return SettlementRateSource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_informationSource(self): return self.informationSource
    def set_informationSource(self, informationSource): self.informationSource = informationSource
    def get_cashSettlementReferenceBanks(self): return self.cashSettlementReferenceBanks
    def set_cashSettlementReferenceBanks(self, cashSettlementReferenceBanks): self.cashSettlementReferenceBanks = cashSettlementReferenceBanks
    def hasContent_(self):
        if (
            self.informationSource is not None or
            self.cashSettlementReferenceBanks is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SettlementRateSource', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SettlementRateSource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SettlementRateSource', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SettlementRateSource'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SettlementRateSource', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.informationSource is not None:
            self.informationSource.export(outfile, level, namespace_, name_='informationSource', pretty_print=pretty_print)
        if self.cashSettlementReferenceBanks is not None:
            self.cashSettlementReferenceBanks.export(outfile, level, namespace_, name_='cashSettlementReferenceBanks', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'informationSource':
            class_obj_ = self.get_class_obj_(child_, InformationSource)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.informationSource = obj_
            obj_.original_tagname_ = 'informationSource'
        elif nodeName_ == 'cashSettlementReferenceBanks':
            obj_ = CashSettlementReferenceBanks.factory()
            obj_.build(child_)
            self.cashSettlementReferenceBanks = obj_
            obj_.original_tagname_ = 'cashSettlementReferenceBanks'
# end class SettlementRateSource


class SharedAmericanExercise(Exercise):
    """TBAChoice between latest exercise time expressed as literal time, or
    using a determination method."""
    member_data_items_ = {
        'commencementDate': MemberSpec_('commencementDate', 'AdjustableOrRelativeDate', 0),
        'expirationDate': MemberSpec_('expirationDate', 'AdjustableOrRelativeDate', 0),
        'latestExerciseTime': MemberSpec_('latestExerciseTime', 'BusinessCenterTime', 0),
        'latestExerciseTimeDetermination': MemberSpec_('latestExerciseTimeDetermination', 'DeterminationMethod', 0),
    }
    subclass = None
    superclass = Exercise
    def __init__(self, id=None, commencementDate=None, expirationDate=None, latestExerciseTime=None, latestExerciseTimeDetermination=None):
        self.original_tagname_ = None
        super(SharedAmericanExercise, self).__init__(id, )
        self.commencementDate = commencementDate
        self.expirationDate = expirationDate
        self.latestExerciseTime = latestExerciseTime
        self.latestExerciseTimeDetermination = latestExerciseTimeDetermination
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SharedAmericanExercise)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SharedAmericanExercise.subclass:
            return SharedAmericanExercise.subclass(*args_, **kwargs_)
        else:
            return SharedAmericanExercise(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commencementDate(self): return self.commencementDate
    def set_commencementDate(self, commencementDate): self.commencementDate = commencementDate
    def get_expirationDate(self): return self.expirationDate
    def set_expirationDate(self, expirationDate): self.expirationDate = expirationDate
    def get_latestExerciseTime(self): return self.latestExerciseTime
    def set_latestExerciseTime(self, latestExerciseTime): self.latestExerciseTime = latestExerciseTime
    def get_latestExerciseTimeDetermination(self): return self.latestExerciseTimeDetermination
    def set_latestExerciseTimeDetermination(self, latestExerciseTimeDetermination): self.latestExerciseTimeDetermination = latestExerciseTimeDetermination
    def hasContent_(self):
        if (
            self.commencementDate is not None or
            self.expirationDate is not None or
            self.latestExerciseTime is not None or
            self.latestExerciseTimeDetermination is not None or
            super(SharedAmericanExercise, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SharedAmericanExercise', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SharedAmericanExercise')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SharedAmericanExercise', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SharedAmericanExercise'):
        super(SharedAmericanExercise, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SharedAmericanExercise')
    def exportChildren(self, outfile, level, namespace_='', name_='SharedAmericanExercise', fromsubclass_=False, pretty_print=True):
        super(SharedAmericanExercise, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.commencementDate is not None:
            self.commencementDate.export(outfile, level, namespace_, name_='commencementDate', pretty_print=pretty_print)
        if self.expirationDate is not None:
            self.expirationDate.export(outfile, level, namespace_, name_='expirationDate', pretty_print=pretty_print)
        if self.latestExerciseTime is not None:
            self.latestExerciseTime.export(outfile, level, namespace_, name_='latestExerciseTime', pretty_print=pretty_print)
        if self.latestExerciseTimeDetermination is not None:
            self.latestExerciseTimeDetermination.export(outfile, level, namespace_, name_='latestExerciseTimeDetermination', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SharedAmericanExercise, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'commencementDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.commencementDate = obj_
            obj_.original_tagname_ = 'commencementDate'
        elif nodeName_ == 'expirationDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.expirationDate = obj_
            obj_.original_tagname_ = 'expirationDate'
        elif nodeName_ == 'latestExerciseTime':
            obj_ = BusinessCenterTime.factory()
            obj_.build(child_)
            self.latestExerciseTime = obj_
            obj_.original_tagname_ = 'latestExerciseTime'
        elif nodeName_ == 'latestExerciseTimeDetermination':
            obj_ = DeterminationMethod.factory()
            obj_.build(child_)
            self.latestExerciseTimeDetermination = obj_
            obj_.original_tagname_ = 'latestExerciseTimeDetermination'
        super(SharedAmericanExercise, self).buildChildren(child_, node, nodeName_, True)
# end class SharedAmericanExercise


class SimplePayment(PaymentBase):
    """A complex type to specified payments in a simpler fashion than the
    Payment type. This construct should be used from the version 4.3
    onwards."""
    member_data_items_ = {
        'payerPartyReference': MemberSpec_('payerPartyReference', 'PartyReference', 0),
        'payerAccountReference': MemberSpec_('payerAccountReference', 'AccountReference', 0),
        'receiverPartyReference': MemberSpec_('receiverPartyReference', 'PartyReference', 0),
        'receiverAccountReference': MemberSpec_('receiverAccountReference', 'AccountReference', 0),
        'paymentAmount': MemberSpec_('paymentAmount', 'NonNegativeMoney', 0),
        'paymentDate': MemberSpec_('paymentDate', 'AdjustableOrRelativeDate', 0),
    }
    subclass = None
    superclass = PaymentBase
    def __init__(self, id=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, paymentAmount=None, paymentDate=None, extensiontype_=None):
        self.original_tagname_ = None
        super(SimplePayment, self).__init__(id, extensiontype_, )
        self.payerPartyReference = payerPartyReference
        self.payerAccountReference = payerAccountReference
        self.receiverPartyReference = receiverPartyReference
        self.receiverAccountReference = receiverAccountReference
        self.paymentAmount = paymentAmount
        self.paymentDate = paymentDate
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SimplePayment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SimplePayment.subclass:
            return SimplePayment.subclass(*args_, **kwargs_)
        else:
            return SimplePayment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_payerPartyReference(self): return self.payerPartyReference
    def set_payerPartyReference(self, payerPartyReference): self.payerPartyReference = payerPartyReference
    def get_payerAccountReference(self): return self.payerAccountReference
    def set_payerAccountReference(self, payerAccountReference): self.payerAccountReference = payerAccountReference
    def get_receiverPartyReference(self): return self.receiverPartyReference
    def set_receiverPartyReference(self, receiverPartyReference): self.receiverPartyReference = receiverPartyReference
    def get_receiverAccountReference(self): return self.receiverAccountReference
    def set_receiverAccountReference(self, receiverAccountReference): self.receiverAccountReference = receiverAccountReference
    def get_paymentAmount(self): return self.paymentAmount
    def set_paymentAmount(self, paymentAmount): self.paymentAmount = paymentAmount
    def get_paymentDate(self): return self.paymentDate
    def set_paymentDate(self, paymentDate): self.paymentDate = paymentDate
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.payerPartyReference is not None or
            self.payerAccountReference is not None or
            self.receiverPartyReference is not None or
            self.receiverAccountReference is not None or
            self.paymentAmount is not None or
            self.paymentDate is not None or
            super(SimplePayment, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SimplePayment', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SimplePayment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SimplePayment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SimplePayment'):
        super(SimplePayment, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SimplePayment')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='SimplePayment', fromsubclass_=False, pretty_print=True):
        super(SimplePayment, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.payerPartyReference is not None:
            self.payerPartyReference.export(outfile, level, namespace_, name_='payerPartyReference', pretty_print=pretty_print)
        if self.payerAccountReference is not None:
            self.payerAccountReference.export(outfile, level, namespace_, name_='payerAccountReference', pretty_print=pretty_print)
        if self.receiverPartyReference is not None:
            self.receiverPartyReference.export(outfile, level, namespace_, name_='receiverPartyReference', pretty_print=pretty_print)
        if self.receiverAccountReference is not None:
            self.receiverAccountReference.export(outfile, level, namespace_, name_='receiverAccountReference', pretty_print=pretty_print)
        if self.paymentAmount is not None:
            self.paymentAmount.export(outfile, level, namespace_, name_='paymentAmount', pretty_print=pretty_print)
        if self.paymentDate is not None:
            self.paymentDate.export(outfile, level, namespace_, name_='paymentDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(SimplePayment, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'payerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.payerPartyReference = obj_
            obj_.original_tagname_ = 'payerPartyReference'
        elif nodeName_ == 'payerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.payerAccountReference = obj_
            obj_.original_tagname_ = 'payerAccountReference'
        elif nodeName_ == 'receiverPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.receiverPartyReference = obj_
            obj_.original_tagname_ = 'receiverPartyReference'
        elif nodeName_ == 'receiverAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.receiverAccountReference = obj_
            obj_.original_tagname_ = 'receiverAccountReference'
        elif nodeName_ == 'paymentAmount':
            class_obj_ = self.get_class_obj_(child_, NonNegativeMoney)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.paymentAmount = obj_
            obj_.original_tagname_ = 'paymentAmount'
        elif nodeName_ == 'paymentDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.paymentDate = obj_
            obj_.original_tagname_ = 'paymentDate'
        super(SimplePayment, self).buildChildren(child_, node, nodeName_, True)
# end class SimplePayment


class SplitSettlement(GeneratedsSuper):
    """A type that supports the division of a gross settlement amount into
    a number of split settlements, each requiring its own settlement
    instruction."""
    member_data_items_ = {
        'splitSettlementAmount': MemberSpec_('splitSettlementAmount', 'Money', 0),
        'beneficiaryBank': MemberSpec_('beneficiaryBank', 'Routing', 0),
        'beneficiary': MemberSpec_('beneficiary', 'Routing', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, splitSettlementAmount=None, beneficiaryBank=None, beneficiary=None):
        self.original_tagname_ = None
        self.splitSettlementAmount = splitSettlementAmount
        self.beneficiaryBank = beneficiaryBank
        self.beneficiary = beneficiary
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SplitSettlement)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SplitSettlement.subclass:
            return SplitSettlement.subclass(*args_, **kwargs_)
        else:
            return SplitSettlement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_splitSettlementAmount(self): return self.splitSettlementAmount
    def set_splitSettlementAmount(self, splitSettlementAmount): self.splitSettlementAmount = splitSettlementAmount
    def get_beneficiaryBank(self): return self.beneficiaryBank
    def set_beneficiaryBank(self, beneficiaryBank): self.beneficiaryBank = beneficiaryBank
    def get_beneficiary(self): return self.beneficiary
    def set_beneficiary(self, beneficiary): self.beneficiary = beneficiary
    def hasContent_(self):
        if (
            self.splitSettlementAmount is not None or
            self.beneficiaryBank is not None or
            self.beneficiary is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SplitSettlement', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SplitSettlement')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SplitSettlement', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SplitSettlement'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SplitSettlement', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.splitSettlementAmount is not None:
            self.splitSettlementAmount.export(outfile, level, namespace_, name_='splitSettlementAmount', pretty_print=pretty_print)
        if self.beneficiaryBank is not None:
            self.beneficiaryBank.export(outfile, level, namespace_, name_='beneficiaryBank', pretty_print=pretty_print)
        if self.beneficiary is not None:
            self.beneficiary.export(outfile, level, namespace_, name_='beneficiary', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'splitSettlementAmount':
            obj_ = Money.factory()
            obj_.build(child_)
            self.splitSettlementAmount = obj_
            obj_.original_tagname_ = 'splitSettlementAmount'
        elif nodeName_ == 'beneficiaryBank':
            obj_ = Routing.factory()
            obj_.build(child_)
            self.beneficiaryBank = obj_
            obj_.original_tagname_ = 'beneficiaryBank'
        elif nodeName_ == 'beneficiary':
            obj_ = Routing.factory()
            obj_.build(child_)
            self.beneficiary = obj_
            obj_.original_tagname_ = 'beneficiary'
# end class SplitSettlement


class SpreadSchedule(Schedule):
    """Adds an optional spread type element to the Schedule to identify a
    long or short spread value."""
    member_data_items_ = {
        'type_': MemberSpec_('type_', 'SpreadScheduleType', 0),
    }
    subclass = None
    superclass = Schedule
    def __init__(self, id=None, initialValue=None, step=None, type_=None):
        self.original_tagname_ = None
        super(SpreadSchedule, self).__init__(id, initialValue, step, )
        self.type_ = type_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpreadSchedule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpreadSchedule.subclass:
            return SpreadSchedule.subclass(*args_, **kwargs_)
        else:
            return SpreadSchedule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (
            self.type_ is not None or
            super(SpreadSchedule, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SpreadSchedule', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SpreadSchedule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SpreadSchedule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SpreadSchedule'):
        super(SpreadSchedule, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SpreadSchedule')
    def exportChildren(self, outfile, level, namespace_='', name_='SpreadSchedule', fromsubclass_=False, pretty_print=True):
        super(SpreadSchedule, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            self.type_.export(outfile, level, namespace_, name_='type', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SpreadSchedule, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            obj_ = SpreadScheduleType.factory()
            obj_.build(child_)
            self.type_ = obj_
            obj_.original_tagname_ = 'type'
        super(SpreadSchedule, self).buildChildren(child_, node, nodeName_, True)
# end class SpreadSchedule


class SpreadScheduleReference(Reference):
    """Provides a reference to a spread schedule."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(SpreadScheduleReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpreadScheduleReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpreadScheduleReference.subclass:
            return SpreadScheduleReference.subclass(*args_, **kwargs_)
        else:
            return SpreadScheduleReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(SpreadScheduleReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SpreadScheduleReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SpreadScheduleReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SpreadScheduleReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SpreadScheduleReference'):
        super(SpreadScheduleReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SpreadScheduleReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SpreadScheduleReference', fromsubclass_=False, pretty_print=True):
        super(SpreadScheduleReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(SpreadScheduleReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SpreadScheduleReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SpreadScheduleReference


class SpreadScheduleType(GeneratedsSuper):
    """Defines a Spread Type Scheme to identify a long or short spread
    value."""
    member_data_items_ = {
        'spreadScheduleTypeScheme': MemberSpec_('spreadScheduleTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, spreadScheduleTypeScheme='http://www.fpml.org/coding-scheme/spread-schedule-type', valueOf_=None):
        self.original_tagname_ = None
        self.spreadScheduleTypeScheme = _cast(None, spreadScheduleTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpreadScheduleType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpreadScheduleType.subclass:
            return SpreadScheduleType.subclass(*args_, **kwargs_)
        else:
            return SpreadScheduleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_spreadScheduleTypeScheme(self): return self.spreadScheduleTypeScheme
    def set_spreadScheduleTypeScheme(self, spreadScheduleTypeScheme): self.spreadScheduleTypeScheme = spreadScheduleTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SpreadScheduleType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SpreadScheduleType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SpreadScheduleType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SpreadScheduleType'):
        if self.spreadScheduleTypeScheme != "http://www.fpml.org/coding-scheme/spread-schedule-type" and 'spreadScheduleTypeScheme' not in already_processed:
            already_processed.add('spreadScheduleTypeScheme')
            outfile.write(' spreadScheduleTypeScheme=%s' % (quote_attrib(self.spreadScheduleTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SpreadScheduleType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('spreadScheduleTypeScheme', node)
        if value is not None and 'spreadScheduleTypeScheme' not in already_processed:
            already_processed.add('spreadScheduleTypeScheme')
            self.spreadScheduleTypeScheme = value
            self.validate_NonEmptyURI(self.spreadScheduleTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SpreadScheduleType


class StepBase(GeneratedsSuper):
    """A type defining a step date and step value pair. This step
    definitions are used to define varying rate or amount schedules,
    e.g. a notional amortization or a step-up coupon schedule."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'stepDate': MemberSpec_('stepDate', 'xsd:date', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, stepDate=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if isinstance(stepDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(stepDate, '%Y-%m-%d').date()
        else:
            initvalue_ = stepDate
        self.stepDate = initvalue_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StepBase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StepBase.subclass:
            return StepBase.subclass(*args_, **kwargs_)
        else:
            return StepBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_stepDate(self): return self.stepDate
    def set_stepDate(self, stepDate): self.stepDate = stepDate
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.stepDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StepBase', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StepBase')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StepBase', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StepBase'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='StepBase', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.stepDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstepDate>%s</%sstepDate>%s' % (namespace_, self.gds_format_date(self.stepDate, input_name='stepDate'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'stepDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.stepDate = dval_
# end class StepBase


class StreetAddress(GeneratedsSuper):
    """A type that describes the set of street and building number
    information that identifies a postal address within a city."""
    member_data_items_ = {
        'streetLine': MemberSpec_('streetLine', ['String', 'xsd:string'], 1),
    }
    subclass = None
    superclass = None
    def __init__(self, streetLine=None):
        self.original_tagname_ = None
        if streetLine is None:
            self.streetLine = []
        else:
            self.streetLine = streetLine
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StreetAddress)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StreetAddress.subclass:
            return StreetAddress.subclass(*args_, **kwargs_)
        else:
            return StreetAddress(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_streetLine(self): return self.streetLine
    def set_streetLine(self, streetLine): self.streetLine = streetLine
    def add_streetLine(self, value): self.streetLine.append(value)
    def insert_streetLine_at(self, index, value): self.streetLine.insert(index, value)
    def replace_streetLine_at(self, index, value): self.streetLine[index] = value
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.streetLine
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StreetAddress', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StreetAddress')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StreetAddress', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StreetAddress'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StreetAddress', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for streetLine_ in self.streetLine:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstreetLine>%s</%sstreetLine>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(streetLine_), input_name='streetLine')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'streetLine':
            streetLine_ = child_.text
            streetLine_ = self.gds_validate_string(streetLine_, node, 'streetLine')
            self.streetLine.append(streetLine_)
            # validate type String
            self.validate_String(self.streetLine[-1])
# end class StreetAddress


class Strike(GeneratedsSuper):
    """A type describing a single cap or floor rate."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'strikeRate': MemberSpec_('strikeRate', 'xsd:decimal', 0),
        'buyer': MemberSpec_('buyer', 'IdentifiedPayerReceiver', 0),
        'seller': MemberSpec_('seller', 'IdentifiedPayerReceiver', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, strikeRate=None, buyer=None, seller=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.strikeRate = strikeRate
        self.buyer = buyer
        self.seller = seller
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Strike)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Strike.subclass:
            return Strike.subclass(*args_, **kwargs_)
        else:
            return Strike(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_strikeRate(self): return self.strikeRate
    def set_strikeRate(self, strikeRate): self.strikeRate = strikeRate
    def get_buyer(self): return self.buyer
    def set_buyer(self, buyer): self.buyer = buyer
    def get_seller(self): return self.seller
    def set_seller(self, seller): self.seller = seller
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.strikeRate is not None or
            self.buyer is not None or
            self.seller is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Strike', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Strike')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Strike', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Strike'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Strike', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.strikeRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstrikeRate>%s</%sstrikeRate>%s' % (namespace_, self.gds_format_float(self.strikeRate, input_name='strikeRate'), namespace_, eol_))
        if self.buyer is not None:
            self.buyer.export(outfile, level, namespace_, name_='buyer', pretty_print=pretty_print)
        if self.seller is not None:
            self.seller.export(outfile, level, namespace_, name_='seller', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'strikeRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'strikeRate')
            self.strikeRate = fval_
        elif nodeName_ == 'buyer':
            obj_ = IdentifiedPayerReceiver.factory()
            obj_.build(child_)
            self.buyer = obj_
            obj_.original_tagname_ = 'buyer'
        elif nodeName_ == 'seller':
            obj_ = IdentifiedPayerReceiver.factory()
            obj_.build(child_)
            self.seller = obj_
            obj_.original_tagname_ = 'seller'
# end class Strike


class StrikeSchedule(Schedule):
    """A type describing a schedule of cap or floor rates."""
    member_data_items_ = {
        'buyer': MemberSpec_('buyer', 'IdentifiedPayerReceiver', 0),
        'seller': MemberSpec_('seller', 'IdentifiedPayerReceiver', 0),
    }
    subclass = None
    superclass = Schedule
    def __init__(self, id=None, initialValue=None, step=None, buyer=None, seller=None):
        self.original_tagname_ = None
        super(StrikeSchedule, self).__init__(id, initialValue, step, )
        self.buyer = buyer
        self.seller = seller
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrikeSchedule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrikeSchedule.subclass:
            return StrikeSchedule.subclass(*args_, **kwargs_)
        else:
            return StrikeSchedule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_buyer(self): return self.buyer
    def set_buyer(self, buyer): self.buyer = buyer
    def get_seller(self): return self.seller
    def set_seller(self, seller): self.seller = seller
    def hasContent_(self):
        if (
            self.buyer is not None or
            self.seller is not None or
            super(StrikeSchedule, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StrikeSchedule', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StrikeSchedule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StrikeSchedule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StrikeSchedule'):
        super(StrikeSchedule, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StrikeSchedule')
    def exportChildren(self, outfile, level, namespace_='', name_='StrikeSchedule', fromsubclass_=False, pretty_print=True):
        super(StrikeSchedule, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.buyer is not None:
            self.buyer.export(outfile, level, namespace_, name_='buyer', pretty_print=pretty_print)
        if self.seller is not None:
            self.seller.export(outfile, level, namespace_, name_='seller', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(StrikeSchedule, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'buyer':
            obj_ = IdentifiedPayerReceiver.factory()
            obj_.build(child_)
            self.buyer = obj_
            obj_.original_tagname_ = 'buyer'
        elif nodeName_ == 'seller':
            obj_ = IdentifiedPayerReceiver.factory()
            obj_.build(child_)
            self.seller = obj_
            obj_.original_tagname_ = 'seller'
        super(StrikeSchedule, self).buildChildren(child_, node, nodeName_, True)
# end class StrikeSchedule


class StubValue(GeneratedsSuper):
    """A type defining how a stub calculation period amount is calculated.
    A single floating rate tenor different to that used for the
    regular part of the calculation periods schedule may be
    specified, or two floating rate tenors many be specified. If two
    floating rate tenors are specified then Linear Interpolation (in
    accordance with the 2000 ISDA Definitions, Section 8.3
    Interpolation) is assumed to apply. Alternatively, an actual
    known stub rate or stub amount may be specified."""
    member_data_items_ = {
        'floatingRate': MemberSpec_('floatingRate', 'StubFloatingRate', 1),
        'stubRate': MemberSpec_('stubRate', 'xsd:decimal', 0),
        'stubAmount': MemberSpec_('stubAmount', 'Money', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, floatingRate=None, stubRate=None, stubAmount=None, extensiontype_=None):
        self.original_tagname_ = None
        if floatingRate is None:
            self.floatingRate = []
        else:
            self.floatingRate = floatingRate
        self.stubRate = stubRate
        self.stubAmount = stubAmount
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StubValue)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StubValue.subclass:
            return StubValue.subclass(*args_, **kwargs_)
        else:
            return StubValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_floatingRate(self): return self.floatingRate
    def set_floatingRate(self, floatingRate): self.floatingRate = floatingRate
    def add_floatingRate(self, value): self.floatingRate.append(value)
    def insert_floatingRate_at(self, index, value): self.floatingRate.insert(index, value)
    def replace_floatingRate_at(self, index, value): self.floatingRate[index] = value
    def get_stubRate(self): return self.stubRate
    def set_stubRate(self, stubRate): self.stubRate = stubRate
    def get_stubAmount(self): return self.stubAmount
    def set_stubAmount(self, stubAmount): self.stubAmount = stubAmount
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.floatingRate or
            self.stubRate is not None or
            self.stubAmount is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StubValue', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StubValue')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StubValue', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StubValue'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StubValue', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for floatingRate_ in self.floatingRate:
            floatingRate_.export(outfile, level, namespace_, name_='floatingRate', pretty_print=pretty_print)
        if self.stubRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstubRate>%s</%sstubRate>%s' % (namespace_, self.gds_format_float(self.stubRate, input_name='stubRate'), namespace_, eol_))
        if self.stubAmount is not None:
            self.stubAmount.export(outfile, level, namespace_, name_='stubAmount', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'floatingRate':
            obj_ = StubFloatingRate.factory()
            obj_.build(child_)
            self.floatingRate.append(obj_)
            obj_.original_tagname_ = 'floatingRate'
        elif nodeName_ == 'stubRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'stubRate')
            self.stubRate = fval_
        elif nodeName_ == 'stubAmount':
            obj_ = Money.factory()
            obj_.build(child_)
            self.stubAmount = obj_
            obj_.original_tagname_ = 'stubAmount'
# end class StubValue


class StubFloatingRate(Rate):
    """A type defining a floating rate."""
    member_data_items_ = {
        'floatingRateIndex': MemberSpec_('floatingRateIndex', 'FloatingRateIndex', 0),
        'indexTenor': MemberSpec_('indexTenor', 'Period', 0),
        'floatingRateMultiplierSchedule': MemberSpec_('floatingRateMultiplierSchedule', 'Schedule', 0),
        'spreadSchedule': MemberSpec_('spreadSchedule', 'SpreadSchedule', 1),
        'rateTreatment': MemberSpec_('rateTreatment', ['RateTreatmentEnum', 'Token', 'xsd:token'], 0),
        'capRateSchedule': MemberSpec_('capRateSchedule', 'StrikeSchedule', 1),
        'floorRateSchedule': MemberSpec_('floorRateSchedule', 'StrikeSchedule', 1),
        'capFloorStraddle': MemberSpec_('capFloorStraddle', 'xsd:boolean', 0),
    }
    subclass = None
    superclass = Rate
    def __init__(self, id=None, floatingRateIndex=None, indexTenor=None, floatingRateMultiplierSchedule=None, spreadSchedule=None, rateTreatment=None, capRateSchedule=None, floorRateSchedule=None, capFloorStraddle=None):
        self.original_tagname_ = None
        super(StubFloatingRate, self).__init__(id, )
        self.floatingRateIndex = floatingRateIndex
        self.indexTenor = indexTenor
        self.floatingRateMultiplierSchedule = floatingRateMultiplierSchedule
        if spreadSchedule is None:
            self.spreadSchedule = []
        else:
            self.spreadSchedule = spreadSchedule
        self.rateTreatment = rateTreatment
        self.validate_RateTreatmentEnum(self.rateTreatment)
        if capRateSchedule is None:
            self.capRateSchedule = []
        else:
            self.capRateSchedule = capRateSchedule
        if floorRateSchedule is None:
            self.floorRateSchedule = []
        else:
            self.floorRateSchedule = floorRateSchedule
        self.capFloorStraddle = capFloorStraddle
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StubFloatingRate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StubFloatingRate.subclass:
            return StubFloatingRate.subclass(*args_, **kwargs_)
        else:
            return StubFloatingRate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_floatingRateIndex(self): return self.floatingRateIndex
    def set_floatingRateIndex(self, floatingRateIndex): self.floatingRateIndex = floatingRateIndex
    def get_indexTenor(self): return self.indexTenor
    def set_indexTenor(self, indexTenor): self.indexTenor = indexTenor
    def get_floatingRateMultiplierSchedule(self): return self.floatingRateMultiplierSchedule
    def set_floatingRateMultiplierSchedule(self, floatingRateMultiplierSchedule): self.floatingRateMultiplierSchedule = floatingRateMultiplierSchedule
    def get_spreadSchedule(self): return self.spreadSchedule
    def set_spreadSchedule(self, spreadSchedule): self.spreadSchedule = spreadSchedule
    def add_spreadSchedule(self, value): self.spreadSchedule.append(value)
    def insert_spreadSchedule_at(self, index, value): self.spreadSchedule.insert(index, value)
    def replace_spreadSchedule_at(self, index, value): self.spreadSchedule[index] = value
    def get_rateTreatment(self): return self.rateTreatment
    def set_rateTreatment(self, rateTreatment): self.rateTreatment = rateTreatment
    def get_capRateSchedule(self): return self.capRateSchedule
    def set_capRateSchedule(self, capRateSchedule): self.capRateSchedule = capRateSchedule
    def add_capRateSchedule(self, value): self.capRateSchedule.append(value)
    def insert_capRateSchedule_at(self, index, value): self.capRateSchedule.insert(index, value)
    def replace_capRateSchedule_at(self, index, value): self.capRateSchedule[index] = value
    def get_floorRateSchedule(self): return self.floorRateSchedule
    def set_floorRateSchedule(self, floorRateSchedule): self.floorRateSchedule = floorRateSchedule
    def add_floorRateSchedule(self, value): self.floorRateSchedule.append(value)
    def insert_floorRateSchedule_at(self, index, value): self.floorRateSchedule.insert(index, value)
    def replace_floorRateSchedule_at(self, index, value): self.floorRateSchedule[index] = value
    def get_capFloorStraddle(self): return self.capFloorStraddle
    def set_capFloorStraddle(self, capFloorStraddle): self.capFloorStraddle = capFloorStraddle
    def validate_RateTreatmentEnum(self, value):
        # Validate type RateTreatmentEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['BondEquivalentYield', 'MoneyMarketYield']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RateTreatmentEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on RateTreatmentEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.floatingRateIndex is not None or
            self.indexTenor is not None or
            self.floatingRateMultiplierSchedule is not None or
            self.spreadSchedule or
            self.rateTreatment is not None or
            self.capRateSchedule or
            self.floorRateSchedule or
            self.capFloorStraddle is not None or
            super(StubFloatingRate, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StubFloatingRate', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StubFloatingRate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StubFloatingRate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StubFloatingRate'):
        super(StubFloatingRate, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StubFloatingRate')
    def exportChildren(self, outfile, level, namespace_='', name_='StubFloatingRate', fromsubclass_=False, pretty_print=True):
        super(StubFloatingRate, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.floatingRateIndex is not None:
            self.floatingRateIndex.export(outfile, level, namespace_, name_='floatingRateIndex', pretty_print=pretty_print)
        if self.indexTenor is not None:
            self.indexTenor.export(outfile, level, namespace_, name_='indexTenor', pretty_print=pretty_print)
        if self.floatingRateMultiplierSchedule is not None:
            self.floatingRateMultiplierSchedule.export(outfile, level, namespace_, name_='floatingRateMultiplierSchedule', pretty_print=pretty_print)
        for spreadSchedule_ in self.spreadSchedule:
            spreadSchedule_.export(outfile, level, namespace_, name_='spreadSchedule', pretty_print=pretty_print)
        if self.rateTreatment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srateTreatment>%s</%srateTreatment>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.rateTreatment), input_name='rateTreatment')), namespace_, eol_))
        for capRateSchedule_ in self.capRateSchedule:
            capRateSchedule_.export(outfile, level, namespace_, name_='capRateSchedule', pretty_print=pretty_print)
        for floorRateSchedule_ in self.floorRateSchedule:
            floorRateSchedule_.export(outfile, level, namespace_, name_='floorRateSchedule', pretty_print=pretty_print)
        if self.capFloorStraddle is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scapFloorStraddle>%s</%scapFloorStraddle>%s' % (namespace_, self.gds_format_boolean(self.capFloorStraddle, input_name='capFloorStraddle'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(StubFloatingRate, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'floatingRateIndex':
            obj_ = FloatingRateIndex.factory()
            obj_.build(child_)
            self.floatingRateIndex = obj_
            obj_.original_tagname_ = 'floatingRateIndex'
        elif nodeName_ == 'indexTenor':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.indexTenor = obj_
            obj_.original_tagname_ = 'indexTenor'
        elif nodeName_ == 'floatingRateMultiplierSchedule':
            class_obj_ = self.get_class_obj_(child_, Schedule)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.floatingRateMultiplierSchedule = obj_
            obj_.original_tagname_ = 'floatingRateMultiplierSchedule'
        elif nodeName_ == 'spreadSchedule':
            obj_ = SpreadSchedule.factory()
            obj_.build(child_)
            self.spreadSchedule.append(obj_)
            obj_.original_tagname_ = 'spreadSchedule'
        elif nodeName_ == 'rateTreatment':
            rateTreatment_ = child_.text
            rateTreatment_ = re_.sub(String_cleanup_pat_, " ", rateTreatment_).strip()
            rateTreatment_ = self.gds_validate_string(rateTreatment_, node, 'rateTreatment')
            self.rateTreatment = rateTreatment_
            # validate type RateTreatmentEnum
            self.validate_RateTreatmentEnum(self.rateTreatment)
        elif nodeName_ == 'capRateSchedule':
            obj_ = StrikeSchedule.factory()
            obj_.build(child_)
            self.capRateSchedule.append(obj_)
            obj_.original_tagname_ = 'capRateSchedule'
        elif nodeName_ == 'floorRateSchedule':
            obj_ = StrikeSchedule.factory()
            obj_.build(child_)
            self.floorRateSchedule.append(obj_)
            obj_.original_tagname_ = 'floorRateSchedule'
        elif nodeName_ == 'capFloorStraddle':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'capFloorStraddle')
            self.capFloorStraddle = ival_
        super(StubFloatingRate, self).buildChildren(child_, node, nodeName_, True)
# end class StubFloatingRate


class SupervisoryBody(GeneratedsSuper):
    """An identifier of an organization that supervises or regulates
    trading activity, e.g. CFTC, SEC, FSA, ODRF, etc."""
    member_data_items_ = {
        'supervisoryBodyScheme': MemberSpec_('supervisoryBodyScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, supervisoryBodyScheme='http://www.fpml.org/coding-scheme/supervisory-body', valueOf_=None):
        self.original_tagname_ = None
        self.supervisoryBodyScheme = _cast(None, supervisoryBodyScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SupervisoryBody)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SupervisoryBody.subclass:
            return SupervisoryBody.subclass(*args_, **kwargs_)
        else:
            return SupervisoryBody(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_supervisoryBodyScheme(self): return self.supervisoryBodyScheme
    def set_supervisoryBodyScheme(self, supervisoryBodyScheme): self.supervisoryBodyScheme = supervisoryBodyScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SupervisoryBody', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SupervisoryBody')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SupervisoryBody', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SupervisoryBody'):
        if self.supervisoryBodyScheme != "http://www.fpml.org/coding-scheme/supervisory-body" and 'supervisoryBodyScheme' not in already_processed:
            already_processed.add('supervisoryBodyScheme')
            outfile.write(' supervisoryBodyScheme=%s' % (quote_attrib(self.supervisoryBodyScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SupervisoryBody', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('supervisoryBodyScheme', node)
        if value is not None and 'supervisoryBodyScheme' not in already_processed:
            already_processed.add('supervisoryBodyScheme')
            self.supervisoryBodyScheme = value
            self.validate_NonEmptyURI(self.supervisoryBodyScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SupervisoryBody


class TelephoneNumber(GeneratedsSuper):
    """A type that represents a telephonic contact."""
    member_data_items_ = {
        'type_': MemberSpec_('type_', ['TelephoneTypeEnum', 'Token', 'xsd:token'], 0),
        'number': MemberSpec_('number', ['String', 'xsd:string'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, type_=None, number=None):
        self.original_tagname_ = None
        self.type_ = type_
        self.validate_TelephoneTypeEnum(self.type_)
        self.number = number
        self.validate_String(self.number)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TelephoneNumber)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TelephoneNumber.subclass:
            return TelephoneNumber.subclass(*args_, **kwargs_)
        else:
            return TelephoneNumber(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_number(self): return self.number
    def set_number(self, number): self.number = number
    def validate_TelephoneTypeEnum(self, value):
        # Validate type TelephoneTypeEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Work', 'Mobile', 'Fax', 'Personal']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TelephoneTypeEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on TelephoneTypeEnum' % {"value" : value} )
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.type_ is not None or
            self.number is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TelephoneNumber', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TelephoneNumber')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TelephoneNumber', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TelephoneNumber'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TelephoneNumber', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stype>%s</%stype>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.type_), input_name='type')), namespace_, eol_))
        if self.number is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumber>%s</%snumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.number), input_name='number')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            type_ = child_.text
            type_ = re_.sub(String_cleanup_pat_, " ", type_).strip()
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
            # validate type TelephoneTypeEnum
            self.validate_TelephoneTypeEnum(self.type_)
        elif nodeName_ == 'number':
            number_ = child_.text
            number_ = self.gds_validate_string(number_, node, 'number')
            self.number = number_
            # validate type String
            self.validate_String(self.number)
# end class TelephoneNumber


class TimezoneLocation(GeneratedsSuper):
    """A geophraphic location for the purposes of defining a prevailing
    time according to the tz database."""
    member_data_items_ = {
        'timezoneLocationScheme': MemberSpec_('timezoneLocationScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, timezoneLocationScheme='http://www.fpml.org/coding-scheme/external/tzdatabase', valueOf_=None):
        self.original_tagname_ = None
        self.timezoneLocationScheme = _cast(None, timezoneLocationScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimezoneLocation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimezoneLocation.subclass:
            return TimezoneLocation.subclass(*args_, **kwargs_)
        else:
            return TimezoneLocation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_timezoneLocationScheme(self): return self.timezoneLocationScheme
    def set_timezoneLocationScheme(self, timezoneLocationScheme): self.timezoneLocationScheme = timezoneLocationScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TimezoneLocation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimezoneLocation')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TimezoneLocation', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimezoneLocation'):
        if self.timezoneLocationScheme != "http://www.fpml.org/coding-scheme/external/tzdatabase" and 'timezoneLocationScheme' not in already_processed:
            already_processed.add('timezoneLocationScheme')
            outfile.write(' timezoneLocationScheme=%s' % (quote_attrib(self.timezoneLocationScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TimezoneLocation', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('timezoneLocationScheme', node)
        if value is not None and 'timezoneLocationScheme' not in already_processed:
            already_processed.add('timezoneLocationScheme')
            self.timezoneLocationScheme = value
            self.validate_NonEmptyURI(self.timezoneLocationScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TimezoneLocation


class TradeId(GeneratedsSuper):
    """A trade reference identifier allocated by a party. FpML does not
    define the domain values associated with this element. Note that
    the domain values for this element are not strictly an
    enumerated list."""
    member_data_items_ = {
        'tradeIdScheme': MemberSpec_('tradeIdScheme', 'NonEmptyURI', 0),
        'id': MemberSpec_('id', 'xsd:string', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, tradeIdScheme=None, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.tradeIdScheme = _cast(None, tradeIdScheme)
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TradeId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TradeId.subclass:
            return TradeId.subclass(*args_, **kwargs_)
        else:
            return TradeId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tradeIdScheme(self): return self.tradeIdScheme
    def set_tradeIdScheme(self, tradeIdScheme): self.tradeIdScheme = tradeIdScheme
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TradeId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TradeId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TradeId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TradeId'):
        if self.tradeIdScheme is not None and 'tradeIdScheme' not in already_processed:
            already_processed.add('tradeIdScheme')
            outfile.write(' tradeIdScheme=%s' % (quote_attrib(self.tradeIdScheme), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TradeId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('tradeIdScheme', node)
        if value is not None and 'tradeIdScheme' not in already_processed:
            already_processed.add('tradeIdScheme')
            self.tradeIdScheme = value
            self.validate_NonEmptyURI(self.tradeIdScheme)    # validate type NonEmptyURI
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TradeId


class Unit(GeneratedsSuper):
    """A type used to record information about a unit, subdivision, desk,
    or other similar business entity."""
    member_data_items_ = {
        'unitScheme': MemberSpec_('unitScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, unitScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.unitScheme = _cast(None, unitScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Unit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Unit.subclass:
            return Unit.subclass(*args_, **kwargs_)
        else:
            return Unit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unitScheme(self): return self.unitScheme
    def set_unitScheme(self, unitScheme): self.unitScheme = unitScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Unit', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Unit')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Unit', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Unit'):
        if self.unitScheme is not None and 'unitScheme' not in already_processed:
            already_processed.add('unitScheme')
            outfile.write(' unitScheme=%s' % (quote_attrib(self.unitScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Unit', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unitScheme', node)
        if value is not None and 'unitScheme' not in already_processed:
            already_processed.add('unitScheme')
            self.unitScheme = value
            self.validate_NonEmptyURI(self.unitScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Unit


class IssuerId(GeneratedsSuper):
    """The data type used for issuer identifiers."""
    member_data_items_ = {
        'issuerIdScheme': MemberSpec_('issuerIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, issuerIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.issuerIdScheme = _cast(None, issuerIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IssuerId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IssuerId.subclass:
            return IssuerId.subclass(*args_, **kwargs_)
        else:
            return IssuerId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_issuerIdScheme(self): return self.issuerIdScheme
    def set_issuerIdScheme(self, issuerIdScheme): self.issuerIdScheme = issuerIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IssuerId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IssuerId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IssuerId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IssuerId'):
        if self.issuerIdScheme is not None and 'issuerIdScheme' not in already_processed:
            already_processed.add('issuerIdScheme')
            outfile.write(' issuerIdScheme=%s' % (quote_attrib(self.issuerIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IssuerId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('issuerIdScheme', node)
        if value is not None and 'issuerIdScheme' not in already_processed:
            already_processed.add('issuerIdScheme')
            self.issuerIdScheme = value
            self.validate_NonEmptyURI(self.issuerIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IssuerId


class IssuerTradeId(GeneratedsSuper):
    """A complex type for a two part identifier such as a USI."""
    member_data_items_ = {
        'issuer': MemberSpec_('issuer', 'IssuerId', 0),
        'tradeId': MemberSpec_('tradeId', 'TradeId', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, issuer=None, tradeId=None):
        self.original_tagname_ = None
        self.issuer = issuer
        self.tradeId = tradeId
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IssuerTradeId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IssuerTradeId.subclass:
            return IssuerTradeId.subclass(*args_, **kwargs_)
        else:
            return IssuerTradeId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_issuer(self): return self.issuer
    def set_issuer(self, issuer): self.issuer = issuer
    def get_tradeId(self): return self.tradeId
    def set_tradeId(self, tradeId): self.tradeId = tradeId
    def hasContent_(self):
        if (
            self.issuer is not None or
            self.tradeId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IssuerTradeId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IssuerTradeId')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IssuerTradeId', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IssuerTradeId'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IssuerTradeId', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.issuer is not None:
            self.issuer.export(outfile, level, namespace_, name_='issuer', pretty_print=pretty_print)
        if self.tradeId is not None:
            self.tradeId.export(outfile, level, namespace_, name_='tradeId', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'issuer':
            obj_ = IssuerId.factory()
            obj_.build(child_)
            self.issuer = obj_
            obj_.original_tagname_ = 'issuer'
        elif nodeName_ == 'tradeId':
            obj_ = TradeId.factory()
            obj_.build(child_)
            self.tradeId = obj_
            obj_.original_tagname_ = 'tradeId'
# end class IssuerTradeId


class Stub(StubValue):
    """A type defining how a stub calculation period amount is calculated
    and the start and end date of the stub. A single floating rate
    tenor different to that used for the regular part of the
    calculation periods schedule may be specified, or two floating
    rate tenors many be specified. If two floating rate tenors are
    specified then Linear Interpolation (in accordance with the 2000
    ISDA Definitions, Section 8.3 Interpolation) is assumed to
    apply. Alternatively, an actual known stub rate or stub amount
    may be specified."""
    member_data_items_ = {
        'stubStartDate': MemberSpec_('stubStartDate', 'AdjustableOrRelativeDate', 0),
        'stubEndDate': MemberSpec_('stubEndDate', 'AdjustableOrRelativeDate', 0),
    }
    subclass = None
    superclass = StubValue
    def __init__(self, floatingRate=None, stubRate=None, stubAmount=None, stubStartDate=None, stubEndDate=None):
        self.original_tagname_ = None
        super(Stub, self).__init__(floatingRate, stubRate, stubAmount, )
        self.stubStartDate = stubStartDate
        self.stubEndDate = stubEndDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Stub)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Stub.subclass:
            return Stub.subclass(*args_, **kwargs_)
        else:
            return Stub(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_stubStartDate(self): return self.stubStartDate
    def set_stubStartDate(self, stubStartDate): self.stubStartDate = stubStartDate
    def get_stubEndDate(self): return self.stubEndDate
    def set_stubEndDate(self, stubEndDate): self.stubEndDate = stubEndDate
    def hasContent_(self):
        if (
            self.stubStartDate is not None or
            self.stubEndDate is not None or
            super(Stub, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Stub', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Stub')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Stub', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Stub'):
        super(Stub, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Stub')
    def exportChildren(self, outfile, level, namespace_='', name_='Stub', fromsubclass_=False, pretty_print=True):
        super(Stub, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.stubStartDate is not None:
            self.stubStartDate.export(outfile, level, namespace_, name_='stubStartDate', pretty_print=pretty_print)
        if self.stubEndDate is not None:
            self.stubEndDate.export(outfile, level, namespace_, name_='stubEndDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Stub, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'stubStartDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.stubStartDate = obj_
            obj_.original_tagname_ = 'stubStartDate'
        elif nodeName_ == 'stubEndDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.stubEndDate = obj_
            obj_.original_tagname_ = 'stubEndDate'
        super(Stub, self).buildChildren(child_, node, nodeName_, True)
# end class Stub


class Step(StepBase):
    """A type defining a step date and step value pair. This step
    definitions are used to define varying rate or amount schedules,
    e.g. a notional amortization or a step-up coupon schedule."""
    member_data_items_ = {
        'stepValue': MemberSpec_('stepValue', 'xsd:decimal', 0),
    }
    subclass = None
    superclass = StepBase
    def __init__(self, id=None, stepDate=None, stepValue=None):
        self.original_tagname_ = None
        super(Step, self).__init__(id, stepDate, )
        self.stepValue = stepValue
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Step)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Step.subclass:
            return Step.subclass(*args_, **kwargs_)
        else:
            return Step(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_stepValue(self): return self.stepValue
    def set_stepValue(self, stepValue): self.stepValue = stepValue
    def hasContent_(self):
        if (
            self.stepValue is not None or
            super(Step, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Step', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Step')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Step', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Step'):
        super(Step, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Step')
    def exportChildren(self, outfile, level, namespace_='', name_='Step', fromsubclass_=False, pretty_print=True):
        super(Step, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.stepValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstepValue>%s</%sstepValue>%s' % (namespace_, self.gds_format_float(self.stepValue, input_name='stepValue'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Step, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'stepValue':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'stepValue')
            self.stepValue = fval_
        super(Step, self).buildChildren(child_, node, nodeName_, True)
# end class Step


class ProductReference(Reference):
    """Reference to a full FpML product."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(ProductReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductReference.subclass:
            return ProductReference.subclass(*args_, **kwargs_)
        else:
            return ProductReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(ProductReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ProductReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ProductReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProductReference'):
        super(ProductReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ProductReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ProductReference', fromsubclass_=False, pretty_print=True):
        super(ProductReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(ProductReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ProductReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ProductReference


class PricingStructureReference(Reference):
    """Reference to a pricing structure or any derived components (i.e.
    yield curve)."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(PricingStructureReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PricingStructureReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PricingStructureReference.subclass:
            return PricingStructureReference.subclass(*args_, **kwargs_)
        else:
            return PricingStructureReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(PricingStructureReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PricingStructureReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PricingStructureReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PricingStructureReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PricingStructureReference'):
        super(PricingStructureReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PricingStructureReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PricingStructureReference', fromsubclass_=False, pretty_print=True):
        super(PricingStructureReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(PricingStructureReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(PricingStructureReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PricingStructureReference


class PaymentReference(Reference):
    """Reference to a payment."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(PaymentReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PaymentReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PaymentReference.subclass:
            return PaymentReference.subclass(*args_, **kwargs_)
        else:
            return PaymentReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(PaymentReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PaymentReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PaymentReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PaymentReference'):
        super(PaymentReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PaymentReference', fromsubclass_=False, pretty_print=True):
        super(PaymentReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(PaymentReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(PaymentReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PaymentReference


class Payment(PaymentBase):
    """A type for defining payments. In Transparency view, normally the
    payer and receiver party references are not used; however they
    may be provided if necessary for administrative activities such
    as Reporting Party Determination in FX.Can be used to reference
    the yield curve used to estimate the discount factor."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
        'payerPartyReference': MemberSpec_('payerPartyReference', 'PartyReference', 0),
        'payerAccountReference': MemberSpec_('payerAccountReference', 'AccountReference', 0),
        'receiverPartyReference': MemberSpec_('receiverPartyReference', 'PartyReference', 0),
        'receiverAccountReference': MemberSpec_('receiverAccountReference', 'AccountReference', 0),
        'paymentAmount': MemberSpec_('paymentAmount', 'NonNegativeMoney', 0),
        'paymentDate': MemberSpec_('paymentDate', 'AdjustableOrAdjustedDate', 0),
        'paymentType': MemberSpec_('paymentType', 'PaymentType', 0),
        'settlementInformation': MemberSpec_('settlementInformation', 'SettlementInformation', 0),
        'discountFactor': MemberSpec_('discountFactor', 'xsd:decimal', 0),
        'presentValueAmount': MemberSpec_('presentValueAmount', 'Money', 0),
    }
    subclass = None
    superclass = PaymentBase
    def __init__(self, id=None, href=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, paymentAmount=None, paymentDate=None, paymentType=None, settlementInformation=None, discountFactor=None, presentValueAmount=None):
        self.original_tagname_ = None
        super(Payment, self).__init__(id, )
        self.href = _cast(None, href)
        self.payerPartyReference = payerPartyReference
        self.payerAccountReference = payerAccountReference
        self.receiverPartyReference = receiverPartyReference
        self.receiverAccountReference = receiverAccountReference
        self.paymentAmount = paymentAmount
        self.paymentDate = paymentDate
        self.paymentType = paymentType
        self.settlementInformation = settlementInformation
        self.discountFactor = discountFactor
        self.presentValueAmount = presentValueAmount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Payment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Payment.subclass:
            return Payment.subclass(*args_, **kwargs_)
        else:
            return Payment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_payerPartyReference(self): return self.payerPartyReference
    def set_payerPartyReference(self, payerPartyReference): self.payerPartyReference = payerPartyReference
    def get_payerAccountReference(self): return self.payerAccountReference
    def set_payerAccountReference(self, payerAccountReference): self.payerAccountReference = payerAccountReference
    def get_receiverPartyReference(self): return self.receiverPartyReference
    def set_receiverPartyReference(self, receiverPartyReference): self.receiverPartyReference = receiverPartyReference
    def get_receiverAccountReference(self): return self.receiverAccountReference
    def set_receiverAccountReference(self, receiverAccountReference): self.receiverAccountReference = receiverAccountReference
    def get_paymentAmount(self): return self.paymentAmount
    def set_paymentAmount(self, paymentAmount): self.paymentAmount = paymentAmount
    def get_paymentDate(self): return self.paymentDate
    def set_paymentDate(self, paymentDate): self.paymentDate = paymentDate
    def get_paymentType(self): return self.paymentType
    def set_paymentType(self, paymentType): self.paymentType = paymentType
    def get_settlementInformation(self): return self.settlementInformation
    def set_settlementInformation(self, settlementInformation): self.settlementInformation = settlementInformation
    def get_discountFactor(self): return self.discountFactor
    def set_discountFactor(self, discountFactor): self.discountFactor = discountFactor
    def get_presentValueAmount(self): return self.presentValueAmount
    def set_presentValueAmount(self, presentValueAmount): self.presentValueAmount = presentValueAmount
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            self.payerPartyReference is not None or
            self.payerAccountReference is not None or
            self.receiverPartyReference is not None or
            self.receiverAccountReference is not None or
            self.paymentAmount is not None or
            self.paymentDate is not None or
            self.paymentType is not None or
            self.settlementInformation is not None or
            self.discountFactor is not None or
            self.presentValueAmount is not None or
            super(Payment, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Payment', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Payment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Payment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Payment'):
        super(Payment, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Payment')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Payment', fromsubclass_=False, pretty_print=True):
        super(Payment, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.payerPartyReference is not None:
            self.payerPartyReference.export(outfile, level, namespace_, name_='payerPartyReference', pretty_print=pretty_print)
        if self.payerAccountReference is not None:
            self.payerAccountReference.export(outfile, level, namespace_, name_='payerAccountReference', pretty_print=pretty_print)
        if self.receiverPartyReference is not None:
            self.receiverPartyReference.export(outfile, level, namespace_, name_='receiverPartyReference', pretty_print=pretty_print)
        if self.receiverAccountReference is not None:
            self.receiverAccountReference.export(outfile, level, namespace_, name_='receiverAccountReference', pretty_print=pretty_print)
        if self.paymentAmount is not None:
            self.paymentAmount.export(outfile, level, namespace_, name_='paymentAmount', pretty_print=pretty_print)
        if self.paymentDate is not None:
            self.paymentDate.export(outfile, level, namespace_, name_='paymentDate', pretty_print=pretty_print)
        if self.paymentType is not None:
            self.paymentType.export(outfile, level, namespace_, name_='paymentType', pretty_print=pretty_print)
        if self.settlementInformation is not None:
            self.settlementInformation.export(outfile, level, namespace_, name_='settlementInformation', pretty_print=pretty_print)
        if self.discountFactor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdiscountFactor>%s</%sdiscountFactor>%s' % (namespace_, self.gds_format_float(self.discountFactor, input_name='discountFactor'), namespace_, eol_))
        if self.presentValueAmount is not None:
            self.presentValueAmount.export(outfile, level, namespace_, name_='presentValueAmount', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(Payment, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'payerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.payerPartyReference = obj_
            obj_.original_tagname_ = 'payerPartyReference'
        elif nodeName_ == 'payerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.payerAccountReference = obj_
            obj_.original_tagname_ = 'payerAccountReference'
        elif nodeName_ == 'receiverPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.receiverPartyReference = obj_
            obj_.original_tagname_ = 'receiverPartyReference'
        elif nodeName_ == 'receiverAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.receiverAccountReference = obj_
            obj_.original_tagname_ = 'receiverAccountReference'
        elif nodeName_ == 'paymentAmount':
            class_obj_ = self.get_class_obj_(child_, NonNegativeMoney)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.paymentAmount = obj_
            obj_.original_tagname_ = 'paymentAmount'
        elif nodeName_ == 'paymentDate':
            obj_ = AdjustableOrAdjustedDate.factory()
            obj_.build(child_)
            self.paymentDate = obj_
            obj_.original_tagname_ = 'paymentDate'
        elif nodeName_ == 'paymentType':
            obj_ = PaymentType.factory()
            obj_.build(child_)
            self.paymentType = obj_
            obj_.original_tagname_ = 'paymentType'
        elif nodeName_ == 'settlementInformation':
            obj_ = SettlementInformation.factory()
            obj_.build(child_)
            self.settlementInformation = obj_
            obj_.original_tagname_ = 'settlementInformation'
        elif nodeName_ == 'discountFactor':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'discountFactor')
            self.discountFactor = fval_
        elif nodeName_ == 'presentValueAmount':
            obj_ = Money.factory()
            obj_.build(child_)
            self.presentValueAmount = obj_
            obj_.original_tagname_ = 'presentValueAmount'
        super(Payment, self).buildChildren(child_, node, nodeName_, True)
# end class Payment


class PartyTradeIdentifierReference(Reference):
    """A reference to a partyTradeIdentifier object."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(PartyTradeIdentifierReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyTradeIdentifierReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyTradeIdentifierReference.subclass:
            return PartyTradeIdentifierReference.subclass(*args_, **kwargs_)
        else:
            return PartyTradeIdentifierReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(PartyTradeIdentifierReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartyTradeIdentifierReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyTradeIdentifierReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartyTradeIdentifierReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyTradeIdentifierReference'):
        super(PartyTradeIdentifierReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PartyTradeIdentifierReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PartyTradeIdentifierReference', fromsubclass_=False, pretty_print=True):
        super(PartyTradeIdentifierReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(PartyTradeIdentifierReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(PartyTradeIdentifierReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PartyTradeIdentifierReference


class PersonReference(Reference):
    """Reference to an individual."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(PersonReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PersonReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PersonReference.subclass:
            return PersonReference.subclass(*args_, **kwargs_)
        else:
            return PersonReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(PersonReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PersonReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PersonReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PersonReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PersonReference'):
        super(PersonReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PersonReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PersonReference', fromsubclass_=False, pretty_print=True):
        super(PersonReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(PersonReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(PersonReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PersonReference


class PartyReference(Reference):
    """Reference to a party."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(PartyReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyReference.subclass:
            return PartyReference.subclass(*args_, **kwargs_)
        else:
            return PartyReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(PartyReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartyReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartyReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyReference'):
        super(PartyReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PartyReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PartyReference', fromsubclass_=False, pretty_print=True):
        super(PartyReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(PartyReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(PartyReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PartyReference


class Offset(Period):
    """A type defining an offset used in calculating a new date relative to
    a reference date. E.g. calendar days, business days, Commodity
    Business days, etc.."""
    member_data_items_ = {
        'dayType': MemberSpec_('dayType', ['DayTypeEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = Period
    def __init__(self, id=None, periodMultiplier=None, period=None, dayType=None, extensiontype_=None):
        self.original_tagname_ = None
        super(Offset, self).__init__(id, periodMultiplier, period, extensiontype_, )
        self.dayType = dayType
        self.validate_DayTypeEnum(self.dayType)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Offset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Offset.subclass:
            return Offset.subclass(*args_, **kwargs_)
        else:
            return Offset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dayType(self): return self.dayType
    def set_dayType(self, dayType): self.dayType = dayType
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_DayTypeEnum(self, value):
        # Validate type DayTypeEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Business', 'Calendar', 'CommodityBusiness', 'CurrencyBusiness', 'ExchangeBusiness', 'ScheduledTradingDay']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DayTypeEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on DayTypeEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.dayType is not None or
            super(Offset, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Offset', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Offset')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Offset', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Offset'):
        super(Offset, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Offset')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Offset', fromsubclass_=False, pretty_print=True):
        super(Offset, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dayType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdayType>%s</%sdayType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.dayType), input_name='dayType')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(Offset, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dayType':
            dayType_ = child_.text
            dayType_ = re_.sub(String_cleanup_pat_, " ", dayType_).strip()
            dayType_ = self.gds_validate_string(dayType_, node, 'dayType')
            self.dayType = dayType_
            # validate type DayTypeEnum
            self.validate_DayTypeEnum(self.dayType)
        super(Offset, self).buildChildren(child_, node, nodeName_, True)
# end class Offset


class ObservationFrequency(Period):
    """A type defining the frequency at which calculation period end dates
    occur within the regular part of the calculation period schedule
    and thier roll date convention. In case the calculation
    frequency is of value T (term), the period is defined by the
    swap\swapStream\calculationPerioDates\effectiveDate and the
    swap\swapStream\calculationPerioDates\terminationDate."""
    member_data_items_ = {
        'periodConvention': MemberSpec_('periodConvention', ['RollConventionEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = Period
    def __init__(self, id=None, periodMultiplier=None, period=None, periodConvention=None):
        self.original_tagname_ = None
        super(ObservationFrequency, self).__init__(id, periodMultiplier, period, )
        self.periodConvention = periodConvention
        self.validate_RollConventionEnum(self.periodConvention)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ObservationFrequency)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ObservationFrequency.subclass:
            return ObservationFrequency.subclass(*args_, **kwargs_)
        else:
            return ObservationFrequency(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_periodConvention(self): return self.periodConvention
    def set_periodConvention(self, periodConvention): self.periodConvention = periodConvention
    def validate_RollConventionEnum(self, value):
        # Validate type RollConventionEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['EOM', 'FRN', 'IMM', 'IMMCAD', 'IMMAUD', 'IMMNZD', 'SFE', 'NONE', 'TBILL', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '30', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT', 'SUN']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RollConventionEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on RollConventionEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.periodConvention is not None or
            super(ObservationFrequency, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ObservationFrequency', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObservationFrequency')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ObservationFrequency', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ObservationFrequency'):
        super(ObservationFrequency, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ObservationFrequency')
    def exportChildren(self, outfile, level, namespace_='', name_='ObservationFrequency', fromsubclass_=False, pretty_print=True):
        super(ObservationFrequency, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.periodConvention is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%speriodConvention>%s</%speriodConvention>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.periodConvention), input_name='periodConvention')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ObservationFrequency, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'periodConvention':
            periodConvention_ = child_.text
            periodConvention_ = re_.sub(String_cleanup_pat_, " ", periodConvention_).strip()
            periodConvention_ = self.gds_validate_string(periodConvention_, node, 'periodConvention')
            self.periodConvention = periodConvention_
            # validate type RollConventionEnum
            self.validate_RollConventionEnum(self.periodConvention)
        super(ObservationFrequency, self).buildChildren(child_, node, nodeName_, True)
# end class ObservationFrequency


class NumberOfUnitsReference(Reference):
    """A reference to the number of units."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(NumberOfUnitsReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NumberOfUnitsReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NumberOfUnitsReference.subclass:
            return NumberOfUnitsReference.subclass(*args_, **kwargs_)
        else:
            return NumberOfUnitsReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(NumberOfUnitsReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NumberOfUnitsReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NumberOfUnitsReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NumberOfUnitsReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NumberOfUnitsReference'):
        super(NumberOfUnitsReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NumberOfUnitsReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NumberOfUnitsReference', fromsubclass_=False, pretty_print=True):
        super(NumberOfUnitsReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(NumberOfUnitsReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(NumberOfUnitsReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class NumberOfUnitsReference


class NumberOfOptionsReference(Reference):
    """A reference to the number of options."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(NumberOfOptionsReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NumberOfOptionsReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NumberOfOptionsReference.subclass:
            return NumberOfOptionsReference.subclass(*args_, **kwargs_)
        else:
            return NumberOfOptionsReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(NumberOfOptionsReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NumberOfOptionsReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NumberOfOptionsReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NumberOfOptionsReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NumberOfOptionsReference'):
        super(NumberOfOptionsReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NumberOfOptionsReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NumberOfOptionsReference', fromsubclass_=False, pretty_print=True):
        super(NumberOfOptionsReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(NumberOfOptionsReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(NumberOfOptionsReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class NumberOfOptionsReference


class NotionalReference(Reference):
    """A reference to the notional amount."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(NotionalReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NotionalReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NotionalReference.subclass:
            return NotionalReference.subclass(*args_, **kwargs_)
        else:
            return NotionalReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(NotionalReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NotionalReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NotionalReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NotionalReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NotionalReference'):
        super(NotionalReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NotionalReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NotionalReference', fromsubclass_=False, pretty_print=True):
        super(NotionalReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(NotionalReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(NotionalReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class NotionalReference


class NotionalAmountReference(Reference):
    """A reference to the notional amount."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(NotionalAmountReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NotionalAmountReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NotionalAmountReference.subclass:
            return NotionalAmountReference.subclass(*args_, **kwargs_)
        else:
            return NotionalAmountReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(NotionalAmountReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NotionalAmountReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NotionalAmountReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NotionalAmountReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NotionalAmountReference'):
        super(NotionalAmountReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NotionalAmountReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NotionalAmountReference', fromsubclass_=False, pretty_print=True):
        super(NotionalAmountReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(NotionalAmountReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(NotionalAmountReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class NotionalAmountReference


class NonNegativeStep(StepBase):
    """A type defining a step date and non-negative step value pair. This
    step definitions are used to define varying rate or amount
    schedules, e.g. a notional amortization or a step-up coupon
    schedule."""
    member_data_items_ = {
        'stepValue': MemberSpec_('stepValue', ['NonNegativeDecimal', 'xsd:decimal'], 0),
    }
    subclass = None
    superclass = StepBase
    def __init__(self, id=None, stepDate=None, stepValue=None):
        self.original_tagname_ = None
        super(NonNegativeStep, self).__init__(id, stepDate, )
        self.stepValue = stepValue
        self.validate_NonNegativeDecimal(self.stepValue)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NonNegativeStep)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NonNegativeStep.subclass:
            return NonNegativeStep.subclass(*args_, **kwargs_)
        else:
            return NonNegativeStep(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_stepValue(self): return self.stepValue
    def set_stepValue(self, stepValue): self.stepValue = stepValue
    def validate_NonNegativeDecimal(self, value):
        # Validate type NonNegativeDecimal, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on NonNegativeDecimal' % {"value" : value} )
    def hasContent_(self):
        if (
            self.stepValue is not None or
            super(NonNegativeStep, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NonNegativeStep', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NonNegativeStep')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NonNegativeStep', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NonNegativeStep'):
        super(NonNegativeStep, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NonNegativeStep')
    def exportChildren(self, outfile, level, namespace_='', name_='NonNegativeStep', fromsubclass_=False, pretty_print=True):
        super(NonNegativeStep, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.stepValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstepValue>%s</%sstepValue>%s' % (namespace_, self.gds_format_float(self.stepValue, input_name='stepValue'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NonNegativeStep, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'stepValue':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'stepValue')
            self.stepValue = fval_
            # validate type NonNegativeDecimal
            self.validate_NonNegativeDecimal(self.stepValue)
        super(NonNegativeStep, self).buildChildren(child_, node, nodeName_, True)
# end class NonNegativeStep


class NonNegativePayment(PaymentBaseExtended):
    """A complex type to specify non negative payments."""
    member_data_items_ = {
        'paymentAmount': MemberSpec_('paymentAmount', 'NonNegativeMoney', 0),
    }
    subclass = None
    superclass = PaymentBaseExtended
    def __init__(self, id=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, paymentDate=None, paymentAmount=None, extensiontype_=None):
        self.original_tagname_ = None
        super(NonNegativePayment, self).__init__(id, payerPartyReference, payerAccountReference, receiverPartyReference, receiverAccountReference, paymentDate, extensiontype_, )
        self.paymentAmount = paymentAmount
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NonNegativePayment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NonNegativePayment.subclass:
            return NonNegativePayment.subclass(*args_, **kwargs_)
        else:
            return NonNegativePayment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_paymentAmount(self): return self.paymentAmount
    def set_paymentAmount(self, paymentAmount): self.paymentAmount = paymentAmount
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.paymentAmount is not None or
            super(NonNegativePayment, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NonNegativePayment', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NonNegativePayment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NonNegativePayment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NonNegativePayment'):
        super(NonNegativePayment, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NonNegativePayment')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='NonNegativePayment', fromsubclass_=False, pretty_print=True):
        super(NonNegativePayment, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.paymentAmount is not None:
            self.paymentAmount.export(outfile, level, namespace_, name_='paymentAmount', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(NonNegativePayment, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'paymentAmount':
            class_obj_ = self.get_class_obj_(child_, NonNegativeMoney)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.paymentAmount = obj_
            obj_.original_tagname_ = 'paymentAmount'
        super(NonNegativePayment, self).buildChildren(child_, node, nodeName_, True)
# end class NonNegativePayment


class NonNegativeAmountSchedule(NonNegativeSchedule):
    """A type defining a currency amount or a currency amount schedule."""
    member_data_items_ = {
        'currency': MemberSpec_('currency', 'Currency', 0),
    }
    subclass = None
    superclass = NonNegativeSchedule
    def __init__(self, id=None, initialValue=None, step=None, currency=None):
        self.original_tagname_ = None
        super(NonNegativeAmountSchedule, self).__init__(id, initialValue, step, )
        self.currency = currency
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NonNegativeAmountSchedule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NonNegativeAmountSchedule.subclass:
            return NonNegativeAmountSchedule.subclass(*args_, **kwargs_)
        else:
            return NonNegativeAmountSchedule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def hasContent_(self):
        if (
            self.currency is not None or
            super(NonNegativeAmountSchedule, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NonNegativeAmountSchedule', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NonNegativeAmountSchedule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NonNegativeAmountSchedule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NonNegativeAmountSchedule'):
        super(NonNegativeAmountSchedule, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NonNegativeAmountSchedule')
    def exportChildren(self, outfile, level, namespace_='', name_='NonNegativeAmountSchedule', fromsubclass_=False, pretty_print=True):
        super(NonNegativeAmountSchedule, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.currency is not None:
            self.currency.export(outfile, level, namespace_, name_='currency', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NonNegativeAmountSchedule, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'currency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        super(NonNegativeAmountSchedule, self).buildChildren(child_, node, nodeName_, True)
# end class NonNegativeAmountSchedule


class Money(MoneyBase):
    """A type defining a currency amount."""
    member_data_items_ = {
        'amount': MemberSpec_('amount', 'xsd:decimal', 0),
    }
    subclass = None
    superclass = MoneyBase
    def __init__(self, id=None, currency=None, amount=None):
        self.original_tagname_ = None
        super(Money, self).__init__(id, currency, )
        self.amount = amount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Money)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Money.subclass:
            return Money.subclass(*args_, **kwargs_)
        else:
            return Money(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_amount(self): return self.amount
    def set_amount(self, amount): self.amount = amount
    def hasContent_(self):
        if (
            self.amount is not None or
            super(Money, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Money', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Money')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Money', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Money'):
        super(Money, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Money')
    def exportChildren(self, outfile, level, namespace_='', name_='Money', fromsubclass_=False, pretty_print=True):
        super(Money, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.amount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%samount>%s</%samount>%s' % (namespace_, self.gds_format_float(self.amount, input_name='amount'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Money, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'amount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'amount')
            self.amount = fval_
        super(Money, self).buildChildren(child_, node, nodeName_, True)
# end class Money


class LegalEntityReference(Reference):
    """References a credit entity defined elsewhere in the document."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(LegalEntityReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LegalEntityReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LegalEntityReference.subclass:
            return LegalEntityReference.subclass(*args_, **kwargs_)
        else:
            return LegalEntityReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(LegalEntityReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LegalEntityReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LegalEntityReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LegalEntityReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LegalEntityReference'):
        super(LegalEntityReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LegalEntityReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LegalEntityReference', fromsubclass_=False, pretty_print=True):
        super(LegalEntityReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(LegalEntityReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(LegalEntityReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class LegalEntityReference


class InterestAccrualsCompoundingMethod(InterestAccrualsMethod):
    """A type defining the way in which interests are accrued: the
    applicable rate (fixed or floating reference) and the
    compounding method."""
    member_data_items_ = {
        'compoundingMethod': MemberSpec_('compoundingMethod', ['CompoundingMethodEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = InterestAccrualsMethod
    def __init__(self, floatingRateCalculation=None, fixedRate=None, compoundingMethod=None):
        self.original_tagname_ = None
        super(InterestAccrualsCompoundingMethod, self).__init__(floatingRateCalculation, fixedRate, )
        self.compoundingMethod = compoundingMethod
        self.validate_CompoundingMethodEnum(self.compoundingMethod)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InterestAccrualsCompoundingMethod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InterestAccrualsCompoundingMethod.subclass:
            return InterestAccrualsCompoundingMethod.subclass(*args_, **kwargs_)
        else:
            return InterestAccrualsCompoundingMethod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_compoundingMethod(self): return self.compoundingMethod
    def set_compoundingMethod(self, compoundingMethod): self.compoundingMethod = compoundingMethod
    def validate_CompoundingMethodEnum(self, value):
        # Validate type CompoundingMethodEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Flat', 'None', 'Straight', 'SpreadExclusive']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CompoundingMethodEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on CompoundingMethodEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.compoundingMethod is not None or
            super(InterestAccrualsCompoundingMethod, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InterestAccrualsCompoundingMethod', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InterestAccrualsCompoundingMethod')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InterestAccrualsCompoundingMethod', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InterestAccrualsCompoundingMethod'):
        super(InterestAccrualsCompoundingMethod, self).exportAttributes(outfile, level, already_processed, namespace_, name_='InterestAccrualsCompoundingMethod')
    def exportChildren(self, outfile, level, namespace_='', name_='InterestAccrualsCompoundingMethod', fromsubclass_=False, pretty_print=True):
        super(InterestAccrualsCompoundingMethod, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.compoundingMethod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scompoundingMethod>%s</%scompoundingMethod>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.compoundingMethod), input_name='compoundingMethod')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(InterestAccrualsCompoundingMethod, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'compoundingMethod':
            compoundingMethod_ = child_.text
            compoundingMethod_ = re_.sub(String_cleanup_pat_, " ", compoundingMethod_).strip()
            compoundingMethod_ = self.gds_validate_string(compoundingMethod_, node, 'compoundingMethod')
            self.compoundingMethod = compoundingMethod_
            # validate type CompoundingMethodEnum
            self.validate_CompoundingMethodEnum(self.compoundingMethod)
        super(InterestAccrualsCompoundingMethod, self).buildChildren(child_, node, nodeName_, True)
# end class InterestAccrualsCompoundingMethod


class IdentifiedCurrencyReference(Reference):
    """Reference to a currency with ID attribute"""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(IdentifiedCurrencyReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IdentifiedCurrencyReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IdentifiedCurrencyReference.subclass:
            return IdentifiedCurrencyReference.subclass(*args_, **kwargs_)
        else:
            return IdentifiedCurrencyReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(IdentifiedCurrencyReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IdentifiedCurrencyReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifiedCurrencyReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IdentifiedCurrencyReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IdentifiedCurrencyReference'):
        super(IdentifiedCurrencyReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifiedCurrencyReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IdentifiedCurrencyReference', fromsubclass_=False, pretty_print=True):
        super(IdentifiedCurrencyReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(IdentifiedCurrencyReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(IdentifiedCurrencyReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IdentifiedCurrencyReference


class FxInformationSource(InformationSource):
    member_data_items_ = {
        'fixingTime': MemberSpec_('fixingTime', 'BusinessCenterTime', 0),
    }
    subclass = None
    superclass = InformationSource
    def __init__(self, rateSource=None, rateSourcePage=None, rateSourcePageHeading=None, fixingTime=None):
        self.original_tagname_ = None
        super(FxInformationSource, self).__init__(rateSource, rateSourcePage, rateSourcePageHeading, )
        self.fixingTime = fixingTime
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FxInformationSource)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FxInformationSource.subclass:
            return FxInformationSource.subclass(*args_, **kwargs_)
        else:
            return FxInformationSource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fixingTime(self): return self.fixingTime
    def set_fixingTime(self, fixingTime): self.fixingTime = fixingTime
    def hasContent_(self):
        if (
            self.fixingTime is not None or
            super(FxInformationSource, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FxInformationSource', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FxInformationSource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FxInformationSource', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FxInformationSource'):
        super(FxInformationSource, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FxInformationSource')
    def exportChildren(self, outfile, level, namespace_='', name_='FxInformationSource', fromsubclass_=False, pretty_print=True):
        super(FxInformationSource, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.fixingTime is not None:
            self.fixingTime.export(outfile, level, namespace_, name_='fixingTime', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FxInformationSource, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fixingTime':
            obj_ = BusinessCenterTime.factory()
            obj_.build(child_)
            self.fixingTime = obj_
            obj_.original_tagname_ = 'fixingTime'
        super(FxInformationSource, self).buildChildren(child_, node, nodeName_, True)
# end class FxInformationSource


class FutureValueAmount(NonNegativeMoney):
    """A type defining a currency amount as at a future value date.A type
    defining a currency amount as at a future value date. - For use
    with pre-trade Credit Limit Check messages."""
    member_data_items_ = {
        'calculationPeriodNumberOfDays': MemberSpec_('calculationPeriodNumberOfDays', 'xsd:positiveInteger', 0),
        'valueDate': MemberSpec_('valueDate', 'xsd:date', 0),
    }
    subclass = None
    superclass = NonNegativeMoney
    def __init__(self, id=None, currency=None, amount=None, calculationPeriodNumberOfDays=None, valueDate=None):
        self.original_tagname_ = None
        super(FutureValueAmount, self).__init__(id, currency, amount, )
        self.calculationPeriodNumberOfDays = calculationPeriodNumberOfDays
        if isinstance(valueDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(valueDate, '%Y-%m-%d').date()
        else:
            initvalue_ = valueDate
        self.valueDate = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FutureValueAmount)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FutureValueAmount.subclass:
            return FutureValueAmount.subclass(*args_, **kwargs_)
        else:
            return FutureValueAmount(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_calculationPeriodNumberOfDays(self): return self.calculationPeriodNumberOfDays
    def set_calculationPeriodNumberOfDays(self, calculationPeriodNumberOfDays): self.calculationPeriodNumberOfDays = calculationPeriodNumberOfDays
    def get_valueDate(self): return self.valueDate
    def set_valueDate(self, valueDate): self.valueDate = valueDate
    def hasContent_(self):
        if (
            self.calculationPeriodNumberOfDays is not None or
            self.valueDate is not None or
            super(FutureValueAmount, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FutureValueAmount', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FutureValueAmount')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FutureValueAmount', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FutureValueAmount'):
        super(FutureValueAmount, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FutureValueAmount')
    def exportChildren(self, outfile, level, namespace_='', name_='FutureValueAmount', fromsubclass_=False, pretty_print=True):
        super(FutureValueAmount, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.calculationPeriodNumberOfDays is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scalculationPeriodNumberOfDays>%s</%scalculationPeriodNumberOfDays>%s' % (namespace_, self.gds_format_integer(self.calculationPeriodNumberOfDays, input_name='calculationPeriodNumberOfDays'), namespace_, eol_))
        if self.valueDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalueDate>%s</%svalueDate>%s' % (namespace_, self.gds_format_date(self.valueDate, input_name='valueDate'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FutureValueAmount, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'calculationPeriodNumberOfDays':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'calculationPeriodNumberOfDays')
            self.calculationPeriodNumberOfDays = ival_
        elif nodeName_ == 'valueDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.valueDate = dval_
        super(FutureValueAmount, self).buildChildren(child_, node, nodeName_, True)
# end class FutureValueAmount


class FloatingRate(Rate):
    """A type defining a floating rate."""
    member_data_items_ = {
        'floatingRateIndex': MemberSpec_('floatingRateIndex', 'FloatingRateIndex', 0),
        'indexTenor': MemberSpec_('indexTenor', 'Period', 0),
        'floatingRateMultiplierSchedule': MemberSpec_('floatingRateMultiplierSchedule', 'Schedule', 0),
        'spreadSchedule': MemberSpec_('spreadSchedule', 'SpreadSchedule', 1),
        'rateTreatment': MemberSpec_('rateTreatment', ['RateTreatmentEnum', 'Token', 'xsd:token'], 0),
        'capRateSchedule': MemberSpec_('capRateSchedule', 'StrikeSchedule', 1),
        'floorRateSchedule': MemberSpec_('floorRateSchedule', 'StrikeSchedule', 1),
        'capFloorStraddle': MemberSpec_('capFloorStraddle', 'xsd:boolean', 0),
    }
    subclass = None
    superclass = Rate
    def __init__(self, id=None, floatingRateIndex=None, indexTenor=None, floatingRateMultiplierSchedule=None, spreadSchedule=None, rateTreatment=None, capRateSchedule=None, floorRateSchedule=None, capFloorStraddle=None, extensiontype_=None):
        self.original_tagname_ = None
        super(FloatingRate, self).__init__(id, extensiontype_, )
        self.floatingRateIndex = floatingRateIndex
        self.indexTenor = indexTenor
        self.floatingRateMultiplierSchedule = floatingRateMultiplierSchedule
        if spreadSchedule is None:
            self.spreadSchedule = []
        else:
            self.spreadSchedule = spreadSchedule
        self.rateTreatment = rateTreatment
        self.validate_RateTreatmentEnum(self.rateTreatment)
        if capRateSchedule is None:
            self.capRateSchedule = []
        else:
            self.capRateSchedule = capRateSchedule
        if floorRateSchedule is None:
            self.floorRateSchedule = []
        else:
            self.floorRateSchedule = floorRateSchedule
        self.capFloorStraddle = capFloorStraddle
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FloatingRate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FloatingRate.subclass:
            return FloatingRate.subclass(*args_, **kwargs_)
        else:
            return FloatingRate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_floatingRateIndex(self): return self.floatingRateIndex
    def set_floatingRateIndex(self, floatingRateIndex): self.floatingRateIndex = floatingRateIndex
    def get_indexTenor(self): return self.indexTenor
    def set_indexTenor(self, indexTenor): self.indexTenor = indexTenor
    def get_floatingRateMultiplierSchedule(self): return self.floatingRateMultiplierSchedule
    def set_floatingRateMultiplierSchedule(self, floatingRateMultiplierSchedule): self.floatingRateMultiplierSchedule = floatingRateMultiplierSchedule
    def get_spreadSchedule(self): return self.spreadSchedule
    def set_spreadSchedule(self, spreadSchedule): self.spreadSchedule = spreadSchedule
    def add_spreadSchedule(self, value): self.spreadSchedule.append(value)
    def insert_spreadSchedule_at(self, index, value): self.spreadSchedule.insert(index, value)
    def replace_spreadSchedule_at(self, index, value): self.spreadSchedule[index] = value
    def get_rateTreatment(self): return self.rateTreatment
    def set_rateTreatment(self, rateTreatment): self.rateTreatment = rateTreatment
    def get_capRateSchedule(self): return self.capRateSchedule
    def set_capRateSchedule(self, capRateSchedule): self.capRateSchedule = capRateSchedule
    def add_capRateSchedule(self, value): self.capRateSchedule.append(value)
    def insert_capRateSchedule_at(self, index, value): self.capRateSchedule.insert(index, value)
    def replace_capRateSchedule_at(self, index, value): self.capRateSchedule[index] = value
    def get_floorRateSchedule(self): return self.floorRateSchedule
    def set_floorRateSchedule(self, floorRateSchedule): self.floorRateSchedule = floorRateSchedule
    def add_floorRateSchedule(self, value): self.floorRateSchedule.append(value)
    def insert_floorRateSchedule_at(self, index, value): self.floorRateSchedule.insert(index, value)
    def replace_floorRateSchedule_at(self, index, value): self.floorRateSchedule[index] = value
    def get_capFloorStraddle(self): return self.capFloorStraddle
    def set_capFloorStraddle(self, capFloorStraddle): self.capFloorStraddle = capFloorStraddle
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_RateTreatmentEnum(self, value):
        # Validate type RateTreatmentEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['BondEquivalentYield', 'MoneyMarketYield']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RateTreatmentEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on RateTreatmentEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.floatingRateIndex is not None or
            self.indexTenor is not None or
            self.floatingRateMultiplierSchedule is not None or
            self.spreadSchedule or
            self.rateTreatment is not None or
            self.capRateSchedule or
            self.floorRateSchedule or
            self.capFloorStraddle is not None or
            super(FloatingRate, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FloatingRate', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FloatingRate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FloatingRate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FloatingRate'):
        super(FloatingRate, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FloatingRate')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='FloatingRate', fromsubclass_=False, pretty_print=True):
        super(FloatingRate, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.floatingRateIndex is not None:
            self.floatingRateIndex.export(outfile, level, namespace_, name_='floatingRateIndex', pretty_print=pretty_print)
        if self.indexTenor is not None:
            self.indexTenor.export(outfile, level, namespace_, name_='indexTenor', pretty_print=pretty_print)
        if self.floatingRateMultiplierSchedule is not None:
            self.floatingRateMultiplierSchedule.export(outfile, level, namespace_, name_='floatingRateMultiplierSchedule', pretty_print=pretty_print)
        for spreadSchedule_ in self.spreadSchedule:
            spreadSchedule_.export(outfile, level, namespace_, name_='spreadSchedule', pretty_print=pretty_print)
        if self.rateTreatment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srateTreatment>%s</%srateTreatment>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.rateTreatment), input_name='rateTreatment')), namespace_, eol_))
        for capRateSchedule_ in self.capRateSchedule:
            capRateSchedule_.export(outfile, level, namespace_, name_='capRateSchedule', pretty_print=pretty_print)
        for floorRateSchedule_ in self.floorRateSchedule:
            floorRateSchedule_.export(outfile, level, namespace_, name_='floorRateSchedule', pretty_print=pretty_print)
        if self.capFloorStraddle is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scapFloorStraddle>%s</%scapFloorStraddle>%s' % (namespace_, self.gds_format_boolean(self.capFloorStraddle, input_name='capFloorStraddle'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(FloatingRate, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'floatingRateIndex':
            obj_ = FloatingRateIndex.factory()
            obj_.build(child_)
            self.floatingRateIndex = obj_
            obj_.original_tagname_ = 'floatingRateIndex'
        elif nodeName_ == 'indexTenor':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.indexTenor = obj_
            obj_.original_tagname_ = 'indexTenor'
        elif nodeName_ == 'floatingRateMultiplierSchedule':
            class_obj_ = self.get_class_obj_(child_, Schedule)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.floatingRateMultiplierSchedule = obj_
            obj_.original_tagname_ = 'floatingRateMultiplierSchedule'
        elif nodeName_ == 'spreadSchedule':
            obj_ = SpreadSchedule.factory()
            obj_.build(child_)
            self.spreadSchedule.append(obj_)
            obj_.original_tagname_ = 'spreadSchedule'
        elif nodeName_ == 'rateTreatment':
            rateTreatment_ = child_.text
            rateTreatment_ = re_.sub(String_cleanup_pat_, " ", rateTreatment_).strip()
            rateTreatment_ = self.gds_validate_string(rateTreatment_, node, 'rateTreatment')
            self.rateTreatment = rateTreatment_
            # validate type RateTreatmentEnum
            self.validate_RateTreatmentEnum(self.rateTreatment)
        elif nodeName_ == 'capRateSchedule':
            obj_ = StrikeSchedule.factory()
            obj_.build(child_)
            self.capRateSchedule.append(obj_)
            obj_.original_tagname_ = 'capRateSchedule'
        elif nodeName_ == 'floorRateSchedule':
            obj_ = StrikeSchedule.factory()
            obj_.build(child_)
            self.floorRateSchedule.append(obj_)
            obj_.original_tagname_ = 'floorRateSchedule'
        elif nodeName_ == 'capFloorStraddle':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'capFloorStraddle')
            self.capFloorStraddle = ival_
        super(FloatingRate, self).buildChildren(child_, node, nodeName_, True)
# end class FloatingRate


class EuropeanExercise(Exercise):
    """A type defining the exercise period for a European style option
    together with any rules governing the notional amount of the
    underlying which can be exercised on any given exercise date and
    any associated exercise fees."""
    member_data_items_ = {
        'expirationDate': MemberSpec_('expirationDate', 'AdjustableOrRelativeDate', 0),
        'relevantUnderlyingDate': MemberSpec_('relevantUnderlyingDate', 'AdjustableOrRelativeDates', 0),
        'earliestExerciseTime': MemberSpec_('earliestExerciseTime', 'BusinessCenterTime', 0),
        'expirationTime': MemberSpec_('expirationTime', 'BusinessCenterTime', 0),
        'partialExercise': MemberSpec_('partialExercise', 'PartialExercise', 0),
        'exerciseFee': MemberSpec_('exerciseFee', 'ExerciseFee', 0),
    }
    subclass = None
    superclass = Exercise
    def __init__(self, id=None, expirationDate=None, relevantUnderlyingDate=None, earliestExerciseTime=None, expirationTime=None, partialExercise=None, exerciseFee=None):
        self.original_tagname_ = None
        super(EuropeanExercise, self).__init__(id, )
        self.expirationDate = expirationDate
        self.relevantUnderlyingDate = relevantUnderlyingDate
        self.earliestExerciseTime = earliestExerciseTime
        self.expirationTime = expirationTime
        self.partialExercise = partialExercise
        self.exerciseFee = exerciseFee
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EuropeanExercise)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EuropeanExercise.subclass:
            return EuropeanExercise.subclass(*args_, **kwargs_)
        else:
            return EuropeanExercise(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_expirationDate(self): return self.expirationDate
    def set_expirationDate(self, expirationDate): self.expirationDate = expirationDate
    def get_relevantUnderlyingDate(self): return self.relevantUnderlyingDate
    def set_relevantUnderlyingDate(self, relevantUnderlyingDate): self.relevantUnderlyingDate = relevantUnderlyingDate
    def get_earliestExerciseTime(self): return self.earliestExerciseTime
    def set_earliestExerciseTime(self, earliestExerciseTime): self.earliestExerciseTime = earliestExerciseTime
    def get_expirationTime(self): return self.expirationTime
    def set_expirationTime(self, expirationTime): self.expirationTime = expirationTime
    def get_partialExercise(self): return self.partialExercise
    def set_partialExercise(self, partialExercise): self.partialExercise = partialExercise
    def get_exerciseFee(self): return self.exerciseFee
    def set_exerciseFee(self, exerciseFee): self.exerciseFee = exerciseFee
    def hasContent_(self):
        if (
            self.expirationDate is not None or
            self.relevantUnderlyingDate is not None or
            self.earliestExerciseTime is not None or
            self.expirationTime is not None or
            self.partialExercise is not None or
            self.exerciseFee is not None or
            super(EuropeanExercise, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EuropeanExercise', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EuropeanExercise')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EuropeanExercise', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EuropeanExercise'):
        super(EuropeanExercise, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EuropeanExercise')
    def exportChildren(self, outfile, level, namespace_='', name_='EuropeanExercise', fromsubclass_=False, pretty_print=True):
        super(EuropeanExercise, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.expirationDate is not None:
            self.expirationDate.export(outfile, level, namespace_, name_='expirationDate', pretty_print=pretty_print)
        if self.relevantUnderlyingDate is not None:
            self.relevantUnderlyingDate.export(outfile, level, namespace_, name_='relevantUnderlyingDate', pretty_print=pretty_print)
        if self.earliestExerciseTime is not None:
            self.earliestExerciseTime.export(outfile, level, namespace_, name_='earliestExerciseTime', pretty_print=pretty_print)
        if self.expirationTime is not None:
            self.expirationTime.export(outfile, level, namespace_, name_='expirationTime', pretty_print=pretty_print)
        if self.partialExercise is not None:
            self.partialExercise.export(outfile, level, namespace_, name_='partialExercise', pretty_print=pretty_print)
        if self.exerciseFee is not None:
            self.exerciseFee.export(outfile, level, namespace_, name_='exerciseFee', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EuropeanExercise, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'expirationDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.expirationDate = obj_
            obj_.original_tagname_ = 'expirationDate'
        elif nodeName_ == 'relevantUnderlyingDate':
            obj_ = AdjustableOrRelativeDates.factory()
            obj_.build(child_)
            self.relevantUnderlyingDate = obj_
            obj_.original_tagname_ = 'relevantUnderlyingDate'
        elif nodeName_ == 'earliestExerciseTime':
            obj_ = BusinessCenterTime.factory()
            obj_.build(child_)
            self.earliestExerciseTime = obj_
            obj_.original_tagname_ = 'earliestExerciseTime'
        elif nodeName_ == 'expirationTime':
            obj_ = BusinessCenterTime.factory()
            obj_.build(child_)
            self.expirationTime = obj_
            obj_.original_tagname_ = 'expirationTime'
        elif nodeName_ == 'partialExercise':
            obj_ = PartialExercise.factory()
            obj_.build(child_)
            self.partialExercise = obj_
            obj_.original_tagname_ = 'partialExercise'
        elif nodeName_ == 'exerciseFee':
            obj_ = ExerciseFee.factory()
            obj_.build(child_)
            self.exerciseFee = obj_
            obj_.original_tagname_ = 'exerciseFee'
        super(EuropeanExercise, self).buildChildren(child_, node, nodeName_, True)
# end class EuropeanExercise


class DirectionalLeg(Leg):
    """An abstract base class for all directional leg types with effective
    date, termination date, where a payer makes a stream of payments
    of greater than zero value to a receiver."""
    member_data_items_ = {
        'legIdentifier': MemberSpec_('legIdentifier', 'LegIdentifier', 1),
        'payerPartyReference': MemberSpec_('payerPartyReference', 'PartyReference', 0),
        'payerAccountReference': MemberSpec_('payerAccountReference', 'AccountReference', 0),
        'receiverPartyReference': MemberSpec_('receiverPartyReference', 'PartyReference', 0),
        'receiverAccountReference': MemberSpec_('receiverAccountReference', 'AccountReference', 0),
        'effectiveDate': MemberSpec_('effectiveDate', 'AdjustableOrRelativeDate', 0),
        'terminationDate': MemberSpec_('terminationDate', 'AdjustableOrRelativeDate', 0),
    }
    subclass = None
    superclass = Leg
    def __init__(self, id=None, legIdentifier=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, effectiveDate=None, terminationDate=None, extensiontype_=None):
        self.original_tagname_ = None
        super(DirectionalLeg, self).__init__(id, extensiontype_, )
        if legIdentifier is None:
            self.legIdentifier = []
        else:
            self.legIdentifier = legIdentifier
        self.payerPartyReference = payerPartyReference
        self.payerAccountReference = payerAccountReference
        self.receiverPartyReference = receiverPartyReference
        self.receiverAccountReference = receiverAccountReference
        self.effectiveDate = effectiveDate
        self.terminationDate = terminationDate
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DirectionalLeg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DirectionalLeg.subclass:
            return DirectionalLeg.subclass(*args_, **kwargs_)
        else:
            return DirectionalLeg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_legIdentifier(self): return self.legIdentifier
    def set_legIdentifier(self, legIdentifier): self.legIdentifier = legIdentifier
    def add_legIdentifier(self, value): self.legIdentifier.append(value)
    def insert_legIdentifier_at(self, index, value): self.legIdentifier.insert(index, value)
    def replace_legIdentifier_at(self, index, value): self.legIdentifier[index] = value
    def get_payerPartyReference(self): return self.payerPartyReference
    def set_payerPartyReference(self, payerPartyReference): self.payerPartyReference = payerPartyReference
    def get_payerAccountReference(self): return self.payerAccountReference
    def set_payerAccountReference(self, payerAccountReference): self.payerAccountReference = payerAccountReference
    def get_receiverPartyReference(self): return self.receiverPartyReference
    def set_receiverPartyReference(self, receiverPartyReference): self.receiverPartyReference = receiverPartyReference
    def get_receiverAccountReference(self): return self.receiverAccountReference
    def set_receiverAccountReference(self, receiverAccountReference): self.receiverAccountReference = receiverAccountReference
    def get_effectiveDate(self): return self.effectiveDate
    def set_effectiveDate(self, effectiveDate): self.effectiveDate = effectiveDate
    def get_terminationDate(self): return self.terminationDate
    def set_terminationDate(self, terminationDate): self.terminationDate = terminationDate
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.legIdentifier or
            self.payerPartyReference is not None or
            self.payerAccountReference is not None or
            self.receiverPartyReference is not None or
            self.receiverAccountReference is not None or
            self.effectiveDate is not None or
            self.terminationDate is not None or
            super(DirectionalLeg, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DirectionalLeg', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DirectionalLeg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DirectionalLeg', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DirectionalLeg'):
        super(DirectionalLeg, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DirectionalLeg')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='DirectionalLeg', fromsubclass_=False, pretty_print=True):
        super(DirectionalLeg, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for legIdentifier_ in self.legIdentifier:
            legIdentifier_.export(outfile, level, namespace_, name_='legIdentifier', pretty_print=pretty_print)
        if self.payerPartyReference is not None:
            self.payerPartyReference.export(outfile, level, namespace_, name_='payerPartyReference', pretty_print=pretty_print)
        if self.payerAccountReference is not None:
            self.payerAccountReference.export(outfile, level, namespace_, name_='payerAccountReference', pretty_print=pretty_print)
        if self.receiverPartyReference is not None:
            self.receiverPartyReference.export(outfile, level, namespace_, name_='receiverPartyReference', pretty_print=pretty_print)
        if self.receiverAccountReference is not None:
            self.receiverAccountReference.export(outfile, level, namespace_, name_='receiverAccountReference', pretty_print=pretty_print)
        if self.effectiveDate is not None:
            self.effectiveDate.export(outfile, level, namespace_, name_='effectiveDate', pretty_print=pretty_print)
        if self.terminationDate is not None:
            self.terminationDate.export(outfile, level, namespace_, name_='terminationDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(DirectionalLeg, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'legIdentifier':
            obj_ = LegIdentifier.factory()
            obj_.build(child_)
            self.legIdentifier.append(obj_)
            obj_.original_tagname_ = 'legIdentifier'
        elif nodeName_ == 'payerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.payerPartyReference = obj_
            obj_.original_tagname_ = 'payerPartyReference'
        elif nodeName_ == 'payerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.payerAccountReference = obj_
            obj_.original_tagname_ = 'payerAccountReference'
        elif nodeName_ == 'receiverPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.receiverPartyReference = obj_
            obj_.original_tagname_ = 'receiverPartyReference'
        elif nodeName_ == 'receiverAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.receiverAccountReference = obj_
            obj_.original_tagname_ = 'receiverAccountReference'
        elif nodeName_ == 'effectiveDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.effectiveDate = obj_
            obj_.original_tagname_ = 'effectiveDate'
        elif nodeName_ == 'terminationDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.terminationDate = obj_
            obj_.original_tagname_ = 'terminationDate'
        super(DirectionalLeg, self).buildChildren(child_, node, nodeName_, True)
# end class DirectionalLeg


class DeterminationMethodReference(Reference):
    """A reference to the return swap notional determination method."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(DeterminationMethodReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DeterminationMethodReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DeterminationMethodReference.subclass:
            return DeterminationMethodReference.subclass(*args_, **kwargs_)
        else:
            return DeterminationMethodReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(DeterminationMethodReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DeterminationMethodReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeterminationMethodReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DeterminationMethodReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DeterminationMethodReference'):
        super(DeterminationMethodReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DeterminationMethodReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DeterminationMethodReference', fromsubclass_=False, pretty_print=True):
        super(DeterminationMethodReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(DeterminationMethodReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DeterminationMethodReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DeterminationMethodReference


class DateReference(Reference):
    """Reference to an identified date or a complex date structure."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(DateReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DateReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DateReference.subclass:
            return DateReference.subclass(*args_, **kwargs_)
        else:
            return DateReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(DateReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DateReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DateReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DateReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DateReference'):
        super(DateReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DateReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DateReference', fromsubclass_=False, pretty_print=True):
        super(DateReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(DateReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DateReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DateReference


class DateOffset(Offset):
    """A type defining an offset used in calculating a date when this date
    is defined in reference to another date through a date offset.
    The type includes the convention for adjusting the date and an
    optional sequence element to indicate the order in a sequence of
    multiple date offsets."""
    member_data_items_ = {
        'businessDayConvention': MemberSpec_('businessDayConvention', ['BusinessDayConventionEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = Offset
    def __init__(self, id=None, periodMultiplier=None, period=None, dayType=None, businessDayConvention=None):
        self.original_tagname_ = None
        super(DateOffset, self).__init__(id, periodMultiplier, period, dayType, )
        self.businessDayConvention = businessDayConvention
        self.validate_BusinessDayConventionEnum(self.businessDayConvention)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DateOffset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DateOffset.subclass:
            return DateOffset.subclass(*args_, **kwargs_)
        else:
            return DateOffset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_businessDayConvention(self): return self.businessDayConvention
    def set_businessDayConvention(self, businessDayConvention): self.businessDayConvention = businessDayConvention
    def validate_BusinessDayConventionEnum(self, value):
        # Validate type BusinessDayConventionEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FOLLOWING', 'FRN', 'MODFOLLOWING', 'PRECEDING', 'MODPRECEDING', 'NEAREST', 'NONE', 'NotApplicable']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on BusinessDayConventionEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on BusinessDayConventionEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.businessDayConvention is not None or
            super(DateOffset, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DateOffset', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DateOffset')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DateOffset', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DateOffset'):
        super(DateOffset, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DateOffset')
    def exportChildren(self, outfile, level, namespace_='', name_='DateOffset', fromsubclass_=False, pretty_print=True):
        super(DateOffset, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.businessDayConvention is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbusinessDayConvention>%s</%sbusinessDayConvention>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.businessDayConvention), input_name='businessDayConvention')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DateOffset, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'businessDayConvention':
            businessDayConvention_ = child_.text
            businessDayConvention_ = re_.sub(String_cleanup_pat_, " ", businessDayConvention_).strip()
            businessDayConvention_ = self.gds_validate_string(businessDayConvention_, node, 'businessDayConvention')
            self.businessDayConvention = businessDayConvention_
            # validate type BusinessDayConventionEnum
            self.validate_BusinessDayConventionEnum(self.businessDayConvention)
        super(DateOffset, self).buildChildren(child_, node, nodeName_, True)
# end class DateOffset


class CalculationPeriodFrequency(Frequency):
    """A type defining the frequency at which calculation period end dates
    occur within the regular part of the calculation period schedule
    and thier roll date convention. In case the calculation
    frequency is of value T (term), the period is defined by the
    swap\swapStream\calculationPerioDates\effectiveDate and the
    swap\swapStream\calculationPerioDates\terminationDate."""
    member_data_items_ = {
        'rollConvention': MemberSpec_('rollConvention', ['RollConventionEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = Frequency
    def __init__(self, id=None, periodMultiplier=None, period=None, rollConvention=None):
        self.original_tagname_ = None
        super(CalculationPeriodFrequency, self).__init__(id, periodMultiplier, period, )
        self.rollConvention = rollConvention
        self.validate_RollConventionEnum(self.rollConvention)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CalculationPeriodFrequency)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CalculationPeriodFrequency.subclass:
            return CalculationPeriodFrequency.subclass(*args_, **kwargs_)
        else:
            return CalculationPeriodFrequency(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rollConvention(self): return self.rollConvention
    def set_rollConvention(self, rollConvention): self.rollConvention = rollConvention
    def validate_RollConventionEnum(self, value):
        # Validate type RollConventionEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['EOM', 'FRN', 'IMM', 'IMMCAD', 'IMMAUD', 'IMMNZD', 'SFE', 'NONE', 'TBILL', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '30', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT', 'SUN']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RollConventionEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on RollConventionEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.rollConvention is not None or
            super(CalculationPeriodFrequency, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CalculationPeriodFrequency', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CalculationPeriodFrequency')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CalculationPeriodFrequency', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CalculationPeriodFrequency'):
        super(CalculationPeriodFrequency, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CalculationPeriodFrequency')
    def exportChildren(self, outfile, level, namespace_='', name_='CalculationPeriodFrequency', fromsubclass_=False, pretty_print=True):
        super(CalculationPeriodFrequency, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.rollConvention is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srollConvention>%s</%srollConvention>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.rollConvention), input_name='rollConvention')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CalculationPeriodFrequency, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'rollConvention':
            rollConvention_ = child_.text
            rollConvention_ = re_.sub(String_cleanup_pat_, " ", rollConvention_).strip()
            rollConvention_ = self.gds_validate_string(rollConvention_, node, 'rollConvention')
            self.rollConvention = rollConvention_
            # validate type RollConventionEnum
            self.validate_RollConventionEnum(self.rollConvention)
        super(CalculationPeriodFrequency, self).buildChildren(child_, node, nodeName_, True)
# end class CalculationPeriodFrequency


class BusinessUnitReference(Reference):
    """Reference to an organizational unit."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(BusinessUnitReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BusinessUnitReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BusinessUnitReference.subclass:
            return BusinessUnitReference.subclass(*args_, **kwargs_)
        else:
            return BusinessUnitReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(BusinessUnitReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BusinessUnitReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BusinessUnitReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BusinessUnitReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BusinessUnitReference'):
        super(BusinessUnitReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BusinessUnitReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BusinessUnitReference', fromsubclass_=False, pretty_print=True):
        super(BusinessUnitReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(BusinessUnitReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(BusinessUnitReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BusinessUnitReference


class BusinessDayAdjustmentsReference(Reference):
    """Reference to a business day adjustments structure."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(BusinessDayAdjustmentsReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BusinessDayAdjustmentsReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BusinessDayAdjustmentsReference.subclass:
            return BusinessDayAdjustmentsReference.subclass(*args_, **kwargs_)
        else:
            return BusinessDayAdjustmentsReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(BusinessDayAdjustmentsReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BusinessDayAdjustmentsReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BusinessDayAdjustmentsReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BusinessDayAdjustmentsReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BusinessDayAdjustmentsReference'):
        super(BusinessDayAdjustmentsReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BusinessDayAdjustmentsReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BusinessDayAdjustmentsReference', fromsubclass_=False, pretty_print=True):
        super(BusinessDayAdjustmentsReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(BusinessDayAdjustmentsReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(BusinessDayAdjustmentsReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BusinessDayAdjustmentsReference


class BusinessDateRange(DateRange):
    """A type defining a range of contiguous business days by defining an
    unadjusted first date, an unadjusted last date and a business
    day convention and business centers for adjusting the first and
    last dates if they would otherwise fall on a non business day in
    the specified business centers. The days between the first and
    last date must also be good business days in the specified
    centers to be counted in the range."""
    member_data_items_ = {
        'businessDayConvention': MemberSpec_('businessDayConvention', ['BusinessDayConventionEnum', 'Token', 'xsd:token'], 0),
        'businessCentersReference': MemberSpec_('businessCentersReference', 'BusinessCentersReference', 0),
        'businessCenters': MemberSpec_('businessCenters', 'BusinessCenters', 0),
    }
    subclass = None
    superclass = DateRange
    def __init__(self, unadjustedFirstDate=None, unadjustedLastDate=None, businessDayConvention=None, businessCentersReference=None, businessCenters=None):
        self.original_tagname_ = None
        super(BusinessDateRange, self).__init__(unadjustedFirstDate, unadjustedLastDate, )
        self.businessDayConvention = businessDayConvention
        self.validate_BusinessDayConventionEnum(self.businessDayConvention)
        self.businessCentersReference = businessCentersReference
        self.businessCenters = businessCenters
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BusinessDateRange)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BusinessDateRange.subclass:
            return BusinessDateRange.subclass(*args_, **kwargs_)
        else:
            return BusinessDateRange(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_businessDayConvention(self): return self.businessDayConvention
    def set_businessDayConvention(self, businessDayConvention): self.businessDayConvention = businessDayConvention
    def get_businessCentersReference(self): return self.businessCentersReference
    def set_businessCentersReference(self, businessCentersReference): self.businessCentersReference = businessCentersReference
    def get_businessCenters(self): return self.businessCenters
    def set_businessCenters(self, businessCenters): self.businessCenters = businessCenters
    def validate_BusinessDayConventionEnum(self, value):
        # Validate type BusinessDayConventionEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FOLLOWING', 'FRN', 'MODFOLLOWING', 'PRECEDING', 'MODPRECEDING', 'NEAREST', 'NONE', 'NotApplicable']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on BusinessDayConventionEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on BusinessDayConventionEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.businessDayConvention is not None or
            self.businessCentersReference is not None or
            self.businessCenters is not None or
            super(BusinessDateRange, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BusinessDateRange', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BusinessDateRange')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BusinessDateRange', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BusinessDateRange'):
        super(BusinessDateRange, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BusinessDateRange')
    def exportChildren(self, outfile, level, namespace_='', name_='BusinessDateRange', fromsubclass_=False, pretty_print=True):
        super(BusinessDateRange, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.businessDayConvention is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbusinessDayConvention>%s</%sbusinessDayConvention>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.businessDayConvention), input_name='businessDayConvention')), namespace_, eol_))
        if self.businessCentersReference is not None:
            self.businessCentersReference.export(outfile, level, namespace_, name_='businessCentersReference', pretty_print=pretty_print)
        if self.businessCenters is not None:
            self.businessCenters.export(outfile, level, namespace_, name_='businessCenters', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(BusinessDateRange, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'businessDayConvention':
            businessDayConvention_ = child_.text
            businessDayConvention_ = re_.sub(String_cleanup_pat_, " ", businessDayConvention_).strip()
            businessDayConvention_ = self.gds_validate_string(businessDayConvention_, node, 'businessDayConvention')
            self.businessDayConvention = businessDayConvention_
            # validate type BusinessDayConventionEnum
            self.validate_BusinessDayConventionEnum(self.businessDayConvention)
        elif nodeName_ == 'businessCentersReference':
            obj_ = BusinessCentersReference.factory()
            obj_.build(child_)
            self.businessCentersReference = obj_
            obj_.original_tagname_ = 'businessCentersReference'
        elif nodeName_ == 'businessCenters':
            obj_ = BusinessCenters.factory()
            obj_.build(child_)
            self.businessCenters = obj_
            obj_.original_tagname_ = 'businessCenters'
        super(BusinessDateRange, self).buildChildren(child_, node, nodeName_, True)
# end class BusinessDateRange


class BusinessCentersReference(Reference):
    """A pointer style reference to a set of business day calendar defined
    elsewhere in the document."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(BusinessCentersReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BusinessCentersReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BusinessCentersReference.subclass:
            return BusinessCentersReference.subclass(*args_, **kwargs_)
        else:
            return BusinessCentersReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(BusinessCentersReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BusinessCentersReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BusinessCentersReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BusinessCentersReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BusinessCentersReference'):
        super(BusinessCentersReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BusinessCentersReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BusinessCentersReference', fromsubclass_=False, pretty_print=True):
        super(BusinessCentersReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(BusinessCentersReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(BusinessCentersReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BusinessCentersReference


class BermudaExercise(Exercise):
    """A type defining the Bermuda option exercise dates and the expiration
    date together with any rules govenerning the notional amount of
    the underlying which can be exercised on any given exercise date
    and any associated exercise fee."""
    member_data_items_ = {
        'bermudaExerciseDates': MemberSpec_('bermudaExerciseDates', 'AdjustableOrRelativeDates', 0),
        'relevantUnderlyingDate': MemberSpec_('relevantUnderlyingDate', 'AdjustableOrRelativeDates', 0),
        'earliestExerciseTime': MemberSpec_('earliestExerciseTime', 'BusinessCenterTime', 0),
        'latestExerciseTime': MemberSpec_('latestExerciseTime', 'BusinessCenterTime', 0),
        'expirationTime': MemberSpec_('expirationTime', 'BusinessCenterTime', 0),
        'multipleExercise': MemberSpec_('multipleExercise', 'MultipleExercise', 0),
        'exerciseFeeSchedule': MemberSpec_('exerciseFeeSchedule', 'ExerciseFeeSchedule', 0),
    }
    subclass = None
    superclass = Exercise
    def __init__(self, id=None, bermudaExerciseDates=None, relevantUnderlyingDate=None, earliestExerciseTime=None, latestExerciseTime=None, expirationTime=None, multipleExercise=None, exerciseFeeSchedule=None):
        self.original_tagname_ = None
        super(BermudaExercise, self).__init__(id, )
        self.bermudaExerciseDates = bermudaExerciseDates
        self.relevantUnderlyingDate = relevantUnderlyingDate
        self.earliestExerciseTime = earliestExerciseTime
        self.latestExerciseTime = latestExerciseTime
        self.expirationTime = expirationTime
        self.multipleExercise = multipleExercise
        self.exerciseFeeSchedule = exerciseFeeSchedule
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BermudaExercise)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BermudaExercise.subclass:
            return BermudaExercise.subclass(*args_, **kwargs_)
        else:
            return BermudaExercise(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_bermudaExerciseDates(self): return self.bermudaExerciseDates
    def set_bermudaExerciseDates(self, bermudaExerciseDates): self.bermudaExerciseDates = bermudaExerciseDates
    def get_relevantUnderlyingDate(self): return self.relevantUnderlyingDate
    def set_relevantUnderlyingDate(self, relevantUnderlyingDate): self.relevantUnderlyingDate = relevantUnderlyingDate
    def get_earliestExerciseTime(self): return self.earliestExerciseTime
    def set_earliestExerciseTime(self, earliestExerciseTime): self.earliestExerciseTime = earliestExerciseTime
    def get_latestExerciseTime(self): return self.latestExerciseTime
    def set_latestExerciseTime(self, latestExerciseTime): self.latestExerciseTime = latestExerciseTime
    def get_expirationTime(self): return self.expirationTime
    def set_expirationTime(self, expirationTime): self.expirationTime = expirationTime
    def get_multipleExercise(self): return self.multipleExercise
    def set_multipleExercise(self, multipleExercise): self.multipleExercise = multipleExercise
    def get_exerciseFeeSchedule(self): return self.exerciseFeeSchedule
    def set_exerciseFeeSchedule(self, exerciseFeeSchedule): self.exerciseFeeSchedule = exerciseFeeSchedule
    def hasContent_(self):
        if (
            self.bermudaExerciseDates is not None or
            self.relevantUnderlyingDate is not None or
            self.earliestExerciseTime is not None or
            self.latestExerciseTime is not None or
            self.expirationTime is not None or
            self.multipleExercise is not None or
            self.exerciseFeeSchedule is not None or
            super(BermudaExercise, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BermudaExercise', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BermudaExercise')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BermudaExercise', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BermudaExercise'):
        super(BermudaExercise, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BermudaExercise')
    def exportChildren(self, outfile, level, namespace_='', name_='BermudaExercise', fromsubclass_=False, pretty_print=True):
        super(BermudaExercise, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.bermudaExerciseDates is not None:
            self.bermudaExerciseDates.export(outfile, level, namespace_, name_='bermudaExerciseDates', pretty_print=pretty_print)
        if self.relevantUnderlyingDate is not None:
            self.relevantUnderlyingDate.export(outfile, level, namespace_, name_='relevantUnderlyingDate', pretty_print=pretty_print)
        if self.earliestExerciseTime is not None:
            self.earliestExerciseTime.export(outfile, level, namespace_, name_='earliestExerciseTime', pretty_print=pretty_print)
        if self.latestExerciseTime is not None:
            self.latestExerciseTime.export(outfile, level, namespace_, name_='latestExerciseTime', pretty_print=pretty_print)
        if self.expirationTime is not None:
            self.expirationTime.export(outfile, level, namespace_, name_='expirationTime', pretty_print=pretty_print)
        if self.multipleExercise is not None:
            self.multipleExercise.export(outfile, level, namespace_, name_='multipleExercise', pretty_print=pretty_print)
        if self.exerciseFeeSchedule is not None:
            self.exerciseFeeSchedule.export(outfile, level, namespace_, name_='exerciseFeeSchedule', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(BermudaExercise, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'bermudaExerciseDates':
            obj_ = AdjustableOrRelativeDates.factory()
            obj_.build(child_)
            self.bermudaExerciseDates = obj_
            obj_.original_tagname_ = 'bermudaExerciseDates'
        elif nodeName_ == 'relevantUnderlyingDate':
            obj_ = AdjustableOrRelativeDates.factory()
            obj_.build(child_)
            self.relevantUnderlyingDate = obj_
            obj_.original_tagname_ = 'relevantUnderlyingDate'
        elif nodeName_ == 'earliestExerciseTime':
            obj_ = BusinessCenterTime.factory()
            obj_.build(child_)
            self.earliestExerciseTime = obj_
            obj_.original_tagname_ = 'earliestExerciseTime'
        elif nodeName_ == 'latestExerciseTime':
            obj_ = BusinessCenterTime.factory()
            obj_.build(child_)
            self.latestExerciseTime = obj_
            obj_.original_tagname_ = 'latestExerciseTime'
        elif nodeName_ == 'expirationTime':
            obj_ = BusinessCenterTime.factory()
            obj_.build(child_)
            self.expirationTime = obj_
            obj_.original_tagname_ = 'expirationTime'
        elif nodeName_ == 'multipleExercise':
            obj_ = MultipleExercise.factory()
            obj_.build(child_)
            self.multipleExercise = obj_
            obj_.original_tagname_ = 'multipleExercise'
        elif nodeName_ == 'exerciseFeeSchedule':
            obj_ = ExerciseFeeSchedule.factory()
            obj_.build(child_)
            self.exerciseFeeSchedule = obj_
            obj_.original_tagname_ = 'exerciseFeeSchedule'
        super(BermudaExercise, self).buildChildren(child_, node, nodeName_, True)
# end class BermudaExercise


class AmountSchedule(Schedule):
    """A type defining a currency amount or a currency amount schedule."""
    member_data_items_ = {
        'currency': MemberSpec_('currency', 'Currency', 0),
    }
    subclass = None
    superclass = Schedule
    def __init__(self, id=None, initialValue=None, step=None, currency=None):
        self.original_tagname_ = None
        super(AmountSchedule, self).__init__(id, initialValue, step, )
        self.currency = currency
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AmountSchedule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AmountSchedule.subclass:
            return AmountSchedule.subclass(*args_, **kwargs_)
        else:
            return AmountSchedule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def hasContent_(self):
        if (
            self.currency is not None or
            super(AmountSchedule, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AmountSchedule', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AmountSchedule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AmountSchedule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AmountSchedule'):
        super(AmountSchedule, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AmountSchedule')
    def exportChildren(self, outfile, level, namespace_='', name_='AmountSchedule', fromsubclass_=False, pretty_print=True):
        super(AmountSchedule, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.currency is not None:
            self.currency.export(outfile, level, namespace_, name_='currency', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AmountSchedule, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'currency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        super(AmountSchedule, self).buildChildren(child_, node, nodeName_, True)
# end class AmountSchedule


class AmountReference(Reference):
    """Specifies a reference to a monetary amount."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(AmountReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AmountReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AmountReference.subclass:
            return AmountReference.subclass(*args_, **kwargs_)
        else:
            return AmountReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(AmountReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AmountReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AmountReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AmountReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AmountReference'):
        super(AmountReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AmountReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AmountReference', fromsubclass_=False, pretty_print=True):
        super(AmountReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(AmountReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AmountReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AmountReference


class AmericanExercise(Exercise):
    """A type defining the exercise period for an American style option
    together with any rules governing the notional amount of the
    underlying which can be exercised on any given exercise date and
    any associated exercise fees."""
    member_data_items_ = {
        'commencementDate': MemberSpec_('commencementDate', 'AdjustableOrRelativeDate', 0),
        'expirationDate': MemberSpec_('expirationDate', 'AdjustableOrRelativeDate', 0),
        'relevantUnderlyingDate': MemberSpec_('relevantUnderlyingDate', 'AdjustableOrRelativeDates', 0),
        'earliestExerciseTime': MemberSpec_('earliestExerciseTime', 'BusinessCenterTime', 0),
        'latestExerciseTime': MemberSpec_('latestExerciseTime', 'BusinessCenterTime', 0),
        'expirationTime': MemberSpec_('expirationTime', 'BusinessCenterTime', 0),
        'multipleExercise': MemberSpec_('multipleExercise', 'MultipleExercise', 0),
        'exerciseFeeSchedule': MemberSpec_('exerciseFeeSchedule', 'ExerciseFeeSchedule', 0),
    }
    subclass = None
    superclass = Exercise
    def __init__(self, id=None, commencementDate=None, expirationDate=None, relevantUnderlyingDate=None, earliestExerciseTime=None, latestExerciseTime=None, expirationTime=None, multipleExercise=None, exerciseFeeSchedule=None):
        self.original_tagname_ = None
        super(AmericanExercise, self).__init__(id, )
        self.commencementDate = commencementDate
        self.expirationDate = expirationDate
        self.relevantUnderlyingDate = relevantUnderlyingDate
        self.earliestExerciseTime = earliestExerciseTime
        self.latestExerciseTime = latestExerciseTime
        self.expirationTime = expirationTime
        self.multipleExercise = multipleExercise
        self.exerciseFeeSchedule = exerciseFeeSchedule
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AmericanExercise)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AmericanExercise.subclass:
            return AmericanExercise.subclass(*args_, **kwargs_)
        else:
            return AmericanExercise(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commencementDate(self): return self.commencementDate
    def set_commencementDate(self, commencementDate): self.commencementDate = commencementDate
    def get_expirationDate(self): return self.expirationDate
    def set_expirationDate(self, expirationDate): self.expirationDate = expirationDate
    def get_relevantUnderlyingDate(self): return self.relevantUnderlyingDate
    def set_relevantUnderlyingDate(self, relevantUnderlyingDate): self.relevantUnderlyingDate = relevantUnderlyingDate
    def get_earliestExerciseTime(self): return self.earliestExerciseTime
    def set_earliestExerciseTime(self, earliestExerciseTime): self.earliestExerciseTime = earliestExerciseTime
    def get_latestExerciseTime(self): return self.latestExerciseTime
    def set_latestExerciseTime(self, latestExerciseTime): self.latestExerciseTime = latestExerciseTime
    def get_expirationTime(self): return self.expirationTime
    def set_expirationTime(self, expirationTime): self.expirationTime = expirationTime
    def get_multipleExercise(self): return self.multipleExercise
    def set_multipleExercise(self, multipleExercise): self.multipleExercise = multipleExercise
    def get_exerciseFeeSchedule(self): return self.exerciseFeeSchedule
    def set_exerciseFeeSchedule(self, exerciseFeeSchedule): self.exerciseFeeSchedule = exerciseFeeSchedule
    def hasContent_(self):
        if (
            self.commencementDate is not None or
            self.expirationDate is not None or
            self.relevantUnderlyingDate is not None or
            self.earliestExerciseTime is not None or
            self.latestExerciseTime is not None or
            self.expirationTime is not None or
            self.multipleExercise is not None or
            self.exerciseFeeSchedule is not None or
            super(AmericanExercise, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AmericanExercise', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AmericanExercise')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AmericanExercise', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AmericanExercise'):
        super(AmericanExercise, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AmericanExercise')
    def exportChildren(self, outfile, level, namespace_='', name_='AmericanExercise', fromsubclass_=False, pretty_print=True):
        super(AmericanExercise, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.commencementDate is not None:
            self.commencementDate.export(outfile, level, namespace_, name_='commencementDate', pretty_print=pretty_print)
        if self.expirationDate is not None:
            self.expirationDate.export(outfile, level, namespace_, name_='expirationDate', pretty_print=pretty_print)
        if self.relevantUnderlyingDate is not None:
            self.relevantUnderlyingDate.export(outfile, level, namespace_, name_='relevantUnderlyingDate', pretty_print=pretty_print)
        if self.earliestExerciseTime is not None:
            self.earliestExerciseTime.export(outfile, level, namespace_, name_='earliestExerciseTime', pretty_print=pretty_print)
        if self.latestExerciseTime is not None:
            self.latestExerciseTime.export(outfile, level, namespace_, name_='latestExerciseTime', pretty_print=pretty_print)
        if self.expirationTime is not None:
            self.expirationTime.export(outfile, level, namespace_, name_='expirationTime', pretty_print=pretty_print)
        if self.multipleExercise is not None:
            self.multipleExercise.export(outfile, level, namespace_, name_='multipleExercise', pretty_print=pretty_print)
        if self.exerciseFeeSchedule is not None:
            self.exerciseFeeSchedule.export(outfile, level, namespace_, name_='exerciseFeeSchedule', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AmericanExercise, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'commencementDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.commencementDate = obj_
            obj_.original_tagname_ = 'commencementDate'
        elif nodeName_ == 'expirationDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.expirationDate = obj_
            obj_.original_tagname_ = 'expirationDate'
        elif nodeName_ == 'relevantUnderlyingDate':
            obj_ = AdjustableOrRelativeDates.factory()
            obj_.build(child_)
            self.relevantUnderlyingDate = obj_
            obj_.original_tagname_ = 'relevantUnderlyingDate'
        elif nodeName_ == 'earliestExerciseTime':
            obj_ = BusinessCenterTime.factory()
            obj_.build(child_)
            self.earliestExerciseTime = obj_
            obj_.original_tagname_ = 'earliestExerciseTime'
        elif nodeName_ == 'latestExerciseTime':
            obj_ = BusinessCenterTime.factory()
            obj_.build(child_)
            self.latestExerciseTime = obj_
            obj_.original_tagname_ = 'latestExerciseTime'
        elif nodeName_ == 'expirationTime':
            obj_ = BusinessCenterTime.factory()
            obj_.build(child_)
            self.expirationTime = obj_
            obj_.original_tagname_ = 'expirationTime'
        elif nodeName_ == 'multipleExercise':
            obj_ = MultipleExercise.factory()
            obj_.build(child_)
            self.multipleExercise = obj_
            obj_.original_tagname_ = 'multipleExercise'
        elif nodeName_ == 'exerciseFeeSchedule':
            obj_ = ExerciseFeeSchedule.factory()
            obj_.build(child_)
            self.exerciseFeeSchedule = obj_
            obj_.original_tagname_ = 'exerciseFeeSchedule'
        super(AmericanExercise, self).buildChildren(child_, node, nodeName_, True)
# end class AmericanExercise


class AccountReference(Reference):
    """Reference to an account."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(AccountReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AccountReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AccountReference.subclass:
            return AccountReference.subclass(*args_, **kwargs_)
        else:
            return AccountReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(AccountReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AccountReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AccountReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AccountReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AccountReference'):
        super(AccountReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AccountReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AccountReference', fromsubclass_=False, pretty_print=True):
        super(AccountReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(AccountReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AccountReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AccountReference


class SimpleIRSwap(UnderlyingAsset):
    member_data_items_ = {
        'term': MemberSpec_('term', 'Period', 0),
        'paymentFrequency': MemberSpec_('paymentFrequency', 'Period', 0),
        'dayCountFraction': MemberSpec_('dayCountFraction', 'DayCountFraction', 0),
    }
    subclass = None
    superclass = UnderlyingAsset
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, term=None, paymentFrequency=None, dayCountFraction=None):
        self.original_tagname_ = None
        super(SimpleIRSwap, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, )
        self.term = term
        self.paymentFrequency = paymentFrequency
        self.dayCountFraction = dayCountFraction
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SimpleIRSwap)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SimpleIRSwap.subclass:
            return SimpleIRSwap.subclass(*args_, **kwargs_)
        else:
            return SimpleIRSwap(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_term(self): return self.term
    def set_term(self, term): self.term = term
    def get_paymentFrequency(self): return self.paymentFrequency
    def set_paymentFrequency(self, paymentFrequency): self.paymentFrequency = paymentFrequency
    def get_dayCountFraction(self): return self.dayCountFraction
    def set_dayCountFraction(self, dayCountFraction): self.dayCountFraction = dayCountFraction
    def hasContent_(self):
        if (
            self.term is not None or
            self.paymentFrequency is not None or
            self.dayCountFraction is not None or
            super(SimpleIRSwap, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SimpleIRSwap', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SimpleIRSwap')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SimpleIRSwap', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SimpleIRSwap'):
        super(SimpleIRSwap, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SimpleIRSwap')
    def exportChildren(self, outfile, level, namespace_='', name_='SimpleIRSwap', fromsubclass_=False, pretty_print=True):
        super(SimpleIRSwap, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.term is not None:
            self.term.export(outfile, level, namespace_, name_='term', pretty_print=pretty_print)
        if self.paymentFrequency is not None:
            self.paymentFrequency.export(outfile, level, namespace_, name_='paymentFrequency', pretty_print=pretty_print)
        if self.dayCountFraction is not None:
            self.dayCountFraction.export(outfile, level, namespace_, name_='dayCountFraction', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SimpleIRSwap, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'term':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.term = obj_
            obj_.original_tagname_ = 'term'
        elif nodeName_ == 'paymentFrequency':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.paymentFrequency = obj_
            obj_.original_tagname_ = 'paymentFrequency'
        elif nodeName_ == 'dayCountFraction':
            obj_ = DayCountFraction.factory()
            obj_.build(child_)
            self.dayCountFraction = obj_
            obj_.original_tagname_ = 'dayCountFraction'
        super(SimpleIRSwap, self).buildChildren(child_, node, nodeName_, True)
# end class SimpleIRSwap


class SimpleFra(UnderlyingAsset):
    member_data_items_ = {
        'startTerm': MemberSpec_('startTerm', 'Period', 0),
        'endTerm': MemberSpec_('endTerm', 'Period', 0),
        'dayCountFraction': MemberSpec_('dayCountFraction', 'DayCountFraction', 0),
    }
    subclass = None
    superclass = UnderlyingAsset
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, startTerm=None, endTerm=None, dayCountFraction=None):
        self.original_tagname_ = None
        super(SimpleFra, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, )
        self.startTerm = startTerm
        self.endTerm = endTerm
        self.dayCountFraction = dayCountFraction
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SimpleFra)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SimpleFra.subclass:
            return SimpleFra.subclass(*args_, **kwargs_)
        else:
            return SimpleFra(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_startTerm(self): return self.startTerm
    def set_startTerm(self, startTerm): self.startTerm = startTerm
    def get_endTerm(self): return self.endTerm
    def set_endTerm(self, endTerm): self.endTerm = endTerm
    def get_dayCountFraction(self): return self.dayCountFraction
    def set_dayCountFraction(self, dayCountFraction): self.dayCountFraction = dayCountFraction
    def hasContent_(self):
        if (
            self.startTerm is not None or
            self.endTerm is not None or
            self.dayCountFraction is not None or
            super(SimpleFra, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SimpleFra', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SimpleFra')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SimpleFra', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SimpleFra'):
        super(SimpleFra, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SimpleFra')
    def exportChildren(self, outfile, level, namespace_='', name_='SimpleFra', fromsubclass_=False, pretty_print=True):
        super(SimpleFra, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.startTerm is not None:
            self.startTerm.export(outfile, level, namespace_, name_='startTerm', pretty_print=pretty_print)
        if self.endTerm is not None:
            self.endTerm.export(outfile, level, namespace_, name_='endTerm', pretty_print=pretty_print)
        if self.dayCountFraction is not None:
            self.dayCountFraction.export(outfile, level, namespace_, name_='dayCountFraction', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SimpleFra, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'startTerm':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.startTerm = obj_
            obj_.original_tagname_ = 'startTerm'
        elif nodeName_ == 'endTerm':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.endTerm = obj_
            obj_.original_tagname_ = 'endTerm'
        elif nodeName_ == 'dayCountFraction':
            obj_ = DayCountFraction.factory()
            obj_.build(child_)
            self.dayCountFraction = obj_
            obj_.original_tagname_ = 'dayCountFraction'
        super(SimpleFra, self).buildChildren(child_, node, nodeName_, True)
# end class SimpleFra


class SimpleCreditDefaultSwap(UnderlyingAsset):
    member_data_items_ = {
        'referenceEntity': MemberSpec_('referenceEntity', 'LegalEntity', 0),
        'creditEntityReference': MemberSpec_('creditEntityReference', 'LegalEntityReference', 0),
        'term': MemberSpec_('term', 'Period', 0),
        'paymentFrequency': MemberSpec_('paymentFrequency', 'Period', 0),
    }
    subclass = None
    superclass = UnderlyingAsset
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, referenceEntity=None, creditEntityReference=None, term=None, paymentFrequency=None):
        self.original_tagname_ = None
        super(SimpleCreditDefaultSwap, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, )
        self.referenceEntity = referenceEntity
        self.creditEntityReference = creditEntityReference
        self.term = term
        self.paymentFrequency = paymentFrequency
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SimpleCreditDefaultSwap)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SimpleCreditDefaultSwap.subclass:
            return SimpleCreditDefaultSwap.subclass(*args_, **kwargs_)
        else:
            return SimpleCreditDefaultSwap(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_referenceEntity(self): return self.referenceEntity
    def set_referenceEntity(self, referenceEntity): self.referenceEntity = referenceEntity
    def get_creditEntityReference(self): return self.creditEntityReference
    def set_creditEntityReference(self, creditEntityReference): self.creditEntityReference = creditEntityReference
    def get_term(self): return self.term
    def set_term(self, term): self.term = term
    def get_paymentFrequency(self): return self.paymentFrequency
    def set_paymentFrequency(self, paymentFrequency): self.paymentFrequency = paymentFrequency
    def hasContent_(self):
        if (
            self.referenceEntity is not None or
            self.creditEntityReference is not None or
            self.term is not None or
            self.paymentFrequency is not None or
            super(SimpleCreditDefaultSwap, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SimpleCreditDefaultSwap', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SimpleCreditDefaultSwap')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SimpleCreditDefaultSwap', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SimpleCreditDefaultSwap'):
        super(SimpleCreditDefaultSwap, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SimpleCreditDefaultSwap')
    def exportChildren(self, outfile, level, namespace_='', name_='SimpleCreditDefaultSwap', fromsubclass_=False, pretty_print=True):
        super(SimpleCreditDefaultSwap, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.referenceEntity is not None:
            self.referenceEntity.export(outfile, level, namespace_, name_='referenceEntity', pretty_print=pretty_print)
        if self.creditEntityReference is not None:
            self.creditEntityReference.export(outfile, level, namespace_, name_='creditEntityReference', pretty_print=pretty_print)
        if self.term is not None:
            self.term.export(outfile, level, namespace_, name_='term', pretty_print=pretty_print)
        if self.paymentFrequency is not None:
            self.paymentFrequency.export(outfile, level, namespace_, name_='paymentFrequency', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SimpleCreditDefaultSwap, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'referenceEntity':
            obj_ = LegalEntity.factory()
            obj_.build(child_)
            self.referenceEntity = obj_
            obj_.original_tagname_ = 'referenceEntity'
        elif nodeName_ == 'creditEntityReference':
            obj_ = LegalEntityReference.factory()
            obj_.build(child_)
            self.creditEntityReference = obj_
            obj_.original_tagname_ = 'creditEntityReference'
        elif nodeName_ == 'term':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.term = obj_
            obj_.original_tagname_ = 'term'
        elif nodeName_ == 'paymentFrequency':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.paymentFrequency = obj_
            obj_.original_tagname_ = 'paymentFrequency'
        super(SimpleCreditDefaultSwap, self).buildChildren(child_, node, nodeName_, True)
# end class SimpleCreditDefaultSwap


class RateIndex(UnderlyingAsset):
    member_data_items_ = {
        'floatingRateIndex': MemberSpec_('floatingRateIndex', 'FloatingRateIndex', 0),
        'term': MemberSpec_('term', 'Period', 0),
        'paymentFrequency': MemberSpec_('paymentFrequency', 'Period', 0),
        'dayCountFraction': MemberSpec_('dayCountFraction', 'DayCountFraction', 0),
    }
    subclass = None
    superclass = UnderlyingAsset
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, floatingRateIndex=None, term=None, paymentFrequency=None, dayCountFraction=None):
        self.original_tagname_ = None
        super(RateIndex, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, )
        self.floatingRateIndex = floatingRateIndex
        self.term = term
        self.paymentFrequency = paymentFrequency
        self.dayCountFraction = dayCountFraction
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RateIndex)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RateIndex.subclass:
            return RateIndex.subclass(*args_, **kwargs_)
        else:
            return RateIndex(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_floatingRateIndex(self): return self.floatingRateIndex
    def set_floatingRateIndex(self, floatingRateIndex): self.floatingRateIndex = floatingRateIndex
    def get_term(self): return self.term
    def set_term(self, term): self.term = term
    def get_paymentFrequency(self): return self.paymentFrequency
    def set_paymentFrequency(self, paymentFrequency): self.paymentFrequency = paymentFrequency
    def get_dayCountFraction(self): return self.dayCountFraction
    def set_dayCountFraction(self, dayCountFraction): self.dayCountFraction = dayCountFraction
    def hasContent_(self):
        if (
            self.floatingRateIndex is not None or
            self.term is not None or
            self.paymentFrequency is not None or
            self.dayCountFraction is not None or
            super(RateIndex, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RateIndex', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RateIndex')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RateIndex', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RateIndex'):
        super(RateIndex, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RateIndex')
    def exportChildren(self, outfile, level, namespace_='', name_='RateIndex', fromsubclass_=False, pretty_print=True):
        super(RateIndex, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.floatingRateIndex is not None:
            self.floatingRateIndex.export(outfile, level, namespace_, name_='floatingRateIndex', pretty_print=pretty_print)
        if self.term is not None:
            self.term.export(outfile, level, namespace_, name_='term', pretty_print=pretty_print)
        if self.paymentFrequency is not None:
            self.paymentFrequency.export(outfile, level, namespace_, name_='paymentFrequency', pretty_print=pretty_print)
        if self.dayCountFraction is not None:
            self.dayCountFraction.export(outfile, level, namespace_, name_='dayCountFraction', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RateIndex, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'floatingRateIndex':
            obj_ = FloatingRateIndex.factory()
            obj_.build(child_)
            self.floatingRateIndex = obj_
            obj_.original_tagname_ = 'floatingRateIndex'
        elif nodeName_ == 'term':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.term = obj_
            obj_.original_tagname_ = 'term'
        elif nodeName_ == 'paymentFrequency':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.paymentFrequency = obj_
            obj_.original_tagname_ = 'paymentFrequency'
        elif nodeName_ == 'dayCountFraction':
            obj_ = DayCountFraction.factory()
            obj_.build(child_)
            self.dayCountFraction = obj_
            obj_.original_tagname_ = 'dayCountFraction'
        super(RateIndex, self).buildChildren(child_, node, nodeName_, True)
# end class RateIndex


class PendingPayment(PaymentBase):
    """A structure representing a pending dividend or coupon payment."""
    member_data_items_ = {
        'paymentDate': MemberSpec_('paymentDate', 'xsd:date', 0),
        'amount': MemberSpec_('amount', 'Money', 0),
        'accruedInterest': MemberSpec_('accruedInterest', 'Money', 0),
    }
    subclass = None
    superclass = PaymentBase
    def __init__(self, id=None, paymentDate=None, amount=None, accruedInterest=None):
        self.original_tagname_ = None
        super(PendingPayment, self).__init__(id, )
        if isinstance(paymentDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(paymentDate, '%Y-%m-%d').date()
        else:
            initvalue_ = paymentDate
        self.paymentDate = initvalue_
        self.amount = amount
        self.accruedInterest = accruedInterest
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PendingPayment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PendingPayment.subclass:
            return PendingPayment.subclass(*args_, **kwargs_)
        else:
            return PendingPayment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_paymentDate(self): return self.paymentDate
    def set_paymentDate(self, paymentDate): self.paymentDate = paymentDate
    def get_amount(self): return self.amount
    def set_amount(self, amount): self.amount = amount
    def get_accruedInterest(self): return self.accruedInterest
    def set_accruedInterest(self, accruedInterest): self.accruedInterest = accruedInterest
    def hasContent_(self):
        if (
            self.paymentDate is not None or
            self.amount is not None or
            self.accruedInterest is not None or
            super(PendingPayment, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PendingPayment', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PendingPayment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PendingPayment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PendingPayment'):
        super(PendingPayment, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PendingPayment')
    def exportChildren(self, outfile, level, namespace_='', name_='PendingPayment', fromsubclass_=False, pretty_print=True):
        super(PendingPayment, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.paymentDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spaymentDate>%s</%spaymentDate>%s' % (namespace_, self.gds_format_date(self.paymentDate, input_name='paymentDate'), namespace_, eol_))
        if self.amount is not None:
            self.amount.export(outfile, level, namespace_, name_='amount', pretty_print=pretty_print)
        if self.accruedInterest is not None:
            self.accruedInterest.export(outfile, level, namespace_, name_='accruedInterest', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PendingPayment, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'paymentDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.paymentDate = dval_
        elif nodeName_ == 'amount':
            obj_ = Money.factory()
            obj_.build(child_)
            self.amount = obj_
            obj_.original_tagname_ = 'amount'
        elif nodeName_ == 'accruedInterest':
            obj_ = Money.factory()
            obj_.build(child_)
            self.accruedInterest = obj_
            obj_.original_tagname_ = 'accruedInterest'
        super(PendingPayment, self).buildChildren(child_, node, nodeName_, True)
# end class PendingPayment


class MutualFund(UnderlyingAsset):
    member_data_items_ = {
        'openEndedFund': MemberSpec_('openEndedFund', 'xsd:boolean', 0),
        'fundManager': MemberSpec_('fundManager', ['String', 'xsd:string'], 0),
    }
    subclass = None
    superclass = UnderlyingAsset
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, openEndedFund=None, fundManager=None):
        self.original_tagname_ = None
        super(MutualFund, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, )
        self.openEndedFund = openEndedFund
        self.fundManager = fundManager
        self.validate_String(self.fundManager)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MutualFund)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MutualFund.subclass:
            return MutualFund.subclass(*args_, **kwargs_)
        else:
            return MutualFund(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_openEndedFund(self): return self.openEndedFund
    def set_openEndedFund(self, openEndedFund): self.openEndedFund = openEndedFund
    def get_fundManager(self): return self.fundManager
    def set_fundManager(self, fundManager): self.fundManager = fundManager
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.openEndedFund is not None or
            self.fundManager is not None or
            super(MutualFund, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MutualFund', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MutualFund')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MutualFund', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MutualFund'):
        super(MutualFund, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MutualFund')
    def exportChildren(self, outfile, level, namespace_='', name_='MutualFund', fromsubclass_=False, pretty_print=True):
        super(MutualFund, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.openEndedFund is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sopenEndedFund>%s</%sopenEndedFund>%s' % (namespace_, self.gds_format_boolean(self.openEndedFund, input_name='openEndedFund'), namespace_, eol_))
        if self.fundManager is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfundManager>%s</%sfundManager>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.fundManager), input_name='fundManager')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MutualFund, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'openEndedFund':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'openEndedFund')
            self.openEndedFund = ival_
        elif nodeName_ == 'fundManager':
            fundManager_ = child_.text
            fundManager_ = self.gds_validate_string(fundManager_, node, 'fundManager')
            self.fundManager = fundManager_
            # validate type String
            self.validate_String(self.fundManager)
        super(MutualFund, self).buildChildren(child_, node, nodeName_, True)
# end class MutualFund


class Mortgage(UnderlyingAsset):
    """A type describing a mortgage asset.Applicable to the case of default
    swaps on MBS terms. For specifying the insurer name, when
    applicable (when the element is not present, it signifies that
    the insurer is Not Applicable)Specifies the issuer name of a
    fixed income security or convertible bond. This name can either
    be explicitly stated, or specified as an href into another
    element of the document, such as the obligor."""
    member_data_items_ = {
        'insurer': MemberSpec_('insurer', 'LegalEntity', 0),
        'insurerReference': MemberSpec_('insurerReference', 'LegalEntityReference', 0),
        'issuerName': MemberSpec_('issuerName', ['String', 'xsd:string'], 0),
        'issuerPartyReference': MemberSpec_('issuerPartyReference', 'PartyReference', 0),
        'seniority': MemberSpec_('seniority', 'CreditSeniority', 0),
        'couponType': MemberSpec_('couponType', 'CouponType', 0),
        'couponRate': MemberSpec_('couponRate', 'xsd:decimal', 0),
        'maturity': MemberSpec_('maturity', 'xsd:date', 0),
        'paymentFrequency': MemberSpec_('paymentFrequency', 'Period', 0),
        'dayCountFraction': MemberSpec_('dayCountFraction', 'DayCountFraction', 0),
        'originalPrincipalAmount': MemberSpec_('originalPrincipalAmount', 'xsd:decimal', 0),
        'pool': MemberSpec_('pool', 'AssetPool', 0),
        'sector': MemberSpec_('sector', 'MortgageSector', 0),
        'tranche': MemberSpec_('tranche', ['Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = UnderlyingAsset
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, insurer=None, insurerReference=None, issuerName=None, issuerPartyReference=None, seniority=None, couponType=None, couponRate=None, maturity=None, paymentFrequency=None, dayCountFraction=None, originalPrincipalAmount=None, pool=None, sector=None, tranche=None):
        self.original_tagname_ = None
        super(Mortgage, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, )
        self.insurer = insurer
        self.insurerReference = insurerReference
        self.issuerName = issuerName
        self.validate_String(self.issuerName)
        self.issuerPartyReference = issuerPartyReference
        self.seniority = seniority
        self.couponType = couponType
        self.couponRate = couponRate
        if isinstance(maturity, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(maturity, '%Y-%m-%d').date()
        else:
            initvalue_ = maturity
        self.maturity = initvalue_
        self.paymentFrequency = paymentFrequency
        self.dayCountFraction = dayCountFraction
        self.originalPrincipalAmount = originalPrincipalAmount
        self.pool = pool
        self.sector = sector
        self.tranche = tranche
        self.validate_Token(self.tranche)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Mortgage)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Mortgage.subclass:
            return Mortgage.subclass(*args_, **kwargs_)
        else:
            return Mortgage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_insurer(self): return self.insurer
    def set_insurer(self, insurer): self.insurer = insurer
    def get_insurerReference(self): return self.insurerReference
    def set_insurerReference(self, insurerReference): self.insurerReference = insurerReference
    def get_issuerName(self): return self.issuerName
    def set_issuerName(self, issuerName): self.issuerName = issuerName
    def get_issuerPartyReference(self): return self.issuerPartyReference
    def set_issuerPartyReference(self, issuerPartyReference): self.issuerPartyReference = issuerPartyReference
    def get_seniority(self): return self.seniority
    def set_seniority(self, seniority): self.seniority = seniority
    def get_couponType(self): return self.couponType
    def set_couponType(self, couponType): self.couponType = couponType
    def get_couponRate(self): return self.couponRate
    def set_couponRate(self, couponRate): self.couponRate = couponRate
    def get_maturity(self): return self.maturity
    def set_maturity(self, maturity): self.maturity = maturity
    def get_paymentFrequency(self): return self.paymentFrequency
    def set_paymentFrequency(self, paymentFrequency): self.paymentFrequency = paymentFrequency
    def get_dayCountFraction(self): return self.dayCountFraction
    def set_dayCountFraction(self, dayCountFraction): self.dayCountFraction = dayCountFraction
    def get_originalPrincipalAmount(self): return self.originalPrincipalAmount
    def set_originalPrincipalAmount(self, originalPrincipalAmount): self.originalPrincipalAmount = originalPrincipalAmount
    def get_pool(self): return self.pool
    def set_pool(self, pool): self.pool = pool
    def get_sector(self): return self.sector
    def set_sector(self, sector): self.sector = sector
    def get_tranche(self): return self.tranche
    def set_tranche(self, tranche): self.tranche = tranche
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def validate_Token(self, value):
        # Validate type Token, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Token' % {"value" : value} )
    def hasContent_(self):
        if (
            self.insurer is not None or
            self.insurerReference is not None or
            self.issuerName is not None or
            self.issuerPartyReference is not None or
            self.seniority is not None or
            self.couponType is not None or
            self.couponRate is not None or
            self.maturity is not None or
            self.paymentFrequency is not None or
            self.dayCountFraction is not None or
            self.originalPrincipalAmount is not None or
            self.pool is not None or
            self.sector is not None or
            self.tranche is not None or
            super(Mortgage, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Mortgage', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Mortgage')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Mortgage', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Mortgage'):
        super(Mortgage, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Mortgage')
    def exportChildren(self, outfile, level, namespace_='', name_='Mortgage', fromsubclass_=False, pretty_print=True):
        super(Mortgage, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.insurer is not None:
            self.insurer.export(outfile, level, namespace_, name_='insurer', pretty_print=pretty_print)
        if self.insurerReference is not None:
            self.insurerReference.export(outfile, level, namespace_, name_='insurerReference', pretty_print=pretty_print)
        if self.issuerName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sissuerName>%s</%sissuerName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.issuerName), input_name='issuerName')), namespace_, eol_))
        if self.issuerPartyReference is not None:
            self.issuerPartyReference.export(outfile, level, namespace_, name_='issuerPartyReference', pretty_print=pretty_print)
        if self.seniority is not None:
            self.seniority.export(outfile, level, namespace_, name_='seniority', pretty_print=pretty_print)
        if self.couponType is not None:
            self.couponType.export(outfile, level, namespace_, name_='couponType', pretty_print=pretty_print)
        if self.couponRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scouponRate>%s</%scouponRate>%s' % (namespace_, self.gds_format_float(self.couponRate, input_name='couponRate'), namespace_, eol_))
        if self.maturity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaturity>%s</%smaturity>%s' % (namespace_, self.gds_format_date(self.maturity, input_name='maturity'), namespace_, eol_))
        if self.paymentFrequency is not None:
            self.paymentFrequency.export(outfile, level, namespace_, name_='paymentFrequency', pretty_print=pretty_print)
        if self.dayCountFraction is not None:
            self.dayCountFraction.export(outfile, level, namespace_, name_='dayCountFraction', pretty_print=pretty_print)
        if self.originalPrincipalAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soriginalPrincipalAmount>%s</%soriginalPrincipalAmount>%s' % (namespace_, self.gds_format_float(self.originalPrincipalAmount, input_name='originalPrincipalAmount'), namespace_, eol_))
        if self.pool is not None:
            self.pool.export(outfile, level, namespace_, name_='pool', pretty_print=pretty_print)
        if self.sector is not None:
            self.sector.export(outfile, level, namespace_, name_='sector', pretty_print=pretty_print)
        if self.tranche is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stranche>%s</%stranche>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.tranche), input_name='tranche')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Mortgage, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'insurer':
            obj_ = LegalEntity.factory()
            obj_.build(child_)
            self.insurer = obj_
            obj_.original_tagname_ = 'insurer'
        elif nodeName_ == 'insurerReference':
            obj_ = LegalEntityReference.factory()
            obj_.build(child_)
            self.insurerReference = obj_
            obj_.original_tagname_ = 'insurerReference'
        elif nodeName_ == 'issuerName':
            issuerName_ = child_.text
            issuerName_ = self.gds_validate_string(issuerName_, node, 'issuerName')
            self.issuerName = issuerName_
            # validate type String
            self.validate_String(self.issuerName)
        elif nodeName_ == 'issuerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.issuerPartyReference = obj_
            obj_.original_tagname_ = 'issuerPartyReference'
        elif nodeName_ == 'seniority':
            obj_ = CreditSeniority.factory()
            obj_.build(child_)
            self.seniority = obj_
            obj_.original_tagname_ = 'seniority'
        elif nodeName_ == 'couponType':
            obj_ = CouponType.factory()
            obj_.build(child_)
            self.couponType = obj_
            obj_.original_tagname_ = 'couponType'
        elif nodeName_ == 'couponRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'couponRate')
            self.couponRate = fval_
        elif nodeName_ == 'maturity':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.maturity = dval_
        elif nodeName_ == 'paymentFrequency':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.paymentFrequency = obj_
            obj_.original_tagname_ = 'paymentFrequency'
        elif nodeName_ == 'dayCountFraction':
            obj_ = DayCountFraction.factory()
            obj_.build(child_)
            self.dayCountFraction = obj_
            obj_.original_tagname_ = 'dayCountFraction'
        elif nodeName_ == 'originalPrincipalAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'originalPrincipalAmount')
            self.originalPrincipalAmount = fval_
        elif nodeName_ == 'pool':
            obj_ = AssetPool.factory()
            obj_.build(child_)
            self.pool = obj_
            obj_.original_tagname_ = 'pool'
        elif nodeName_ == 'sector':
            obj_ = MortgageSector.factory()
            obj_.build(child_)
            self.sector = obj_
            obj_.original_tagname_ = 'sector'
        elif nodeName_ == 'tranche':
            tranche_ = child_.text
            tranche_ = re_.sub(String_cleanup_pat_, " ", tranche_).strip()
            tranche_ = self.gds_validate_string(tranche_, node, 'tranche')
            self.tranche = tranche_
            # validate type Token
            self.validate_Token(self.tranche)
        super(Mortgage, self).buildChildren(child_, node, nodeName_, True)
# end class Mortgage


class Loan(UnderlyingAsset):
    """A type describing a loan underlying asset.Specifies the borrower.
    There can be more than one borrower. It is meant to be used in
    the event that there is no Bloomberg Id or the Secured List
    isn't applicable."""
    member_data_items_ = {
        'borrower': MemberSpec_('borrower', 'LegalEntity', 1),
        'borrowerReference': MemberSpec_('borrowerReference', 'LegalEntityReference', 1),
        'lien': MemberSpec_('lien', 'Lien', 0),
        'facilityType': MemberSpec_('facilityType', 'FacilityType', 0),
        'maturity': MemberSpec_('maturity', 'xsd:date', 0),
        'creditAgreementDate': MemberSpec_('creditAgreementDate', 'xsd:date', 0),
        'tranche': MemberSpec_('tranche', 'UnderlyingAssetTranche', 0),
    }
    subclass = None
    superclass = UnderlyingAsset
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, borrower=None, borrowerReference=None, lien=None, facilityType=None, maturity=None, creditAgreementDate=None, tranche=None):
        self.original_tagname_ = None
        super(Loan, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, )
        if borrower is None:
            self.borrower = []
        else:
            self.borrower = borrower
        if borrowerReference is None:
            self.borrowerReference = []
        else:
            self.borrowerReference = borrowerReference
        self.lien = lien
        self.facilityType = facilityType
        if isinstance(maturity, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(maturity, '%Y-%m-%d').date()
        else:
            initvalue_ = maturity
        self.maturity = initvalue_
        if isinstance(creditAgreementDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(creditAgreementDate, '%Y-%m-%d').date()
        else:
            initvalue_ = creditAgreementDate
        self.creditAgreementDate = initvalue_
        self.tranche = tranche
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Loan)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Loan.subclass:
            return Loan.subclass(*args_, **kwargs_)
        else:
            return Loan(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_borrower(self): return self.borrower
    def set_borrower(self, borrower): self.borrower = borrower
    def add_borrower(self, value): self.borrower.append(value)
    def insert_borrower_at(self, index, value): self.borrower.insert(index, value)
    def replace_borrower_at(self, index, value): self.borrower[index] = value
    def get_borrowerReference(self): return self.borrowerReference
    def set_borrowerReference(self, borrowerReference): self.borrowerReference = borrowerReference
    def add_borrowerReference(self, value): self.borrowerReference.append(value)
    def insert_borrowerReference_at(self, index, value): self.borrowerReference.insert(index, value)
    def replace_borrowerReference_at(self, index, value): self.borrowerReference[index] = value
    def get_lien(self): return self.lien
    def set_lien(self, lien): self.lien = lien
    def get_facilityType(self): return self.facilityType
    def set_facilityType(self, facilityType): self.facilityType = facilityType
    def get_maturity(self): return self.maturity
    def set_maturity(self, maturity): self.maturity = maturity
    def get_creditAgreementDate(self): return self.creditAgreementDate
    def set_creditAgreementDate(self, creditAgreementDate): self.creditAgreementDate = creditAgreementDate
    def get_tranche(self): return self.tranche
    def set_tranche(self, tranche): self.tranche = tranche
    def hasContent_(self):
        if (
            self.borrower or
            self.borrowerReference or
            self.lien is not None or
            self.facilityType is not None or
            self.maturity is not None or
            self.creditAgreementDate is not None or
            self.tranche is not None or
            super(Loan, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Loan', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Loan')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Loan', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Loan'):
        super(Loan, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Loan')
    def exportChildren(self, outfile, level, namespace_='', name_='Loan', fromsubclass_=False, pretty_print=True):
        super(Loan, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for borrower_ in self.borrower:
            borrower_.export(outfile, level, namespace_, name_='borrower', pretty_print=pretty_print)
        for borrowerReference_ in self.borrowerReference:
            borrowerReference_.export(outfile, level, namespace_, name_='borrowerReference', pretty_print=pretty_print)
        if self.lien is not None:
            self.lien.export(outfile, level, namespace_, name_='lien', pretty_print=pretty_print)
        if self.facilityType is not None:
            self.facilityType.export(outfile, level, namespace_, name_='facilityType', pretty_print=pretty_print)
        if self.maturity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaturity>%s</%smaturity>%s' % (namespace_, self.gds_format_date(self.maturity, input_name='maturity'), namespace_, eol_))
        if self.creditAgreementDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%screditAgreementDate>%s</%screditAgreementDate>%s' % (namespace_, self.gds_format_date(self.creditAgreementDate, input_name='creditAgreementDate'), namespace_, eol_))
        if self.tranche is not None:
            self.tranche.export(outfile, level, namespace_, name_='tranche', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Loan, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'borrower':
            obj_ = LegalEntity.factory()
            obj_.build(child_)
            self.borrower.append(obj_)
            obj_.original_tagname_ = 'borrower'
        elif nodeName_ == 'borrowerReference':
            obj_ = LegalEntityReference.factory()
            obj_.build(child_)
            self.borrowerReference.append(obj_)
            obj_.original_tagname_ = 'borrowerReference'
        elif nodeName_ == 'lien':
            obj_ = Lien.factory()
            obj_.build(child_)
            self.lien = obj_
            obj_.original_tagname_ = 'lien'
        elif nodeName_ == 'facilityType':
            obj_ = FacilityType.factory()
            obj_.build(child_)
            self.facilityType = obj_
            obj_.original_tagname_ = 'facilityType'
        elif nodeName_ == 'maturity':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.maturity = dval_
        elif nodeName_ == 'creditAgreementDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.creditAgreementDate = dval_
        elif nodeName_ == 'tranche':
            obj_ = UnderlyingAssetTranche.factory()
            obj_.build(child_)
            self.tranche = obj_
            obj_.original_tagname_ = 'tranche'
        super(Loan, self).buildChildren(child_, node, nodeName_, True)
# end class Loan


class FxRateAsset(UnderlyingAsset):
    member_data_items_ = {
        'quotedCurrencyPair': MemberSpec_('quotedCurrencyPair', 'QuotedCurrencyPair', 0),
        'rateSource': MemberSpec_('rateSource', 'FxSpotRateSource', 0),
    }
    subclass = None
    superclass = UnderlyingAsset
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, quotedCurrencyPair=None, rateSource=None):
        self.original_tagname_ = None
        super(FxRateAsset, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, )
        self.quotedCurrencyPair = quotedCurrencyPair
        self.rateSource = rateSource
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FxRateAsset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FxRateAsset.subclass:
            return FxRateAsset.subclass(*args_, **kwargs_)
        else:
            return FxRateAsset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_quotedCurrencyPair(self): return self.quotedCurrencyPair
    def set_quotedCurrencyPair(self, quotedCurrencyPair): self.quotedCurrencyPair = quotedCurrencyPair
    def get_rateSource(self): return self.rateSource
    def set_rateSource(self, rateSource): self.rateSource = rateSource
    def hasContent_(self):
        if (
            self.quotedCurrencyPair is not None or
            self.rateSource is not None or
            super(FxRateAsset, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FxRateAsset', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FxRateAsset')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FxRateAsset', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FxRateAsset'):
        super(FxRateAsset, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FxRateAsset')
    def exportChildren(self, outfile, level, namespace_='', name_='FxRateAsset', fromsubclass_=False, pretty_print=True):
        super(FxRateAsset, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.quotedCurrencyPair is not None:
            self.quotedCurrencyPair.export(outfile, level, namespace_, name_='quotedCurrencyPair', pretty_print=pretty_print)
        if self.rateSource is not None:
            self.rateSource.export(outfile, level, namespace_, name_='rateSource', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FxRateAsset, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'quotedCurrencyPair':
            obj_ = QuotedCurrencyPair.factory()
            obj_.build(child_)
            self.quotedCurrencyPair = obj_
            obj_.original_tagname_ = 'quotedCurrencyPair'
        elif nodeName_ == 'rateSource':
            obj_ = FxSpotRateSource.factory()
            obj_.build(child_)
            self.rateSource = obj_
            obj_.original_tagname_ = 'rateSource'
        super(FxRateAsset, self).buildChildren(child_, node, nodeName_, True)
# end class FxRateAsset


class ExchangeTraded(UnderlyingAsset):
    """An abstract base class for all exchange traded financial products."""
    member_data_items_ = {
        'relatedExchangeId': MemberSpec_('relatedExchangeId', 'ExchangeId', 1),
        'optionsExchangeId': MemberSpec_('optionsExchangeId', 'ExchangeId', 1),
        'specifiedExchangeId': MemberSpec_('specifiedExchangeId', 'ExchangeId', 1),
    }
    subclass = None
    superclass = UnderlyingAsset
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, relatedExchangeId=None, optionsExchangeId=None, specifiedExchangeId=None, extensiontype_=None):
        self.original_tagname_ = None
        super(ExchangeTraded, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, extensiontype_, )
        if relatedExchangeId is None:
            self.relatedExchangeId = []
        else:
            self.relatedExchangeId = relatedExchangeId
        if optionsExchangeId is None:
            self.optionsExchangeId = []
        else:
            self.optionsExchangeId = optionsExchangeId
        if specifiedExchangeId is None:
            self.specifiedExchangeId = []
        else:
            self.specifiedExchangeId = specifiedExchangeId
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExchangeTraded)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExchangeTraded.subclass:
            return ExchangeTraded.subclass(*args_, **kwargs_)
        else:
            return ExchangeTraded(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_relatedExchangeId(self): return self.relatedExchangeId
    def set_relatedExchangeId(self, relatedExchangeId): self.relatedExchangeId = relatedExchangeId
    def add_relatedExchangeId(self, value): self.relatedExchangeId.append(value)
    def insert_relatedExchangeId_at(self, index, value): self.relatedExchangeId.insert(index, value)
    def replace_relatedExchangeId_at(self, index, value): self.relatedExchangeId[index] = value
    def get_optionsExchangeId(self): return self.optionsExchangeId
    def set_optionsExchangeId(self, optionsExchangeId): self.optionsExchangeId = optionsExchangeId
    def add_optionsExchangeId(self, value): self.optionsExchangeId.append(value)
    def insert_optionsExchangeId_at(self, index, value): self.optionsExchangeId.insert(index, value)
    def replace_optionsExchangeId_at(self, index, value): self.optionsExchangeId[index] = value
    def get_specifiedExchangeId(self): return self.specifiedExchangeId
    def set_specifiedExchangeId(self, specifiedExchangeId): self.specifiedExchangeId = specifiedExchangeId
    def add_specifiedExchangeId(self, value): self.specifiedExchangeId.append(value)
    def insert_specifiedExchangeId_at(self, index, value): self.specifiedExchangeId.insert(index, value)
    def replace_specifiedExchangeId_at(self, index, value): self.specifiedExchangeId[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.relatedExchangeId or
            self.optionsExchangeId or
            self.specifiedExchangeId or
            super(ExchangeTraded, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExchangeTraded', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExchangeTraded')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExchangeTraded', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExchangeTraded'):
        super(ExchangeTraded, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ExchangeTraded')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='ExchangeTraded', fromsubclass_=False, pretty_print=True):
        super(ExchangeTraded, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for relatedExchangeId_ in self.relatedExchangeId:
            relatedExchangeId_.export(outfile, level, namespace_, name_='relatedExchangeId', pretty_print=pretty_print)
        for optionsExchangeId_ in self.optionsExchangeId:
            optionsExchangeId_.export(outfile, level, namespace_, name_='optionsExchangeId', pretty_print=pretty_print)
        for specifiedExchangeId_ in self.specifiedExchangeId:
            specifiedExchangeId_.export(outfile, level, namespace_, name_='specifiedExchangeId', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ExchangeTraded, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'relatedExchangeId':
            obj_ = ExchangeId.factory()
            obj_.build(child_)
            self.relatedExchangeId.append(obj_)
            obj_.original_tagname_ = 'relatedExchangeId'
        elif nodeName_ == 'optionsExchangeId':
            obj_ = ExchangeId.factory()
            obj_.build(child_)
            self.optionsExchangeId.append(obj_)
            obj_.original_tagname_ = 'optionsExchangeId'
        elif nodeName_ == 'specifiedExchangeId':
            obj_ = ExchangeId.factory()
            obj_.build(child_)
            self.specifiedExchangeId.append(obj_)
            obj_.original_tagname_ = 'specifiedExchangeId'
        super(ExchangeTraded, self).buildChildren(child_, node, nodeName_, True)
# end class ExchangeTraded


class EquityAsset(ExchangeTraded):
    """An exchange traded equity asset."""
    member_data_items_ = {
    }
    subclass = None
    superclass = ExchangeTraded
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, relatedExchangeId=None, optionsExchangeId=None, specifiedExchangeId=None):
        self.original_tagname_ = None
        super(EquityAsset, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, relatedExchangeId, optionsExchangeId, specifiedExchangeId, )
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EquityAsset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EquityAsset.subclass:
            return EquityAsset.subclass(*args_, **kwargs_)
        else:
            return EquityAsset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(EquityAsset, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EquityAsset', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EquityAsset')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EquityAsset', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EquityAsset'):
        super(EquityAsset, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EquityAsset')
    def exportChildren(self, outfile, level, namespace_='', name_='EquityAsset', fromsubclass_=False, pretty_print=True):
        super(EquityAsset, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EquityAsset, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(EquityAsset, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class EquityAsset


class Deposit(UnderlyingAsset):
    member_data_items_ = {
        'term': MemberSpec_('term', 'Period', 0),
        'paymentFrequency': MemberSpec_('paymentFrequency', 'Period', 0),
        'dayCountFraction': MemberSpec_('dayCountFraction', 'DayCountFraction', 0),
    }
    subclass = None
    superclass = UnderlyingAsset
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, term=None, paymentFrequency=None, dayCountFraction=None):
        self.original_tagname_ = None
        super(Deposit, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, )
        self.term = term
        self.paymentFrequency = paymentFrequency
        self.dayCountFraction = dayCountFraction
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Deposit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Deposit.subclass:
            return Deposit.subclass(*args_, **kwargs_)
        else:
            return Deposit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_term(self): return self.term
    def set_term(self, term): self.term = term
    def get_paymentFrequency(self): return self.paymentFrequency
    def set_paymentFrequency(self, paymentFrequency): self.paymentFrequency = paymentFrequency
    def get_dayCountFraction(self): return self.dayCountFraction
    def set_dayCountFraction(self, dayCountFraction): self.dayCountFraction = dayCountFraction
    def hasContent_(self):
        if (
            self.term is not None or
            self.paymentFrequency is not None or
            self.dayCountFraction is not None or
            super(Deposit, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Deposit', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Deposit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Deposit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Deposit'):
        super(Deposit, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Deposit')
    def exportChildren(self, outfile, level, namespace_='', name_='Deposit', fromsubclass_=False, pretty_print=True):
        super(Deposit, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.term is not None:
            self.term.export(outfile, level, namespace_, name_='term', pretty_print=pretty_print)
        if self.paymentFrequency is not None:
            self.paymentFrequency.export(outfile, level, namespace_, name_='paymentFrequency', pretty_print=pretty_print)
        if self.dayCountFraction is not None:
            self.dayCountFraction.export(outfile, level, namespace_, name_='dayCountFraction', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Deposit, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'term':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.term = obj_
            obj_.original_tagname_ = 'term'
        elif nodeName_ == 'paymentFrequency':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.paymentFrequency = obj_
            obj_.original_tagname_ = 'paymentFrequency'
        elif nodeName_ == 'dayCountFraction':
            obj_ = DayCountFraction.factory()
            obj_.build(child_)
            self.dayCountFraction = obj_
            obj_.original_tagname_ = 'dayCountFraction'
        super(Deposit, self).buildChildren(child_, node, nodeName_, True)
# end class Deposit


class Commodity(IdentifiedAsset):
    """A type describing a commodity underlying asset."""
    member_data_items_ = {
        'commodityBase': MemberSpec_('commodityBase', 'CommodityBase', 0),
        'commodityDetails': MemberSpec_('commodityDetails', 'CommodityDetails', 0),
        'unit': MemberSpec_('unit', 'QuantityUnit', 0),
        'currency': MemberSpec_('currency', 'Currency', 0),
        'exchangeId': MemberSpec_('exchangeId', 'ExchangeId', 0),
        'publication': MemberSpec_('publication', 'CommodityInformationSource', 0),
        'specifiedPrice': MemberSpec_('specifiedPrice', ['SpecifiedPriceEnum', 'Token', 'xsd:token'], 0),
        'deliveryDates': MemberSpec_('deliveryDates', ['DeliveryDatesEnum', 'Token', 'xsd:token'], 0),
        'deliveryNearby': MemberSpec_('deliveryNearby', 'DeliveryNearby', 0),
        'deliveryDate': MemberSpec_('deliveryDate', 'AdjustableDate', 0),
        'deliveryDateYearMonth': MemberSpec_('deliveryDateYearMonth', 'xsd:gYearMonth', 0),
        'deliveryDateRollConvention': MemberSpec_('deliveryDateRollConvention', 'Offset', 0),
        'deliveryDateExpirationConvention': MemberSpec_('deliveryDateExpirationConvention', 'Offset', 0),
        'multiplier': MemberSpec_('multiplier', ['PositiveDecimal', 'xsd:decimal'], 0),
    }
    subclass = None
    superclass = IdentifiedAsset
    def __init__(self, id=None, instrumentId=None, description=None, commodityBase=None, commodityDetails=None, unit=None, currency=None, exchangeId=None, publication=None, specifiedPrice=None, deliveryDates=None, deliveryNearby=None, deliveryDate=None, deliveryDateYearMonth=None, deliveryDateRollConvention=None, deliveryDateExpirationConvention=None, multiplier=None):
        self.original_tagname_ = None
        super(Commodity, self).__init__(id, instrumentId, description, )
        self.commodityBase = commodityBase
        self.commodityDetails = commodityDetails
        self.unit = unit
        self.currency = currency
        self.exchangeId = exchangeId
        self.publication = publication
        self.specifiedPrice = specifiedPrice
        self.validate_SpecifiedPriceEnum(self.specifiedPrice)
        self.deliveryDates = deliveryDates
        self.validate_DeliveryDatesEnum(self.deliveryDates)
        self.deliveryNearby = deliveryNearby
        self.deliveryDate = deliveryDate
        self.deliveryDateYearMonth = deliveryDateYearMonth
        self.deliveryDateRollConvention = deliveryDateRollConvention
        self.deliveryDateExpirationConvention = deliveryDateExpirationConvention
        self.multiplier = multiplier
        self.validate_PositiveDecimal(self.multiplier)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Commodity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Commodity.subclass:
            return Commodity.subclass(*args_, **kwargs_)
        else:
            return Commodity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commodityBase(self): return self.commodityBase
    def set_commodityBase(self, commodityBase): self.commodityBase = commodityBase
    def get_commodityDetails(self): return self.commodityDetails
    def set_commodityDetails(self, commodityDetails): self.commodityDetails = commodityDetails
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_exchangeId(self): return self.exchangeId
    def set_exchangeId(self, exchangeId): self.exchangeId = exchangeId
    def get_publication(self): return self.publication
    def set_publication(self, publication): self.publication = publication
    def get_specifiedPrice(self): return self.specifiedPrice
    def set_specifiedPrice(self, specifiedPrice): self.specifiedPrice = specifiedPrice
    def get_deliveryDates(self): return self.deliveryDates
    def set_deliveryDates(self, deliveryDates): self.deliveryDates = deliveryDates
    def get_deliveryNearby(self): return self.deliveryNearby
    def set_deliveryNearby(self, deliveryNearby): self.deliveryNearby = deliveryNearby
    def get_deliveryDate(self): return self.deliveryDate
    def set_deliveryDate(self, deliveryDate): self.deliveryDate = deliveryDate
    def get_deliveryDateYearMonth(self): return self.deliveryDateYearMonth
    def set_deliveryDateYearMonth(self, deliveryDateYearMonth): self.deliveryDateYearMonth = deliveryDateYearMonth
    def get_deliveryDateRollConvention(self): return self.deliveryDateRollConvention
    def set_deliveryDateRollConvention(self, deliveryDateRollConvention): self.deliveryDateRollConvention = deliveryDateRollConvention
    def get_deliveryDateExpirationConvention(self): return self.deliveryDateExpirationConvention
    def set_deliveryDateExpirationConvention(self, deliveryDateExpirationConvention): self.deliveryDateExpirationConvention = deliveryDateExpirationConvention
    def get_multiplier(self): return self.multiplier
    def set_multiplier(self, multiplier): self.multiplier = multiplier
    def validate_SpecifiedPriceEnum(self, value):
        # Validate type SpecifiedPriceEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Afternoon', 'Ask', 'Bid', 'Closing', 'High', 'Index', 'MeanOfBidAndAsk', 'LocationalMarginal', 'Low', 'MarginalHourly', 'MarketClearing', 'MeanOfHighAndLow', 'Morning', 'Official', 'Opening', 'OSP', 'Settlement', 'Spot', 'Midpoint', 'NationalSingle', 'WeightedAverage', 'UnWeightedAverage']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SpecifiedPriceEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on SpecifiedPriceEnum' % {"value" : value} )
    def validate_DeliveryDatesEnum(self, value):
        # Validate type DeliveryDatesEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CalculationPeriod', 'FirstNearby', 'SecondNearby', 'ThirdNearby', 'FourthNearby', 'FifthNearby', 'SixthNearby', 'SeventhNearby', 'EighthNearby', 'NinthNearby', 'TenthNearby', 'EleventhNearby', 'TwelfthNearby', 'ThirteenthNearby', 'FourteenthNearby', 'FifteenthNearby', 'SixteenthNearby', 'SeventeenthNearby', 'EighteenthNearby', 'NineteenthNearby', 'TwentiethNearby', 'TwentyFirstNearby', 'TwentySecondNearby', 'TwentyThirdNearby', 'TwentyFourthNearby', 'TwentyFifthNearby', 'TwentySixthNearby', 'TwentySeventhNearby', 'TwentyEighthNearby', 'TwentyNinthNearby', 'ThirtiethNearby', 'ThirtyFirstNearby', 'ThirtySecondNearby', 'ThirtyThirdNearby', 'ThirtyFourthNearby', 'ThirtyFifthNearby', 'ThirtySixthNearby', 'ThirtySeventhNearby', 'ThirtyEighthNearby', 'ThirtyNinthNearby', 'FortiethNearby', 'FortyFirstNearby', 'FortySecondNearby', 'FortyThirdNearby', 'FortyFourthNearby', 'FortyFifthNearby', 'FortySixthNearby', 'FortySeventhNearby', 'FortyEighthNearby', 'FortyNinthNearby', 'FiftiethNearby', 'FiftyFirstNearby', 'FiftySecondNearby', 'FiftyThirdNearby', 'FiftyFourthNearby', 'FiftyFifthNearby', 'FiftySixthNearby', 'FiftySeventhNearby', 'FiftyEighthNearby', 'FiftyNinthNearby', 'Spot', 'FirstNearbyWeek', 'SecondNearbyWeek', 'ThirdNearbyWeek', 'FourthNearbyWeek', 'FifthNearbyWeek', 'SixthNearbyWeek', 'SeventhNearbyWeek', 'EighthNearbyWeek', 'NinthNearbyWeek', 'TenthNearbyWeek', 'EleventhNearbyWeek', 'TwelfthNearbyWeek', 'ThirteenthNearbyWeek', 'FourteenthNearbyWeek', 'FifteenthNearbyWeek', 'SixteenthNearbyWeek', 'SeventeenthNearbyWeek', 'EighteenthNearbyWeek', 'NineteenthNearbyWeek', 'TwentiethNearbyWeek', 'TwentyFirstNearbyWeek', 'TwentySecondNearbyWeek', 'TwentyThirdNearbyWeek', 'TwentyFourthearbyWeek', 'TwentyFifthNearbyWeek', 'TwentySixthNearbyWeek', 'TwentySeventhNearbyWeek', 'TwentyEighthNearbyWeek', 'TwentyNinthNearbyWeek', 'ThirtiethNearbyWeek', 'ThirtyFirstNearbyWeek', 'ThirtySecondNearbyWeek', 'ThirtyThirdNearbyWeek', 'ThirtyFourthNearbyWeek', 'ThirtyFifthNearbyWeek', 'ThirtySixthNearbyWeek', 'ThirtySeventhNearbyWeek', 'ThirtyEighthNearbyWeek', 'ThirtyNinthNearbyWeek', 'FortiethNearbyWeek', 'FortyFirstNearbyWeek', 'FortySecondNearbyWeek', 'FortyThirdNearbyWeek', 'FortyFourthNearbyWeek', 'FortyFifthNearbyWeek', 'FortySixthNearbyWeek', 'FortySeventhNearbyWeek', 'FortyEighthNearbyWeek', 'FortyNinthNearbyWeek', 'FiftiethNearbyWeek', 'FiftyFirstNearbyWeek', 'FiftySecondNearbyWeek']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeliveryDatesEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on DeliveryDatesEnum' % {"value" : value} )
    def validate_PositiveDecimal(self, value):
        # Validate type PositiveDecimal, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value <= 0:
                warnings_.warn('Value "%(value)s" does not match xsd minExclusive restriction on PositiveDecimal' % {"value" : value} )
    def hasContent_(self):
        if (
            self.commodityBase is not None or
            self.commodityDetails is not None or
            self.unit is not None or
            self.currency is not None or
            self.exchangeId is not None or
            self.publication is not None or
            self.specifiedPrice is not None or
            self.deliveryDates is not None or
            self.deliveryNearby is not None or
            self.deliveryDate is not None or
            self.deliveryDateYearMonth is not None or
            self.deliveryDateRollConvention is not None or
            self.deliveryDateExpirationConvention is not None or
            self.multiplier is not None or
            super(Commodity, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Commodity', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Commodity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Commodity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Commodity'):
        super(Commodity, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Commodity')
    def exportChildren(self, outfile, level, namespace_='', name_='Commodity', fromsubclass_=False, pretty_print=True):
        super(Commodity, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.commodityBase is not None:
            self.commodityBase.export(outfile, level, namespace_, name_='commodityBase', pretty_print=pretty_print)
        if self.commodityDetails is not None:
            self.commodityDetails.export(outfile, level, namespace_, name_='commodityDetails', pretty_print=pretty_print)
        if self.unit is not None:
            self.unit.export(outfile, level, namespace_, name_='unit', pretty_print=pretty_print)
        if self.currency is not None:
            self.currency.export(outfile, level, namespace_, name_='currency', pretty_print=pretty_print)
        if self.exchangeId is not None:
            self.exchangeId.export(outfile, level, namespace_, name_='exchangeId', pretty_print=pretty_print)
        if self.publication is not None:
            self.publication.export(outfile, level, namespace_, name_='publication', pretty_print=pretty_print)
        if self.specifiedPrice is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sspecifiedPrice>%s</%sspecifiedPrice>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.specifiedPrice), input_name='specifiedPrice')), namespace_, eol_))
        if self.deliveryDates is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdeliveryDates>%s</%sdeliveryDates>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.deliveryDates), input_name='deliveryDates')), namespace_, eol_))
        if self.deliveryNearby is not None:
            self.deliveryNearby.export(outfile, level, namespace_, name_='deliveryNearby', pretty_print=pretty_print)
        if self.deliveryDate is not None:
            self.deliveryDate.export(outfile, level, namespace_, name_='deliveryDate', pretty_print=pretty_print)
        if self.deliveryDateYearMonth is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdeliveryDateYearMonth>%s</%sdeliveryDateYearMonth>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.deliveryDateYearMonth), input_name='deliveryDateYearMonth')), namespace_, eol_))
        if self.deliveryDateRollConvention is not None:
            self.deliveryDateRollConvention.export(outfile, level, namespace_, name_='deliveryDateRollConvention', pretty_print=pretty_print)
        if self.deliveryDateExpirationConvention is not None:
            self.deliveryDateExpirationConvention.export(outfile, level, namespace_, name_='deliveryDateExpirationConvention', pretty_print=pretty_print)
        if self.multiplier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smultiplier>%s</%smultiplier>%s' % (namespace_, self.gds_format_float(self.multiplier, input_name='multiplier'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Commodity, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'commodityBase':
            obj_ = CommodityBase.factory()
            obj_.build(child_)
            self.commodityBase = obj_
            obj_.original_tagname_ = 'commodityBase'
        elif nodeName_ == 'commodityDetails':
            obj_ = CommodityDetails.factory()
            obj_.build(child_)
            self.commodityDetails = obj_
            obj_.original_tagname_ = 'commodityDetails'
        elif nodeName_ == 'unit':
            obj_ = QuantityUnit.factory()
            obj_.build(child_)
            self.unit = obj_
            obj_.original_tagname_ = 'unit'
        elif nodeName_ == 'currency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'exchangeId':
            obj_ = ExchangeId.factory()
            obj_.build(child_)
            self.exchangeId = obj_
            obj_.original_tagname_ = 'exchangeId'
        elif nodeName_ == 'publication':
            obj_ = CommodityInformationSource.factory()
            obj_.build(child_)
            self.publication = obj_
            obj_.original_tagname_ = 'publication'
        elif nodeName_ == 'specifiedPrice':
            specifiedPrice_ = child_.text
            specifiedPrice_ = re_.sub(String_cleanup_pat_, " ", specifiedPrice_).strip()
            specifiedPrice_ = self.gds_validate_string(specifiedPrice_, node, 'specifiedPrice')
            self.specifiedPrice = specifiedPrice_
            # validate type SpecifiedPriceEnum
            self.validate_SpecifiedPriceEnum(self.specifiedPrice)
        elif nodeName_ == 'deliveryDates':
            deliveryDates_ = child_.text
            deliveryDates_ = re_.sub(String_cleanup_pat_, " ", deliveryDates_).strip()
            deliveryDates_ = self.gds_validate_string(deliveryDates_, node, 'deliveryDates')
            self.deliveryDates = deliveryDates_
            # validate type DeliveryDatesEnum
            self.validate_DeliveryDatesEnum(self.deliveryDates)
        elif nodeName_ == 'deliveryNearby':
            obj_ = DeliveryNearby.factory()
            obj_.build(child_)
            self.deliveryNearby = obj_
            obj_.original_tagname_ = 'deliveryNearby'
        elif nodeName_ == 'deliveryDate':
            obj_ = AdjustableDate.factory()
            obj_.build(child_)
            self.deliveryDate = obj_
            obj_.original_tagname_ = 'deliveryDate'
        elif nodeName_ == 'deliveryDateYearMonth':
            deliveryDateYearMonth_ = child_.text
            deliveryDateYearMonth_ = self.gds_validate_string(deliveryDateYearMonth_, node, 'deliveryDateYearMonth')
            self.deliveryDateYearMonth = deliveryDateYearMonth_
        elif nodeName_ == 'deliveryDateRollConvention':
            class_obj_ = self.get_class_obj_(child_, Offset)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.deliveryDateRollConvention = obj_
            obj_.original_tagname_ = 'deliveryDateRollConvention'
        elif nodeName_ == 'deliveryDateExpirationConvention':
            class_obj_ = self.get_class_obj_(child_, Offset)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.deliveryDateExpirationConvention = obj_
            obj_.original_tagname_ = 'deliveryDateExpirationConvention'
        elif nodeName_ == 'multiplier':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'multiplier')
            self.multiplier = fval_
            # validate type PositiveDecimal
            self.validate_PositiveDecimal(self.multiplier)
        super(Commodity, self).buildChildren(child_, node, nodeName_, True)
# end class Commodity


class Bond(UnderlyingAsset):
    """An exchange traded bond.Specifies the issuer name of a fixed income
    security or convertible bond. This name can either be explicitly
    stated, or specified as an href into another element of the
    document, such as the obligor."""
    member_data_items_ = {
        'issuerName': MemberSpec_('issuerName', ['String', 'xsd:string'], 0),
        'issuerPartyReference': MemberSpec_('issuerPartyReference', 'PartyReference', 0),
        'seniority': MemberSpec_('seniority', 'CreditSeniority', 0),
        'couponType': MemberSpec_('couponType', 'CouponType', 0),
        'couponRate': MemberSpec_('couponRate', 'xsd:decimal', 0),
        'maturity': MemberSpec_('maturity', 'xsd:date', 0),
        'parValue': MemberSpec_('parValue', 'xsd:decimal', 0),
        'faceAmount': MemberSpec_('faceAmount', 'xsd:decimal', 0),
        'paymentFrequency': MemberSpec_('paymentFrequency', 'Period', 0),
        'dayCountFraction': MemberSpec_('dayCountFraction', 'DayCountFraction', 0),
    }
    subclass = None
    superclass = UnderlyingAsset
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, issuerName=None, issuerPartyReference=None, seniority=None, couponType=None, couponRate=None, maturity=None, parValue=None, faceAmount=None, paymentFrequency=None, dayCountFraction=None, extensiontype_=None):
        self.original_tagname_ = None
        super(Bond, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, extensiontype_, )
        self.issuerName = issuerName
        self.validate_String(self.issuerName)
        self.issuerPartyReference = issuerPartyReference
        self.seniority = seniority
        self.couponType = couponType
        self.couponRate = couponRate
        if isinstance(maturity, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(maturity, '%Y-%m-%d').date()
        else:
            initvalue_ = maturity
        self.maturity = initvalue_
        self.parValue = parValue
        self.faceAmount = faceAmount
        self.paymentFrequency = paymentFrequency
        self.dayCountFraction = dayCountFraction
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Bond)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Bond.subclass:
            return Bond.subclass(*args_, **kwargs_)
        else:
            return Bond(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_issuerName(self): return self.issuerName
    def set_issuerName(self, issuerName): self.issuerName = issuerName
    def get_issuerPartyReference(self): return self.issuerPartyReference
    def set_issuerPartyReference(self, issuerPartyReference): self.issuerPartyReference = issuerPartyReference
    def get_seniority(self): return self.seniority
    def set_seniority(self, seniority): self.seniority = seniority
    def get_couponType(self): return self.couponType
    def set_couponType(self, couponType): self.couponType = couponType
    def get_couponRate(self): return self.couponRate
    def set_couponRate(self, couponRate): self.couponRate = couponRate
    def get_maturity(self): return self.maturity
    def set_maturity(self, maturity): self.maturity = maturity
    def get_parValue(self): return self.parValue
    def set_parValue(self, parValue): self.parValue = parValue
    def get_faceAmount(self): return self.faceAmount
    def set_faceAmount(self, faceAmount): self.faceAmount = faceAmount
    def get_paymentFrequency(self): return self.paymentFrequency
    def set_paymentFrequency(self, paymentFrequency): self.paymentFrequency = paymentFrequency
    def get_dayCountFraction(self): return self.dayCountFraction
    def set_dayCountFraction(self, dayCountFraction): self.dayCountFraction = dayCountFraction
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.issuerName is not None or
            self.issuerPartyReference is not None or
            self.seniority is not None or
            self.couponType is not None or
            self.couponRate is not None or
            self.maturity is not None or
            self.parValue is not None or
            self.faceAmount is not None or
            self.paymentFrequency is not None or
            self.dayCountFraction is not None or
            super(Bond, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Bond', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Bond')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Bond', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Bond'):
        super(Bond, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Bond')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Bond', fromsubclass_=False, pretty_print=True):
        super(Bond, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.issuerName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sissuerName>%s</%sissuerName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.issuerName), input_name='issuerName')), namespace_, eol_))
        if self.issuerPartyReference is not None:
            self.issuerPartyReference.export(outfile, level, namespace_, name_='issuerPartyReference', pretty_print=pretty_print)
        if self.seniority is not None:
            self.seniority.export(outfile, level, namespace_, name_='seniority', pretty_print=pretty_print)
        if self.couponType is not None:
            self.couponType.export(outfile, level, namespace_, name_='couponType', pretty_print=pretty_print)
        if self.couponRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scouponRate>%s</%scouponRate>%s' % (namespace_, self.gds_format_float(self.couponRate, input_name='couponRate'), namespace_, eol_))
        if self.maturity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaturity>%s</%smaturity>%s' % (namespace_, self.gds_format_date(self.maturity, input_name='maturity'), namespace_, eol_))
        if self.parValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sparValue>%s</%sparValue>%s' % (namespace_, self.gds_format_float(self.parValue, input_name='parValue'), namespace_, eol_))
        if self.faceAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfaceAmount>%s</%sfaceAmount>%s' % (namespace_, self.gds_format_float(self.faceAmount, input_name='faceAmount'), namespace_, eol_))
        if self.paymentFrequency is not None:
            self.paymentFrequency.export(outfile, level, namespace_, name_='paymentFrequency', pretty_print=pretty_print)
        if self.dayCountFraction is not None:
            self.dayCountFraction.export(outfile, level, namespace_, name_='dayCountFraction', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(Bond, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'issuerName':
            issuerName_ = child_.text
            issuerName_ = self.gds_validate_string(issuerName_, node, 'issuerName')
            self.issuerName = issuerName_
            # validate type String
            self.validate_String(self.issuerName)
        elif nodeName_ == 'issuerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.issuerPartyReference = obj_
            obj_.original_tagname_ = 'issuerPartyReference'
        elif nodeName_ == 'seniority':
            obj_ = CreditSeniority.factory()
            obj_.build(child_)
            self.seniority = obj_
            obj_.original_tagname_ = 'seniority'
        elif nodeName_ == 'couponType':
            obj_ = CouponType.factory()
            obj_.build(child_)
            self.couponType = obj_
            obj_.original_tagname_ = 'couponType'
        elif nodeName_ == 'couponRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'couponRate')
            self.couponRate = fval_
        elif nodeName_ == 'maturity':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.maturity = dval_
        elif nodeName_ == 'parValue':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'parValue')
            self.parValue = fval_
        elif nodeName_ == 'faceAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'faceAmount')
            self.faceAmount = fval_
        elif nodeName_ == 'paymentFrequency':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.paymentFrequency = obj_
            obj_.original_tagname_ = 'paymentFrequency'
        elif nodeName_ == 'dayCountFraction':
            obj_ = DayCountFraction.factory()
            obj_.build(child_)
            self.dayCountFraction = obj_
            obj_.original_tagname_ = 'dayCountFraction'
        super(Bond, self).buildChildren(child_, node, nodeName_, True)
# end class Bond


class AssetReference(Reference):
    """Reference to an underlying asset."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(AssetReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AssetReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AssetReference.subclass:
            return AssetReference.subclass(*args_, **kwargs_)
        else:
            return AssetReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(AssetReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AssetReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AssetReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AssetReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AssetReference'):
        super(AssetReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AssetReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AssetReference', fromsubclass_=False, pretty_print=True):
        super(AssetReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(AssetReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AssetReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AssetReference


class AnyAssetReference(Reference):
    """A reference to an asset, e.g. a portfolio, trade, or reference
    instrument.."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(AnyAssetReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnyAssetReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnyAssetReference.subclass:
            return AnyAssetReference.subclass(*args_, **kwargs_)
        else:
            return AnyAssetReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(AnyAssetReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AnyAssetReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnyAssetReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AnyAssetReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AnyAssetReference'):
        super(AnyAssetReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AnyAssetReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AnyAssetReference', fromsubclass_=False, pretty_print=True):
        super(AnyAssetReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(AnyAssetReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AnyAssetReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AnyAssetReference


class Premium(SimplePayment):
    """A type for defining a premium."""
    member_data_items_ = {
        'premiumType': MemberSpec_('premiumType', ['PremiumTypeEnum', 'Token', 'xsd:token'], 0),
        'pricePerOption': MemberSpec_('pricePerOption', 'Money', 0),
        'percentageOfNotional': MemberSpec_('percentageOfNotional', 'xsd:decimal', 0),
        'discountFactor': MemberSpec_('discountFactor', 'xsd:decimal', 0),
        'presentValueAmount': MemberSpec_('presentValueAmount', 'Money', 0),
    }
    subclass = None
    superclass = SimplePayment
    def __init__(self, id=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, paymentAmount=None, paymentDate=None, premiumType=None, pricePerOption=None, percentageOfNotional=None, discountFactor=None, presentValueAmount=None):
        self.original_tagname_ = None
        super(Premium, self).__init__(id, payerPartyReference, payerAccountReference, receiverPartyReference, receiverAccountReference, paymentAmount, paymentDate, )
        self.premiumType = premiumType
        self.validate_PremiumTypeEnum(self.premiumType)
        self.pricePerOption = pricePerOption
        self.percentageOfNotional = percentageOfNotional
        self.discountFactor = discountFactor
        self.presentValueAmount = presentValueAmount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Premium)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Premium.subclass:
            return Premium.subclass(*args_, **kwargs_)
        else:
            return Premium(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_premiumType(self): return self.premiumType
    def set_premiumType(self, premiumType): self.premiumType = premiumType
    def get_pricePerOption(self): return self.pricePerOption
    def set_pricePerOption(self, pricePerOption): self.pricePerOption = pricePerOption
    def get_percentageOfNotional(self): return self.percentageOfNotional
    def set_percentageOfNotional(self, percentageOfNotional): self.percentageOfNotional = percentageOfNotional
    def get_discountFactor(self): return self.discountFactor
    def set_discountFactor(self, discountFactor): self.discountFactor = discountFactor
    def get_presentValueAmount(self): return self.presentValueAmount
    def set_presentValueAmount(self, presentValueAmount): self.presentValueAmount = presentValueAmount
    def validate_PremiumTypeEnum(self, value):
        # Validate type PremiumTypeEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['PrePaid', 'PostPaid', 'Variable', 'Fixed']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PremiumTypeEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on PremiumTypeEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.premiumType is not None or
            self.pricePerOption is not None or
            self.percentageOfNotional is not None or
            self.discountFactor is not None or
            self.presentValueAmount is not None or
            super(Premium, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Premium', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Premium')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Premium', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Premium'):
        super(Premium, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Premium')
    def exportChildren(self, outfile, level, namespace_='', name_='Premium', fromsubclass_=False, pretty_print=True):
        super(Premium, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.premiumType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spremiumType>%s</%spremiumType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.premiumType), input_name='premiumType')), namespace_, eol_))
        if self.pricePerOption is not None:
            self.pricePerOption.export(outfile, level, namespace_, name_='pricePerOption', pretty_print=pretty_print)
        if self.percentageOfNotional is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spercentageOfNotional>%s</%spercentageOfNotional>%s' % (namespace_, self.gds_format_float(self.percentageOfNotional, input_name='percentageOfNotional'), namespace_, eol_))
        if self.discountFactor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdiscountFactor>%s</%sdiscountFactor>%s' % (namespace_, self.gds_format_float(self.discountFactor, input_name='discountFactor'), namespace_, eol_))
        if self.presentValueAmount is not None:
            self.presentValueAmount.export(outfile, level, namespace_, name_='presentValueAmount', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Premium, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'premiumType':
            premiumType_ = child_.text
            premiumType_ = re_.sub(String_cleanup_pat_, " ", premiumType_).strip()
            premiumType_ = self.gds_validate_string(premiumType_, node, 'premiumType')
            self.premiumType = premiumType_
            # validate type PremiumTypeEnum
            self.validate_PremiumTypeEnum(self.premiumType)
        elif nodeName_ == 'pricePerOption':
            obj_ = Money.factory()
            obj_.build(child_)
            self.pricePerOption = obj_
            obj_.original_tagname_ = 'pricePerOption'
        elif nodeName_ == 'percentageOfNotional':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'percentageOfNotional')
            self.percentageOfNotional = fval_
        elif nodeName_ == 'discountFactor':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'discountFactor')
            self.discountFactor = fval_
        elif nodeName_ == 'presentValueAmount':
            obj_ = Money.factory()
            obj_.build(child_)
            self.presentValueAmount = obj_
            obj_.original_tagname_ = 'presentValueAmount'
        super(Premium, self).buildChildren(child_, node, nodeName_, True)
# end class Premium


class Option(Product):
    """A type for defining the common features of options. Buyer/seller
    information is not normally used in Transparency view but is
    optional in case the information is needed for administrative
    purposes such as Reporting Party determination."""
    member_data_items_ = {
        'buyerPartyReference': MemberSpec_('buyerPartyReference', 'PartyReference', 0),
        'buyerAccountReference': MemberSpec_('buyerAccountReference', 'AccountReference', 0),
        'sellerPartyReference': MemberSpec_('sellerPartyReference', 'PartyReference', 0),
        'sellerAccountReference': MemberSpec_('sellerAccountReference', 'AccountReference', 0),
    }
    subclass = None
    superclass = Product
    def __init__(self, id=None, primaryAssetClass=None, secondaryAssetClass=None, productType=None, productId=None, assetClass=None, embeddedOptionType=None, buyerPartyReference=None, buyerAccountReference=None, sellerPartyReference=None, sellerAccountReference=None, extensiontype_=None):
        self.original_tagname_ = None
        super(Option, self).__init__(id, primaryAssetClass, secondaryAssetClass, productType, productId, assetClass, embeddedOptionType, extensiontype_, )
        self.buyerPartyReference = buyerPartyReference
        self.buyerAccountReference = buyerAccountReference
        self.sellerPartyReference = sellerPartyReference
        self.sellerAccountReference = sellerAccountReference
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Option)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Option.subclass:
            return Option.subclass(*args_, **kwargs_)
        else:
            return Option(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_buyerPartyReference(self): return self.buyerPartyReference
    def set_buyerPartyReference(self, buyerPartyReference): self.buyerPartyReference = buyerPartyReference
    def get_buyerAccountReference(self): return self.buyerAccountReference
    def set_buyerAccountReference(self, buyerAccountReference): self.buyerAccountReference = buyerAccountReference
    def get_sellerPartyReference(self): return self.sellerPartyReference
    def set_sellerPartyReference(self, sellerPartyReference): self.sellerPartyReference = sellerPartyReference
    def get_sellerAccountReference(self): return self.sellerAccountReference
    def set_sellerAccountReference(self, sellerAccountReference): self.sellerAccountReference = sellerAccountReference
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.buyerPartyReference is not None or
            self.buyerAccountReference is not None or
            self.sellerPartyReference is not None or
            self.sellerAccountReference is not None or
            super(Option, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Option', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Option')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Option', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Option'):
        super(Option, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Option')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Option', fromsubclass_=False, pretty_print=True):
        super(Option, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.buyerPartyReference is not None:
            self.buyerPartyReference.export(outfile, level, namespace_, name_='buyerPartyReference', pretty_print=pretty_print)
        if self.buyerAccountReference is not None:
            self.buyerAccountReference.export(outfile, level, namespace_, name_='buyerAccountReference', pretty_print=pretty_print)
        if self.sellerPartyReference is not None:
            self.sellerPartyReference.export(outfile, level, namespace_, name_='sellerPartyReference', pretty_print=pretty_print)
        if self.sellerAccountReference is not None:
            self.sellerAccountReference.export(outfile, level, namespace_, name_='sellerAccountReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(Option, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'buyerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.buyerPartyReference = obj_
            obj_.original_tagname_ = 'buyerPartyReference'
        elif nodeName_ == 'buyerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.buyerAccountReference = obj_
            obj_.original_tagname_ = 'buyerAccountReference'
        elif nodeName_ == 'sellerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.sellerPartyReference = obj_
            obj_.original_tagname_ = 'sellerPartyReference'
        elif nodeName_ == 'sellerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.sellerAccountReference = obj_
            obj_.original_tagname_ = 'sellerAccountReference'
        super(Option, self).buildChildren(child_, node, nodeName_, True)
# end class Option


class FeaturePayment(PaymentBase):
    """Payment made following trigger occurence."""
    member_data_items_ = {
        'payerPartyReference': MemberSpec_('payerPartyReference', 'PartyReference', 0),
        'payerAccountReference': MemberSpec_('payerAccountReference', 'AccountReference', 0),
        'receiverPartyReference': MemberSpec_('receiverPartyReference', 'PartyReference', 0),
        'receiverAccountReference': MemberSpec_('receiverAccountReference', 'AccountReference', 0),
        'levelPercentage': MemberSpec_('levelPercentage', 'xsd:decimal', 0),
        'amount': MemberSpec_('amount', ['NonNegativeDecimal', 'xsd:decimal'], 0),
        'time': MemberSpec_('time', ['TimeTypeEnum', 'Token', 'xsd:token'], 0),
        'currency': MemberSpec_('currency', 'Currency', 0),
        'featurePaymentDate': MemberSpec_('featurePaymentDate', 'AdjustableOrRelativeDate', 0),
    }
    subclass = None
    superclass = PaymentBase
    def __init__(self, id=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, levelPercentage=None, amount=None, time=None, currency=None, featurePaymentDate=None):
        self.original_tagname_ = None
        super(FeaturePayment, self).__init__(id, )
        self.payerPartyReference = payerPartyReference
        self.payerAccountReference = payerAccountReference
        self.receiverPartyReference = receiverPartyReference
        self.receiverAccountReference = receiverAccountReference
        self.levelPercentage = levelPercentage
        self.amount = amount
        self.validate_NonNegativeDecimal(self.amount)
        self.time = time
        self.validate_TimeTypeEnum(self.time)
        self.currency = currency
        self.featurePaymentDate = featurePaymentDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FeaturePayment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FeaturePayment.subclass:
            return FeaturePayment.subclass(*args_, **kwargs_)
        else:
            return FeaturePayment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_payerPartyReference(self): return self.payerPartyReference
    def set_payerPartyReference(self, payerPartyReference): self.payerPartyReference = payerPartyReference
    def get_payerAccountReference(self): return self.payerAccountReference
    def set_payerAccountReference(self, payerAccountReference): self.payerAccountReference = payerAccountReference
    def get_receiverPartyReference(self): return self.receiverPartyReference
    def set_receiverPartyReference(self, receiverPartyReference): self.receiverPartyReference = receiverPartyReference
    def get_receiverAccountReference(self): return self.receiverAccountReference
    def set_receiverAccountReference(self, receiverAccountReference): self.receiverAccountReference = receiverAccountReference
    def get_levelPercentage(self): return self.levelPercentage
    def set_levelPercentage(self, levelPercentage): self.levelPercentage = levelPercentage
    def get_amount(self): return self.amount
    def set_amount(self, amount): self.amount = amount
    def get_time(self): return self.time
    def set_time(self, time): self.time = time
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_featurePaymentDate(self): return self.featurePaymentDate
    def set_featurePaymentDate(self, featurePaymentDate): self.featurePaymentDate = featurePaymentDate
    def validate_NonNegativeDecimal(self, value):
        # Validate type NonNegativeDecimal, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on NonNegativeDecimal' % {"value" : value} )
    def validate_TimeTypeEnum(self, value):
        # Validate type TimeTypeEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Close', 'Open', 'OSP', 'SpecificTime', 'XETRA', 'DerivativesClose', 'AsSpecifiedInMasterConfirmation']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TimeTypeEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on TimeTypeEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.payerPartyReference is not None or
            self.payerAccountReference is not None or
            self.receiverPartyReference is not None or
            self.receiverAccountReference is not None or
            self.levelPercentage is not None or
            self.amount is not None or
            self.time is not None or
            self.currency is not None or
            self.featurePaymentDate is not None or
            super(FeaturePayment, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FeaturePayment', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FeaturePayment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FeaturePayment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FeaturePayment'):
        super(FeaturePayment, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FeaturePayment')
    def exportChildren(self, outfile, level, namespace_='', name_='FeaturePayment', fromsubclass_=False, pretty_print=True):
        super(FeaturePayment, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.payerPartyReference is not None:
            self.payerPartyReference.export(outfile, level, namespace_, name_='payerPartyReference', pretty_print=pretty_print)
        if self.payerAccountReference is not None:
            self.payerAccountReference.export(outfile, level, namespace_, name_='payerAccountReference', pretty_print=pretty_print)
        if self.receiverPartyReference is not None:
            self.receiverPartyReference.export(outfile, level, namespace_, name_='receiverPartyReference', pretty_print=pretty_print)
        if self.receiverAccountReference is not None:
            self.receiverAccountReference.export(outfile, level, namespace_, name_='receiverAccountReference', pretty_print=pretty_print)
        if self.levelPercentage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slevelPercentage>%s</%slevelPercentage>%s' % (namespace_, self.gds_format_float(self.levelPercentage, input_name='levelPercentage'), namespace_, eol_))
        if self.amount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%samount>%s</%samount>%s' % (namespace_, self.gds_format_float(self.amount, input_name='amount'), namespace_, eol_))
        if self.time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stime>%s</%stime>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.time), input_name='time')), namespace_, eol_))
        if self.currency is not None:
            self.currency.export(outfile, level, namespace_, name_='currency', pretty_print=pretty_print)
        if self.featurePaymentDate is not None:
            self.featurePaymentDate.export(outfile, level, namespace_, name_='featurePaymentDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FeaturePayment, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'payerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.payerPartyReference = obj_
            obj_.original_tagname_ = 'payerPartyReference'
        elif nodeName_ == 'payerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.payerAccountReference = obj_
            obj_.original_tagname_ = 'payerAccountReference'
        elif nodeName_ == 'receiverPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.receiverPartyReference = obj_
            obj_.original_tagname_ = 'receiverPartyReference'
        elif nodeName_ == 'receiverAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.receiverAccountReference = obj_
            obj_.original_tagname_ = 'receiverAccountReference'
        elif nodeName_ == 'levelPercentage':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'levelPercentage')
            self.levelPercentage = fval_
        elif nodeName_ == 'amount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'amount')
            self.amount = fval_
            # validate type NonNegativeDecimal
            self.validate_NonNegativeDecimal(self.amount)
        elif nodeName_ == 'time':
            time_ = child_.text
            time_ = re_.sub(String_cleanup_pat_, " ", time_).strip()
            time_ = self.gds_validate_string(time_, node, 'time')
            self.time = time_
            # validate type TimeTypeEnum
            self.validate_TimeTypeEnum(self.time)
        elif nodeName_ == 'currency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'featurePaymentDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.featurePaymentDate = obj_
            obj_.original_tagname_ = 'featurePaymentDate'
        super(FeaturePayment, self).buildChildren(child_, node, nodeName_, True)
# end class FeaturePayment


class CreditEventsReference(Reference):
    """Reference to credit events."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(CreditEventsReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditEventsReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditEventsReference.subclass:
            return CreditEventsReference.subclass(*args_, **kwargs_)
        else:
            return CreditEventsReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(CreditEventsReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditEventsReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditEventsReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditEventsReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditEventsReference'):
        super(CreditEventsReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CreditEventsReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CreditEventsReference', fromsubclass_=False, pretty_print=True):
        super(CreditEventsReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(CreditEventsReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(CreditEventsReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CreditEventsReference


class ClassifiablePayment(NonNegativePayment):
    """A classified non negative payment."""
    member_data_items_ = {
        'paymentType': MemberSpec_('paymentType', 'PaymentType', 1),
    }
    subclass = None
    superclass = NonNegativePayment
    def __init__(self, id=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, paymentDate=None, paymentAmount=None, paymentType=None):
        self.original_tagname_ = None
        super(ClassifiablePayment, self).__init__(id, payerPartyReference, payerAccountReference, receiverPartyReference, receiverAccountReference, paymentDate, paymentAmount, )
        if paymentType is None:
            self.paymentType = []
        else:
            self.paymentType = paymentType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClassifiablePayment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClassifiablePayment.subclass:
            return ClassifiablePayment.subclass(*args_, **kwargs_)
        else:
            return ClassifiablePayment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_paymentType(self): return self.paymentType
    def set_paymentType(self, paymentType): self.paymentType = paymentType
    def add_paymentType(self, value): self.paymentType.append(value)
    def insert_paymentType_at(self, index, value): self.paymentType.insert(index, value)
    def replace_paymentType_at(self, index, value): self.paymentType[index] = value
    def hasContent_(self):
        if (
            self.paymentType or
            super(ClassifiablePayment, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ClassifiablePayment', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ClassifiablePayment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ClassifiablePayment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ClassifiablePayment'):
        super(ClassifiablePayment, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ClassifiablePayment')
    def exportChildren(self, outfile, level, namespace_='', name_='ClassifiablePayment', fromsubclass_=False, pretty_print=True):
        super(ClassifiablePayment, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for paymentType_ in self.paymentType:
            paymentType_.export(outfile, level, namespace_, name_='paymentType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ClassifiablePayment, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'paymentType':
            obj_ = PaymentType.factory()
            obj_.build(child_)
            self.paymentType.append(obj_)
            obj_.original_tagname_ = 'paymentType'
        super(ClassifiablePayment, self).buildChildren(child_, node, nodeName_, True)
# end class ClassifiablePayment


class UnderlyerInterestLeg(DirectionalLeg):
    """A type describing interest payments associated with and underlyer,
    such as financing"""
    member_data_items_ = {
        'fixedRate': MemberSpec_('fixedRate', 'xsd:decimal', 0),
        'spreadSchedule': MemberSpec_('spreadSchedule', 'SpreadSchedule', 1),
    }
    subclass = None
    superclass = DirectionalLeg
    def __init__(self, id=None, legIdentifier=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, effectiveDate=None, terminationDate=None, fixedRate=None, spreadSchedule=None):
        self.original_tagname_ = None
        super(UnderlyerInterestLeg, self).__init__(id, legIdentifier, payerPartyReference, payerAccountReference, receiverPartyReference, receiverAccountReference, effectiveDate, terminationDate, )
        self.fixedRate = fixedRate
        if spreadSchedule is None:
            self.spreadSchedule = []
        else:
            self.spreadSchedule = spreadSchedule
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UnderlyerInterestLeg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UnderlyerInterestLeg.subclass:
            return UnderlyerInterestLeg.subclass(*args_, **kwargs_)
        else:
            return UnderlyerInterestLeg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fixedRate(self): return self.fixedRate
    def set_fixedRate(self, fixedRate): self.fixedRate = fixedRate
    def get_spreadSchedule(self): return self.spreadSchedule
    def set_spreadSchedule(self, spreadSchedule): self.spreadSchedule = spreadSchedule
    def add_spreadSchedule(self, value): self.spreadSchedule.append(value)
    def insert_spreadSchedule_at(self, index, value): self.spreadSchedule.insert(index, value)
    def replace_spreadSchedule_at(self, index, value): self.spreadSchedule[index] = value
    def hasContent_(self):
        if (
            self.fixedRate is not None or
            self.spreadSchedule or
            super(UnderlyerInterestLeg, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='UnderlyerInterestLeg', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UnderlyerInterestLeg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='UnderlyerInterestLeg', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UnderlyerInterestLeg'):
        super(UnderlyerInterestLeg, self).exportAttributes(outfile, level, already_processed, namespace_, name_='UnderlyerInterestLeg')
    def exportChildren(self, outfile, level, namespace_='', name_='UnderlyerInterestLeg', fromsubclass_=False, pretty_print=True):
        super(UnderlyerInterestLeg, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.fixedRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfixedRate>%s</%sfixedRate>%s' % (namespace_, self.gds_format_float(self.fixedRate, input_name='fixedRate'), namespace_, eol_))
        for spreadSchedule_ in self.spreadSchedule:
            spreadSchedule_.export(outfile, level, namespace_, name_='spreadSchedule', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(UnderlyerInterestLeg, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fixedRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'fixedRate')
            self.fixedRate = fval_
        elif nodeName_ == 'spreadSchedule':
            obj_ = SpreadSchedule.factory()
            obj_.build(child_)
            self.spreadSchedule.append(obj_)
            obj_.original_tagname_ = 'spreadSchedule'
        super(UnderlyerInterestLeg, self).buildChildren(child_, node, nodeName_, True)
# end class UnderlyerInterestLeg


class RelativeDateOffset(Offset):
    """A type defining a date (referred to as the derived date) as a
    relative offset from another date (referred to as the anchor
    date). If the anchor date is itself an adjustable date then the
    offset is assumed to be calculated from the adjusted anchor
    date. A number of different scenarios can be supported, namely;
    1) the derived date may simply be a number of calendar periods
    (days, weeks, months or years) preceding or following the anchor
    date; 2) the unadjusted derived date may be a number of calendar
    periods (days, weeks, months or years) preceding or following
    the anchor date with the resulting unadjusted derived date
    subject to adjustment in accordance with a specified business
    day convention, i.e. the derived date must fall on a good
    business day; 3) the derived date may be a number of business
    days preceding or following the anchor date. Note that the
    businessDayConvention specifies any required adjustment to the
    unadjusted derived date. A negative or positive value in the
    periodMultiplier indicates whether the unadjusted derived
    precedes or follows the anchor date. The businessDayConvention
    should contain a value NONE if the day type element contains a
    value of Business (since specifying a negative or positive
    business days offset would already guarantee that the derived
    date would fall on a good business day in the specified business
    centers)."""
    member_data_items_ = {
        'businessDayConvention': MemberSpec_('businessDayConvention', ['BusinessDayConventionEnum', 'Token', 'xsd:token'], 0),
        'businessCentersReference': MemberSpec_('businessCentersReference', 'BusinessCentersReference', 0),
        'businessCenters': MemberSpec_('businessCenters', 'BusinessCenters', 0),
        'dateRelativeTo': MemberSpec_('dateRelativeTo', 'DateReference', 0),
        'adjustedDate': MemberSpec_('adjustedDate', 'IdentifiedDate', 0),
    }
    subclass = None
    superclass = Offset
    def __init__(self, id=None, periodMultiplier=None, period=None, dayType=None, businessDayConvention=None, businessCentersReference=None, businessCenters=None, dateRelativeTo=None, adjustedDate=None, extensiontype_=None):
        self.original_tagname_ = None
        super(RelativeDateOffset, self).__init__(id, periodMultiplier, period, dayType, extensiontype_, )
        self.businessDayConvention = businessDayConvention
        self.validate_BusinessDayConventionEnum(self.businessDayConvention)
        self.businessCentersReference = businessCentersReference
        self.businessCenters = businessCenters
        self.dateRelativeTo = dateRelativeTo
        self.adjustedDate = adjustedDate
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RelativeDateOffset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RelativeDateOffset.subclass:
            return RelativeDateOffset.subclass(*args_, **kwargs_)
        else:
            return RelativeDateOffset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_businessDayConvention(self): return self.businessDayConvention
    def set_businessDayConvention(self, businessDayConvention): self.businessDayConvention = businessDayConvention
    def get_businessCentersReference(self): return self.businessCentersReference
    def set_businessCentersReference(self, businessCentersReference): self.businessCentersReference = businessCentersReference
    def get_businessCenters(self): return self.businessCenters
    def set_businessCenters(self, businessCenters): self.businessCenters = businessCenters
    def get_dateRelativeTo(self): return self.dateRelativeTo
    def set_dateRelativeTo(self, dateRelativeTo): self.dateRelativeTo = dateRelativeTo
    def get_adjustedDate(self): return self.adjustedDate
    def set_adjustedDate(self, adjustedDate): self.adjustedDate = adjustedDate
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_BusinessDayConventionEnum(self, value):
        # Validate type BusinessDayConventionEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FOLLOWING', 'FRN', 'MODFOLLOWING', 'PRECEDING', 'MODPRECEDING', 'NEAREST', 'NONE', 'NotApplicable']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on BusinessDayConventionEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on BusinessDayConventionEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.businessDayConvention is not None or
            self.businessCentersReference is not None or
            self.businessCenters is not None or
            self.dateRelativeTo is not None or
            self.adjustedDate is not None or
            super(RelativeDateOffset, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RelativeDateOffset', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RelativeDateOffset')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RelativeDateOffset', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RelativeDateOffset'):
        super(RelativeDateOffset, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RelativeDateOffset')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='RelativeDateOffset', fromsubclass_=False, pretty_print=True):
        super(RelativeDateOffset, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.businessDayConvention is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbusinessDayConvention>%s</%sbusinessDayConvention>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.businessDayConvention), input_name='businessDayConvention')), namespace_, eol_))
        if self.businessCentersReference is not None:
            self.businessCentersReference.export(outfile, level, namespace_, name_='businessCentersReference', pretty_print=pretty_print)
        if self.businessCenters is not None:
            self.businessCenters.export(outfile, level, namespace_, name_='businessCenters', pretty_print=pretty_print)
        if self.dateRelativeTo is not None:
            self.dateRelativeTo.export(outfile, level, namespace_, name_='dateRelativeTo', pretty_print=pretty_print)
        if self.adjustedDate is not None:
            self.adjustedDate.export(outfile, level, namespace_, name_='adjustedDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(RelativeDateOffset, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'businessDayConvention':
            businessDayConvention_ = child_.text
            businessDayConvention_ = re_.sub(String_cleanup_pat_, " ", businessDayConvention_).strip()
            businessDayConvention_ = self.gds_validate_string(businessDayConvention_, node, 'businessDayConvention')
            self.businessDayConvention = businessDayConvention_
            # validate type BusinessDayConventionEnum
            self.validate_BusinessDayConventionEnum(self.businessDayConvention)
        elif nodeName_ == 'businessCentersReference':
            obj_ = BusinessCentersReference.factory()
            obj_.build(child_)
            self.businessCentersReference = obj_
            obj_.original_tagname_ = 'businessCentersReference'
        elif nodeName_ == 'businessCenters':
            obj_ = BusinessCenters.factory()
            obj_.build(child_)
            self.businessCenters = obj_
            obj_.original_tagname_ = 'businessCenters'
        elif nodeName_ == 'dateRelativeTo':
            obj_ = DateReference.factory()
            obj_.build(child_)
            self.dateRelativeTo = obj_
            obj_.original_tagname_ = 'dateRelativeTo'
        elif nodeName_ == 'adjustedDate':
            obj_ = IdentifiedDate.factory()
            obj_.build(child_)
            self.adjustedDate = obj_
            obj_.original_tagname_ = 'adjustedDate'
        super(RelativeDateOffset, self).buildChildren(child_, node, nodeName_, True)
# end class RelativeDateOffset


class FloatingRateCalculation(FloatingRate):
    """A type defining the floating rate and definitions relating to the
    calculation of floating rate amounts."""
    member_data_items_ = {
        'initialRate': MemberSpec_('initialRate', 'xsd:decimal', 0),
        'finalRateRounding': MemberSpec_('finalRateRounding', 'Rounding', 0),
        'averagingMethod': MemberSpec_('averagingMethod', ['AveragingMethodEnum', 'Token', 'xsd:token'], 0),
        'negativeInterestRateTreatment': MemberSpec_('negativeInterestRateTreatment', ['NegativeInterestRateTreatmentEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = FloatingRate
    def __init__(self, id=None, floatingRateIndex=None, indexTenor=None, floatingRateMultiplierSchedule=None, spreadSchedule=None, rateTreatment=None, capRateSchedule=None, floorRateSchedule=None, capFloorStraddle=None, initialRate=None, finalRateRounding=None, averagingMethod=None, negativeInterestRateTreatment=None):
        self.original_tagname_ = None
        super(FloatingRateCalculation, self).__init__(id, floatingRateIndex, indexTenor, floatingRateMultiplierSchedule, spreadSchedule, rateTreatment, capRateSchedule, floorRateSchedule, capFloorStraddle, )
        self.initialRate = initialRate
        self.finalRateRounding = finalRateRounding
        self.averagingMethod = averagingMethod
        self.validate_AveragingMethodEnum(self.averagingMethod)
        self.negativeInterestRateTreatment = negativeInterestRateTreatment
        self.validate_NegativeInterestRateTreatmentEnum(self.negativeInterestRateTreatment)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FloatingRateCalculation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FloatingRateCalculation.subclass:
            return FloatingRateCalculation.subclass(*args_, **kwargs_)
        else:
            return FloatingRateCalculation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_initialRate(self): return self.initialRate
    def set_initialRate(self, initialRate): self.initialRate = initialRate
    def get_finalRateRounding(self): return self.finalRateRounding
    def set_finalRateRounding(self, finalRateRounding): self.finalRateRounding = finalRateRounding
    def get_averagingMethod(self): return self.averagingMethod
    def set_averagingMethod(self, averagingMethod): self.averagingMethod = averagingMethod
    def get_negativeInterestRateTreatment(self): return self.negativeInterestRateTreatment
    def set_negativeInterestRateTreatment(self, negativeInterestRateTreatment): self.negativeInterestRateTreatment = negativeInterestRateTreatment
    def validate_AveragingMethodEnum(self, value):
        # Validate type AveragingMethodEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Unweighted', 'Weighted']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AveragingMethodEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on AveragingMethodEnum' % {"value" : value} )
    def validate_NegativeInterestRateTreatmentEnum(self, value):
        # Validate type NegativeInterestRateTreatmentEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NegativeInterestRateMethod', 'ZeroInterestRateMethod']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on NegativeInterestRateTreatmentEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NegativeInterestRateTreatmentEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.initialRate is not None or
            self.finalRateRounding is not None or
            self.averagingMethod is not None or
            self.negativeInterestRateTreatment is not None or
            super(FloatingRateCalculation, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FloatingRateCalculation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FloatingRateCalculation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FloatingRateCalculation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FloatingRateCalculation'):
        super(FloatingRateCalculation, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FloatingRateCalculation')
    def exportChildren(self, outfile, level, namespace_='', name_='FloatingRateCalculation', fromsubclass_=False, pretty_print=True):
        super(FloatingRateCalculation, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.initialRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinitialRate>%s</%sinitialRate>%s' % (namespace_, self.gds_format_float(self.initialRate, input_name='initialRate'), namespace_, eol_))
        if self.finalRateRounding is not None:
            self.finalRateRounding.export(outfile, level, namespace_, name_='finalRateRounding', pretty_print=pretty_print)
        if self.averagingMethod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saveragingMethod>%s</%saveragingMethod>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.averagingMethod), input_name='averagingMethod')), namespace_, eol_))
        if self.negativeInterestRateTreatment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snegativeInterestRateTreatment>%s</%snegativeInterestRateTreatment>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.negativeInterestRateTreatment), input_name='negativeInterestRateTreatment')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FloatingRateCalculation, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'initialRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'initialRate')
            self.initialRate = fval_
        elif nodeName_ == 'finalRateRounding':
            obj_ = Rounding.factory()
            obj_.build(child_)
            self.finalRateRounding = obj_
            obj_.original_tagname_ = 'finalRateRounding'
        elif nodeName_ == 'averagingMethod':
            averagingMethod_ = child_.text
            averagingMethod_ = re_.sub(String_cleanup_pat_, " ", averagingMethod_).strip()
            averagingMethod_ = self.gds_validate_string(averagingMethod_, node, 'averagingMethod')
            self.averagingMethod = averagingMethod_
            # validate type AveragingMethodEnum
            self.validate_AveragingMethodEnum(self.averagingMethod)
        elif nodeName_ == 'negativeInterestRateTreatment':
            negativeInterestRateTreatment_ = child_.text
            negativeInterestRateTreatment_ = re_.sub(String_cleanup_pat_, " ", negativeInterestRateTreatment_).strip()
            negativeInterestRateTreatment_ = self.gds_validate_string(negativeInterestRateTreatment_, node, 'negativeInterestRateTreatment')
            self.negativeInterestRateTreatment = negativeInterestRateTreatment_
            # validate type NegativeInterestRateTreatmentEnum
            self.validate_NegativeInterestRateTreatmentEnum(self.negativeInterestRateTreatment)
        super(FloatingRateCalculation, self).buildChildren(child_, node, nodeName_, True)
# end class FloatingRateCalculation


class AdjustedRelativeDateOffset(RelativeDateOffset):
    """A type defining a date (referred to as the derived date) as a
    relative offset from another date (referred to as the anchor
    date) plus optional date adjustments."""
    member_data_items_ = {
        'relativeDateAdjustments': MemberSpec_('relativeDateAdjustments', 'BusinessDayAdjustments', 0),
    }
    subclass = None
    superclass = RelativeDateOffset
    def __init__(self, id=None, periodMultiplier=None, period=None, dayType=None, businessDayConvention=None, businessCentersReference=None, businessCenters=None, dateRelativeTo=None, adjustedDate=None, relativeDateAdjustments=None):
        self.original_tagname_ = None
        super(AdjustedRelativeDateOffset, self).__init__(id, periodMultiplier, period, dayType, businessDayConvention, businessCentersReference, businessCenters, dateRelativeTo, adjustedDate, )
        self.relativeDateAdjustments = relativeDateAdjustments
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdjustedRelativeDateOffset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdjustedRelativeDateOffset.subclass:
            return AdjustedRelativeDateOffset.subclass(*args_, **kwargs_)
        else:
            return AdjustedRelativeDateOffset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_relativeDateAdjustments(self): return self.relativeDateAdjustments
    def set_relativeDateAdjustments(self, relativeDateAdjustments): self.relativeDateAdjustments = relativeDateAdjustments
    def hasContent_(self):
        if (
            self.relativeDateAdjustments is not None or
            super(AdjustedRelativeDateOffset, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AdjustedRelativeDateOffset', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdjustedRelativeDateOffset')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AdjustedRelativeDateOffset', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AdjustedRelativeDateOffset'):
        super(AdjustedRelativeDateOffset, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AdjustedRelativeDateOffset')
    def exportChildren(self, outfile, level, namespace_='', name_='AdjustedRelativeDateOffset', fromsubclass_=False, pretty_print=True):
        super(AdjustedRelativeDateOffset, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.relativeDateAdjustments is not None:
            self.relativeDateAdjustments.export(outfile, level, namespace_, name_='relativeDateAdjustments', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AdjustedRelativeDateOffset, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'relativeDateAdjustments':
            obj_ = BusinessDayAdjustments.factory()
            obj_.build(child_)
            self.relativeDateAdjustments = obj_
            obj_.original_tagname_ = 'relativeDateAdjustments'
        super(AdjustedRelativeDateOffset, self).buildChildren(child_, node, nodeName_, True)
# end class AdjustedRelativeDateOffset


class Future(ExchangeTraded):
    """An exchange traded future contract."""
    member_data_items_ = {
        'multiplier': MemberSpec_('multiplier', 'xsd:positiveInteger', 0),
        'futureContractReference': MemberSpec_('futureContractReference', ['String', 'xsd:string'], 0),
        'maturity': MemberSpec_('maturity', 'xsd:date', 0),
        'contractYearMonth': MemberSpec_('contractYearMonth', 'xsd:gYearMonth', 0),
    }
    subclass = None
    superclass = ExchangeTraded
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, relatedExchangeId=None, optionsExchangeId=None, specifiedExchangeId=None, multiplier=None, futureContractReference=None, maturity=None, contractYearMonth=None):
        self.original_tagname_ = None
        super(Future, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, relatedExchangeId, optionsExchangeId, specifiedExchangeId, )
        self.multiplier = multiplier
        self.futureContractReference = futureContractReference
        self.validate_String(self.futureContractReference)
        if isinstance(maturity, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(maturity, '%Y-%m-%d').date()
        else:
            initvalue_ = maturity
        self.maturity = initvalue_
        self.contractYearMonth = contractYearMonth
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Future)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Future.subclass:
            return Future.subclass(*args_, **kwargs_)
        else:
            return Future(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_multiplier(self): return self.multiplier
    def set_multiplier(self, multiplier): self.multiplier = multiplier
    def get_futureContractReference(self): return self.futureContractReference
    def set_futureContractReference(self, futureContractReference): self.futureContractReference = futureContractReference
    def get_maturity(self): return self.maturity
    def set_maturity(self, maturity): self.maturity = maturity
    def get_contractYearMonth(self): return self.contractYearMonth
    def set_contractYearMonth(self, contractYearMonth): self.contractYearMonth = contractYearMonth
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.multiplier is not None or
            self.futureContractReference is not None or
            self.maturity is not None or
            self.contractYearMonth is not None or
            super(Future, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Future', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Future')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Future', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Future'):
        super(Future, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Future')
    def exportChildren(self, outfile, level, namespace_='', name_='Future', fromsubclass_=False, pretty_print=True):
        super(Future, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.multiplier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smultiplier>%s</%smultiplier>%s' % (namespace_, self.gds_format_integer(self.multiplier, input_name='multiplier'), namespace_, eol_))
        if self.futureContractReference is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfutureContractReference>%s</%sfutureContractReference>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.futureContractReference), input_name='futureContractReference')), namespace_, eol_))
        if self.maturity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaturity>%s</%smaturity>%s' % (namespace_, self.gds_format_date(self.maturity, input_name='maturity'), namespace_, eol_))
        if self.contractYearMonth is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scontractYearMonth>%s</%scontractYearMonth>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.contractYearMonth), input_name='contractYearMonth')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Future, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'multiplier':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'multiplier')
            self.multiplier = ival_
        elif nodeName_ == 'futureContractReference':
            futureContractReference_ = child_.text
            futureContractReference_ = self.gds_validate_string(futureContractReference_, node, 'futureContractReference')
            self.futureContractReference = futureContractReference_
            # validate type String
            self.validate_String(self.futureContractReference)
        elif nodeName_ == 'maturity':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.maturity = dval_
        elif nodeName_ == 'contractYearMonth':
            contractYearMonth_ = child_.text
            contractYearMonth_ = self.gds_validate_string(contractYearMonth_, node, 'contractYearMonth')
            self.contractYearMonth = contractYearMonth_
        super(Future, self).buildChildren(child_, node, nodeName_, True)
# end class Future


class ExchangeTradedContract(ExchangeTraded):
    """An exchange traded derivative contract."""
    member_data_items_ = {
        'multiplier': MemberSpec_('multiplier', 'xsd:positiveInteger', 0),
        'contractReference': MemberSpec_('contractReference', ['String', 'xsd:string'], 0),
        'expirationDate': MemberSpec_('expirationDate', 'AdjustableOrRelativeDate', 0),
    }
    subclass = None
    superclass = ExchangeTraded
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, relatedExchangeId=None, optionsExchangeId=None, specifiedExchangeId=None, multiplier=None, contractReference=None, expirationDate=None, extensiontype_=None):
        self.original_tagname_ = None
        super(ExchangeTradedContract, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, relatedExchangeId, optionsExchangeId, specifiedExchangeId, extensiontype_, )
        self.multiplier = multiplier
        self.contractReference = contractReference
        self.validate_String(self.contractReference)
        self.expirationDate = expirationDate
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExchangeTradedContract)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExchangeTradedContract.subclass:
            return ExchangeTradedContract.subclass(*args_, **kwargs_)
        else:
            return ExchangeTradedContract(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_multiplier(self): return self.multiplier
    def set_multiplier(self, multiplier): self.multiplier = multiplier
    def get_contractReference(self): return self.contractReference
    def set_contractReference(self, contractReference): self.contractReference = contractReference
    def get_expirationDate(self): return self.expirationDate
    def set_expirationDate(self, expirationDate): self.expirationDate = expirationDate
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.multiplier is not None or
            self.contractReference is not None or
            self.expirationDate is not None or
            super(ExchangeTradedContract, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExchangeTradedContract', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExchangeTradedContract')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExchangeTradedContract', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExchangeTradedContract'):
        super(ExchangeTradedContract, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ExchangeTradedContract')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='ExchangeTradedContract', fromsubclass_=False, pretty_print=True):
        super(ExchangeTradedContract, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.multiplier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smultiplier>%s</%smultiplier>%s' % (namespace_, self.gds_format_integer(self.multiplier, input_name='multiplier'), namespace_, eol_))
        if self.contractReference is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scontractReference>%s</%scontractReference>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.contractReference), input_name='contractReference')), namespace_, eol_))
        if self.expirationDate is not None:
            self.expirationDate.export(outfile, level, namespace_, name_='expirationDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ExchangeTradedContract, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'multiplier':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'multiplier')
            self.multiplier = ival_
        elif nodeName_ == 'contractReference':
            contractReference_ = child_.text
            contractReference_ = self.gds_validate_string(contractReference_, node, 'contractReference')
            self.contractReference = contractReference_
            # validate type String
            self.validate_String(self.contractReference)
        elif nodeName_ == 'expirationDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.expirationDate = obj_
            obj_.original_tagname_ = 'expirationDate'
        super(ExchangeTradedContract, self).buildChildren(child_, node, nodeName_, True)
# end class ExchangeTradedContract


class ExchangeTradedCalculatedPrice(ExchangeTraded):
    """Abstract base class for all exchange traded financial products with
    a price which is calculated from exchange traded constituents."""
    member_data_items_ = {
        'constituentExchangeId': MemberSpec_('constituentExchangeId', 'ExchangeId', 1),
    }
    subclass = None
    superclass = ExchangeTraded
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, relatedExchangeId=None, optionsExchangeId=None, specifiedExchangeId=None, constituentExchangeId=None, extensiontype_=None):
        self.original_tagname_ = None
        super(ExchangeTradedCalculatedPrice, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, relatedExchangeId, optionsExchangeId, specifiedExchangeId, extensiontype_, )
        if constituentExchangeId is None:
            self.constituentExchangeId = []
        else:
            self.constituentExchangeId = constituentExchangeId
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExchangeTradedCalculatedPrice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExchangeTradedCalculatedPrice.subclass:
            return ExchangeTradedCalculatedPrice.subclass(*args_, **kwargs_)
        else:
            return ExchangeTradedCalculatedPrice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_constituentExchangeId(self): return self.constituentExchangeId
    def set_constituentExchangeId(self, constituentExchangeId): self.constituentExchangeId = constituentExchangeId
    def add_constituentExchangeId(self, value): self.constituentExchangeId.append(value)
    def insert_constituentExchangeId_at(self, index, value): self.constituentExchangeId.insert(index, value)
    def replace_constituentExchangeId_at(self, index, value): self.constituentExchangeId[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.constituentExchangeId or
            super(ExchangeTradedCalculatedPrice, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExchangeTradedCalculatedPrice', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExchangeTradedCalculatedPrice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExchangeTradedCalculatedPrice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExchangeTradedCalculatedPrice'):
        super(ExchangeTradedCalculatedPrice, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ExchangeTradedCalculatedPrice')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='ExchangeTradedCalculatedPrice', fromsubclass_=False, pretty_print=True):
        super(ExchangeTradedCalculatedPrice, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for constituentExchangeId_ in self.constituentExchangeId:
            constituentExchangeId_.export(outfile, level, namespace_, name_='constituentExchangeId', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ExchangeTradedCalculatedPrice, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'constituentExchangeId':
            obj_ = ExchangeId.factory()
            obj_.build(child_)
            self.constituentExchangeId.append(obj_)
            obj_.original_tagname_ = 'constituentExchangeId'
        super(ExchangeTradedCalculatedPrice, self).buildChildren(child_, node, nodeName_, True)
# end class ExchangeTradedCalculatedPrice


class ConvertibleBond(Bond):
    member_data_items_ = {
        'underlyingEquity': MemberSpec_('underlyingEquity', 'EquityAsset', 0),
        'redemptionDate': MemberSpec_('redemptionDate', 'xsd:date', 0),
    }
    subclass = None
    superclass = Bond
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, issuerName=None, issuerPartyReference=None, seniority=None, couponType=None, couponRate=None, maturity=None, parValue=None, faceAmount=None, paymentFrequency=None, dayCountFraction=None, underlyingEquity=None, redemptionDate=None):
        self.original_tagname_ = None
        super(ConvertibleBond, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, issuerName, issuerPartyReference, seniority, couponType, couponRate, maturity, parValue, faceAmount, paymentFrequency, dayCountFraction, )
        self.underlyingEquity = underlyingEquity
        if isinstance(redemptionDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(redemptionDate, '%Y-%m-%d').date()
        else:
            initvalue_ = redemptionDate
        self.redemptionDate = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConvertibleBond)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConvertibleBond.subclass:
            return ConvertibleBond.subclass(*args_, **kwargs_)
        else:
            return ConvertibleBond(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_underlyingEquity(self): return self.underlyingEquity
    def set_underlyingEquity(self, underlyingEquity): self.underlyingEquity = underlyingEquity
    def get_redemptionDate(self): return self.redemptionDate
    def set_redemptionDate(self, redemptionDate): self.redemptionDate = redemptionDate
    def hasContent_(self):
        if (
            self.underlyingEquity is not None or
            self.redemptionDate is not None or
            super(ConvertibleBond, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ConvertibleBond', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConvertibleBond')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ConvertibleBond', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConvertibleBond'):
        super(ConvertibleBond, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ConvertibleBond')
    def exportChildren(self, outfile, level, namespace_='', name_='ConvertibleBond', fromsubclass_=False, pretty_print=True):
        super(ConvertibleBond, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.underlyingEquity is not None:
            self.underlyingEquity.export(outfile, level, namespace_, name_='underlyingEquity', pretty_print=pretty_print)
        if self.redemptionDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sredemptionDate>%s</%sredemptionDate>%s' % (namespace_, self.gds_format_date(self.redemptionDate, input_name='redemptionDate'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ConvertibleBond, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'underlyingEquity':
            obj_ = EquityAsset.factory()
            obj_.build(child_)
            self.underlyingEquity = obj_
            obj_.original_tagname_ = 'underlyingEquity'
        elif nodeName_ == 'redemptionDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.redemptionDate = dval_
        super(ConvertibleBond, self).buildChildren(child_, node, nodeName_, True)
# end class ConvertibleBond


class OptionBase(Option):
    """A type for defining the common features of options."""
    member_data_items_ = {
        'optionType': MemberSpec_('optionType', ['OptionTypeEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = Option
    def __init__(self, id=None, primaryAssetClass=None, secondaryAssetClass=None, productType=None, productId=None, assetClass=None, embeddedOptionType=None, buyerPartyReference=None, buyerAccountReference=None, sellerPartyReference=None, sellerAccountReference=None, optionType=None, extensiontype_=None):
        self.original_tagname_ = None
        super(OptionBase, self).__init__(id, primaryAssetClass, secondaryAssetClass, productType, productId, assetClass, embeddedOptionType, buyerPartyReference, buyerAccountReference, sellerPartyReference, sellerAccountReference, extensiontype_, )
        self.optionType = optionType
        self.validate_OptionTypeEnum(self.optionType)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OptionBase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OptionBase.subclass:
            return OptionBase.subclass(*args_, **kwargs_)
        else:
            return OptionBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_optionType(self): return self.optionType
    def set_optionType(self, optionType): self.optionType = optionType
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_OptionTypeEnum(self, value):
        # Validate type OptionTypeEnum, a restriction on Token.
        pass
    def hasContent_(self):
        if (
            self.optionType is not None or
            super(OptionBase, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OptionBase', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OptionBase')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OptionBase', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OptionBase'):
        super(OptionBase, self).exportAttributes(outfile, level, already_processed, namespace_, name_='OptionBase')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='OptionBase', fromsubclass_=False, pretty_print=True):
        super(OptionBase, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.optionType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soptionType>%s</%soptionType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.optionType), input_name='optionType')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(OptionBase, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'optionType':
            optionType_ = child_.text
            optionType_ = re_.sub(String_cleanup_pat_, " ", optionType_).strip()
            optionType_ = self.gds_validate_string(optionType_, node, 'optionType')
            self.optionType = optionType_
            # validate type OptionTypeEnum
            self.validate_OptionTypeEnum(self.optionType)
        super(OptionBase, self).buildChildren(child_, node, nodeName_, True)
# end class OptionBase


class RelativeDates(RelativeDateOffset):
    """A type describing a set of dates defined as relative to another set
    of dates."""
    member_data_items_ = {
        'periodSkip': MemberSpec_('periodSkip', 'xsd:positiveInteger', 0),
        'scheduleBounds': MemberSpec_('scheduleBounds', 'DateRange', 0),
    }
    subclass = None
    superclass = RelativeDateOffset
    def __init__(self, id=None, periodMultiplier=None, period=None, dayType=None, businessDayConvention=None, businessCentersReference=None, businessCenters=None, dateRelativeTo=None, adjustedDate=None, periodSkip=None, scheduleBounds=None):
        self.original_tagname_ = None
        super(RelativeDates, self).__init__(id, periodMultiplier, period, dayType, businessDayConvention, businessCentersReference, businessCenters, dateRelativeTo, adjustedDate, )
        self.periodSkip = periodSkip
        self.scheduleBounds = scheduleBounds
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RelativeDates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RelativeDates.subclass:
            return RelativeDates.subclass(*args_, **kwargs_)
        else:
            return RelativeDates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_periodSkip(self): return self.periodSkip
    def set_periodSkip(self, periodSkip): self.periodSkip = periodSkip
    def get_scheduleBounds(self): return self.scheduleBounds
    def set_scheduleBounds(self, scheduleBounds): self.scheduleBounds = scheduleBounds
    def hasContent_(self):
        if (
            self.periodSkip is not None or
            self.scheduleBounds is not None or
            super(RelativeDates, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RelativeDates', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RelativeDates')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RelativeDates', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RelativeDates'):
        super(RelativeDates, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RelativeDates')
    def exportChildren(self, outfile, level, namespace_='', name_='RelativeDates', fromsubclass_=False, pretty_print=True):
        super(RelativeDates, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.periodSkip is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%speriodSkip>%s</%speriodSkip>%s' % (namespace_, self.gds_format_integer(self.periodSkip, input_name='periodSkip'), namespace_, eol_))
        if self.scheduleBounds is not None:
            self.scheduleBounds.export(outfile, level, namespace_, name_='scheduleBounds', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RelativeDates, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'periodSkip':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'periodSkip')
            self.periodSkip = ival_
        elif nodeName_ == 'scheduleBounds':
            class_obj_ = self.get_class_obj_(child_, DateRange)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.scheduleBounds = obj_
            obj_.original_tagname_ = 'scheduleBounds'
        super(RelativeDates, self).buildChildren(child_, node, nodeName_, True)
# end class RelativeDates


class Index(ExchangeTradedCalculatedPrice):
    """A published index whose price depends on exchange traded
    constituents."""
    member_data_items_ = {
        'futureId': MemberSpec_('futureId', 'FutureId', 0),
    }
    subclass = None
    superclass = ExchangeTradedCalculatedPrice
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, relatedExchangeId=None, optionsExchangeId=None, specifiedExchangeId=None, constituentExchangeId=None, futureId=None):
        self.original_tagname_ = None
        super(Index, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, relatedExchangeId, optionsExchangeId, specifiedExchangeId, constituentExchangeId, )
        self.futureId = futureId
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Index)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Index.subclass:
            return Index.subclass(*args_, **kwargs_)
        else:
            return Index(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_futureId(self): return self.futureId
    def set_futureId(self, futureId): self.futureId = futureId
    def hasContent_(self):
        if (
            self.futureId is not None or
            super(Index, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Index', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Index')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Index', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Index'):
        super(Index, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Index')
    def exportChildren(self, outfile, level, namespace_='', name_='Index', fromsubclass_=False, pretty_print=True):
        super(Index, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.futureId is not None:
            self.futureId.export(outfile, level, namespace_, name_='futureId', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Index, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'futureId':
            obj_ = FutureId.factory()
            obj_.build(child_)
            self.futureId = obj_
            obj_.original_tagname_ = 'futureId'
        super(Index, self).buildChildren(child_, node, nodeName_, True)
# end class Index


class ExchangeTradedOption(ExchangeTradedContract):
    """An exchange traded option."""
    member_data_items_ = {
        'strike': MemberSpec_('strike', 'xsd:decimal', 0),
        'optionType': MemberSpec_('optionType', ['PutCallEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = ExchangeTradedContract
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, relatedExchangeId=None, optionsExchangeId=None, specifiedExchangeId=None, multiplier=None, contractReference=None, expirationDate=None, strike=None, optionType=None):
        self.original_tagname_ = None
        super(ExchangeTradedOption, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, relatedExchangeId, optionsExchangeId, specifiedExchangeId, multiplier, contractReference, expirationDate, )
        self.strike = strike
        self.optionType = optionType
        self.validate_PutCallEnum(self.optionType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExchangeTradedOption)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExchangeTradedOption.subclass:
            return ExchangeTradedOption.subclass(*args_, **kwargs_)
        else:
            return ExchangeTradedOption(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_strike(self): return self.strike
    def set_strike(self, strike): self.strike = strike
    def get_optionType(self): return self.optionType
    def set_optionType(self, optionType): self.optionType = optionType
    def validate_PutCallEnum(self, value):
        # Validate type PutCallEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Put', 'Call']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PutCallEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on PutCallEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.strike is not None or
            self.optionType is not None or
            super(ExchangeTradedOption, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExchangeTradedOption', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExchangeTradedOption')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExchangeTradedOption', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExchangeTradedOption'):
        super(ExchangeTradedOption, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ExchangeTradedOption')
    def exportChildren(self, outfile, level, namespace_='', name_='ExchangeTradedOption', fromsubclass_=False, pretty_print=True):
        super(ExchangeTradedOption, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.strike is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstrike>%s</%sstrike>%s' % (namespace_, self.gds_format_float(self.strike, input_name='strike'), namespace_, eol_))
        if self.optionType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soptionType>%s</%soptionType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.optionType), input_name='optionType')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ExchangeTradedOption, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'strike':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'strike')
            self.strike = fval_
        elif nodeName_ == 'optionType':
            optionType_ = child_.text
            optionType_ = re_.sub(String_cleanup_pat_, " ", optionType_).strip()
            optionType_ = self.gds_validate_string(optionType_, node, 'optionType')
            self.optionType = optionType_
            # validate type PutCallEnum
            self.validate_PutCallEnum(self.optionType)
        super(ExchangeTradedOption, self).buildChildren(child_, node, nodeName_, True)
# end class ExchangeTradedOption


class ExchangeTradedFund(ExchangeTradedCalculatedPrice):
    """An exchange traded fund whose price depends on exchange traded
    constituents."""
    member_data_items_ = {
        'fundManager': MemberSpec_('fundManager', ['String', 'xsd:string'], 0),
    }
    subclass = None
    superclass = ExchangeTradedCalculatedPrice
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, relatedExchangeId=None, optionsExchangeId=None, specifiedExchangeId=None, constituentExchangeId=None, fundManager=None):
        self.original_tagname_ = None
        super(ExchangeTradedFund, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, relatedExchangeId, optionsExchangeId, specifiedExchangeId, constituentExchangeId, )
        self.fundManager = fundManager
        self.validate_String(self.fundManager)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExchangeTradedFund)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExchangeTradedFund.subclass:
            return ExchangeTradedFund.subclass(*args_, **kwargs_)
        else:
            return ExchangeTradedFund(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fundManager(self): return self.fundManager
    def set_fundManager(self, fundManager): self.fundManager = fundManager
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.fundManager is not None or
            super(ExchangeTradedFund, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExchangeTradedFund', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExchangeTradedFund')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExchangeTradedFund', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExchangeTradedFund'):
        super(ExchangeTradedFund, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ExchangeTradedFund')
    def exportChildren(self, outfile, level, namespace_='', name_='ExchangeTradedFund', fromsubclass_=False, pretty_print=True):
        super(ExchangeTradedFund, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.fundManager is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfundManager>%s</%sfundManager>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.fundManager), input_name='fundManager')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ExchangeTradedFund, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fundManager':
            fundManager_ = child_.text
            fundManager_ = self.gds_validate_string(fundManager_, node, 'fundManager')
            self.fundManager = fundManager_
            # validate type String
            self.validate_String(self.fundManager)
        super(ExchangeTradedFund, self).buildChildren(child_, node, nodeName_, True)
# end class ExchangeTradedFund


class OptionBaseExtended(OptionBase):
    """Base type for options starting with the 4-3 release, until we
    refactor the schema as part of the 5-0 release series.A choice
    between an explicit representation of the notional amount, or a
    reference to a notional amount defined elsewhere in this
    document."""
    member_data_items_ = {
        'premium': MemberSpec_('premium', 'Premium', 0),
        'exercise': MemberSpec_('exercise', 'Exercise', 0),
        'exerciseProcedure': MemberSpec_('exerciseProcedure', 'ExerciseProcedure', 0),
        'feature': MemberSpec_('feature', 'OptionFeature', 0),
        'notionalReference': MemberSpec_('notionalReference', 'NotionalAmountReference', 0),
        'notionalAmount': MemberSpec_('notionalAmount', 'Money', 0),
        'optionEntitlement': MemberSpec_('optionEntitlement', ['PositiveDecimal', 'xsd:decimal'], 0),
        'entitlementCurrency': MemberSpec_('entitlementCurrency', 'Currency', 0),
        'numberOfOptions': MemberSpec_('numberOfOptions', ['PositiveDecimal', 'xsd:decimal'], 0),
        'settlementType': MemberSpec_('settlementType', ['SettlementTypeEnum', 'Token', 'xsd:token'], 0),
        'settlementDate': MemberSpec_('settlementDate', 'AdjustableOrRelativeDate', 0),
        'settlementAmount': MemberSpec_('settlementAmount', 'Money', 0),
        'settlementCurrency': MemberSpec_('settlementCurrency', 'Currency', 0),
    }
    subclass = None
    superclass = OptionBase
    def __init__(self, id=None, primaryAssetClass=None, secondaryAssetClass=None, productType=None, productId=None, assetClass=None, embeddedOptionType=None, buyerPartyReference=None, buyerAccountReference=None, sellerPartyReference=None, sellerAccountReference=None, optionType=None, premium=None, exercise=None, exerciseProcedure=None, feature=None, notionalReference=None, notionalAmount=None, optionEntitlement=None, entitlementCurrency=None, numberOfOptions=None, settlementType=None, settlementDate=None, settlementAmount=None, settlementCurrency=None):
        self.original_tagname_ = None
        super(OptionBaseExtended, self).__init__(id, primaryAssetClass, secondaryAssetClass, productType, productId, assetClass, embeddedOptionType, buyerPartyReference, buyerAccountReference, sellerPartyReference, sellerAccountReference, optionType, )
        self.premium = premium
        self.exercise = exercise
        self.exerciseProcedure = exerciseProcedure
        self.feature = feature
        self.notionalReference = notionalReference
        self.notionalAmount = notionalAmount
        self.optionEntitlement = optionEntitlement
        self.validate_PositiveDecimal(self.optionEntitlement)
        self.entitlementCurrency = entitlementCurrency
        self.numberOfOptions = numberOfOptions
        self.validate_PositiveDecimal(self.numberOfOptions)
        self.settlementType = settlementType
        self.validate_SettlementTypeEnum(self.settlementType)
        self.settlementDate = settlementDate
        self.settlementAmount = settlementAmount
        self.settlementCurrency = settlementCurrency
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OptionBaseExtended)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OptionBaseExtended.subclass:
            return OptionBaseExtended.subclass(*args_, **kwargs_)
        else:
            return OptionBaseExtended(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_premium(self): return self.premium
    def set_premium(self, premium): self.premium = premium
    def get_exercise(self): return self.exercise
    def set_exercise(self, exercise): self.exercise = exercise
    def get_exerciseProcedure(self): return self.exerciseProcedure
    def set_exerciseProcedure(self, exerciseProcedure): self.exerciseProcedure = exerciseProcedure
    def get_feature(self): return self.feature
    def set_feature(self, feature): self.feature = feature
    def get_notionalReference(self): return self.notionalReference
    def set_notionalReference(self, notionalReference): self.notionalReference = notionalReference
    def get_notionalAmount(self): return self.notionalAmount
    def set_notionalAmount(self, notionalAmount): self.notionalAmount = notionalAmount
    def get_optionEntitlement(self): return self.optionEntitlement
    def set_optionEntitlement(self, optionEntitlement): self.optionEntitlement = optionEntitlement
    def get_entitlementCurrency(self): return self.entitlementCurrency
    def set_entitlementCurrency(self, entitlementCurrency): self.entitlementCurrency = entitlementCurrency
    def get_numberOfOptions(self): return self.numberOfOptions
    def set_numberOfOptions(self, numberOfOptions): self.numberOfOptions = numberOfOptions
    def get_settlementType(self): return self.settlementType
    def set_settlementType(self, settlementType): self.settlementType = settlementType
    def get_settlementDate(self): return self.settlementDate
    def set_settlementDate(self, settlementDate): self.settlementDate = settlementDate
    def get_settlementAmount(self): return self.settlementAmount
    def set_settlementAmount(self, settlementAmount): self.settlementAmount = settlementAmount
    def get_settlementCurrency(self): return self.settlementCurrency
    def set_settlementCurrency(self, settlementCurrency): self.settlementCurrency = settlementCurrency
    def validate_PositiveDecimal(self, value):
        # Validate type PositiveDecimal, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value <= 0:
                warnings_.warn('Value "%(value)s" does not match xsd minExclusive restriction on PositiveDecimal' % {"value" : value} )
    def validate_SettlementTypeEnum(self, value):
        # Validate type SettlementTypeEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Cash', 'Physical', 'Election', 'CashOrPhysical']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SettlementTypeEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on SettlementTypeEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.premium is not None or
            self.exercise is not None or
            self.exerciseProcedure is not None or
            self.feature is not None or
            self.notionalReference is not None or
            self.notionalAmount is not None or
            self.optionEntitlement is not None or
            self.entitlementCurrency is not None or
            self.numberOfOptions is not None or
            self.settlementType is not None or
            self.settlementDate is not None or
            self.settlementAmount is not None or
            self.settlementCurrency is not None or
            super(OptionBaseExtended, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OptionBaseExtended', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OptionBaseExtended')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OptionBaseExtended', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OptionBaseExtended'):
        super(OptionBaseExtended, self).exportAttributes(outfile, level, already_processed, namespace_, name_='OptionBaseExtended')
    def exportChildren(self, outfile, level, namespace_='', name_='OptionBaseExtended', fromsubclass_=False, pretty_print=True):
        super(OptionBaseExtended, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.premium is not None:
            self.premium.export(outfile, level, namespace_, name_='premium', pretty_print=pretty_print)
        if self.exercise is not None:
            self.exercise.export(outfile, level, namespace_, name_='exercise', pretty_print=pretty_print)
        if self.exerciseProcedure is not None:
            self.exerciseProcedure.export(outfile, level, namespace_, name_='exerciseProcedure', pretty_print=pretty_print)
        if self.feature is not None:
            self.feature.export(outfile, level, namespace_, name_='feature', pretty_print=pretty_print)
        if self.notionalReference is not None:
            self.notionalReference.export(outfile, level, namespace_, name_='notionalReference', pretty_print=pretty_print)
        if self.notionalAmount is not None:
            self.notionalAmount.export(outfile, level, namespace_, name_='notionalAmount', pretty_print=pretty_print)
        if self.optionEntitlement is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soptionEntitlement>%s</%soptionEntitlement>%s' % (namespace_, self.gds_format_float(self.optionEntitlement, input_name='optionEntitlement'), namespace_, eol_))
        if self.entitlementCurrency is not None:
            self.entitlementCurrency.export(outfile, level, namespace_, name_='entitlementCurrency', pretty_print=pretty_print)
        if self.numberOfOptions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumberOfOptions>%s</%snumberOfOptions>%s' % (namespace_, self.gds_format_float(self.numberOfOptions, input_name='numberOfOptions'), namespace_, eol_))
        if self.settlementType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssettlementType>%s</%ssettlementType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.settlementType), input_name='settlementType')), namespace_, eol_))
        if self.settlementDate is not None:
            self.settlementDate.export(outfile, level, namespace_, name_='settlementDate', pretty_print=pretty_print)
        if self.settlementAmount is not None:
            self.settlementAmount.export(outfile, level, namespace_, name_='settlementAmount', pretty_print=pretty_print)
        if self.settlementCurrency is not None:
            self.settlementCurrency.export(outfile, level, namespace_, name_='settlementCurrency', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(OptionBaseExtended, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'premium':
            obj_ = Premium.factory()
            obj_.build(child_)
            self.premium = obj_
            obj_.original_tagname_ = 'premium'
        elif nodeName_ == 'exercise':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <exercise> element')
            self.exercise = obj_
            obj_.original_tagname_ = 'exercise'
        elif nodeName_ == 'americanExercise':
            obj_ = AmericanExercise.factory()
            obj_.build(child_)
            self.exercise = obj_
            obj_.original_tagname_ = 'americanExercise'
        elif nodeName_ == 'bermudaExercise':
            obj_ = BermudaExercise.factory()
            obj_.build(child_)
            self.exercise = obj_
            obj_.original_tagname_ = 'bermudaExercise'
        elif nodeName_ == 'europeanExercise':
            obj_ = EuropeanExercise.factory()
            obj_.build(child_)
            self.exercise = obj_
            obj_.original_tagname_ = 'europeanExercise'
        elif nodeName_ == 'exerciseProcedure':
            obj_ = ExerciseProcedure.factory()
            obj_.build(child_)
            self.exerciseProcedure = obj_
            obj_.original_tagname_ = 'exerciseProcedure'
        elif nodeName_ == 'feature':
            obj_ = OptionFeature.factory()
            obj_.build(child_)
            self.feature = obj_
            obj_.original_tagname_ = 'feature'
        elif nodeName_ == 'notionalReference':
            obj_ = NotionalAmountReference.factory()
            obj_.build(child_)
            self.notionalReference = obj_
            obj_.original_tagname_ = 'notionalReference'
        elif nodeName_ == 'notionalAmount':
            obj_ = Money.factory()
            obj_.build(child_)
            self.notionalAmount = obj_
            obj_.original_tagname_ = 'notionalAmount'
        elif nodeName_ == 'optionEntitlement':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'optionEntitlement')
            self.optionEntitlement = fval_
            # validate type PositiveDecimal
            self.validate_PositiveDecimal(self.optionEntitlement)
        elif nodeName_ == 'entitlementCurrency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.entitlementCurrency = obj_
            obj_.original_tagname_ = 'entitlementCurrency'
        elif nodeName_ == 'numberOfOptions':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'numberOfOptions')
            self.numberOfOptions = fval_
            # validate type PositiveDecimal
            self.validate_PositiveDecimal(self.numberOfOptions)
        elif nodeName_ == 'settlementType':
            settlementType_ = child_.text
            settlementType_ = re_.sub(String_cleanup_pat_, " ", settlementType_).strip()
            settlementType_ = self.gds_validate_string(settlementType_, node, 'settlementType')
            self.settlementType = settlementType_
            # validate type SettlementTypeEnum
            self.validate_SettlementTypeEnum(self.settlementType)
        elif nodeName_ == 'settlementDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.settlementDate = obj_
            obj_.original_tagname_ = 'settlementDate'
        elif nodeName_ == 'settlementAmount':
            obj_ = Money.factory()
            obj_.build(child_)
            self.settlementAmount = obj_
            obj_.original_tagname_ = 'settlementAmount'
        elif nodeName_ == 'settlementCurrency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.settlementCurrency = obj_
            obj_.original_tagname_ = 'settlementCurrency'
        super(OptionBaseExtended, self).buildChildren(child_, node, nodeName_, True)
# end class OptionBaseExtended


GDSClassesMapping = {
    'accountBeneficiary': PartyReference,
    'accountId': AccountId,
    'accountName': AccountName,
    'accountReference': AccountReference,
    'accountType': AccountType,
    'accruedInterest': Money,
    'address': Address,
    'adjustableDate': AdjustableDate,
    'adjustableDates': AdjustableDates,
    'adjustedDate': IdentifiedDate,
    'agreement': GenericAgreement,
    'allocationAccountReference': AccountReference,
    'allocationPartyReference': PartyReference,
    'americanExercise': AmericanExercise,
    'amount': Money,
    'amountRelativeTo': AmountReference,
    'asian': Asian,
    'assetClass': AssetClass,
    'attachment': Resource,
    'automaticExercise': Empty,
    'averageDailyTradingVolume': AverageDailyTradingVolumeLimit,
    'averagingDateTimes': DateTimeList,
    'averagingObservation': WeightedAveragingObservation,
    'averagingObservations': AveragingObservationList,
    'averagingPeriodFrequency': CalculationPeriodFrequency,
    'averagingPeriodIn': AveragingPeriod,
    'averagingPeriodOut': AveragingPeriod,
    'barrier': Barrier,
    'barrierCap': TriggerEvent,
    'barrierFloor': TriggerEvent,
    'basket': Basket,
    'basketAmount': Money,
    'basketConstituent': BasketConstituent,
    'basketCurrency': Currency,
    'basketId': BasketId,
    'basketName': BasketName,
    'beneficiary': Routing,
    'beneficiaryBank': Routing,
    'beneficiaryPartyReference': PartyReference,
    'bermudaExercise': BermudaExercise,
    'bermudaExerciseDates': AdjustableOrRelativeDates,
    'bond': Bond,
    'borrower': LegalEntity,
    'borrowerReference': LegalEntityReference,
    'brokerConfirmation': BrokerConfirmation,
    'brokerConfirmationType': BrokerConfirmationType,
    'businessCenter': BusinessCenter,
    'businessCenters': BusinessCenters,
    'businessCentersReference': BusinessCentersReference,
    'businessUnit': BusinessUnit,
    'businessUnitId': Unit,
    'businessUnitReference': BusinessUnitReference,
    'buyer': IdentifiedPayerReceiver,
    'buyerAccountReference': AccountReference,
    'buyerPartyReference': PartyReference,
    'calculationAgentPartyReference': PartyReference,
    'calculationEndDate': AdjustableOrRelativeDate,
    'calculationPeriodDatesAdjustments': BusinessDayAdjustments,
    'calculationPeriodFrequency': CalculationPeriodFrequency,
    'calculationStartDate': AdjustableOrRelativeDate,
    'calendarSpread': CalendarSpread,
    'capRateSchedule': StrikeSchedule,
    'cash': Cash,
    'cashSettlementReferenceBanks': CashSettlementReferenceBanks,
    'cashflowAmount': Money,
    'cashflowId': CashflowId,
    'cashflowType': CashflowType,
    'classification': IndustryClassification,
    'clearanceSystem': ClearanceSystem,
    'collateralValueAllocation': CollateralValueAllocation,
    'commencementDate': AdjustableOrRelativeDate,
    'commission': Commission,
    'commodity': Commodity,
    'commodityBase': CommodityBase,
    'commodityDetails': CommodityDetails,
    'composite': Composite,
    'constituentExchangeId': ExchangeId,
    'constituentWeight': ConstituentWeight,
    'contactInfo': ContactInformation,
    'contractualDefinitions': ContractualDefinitions,
    'contractualMatrix': ContractualMatrix,
    'contractualTermsSupplement': ContractualTermsSupplement,
    'convertibleBond': ConvertibleBond,
    'correspondentInformation': CorrespondentInformation,
    'correspondentPartyReference': PartyReference,
    'country': CountryCode,
    'couponPayment': PendingPayment,
    'couponType': CouponType,
    'creditEntityReference': LegalEntityReference,
    'creditEventNotice': CreditEventNotice,
    'creditEvents': CreditEvents,
    'creditEventsReference': CreditEventsReference,
    'creditRating': CreditRating,
    'creditSupportAgreement': CreditSupportAgreement,
    'crossCurrency': Composite,
    'currency': Currency,
    'currency1': Currency,
    'currency2': Currency,
    'currencyType': ReportingCurrencyType,
    'curveInstrument': Asset,
    'dateAdjustments': BusinessDayAdjustments,
    'dateAdjustmentsReference': BusinessDayAdjustmentsReference,
    'dateOffset': DateOffset,
    'dateRelativeTo': DateReference,
    'dayCountFraction': DayCountFraction,
    'defaultRequirement': Money,
    'definition': ProductReference,
    'deliveryDate': AdjustableDate,
    'deliveryDateExpirationConvention': Offset,
    'deliveryDateRollConvention': Offset,
    'deliveryNearby': DeliveryNearby,
    'deposit': Deposit,
    'depositoryPartyReference': PartyReference,
    'determinationMethod': DeterminationMethod,
    'dividendPayment': PendingPayment,
    'dividendPayout': DividendPayout,
    'documentation': PartyRelationshipDocumentation,
    'earliestExerciseTime': BusinessCenterTime,
    'effectiveDate': IdentifiedDate,
    'embeddedOptionType': EmbeddedOptionType,
    'endTerm': Period,
    'entitlementCurrency': Currency,
    'entityId': EntityId,
    'entityName': EntityName,
    'equity': EquityAsset,
    'europeanExercise': EuropeanExercise,
    'exchangeId': ExchangeId,
    'exchangeTradedFund': ExchangeTradedFund,
    'exercise': Exercise,
    'exerciseFee': ExerciseFee,
    'exerciseFeeSchedule': ExerciseFeeSchedule,
    'exerciseNotice': ExerciseNotice,
    'exerciseNoticePartyReference': PartyReference,
    'exerciseProcedure': ExerciseProcedure,
    'expirationDate': AdjustableOrRelativeDate,
    'expirationDateTwo': AdjustableOrRelativeDate,
    'expirationTime': BusinessCenterTime,
    'facilityType': FacilityType,
    'failureToPay': FailureToPay,
    'feature': OptionFeature,
    'featurePayment': FeaturePayment,
    'featurePaymentDate': AdjustableOrRelativeDate,
    'feeAmountSchedule': AmountSchedule,
    'feePaymentDate': RelativeDateOffset,
    'feeRateSchedule': Schedule,
    'finalRateRounding': Rounding,
    'fixing': FxFixing,
    'fixingDate': AdjustableDate,
    'fixingTime': BusinessCenterTime,
    'floatingRate': StubFloatingRate,
    'floatingRateCalculation': FloatingRateCalculation,
    'floatingRateIndex': FloatingRateIndex,
    'floatingRateMultiplierSchedule': Schedule,
    'floorRateSchedule': StrikeSchedule,
    'formula': Formula,
    'formulaComponent': FormulaComponent,
    'future': Future,
    'futureId': FutureId,
    'fx': FxRateAsset,
    'fxConversion': FxConversion,
    'fxFeature': FxFeature,
    'fxRate': FxRate,
    'fxSpotRateSource': FxSpotRateSource,
    'governingLaw': GoverningLaw,
    'gracePeriod': Offset,
    'gracePeriodExtension': GracePeriodExtension,
    'grossCashflow': GrossCashflow,
    'grossPrice': ActualPrice,
    'groupType': PartyGroupType,
    'identifier': CreditSupportAgreementIdentifier,
    'independentAmount': IndependentAmount,
    'index': Index,
    'indexTenor': Period,
    'informationSource': InformationSource,
    'instrumentId': InstrumentId,
    'insurer': LegalEntity,
    'insurerReference': LegalEntityReference,
    'intermediaryInformation': IntermediaryInformation,
    'intermediaryPartyReference': PartyReference,
    'issuer': IssuerId,
    'issuerPartyReference': PartyReference,
    'jurisdiction': GoverningLaw,
    'knock': Knock,
    'knockIn': TriggerEvent,
    'knockOut': TriggerEvent,
    'language': Language,
    'latestExerciseTime': BusinessCenterTime,
    'latestExerciseTimeDetermination': DeterminationMethod,
    'legId': LegId,
    'legIdentifier': LegIdentifier,
    'length': ResourceLength,
    'lien': Lien,
    'loan': Loan,
    'location': TimezoneLocation,
    'manualExercise': Empty,
    'marketDisruption': MarketDisruption,
    'masterAgreement': MasterAgreement,
    'masterAgreementId': MasterAgreementId,
    'masterAgreementType': MasterAgreementType,
    'masterAgreementVersion': MasterAgreementVersion,
    'masterConfirmation': MasterConfirmation,
    'masterConfirmationAnnexType': MasterConfirmationAnnexType,
    'masterConfirmationType': MasterConfirmationType,
    'math': Math,
    'matrixTerm': MatrixTerm,
    'matrixType': MatrixType,
    'measureType': AssetMeasureType,
    'mimeType': MimeType,
    'mortgage': Mortgage,
    'multipleExercise': MultipleExercise,
    'mutualFund': MutualFund,
    'netPrice': ActualPrice,
    'nonstandardSettlementRate': FxInformationSource,
    'notifyingParty': NotifyingParty,
    'notionalAmount': PositiveMoney,
    'notionalReference': NotionalReference,
    'offset': Offset,
    'option': ExchangeTradedOption,
    'optionsExchangeId': ExchangeId,
    'organizationType': OrganizationType,
    'partialExercise': PartialExercise,
    'partyId': PartyId,
    'partyName': PartyName,
    'partyReference': PartyReference,
    'partyTradeIdentifierReference': PartyTradeIdentifierReference,
    'passThrough': PassThrough,
    'passThroughItem': PassThroughItem,
    'payerAccountReference': AccountReference,
    'payerPartyReference': PartyReference,
    'paymentAmount': NonNegativeMoney,
    'paymentDate': AdjustableOrRelativeDate,
    'paymentDetail': PaymentDetail,
    'paymentFrequency': Period,
    'paymentReference': PaymentReference,
    'paymentRequirement': Money,
    'paymentRule': PaymentRule,
    'paymentType': PaymentType,
    'periodicDates': PeriodicDates,
    'person': Person,
    'personId': PersonId,
    'personReference': PersonReference,
    'pool': AssetPool,
    'predeterminedClearingOrganizationPartyReference': PartyReference,
    'premium': Premium,
    'presentValueAmount': Money,
    'pricePerOption': Money,
    'pricingModel': PricingModel,
    'primaryAssetClass': AssetClass,
    'primaryRateSource': InformationSource,
    'product': Product,
    'productId': ProductId,
    'productType': ProductType,
    'publication': CommodityInformationSource,
    'publiclyAvailableInformation': PubliclyAvailableInformation,
    'quanto': Quanto,
    'quotationCharacteristics': QuotationCharacteristics,
    'quoteUnits': PriceQuoteUnits,
    'quotedCurrencyPair': QuotedCurrencyPair,
    'rateIndex': RateIndex,
    'rateReference': RateReference,
    'rateSource': InformationProvider,
    'rateSourceFixing': FxRateSourceFixing,
    'rateSourcePage': RateSourcePage,
    'receiverAccountReference': AccountReference,
    'receiverPartyReference': PartyReference,
    'referenceBank': ReferenceBank,
    'referenceBankId': ReferenceBankId,
    'referenceCurrency': Currency,
    'referenceEntity': LegalEntity,
    'region': Region,
    'relatedExchangeId': ExchangeId,
    'relatedParty': PartyRelationship,
    'relativeDate': RelativeDateOffset,
    'relativeDateAdjustments': BusinessDayAdjustments,
    'relativeDateSequence': RelativeDateSequence,
    'relativeDates': RelativeDates,
    'relevantUnderlyingDate': AdjustableOrRelativeDates,
    'resourceId': ResourceId,
    'resourceType': ResourceType,
    'restructuring': Restructuring,
    'restructuringType': RestructuringType,
    'role': PersonRole,
    'routingAddress': Address,
    'routingExplicitDetails': RoutingExplicitDetails,
    'routingId': RoutingId,
    'routingIds': RoutingIds,
    'routingIdsAndExplicitDetails': RoutingIdsAndExplicitDetails,
    'schedule': AveragingSchedule,
    'scheduleBounds': DateRange,
    'secondaryAssetClass': AssetClass,
    'secondaryRateSource': InformationSource,
    'sector': MortgageSector,
    'seller': IdentifiedPayerReceiver,
    'sellerAccountReference': AccountReference,
    'sellerPartyReference': PartyReference,
    'seniority': CreditSeniority,
    'servicingParty': PartyReference,
    'settlementAmount': Money,
    'settlementCurrency': Currency,
    'settlementDate': AdjustableDate,
    'settlementInformation': SettlementInformation,
    'settlementInstruction': SettlementInstruction,
    'settlementMethod': SettlementMethod,
    'settlementRateOption': SettlementRateOption,
    'settlementRateSource': FxSettlementRateSource,
    'simpleCreditDefaultSwap': SimpleCreditDefaultSwap,
    'simpleFra': SimpleFra,
    'simpleIrSwap': SimpleIRSwap,
    'singleUnderlyer': SingleUnderlyer,
    'specifiedExchangeId': ExchangeId,
    'splitSettlement': SplitSettlement,
    'splitSettlementAmount': Money,
    'spreadSchedule': SpreadSchedule,
    'startTerm': Period,
    'step': Step,
    'strategyFeature': StrategyFeature,
    'streetAddress': StreetAddress,
    'strikeSpread': StrikeSpread,
    'stubAmount': Money,
    'stubEndDate': AdjustableOrRelativeDate,
    'stubStartDate': AdjustableOrRelativeDate,
    'telephone': TelephoneNumber,
    'term': Period,
    'terminationDate': AdjustableOrRelativeDate,
    'time': PrevailingTime,
    'timing': QuoteTiming,
    'tradeId': TradeId,
    'tranche': UnderlyingAssetTranche,
    'trigger': Trigger,
    'triggerDates': DateList,
    'type': SpreadScheduleType,
    'unadjustedDate': IdentifiedDate,
    'underlyerCollateral': Collateral,
    'underlyerFinancing': UnderlyerInterestLeg,
    'underlyerLoanRate': UnderlyerLoanRate,
    'underlyerNotional': Money,
    'underlyerPrice': Price,
    'underlyerReference': AssetReference,
    'underlyerSpread': SpreadScheduleReference,
    'underlyingAsset': Asset,
    'underlyingEquity': EquityAsset,
    'unit': QuantityUnit,
    'upperStrike': OptionStrike,
    'value': Money,
    'version': AgreementVersion,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Asian'
        rootClass = Asian
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Asian'
        rootClass = Asian
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from StringIO import StringIO
    parser = None
    doc = parsexml_(StringIO(inString), parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Asian'
        rootClass = Asian
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Asian'
        rootClass = Asian
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from fpml_option_sharedlib import *\n\n')
        sys.stdout.write('import fpml_option_sharedlib as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "Account",
    "AccountId",
    "AccountName",
    "AccountReference",
    "AccountType",
    "ActionType",
    "ActualPrice",
    "Address",
    "AdjustableDate",
    "AdjustableDate2",
    "AdjustableDates",
    "AdjustableDatesOrRelativeDateOffset",
    "AdjustableOrAdjustedDate",
    "AdjustableOrRelativeDate",
    "AdjustableOrRelativeDates",
    "AdjustableRelativeOrPeriodicDates",
    "AdjustableRelativeOrPeriodicDates2",
    "AdjustedRelativeDateOffset",
    "AgreementType",
    "AgreementVersion",
    "AmericanExercise",
    "AmountReference",
    "AmountSchedule",
    "AnyAssetReference",
    "Asian",
    "Asset",
    "AssetClass",
    "AssetMeasureType",
    "AssetPool",
    "AssetReference",
    "AutomaticExercise",
    "AverageDailyTradingVolumeLimit",
    "AveragingObservationList",
    "AveragingPeriod",
    "AveragingSchedule",
    "Barrier",
    "BasicQuotation",
    "Basket",
    "BasketConstituent",
    "BasketId",
    "BasketName",
    "Beneficiary",
    "BermudaExercise",
    "Bond",
    "BrokerConfirmation",
    "BrokerConfirmationType",
    "BusinessCenter",
    "BusinessCenterTime",
    "BusinessCenters",
    "BusinessCentersReference",
    "BusinessDateRange",
    "BusinessDayAdjustments",
    "BusinessDayAdjustmentsReference",
    "BusinessUnit",
    "BusinessUnitReference",
    "BusinessUnitRole",
    "CalculationAgent",
    "CalculationPeriodFrequency",
    "CalendarSpread",
    "Cash",
    "CashSettlementReferenceBanks",
    "CashflowId",
    "CashflowNotional",
    "CashflowType",
    "ClassifiablePayment",
    "ClearanceSystem",
    "Collateral",
    "CollateralValueAllocation",
    "Commission",
    "Commodity",
    "CommodityBase",
    "CommodityBusinessCalendar",
    "CommodityDetails",
    "CommodityInformationProvider",
    "CommodityInformationSource",
    "Composite",
    "ConstituentWeight",
    "ContactInformation",
    "ContractualDefinitions",
    "ContractualMatrix",
    "ContractualSupplement",
    "ContractualTermsSupplement",
    "ConvertibleBond",
    "CorrespondentInformation",
    "CountryCode",
    "CouponType",
    "CreditEventNotice",
    "CreditEvents",
    "CreditEventsReference",
    "CreditRating",
    "CreditSeniority",
    "CreditSupportAgreement",
    "CreditSupportAgreementIdentifier",
    "CreditSupportAgreementType",
    "Currency",
    "DateList",
    "DateOffset",
    "DateRange",
    "DateReference",
    "DateTimeList",
    "DayCountFraction",
    "DeliveryNearby",
    "Deposit",
    "DeterminationMethod",
    "DeterminationMethodReference",
    "DirectionalLeg",
    "DividendPayout",
    "Documentation",
    "EmbeddedOptionType",
    "Empty",
    "EntityId",
    "EntityName",
    "EquityAsset",
    "EuropeanExercise",
    "ExchangeId",
    "ExchangeTraded",
    "ExchangeTradedCalculatedPrice",
    "ExchangeTradedContract",
    "ExchangeTradedFund",
    "ExchangeTradedOption",
    "Exercise",
    "ExerciseFee",
    "ExerciseFeeSchedule",
    "ExerciseNotice",
    "ExerciseProcedure",
    "ExerciseProcedureOption",
    "FacilityType",
    "FailureToPay",
    "FeaturePayment",
    "FloatingRate",
    "FloatingRateCalculation",
    "FloatingRateIndex",
    "ForecastRateIndex",
    "Formula",
    "FormulaComponent",
    "Frequency",
    "Future",
    "FutureId",
    "FutureValueAmount",
    "FxCashSettlement",
    "FxCashSettlementSimple",
    "FxConversion",
    "FxFeature",
    "FxFixing",
    "FxInformationSource",
    "FxRate",
    "FxRateAsset",
    "FxRateSourceFixing",
    "FxSettlementRateSource",
    "FxSpotRateSource",
    "GenericAgreement",
    "GoverningLaw",
    "GracePeriodExtension",
    "GrossCashflow",
    "IdentifiedAsset",
    "IdentifiedCurrency",
    "IdentifiedCurrencyReference",
    "IdentifiedDate",
    "IdentifiedPayerReceiver",
    "IdentifiedRate",
    "IndependentAmount",
    "Index",
    "IndustryClassification",
    "InformationProvider",
    "InformationSource",
    "InstrumentId",
    "InterestAccrualsCompoundingMethod",
    "InterestAccrualsMethod",
    "IntermediaryInformation",
    "InterpolationMethod",
    "IssuerId",
    "IssuerTradeId",
    "Knock",
    "Language",
    "Leg",
    "LegId",
    "LegIdentifier",
    "LegalEntity",
    "LegalEntityReference",
    "Lien",
    "Loan",
    "MainPublication",
    "ManualExercise",
    "MarketDisruption",
    "MasterAgreement",
    "MasterAgreementId",
    "MasterAgreementType",
    "MasterAgreementVersion",
    "MasterConfirmation",
    "MasterConfirmationAnnexType",
    "MasterConfirmationType",
    "MatchId",
    "Math",
    "MatrixTerm",
    "MatrixType",
    "MimeType",
    "Money",
    "MoneyBase",
    "Mortgage",
    "MortgageSector",
    "MultipleExercise",
    "MutualFund",
    "NonNegativeAmountSchedule",
    "NonNegativeMoney",
    "NonNegativePayment",
    "NonNegativeSchedule",
    "NonNegativeStep",
    "NotifyingParty",
    "NotionalAmount",
    "NotionalAmountReference",
    "NotionalReference",
    "NumberOfOptionsReference",
    "NumberOfUnitsReference",
    "ObservationFrequency",
    "Offset",
    "OffsetPrevailingTime",
    "OnBehalfOf",
    "Option",
    "OptionBase",
    "OptionBaseExtended",
    "OptionFeature",
    "OptionNumericStrike",
    "OptionStrike",
    "OrganizationType",
    "OriginatingEvent",
    "PartialExercise",
    "Party",
    "PartyContactInformation",
    "PartyGroupType",
    "PartyId",
    "PartyName",
    "PartyReference",
    "PartyRelationship",
    "PartyRelationshipDocumentation",
    "PartyRole",
    "PartyRoleType",
    "PartyTradeIdentifierReference",
    "PassThrough",
    "PassThroughItem",
    "Payment",
    "PaymentBase",
    "PaymentBaseExtended",
    "PaymentDetail",
    "PaymentDetails",
    "PaymentId",
    "PaymentReference",
    "PaymentRule",
    "PaymentType",
    "PendingPayment",
    "Period",
    "PeriodicDates",
    "Person",
    "PersonId",
    "PersonReference",
    "PersonRole",
    "PositiveMoney",
    "Premium",
    "PrevailingTime",
    "Price",
    "PriceQuoteUnits",
    "PricingModel",
    "PricingStructure",
    "PricingStructureReference",
    "PrincipalExchanges",
    "Product",
    "ProductId",
    "ProductReference",
    "ProductType",
    "ProposedCollateralAllocation",
    "PubliclyAvailableInformation",
    "QuantityUnit",
    "Quanto",
    "QuotationCharacteristics",
    "QuoteTiming",
    "QuotedCurrencyPair",
    "Rate",
    "RateIndex",
    "RateObservation",
    "RateReference",
    "RateSourcePage",
    "Reference",
    "ReferenceAmount",
    "ReferenceBank",
    "ReferenceBankId",
    "Region",
    "RelatedBusinessUnit",
    "RelatedParty",
    "RelatedPerson",
    "RelativeDateOffset",
    "RelativeDateSequence",
    "RelativeDates",
    "ReportingCurrencyType",
    "ReportingRegimeName",
    "RequestedAction",
    "RequiredIdentifierDate",
    "ResetFrequency",
    "Resource",
    "ResourceId",
    "ResourceLength",
    "ResourceType",
    "Restructuring",
    "RestructuringType",
    "ReturnSwapNotionalAmountReference",
    "Rounding",
    "Routing",
    "RoutingExplicitDetails",
    "RoutingId",
    "RoutingIds",
    "RoutingIdsAndExplicitDetails",
    "Schedule",
    "ScheduleReference",
    "SettlementInformation",
    "SettlementInstruction",
    "SettlementMethod",
    "SettlementPriceDefaultElection",
    "SettlementPriceSource",
    "SettlementRateOption",
    "SettlementRateSource",
    "SettlementTerms",
    "SharedAmericanExercise",
    "SimpleCreditDefaultSwap",
    "SimpleFra",
    "SimpleIRSwap",
    "SimplePayment",
    "SingleUnderlyer",
    "SplitSettlement",
    "SpreadSchedule",
    "SpreadScheduleReference",
    "SpreadScheduleType",
    "Step",
    "StepBase",
    "StrategyFeature",
    "StreetAddress",
    "Strike",
    "StrikeSchedule",
    "StrikeSpread",
    "Stub",
    "StubFloatingRate",
    "StubValue",
    "SupervisoryBody",
    "SwaptionPhysicalSettlement",
    "TelephoneNumber",
    "TimezoneLocation",
    "TradeId",
    "Trigger",
    "TriggerEvent",
    "Underlyer",
    "UnderlyerInterestLeg",
    "UnderlyerLoanRate",
    "UnderlyingAsset",
    "UnderlyingAssetTranche",
    "Unit",
    "WeightedAveragingObservation"
]
