#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Tue Feb 23 09:04:10 2016 by generateDS.py version 2.19b.
#
# Command line options:
#   ('-f', '')
#   ('-o', 'fpml01/fpml_transparency_processeslib.py')
#   ('-s', 'fpml01/fpml_transparency_processesapp.py')
#   ('--super', 'fpml01/fpml_transparency_processeslib')
#   ('--member-specs', 'dict')
#   ('--export', 'write')
#
# Command line arguments:
#   fpml-master-schema-and-key-gen-scripts/src/schema/fpml-transparency-processes.xsd
#
# Command line:
#   ./generateDS.py -f -o "fpml01/fpml_transparency_processeslib.py" -s "fpml01/fpml_transparency_processesapp.py" --super="fpml01/fpml_transparency_processeslib" --member-specs="dict" --export="write" fpml-master-schema-and-key-gen-scripts/src/schema/fpml-transparency-processes.xsd
#
# Current working directory (os.getcwd()):
#   Test02
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
from lxml import etree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        parser = etree_.ETCompatXMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                return instring.encode(ExternalEncoding)
            else:
                return instring

    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class AbstractEvent(GeneratedsSuper):
    """Abstract base type for all events."""
    member_data_items_ = {
        'eventIdentifier': MemberSpec_('eventIdentifier', 'BusinessEventIdentifier', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, eventIdentifier=None, extensiontype_=None):
        self.original_tagname_ = None
        if eventIdentifier is None:
            self.eventIdentifier = []
        else:
            self.eventIdentifier = eventIdentifier
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractEvent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractEvent.subclass:
            return AbstractEvent.subclass(*args_, **kwargs_)
        else:
            return AbstractEvent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_eventIdentifier(self): return self.eventIdentifier
    def set_eventIdentifier(self, eventIdentifier): self.eventIdentifier = eventIdentifier
    def add_eventIdentifier(self, value): self.eventIdentifier.append(value)
    def insert_eventIdentifier_at(self, index, value): self.eventIdentifier.insert(index, value)
    def replace_eventIdentifier_at(self, index, value): self.eventIdentifier[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.eventIdentifier
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AbstractEvent', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractEvent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AbstractEvent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractEvent'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractEvent', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for eventIdentifier_ in self.eventIdentifier:
            eventIdentifier_.export(outfile, level, namespace_, name_='eventIdentifier', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'eventIdentifier':
            obj_ = BusinessEventIdentifier.factory()
            obj_.build(child_)
            self.eventIdentifier.append(obj_)
            obj_.original_tagname_ = 'eventIdentifier'
# end class AbstractEvent


class ActionOnExpiration(GeneratedsSuper):
    member_data_items_ = {
        'exerciseAction': MemberSpec_('exerciseAction', ['ExerciseActionEnum', 'Token', 'xsd:token'], 0),
        'expiry': MemberSpec_('expiry', 'xsd:boolean', 0),
        'fullExercise': MemberSpec_('fullExercise', 'xsd:boolean', 0),
        'exerciseInNotionalAmount': MemberSpec_('exerciseInNotionalAmount', 'Money', 0),
        'outstandingNotionalAmount': MemberSpec_('outstandingNotionalAmount', 'Money', 0),
        'exerciseInNumberOfOptions': MemberSpec_('exerciseInNumberOfOptions', 'xsd:decimal', 0),
        'outstandingNumberOfOptions': MemberSpec_('outstandingNumberOfOptions', 'xsd:decimal', 0),
        'exerciseInNumberOfUnits': MemberSpec_('exerciseInNumberOfUnits', 'xsd:decimal', 0),
        'outstandingNumberOfUnits': MemberSpec_('outstandingNumberOfUnits', 'xsd:decimal', 0),
        'specifiedExercise': MemberSpec_('specifiedExercise', 'OptionExerciseAmounts', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, exerciseAction=None, expiry=None, fullExercise=None, exerciseInNotionalAmount=None, outstandingNotionalAmount=None, exerciseInNumberOfOptions=None, outstandingNumberOfOptions=None, exerciseInNumberOfUnits=None, outstandingNumberOfUnits=None, specifiedExercise=None):
        self.original_tagname_ = None
        self.exerciseAction = exerciseAction
        self.validate_ExerciseActionEnum(self.exerciseAction)
        self.expiry = expiry
        self.fullExercise = fullExercise
        self.exerciseInNotionalAmount = exerciseInNotionalAmount
        self.outstandingNotionalAmount = outstandingNotionalAmount
        self.exerciseInNumberOfOptions = exerciseInNumberOfOptions
        self.outstandingNumberOfOptions = outstandingNumberOfOptions
        self.exerciseInNumberOfUnits = exerciseInNumberOfUnits
        self.outstandingNumberOfUnits = outstandingNumberOfUnits
        if specifiedExercise is None:
            self.specifiedExercise = []
        else:
            self.specifiedExercise = specifiedExercise
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ActionOnExpiration)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ActionOnExpiration.subclass:
            return ActionOnExpiration.subclass(*args_, **kwargs_)
        else:
            return ActionOnExpiration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_exerciseAction(self): return self.exerciseAction
    def set_exerciseAction(self, exerciseAction): self.exerciseAction = exerciseAction
    def get_expiry(self): return self.expiry
    def set_expiry(self, expiry): self.expiry = expiry
    def get_fullExercise(self): return self.fullExercise
    def set_fullExercise(self, fullExercise): self.fullExercise = fullExercise
    def get_exerciseInNotionalAmount(self): return self.exerciseInNotionalAmount
    def set_exerciseInNotionalAmount(self, exerciseInNotionalAmount): self.exerciseInNotionalAmount = exerciseInNotionalAmount
    def get_outstandingNotionalAmount(self): return self.outstandingNotionalAmount
    def set_outstandingNotionalAmount(self, outstandingNotionalAmount): self.outstandingNotionalAmount = outstandingNotionalAmount
    def get_exerciseInNumberOfOptions(self): return self.exerciseInNumberOfOptions
    def set_exerciseInNumberOfOptions(self, exerciseInNumberOfOptions): self.exerciseInNumberOfOptions = exerciseInNumberOfOptions
    def get_outstandingNumberOfOptions(self): return self.outstandingNumberOfOptions
    def set_outstandingNumberOfOptions(self, outstandingNumberOfOptions): self.outstandingNumberOfOptions = outstandingNumberOfOptions
    def get_exerciseInNumberOfUnits(self): return self.exerciseInNumberOfUnits
    def set_exerciseInNumberOfUnits(self, exerciseInNumberOfUnits): self.exerciseInNumberOfUnits = exerciseInNumberOfUnits
    def get_outstandingNumberOfUnits(self): return self.outstandingNumberOfUnits
    def set_outstandingNumberOfUnits(self, outstandingNumberOfUnits): self.outstandingNumberOfUnits = outstandingNumberOfUnits
    def get_specifiedExercise(self): return self.specifiedExercise
    def set_specifiedExercise(self, specifiedExercise): self.specifiedExercise = specifiedExercise
    def add_specifiedExercise(self, value): self.specifiedExercise.append(value)
    def insert_specifiedExercise_at(self, index, value): self.specifiedExercise.insert(index, value)
    def replace_specifiedExercise_at(self, index, value): self.specifiedExercise[index] = value
    def validate_ExerciseActionEnum(self, value):
        # Validate type ExerciseActionEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FullExercise', 'PartialExercise', 'Abandon']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ExerciseActionEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on ExerciseActionEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.exerciseAction is not None or
            self.expiry is not None or
            self.fullExercise is not None or
            self.exerciseInNotionalAmount is not None or
            self.outstandingNotionalAmount is not None or
            self.exerciseInNumberOfOptions is not None or
            self.outstandingNumberOfOptions is not None or
            self.exerciseInNumberOfUnits is not None or
            self.outstandingNumberOfUnits is not None or
            self.specifiedExercise
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ActionOnExpiration', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActionOnExpiration')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ActionOnExpiration', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ActionOnExpiration'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ActionOnExpiration', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.exerciseAction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexerciseAction>%s</%sexerciseAction>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.exerciseAction), input_name='exerciseAction')), namespace_, eol_))
        if self.expiry is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexpiry>%s</%sexpiry>%s' % (namespace_, self.gds_format_boolean(self.expiry, input_name='expiry'), namespace_, eol_))
        if self.fullExercise is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfullExercise>%s</%sfullExercise>%s' % (namespace_, self.gds_format_boolean(self.fullExercise, input_name='fullExercise'), namespace_, eol_))
        if self.exerciseInNotionalAmount is not None:
            self.exerciseInNotionalAmount.export(outfile, level, namespace_, name_='exerciseInNotionalAmount', pretty_print=pretty_print)
        if self.outstandingNotionalAmount is not None:
            self.outstandingNotionalAmount.export(outfile, level, namespace_, name_='outstandingNotionalAmount', pretty_print=pretty_print)
        if self.exerciseInNumberOfOptions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexerciseInNumberOfOptions>%s</%sexerciseInNumberOfOptions>%s' % (namespace_, self.gds_format_float(self.exerciseInNumberOfOptions, input_name='exerciseInNumberOfOptions'), namespace_, eol_))
        if self.outstandingNumberOfOptions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soutstandingNumberOfOptions>%s</%soutstandingNumberOfOptions>%s' % (namespace_, self.gds_format_float(self.outstandingNumberOfOptions, input_name='outstandingNumberOfOptions'), namespace_, eol_))
        if self.exerciseInNumberOfUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexerciseInNumberOfUnits>%s</%sexerciseInNumberOfUnits>%s' % (namespace_, self.gds_format_float(self.exerciseInNumberOfUnits, input_name='exerciseInNumberOfUnits'), namespace_, eol_))
        if self.outstandingNumberOfUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soutstandingNumberOfUnits>%s</%soutstandingNumberOfUnits>%s' % (namespace_, self.gds_format_float(self.outstandingNumberOfUnits, input_name='outstandingNumberOfUnits'), namespace_, eol_))
        for specifiedExercise_ in self.specifiedExercise:
            specifiedExercise_.export(outfile, level, namespace_, name_='specifiedExercise', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'exerciseAction':
            exerciseAction_ = child_.text
            exerciseAction_ = re_.sub(String_cleanup_pat_, " ", exerciseAction_).strip()
            exerciseAction_ = self.gds_validate_string(exerciseAction_, node, 'exerciseAction')
            self.exerciseAction = exerciseAction_
            # validate type ExerciseActionEnum
            self.validate_ExerciseActionEnum(self.exerciseAction)
        elif nodeName_ == 'expiry':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'expiry')
            self.expiry = ival_
        elif nodeName_ == 'fullExercise':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'fullExercise')
            self.fullExercise = ival_
        elif nodeName_ == 'exerciseInNotionalAmount':
            obj_ = Money.factory()
            obj_.build(child_)
            self.exerciseInNotionalAmount = obj_
            obj_.original_tagname_ = 'exerciseInNotionalAmount'
        elif nodeName_ == 'outstandingNotionalAmount':
            obj_ = Money.factory()
            obj_.build(child_)
            self.outstandingNotionalAmount = obj_
            obj_.original_tagname_ = 'outstandingNotionalAmount'
        elif nodeName_ == 'exerciseInNumberOfOptions':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'exerciseInNumberOfOptions')
            self.exerciseInNumberOfOptions = fval_
        elif nodeName_ == 'outstandingNumberOfOptions':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'outstandingNumberOfOptions')
            self.outstandingNumberOfOptions = fval_
        elif nodeName_ == 'exerciseInNumberOfUnits':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'exerciseInNumberOfUnits')
            self.exerciseInNumberOfUnits = fval_
        elif nodeName_ == 'outstandingNumberOfUnits':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'outstandingNumberOfUnits')
            self.outstandingNumberOfUnits = fval_
        elif nodeName_ == 'specifiedExercise':
            obj_ = OptionExerciseAmounts.factory()
            obj_.build(child_)
            self.specifiedExercise.append(obj_)
            obj_.original_tagname_ = 'specifiedExercise'
# end class ActionOnExpiration


class AdditionalEvent(AbstractEvent):
    """Abstract base type for an extension/substitution point to customize
    FpML and add additional events."""
    member_data_items_ = {
    }
    subclass = None
    superclass = AbstractEvent
    def __init__(self, eventIdentifier=None):
        self.original_tagname_ = None
        super(AdditionalEvent, self).__init__(eventIdentifier, )
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdditionalEvent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdditionalEvent.subclass:
            return AdditionalEvent.subclass(*args_, **kwargs_)
        else:
            return AdditionalEvent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(AdditionalEvent, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AdditionalEvent', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdditionalEvent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AdditionalEvent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AdditionalEvent'):
        super(AdditionalEvent, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AdditionalEvent')
    def exportChildren(self, outfile, level, namespace_='', name_='AdditionalEvent', fromsubclass_=False, pretty_print=True):
        super(AdditionalEvent, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AdditionalEvent, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AdditionalEvent, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AdditionalEvent


class BusinessEventIdentifier(GeneratedsSuper):
    """A type defining an event identifier issued by the indicated party."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'partyReference': MemberSpec_('partyReference', 'PartyReference', 0),
        'accountReference': MemberSpec_('accountReference', 'AccountReference', 0),
        'eventId': MemberSpec_('eventId', 'EventId', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, partyReference=None, accountReference=None, eventId=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.partyReference = partyReference
        self.accountReference = accountReference
        self.eventId = eventId
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BusinessEventIdentifier)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BusinessEventIdentifier.subclass:
            return BusinessEventIdentifier.subclass(*args_, **kwargs_)
        else:
            return BusinessEventIdentifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyReference(self): return self.partyReference
    def set_partyReference(self, partyReference): self.partyReference = partyReference
    def get_accountReference(self): return self.accountReference
    def set_accountReference(self, accountReference): self.accountReference = accountReference
    def get_eventId(self): return self.eventId
    def set_eventId(self, eventId): self.eventId = eventId
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.partyReference is not None or
            self.accountReference is not None or
            self.eventId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BusinessEventIdentifier', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BusinessEventIdentifier')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BusinessEventIdentifier', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BusinessEventIdentifier'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BusinessEventIdentifier', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.partyReference is not None:
            self.partyReference.export(outfile, level, namespace_, name_='partyReference', pretty_print=pretty_print)
        if self.accountReference is not None:
            self.accountReference.export(outfile, level, namespace_, name_='accountReference', pretty_print=pretty_print)
        if self.eventId is not None:
            self.eventId.export(outfile, level, namespace_, name_='eventId', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'partyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.partyReference = obj_
            obj_.original_tagname_ = 'partyReference'
        elif nodeName_ == 'accountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.accountReference = obj_
            obj_.original_tagname_ = 'accountReference'
        elif nodeName_ == 'eventId':
            obj_ = EventId.factory()
            obj_.build(child_)
            self.eventId = obj_
            obj_.original_tagname_ = 'eventId'
# end class BusinessEventIdentifier


class ChangeEvent(AbstractEvent):
    """Abstract base type for non-negotiated trade change descriptions"""
    member_data_items_ = {
    }
    subclass = None
    superclass = AbstractEvent
    def __init__(self, eventIdentifier=None, extensiontype_=None):
        self.original_tagname_ = None
        super(ChangeEvent, self).__init__(eventIdentifier, extensiontype_, )
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChangeEvent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChangeEvent.subclass:
            return ChangeEvent.subclass(*args_, **kwargs_)
        else:
            return ChangeEvent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(ChangeEvent, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ChangeEvent', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChangeEvent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ChangeEvent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChangeEvent'):
        super(ChangeEvent, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ChangeEvent')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='ChangeEvent', fromsubclass_=False, pretty_print=True):
        super(ChangeEvent, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ChangeEvent, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ChangeEvent, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ChangeEvent


class ClearingStatusItem(GeneratedsSuper):
    """A component of a clearing status report. This provides the clearing
    status for a single trade."""
    member_data_items_ = {
        'tradeIdentifier': MemberSpec_('tradeIdentifier', 'TradeIdentifier', 1),
        'tradeReferenceInformation': MemberSpec_('tradeReferenceInformation', 'TradeReferenceInformation', 0),
        'trade': MemberSpec_('trade', 'Trade', 0),
        'tradePackage': MemberSpec_('tradePackage', 'TradePackage', 0),
        'clearingStatusValue': MemberSpec_('clearingStatusValue', 'ClearingStatusValue', 0),
        'updatedDateTime': MemberSpec_('updatedDateTime', 'xsd:dateTime', 0),
        'reason': MemberSpec_('reason', 'Reason', 1),
        'statusAppliesTo': MemberSpec_('statusAppliesTo', 'PartyReference', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, tradeIdentifier=None, tradeReferenceInformation=None, trade=None, tradePackage=None, clearingStatusValue=None, updatedDateTime=None, reason=None, statusAppliesTo=None):
        self.original_tagname_ = None
        if tradeIdentifier is None:
            self.tradeIdentifier = []
        else:
            self.tradeIdentifier = tradeIdentifier
        self.tradeReferenceInformation = tradeReferenceInformation
        self.trade = trade
        self.tradePackage = tradePackage
        self.clearingStatusValue = clearingStatusValue
        if isinstance(updatedDateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(updatedDateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = updatedDateTime
        self.updatedDateTime = initvalue_
        if reason is None:
            self.reason = []
        else:
            self.reason = reason
        if statusAppliesTo is None:
            self.statusAppliesTo = []
        else:
            self.statusAppliesTo = statusAppliesTo
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClearingStatusItem)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClearingStatusItem.subclass:
            return ClearingStatusItem.subclass(*args_, **kwargs_)
        else:
            return ClearingStatusItem(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tradeIdentifier(self): return self.tradeIdentifier
    def set_tradeIdentifier(self, tradeIdentifier): self.tradeIdentifier = tradeIdentifier
    def add_tradeIdentifier(self, value): self.tradeIdentifier.append(value)
    def insert_tradeIdentifier_at(self, index, value): self.tradeIdentifier.insert(index, value)
    def replace_tradeIdentifier_at(self, index, value): self.tradeIdentifier[index] = value
    def get_tradeReferenceInformation(self): return self.tradeReferenceInformation
    def set_tradeReferenceInformation(self, tradeReferenceInformation): self.tradeReferenceInformation = tradeReferenceInformation
    def get_trade(self): return self.trade
    def set_trade(self, trade): self.trade = trade
    def get_tradePackage(self): return self.tradePackage
    def set_tradePackage(self, tradePackage): self.tradePackage = tradePackage
    def get_clearingStatusValue(self): return self.clearingStatusValue
    def set_clearingStatusValue(self, clearingStatusValue): self.clearingStatusValue = clearingStatusValue
    def get_updatedDateTime(self): return self.updatedDateTime
    def set_updatedDateTime(self, updatedDateTime): self.updatedDateTime = updatedDateTime
    def get_reason(self): return self.reason
    def set_reason(self, reason): self.reason = reason
    def add_reason(self, value): self.reason.append(value)
    def insert_reason_at(self, index, value): self.reason.insert(index, value)
    def replace_reason_at(self, index, value): self.reason[index] = value
    def get_statusAppliesTo(self): return self.statusAppliesTo
    def set_statusAppliesTo(self, statusAppliesTo): self.statusAppliesTo = statusAppliesTo
    def add_statusAppliesTo(self, value): self.statusAppliesTo.append(value)
    def insert_statusAppliesTo_at(self, index, value): self.statusAppliesTo.insert(index, value)
    def replace_statusAppliesTo_at(self, index, value): self.statusAppliesTo[index] = value
    def hasContent_(self):
        if (
            self.tradeIdentifier or
            self.tradeReferenceInformation is not None or
            self.trade is not None or
            self.tradePackage is not None or
            self.clearingStatusValue is not None or
            self.updatedDateTime is not None or
            self.reason or
            self.statusAppliesTo
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ClearingStatusItem', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ClearingStatusItem')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ClearingStatusItem', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ClearingStatusItem'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ClearingStatusItem', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for tradeIdentifier_ in self.tradeIdentifier:
            tradeIdentifier_.export(outfile, level, namespace_, name_='tradeIdentifier', pretty_print=pretty_print)
        if self.tradeReferenceInformation is not None:
            self.tradeReferenceInformation.export(outfile, level, namespace_, name_='tradeReferenceInformation', pretty_print=pretty_print)
        if self.trade is not None:
            self.trade.export(outfile, level, namespace_, name_='trade', pretty_print=pretty_print)
        if self.tradePackage is not None:
            self.tradePackage.export(outfile, level, namespace_, name_='tradePackage', pretty_print=pretty_print)
        if self.clearingStatusValue is not None:
            self.clearingStatusValue.export(outfile, level, namespace_, name_='clearingStatusValue', pretty_print=pretty_print)
        if self.updatedDateTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%supdatedDateTime>%s</%supdatedDateTime>%s' % (namespace_, self.gds_format_datetime(self.updatedDateTime, input_name='updatedDateTime'), namespace_, eol_))
        for reason_ in self.reason:
            reason_.export(outfile, level, namespace_, name_='reason', pretty_print=pretty_print)
        for statusAppliesTo_ in self.statusAppliesTo:
            statusAppliesTo_.export(outfile, level, namespace_, name_='statusAppliesTo', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tradeIdentifier':
            class_obj_ = self.get_class_obj_(child_, TradeIdentifier)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.tradeIdentifier.append(obj_)
            obj_.original_tagname_ = 'tradeIdentifier'
        elif nodeName_ == 'tradeReferenceInformation':
            obj_ = TradeReferenceInformation.factory()
            obj_.build(child_)
            self.tradeReferenceInformation = obj_
            obj_.original_tagname_ = 'tradeReferenceInformation'
        elif nodeName_ == 'trade':
            obj_ = Trade.factory()
            obj_.build(child_)
            self.trade = obj_
            obj_.original_tagname_ = 'trade'
        elif nodeName_ == 'tradePackage':
            obj_ = TradePackage.factory()
            obj_.build(child_)
            self.tradePackage = obj_
            obj_.original_tagname_ = 'tradePackage'
        elif nodeName_ == 'clearingStatusValue':
            obj_ = ClearingStatusValue.factory()
            obj_.build(child_)
            self.clearingStatusValue = obj_
            obj_.original_tagname_ = 'clearingStatusValue'
        elif nodeName_ == 'updatedDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.updatedDateTime = dval_
        elif nodeName_ == 'reason':
            obj_ = Reason.factory()
            obj_.build(child_)
            self.reason.append(obj_)
            obj_.original_tagname_ = 'reason'
        elif nodeName_ == 'statusAppliesTo':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.statusAppliesTo.append(obj_)
            obj_.original_tagname_ = 'statusAppliesTo'
# end class ClearingStatusItem


class ClearingInstructions(GeneratedsSuper):
    member_data_items_ = {
        'requestedClearingAction': MemberSpec_('requestedClearingAction', 'RequestedClearingAction', 0),
        'requestedClearingOrganizationPartyReference': MemberSpec_('requestedClearingOrganizationPartyReference', 'PartyReference', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, requestedClearingAction=None, requestedClearingOrganizationPartyReference=None):
        self.original_tagname_ = None
        self.requestedClearingAction = requestedClearingAction
        self.requestedClearingOrganizationPartyReference = requestedClearingOrganizationPartyReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClearingInstructions)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClearingInstructions.subclass:
            return ClearingInstructions.subclass(*args_, **kwargs_)
        else:
            return ClearingInstructions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_requestedClearingAction(self): return self.requestedClearingAction
    def set_requestedClearingAction(self, requestedClearingAction): self.requestedClearingAction = requestedClearingAction
    def get_requestedClearingOrganizationPartyReference(self): return self.requestedClearingOrganizationPartyReference
    def set_requestedClearingOrganizationPartyReference(self, requestedClearingOrganizationPartyReference): self.requestedClearingOrganizationPartyReference = requestedClearingOrganizationPartyReference
    def hasContent_(self):
        if (
            self.requestedClearingAction is not None or
            self.requestedClearingOrganizationPartyReference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ClearingInstructions', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ClearingInstructions')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ClearingInstructions', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ClearingInstructions'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ClearingInstructions', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.requestedClearingAction is not None:
            self.requestedClearingAction.export(outfile, level, namespace_, name_='requestedClearingAction', pretty_print=pretty_print)
        if self.requestedClearingOrganizationPartyReference is not None:
            self.requestedClearingOrganizationPartyReference.export(outfile, level, namespace_, name_='requestedClearingOrganizationPartyReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'requestedClearingAction':
            obj_ = RequestedClearingAction.factory()
            obj_.build(child_)
            self.requestedClearingAction = obj_
            obj_.original_tagname_ = 'requestedClearingAction'
        elif nodeName_ == 'requestedClearingOrganizationPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.requestedClearingOrganizationPartyReference = obj_
            obj_.original_tagname_ = 'requestedClearingOrganizationPartyReference'
# end class ClearingInstructions


class CompressionActivity(GeneratedsSuper):
    """A type that shows how multiple trades have been combined into a
    result.This option is deprecated in favour of the first choice."""
    member_data_items_ = {
        'compressionType': MemberSpec_('compressionType', 'CompressionType', 0),
        'replacementTradeIdentifier': MemberSpec_('replacementTradeIdentifier', 'TradeIdentifier', 0),
        'originatingTradeIdentifier': MemberSpec_('originatingTradeIdentifier', 'TradeIdentifier', 1),
        'replacementTradeId': MemberSpec_('replacementTradeId', 'TradeId', 0),
        'originatingTradeId': MemberSpec_('originatingTradeId', 'TradeId', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, compressionType=None, replacementTradeIdentifier=None, originatingTradeIdentifier=None, replacementTradeId=None, originatingTradeId=None):
        self.original_tagname_ = None
        self.compressionType = compressionType
        self.replacementTradeIdentifier = replacementTradeIdentifier
        if originatingTradeIdentifier is None:
            self.originatingTradeIdentifier = []
        else:
            self.originatingTradeIdentifier = originatingTradeIdentifier
        self.replacementTradeId = replacementTradeId
        if originatingTradeId is None:
            self.originatingTradeId = []
        else:
            self.originatingTradeId = originatingTradeId
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CompressionActivity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CompressionActivity.subclass:
            return CompressionActivity.subclass(*args_, **kwargs_)
        else:
            return CompressionActivity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_compressionType(self): return self.compressionType
    def set_compressionType(self, compressionType): self.compressionType = compressionType
    def get_replacementTradeIdentifier(self): return self.replacementTradeIdentifier
    def set_replacementTradeIdentifier(self, replacementTradeIdentifier): self.replacementTradeIdentifier = replacementTradeIdentifier
    def get_originatingTradeIdentifier(self): return self.originatingTradeIdentifier
    def set_originatingTradeIdentifier(self, originatingTradeIdentifier): self.originatingTradeIdentifier = originatingTradeIdentifier
    def add_originatingTradeIdentifier(self, value): self.originatingTradeIdentifier.append(value)
    def insert_originatingTradeIdentifier_at(self, index, value): self.originatingTradeIdentifier.insert(index, value)
    def replace_originatingTradeIdentifier_at(self, index, value): self.originatingTradeIdentifier[index] = value
    def get_replacementTradeId(self): return self.replacementTradeId
    def set_replacementTradeId(self, replacementTradeId): self.replacementTradeId = replacementTradeId
    def get_originatingTradeId(self): return self.originatingTradeId
    def set_originatingTradeId(self, originatingTradeId): self.originatingTradeId = originatingTradeId
    def add_originatingTradeId(self, value): self.originatingTradeId.append(value)
    def insert_originatingTradeId_at(self, index, value): self.originatingTradeId.insert(index, value)
    def replace_originatingTradeId_at(self, index, value): self.originatingTradeId[index] = value
    def hasContent_(self):
        if (
            self.compressionType is not None or
            self.replacementTradeIdentifier is not None or
            self.originatingTradeIdentifier or
            self.replacementTradeId is not None or
            self.originatingTradeId
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CompressionActivity', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CompressionActivity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CompressionActivity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CompressionActivity'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CompressionActivity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.compressionType is not None:
            self.compressionType.export(outfile, level, namespace_, name_='compressionType', pretty_print=pretty_print)
        if self.replacementTradeIdentifier is not None:
            self.replacementTradeIdentifier.export(outfile, level, namespace_, name_='replacementTradeIdentifier', pretty_print=pretty_print)
        for originatingTradeIdentifier_ in self.originatingTradeIdentifier:
            originatingTradeIdentifier_.export(outfile, level, namespace_, name_='originatingTradeIdentifier', pretty_print=pretty_print)
        if self.replacementTradeId is not None:
            self.replacementTradeId.export(outfile, level, namespace_, name_='replacementTradeId', pretty_print=pretty_print)
        for originatingTradeId_ in self.originatingTradeId:
            originatingTradeId_.export(outfile, level, namespace_, name_='originatingTradeId', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'compressionType':
            obj_ = CompressionType.factory()
            obj_.build(child_)
            self.compressionType = obj_
            obj_.original_tagname_ = 'compressionType'
        elif nodeName_ == 'replacementTradeIdentifier':
            class_obj_ = self.get_class_obj_(child_, TradeIdentifier)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.replacementTradeIdentifier = obj_
            obj_.original_tagname_ = 'replacementTradeIdentifier'
        elif nodeName_ == 'originatingTradeIdentifier':
            class_obj_ = self.get_class_obj_(child_, TradeIdentifier)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.originatingTradeIdentifier.append(obj_)
            obj_.original_tagname_ = 'originatingTradeIdentifier'
        elif nodeName_ == 'replacementTradeId':
            obj_ = TradeId.factory()
            obj_.build(child_)
            self.replacementTradeId = obj_
            obj_.original_tagname_ = 'replacementTradeId'
        elif nodeName_ == 'originatingTradeId':
            obj_ = TradeId.factory()
            obj_.build(child_)
            self.originatingTradeId.append(obj_)
            obj_.original_tagname_ = 'originatingTradeId'
# end class CompressionActivity


class CompressionType(GeneratedsSuper):
    """A type that identifies the type of trade amalgamation, for example
    netting or portfolio compression."""
    member_data_items_ = {
        'compressionTypeScheme': MemberSpec_('compressionTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, compressionTypeScheme='http://www.fpml.org/coding-scheme/compression-type', valueOf_=None):
        self.original_tagname_ = None
        self.compressionTypeScheme = _cast(None, compressionTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CompressionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CompressionType.subclass:
            return CompressionType.subclass(*args_, **kwargs_)
        else:
            return CompressionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_compressionTypeScheme(self): return self.compressionTypeScheme
    def set_compressionTypeScheme(self, compressionTypeScheme): self.compressionTypeScheme = compressionTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CompressionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CompressionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CompressionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CompressionType'):
        if self.compressionTypeScheme != "http://www.fpml.org/coding-scheme/compression-type" and 'compressionTypeScheme' not in already_processed:
            already_processed.add('compressionTypeScheme')
            outfile.write(' compressionTypeScheme=%s' % (quote_attrib(self.compressionTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CompressionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('compressionTypeScheme', node)
        if value is not None and 'compressionTypeScheme' not in already_processed:
            already_processed.add('compressionTypeScheme')
            self.compressionTypeScheme = value
            self.validate_NonEmptyURI(self.compressionTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CompressionType


class CorporateActionEvent(ChangeEvent):
    """A structure indicating that a trade has changed due to a corporate
    action"""
    member_data_items_ = {
        'type_': MemberSpec_('type_', 'CorporateActionType', 0),
    }
    subclass = None
    superclass = ChangeEvent
    def __init__(self, eventIdentifier=None, type_=None):
        self.original_tagname_ = None
        super(CorporateActionEvent, self).__init__(eventIdentifier, )
        self.type_ = type_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CorporateActionEvent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CorporateActionEvent.subclass:
            return CorporateActionEvent.subclass(*args_, **kwargs_)
        else:
            return CorporateActionEvent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (
            self.type_ is not None or
            super(CorporateActionEvent, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CorporateActionEvent', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CorporateActionEvent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CorporateActionEvent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CorporateActionEvent'):
        super(CorporateActionEvent, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CorporateActionEvent')
    def exportChildren(self, outfile, level, namespace_='', name_='CorporateActionEvent', fromsubclass_=False, pretty_print=True):
        super(CorporateActionEvent, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            self.type_.export(outfile, level, namespace_, name_='type', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CorporateActionEvent, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            obj_ = CorporateActionType.factory()
            obj_.build(child_)
            self.type_ = obj_
            obj_.original_tagname_ = 'type'
        super(CorporateActionEvent, self).buildChildren(child_, node, nodeName_, True)
# end class CorporateActionEvent


class CorporateActionType(GeneratedsSuper):
    """A type that describes what type of corporate action occurred."""
    member_data_items_ = {
        'corporateActionScheme': MemberSpec_('corporateActionScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, corporateActionScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.corporateActionScheme = _cast(None, corporateActionScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CorporateActionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CorporateActionType.subclass:
            return CorporateActionType.subclass(*args_, **kwargs_)
        else:
            return CorporateActionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_corporateActionScheme(self): return self.corporateActionScheme
    def set_corporateActionScheme(self, corporateActionScheme): self.corporateActionScheme = corporateActionScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CorporateActionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CorporateActionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CorporateActionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CorporateActionType'):
        if self.corporateActionScheme is not None and 'corporateActionScheme' not in already_processed:
            already_processed.add('corporateActionScheme')
            outfile.write(' corporateActionScheme=%s' % (quote_attrib(self.corporateActionScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CorporateActionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('corporateActionScheme', node)
        if value is not None and 'corporateActionScheme' not in already_processed:
            already_processed.add('corporateActionScheme')
            self.corporateActionScheme = value
            self.validate_NonEmptyURI(self.corporateActionScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CorporateActionType


class CreditLimitBase(GeneratedsSuper):
    """A structure describing a basic credit limit."""
    member_data_items_ = {
        'limitId': MemberSpec_('limitId', 'LimitId', 0),
        'primaryAssetClass': MemberSpec_('primaryAssetClass', 'AssetClass', 0),
        'secondaryAssetClass': MemberSpec_('secondaryAssetClass', 'AssetClass', 1),
        'productType': MemberSpec_('productType', 'ProductType', 1),
        'productId': MemberSpec_('productId', 'ProductId', 1),
        'productId': MemberSpec_('productId', 'ProductId', 1),
        'assetClass': MemberSpec_('assetClass', 'AssetClass', 1),
        'embeddedOptionType': MemberSpec_('embeddedOptionType', 'EmbeddedOptionType', 1),
        'currency': MemberSpec_('currency', 'Currency', 0),
        'tenor': MemberSpec_('tenor', 'Period', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, limitId=None, primaryAssetClass=None, secondaryAssetClass=None, productType=None, productId=None, assetClass=None, embeddedOptionType=None, currency=None, tenor=None, extensiontype_=None):
        self.original_tagname_ = None
        self.limitId = limitId
        self.primaryAssetClass = primaryAssetClass
        if secondaryAssetClass is None:
            self.secondaryAssetClass = []
        else:
            self.secondaryAssetClass = secondaryAssetClass
        if productType is None:
            self.productType = []
        else:
            self.productType = productType
        if productId is None:
            self.productId = []
        else:
            self.productId = productId
        if productId is None:
            self.productId = []
        else:
            self.productId = productId
        if assetClass is None:
            self.assetClass = []
        else:
            self.assetClass = assetClass
        if embeddedOptionType is None:
            self.embeddedOptionType = []
        else:
            self.embeddedOptionType = embeddedOptionType
        self.currency = currency
        self.tenor = tenor
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditLimitBase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditLimitBase.subclass:
            return CreditLimitBase.subclass(*args_, **kwargs_)
        else:
            return CreditLimitBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_limitId(self): return self.limitId
    def set_limitId(self, limitId): self.limitId = limitId
    def get_primaryAssetClass(self): return self.primaryAssetClass
    def set_primaryAssetClass(self, primaryAssetClass): self.primaryAssetClass = primaryAssetClass
    def get_secondaryAssetClass(self): return self.secondaryAssetClass
    def set_secondaryAssetClass(self, secondaryAssetClass): self.secondaryAssetClass = secondaryAssetClass
    def add_secondaryAssetClass(self, value): self.secondaryAssetClass.append(value)
    def insert_secondaryAssetClass_at(self, index, value): self.secondaryAssetClass.insert(index, value)
    def replace_secondaryAssetClass_at(self, index, value): self.secondaryAssetClass[index] = value
    def get_productType(self): return self.productType
    def set_productType(self, productType): self.productType = productType
    def add_productType(self, value): self.productType.append(value)
    def insert_productType_at(self, index, value): self.productType.insert(index, value)
    def replace_productType_at(self, index, value): self.productType[index] = value
    def get_productId(self): return self.productId
    def set_productId(self, productId): self.productId = productId
    def add_productId(self, value): self.productId.append(value)
    def insert_productId_at(self, index, value): self.productId.insert(index, value)
    def replace_productId_at(self, index, value): self.productId[index] = value
    def get_productId(self): return self.productId
    def set_productId(self, productId): self.productId = productId
    def add_productId(self, value): self.productId.append(value)
    def insert_productId_at(self, index, value): self.productId.insert(index, value)
    def replace_productId_at(self, index, value): self.productId[index] = value
    def get_assetClass(self): return self.assetClass
    def set_assetClass(self, assetClass): self.assetClass = assetClass
    def add_assetClass(self, value): self.assetClass.append(value)
    def insert_assetClass_at(self, index, value): self.assetClass.insert(index, value)
    def replace_assetClass_at(self, index, value): self.assetClass[index] = value
    def get_embeddedOptionType(self): return self.embeddedOptionType
    def set_embeddedOptionType(self, embeddedOptionType): self.embeddedOptionType = embeddedOptionType
    def add_embeddedOptionType(self, value): self.embeddedOptionType.append(value)
    def insert_embeddedOptionType_at(self, index, value): self.embeddedOptionType.insert(index, value)
    def replace_embeddedOptionType_at(self, index, value): self.embeddedOptionType[index] = value
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_tenor(self): return self.tenor
    def set_tenor(self, tenor): self.tenor = tenor
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.limitId is not None or
            self.primaryAssetClass is not None or
            self.secondaryAssetClass or
            self.productType or
            self.productId or
            self.productId or
            self.assetClass or
            self.embeddedOptionType or
            self.currency is not None or
            self.tenor is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditLimitBase', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditLimitBase')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditLimitBase', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditLimitBase'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CreditLimitBase', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.limitId is not None:
            self.limitId.export(outfile, level, namespace_, name_='limitId', pretty_print=pretty_print)
        if self.primaryAssetClass is not None:
            self.primaryAssetClass.export(outfile, level, namespace_, name_='primaryAssetClass', pretty_print=pretty_print)
        for secondaryAssetClass_ in self.secondaryAssetClass:
            secondaryAssetClass_.export(outfile, level, namespace_, name_='secondaryAssetClass', pretty_print=pretty_print)
        for productType_ in self.productType:
            productType_.export(outfile, level, namespace_, name_='productType', pretty_print=pretty_print)
        for productId_ in self.productId:
            productId_.export(outfile, level, namespace_, name_='productId', pretty_print=pretty_print)
        for productId_ in self.productId:
            productId_.export(outfile, level, namespace_, name_='productId', pretty_print=pretty_print)
        for assetClass_ in self.assetClass:
            assetClass_.export(outfile, level, namespace_, name_='assetClass', pretty_print=pretty_print)
        for embeddedOptionType_ in self.embeddedOptionType:
            embeddedOptionType_.export(outfile, level, namespace_, name_='embeddedOptionType', pretty_print=pretty_print)
        if self.currency is not None:
            self.currency.export(outfile, level, namespace_, name_='currency', pretty_print=pretty_print)
        if self.tenor is not None:
            self.tenor.export(outfile, level, namespace_, name_='tenor', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'limitId':
            obj_ = LimitId.factory()
            obj_.build(child_)
            self.limitId = obj_
            obj_.original_tagname_ = 'limitId'
        elif nodeName_ == 'primaryAssetClass':
            obj_ = AssetClass.factory()
            obj_.build(child_)
            self.primaryAssetClass = obj_
            obj_.original_tagname_ = 'primaryAssetClass'
        elif nodeName_ == 'secondaryAssetClass':
            obj_ = AssetClass.factory()
            obj_.build(child_)
            self.secondaryAssetClass.append(obj_)
            obj_.original_tagname_ = 'secondaryAssetClass'
        elif nodeName_ == 'productType':
            obj_ = ProductType.factory()
            obj_.build(child_)
            self.productType.append(obj_)
            obj_.original_tagname_ = 'productType'
        elif nodeName_ == 'productId':
            obj_ = ProductId.factory()
            obj_.build(child_)
            self.productId.append(obj_)
            obj_.original_tagname_ = 'productId'
        elif nodeName_ == 'productId':
            obj_ = ProductId.factory()
            obj_.build(child_)
            self.productId.append(obj_)
            obj_.original_tagname_ = 'productId'
        elif nodeName_ == 'assetClass':
            obj_ = AssetClass.factory()
            obj_.build(child_)
            self.assetClass.append(obj_)
            obj_.original_tagname_ = 'assetClass'
        elif nodeName_ == 'embeddedOptionType':
            obj_ = EmbeddedOptionType.factory()
            obj_.build(child_)
            self.embeddedOptionType.append(obj_)
            obj_.original_tagname_ = 'embeddedOptionType'
        elif nodeName_ == 'currency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'tenor':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.tenor = obj_
            obj_.original_tagname_ = 'tenor'
# end class CreditLimitBase


class CreditLimit(CreditLimitBase):
    """A structure describing a credit limit with applicability
    constraints."""
    member_data_items_ = {
        'limitApplicable': MemberSpec_('limitApplicable', 'LimitApplicable', 1),
        'expirationDate': MemberSpec_('expirationDate', 'xsd:dateTime', 0),
    }
    subclass = None
    superclass = CreditLimitBase
    def __init__(self, limitId=None, primaryAssetClass=None, secondaryAssetClass=None, productType=None, productId=None, assetClass=None, embeddedOptionType=None, currency=None, tenor=None, limitApplicable=None, expirationDate=None):
        self.original_tagname_ = None
        super(CreditLimit, self).__init__(limitId, primaryAssetClass, secondaryAssetClass, productType, productId, assetClass, embeddedOptionType, currency, tenor, )
        if limitApplicable is None:
            self.limitApplicable = []
        else:
            self.limitApplicable = limitApplicable
        if isinstance(expirationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(expirationDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = expirationDate
        self.expirationDate = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditLimit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditLimit.subclass:
            return CreditLimit.subclass(*args_, **kwargs_)
        else:
            return CreditLimit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_limitApplicable(self): return self.limitApplicable
    def set_limitApplicable(self, limitApplicable): self.limitApplicable = limitApplicable
    def add_limitApplicable(self, value): self.limitApplicable.append(value)
    def insert_limitApplicable_at(self, index, value): self.limitApplicable.insert(index, value)
    def replace_limitApplicable_at(self, index, value): self.limitApplicable[index] = value
    def get_expirationDate(self): return self.expirationDate
    def set_expirationDate(self, expirationDate): self.expirationDate = expirationDate
    def hasContent_(self):
        if (
            self.limitApplicable or
            self.expirationDate is not None or
            super(CreditLimit, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditLimit', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditLimit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditLimit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditLimit'):
        super(CreditLimit, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CreditLimit')
    def exportChildren(self, outfile, level, namespace_='', name_='CreditLimit', fromsubclass_=False, pretty_print=True):
        super(CreditLimit, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for limitApplicable_ in self.limitApplicable:
            limitApplicable_.export(outfile, level, namespace_, name_='limitApplicable', pretty_print=pretty_print)
        if self.expirationDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexpirationDate>%s</%sexpirationDate>%s' % (namespace_, self.gds_format_datetime(self.expirationDate, input_name='expirationDate'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CreditLimit, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'limitApplicable':
            obj_ = LimitApplicable.factory()
            obj_.build(child_)
            self.limitApplicable.append(obj_)
            obj_.original_tagname_ = 'limitApplicable'
        elif nodeName_ == 'expirationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.expirationDate = dval_
        super(CreditLimit, self).buildChildren(child_, node, nodeName_, True)
# end class CreditLimit


class CreditLimitInformation(GeneratedsSuper):
    member_data_items_ = {
        'partyInformation': MemberSpec_('partyInformation', 'PartyTradeInformation', 0),
        'limitModel': MemberSpec_('limitModel', ['LimitModelEnum', 'Token', 'xsd:token'], 0),
        'creditLimit': MemberSpec_('creditLimit', 'CreditLimit', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, partyInformation=None, limitModel=None, creditLimit=None):
        self.original_tagname_ = None
        self.partyInformation = partyInformation
        self.limitModel = limitModel
        self.validate_LimitModelEnum(self.limitModel)
        if creditLimit is None:
            self.creditLimit = []
        else:
            self.creditLimit = creditLimit
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditLimitInformation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditLimitInformation.subclass:
            return CreditLimitInformation.subclass(*args_, **kwargs_)
        else:
            return CreditLimitInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyInformation(self): return self.partyInformation
    def set_partyInformation(self, partyInformation): self.partyInformation = partyInformation
    def get_limitModel(self): return self.limitModel
    def set_limitModel(self, limitModel): self.limitModel = limitModel
    def get_creditLimit(self): return self.creditLimit
    def set_creditLimit(self, creditLimit): self.creditLimit = creditLimit
    def add_creditLimit(self, value): self.creditLimit.append(value)
    def insert_creditLimit_at(self, index, value): self.creditLimit.insert(index, value)
    def replace_creditLimit_at(self, index, value): self.creditLimit[index] = value
    def validate_LimitModelEnum(self, value):
        # Validate type LimitModelEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Ping', 'Plus1ToStop', 'Plus1ToPing', 'PushToPing', 'PushToStop']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on LimitModelEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on LimitModelEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.partyInformation is not None or
            self.limitModel is not None or
            self.creditLimit
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditLimitInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditLimitInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditLimitInformation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditLimitInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CreditLimitInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.partyInformation is not None:
            self.partyInformation.export(outfile, level, namespace_, name_='partyInformation', pretty_print=pretty_print)
        if self.limitModel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slimitModel>%s</%slimitModel>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.limitModel), input_name='limitModel')), namespace_, eol_))
        for creditLimit_ in self.creditLimit:
            creditLimit_.export(outfile, level, namespace_, name_='creditLimit', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'partyInformation':
            obj_ = PartyTradeInformation.factory()
            obj_.build(child_)
            self.partyInformation = obj_
            obj_.original_tagname_ = 'partyInformation'
        elif nodeName_ == 'limitModel':
            limitModel_ = child_.text
            limitModel_ = re_.sub(String_cleanup_pat_, " ", limitModel_).strip()
            limitModel_ = self.gds_validate_string(limitModel_, node, 'limitModel')
            self.limitModel = limitModel_
            # validate type LimitModelEnum
            self.validate_LimitModelEnum(self.limitModel)
        elif nodeName_ == 'creditLimit':
            obj_ = CreditLimit.factory()
            obj_.build(child_)
            self.creditLimit.append(obj_)
            obj_.original_tagname_ = 'creditLimit'
# end class CreditLimitInformation


class CreditLimitReference(GeneratedsSuper):
    member_data_items_ = {
        'approvingPartyReference': MemberSpec_('approvingPartyReference', 'PartyReference', 0),
        'approvalId': MemberSpec_('approvalId', 'ApprovalId', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, approvingPartyReference=None, approvalId=None):
        self.original_tagname_ = None
        self.approvingPartyReference = approvingPartyReference
        self.approvalId = approvalId
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditLimitReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditLimitReference.subclass:
            return CreditLimitReference.subclass(*args_, **kwargs_)
        else:
            return CreditLimitReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_approvingPartyReference(self): return self.approvingPartyReference
    def set_approvingPartyReference(self, approvingPartyReference): self.approvingPartyReference = approvingPartyReference
    def get_approvalId(self): return self.approvalId
    def set_approvalId(self, approvalId): self.approvalId = approvalId
    def hasContent_(self):
        if (
            self.approvingPartyReference is not None or
            self.approvalId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditLimitReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditLimitReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditLimitReference', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditLimitReference'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CreditLimitReference', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.approvingPartyReference is not None:
            self.approvingPartyReference.export(outfile, level, namespace_, name_='approvingPartyReference', pretty_print=pretty_print)
        if self.approvalId is not None:
            self.approvalId.export(outfile, level, namespace_, name_='approvalId', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'approvingPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.approvingPartyReference = obj_
            obj_.original_tagname_ = 'approvingPartyReference'
        elif nodeName_ == 'approvalId':
            obj_ = ApprovalId.factory()
            obj_.build(child_)
            self.approvalId = obj_
            obj_.original_tagname_ = 'approvalId'
# end class CreditLimitReference


class CreditLimitUtilization(GeneratedsSuper):
    member_data_items_ = {
        'executed': MemberSpec_('executed', 'CreditLimitUtilizationPosition', 0),
        'pending': MemberSpec_('pending', 'CreditLimitUtilizationPosition', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, executed=None, pending=None):
        self.original_tagname_ = None
        self.executed = executed
        self.pending = pending
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditLimitUtilization)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditLimitUtilization.subclass:
            return CreditLimitUtilization.subclass(*args_, **kwargs_)
        else:
            return CreditLimitUtilization(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_executed(self): return self.executed
    def set_executed(self, executed): self.executed = executed
    def get_pending(self): return self.pending
    def set_pending(self, pending): self.pending = pending
    def hasContent_(self):
        if (
            self.executed is not None or
            self.pending is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditLimitUtilization', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditLimitUtilization')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditLimitUtilization', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditLimitUtilization'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CreditLimitUtilization', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.executed is not None:
            self.executed.export(outfile, level, namespace_, name_='executed', pretty_print=pretty_print)
        if self.pending is not None:
            self.pending.export(outfile, level, namespace_, name_='pending', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'executed':
            obj_ = CreditLimitUtilizationPosition.factory()
            obj_.build(child_)
            self.executed = obj_
            obj_.original_tagname_ = 'executed'
        elif nodeName_ == 'pending':
            obj_ = CreditLimitUtilizationPosition.factory()
            obj_.build(child_)
            self.pending = obj_
            obj_.original_tagname_ = 'pending'
# end class CreditLimitUtilization


class CreditLimitUtilizationPosition(GeneratedsSuper):
    member_data_items_ = {
        'short': MemberSpec_('short', ['NonNegativeDecimal', 'xsd:decimal'], 0),
        'long': MemberSpec_('long', ['NonNegativeDecimal', 'xsd:decimal'], 0),
        'global_': MemberSpec_('global_', ['NonNegativeDecimal', 'xsd:decimal'], 0),
        'global_': MemberSpec_('global_', ['NonNegativeDecimal', 'xsd:decimal'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, short=None, long=None, global_=None):
        self.original_tagname_ = None
        self.short = short
        self.validate_NonNegativeDecimal(self.short)
        self.long = long
        self.validate_NonNegativeDecimal(self.long)
        self.global_ = global_
        self.validate_NonNegativeDecimal(self.global_)
        self.global_ = global_
        self.validate_NonNegativeDecimal(self.global_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditLimitUtilizationPosition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditLimitUtilizationPosition.subclass:
            return CreditLimitUtilizationPosition.subclass(*args_, **kwargs_)
        else:
            return CreditLimitUtilizationPosition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_short(self): return self.short
    def set_short(self, short): self.short = short
    def get_long(self): return self.long
    def set_long(self, long): self.long = long
    def get_global(self): return self.global_
    def set_global(self, global_): self.global_ = global_
    def get_global(self): return self.global_
    def set_global(self, global_): self.global_ = global_
    def validate_NonNegativeDecimal(self, value):
        # Validate type NonNegativeDecimal, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on NonNegativeDecimal' % {"value" : value} )
    def hasContent_(self):
        if (
            self.short is not None or
            self.long is not None or
            self.global_ is not None or
            self.global_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditLimitUtilizationPosition', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditLimitUtilizationPosition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditLimitUtilizationPosition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditLimitUtilizationPosition'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CreditLimitUtilizationPosition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.short is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sshort>%s</%sshort>%s' % (namespace_, self.gds_format_float(self.short, input_name='short'), namespace_, eol_))
        if self.long is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slong>%s</%slong>%s' % (namespace_, self.gds_format_float(self.long, input_name='long'), namespace_, eol_))
        if self.global_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sglobal>%s</%sglobal>%s' % (namespace_, self.gds_format_float(self.global_, input_name='global'), namespace_, eol_))
        if self.global_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sglobal>%s</%sglobal>%s' % (namespace_, self.gds_format_float(self.global_, input_name='global'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'short':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'short')
            self.short = fval_
            # validate type NonNegativeDecimal
            self.validate_NonNegativeDecimal(self.short)
        elif nodeName_ == 'long':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'long')
            self.long = fval_
            # validate type NonNegativeDecimal
            self.validate_NonNegativeDecimal(self.long)
        elif nodeName_ == 'global':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'global')
            self.global_ = fval_
            # validate type NonNegativeDecimal
            self.validate_NonNegativeDecimal(self.global_)
        elif nodeName_ == 'global':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'global')
            self.global_ = fval_
            # validate type NonNegativeDecimal
            self.validate_NonNegativeDecimal(self.global_)
# end class CreditLimitUtilizationPosition


class DeClear(GeneratedsSuper):
    """A structure describing a declear event. The deClear event allows a
    firm to request that a trade be removed from clearing, or a
    clearing service to request consent for this, or to report that
    is has been done."""
    member_data_items_ = {
        'tradeIdentifier': MemberSpec_('tradeIdentifier', 'PartyTradeIdentifier', 1),
        'effectiveDate': MemberSpec_('effectiveDate', 'xsd:date', 0),
        'reason': MemberSpec_('reason', 'DeclearReason', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, tradeIdentifier=None, effectiveDate=None, reason=None):
        self.original_tagname_ = None
        if tradeIdentifier is None:
            self.tradeIdentifier = []
        else:
            self.tradeIdentifier = tradeIdentifier
        if isinstance(effectiveDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(effectiveDate, '%Y-%m-%d').date()
        else:
            initvalue_ = effectiveDate
        self.effectiveDate = initvalue_
        self.reason = reason
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DeClear)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DeClear.subclass:
            return DeClear.subclass(*args_, **kwargs_)
        else:
            return DeClear(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tradeIdentifier(self): return self.tradeIdentifier
    def set_tradeIdentifier(self, tradeIdentifier): self.tradeIdentifier = tradeIdentifier
    def add_tradeIdentifier(self, value): self.tradeIdentifier.append(value)
    def insert_tradeIdentifier_at(self, index, value): self.tradeIdentifier.insert(index, value)
    def replace_tradeIdentifier_at(self, index, value): self.tradeIdentifier[index] = value
    def get_effectiveDate(self): return self.effectiveDate
    def set_effectiveDate(self, effectiveDate): self.effectiveDate = effectiveDate
    def get_reason(self): return self.reason
    def set_reason(self, reason): self.reason = reason
    def hasContent_(self):
        if (
            self.tradeIdentifier or
            self.effectiveDate is not None or
            self.reason is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DeClear', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeClear')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DeClear', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DeClear'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DeClear', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for tradeIdentifier_ in self.tradeIdentifier:
            tradeIdentifier_.export(outfile, level, namespace_, name_='tradeIdentifier', pretty_print=pretty_print)
        if self.effectiveDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%seffectiveDate>%s</%seffectiveDate>%s' % (namespace_, self.gds_format_date(self.effectiveDate, input_name='effectiveDate'), namespace_, eol_))
        if self.reason is not None:
            self.reason.export(outfile, level, namespace_, name_='reason', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tradeIdentifier':
            obj_ = PartyTradeIdentifier.factory()
            obj_.build(child_)
            self.tradeIdentifier.append(obj_)
            obj_.original_tagname_ = 'tradeIdentifier'
        elif nodeName_ == 'effectiveDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.effectiveDate = dval_
        elif nodeName_ == 'reason':
            obj_ = DeclearReason.factory()
            obj_.build(child_)
            self.reason = obj_
            obj_.original_tagname_ = 'reason'
# end class DeClear


class DeclearReason(GeneratedsSuper):
    """A type that describes why a trade was removed from clearing."""
    member_data_items_ = {
        'declearReasonScheme': MemberSpec_('declearReasonScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, declearReasonScheme='http://www.fpml.org/coding-scheme/declear-reason', valueOf_=None):
        self.original_tagname_ = None
        self.declearReasonScheme = _cast(None, declearReasonScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DeclearReason)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DeclearReason.subclass:
            return DeclearReason.subclass(*args_, **kwargs_)
        else:
            return DeclearReason(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_declearReasonScheme(self): return self.declearReasonScheme
    def set_declearReasonScheme(self, declearReasonScheme): self.declearReasonScheme = declearReasonScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DeclearReason', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeclearReason')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DeclearReason', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DeclearReason'):
        if self.declearReasonScheme != "http://www.fpml.org/coding-scheme/declear-reason" and 'declearReasonScheme' not in already_processed:
            already_processed.add('declearReasonScheme')
            outfile.write(' declearReasonScheme=%s' % (quote_attrib(self.declearReasonScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DeclearReason', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('declearReasonScheme', node)
        if value is not None and 'declearReasonScheme' not in already_processed:
            already_processed.add('declearReasonScheme')
            self.declearReasonScheme = value
            self.validate_NonEmptyURI(self.declearReasonScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DeclearReason


class EventId(GeneratedsSuper):
    """A post-trade event reference identifier allocated by a party. FpML
    does not define the domain values associated with this element.
    Note that the domain values for this element are not strictly an
    enumerated list."""
    member_data_items_ = {
        'eventIdScheme': MemberSpec_('eventIdScheme', 'NonEmptyURI', 0),
        'id': MemberSpec_('id', 'xsd:string', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, eventIdScheme=None, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.eventIdScheme = _cast(None, eventIdScheme)
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EventId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EventId.subclass:
            return EventId.subclass(*args_, **kwargs_)
        else:
            return EventId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_eventIdScheme(self): return self.eventIdScheme
    def set_eventIdScheme(self, eventIdScheme): self.eventIdScheme = eventIdScheme
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EventId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EventId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EventId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EventId'):
        if self.eventIdScheme is not None and 'eventIdScheme' not in already_processed:
            already_processed.add('eventIdScheme')
            outfile.write(' eventIdScheme=%s' % (quote_attrib(self.eventIdScheme), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EventId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('eventIdScheme', node)
        if value is not None and 'eventIdScheme' not in already_processed:
            already_processed.add('eventIdScheme')
            self.eventIdScheme = value
            self.validate_NonEmptyURI(self.eventIdScheme)    # validate type NonEmptyURI
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EventId


class EventProposedMatch(GeneratedsSuper):
    """A structure that describes a proposed match between trades or post-
    trade event reports."""
    member_data_items_ = {
        'tradePackage': MemberSpec_('tradePackage', 'TradePackage', 0),
        'originatingEvent': MemberSpec_('originatingEvent', 'OriginatingEvent', 0),
        'trade': MemberSpec_('trade', 'Trade', 0),
        'tradingEvent': MemberSpec_('tradingEvent', 'TradingEventSummary', 1),
        'amendment': MemberSpec_('amendment', 'TradeAmendmentContent', 0),
        'increase': MemberSpec_('increase', 'TradeNotionalChange', 0),
        'terminatingEvent': MemberSpec_('terminatingEvent', 'TerminatingEvent', 0),
        'termination': MemberSpec_('termination', 'TradeNotionalChange', 0),
        'novation': MemberSpec_('novation', 'TradeNovationContent', 0),
        'change': MemberSpec_('change', 'TradeChangeContent', 0),
        'optionExercise': MemberSpec_('optionExercise', 'OptionExercise', 0),
        'optionExpiry': MemberSpec_('optionExpiry', 'OptionExpiry', 1),
        'optionEvent': MemberSpec_('optionEvent', 'OptionEvent', 0),
        'withdrawal': MemberSpec_('withdrawal', 'Withdrawal', 0),
        'matchId': MemberSpec_('matchId', 'MatchId', 0),
        'difference': MemberSpec_('difference', 'TradeDifference', 1),
        'matchScore': MemberSpec_('matchScore', 'xsd:decimal', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, tradePackage=None, originatingEvent=None, trade=None, tradingEvent=None, amendment=None, increase=None, terminatingEvent=None, termination=None, novation=None, change=None, optionExercise=None, optionExpiry=None, optionEvent=None, withdrawal=None, matchId=None, difference=None, matchScore=None):
        self.original_tagname_ = None
        self.tradePackage = tradePackage
        self.originatingEvent = originatingEvent
        self.trade = trade
        if tradingEvent is None:
            self.tradingEvent = []
        else:
            self.tradingEvent = tradingEvent
        self.amendment = amendment
        self.increase = increase
        self.terminatingEvent = terminatingEvent
        self.termination = termination
        self.novation = novation
        self.change = change
        self.optionExercise = optionExercise
        if optionExpiry is None:
            self.optionExpiry = []
        else:
            self.optionExpiry = optionExpiry
        self.optionEvent = optionEvent
        self.withdrawal = withdrawal
        self.matchId = matchId
        if difference is None:
            self.difference = []
        else:
            self.difference = difference
        self.matchScore = matchScore
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EventProposedMatch)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EventProposedMatch.subclass:
            return EventProposedMatch.subclass(*args_, **kwargs_)
        else:
            return EventProposedMatch(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tradePackage(self): return self.tradePackage
    def set_tradePackage(self, tradePackage): self.tradePackage = tradePackage
    def get_originatingEvent(self): return self.originatingEvent
    def set_originatingEvent(self, originatingEvent): self.originatingEvent = originatingEvent
    def get_trade(self): return self.trade
    def set_trade(self, trade): self.trade = trade
    def get_tradingEvent(self): return self.tradingEvent
    def set_tradingEvent(self, tradingEvent): self.tradingEvent = tradingEvent
    def add_tradingEvent(self, value): self.tradingEvent.append(value)
    def insert_tradingEvent_at(self, index, value): self.tradingEvent.insert(index, value)
    def replace_tradingEvent_at(self, index, value): self.tradingEvent[index] = value
    def get_amendment(self): return self.amendment
    def set_amendment(self, amendment): self.amendment = amendment
    def get_increase(self): return self.increase
    def set_increase(self, increase): self.increase = increase
    def get_terminatingEvent(self): return self.terminatingEvent
    def set_terminatingEvent(self, terminatingEvent): self.terminatingEvent = terminatingEvent
    def get_termination(self): return self.termination
    def set_termination(self, termination): self.termination = termination
    def get_novation(self): return self.novation
    def set_novation(self, novation): self.novation = novation
    def get_change(self): return self.change
    def set_change(self, change): self.change = change
    def get_optionExercise(self): return self.optionExercise
    def set_optionExercise(self, optionExercise): self.optionExercise = optionExercise
    def get_optionExpiry(self): return self.optionExpiry
    def set_optionExpiry(self, optionExpiry): self.optionExpiry = optionExpiry
    def add_optionExpiry(self, value): self.optionExpiry.append(value)
    def insert_optionExpiry_at(self, index, value): self.optionExpiry.insert(index, value)
    def replace_optionExpiry_at(self, index, value): self.optionExpiry[index] = value
    def get_optionEvent(self): return self.optionEvent
    def set_optionEvent(self, optionEvent): self.optionEvent = optionEvent
    def get_withdrawal(self): return self.withdrawal
    def set_withdrawal(self, withdrawal): self.withdrawal = withdrawal
    def get_matchId(self): return self.matchId
    def set_matchId(self, matchId): self.matchId = matchId
    def get_difference(self): return self.difference
    def set_difference(self, difference): self.difference = difference
    def add_difference(self, value): self.difference.append(value)
    def insert_difference_at(self, index, value): self.difference.insert(index, value)
    def replace_difference_at(self, index, value): self.difference[index] = value
    def get_matchScore(self): return self.matchScore
    def set_matchScore(self, matchScore): self.matchScore = matchScore
    def hasContent_(self):
        if (
            self.tradePackage is not None or
            self.originatingEvent is not None or
            self.trade is not None or
            self.tradingEvent or
            self.amendment is not None or
            self.increase is not None or
            self.terminatingEvent is not None or
            self.termination is not None or
            self.novation is not None or
            self.change is not None or
            self.optionExercise is not None or
            self.optionExpiry or
            self.optionEvent is not None or
            self.withdrawal is not None or
            self.matchId is not None or
            self.difference or
            self.matchScore is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EventProposedMatch', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EventProposedMatch')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EventProposedMatch', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EventProposedMatch'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EventProposedMatch', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tradePackage is not None:
            self.tradePackage.export(outfile, level, namespace_, name_='tradePackage', pretty_print=pretty_print)
        if self.originatingEvent is not None:
            self.originatingEvent.export(outfile, level, namespace_, name_='originatingEvent', pretty_print=pretty_print)
        if self.trade is not None:
            self.trade.export(outfile, level, namespace_, name_='trade', pretty_print=pretty_print)
        for tradingEvent_ in self.tradingEvent:
            tradingEvent_.export(outfile, level, namespace_, name_='tradingEvent', pretty_print=pretty_print)
        if self.amendment is not None:
            self.amendment.export(outfile, level, namespace_, name_='amendment', pretty_print=pretty_print)
        if self.increase is not None:
            self.increase.export(outfile, level, namespace_, name_='increase', pretty_print=pretty_print)
        if self.terminatingEvent is not None:
            self.terminatingEvent.export(outfile, level, namespace_, name_='terminatingEvent', pretty_print=pretty_print)
        if self.termination is not None:
            self.termination.export(outfile, level, namespace_, name_='termination', pretty_print=pretty_print)
        if self.novation is not None:
            self.novation.export(outfile, level, namespace_, name_='novation', pretty_print=pretty_print)
        if self.change is not None:
            self.change.export(outfile, level, namespace_, name_='change', pretty_print=pretty_print)
        if self.optionExercise is not None:
            self.optionExercise.export(outfile, level, namespace_, name_='optionExercise', pretty_print=pretty_print)
        for optionExpiry_ in self.optionExpiry:
            optionExpiry_.export(outfile, level, namespace_, name_='optionExpiry', pretty_print=pretty_print)
        if self.optionEvent is not None:
            self.optionEvent.export(outfile, level, namespace_, name_='optionEvent', pretty_print=pretty_print)
        if self.withdrawal is not None:
            self.withdrawal.export(outfile, level, namespace_, name_='withdrawal', pretty_print=pretty_print)
        if self.matchId is not None:
            self.matchId.export(outfile, level, namespace_, name_='matchId', pretty_print=pretty_print)
        for difference_ in self.difference:
            difference_.export(outfile, level, namespace_, name_='difference', pretty_print=pretty_print)
        if self.matchScore is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smatchScore>%s</%smatchScore>%s' % (namespace_, self.gds_format_float(self.matchScore, input_name='matchScore'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tradePackage':
            obj_ = TradePackage.factory()
            obj_.build(child_)
            self.tradePackage = obj_
            obj_.original_tagname_ = 'tradePackage'
        elif nodeName_ == 'originatingEvent':
            obj_ = OriginatingEvent.factory()
            obj_.build(child_)
            self.originatingEvent = obj_
            obj_.original_tagname_ = 'originatingEvent'
        elif nodeName_ == 'trade':
            obj_ = Trade.factory()
            obj_.build(child_)
            self.trade = obj_
            obj_.original_tagname_ = 'trade'
        elif nodeName_ == 'tradingEvent':
            obj_ = TradingEventSummary.factory()
            obj_.build(child_)
            self.tradingEvent.append(obj_)
            obj_.original_tagname_ = 'tradingEvent'
        elif nodeName_ == 'amendment':
            obj_ = TradeAmendmentContent.factory()
            obj_.build(child_)
            self.amendment = obj_
            obj_.original_tagname_ = 'amendment'
        elif nodeName_ == 'increase':
            obj_ = TradeNotionalChange.factory()
            obj_.build(child_)
            self.increase = obj_
            obj_.original_tagname_ = 'increase'
        elif nodeName_ == 'terminatingEvent':
            obj_ = TerminatingEvent.factory()
            obj_.build(child_)
            self.terminatingEvent = obj_
            obj_.original_tagname_ = 'terminatingEvent'
        elif nodeName_ == 'termination':
            obj_ = TradeNotionalChange.factory()
            obj_.build(child_)
            self.termination = obj_
            obj_.original_tagname_ = 'termination'
        elif nodeName_ == 'novation':
            obj_ = TradeNovationContent.factory()
            obj_.build(child_)
            self.novation = obj_
            obj_.original_tagname_ = 'novation'
        elif nodeName_ == 'change':
            obj_ = TradeChangeContent.factory()
            obj_.build(child_)
            self.change = obj_
            obj_.original_tagname_ = 'change'
        elif nodeName_ == 'optionExercise':
            obj_ = OptionExercise.factory()
            obj_.build(child_)
            self.optionExercise = obj_
            obj_.original_tagname_ = 'optionExercise'
        elif nodeName_ == 'optionExpiry':
            obj_ = OptionExpiry.factory()
            obj_.build(child_)
            self.optionExpiry.append(obj_)
            obj_.original_tagname_ = 'optionExpiry'
        elif nodeName_ == 'optionEvent':
            obj_ = OptionEvent.factory()
            obj_.build(child_)
            self.optionEvent = obj_
            obj_.original_tagname_ = 'optionEvent'
        elif nodeName_ == 'withdrawal':
            obj_ = Withdrawal.factory()
            obj_.build(child_)
            self.withdrawal = obj_
            obj_.original_tagname_ = 'withdrawal'
        elif nodeName_ == 'matchId':
            obj_ = MatchId.factory()
            obj_.build(child_)
            self.matchId = obj_
            obj_.original_tagname_ = 'matchId'
        elif nodeName_ == 'difference':
            obj_ = TradeDifference.factory()
            obj_.build(child_)
            self.difference.append(obj_)
            obj_.original_tagname_ = 'difference'
        elif nodeName_ == 'matchScore':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'matchScore')
            self.matchScore = fval_
# end class EventProposedMatch


class EventsChoice(GeneratedsSuper):
    member_data_items_ = {
        'tradePackage': MemberSpec_('tradePackage', 'TradePackage', 0),
        'originatingEvent': MemberSpec_('originatingEvent', 'OriginatingEvent', 0),
        'trade': MemberSpec_('trade', 'Trade', 0),
        'tradingEvent': MemberSpec_('tradingEvent', 'TradingEventSummary', 1),
        'amendment': MemberSpec_('amendment', 'TradeAmendmentContent', 0),
        'increase': MemberSpec_('increase', 'TradeNotionalChange', 0),
        'terminatingEvent': MemberSpec_('terminatingEvent', 'TerminatingEvent', 0),
        'termination': MemberSpec_('termination', 'TradeNotionalChange', 0),
        'novation': MemberSpec_('novation', 'TradeNovationContent', 0),
        'change': MemberSpec_('change', 'TradeChangeContent', 0),
        'optionExercise': MemberSpec_('optionExercise', 'OptionExercise', 0),
        'optionExpiry': MemberSpec_('optionExpiry', 'OptionExpiry', 1),
        'optionEvent': MemberSpec_('optionEvent', 'OptionEvent', 0),
        'withdrawal': MemberSpec_('withdrawal', 'Withdrawal', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, tradePackage=None, originatingEvent=None, trade=None, tradingEvent=None, amendment=None, increase=None, terminatingEvent=None, termination=None, novation=None, change=None, optionExercise=None, optionExpiry=None, optionEvent=None, withdrawal=None):
        self.original_tagname_ = None
        self.tradePackage = tradePackage
        self.originatingEvent = originatingEvent
        self.trade = trade
        if tradingEvent is None:
            self.tradingEvent = []
        else:
            self.tradingEvent = tradingEvent
        self.amendment = amendment
        self.increase = increase
        self.terminatingEvent = terminatingEvent
        self.termination = termination
        self.novation = novation
        self.change = change
        self.optionExercise = optionExercise
        if optionExpiry is None:
            self.optionExpiry = []
        else:
            self.optionExpiry = optionExpiry
        self.optionEvent = optionEvent
        self.withdrawal = withdrawal
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EventsChoice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EventsChoice.subclass:
            return EventsChoice.subclass(*args_, **kwargs_)
        else:
            return EventsChoice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tradePackage(self): return self.tradePackage
    def set_tradePackage(self, tradePackage): self.tradePackage = tradePackage
    def get_originatingEvent(self): return self.originatingEvent
    def set_originatingEvent(self, originatingEvent): self.originatingEvent = originatingEvent
    def get_trade(self): return self.trade
    def set_trade(self, trade): self.trade = trade
    def get_tradingEvent(self): return self.tradingEvent
    def set_tradingEvent(self, tradingEvent): self.tradingEvent = tradingEvent
    def add_tradingEvent(self, value): self.tradingEvent.append(value)
    def insert_tradingEvent_at(self, index, value): self.tradingEvent.insert(index, value)
    def replace_tradingEvent_at(self, index, value): self.tradingEvent[index] = value
    def get_amendment(self): return self.amendment
    def set_amendment(self, amendment): self.amendment = amendment
    def get_increase(self): return self.increase
    def set_increase(self, increase): self.increase = increase
    def get_terminatingEvent(self): return self.terminatingEvent
    def set_terminatingEvent(self, terminatingEvent): self.terminatingEvent = terminatingEvent
    def get_termination(self): return self.termination
    def set_termination(self, termination): self.termination = termination
    def get_novation(self): return self.novation
    def set_novation(self, novation): self.novation = novation
    def get_change(self): return self.change
    def set_change(self, change): self.change = change
    def get_optionExercise(self): return self.optionExercise
    def set_optionExercise(self, optionExercise): self.optionExercise = optionExercise
    def get_optionExpiry(self): return self.optionExpiry
    def set_optionExpiry(self, optionExpiry): self.optionExpiry = optionExpiry
    def add_optionExpiry(self, value): self.optionExpiry.append(value)
    def insert_optionExpiry_at(self, index, value): self.optionExpiry.insert(index, value)
    def replace_optionExpiry_at(self, index, value): self.optionExpiry[index] = value
    def get_optionEvent(self): return self.optionEvent
    def set_optionEvent(self, optionEvent): self.optionEvent = optionEvent
    def get_withdrawal(self): return self.withdrawal
    def set_withdrawal(self, withdrawal): self.withdrawal = withdrawal
    def hasContent_(self):
        if (
            self.tradePackage is not None or
            self.originatingEvent is not None or
            self.trade is not None or
            self.tradingEvent or
            self.amendment is not None or
            self.increase is not None or
            self.terminatingEvent is not None or
            self.termination is not None or
            self.novation is not None or
            self.change is not None or
            self.optionExercise is not None or
            self.optionExpiry or
            self.optionEvent is not None or
            self.withdrawal is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EventsChoice', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EventsChoice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EventsChoice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EventsChoice'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EventsChoice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tradePackage is not None:
            self.tradePackage.export(outfile, level, namespace_, name_='tradePackage', pretty_print=pretty_print)
        if self.originatingEvent is not None:
            self.originatingEvent.export(outfile, level, namespace_, name_='originatingEvent', pretty_print=pretty_print)
        if self.trade is not None:
            self.trade.export(outfile, level, namespace_, name_='trade', pretty_print=pretty_print)
        for tradingEvent_ in self.tradingEvent:
            tradingEvent_.export(outfile, level, namespace_, name_='tradingEvent', pretty_print=pretty_print)
        if self.amendment is not None:
            self.amendment.export(outfile, level, namespace_, name_='amendment', pretty_print=pretty_print)
        if self.increase is not None:
            self.increase.export(outfile, level, namespace_, name_='increase', pretty_print=pretty_print)
        if self.terminatingEvent is not None:
            self.terminatingEvent.export(outfile, level, namespace_, name_='terminatingEvent', pretty_print=pretty_print)
        if self.termination is not None:
            self.termination.export(outfile, level, namespace_, name_='termination', pretty_print=pretty_print)
        if self.novation is not None:
            self.novation.export(outfile, level, namespace_, name_='novation', pretty_print=pretty_print)
        if self.change is not None:
            self.change.export(outfile, level, namespace_, name_='change', pretty_print=pretty_print)
        if self.optionExercise is not None:
            self.optionExercise.export(outfile, level, namespace_, name_='optionExercise', pretty_print=pretty_print)
        for optionExpiry_ in self.optionExpiry:
            optionExpiry_.export(outfile, level, namespace_, name_='optionExpiry', pretty_print=pretty_print)
        if self.optionEvent is not None:
            self.optionEvent.export(outfile, level, namespace_, name_='optionEvent', pretty_print=pretty_print)
        if self.withdrawal is not None:
            self.withdrawal.export(outfile, level, namespace_, name_='withdrawal', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tradePackage':
            obj_ = TradePackage.factory()
            obj_.build(child_)
            self.tradePackage = obj_
            obj_.original_tagname_ = 'tradePackage'
        elif nodeName_ == 'originatingEvent':
            obj_ = OriginatingEvent.factory()
            obj_.build(child_)
            self.originatingEvent = obj_
            obj_.original_tagname_ = 'originatingEvent'
        elif nodeName_ == 'trade':
            obj_ = Trade.factory()
            obj_.build(child_)
            self.trade = obj_
            obj_.original_tagname_ = 'trade'
        elif nodeName_ == 'tradingEvent':
            obj_ = TradingEventSummary.factory()
            obj_.build(child_)
            self.tradingEvent.append(obj_)
            obj_.original_tagname_ = 'tradingEvent'
        elif nodeName_ == 'amendment':
            obj_ = TradeAmendmentContent.factory()
            obj_.build(child_)
            self.amendment = obj_
            obj_.original_tagname_ = 'amendment'
        elif nodeName_ == 'increase':
            obj_ = TradeNotionalChange.factory()
            obj_.build(child_)
            self.increase = obj_
            obj_.original_tagname_ = 'increase'
        elif nodeName_ == 'terminatingEvent':
            obj_ = TerminatingEvent.factory()
            obj_.build(child_)
            self.terminatingEvent = obj_
            obj_.original_tagname_ = 'terminatingEvent'
        elif nodeName_ == 'termination':
            obj_ = TradeNotionalChange.factory()
            obj_.build(child_)
            self.termination = obj_
            obj_.original_tagname_ = 'termination'
        elif nodeName_ == 'novation':
            obj_ = TradeNovationContent.factory()
            obj_.build(child_)
            self.novation = obj_
            obj_.original_tagname_ = 'novation'
        elif nodeName_ == 'change':
            obj_ = TradeChangeContent.factory()
            obj_.build(child_)
            self.change = obj_
            obj_.original_tagname_ = 'change'
        elif nodeName_ == 'optionExercise':
            obj_ = OptionExercise.factory()
            obj_.build(child_)
            self.optionExercise = obj_
            obj_.original_tagname_ = 'optionExercise'
        elif nodeName_ == 'optionExpiry':
            obj_ = OptionExpiry.factory()
            obj_.build(child_)
            self.optionExpiry.append(obj_)
            obj_.original_tagname_ = 'optionExpiry'
        elif nodeName_ == 'optionEvent':
            obj_ = OptionEvent.factory()
            obj_.build(child_)
            self.optionEvent = obj_
            obj_.original_tagname_ = 'optionEvent'
        elif nodeName_ == 'withdrawal':
            obj_ = Withdrawal.factory()
            obj_.build(child_)
            self.withdrawal = obj_
            obj_.original_tagname_ = 'withdrawal'
# end class EventsChoice


class EventType(GeneratedsSuper):
    member_data_items_ = {
        'eventTypeScheme': MemberSpec_('eventTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, eventTypeScheme='http://www.fpml.org/coding-scheme/event-type', valueOf_=None):
        self.original_tagname_ = None
        self.eventTypeScheme = _cast(None, eventTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EventType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EventType.subclass:
            return EventType.subclass(*args_, **kwargs_)
        else:
            return EventType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_eventTypeScheme(self): return self.eventTypeScheme
    def set_eventTypeScheme(self, eventTypeScheme): self.eventTypeScheme = eventTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EventType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EventType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EventType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EventType'):
        if self.eventTypeScheme != "http://www.fpml.org/coding-scheme/event-type" and 'eventTypeScheme' not in already_processed:
            already_processed.add('eventTypeScheme')
            outfile.write(' eventTypeScheme=%s' % (quote_attrib(self.eventTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EventType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('eventTypeScheme', node)
        if value is not None and 'eventTypeScheme' not in already_processed:
            already_processed.add('eventTypeScheme')
            self.eventTypeScheme = value
            self.validate_NonEmptyURI(self.eventTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EventType


class IndexChange(ChangeEvent):
    """A structure describing the effect of a change to an index."""
    member_data_items_ = {
        'indexFactor': MemberSpec_('indexFactor', 'xsd:decimal', 0),
        'factoredCalculationAmount': MemberSpec_('factoredCalculationAmount', 'Money', 0),
    }
    subclass = None
    superclass = ChangeEvent
    def __init__(self, eventIdentifier=None, indexFactor=None, factoredCalculationAmount=None):
        self.original_tagname_ = None
        super(IndexChange, self).__init__(eventIdentifier, )
        self.indexFactor = indexFactor
        self.factoredCalculationAmount = factoredCalculationAmount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IndexChange)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IndexChange.subclass:
            return IndexChange.subclass(*args_, **kwargs_)
        else:
            return IndexChange(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indexFactor(self): return self.indexFactor
    def set_indexFactor(self, indexFactor): self.indexFactor = indexFactor
    def get_factoredCalculationAmount(self): return self.factoredCalculationAmount
    def set_factoredCalculationAmount(self, factoredCalculationAmount): self.factoredCalculationAmount = factoredCalculationAmount
    def hasContent_(self):
        if (
            self.indexFactor is not None or
            self.factoredCalculationAmount is not None or
            super(IndexChange, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IndexChange', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IndexChange')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IndexChange', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IndexChange'):
        super(IndexChange, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IndexChange')
    def exportChildren(self, outfile, level, namespace_='', name_='IndexChange', fromsubclass_=False, pretty_print=True):
        super(IndexChange, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.indexFactor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindexFactor>%s</%sindexFactor>%s' % (namespace_, self.gds_format_float(self.indexFactor, input_name='indexFactor'), namespace_, eol_))
        if self.factoredCalculationAmount is not None:
            self.factoredCalculationAmount.export(outfile, level, namespace_, name_='factoredCalculationAmount', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IndexChange, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'indexFactor':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'indexFactor')
            self.indexFactor = fval_
        elif nodeName_ == 'factoredCalculationAmount':
            obj_ = Money.factory()
            obj_.build(child_)
            self.factoredCalculationAmount = obj_
            obj_.original_tagname_ = 'factoredCalculationAmount'
        super(IndexChange, self).buildChildren(child_, node, nodeName_, True)
# end class IndexChange


class NoTouchLowerBarrierObservation(GeneratedsSuper):
    member_data_items_ = {
        'triggerRate': MemberSpec_('triggerRate', 'xsd:decimal', 0),
        'quotedCurrencyPair': MemberSpec_('quotedCurrencyPair', 'QuotedCurrencyPair', 0),
        'minimumObservedRate': MemberSpec_('minimumObservedRate', 'ObservedRate', 0),
        'triggerPrice': MemberSpec_('triggerPrice', 'PositiveMoney', 0),
        'minimumObservedPrice': MemberSpec_('minimumObservedPrice', 'ObservedPrice', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, triggerRate=None, quotedCurrencyPair=None, minimumObservedRate=None, triggerPrice=None, minimumObservedPrice=None):
        self.original_tagname_ = None
        self.triggerRate = triggerRate
        self.quotedCurrencyPair = quotedCurrencyPair
        self.minimumObservedRate = minimumObservedRate
        self.triggerPrice = triggerPrice
        self.minimumObservedPrice = minimumObservedPrice
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NoTouchLowerBarrierObservation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NoTouchLowerBarrierObservation.subclass:
            return NoTouchLowerBarrierObservation.subclass(*args_, **kwargs_)
        else:
            return NoTouchLowerBarrierObservation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_triggerRate(self): return self.triggerRate
    def set_triggerRate(self, triggerRate): self.triggerRate = triggerRate
    def get_quotedCurrencyPair(self): return self.quotedCurrencyPair
    def set_quotedCurrencyPair(self, quotedCurrencyPair): self.quotedCurrencyPair = quotedCurrencyPair
    def get_minimumObservedRate(self): return self.minimumObservedRate
    def set_minimumObservedRate(self, minimumObservedRate): self.minimumObservedRate = minimumObservedRate
    def get_triggerPrice(self): return self.triggerPrice
    def set_triggerPrice(self, triggerPrice): self.triggerPrice = triggerPrice
    def get_minimumObservedPrice(self): return self.minimumObservedPrice
    def set_minimumObservedPrice(self, minimumObservedPrice): self.minimumObservedPrice = minimumObservedPrice
    def hasContent_(self):
        if (
            self.triggerRate is not None or
            self.quotedCurrencyPair is not None or
            self.minimumObservedRate is not None or
            self.triggerPrice is not None or
            self.minimumObservedPrice is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NoTouchLowerBarrierObservation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NoTouchLowerBarrierObservation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NoTouchLowerBarrierObservation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NoTouchLowerBarrierObservation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NoTouchLowerBarrierObservation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.triggerRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%striggerRate>%s</%striggerRate>%s' % (namespace_, self.gds_format_float(self.triggerRate, input_name='triggerRate'), namespace_, eol_))
        if self.quotedCurrencyPair is not None:
            self.quotedCurrencyPair.export(outfile, level, namespace_, name_='quotedCurrencyPair', pretty_print=pretty_print)
        if self.minimumObservedRate is not None:
            self.minimumObservedRate.export(outfile, level, namespace_, name_='minimumObservedRate', pretty_print=pretty_print)
        if self.triggerPrice is not None:
            self.triggerPrice.export(outfile, level, namespace_, name_='triggerPrice', pretty_print=pretty_print)
        if self.minimumObservedPrice is not None:
            self.minimumObservedPrice.export(outfile, level, namespace_, name_='minimumObservedPrice', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'triggerRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'triggerRate')
            self.triggerRate = fval_
        elif nodeName_ == 'quotedCurrencyPair':
            obj_ = QuotedCurrencyPair.factory()
            obj_.build(child_)
            self.quotedCurrencyPair = obj_
            obj_.original_tagname_ = 'quotedCurrencyPair'
        elif nodeName_ == 'minimumObservedRate':
            obj_ = ObservedRate.factory()
            obj_.build(child_)
            self.minimumObservedRate = obj_
            obj_.original_tagname_ = 'minimumObservedRate'
        elif nodeName_ == 'triggerPrice':
            obj_ = PositiveMoney.factory()
            obj_.build(child_)
            self.triggerPrice = obj_
            obj_.original_tagname_ = 'triggerPrice'
        elif nodeName_ == 'minimumObservedPrice':
            obj_ = ObservedPrice.factory()
            obj_.build(child_)
            self.minimumObservedPrice = obj_
            obj_.original_tagname_ = 'minimumObservedPrice'
# end class NoTouchLowerBarrierObservation


class NoTouchRateObservation(GeneratedsSuper):
    """Cloned from exercise but looks like some bits are extraneous like
    payment"""
    member_data_items_ = {
        'observationStartDate': MemberSpec_('observationStartDate', 'xsd:date', 0),
        'observationEndDate': MemberSpec_('observationEndDate', 'xsd:date', 0),
        'lowerBarrier': MemberSpec_('lowerBarrier', 'NoTouchLowerBarrierObservation', 0),
        'upperBarrier': MemberSpec_('upperBarrier', 'NoTouchUpperBarrierObservation', 0),
        'upperBarrier': MemberSpec_('upperBarrier', 'NoTouchUpperBarrierObservation', 0),
        'exerciseSide': MemberSpec_('exerciseSide', ['ExerciseSideEnum', 'Token', 'xsd:token'], 0),
        'settlementType': MemberSpec_('settlementType', ['SettlementTypeEnum', 'Token', 'xsd:token'], 0),
        'cashSettlement': MemberSpec_('cashSettlement', 'SimplePayment', 0),
        'physicalSettlement': MemberSpec_('physicalSettlement', 'PhysicalSettlement', 0),
        'payment': MemberSpec_('payment', 'NonNegativePayment', 0),
        'clearingInstructions': MemberSpec_('clearingInstructions', 'ClearingInstructions', 0),
        'isExercisable': MemberSpec_('isExercisable', 'xsd:boolean', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, observationStartDate=None, observationEndDate=None, lowerBarrier=None, upperBarrier=None, exerciseSide=None, settlementType=None, cashSettlement=None, physicalSettlement=None, payment=None, clearingInstructions=None, isExercisable=None):
        self.original_tagname_ = None
        if isinstance(observationStartDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(observationStartDate, '%Y-%m-%d').date()
        else:
            initvalue_ = observationStartDate
        self.observationStartDate = initvalue_
        if isinstance(observationEndDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(observationEndDate, '%Y-%m-%d').date()
        else:
            initvalue_ = observationEndDate
        self.observationEndDate = initvalue_
        self.lowerBarrier = lowerBarrier
        self.upperBarrier = upperBarrier
        self.upperBarrier = upperBarrier
        self.exerciseSide = exerciseSide
        self.validate_ExerciseSideEnum(self.exerciseSide)
        self.settlementType = settlementType
        self.validate_SettlementTypeEnum(self.settlementType)
        self.cashSettlement = cashSettlement
        self.physicalSettlement = physicalSettlement
        self.payment = payment
        self.clearingInstructions = clearingInstructions
        self.isExercisable = isExercisable
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NoTouchRateObservation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NoTouchRateObservation.subclass:
            return NoTouchRateObservation.subclass(*args_, **kwargs_)
        else:
            return NoTouchRateObservation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_observationStartDate(self): return self.observationStartDate
    def set_observationStartDate(self, observationStartDate): self.observationStartDate = observationStartDate
    def get_observationEndDate(self): return self.observationEndDate
    def set_observationEndDate(self, observationEndDate): self.observationEndDate = observationEndDate
    def get_lowerBarrier(self): return self.lowerBarrier
    def set_lowerBarrier(self, lowerBarrier): self.lowerBarrier = lowerBarrier
    def get_upperBarrier(self): return self.upperBarrier
    def set_upperBarrier(self, upperBarrier): self.upperBarrier = upperBarrier
    def get_upperBarrier(self): return self.upperBarrier
    def set_upperBarrier(self, upperBarrier): self.upperBarrier = upperBarrier
    def get_exerciseSide(self): return self.exerciseSide
    def set_exerciseSide(self, exerciseSide): self.exerciseSide = exerciseSide
    def get_settlementType(self): return self.settlementType
    def set_settlementType(self, settlementType): self.settlementType = settlementType
    def get_cashSettlement(self): return self.cashSettlement
    def set_cashSettlement(self, cashSettlement): self.cashSettlement = cashSettlement
    def get_physicalSettlement(self): return self.physicalSettlement
    def set_physicalSettlement(self, physicalSettlement): self.physicalSettlement = physicalSettlement
    def get_payment(self): return self.payment
    def set_payment(self, payment): self.payment = payment
    def get_clearingInstructions(self): return self.clearingInstructions
    def set_clearingInstructions(self, clearingInstructions): self.clearingInstructions = clearingInstructions
    def get_isExercisable(self): return self.isExercisable
    def set_isExercisable(self, isExercisable): self.isExercisable = isExercisable
    def validate_ExerciseSideEnum(self, value):
        # Validate type ExerciseSideEnum, a restriction on Token.
        pass
    def validate_SettlementTypeEnum(self, value):
        # Validate type SettlementTypeEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Cash', 'Physical', 'Election', 'CashOrPhysical']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SettlementTypeEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on SettlementTypeEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.observationStartDate is not None or
            self.observationEndDate is not None or
            self.lowerBarrier is not None or
            self.upperBarrier is not None or
            self.upperBarrier is not None or
            self.exerciseSide is not None or
            self.settlementType is not None or
            self.cashSettlement is not None or
            self.physicalSettlement is not None or
            self.payment is not None or
            self.clearingInstructions is not None or
            self.isExercisable is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NoTouchRateObservation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NoTouchRateObservation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NoTouchRateObservation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NoTouchRateObservation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NoTouchRateObservation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.observationStartDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sobservationStartDate>%s</%sobservationStartDate>%s' % (namespace_, self.gds_format_date(self.observationStartDate, input_name='observationStartDate'), namespace_, eol_))
        if self.observationEndDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sobservationEndDate>%s</%sobservationEndDate>%s' % (namespace_, self.gds_format_date(self.observationEndDate, input_name='observationEndDate'), namespace_, eol_))
        if self.lowerBarrier is not None:
            self.lowerBarrier.export(outfile, level, namespace_, name_='lowerBarrier', pretty_print=pretty_print)
        if self.upperBarrier is not None:
            self.upperBarrier.export(outfile, level, namespace_, name_='upperBarrier', pretty_print=pretty_print)
        if self.upperBarrier is not None:
            self.upperBarrier.export(outfile, level, namespace_, name_='upperBarrier', pretty_print=pretty_print)
        if self.exerciseSide is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexerciseSide>%s</%sexerciseSide>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.exerciseSide), input_name='exerciseSide')), namespace_, eol_))
        if self.settlementType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssettlementType>%s</%ssettlementType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.settlementType), input_name='settlementType')), namespace_, eol_))
        if self.cashSettlement is not None:
            self.cashSettlement.export(outfile, level, namespace_, name_='cashSettlement', pretty_print=pretty_print)
        if self.physicalSettlement is not None:
            self.physicalSettlement.export(outfile, level, namespace_, name_='physicalSettlement', pretty_print=pretty_print)
        if self.payment is not None:
            self.payment.export(outfile, level, namespace_, name_='payment', pretty_print=pretty_print)
        if self.clearingInstructions is not None:
            self.clearingInstructions.export(outfile, level, namespace_, name_='clearingInstructions', pretty_print=pretty_print)
        if self.isExercisable is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sisExercisable>%s</%sisExercisable>%s' % (namespace_, self.gds_format_boolean(self.isExercisable, input_name='isExercisable'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'observationStartDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.observationStartDate = dval_
        elif nodeName_ == 'observationEndDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.observationEndDate = dval_
        elif nodeName_ == 'lowerBarrier':
            obj_ = NoTouchLowerBarrierObservation.factory()
            obj_.build(child_)
            self.lowerBarrier = obj_
            obj_.original_tagname_ = 'lowerBarrier'
        elif nodeName_ == 'upperBarrier':
            obj_ = NoTouchUpperBarrierObservation.factory()
            obj_.build(child_)
            self.upperBarrier = obj_
            obj_.original_tagname_ = 'upperBarrier'
        elif nodeName_ == 'upperBarrier':
            obj_ = NoTouchUpperBarrierObservation.factory()
            obj_.build(child_)
            self.upperBarrier = obj_
            obj_.original_tagname_ = 'upperBarrier'
        elif nodeName_ == 'exerciseSide':
            exerciseSide_ = child_.text
            exerciseSide_ = re_.sub(String_cleanup_pat_, " ", exerciseSide_).strip()
            exerciseSide_ = self.gds_validate_string(exerciseSide_, node, 'exerciseSide')
            self.exerciseSide = exerciseSide_
            # validate type ExerciseSideEnum
            self.validate_ExerciseSideEnum(self.exerciseSide)
        elif nodeName_ == 'settlementType':
            settlementType_ = child_.text
            settlementType_ = re_.sub(String_cleanup_pat_, " ", settlementType_).strip()
            settlementType_ = self.gds_validate_string(settlementType_, node, 'settlementType')
            self.settlementType = settlementType_
            # validate type SettlementTypeEnum
            self.validate_SettlementTypeEnum(self.settlementType)
        elif nodeName_ == 'cashSettlement':
            obj_ = SimplePayment.factory()
            obj_.build(child_)
            self.cashSettlement = obj_
            obj_.original_tagname_ = 'cashSettlement'
        elif nodeName_ == 'physicalSettlement':
            obj_ = PhysicalSettlement.factory()
            obj_.build(child_)
            self.physicalSettlement = obj_
            obj_.original_tagname_ = 'physicalSettlement'
        elif nodeName_ == 'payment':
            obj_ = NonNegativePayment.factory()
            obj_.build(child_)
            self.payment = obj_
            obj_.original_tagname_ = 'payment'
        elif nodeName_ == 'clearingInstructions':
            obj_ = ClearingInstructions.factory()
            obj_.build(child_)
            self.clearingInstructions = obj_
            obj_.original_tagname_ = 'clearingInstructions'
        elif nodeName_ == 'isExercisable':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'isExercisable')
            self.isExercisable = ival_
# end class NoTouchRateObservation


class NoTouchUpperBarrierObservation(GeneratedsSuper):
    member_data_items_ = {
        'triggerRate': MemberSpec_('triggerRate', 'xsd:decimal', 0),
        'quotedCurrencyPair': MemberSpec_('quotedCurrencyPair', 'QuotedCurrencyPair', 0),
        'maximumObservedRate': MemberSpec_('maximumObservedRate', 'ObservedRate', 0),
        'triggerPrice': MemberSpec_('triggerPrice', 'PositiveMoney', 0),
        'maximumObservedPrice': MemberSpec_('maximumObservedPrice', 'ObservedPrice', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, triggerRate=None, quotedCurrencyPair=None, maximumObservedRate=None, triggerPrice=None, maximumObservedPrice=None):
        self.original_tagname_ = None
        self.triggerRate = triggerRate
        self.quotedCurrencyPair = quotedCurrencyPair
        self.maximumObservedRate = maximumObservedRate
        self.triggerPrice = triggerPrice
        self.maximumObservedPrice = maximumObservedPrice
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NoTouchUpperBarrierObservation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NoTouchUpperBarrierObservation.subclass:
            return NoTouchUpperBarrierObservation.subclass(*args_, **kwargs_)
        else:
            return NoTouchUpperBarrierObservation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_triggerRate(self): return self.triggerRate
    def set_triggerRate(self, triggerRate): self.triggerRate = triggerRate
    def get_quotedCurrencyPair(self): return self.quotedCurrencyPair
    def set_quotedCurrencyPair(self, quotedCurrencyPair): self.quotedCurrencyPair = quotedCurrencyPair
    def get_maximumObservedRate(self): return self.maximumObservedRate
    def set_maximumObservedRate(self, maximumObservedRate): self.maximumObservedRate = maximumObservedRate
    def get_triggerPrice(self): return self.triggerPrice
    def set_triggerPrice(self, triggerPrice): self.triggerPrice = triggerPrice
    def get_maximumObservedPrice(self): return self.maximumObservedPrice
    def set_maximumObservedPrice(self, maximumObservedPrice): self.maximumObservedPrice = maximumObservedPrice
    def hasContent_(self):
        if (
            self.triggerRate is not None or
            self.quotedCurrencyPair is not None or
            self.maximumObservedRate is not None or
            self.triggerPrice is not None or
            self.maximumObservedPrice is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NoTouchUpperBarrierObservation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NoTouchUpperBarrierObservation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NoTouchUpperBarrierObservation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NoTouchUpperBarrierObservation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NoTouchUpperBarrierObservation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.triggerRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%striggerRate>%s</%striggerRate>%s' % (namespace_, self.gds_format_float(self.triggerRate, input_name='triggerRate'), namespace_, eol_))
        if self.quotedCurrencyPair is not None:
            self.quotedCurrencyPair.export(outfile, level, namespace_, name_='quotedCurrencyPair', pretty_print=pretty_print)
        if self.maximumObservedRate is not None:
            self.maximumObservedRate.export(outfile, level, namespace_, name_='maximumObservedRate', pretty_print=pretty_print)
        if self.triggerPrice is not None:
            self.triggerPrice.export(outfile, level, namespace_, name_='triggerPrice', pretty_print=pretty_print)
        if self.maximumObservedPrice is not None:
            self.maximumObservedPrice.export(outfile, level, namespace_, name_='maximumObservedPrice', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'triggerRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'triggerRate')
            self.triggerRate = fval_
        elif nodeName_ == 'quotedCurrencyPair':
            obj_ = QuotedCurrencyPair.factory()
            obj_.build(child_)
            self.quotedCurrencyPair = obj_
            obj_.original_tagname_ = 'quotedCurrencyPair'
        elif nodeName_ == 'maximumObservedRate':
            obj_ = ObservedRate.factory()
            obj_.build(child_)
            self.maximumObservedRate = obj_
            obj_.original_tagname_ = 'maximumObservedRate'
        elif nodeName_ == 'triggerPrice':
            obj_ = PositiveMoney.factory()
            obj_.build(child_)
            self.triggerPrice = obj_
            obj_.original_tagname_ = 'triggerPrice'
        elif nodeName_ == 'maximumObservedPrice':
            obj_ = ObservedPrice.factory()
            obj_.build(child_)
            self.maximumObservedPrice = obj_
            obj_.original_tagname_ = 'maximumObservedPrice'
# end class NoTouchUpperBarrierObservation


class LimitApplicable(GeneratedsSuper):
    member_data_items_ = {
        'limitType': MemberSpec_('limitType', 'LimitType', 0),
        'clipSize': MemberSpec_('clipSize', 'xsd:integer', 0),
        'amountUtilized': MemberSpec_('amountUtilized', 'xsd:integer', 0),
        'utilization': MemberSpec_('utilization', 'CreditLimitUtilization', 0),
        'amountRemaining': MemberSpec_('amountRemaining', 'xsd:integer', 0),
        'currency': MemberSpec_('currency', 'Currency', 0),
        'velocity': MemberSpec_('velocity', 'Velocity', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, limitType=None, clipSize=None, amountUtilized=None, utilization=None, amountRemaining=None, currency=None, velocity=None):
        self.original_tagname_ = None
        self.limitType = limitType
        self.clipSize = clipSize
        self.amountUtilized = amountUtilized
        self.utilization = utilization
        self.amountRemaining = amountRemaining
        self.currency = currency
        self.velocity = velocity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LimitApplicable)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LimitApplicable.subclass:
            return LimitApplicable.subclass(*args_, **kwargs_)
        else:
            return LimitApplicable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_limitType(self): return self.limitType
    def set_limitType(self, limitType): self.limitType = limitType
    def get_clipSize(self): return self.clipSize
    def set_clipSize(self, clipSize): self.clipSize = clipSize
    def get_amountUtilized(self): return self.amountUtilized
    def set_amountUtilized(self, amountUtilized): self.amountUtilized = amountUtilized
    def get_utilization(self): return self.utilization
    def set_utilization(self, utilization): self.utilization = utilization
    def get_amountRemaining(self): return self.amountRemaining
    def set_amountRemaining(self, amountRemaining): self.amountRemaining = amountRemaining
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_velocity(self): return self.velocity
    def set_velocity(self, velocity): self.velocity = velocity
    def hasContent_(self):
        if (
            self.limitType is not None or
            self.clipSize is not None or
            self.amountUtilized is not None or
            self.utilization is not None or
            self.amountRemaining is not None or
            self.currency is not None or
            self.velocity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LimitApplicable', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LimitApplicable')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LimitApplicable', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LimitApplicable'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LimitApplicable', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.limitType is not None:
            self.limitType.export(outfile, level, namespace_, name_='limitType', pretty_print=pretty_print)
        if self.clipSize is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sclipSize>%s</%sclipSize>%s' % (namespace_, self.gds_format_integer(self.clipSize, input_name='clipSize'), namespace_, eol_))
        if self.amountUtilized is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%samountUtilized>%s</%samountUtilized>%s' % (namespace_, self.gds_format_integer(self.amountUtilized, input_name='amountUtilized'), namespace_, eol_))
        if self.utilization is not None:
            self.utilization.export(outfile, level, namespace_, name_='utilization', pretty_print=pretty_print)
        if self.amountRemaining is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%samountRemaining>%s</%samountRemaining>%s' % (namespace_, self.gds_format_integer(self.amountRemaining, input_name='amountRemaining'), namespace_, eol_))
        if self.currency is not None:
            self.currency.export(outfile, level, namespace_, name_='currency', pretty_print=pretty_print)
        if self.velocity is not None:
            self.velocity.export(outfile, level, namespace_, name_='velocity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'limitType':
            obj_ = LimitType.factory()
            obj_.build(child_)
            self.limitType = obj_
            obj_.original_tagname_ = 'limitType'
        elif nodeName_ == 'clipSize':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'clipSize')
            self.clipSize = ival_
        elif nodeName_ == 'amountUtilized':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'amountUtilized')
            self.amountUtilized = ival_
        elif nodeName_ == 'utilization':
            obj_ = CreditLimitUtilization.factory()
            obj_.build(child_)
            self.utilization = obj_
            obj_.original_tagname_ = 'utilization'
        elif nodeName_ == 'amountRemaining':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'amountRemaining')
            self.amountRemaining = ival_
        elif nodeName_ == 'currency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'velocity':
            obj_ = Velocity.factory()
            obj_.build(child_)
            self.velocity = obj_
            obj_.original_tagname_ = 'velocity'
# end class LimitApplicable


class LimitId(GeneratedsSuper):
    member_data_items_ = {
        'creditLimitIdScheme': MemberSpec_('creditLimitIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, creditLimitIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.creditLimitIdScheme = _cast(None, creditLimitIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LimitId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LimitId.subclass:
            return LimitId.subclass(*args_, **kwargs_)
        else:
            return LimitId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_creditLimitIdScheme(self): return self.creditLimitIdScheme
    def set_creditLimitIdScheme(self, creditLimitIdScheme): self.creditLimitIdScheme = creditLimitIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LimitId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LimitId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LimitId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LimitId'):
        if self.creditLimitIdScheme is not None and 'creditLimitIdScheme' not in already_processed:
            already_processed.add('creditLimitIdScheme')
            outfile.write(' creditLimitIdScheme=%s' % (quote_attrib(self.creditLimitIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LimitId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('creditLimitIdScheme', node)
        if value is not None and 'creditLimitIdScheme' not in already_processed:
            already_processed.add('creditLimitIdScheme')
            self.creditLimitIdScheme = value
            self.validate_NonEmptyURI(self.creditLimitIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LimitId


class LimitType(GeneratedsSuper):
    member_data_items_ = {
        'creditLimitTypeScheme': MemberSpec_('creditLimitTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, creditLimitTypeScheme='http://www.fpml.org/coding-scheme/credit-limit-type', valueOf_=None):
        self.original_tagname_ = None
        self.creditLimitTypeScheme = _cast(None, creditLimitTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LimitType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LimitType.subclass:
            return LimitType.subclass(*args_, **kwargs_)
        else:
            return LimitType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_creditLimitTypeScheme(self): return self.creditLimitTypeScheme
    def set_creditLimitTypeScheme(self, creditLimitTypeScheme): self.creditLimitTypeScheme = creditLimitTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LimitType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LimitType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LimitType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LimitType'):
        if self.creditLimitTypeScheme != "http://www.fpml.org/coding-scheme/credit-limit-type" and 'creditLimitTypeScheme' not in already_processed:
            already_processed.add('creditLimitTypeScheme')
            outfile.write(' creditLimitTypeScheme=%s' % (quote_attrib(self.creditLimitTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LimitType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('creditLimitTypeScheme', node)
        if value is not None and 'creditLimitTypeScheme' not in already_processed:
            already_processed.add('creditLimitTypeScheme')
            self.creditLimitTypeScheme = value
            self.validate_NonEmptyURI(self.creditLimitTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LimitType


class ObservedPrice(GeneratedsSuper):
    member_data_items_ = {
        'price': MemberSpec_('price', 'NonNegativeMoney', 0),
        'date': MemberSpec_('date', 'xsd:date', 0),
        'time': MemberSpec_('time', 'xsd:time', 0),
        'informationSource': MemberSpec_('informationSource', 'InformationSource', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, price=None, date=None, time=None, informationSource=None):
        self.original_tagname_ = None
        self.price = price
        if isinstance(date, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(date, '%Y-%m-%d').date()
        else:
            initvalue_ = date
        self.date = initvalue_
        if isinstance(time, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(time, '%H:%M:%S').time()
        else:
            initvalue_ = time
        self.time = initvalue_
        self.informationSource = informationSource
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ObservedPrice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ObservedPrice.subclass:
            return ObservedPrice.subclass(*args_, **kwargs_)
        else:
            return ObservedPrice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_price(self): return self.price
    def set_price(self, price): self.price = price
    def get_date(self): return self.date
    def set_date(self, date): self.date = date
    def get_time(self): return self.time
    def set_time(self, time): self.time = time
    def get_informationSource(self): return self.informationSource
    def set_informationSource(self, informationSource): self.informationSource = informationSource
    def hasContent_(self):
        if (
            self.price is not None or
            self.date is not None or
            self.time is not None or
            self.informationSource is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ObservedPrice', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObservedPrice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ObservedPrice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ObservedPrice'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ObservedPrice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.price is not None:
            self.price.export(outfile, level, namespace_, name_='price', pretty_print=pretty_print)
        if self.date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdate>%s</%sdate>%s' % (namespace_, self.gds_format_date(self.date, input_name='date'), namespace_, eol_))
        if self.time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stime>%s</%stime>%s' % (namespace_, self.gds_format_time(self.time, input_name='time'), namespace_, eol_))
        if self.informationSource is not None:
            self.informationSource.export(outfile, level, namespace_, name_='informationSource', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'price':
            class_obj_ = self.get_class_obj_(child_, NonNegativeMoney)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.price = obj_
            obj_.original_tagname_ = 'price'
        elif nodeName_ == 'date':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.date = dval_
        elif nodeName_ == 'time':
            sval_ = child_.text
            dval_ = self.gds_parse_time(sval_)
            self.time = dval_
        elif nodeName_ == 'informationSource':
            class_obj_ = self.get_class_obj_(child_, InformationSource)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.informationSource = obj_
            obj_.original_tagname_ = 'informationSource'
# end class ObservedPrice


class ObservedRate(GeneratedsSuper):
    member_data_items_ = {
        'rate': MemberSpec_('rate', 'xsd:decimal', 0),
        'date': MemberSpec_('date', 'xsd:date', 0),
        'time': MemberSpec_('time', 'xsd:time', 0),
        'informationSource': MemberSpec_('informationSource', 'InformationSource', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, rate=None, date=None, time=None, informationSource=None):
        self.original_tagname_ = None
        self.rate = rate
        if isinstance(date, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(date, '%Y-%m-%d').date()
        else:
            initvalue_ = date
        self.date = initvalue_
        if isinstance(time, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(time, '%H:%M:%S').time()
        else:
            initvalue_ = time
        self.time = initvalue_
        self.informationSource = informationSource
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ObservedRate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ObservedRate.subclass:
            return ObservedRate.subclass(*args_, **kwargs_)
        else:
            return ObservedRate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rate(self): return self.rate
    def set_rate(self, rate): self.rate = rate
    def get_date(self): return self.date
    def set_date(self, date): self.date = date
    def get_time(self): return self.time
    def set_time(self, time): self.time = time
    def get_informationSource(self): return self.informationSource
    def set_informationSource(self, informationSource): self.informationSource = informationSource
    def hasContent_(self):
        if (
            self.rate is not None or
            self.date is not None or
            self.time is not None or
            self.informationSource is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ObservedRate', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObservedRate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ObservedRate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ObservedRate'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ObservedRate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.rate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srate>%s</%srate>%s' % (namespace_, self.gds_format_float(self.rate, input_name='rate'), namespace_, eol_))
        if self.date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdate>%s</%sdate>%s' % (namespace_, self.gds_format_date(self.date, input_name='date'), namespace_, eol_))
        if self.time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stime>%s</%stime>%s' % (namespace_, self.gds_format_time(self.time, input_name='time'), namespace_, eol_))
        if self.informationSource is not None:
            self.informationSource.export(outfile, level, namespace_, name_='informationSource', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'rate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'rate')
            self.rate = fval_
        elif nodeName_ == 'date':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.date = dval_
        elif nodeName_ == 'time':
            sval_ = child_.text
            dval_ = self.gds_parse_time(sval_)
            self.time = dval_
        elif nodeName_ == 'informationSource':
            class_obj_ = self.get_class_obj_(child_, InformationSource)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.informationSource = obj_
            obj_.original_tagname_ = 'informationSource'
# end class ObservedRate


class OptionEvent(AbstractEvent):
    member_data_items_ = {
        'originalTrade': MemberSpec_('originalTrade', 'Trade', 0),
        'tradeIdentifier': MemberSpec_('tradeIdentifier', 'PartyTradeIdentifier', 1),
        'knockIn': MemberSpec_('knockIn', 'TriggerRateObservation', 0),
        'knockOut': MemberSpec_('knockOut', 'KnockOutRateObservation', 0),
        'touch': MemberSpec_('touch', 'TouchRateObservation', 1),
        'noTouch': MemberSpec_('noTouch', 'NoTouchRateObservation', 0),
    }
    subclass = None
    superclass = AbstractEvent
    def __init__(self, eventIdentifier=None, originalTrade=None, tradeIdentifier=None, knockIn=None, knockOut=None, touch=None, noTouch=None):
        self.original_tagname_ = None
        super(OptionEvent, self).__init__(eventIdentifier, )
        self.originalTrade = originalTrade
        if tradeIdentifier is None:
            self.tradeIdentifier = []
        else:
            self.tradeIdentifier = tradeIdentifier
        self.knockIn = knockIn
        self.knockOut = knockOut
        if touch is None:
            self.touch = []
        else:
            self.touch = touch
        self.noTouch = noTouch
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OptionEvent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OptionEvent.subclass:
            return OptionEvent.subclass(*args_, **kwargs_)
        else:
            return OptionEvent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_originalTrade(self): return self.originalTrade
    def set_originalTrade(self, originalTrade): self.originalTrade = originalTrade
    def get_tradeIdentifier(self): return self.tradeIdentifier
    def set_tradeIdentifier(self, tradeIdentifier): self.tradeIdentifier = tradeIdentifier
    def add_tradeIdentifier(self, value): self.tradeIdentifier.append(value)
    def insert_tradeIdentifier_at(self, index, value): self.tradeIdentifier.insert(index, value)
    def replace_tradeIdentifier_at(self, index, value): self.tradeIdentifier[index] = value
    def get_knockIn(self): return self.knockIn
    def set_knockIn(self, knockIn): self.knockIn = knockIn
    def get_knockOut(self): return self.knockOut
    def set_knockOut(self, knockOut): self.knockOut = knockOut
    def get_touch(self): return self.touch
    def set_touch(self, touch): self.touch = touch
    def add_touch(self, value): self.touch.append(value)
    def insert_touch_at(self, index, value): self.touch.insert(index, value)
    def replace_touch_at(self, index, value): self.touch[index] = value
    def get_noTouch(self): return self.noTouch
    def set_noTouch(self, noTouch): self.noTouch = noTouch
    def hasContent_(self):
        if (
            self.originalTrade is not None or
            self.tradeIdentifier or
            self.knockIn is not None or
            self.knockOut is not None or
            self.touch or
            self.noTouch is not None or
            super(OptionEvent, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OptionEvent', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OptionEvent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OptionEvent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OptionEvent'):
        super(OptionEvent, self).exportAttributes(outfile, level, already_processed, namespace_, name_='OptionEvent')
    def exportChildren(self, outfile, level, namespace_='', name_='OptionEvent', fromsubclass_=False, pretty_print=True):
        super(OptionEvent, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.originalTrade is not None:
            self.originalTrade.export(outfile, level, namespace_, name_='originalTrade', pretty_print=pretty_print)
        for tradeIdentifier_ in self.tradeIdentifier:
            tradeIdentifier_.export(outfile, level, namespace_, name_='tradeIdentifier', pretty_print=pretty_print)
        if self.knockIn is not None:
            self.knockIn.export(outfile, level, namespace_, name_='knockIn', pretty_print=pretty_print)
        if self.knockOut is not None:
            self.knockOut.export(outfile, level, namespace_, name_='knockOut', pretty_print=pretty_print)
        for touch_ in self.touch:
            touch_.export(outfile, level, namespace_, name_='touch', pretty_print=pretty_print)
        if self.noTouch is not None:
            self.noTouch.export(outfile, level, namespace_, name_='noTouch', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(OptionEvent, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'originalTrade':
            obj_ = Trade.factory()
            obj_.build(child_)
            self.originalTrade = obj_
            obj_.original_tagname_ = 'originalTrade'
        elif nodeName_ == 'tradeIdentifier':
            obj_ = PartyTradeIdentifier.factory()
            obj_.build(child_)
            self.tradeIdentifier.append(obj_)
            obj_.original_tagname_ = 'tradeIdentifier'
        elif nodeName_ == 'knockIn':
            class_obj_ = self.get_class_obj_(child_, TriggerRateObservation)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.knockIn = obj_
            obj_.original_tagname_ = 'knockIn'
        elif nodeName_ == 'knockOut':
            obj_ = KnockOutRateObservation.factory()
            obj_.build(child_)
            self.knockOut = obj_
            obj_.original_tagname_ = 'knockOut'
        elif nodeName_ == 'touch':
            obj_ = TouchRateObservation.factory()
            obj_.build(child_)
            self.touch.append(obj_)
            obj_.original_tagname_ = 'touch'
        elif nodeName_ == 'noTouch':
            obj_ = NoTouchRateObservation.factory()
            obj_.build(child_)
            self.noTouch = obj_
            obj_.original_tagname_ = 'noTouch'
        super(OptionEvent, self).buildChildren(child_, node, nodeName_, True)
# end class OptionEvent


class OptionExercise(AbstractEvent):
    """A structure describing an option exercise. The OptionExercise type
    supports partial exercise (specify the number of options or
    amount to exercise), full exercise (use fullExercise flag), as
    well as the option to request options not to be exercised."""
    member_data_items_ = {
        'optionSeller': MemberSpec_('optionSeller', 'PartyReference', 0),
        'optionBuyer': MemberSpec_('optionBuyer', 'PartyReference', 0),
        'originalTrade': MemberSpec_('originalTrade', 'Trade', 0),
        'tradeIdentifier': MemberSpec_('tradeIdentifier', 'PartyTradeIdentifier', 1),
        'exerciseDate': MemberSpec_('exerciseDate', 'xsd:date', 0),
        'exerciseTime': MemberSpec_('exerciseTime', 'xsd:time', 0),
        'exerciseTiming': MemberSpec_('exerciseTiming', ['ExerciseTimingEnum', 'Token', 'xsd:token'], 0),
        'exerciseAction': MemberSpec_('exerciseAction', ['ExerciseActionEnum', 'Token', 'xsd:token'], 0),
        'expiry': MemberSpec_('expiry', 'xsd:boolean', 0),
        'fullExercise': MemberSpec_('fullExercise', 'xsd:boolean', 0),
        'exerciseInNotionalAmount': MemberSpec_('exerciseInNotionalAmount', 'Money', 0),
        'outstandingNotionalAmount': MemberSpec_('outstandingNotionalAmount', 'Money', 0),
        'exerciseInNumberOfOptions': MemberSpec_('exerciseInNumberOfOptions', 'xsd:decimal', 0),
        'outstandingNumberOfOptions': MemberSpec_('outstandingNumberOfOptions', 'xsd:decimal', 0),
        'exerciseInNumberOfUnits': MemberSpec_('exerciseInNumberOfUnits', 'xsd:decimal', 0),
        'outstandingNumberOfUnits': MemberSpec_('outstandingNumberOfUnits', 'xsd:decimal', 0),
        'specifiedExercise': MemberSpec_('specifiedExercise', 'OptionExerciseAmounts', 1),
        'exerciseSide': MemberSpec_('exerciseSide', ['ExerciseSideEnum', 'Token', 'xsd:token'], 0),
        'settlementType': MemberSpec_('settlementType', ['SettlementTypeEnum', 'Token', 'xsd:token'], 0),
        'cashSettlement': MemberSpec_('cashSettlement', 'SimplePayment', 0),
        'physicalSettlement': MemberSpec_('physicalSettlement', 'PhysicalSettlement', 0),
        'payment': MemberSpec_('payment', 'NonNegativePayment', 0),
        'clearingInstructions': MemberSpec_('clearingInstructions', 'ClearingInstructions', 0),
    }
    subclass = None
    superclass = AbstractEvent
    def __init__(self, eventIdentifier=None, optionSeller=None, optionBuyer=None, originalTrade=None, tradeIdentifier=None, exerciseDate=None, exerciseTime=None, exerciseTiming=None, exerciseAction=None, expiry=None, fullExercise=None, exerciseInNotionalAmount=None, outstandingNotionalAmount=None, exerciseInNumberOfOptions=None, outstandingNumberOfOptions=None, exerciseInNumberOfUnits=None, outstandingNumberOfUnits=None, specifiedExercise=None, exerciseSide=None, settlementType=None, cashSettlement=None, physicalSettlement=None, payment=None, clearingInstructions=None):
        self.original_tagname_ = None
        super(OptionExercise, self).__init__(eventIdentifier, )
        self.optionSeller = optionSeller
        self.optionBuyer = optionBuyer
        self.originalTrade = originalTrade
        if tradeIdentifier is None:
            self.tradeIdentifier = []
        else:
            self.tradeIdentifier = tradeIdentifier
        if isinstance(exerciseDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(exerciseDate, '%Y-%m-%d').date()
        else:
            initvalue_ = exerciseDate
        self.exerciseDate = initvalue_
        if isinstance(exerciseTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(exerciseTime, '%H:%M:%S').time()
        else:
            initvalue_ = exerciseTime
        self.exerciseTime = initvalue_
        self.exerciseTiming = exerciseTiming
        self.validate_ExerciseTimingEnum(self.exerciseTiming)
        self.exerciseAction = exerciseAction
        self.validate_ExerciseActionEnum(self.exerciseAction)
        self.expiry = expiry
        self.fullExercise = fullExercise
        self.exerciseInNotionalAmount = exerciseInNotionalAmount
        self.outstandingNotionalAmount = outstandingNotionalAmount
        self.exerciseInNumberOfOptions = exerciseInNumberOfOptions
        self.outstandingNumberOfOptions = outstandingNumberOfOptions
        self.exerciseInNumberOfUnits = exerciseInNumberOfUnits
        self.outstandingNumberOfUnits = outstandingNumberOfUnits
        if specifiedExercise is None:
            self.specifiedExercise = []
        else:
            self.specifiedExercise = specifiedExercise
        self.exerciseSide = exerciseSide
        self.validate_ExerciseSideEnum(self.exerciseSide)
        self.settlementType = settlementType
        self.validate_SettlementTypeEnum(self.settlementType)
        self.cashSettlement = cashSettlement
        self.physicalSettlement = physicalSettlement
        self.payment = payment
        self.clearingInstructions = clearingInstructions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OptionExercise)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OptionExercise.subclass:
            return OptionExercise.subclass(*args_, **kwargs_)
        else:
            return OptionExercise(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_optionSeller(self): return self.optionSeller
    def set_optionSeller(self, optionSeller): self.optionSeller = optionSeller
    def get_optionBuyer(self): return self.optionBuyer
    def set_optionBuyer(self, optionBuyer): self.optionBuyer = optionBuyer
    def get_originalTrade(self): return self.originalTrade
    def set_originalTrade(self, originalTrade): self.originalTrade = originalTrade
    def get_tradeIdentifier(self): return self.tradeIdentifier
    def set_tradeIdentifier(self, tradeIdentifier): self.tradeIdentifier = tradeIdentifier
    def add_tradeIdentifier(self, value): self.tradeIdentifier.append(value)
    def insert_tradeIdentifier_at(self, index, value): self.tradeIdentifier.insert(index, value)
    def replace_tradeIdentifier_at(self, index, value): self.tradeIdentifier[index] = value
    def get_exerciseDate(self): return self.exerciseDate
    def set_exerciseDate(self, exerciseDate): self.exerciseDate = exerciseDate
    def get_exerciseTime(self): return self.exerciseTime
    def set_exerciseTime(self, exerciseTime): self.exerciseTime = exerciseTime
    def get_exerciseTiming(self): return self.exerciseTiming
    def set_exerciseTiming(self, exerciseTiming): self.exerciseTiming = exerciseTiming
    def get_exerciseAction(self): return self.exerciseAction
    def set_exerciseAction(self, exerciseAction): self.exerciseAction = exerciseAction
    def get_expiry(self): return self.expiry
    def set_expiry(self, expiry): self.expiry = expiry
    def get_fullExercise(self): return self.fullExercise
    def set_fullExercise(self, fullExercise): self.fullExercise = fullExercise
    def get_exerciseInNotionalAmount(self): return self.exerciseInNotionalAmount
    def set_exerciseInNotionalAmount(self, exerciseInNotionalAmount): self.exerciseInNotionalAmount = exerciseInNotionalAmount
    def get_outstandingNotionalAmount(self): return self.outstandingNotionalAmount
    def set_outstandingNotionalAmount(self, outstandingNotionalAmount): self.outstandingNotionalAmount = outstandingNotionalAmount
    def get_exerciseInNumberOfOptions(self): return self.exerciseInNumberOfOptions
    def set_exerciseInNumberOfOptions(self, exerciseInNumberOfOptions): self.exerciseInNumberOfOptions = exerciseInNumberOfOptions
    def get_outstandingNumberOfOptions(self): return self.outstandingNumberOfOptions
    def set_outstandingNumberOfOptions(self, outstandingNumberOfOptions): self.outstandingNumberOfOptions = outstandingNumberOfOptions
    def get_exerciseInNumberOfUnits(self): return self.exerciseInNumberOfUnits
    def set_exerciseInNumberOfUnits(self, exerciseInNumberOfUnits): self.exerciseInNumberOfUnits = exerciseInNumberOfUnits
    def get_outstandingNumberOfUnits(self): return self.outstandingNumberOfUnits
    def set_outstandingNumberOfUnits(self, outstandingNumberOfUnits): self.outstandingNumberOfUnits = outstandingNumberOfUnits
    def get_specifiedExercise(self): return self.specifiedExercise
    def set_specifiedExercise(self, specifiedExercise): self.specifiedExercise = specifiedExercise
    def add_specifiedExercise(self, value): self.specifiedExercise.append(value)
    def insert_specifiedExercise_at(self, index, value): self.specifiedExercise.insert(index, value)
    def replace_specifiedExercise_at(self, index, value): self.specifiedExercise[index] = value
    def get_exerciseSide(self): return self.exerciseSide
    def set_exerciseSide(self, exerciseSide): self.exerciseSide = exerciseSide
    def get_settlementType(self): return self.settlementType
    def set_settlementType(self, settlementType): self.settlementType = settlementType
    def get_cashSettlement(self): return self.cashSettlement
    def set_cashSettlement(self, cashSettlement): self.cashSettlement = cashSettlement
    def get_physicalSettlement(self): return self.physicalSettlement
    def set_physicalSettlement(self, physicalSettlement): self.physicalSettlement = physicalSettlement
    def get_payment(self): return self.payment
    def set_payment(self, payment): self.payment = payment
    def get_clearingInstructions(self): return self.clearingInstructions
    def set_clearingInstructions(self, clearingInstructions): self.clearingInstructions = clearingInstructions
    def validate_ExerciseTimingEnum(self, value):
        # Validate type ExerciseTimingEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Immediate', 'OnExpiration']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ExerciseTimingEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on ExerciseTimingEnum' % {"value" : value} )
    def validate_ExerciseActionEnum(self, value):
        # Validate type ExerciseActionEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FullExercise', 'PartialExercise', 'Abandon']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ExerciseActionEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on ExerciseActionEnum' % {"value" : value} )
    def validate_ExerciseSideEnum(self, value):
        # Validate type ExerciseSideEnum, a restriction on Token.
        pass
    def validate_SettlementTypeEnum(self, value):
        # Validate type SettlementTypeEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Cash', 'Physical', 'Election', 'CashOrPhysical']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SettlementTypeEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on SettlementTypeEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.optionSeller is not None or
            self.optionBuyer is not None or
            self.originalTrade is not None or
            self.tradeIdentifier or
            self.exerciseDate is not None or
            self.exerciseTime is not None or
            self.exerciseTiming is not None or
            self.exerciseAction is not None or
            self.expiry is not None or
            self.fullExercise is not None or
            self.exerciseInNotionalAmount is not None or
            self.outstandingNotionalAmount is not None or
            self.exerciseInNumberOfOptions is not None or
            self.outstandingNumberOfOptions is not None or
            self.exerciseInNumberOfUnits is not None or
            self.outstandingNumberOfUnits is not None or
            self.specifiedExercise or
            self.exerciseSide is not None or
            self.settlementType is not None or
            self.cashSettlement is not None or
            self.physicalSettlement is not None or
            self.payment is not None or
            self.clearingInstructions is not None or
            super(OptionExercise, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OptionExercise', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OptionExercise')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OptionExercise', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OptionExercise'):
        super(OptionExercise, self).exportAttributes(outfile, level, already_processed, namespace_, name_='OptionExercise')
    def exportChildren(self, outfile, level, namespace_='', name_='OptionExercise', fromsubclass_=False, pretty_print=True):
        super(OptionExercise, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.optionSeller is not None:
            self.optionSeller.export(outfile, level, namespace_, name_='optionSeller', pretty_print=pretty_print)
        if self.optionBuyer is not None:
            self.optionBuyer.export(outfile, level, namespace_, name_='optionBuyer', pretty_print=pretty_print)
        if self.originalTrade is not None:
            self.originalTrade.export(outfile, level, namespace_, name_='originalTrade', pretty_print=pretty_print)
        for tradeIdentifier_ in self.tradeIdentifier:
            tradeIdentifier_.export(outfile, level, namespace_, name_='tradeIdentifier', pretty_print=pretty_print)
        if self.exerciseDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexerciseDate>%s</%sexerciseDate>%s' % (namespace_, self.gds_format_date(self.exerciseDate, input_name='exerciseDate'), namespace_, eol_))
        if self.exerciseTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexerciseTime>%s</%sexerciseTime>%s' % (namespace_, self.gds_format_time(self.exerciseTime, input_name='exerciseTime'), namespace_, eol_))
        if self.exerciseTiming is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexerciseTiming>%s</%sexerciseTiming>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.exerciseTiming), input_name='exerciseTiming')), namespace_, eol_))
        if self.exerciseAction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexerciseAction>%s</%sexerciseAction>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.exerciseAction), input_name='exerciseAction')), namespace_, eol_))
        if self.expiry is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexpiry>%s</%sexpiry>%s' % (namespace_, self.gds_format_boolean(self.expiry, input_name='expiry'), namespace_, eol_))
        if self.fullExercise is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfullExercise>%s</%sfullExercise>%s' % (namespace_, self.gds_format_boolean(self.fullExercise, input_name='fullExercise'), namespace_, eol_))
        if self.exerciseInNotionalAmount is not None:
            self.exerciseInNotionalAmount.export(outfile, level, namespace_, name_='exerciseInNotionalAmount', pretty_print=pretty_print)
        if self.outstandingNotionalAmount is not None:
            self.outstandingNotionalAmount.export(outfile, level, namespace_, name_='outstandingNotionalAmount', pretty_print=pretty_print)
        if self.exerciseInNumberOfOptions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexerciseInNumberOfOptions>%s</%sexerciseInNumberOfOptions>%s' % (namespace_, self.gds_format_float(self.exerciseInNumberOfOptions, input_name='exerciseInNumberOfOptions'), namespace_, eol_))
        if self.outstandingNumberOfOptions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soutstandingNumberOfOptions>%s</%soutstandingNumberOfOptions>%s' % (namespace_, self.gds_format_float(self.outstandingNumberOfOptions, input_name='outstandingNumberOfOptions'), namespace_, eol_))
        if self.exerciseInNumberOfUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexerciseInNumberOfUnits>%s</%sexerciseInNumberOfUnits>%s' % (namespace_, self.gds_format_float(self.exerciseInNumberOfUnits, input_name='exerciseInNumberOfUnits'), namespace_, eol_))
        if self.outstandingNumberOfUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soutstandingNumberOfUnits>%s</%soutstandingNumberOfUnits>%s' % (namespace_, self.gds_format_float(self.outstandingNumberOfUnits, input_name='outstandingNumberOfUnits'), namespace_, eol_))
        for specifiedExercise_ in self.specifiedExercise:
            specifiedExercise_.export(outfile, level, namespace_, name_='specifiedExercise', pretty_print=pretty_print)
        if self.exerciseSide is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexerciseSide>%s</%sexerciseSide>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.exerciseSide), input_name='exerciseSide')), namespace_, eol_))
        if self.settlementType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssettlementType>%s</%ssettlementType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.settlementType), input_name='settlementType')), namespace_, eol_))
        if self.cashSettlement is not None:
            self.cashSettlement.export(outfile, level, namespace_, name_='cashSettlement', pretty_print=pretty_print)
        if self.physicalSettlement is not None:
            self.physicalSettlement.export(outfile, level, namespace_, name_='physicalSettlement', pretty_print=pretty_print)
        if self.payment is not None:
            self.payment.export(outfile, level, namespace_, name_='payment', pretty_print=pretty_print)
        if self.clearingInstructions is not None:
            self.clearingInstructions.export(outfile, level, namespace_, name_='clearingInstructions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(OptionExercise, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'optionSeller':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.optionSeller = obj_
            obj_.original_tagname_ = 'optionSeller'
        elif nodeName_ == 'optionBuyer':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.optionBuyer = obj_
            obj_.original_tagname_ = 'optionBuyer'
        elif nodeName_ == 'originalTrade':
            obj_ = Trade.factory()
            obj_.build(child_)
            self.originalTrade = obj_
            obj_.original_tagname_ = 'originalTrade'
        elif nodeName_ == 'tradeIdentifier':
            obj_ = PartyTradeIdentifier.factory()
            obj_.build(child_)
            self.tradeIdentifier.append(obj_)
            obj_.original_tagname_ = 'tradeIdentifier'
        elif nodeName_ == 'exerciseDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.exerciseDate = dval_
        elif nodeName_ == 'exerciseTime':
            sval_ = child_.text
            dval_ = self.gds_parse_time(sval_)
            self.exerciseTime = dval_
        elif nodeName_ == 'exerciseTiming':
            exerciseTiming_ = child_.text
            exerciseTiming_ = re_.sub(String_cleanup_pat_, " ", exerciseTiming_).strip()
            exerciseTiming_ = self.gds_validate_string(exerciseTiming_, node, 'exerciseTiming')
            self.exerciseTiming = exerciseTiming_
            # validate type ExerciseTimingEnum
            self.validate_ExerciseTimingEnum(self.exerciseTiming)
        elif nodeName_ == 'exerciseAction':
            exerciseAction_ = child_.text
            exerciseAction_ = re_.sub(String_cleanup_pat_, " ", exerciseAction_).strip()
            exerciseAction_ = self.gds_validate_string(exerciseAction_, node, 'exerciseAction')
            self.exerciseAction = exerciseAction_
            # validate type ExerciseActionEnum
            self.validate_ExerciseActionEnum(self.exerciseAction)
        elif nodeName_ == 'expiry':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'expiry')
            self.expiry = ival_
        elif nodeName_ == 'fullExercise':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'fullExercise')
            self.fullExercise = ival_
        elif nodeName_ == 'exerciseInNotionalAmount':
            obj_ = Money.factory()
            obj_.build(child_)
            self.exerciseInNotionalAmount = obj_
            obj_.original_tagname_ = 'exerciseInNotionalAmount'
        elif nodeName_ == 'outstandingNotionalAmount':
            obj_ = Money.factory()
            obj_.build(child_)
            self.outstandingNotionalAmount = obj_
            obj_.original_tagname_ = 'outstandingNotionalAmount'
        elif nodeName_ == 'exerciseInNumberOfOptions':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'exerciseInNumberOfOptions')
            self.exerciseInNumberOfOptions = fval_
        elif nodeName_ == 'outstandingNumberOfOptions':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'outstandingNumberOfOptions')
            self.outstandingNumberOfOptions = fval_
        elif nodeName_ == 'exerciseInNumberOfUnits':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'exerciseInNumberOfUnits')
            self.exerciseInNumberOfUnits = fval_
        elif nodeName_ == 'outstandingNumberOfUnits':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'outstandingNumberOfUnits')
            self.outstandingNumberOfUnits = fval_
        elif nodeName_ == 'specifiedExercise':
            obj_ = OptionExerciseAmounts.factory()
            obj_.build(child_)
            self.specifiedExercise.append(obj_)
            obj_.original_tagname_ = 'specifiedExercise'
        elif nodeName_ == 'exerciseSide':
            exerciseSide_ = child_.text
            exerciseSide_ = re_.sub(String_cleanup_pat_, " ", exerciseSide_).strip()
            exerciseSide_ = self.gds_validate_string(exerciseSide_, node, 'exerciseSide')
            self.exerciseSide = exerciseSide_
            # validate type ExerciseSideEnum
            self.validate_ExerciseSideEnum(self.exerciseSide)
        elif nodeName_ == 'settlementType':
            settlementType_ = child_.text
            settlementType_ = re_.sub(String_cleanup_pat_, " ", settlementType_).strip()
            settlementType_ = self.gds_validate_string(settlementType_, node, 'settlementType')
            self.settlementType = settlementType_
            # validate type SettlementTypeEnum
            self.validate_SettlementTypeEnum(self.settlementType)
        elif nodeName_ == 'cashSettlement':
            obj_ = SimplePayment.factory()
            obj_.build(child_)
            self.cashSettlement = obj_
            obj_.original_tagname_ = 'cashSettlement'
        elif nodeName_ == 'physicalSettlement':
            obj_ = PhysicalSettlement.factory()
            obj_.build(child_)
            self.physicalSettlement = obj_
            obj_.original_tagname_ = 'physicalSettlement'
        elif nodeName_ == 'payment':
            obj_ = NonNegativePayment.factory()
            obj_.build(child_)
            self.payment = obj_
            obj_.original_tagname_ = 'payment'
        elif nodeName_ == 'clearingInstructions':
            obj_ = ClearingInstructions.factory()
            obj_.build(child_)
            self.clearingInstructions = obj_
            obj_.original_tagname_ = 'clearingInstructions'
        super(OptionExercise, self).buildChildren(child_, node, nodeName_, True)
# end class OptionExercise


class OptionExerciseAmounts(GeneratedsSuper):
    member_data_items_ = {
        'notionalReference': MemberSpec_('notionalReference', 'NotionalReference', 0),
        'exerciseInNotionalAmount': MemberSpec_('exerciseInNotionalAmount', 'Money', 0),
        'outstandingNotionalAmount': MemberSpec_('outstandingNotionalAmount', 'Money', 0),
        'notionalScheduleReference': MemberSpec_('notionalScheduleReference', 'NotionalReference', 0),
        'exerciseInNotionalSchedule': MemberSpec_('exerciseInNotionalSchedule', 'NonNegativeAmountSchedule', 0),
        'outstandingNotionalSchedule': MemberSpec_('outstandingNotionalSchedule', 'NonNegativeAmountSchedule', 0),
        'numberOfOptionsReference': MemberSpec_('numberOfOptionsReference', 'NumberOfOptionsReference', 0),
        'exerciseInNumberOfOptions': MemberSpec_('exerciseInNumberOfOptions', 'xsd:decimal', 0),
        'outstandingNumberOfOptions': MemberSpec_('outstandingNumberOfOptions', 'xsd:decimal', 0),
        'numberOfUnitsReference': MemberSpec_('numberOfUnitsReference', 'NumberOfUnitsReference', 0),
        'exerciseInNumberOfUnits': MemberSpec_('exerciseInNumberOfUnits', 'xsd:decimal', 0),
        'outstandingNumberOfUnits': MemberSpec_('outstandingNumberOfUnits', 'xsd:decimal', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, notionalReference=None, exerciseInNotionalAmount=None, outstandingNotionalAmount=None, notionalScheduleReference=None, exerciseInNotionalSchedule=None, outstandingNotionalSchedule=None, numberOfOptionsReference=None, exerciseInNumberOfOptions=None, outstandingNumberOfOptions=None, numberOfUnitsReference=None, exerciseInNumberOfUnits=None, outstandingNumberOfUnits=None):
        self.original_tagname_ = None
        self.notionalReference = notionalReference
        self.exerciseInNotionalAmount = exerciseInNotionalAmount
        self.outstandingNotionalAmount = outstandingNotionalAmount
        self.notionalScheduleReference = notionalScheduleReference
        self.exerciseInNotionalSchedule = exerciseInNotionalSchedule
        self.outstandingNotionalSchedule = outstandingNotionalSchedule
        self.numberOfOptionsReference = numberOfOptionsReference
        self.exerciseInNumberOfOptions = exerciseInNumberOfOptions
        self.outstandingNumberOfOptions = outstandingNumberOfOptions
        self.numberOfUnitsReference = numberOfUnitsReference
        self.exerciseInNumberOfUnits = exerciseInNumberOfUnits
        self.outstandingNumberOfUnits = outstandingNumberOfUnits
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OptionExerciseAmounts)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OptionExerciseAmounts.subclass:
            return OptionExerciseAmounts.subclass(*args_, **kwargs_)
        else:
            return OptionExerciseAmounts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_notionalReference(self): return self.notionalReference
    def set_notionalReference(self, notionalReference): self.notionalReference = notionalReference
    def get_exerciseInNotionalAmount(self): return self.exerciseInNotionalAmount
    def set_exerciseInNotionalAmount(self, exerciseInNotionalAmount): self.exerciseInNotionalAmount = exerciseInNotionalAmount
    def get_outstandingNotionalAmount(self): return self.outstandingNotionalAmount
    def set_outstandingNotionalAmount(self, outstandingNotionalAmount): self.outstandingNotionalAmount = outstandingNotionalAmount
    def get_notionalScheduleReference(self): return self.notionalScheduleReference
    def set_notionalScheduleReference(self, notionalScheduleReference): self.notionalScheduleReference = notionalScheduleReference
    def get_exerciseInNotionalSchedule(self): return self.exerciseInNotionalSchedule
    def set_exerciseInNotionalSchedule(self, exerciseInNotionalSchedule): self.exerciseInNotionalSchedule = exerciseInNotionalSchedule
    def get_outstandingNotionalSchedule(self): return self.outstandingNotionalSchedule
    def set_outstandingNotionalSchedule(self, outstandingNotionalSchedule): self.outstandingNotionalSchedule = outstandingNotionalSchedule
    def get_numberOfOptionsReference(self): return self.numberOfOptionsReference
    def set_numberOfOptionsReference(self, numberOfOptionsReference): self.numberOfOptionsReference = numberOfOptionsReference
    def get_exerciseInNumberOfOptions(self): return self.exerciseInNumberOfOptions
    def set_exerciseInNumberOfOptions(self, exerciseInNumberOfOptions): self.exerciseInNumberOfOptions = exerciseInNumberOfOptions
    def get_outstandingNumberOfOptions(self): return self.outstandingNumberOfOptions
    def set_outstandingNumberOfOptions(self, outstandingNumberOfOptions): self.outstandingNumberOfOptions = outstandingNumberOfOptions
    def get_numberOfUnitsReference(self): return self.numberOfUnitsReference
    def set_numberOfUnitsReference(self, numberOfUnitsReference): self.numberOfUnitsReference = numberOfUnitsReference
    def get_exerciseInNumberOfUnits(self): return self.exerciseInNumberOfUnits
    def set_exerciseInNumberOfUnits(self, exerciseInNumberOfUnits): self.exerciseInNumberOfUnits = exerciseInNumberOfUnits
    def get_outstandingNumberOfUnits(self): return self.outstandingNumberOfUnits
    def set_outstandingNumberOfUnits(self, outstandingNumberOfUnits): self.outstandingNumberOfUnits = outstandingNumberOfUnits
    def hasContent_(self):
        if (
            self.notionalReference is not None or
            self.exerciseInNotionalAmount is not None or
            self.outstandingNotionalAmount is not None or
            self.notionalScheduleReference is not None or
            self.exerciseInNotionalSchedule is not None or
            self.outstandingNotionalSchedule is not None or
            self.numberOfOptionsReference is not None or
            self.exerciseInNumberOfOptions is not None or
            self.outstandingNumberOfOptions is not None or
            self.numberOfUnitsReference is not None or
            self.exerciseInNumberOfUnits is not None or
            self.outstandingNumberOfUnits is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OptionExerciseAmounts', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OptionExerciseAmounts')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OptionExerciseAmounts', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OptionExerciseAmounts'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OptionExerciseAmounts', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.notionalReference is not None:
            self.notionalReference.export(outfile, level, namespace_, name_='notionalReference', pretty_print=pretty_print)
        if self.exerciseInNotionalAmount is not None:
            self.exerciseInNotionalAmount.export(outfile, level, namespace_, name_='exerciseInNotionalAmount', pretty_print=pretty_print)
        if self.outstandingNotionalAmount is not None:
            self.outstandingNotionalAmount.export(outfile, level, namespace_, name_='outstandingNotionalAmount', pretty_print=pretty_print)
        if self.notionalScheduleReference is not None:
            self.notionalScheduleReference.export(outfile, level, namespace_, name_='notionalScheduleReference', pretty_print=pretty_print)
        if self.exerciseInNotionalSchedule is not None:
            self.exerciseInNotionalSchedule.export(outfile, level, namespace_, name_='exerciseInNotionalSchedule', pretty_print=pretty_print)
        if self.outstandingNotionalSchedule is not None:
            self.outstandingNotionalSchedule.export(outfile, level, namespace_, name_='outstandingNotionalSchedule', pretty_print=pretty_print)
        if self.numberOfOptionsReference is not None:
            self.numberOfOptionsReference.export(outfile, level, namespace_, name_='numberOfOptionsReference', pretty_print=pretty_print)
        if self.exerciseInNumberOfOptions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexerciseInNumberOfOptions>%s</%sexerciseInNumberOfOptions>%s' % (namespace_, self.gds_format_float(self.exerciseInNumberOfOptions, input_name='exerciseInNumberOfOptions'), namespace_, eol_))
        if self.outstandingNumberOfOptions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soutstandingNumberOfOptions>%s</%soutstandingNumberOfOptions>%s' % (namespace_, self.gds_format_float(self.outstandingNumberOfOptions, input_name='outstandingNumberOfOptions'), namespace_, eol_))
        if self.numberOfUnitsReference is not None:
            self.numberOfUnitsReference.export(outfile, level, namespace_, name_='numberOfUnitsReference', pretty_print=pretty_print)
        if self.exerciseInNumberOfUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexerciseInNumberOfUnits>%s</%sexerciseInNumberOfUnits>%s' % (namespace_, self.gds_format_float(self.exerciseInNumberOfUnits, input_name='exerciseInNumberOfUnits'), namespace_, eol_))
        if self.outstandingNumberOfUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soutstandingNumberOfUnits>%s</%soutstandingNumberOfUnits>%s' % (namespace_, self.gds_format_float(self.outstandingNumberOfUnits, input_name='outstandingNumberOfUnits'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'notionalReference':
            obj_ = NotionalReference.factory()
            obj_.build(child_)
            self.notionalReference = obj_
            obj_.original_tagname_ = 'notionalReference'
        elif nodeName_ == 'exerciseInNotionalAmount':
            obj_ = Money.factory()
            obj_.build(child_)
            self.exerciseInNotionalAmount = obj_
            obj_.original_tagname_ = 'exerciseInNotionalAmount'
        elif nodeName_ == 'outstandingNotionalAmount':
            obj_ = Money.factory()
            obj_.build(child_)
            self.outstandingNotionalAmount = obj_
            obj_.original_tagname_ = 'outstandingNotionalAmount'
        elif nodeName_ == 'notionalScheduleReference':
            obj_ = NotionalReference.factory()
            obj_.build(child_)
            self.notionalScheduleReference = obj_
            obj_.original_tagname_ = 'notionalScheduleReference'
        elif nodeName_ == 'exerciseInNotionalSchedule':
            obj_ = NonNegativeAmountSchedule.factory()
            obj_.build(child_)
            self.exerciseInNotionalSchedule = obj_
            obj_.original_tagname_ = 'exerciseInNotionalSchedule'
        elif nodeName_ == 'outstandingNotionalSchedule':
            obj_ = NonNegativeAmountSchedule.factory()
            obj_.build(child_)
            self.outstandingNotionalSchedule = obj_
            obj_.original_tagname_ = 'outstandingNotionalSchedule'
        elif nodeName_ == 'numberOfOptionsReference':
            obj_ = NumberOfOptionsReference.factory()
            obj_.build(child_)
            self.numberOfOptionsReference = obj_
            obj_.original_tagname_ = 'numberOfOptionsReference'
        elif nodeName_ == 'exerciseInNumberOfOptions':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'exerciseInNumberOfOptions')
            self.exerciseInNumberOfOptions = fval_
        elif nodeName_ == 'outstandingNumberOfOptions':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'outstandingNumberOfOptions')
            self.outstandingNumberOfOptions = fval_
        elif nodeName_ == 'numberOfUnitsReference':
            obj_ = NumberOfUnitsReference.factory()
            obj_.build(child_)
            self.numberOfUnitsReference = obj_
            obj_.original_tagname_ = 'numberOfUnitsReference'
        elif nodeName_ == 'exerciseInNumberOfUnits':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'exerciseInNumberOfUnits')
            self.exerciseInNumberOfUnits = fval_
        elif nodeName_ == 'outstandingNumberOfUnits':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'outstandingNumberOfUnits')
            self.outstandingNumberOfUnits = fval_
# end class OptionExerciseAmounts


class OptionExpiry(AbstractEvent):
    """A structure describing an option expiring (i.e. passing its last
    exercise time and becoming worthless.)"""
    member_data_items_ = {
        'originalTrade': MemberSpec_('originalTrade', 'Trade', 0),
        'tradeIdentifier': MemberSpec_('tradeIdentifier', 'PartyTradeIdentifier', 1),
        'date': MemberSpec_('date', 'xsd:date', 0),
        'time': MemberSpec_('time', 'xsd:time', 0),
        'exerciseProcedure': MemberSpec_('exerciseProcedure', 'ExerciseProcedureOption', 0),
        'actionOnExpiration': MemberSpec_('actionOnExpiration', 'ActionOnExpiration', 0),
    }
    subclass = None
    superclass = AbstractEvent
    def __init__(self, eventIdentifier=None, originalTrade=None, tradeIdentifier=None, date=None, time=None, exerciseProcedure=None, actionOnExpiration=None):
        self.original_tagname_ = None
        super(OptionExpiry, self).__init__(eventIdentifier, )
        self.originalTrade = originalTrade
        if tradeIdentifier is None:
            self.tradeIdentifier = []
        else:
            self.tradeIdentifier = tradeIdentifier
        if isinstance(date, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(date, '%Y-%m-%d').date()
        else:
            initvalue_ = date
        self.date = initvalue_
        if isinstance(time, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(time, '%H:%M:%S').time()
        else:
            initvalue_ = time
        self.time = initvalue_
        self.exerciseProcedure = exerciseProcedure
        self.actionOnExpiration = actionOnExpiration
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OptionExpiry)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OptionExpiry.subclass:
            return OptionExpiry.subclass(*args_, **kwargs_)
        else:
            return OptionExpiry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_originalTrade(self): return self.originalTrade
    def set_originalTrade(self, originalTrade): self.originalTrade = originalTrade
    def get_tradeIdentifier(self): return self.tradeIdentifier
    def set_tradeIdentifier(self, tradeIdentifier): self.tradeIdentifier = tradeIdentifier
    def add_tradeIdentifier(self, value): self.tradeIdentifier.append(value)
    def insert_tradeIdentifier_at(self, index, value): self.tradeIdentifier.insert(index, value)
    def replace_tradeIdentifier_at(self, index, value): self.tradeIdentifier[index] = value
    def get_date(self): return self.date
    def set_date(self, date): self.date = date
    def get_time(self): return self.time
    def set_time(self, time): self.time = time
    def get_exerciseProcedure(self): return self.exerciseProcedure
    def set_exerciseProcedure(self, exerciseProcedure): self.exerciseProcedure = exerciseProcedure
    def get_actionOnExpiration(self): return self.actionOnExpiration
    def set_actionOnExpiration(self, actionOnExpiration): self.actionOnExpiration = actionOnExpiration
    def hasContent_(self):
        if (
            self.originalTrade is not None or
            self.tradeIdentifier or
            self.date is not None or
            self.time is not None or
            self.exerciseProcedure is not None or
            self.actionOnExpiration is not None or
            super(OptionExpiry, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OptionExpiry', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OptionExpiry')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OptionExpiry', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OptionExpiry'):
        super(OptionExpiry, self).exportAttributes(outfile, level, already_processed, namespace_, name_='OptionExpiry')
    def exportChildren(self, outfile, level, namespace_='', name_='OptionExpiry', fromsubclass_=False, pretty_print=True):
        super(OptionExpiry, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.originalTrade is not None:
            self.originalTrade.export(outfile, level, namespace_, name_='originalTrade', pretty_print=pretty_print)
        for tradeIdentifier_ in self.tradeIdentifier:
            tradeIdentifier_.export(outfile, level, namespace_, name_='tradeIdentifier', pretty_print=pretty_print)
        if self.date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdate>%s</%sdate>%s' % (namespace_, self.gds_format_date(self.date, input_name='date'), namespace_, eol_))
        if self.time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stime>%s</%stime>%s' % (namespace_, self.gds_format_time(self.time, input_name='time'), namespace_, eol_))
        if self.exerciseProcedure is not None:
            self.exerciseProcedure.export(outfile, level, namespace_, name_='exerciseProcedure', pretty_print=pretty_print)
        if self.actionOnExpiration is not None:
            self.actionOnExpiration.export(outfile, level, namespace_, name_='actionOnExpiration', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(OptionExpiry, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'originalTrade':
            obj_ = Trade.factory()
            obj_.build(child_)
            self.originalTrade = obj_
            obj_.original_tagname_ = 'originalTrade'
        elif nodeName_ == 'tradeIdentifier':
            obj_ = PartyTradeIdentifier.factory()
            obj_.build(child_)
            self.tradeIdentifier.append(obj_)
            obj_.original_tagname_ = 'tradeIdentifier'
        elif nodeName_ == 'date':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.date = dval_
        elif nodeName_ == 'time':
            sval_ = child_.text
            dval_ = self.gds_parse_time(sval_)
            self.time = dval_
        elif nodeName_ == 'exerciseProcedure':
            obj_ = ExerciseProcedureOption.factory()
            obj_.build(child_)
            self.exerciseProcedure = obj_
            obj_.original_tagname_ = 'exerciseProcedure'
        elif nodeName_ == 'actionOnExpiration':
            obj_ = ActionOnExpiration.factory()
            obj_.build(child_)
            self.actionOnExpiration = obj_
            obj_.original_tagname_ = 'actionOnExpiration'
        super(OptionExpiry, self).buildChildren(child_, node, nodeName_, True)
# end class OptionExpiry


class OptionExpiryBase(GeneratedsSuper):
    """A structure describing an option expiring."""
    member_data_items_ = {
        'tradeIdentifier': MemberSpec_('tradeIdentifier', 'PartyTradeIdentifier', 1),
        'date': MemberSpec_('date', 'xsd:date', 0),
        'time': MemberSpec_('time', 'xsd:time', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, tradeIdentifier=None, date=None, time=None):
        self.original_tagname_ = None
        if tradeIdentifier is None:
            self.tradeIdentifier = []
        else:
            self.tradeIdentifier = tradeIdentifier
        if isinstance(date, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(date, '%Y-%m-%d').date()
        else:
            initvalue_ = date
        self.date = initvalue_
        if isinstance(time, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(time, '%H:%M:%S').time()
        else:
            initvalue_ = time
        self.time = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OptionExpiryBase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OptionExpiryBase.subclass:
            return OptionExpiryBase.subclass(*args_, **kwargs_)
        else:
            return OptionExpiryBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tradeIdentifier(self): return self.tradeIdentifier
    def set_tradeIdentifier(self, tradeIdentifier): self.tradeIdentifier = tradeIdentifier
    def add_tradeIdentifier(self, value): self.tradeIdentifier.append(value)
    def insert_tradeIdentifier_at(self, index, value): self.tradeIdentifier.insert(index, value)
    def replace_tradeIdentifier_at(self, index, value): self.tradeIdentifier[index] = value
    def get_date(self): return self.date
    def set_date(self, date): self.date = date
    def get_time(self): return self.time
    def set_time(self, time): self.time = time
    def hasContent_(self):
        if (
            self.tradeIdentifier or
            self.date is not None or
            self.time is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OptionExpiryBase', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OptionExpiryBase')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OptionExpiryBase', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OptionExpiryBase'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OptionExpiryBase', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for tradeIdentifier_ in self.tradeIdentifier:
            tradeIdentifier_.export(outfile, level, namespace_, name_='tradeIdentifier', pretty_print=pretty_print)
        if self.date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdate>%s</%sdate>%s' % (namespace_, self.gds_format_date(self.date, input_name='date'), namespace_, eol_))
        if self.time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stime>%s</%stime>%s' % (namespace_, self.gds_format_time(self.time, input_name='time'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tradeIdentifier':
            obj_ = PartyTradeIdentifier.factory()
            obj_.build(child_)
            self.tradeIdentifier.append(obj_)
            obj_.original_tagname_ = 'tradeIdentifier'
        elif nodeName_ == 'date':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.date = dval_
        elif nodeName_ == 'time':
            sval_ = child_.text
            dval_ = self.gds_parse_time(sval_)
            self.time = dval_
# end class OptionExpiryBase


class PackageHeader(GeneratedsSuper):
    """Identifying information for a tradePackage (a bundle of trades)."""
    member_data_items_ = {
        'packageIdentifier': MemberSpec_('packageIdentifier', 'IssuerTradeId', 0),
        'orderIdentifier': MemberSpec_('orderIdentifier', 'OrderIdentifier', 0),
        'packageType': MemberSpec_('packageType', 'PackageType', 1),
        'size': MemberSpec_('size', ['PositiveDecimal', 'xsd:decimal'], 0),
        'originatingEvent': MemberSpec_('originatingEvent', 'OriginatingEvent', 0),
        'packageInformation': MemberSpec_('packageInformation', 'PackageInformation', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, packageIdentifier=None, orderIdentifier=None, packageType=None, size=None, originatingEvent=None, packageInformation=None):
        self.original_tagname_ = None
        self.packageIdentifier = packageIdentifier
        self.orderIdentifier = orderIdentifier
        if packageType is None:
            self.packageType = []
        else:
            self.packageType = packageType
        self.size = size
        self.validate_PositiveDecimal(self.size)
        self.originatingEvent = originatingEvent
        self.packageInformation = packageInformation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PackageHeader)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PackageHeader.subclass:
            return PackageHeader.subclass(*args_, **kwargs_)
        else:
            return PackageHeader(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_packageIdentifier(self): return self.packageIdentifier
    def set_packageIdentifier(self, packageIdentifier): self.packageIdentifier = packageIdentifier
    def get_orderIdentifier(self): return self.orderIdentifier
    def set_orderIdentifier(self, orderIdentifier): self.orderIdentifier = orderIdentifier
    def get_packageType(self): return self.packageType
    def set_packageType(self, packageType): self.packageType = packageType
    def add_packageType(self, value): self.packageType.append(value)
    def insert_packageType_at(self, index, value): self.packageType.insert(index, value)
    def replace_packageType_at(self, index, value): self.packageType[index] = value
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def get_originatingEvent(self): return self.originatingEvent
    def set_originatingEvent(self, originatingEvent): self.originatingEvent = originatingEvent
    def get_packageInformation(self): return self.packageInformation
    def set_packageInformation(self, packageInformation): self.packageInformation = packageInformation
    def validate_PositiveDecimal(self, value):
        # Validate type PositiveDecimal, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value <= 0:
                warnings_.warn('Value "%(value)s" does not match xsd minExclusive restriction on PositiveDecimal' % {"value" : value} )
    def hasContent_(self):
        if (
            self.packageIdentifier is not None or
            self.orderIdentifier is not None or
            self.packageType or
            self.size is not None or
            self.originatingEvent is not None or
            self.packageInformation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PackageHeader', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PackageHeader')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PackageHeader', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PackageHeader'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PackageHeader', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.packageIdentifier is not None:
            self.packageIdentifier.export(outfile, level, namespace_, name_='packageIdentifier', pretty_print=pretty_print)
        if self.orderIdentifier is not None:
            self.orderIdentifier.export(outfile, level, namespace_, name_='orderIdentifier', pretty_print=pretty_print)
        for packageType_ in self.packageType:
            packageType_.export(outfile, level, namespace_, name_='packageType', pretty_print=pretty_print)
        if self.size is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssize>%s</%ssize>%s' % (namespace_, self.gds_format_float(self.size, input_name='size'), namespace_, eol_))
        if self.originatingEvent is not None:
            self.originatingEvent.export(outfile, level, namespace_, name_='originatingEvent', pretty_print=pretty_print)
        if self.packageInformation is not None:
            self.packageInformation.export(outfile, level, namespace_, name_='packageInformation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'packageIdentifier':
            obj_ = IssuerTradeId.factory()
            obj_.build(child_)
            self.packageIdentifier = obj_
            obj_.original_tagname_ = 'packageIdentifier'
        elif nodeName_ == 'orderIdentifier':
            obj_ = OrderIdentifier.factory()
            obj_.build(child_)
            self.orderIdentifier = obj_
            obj_.original_tagname_ = 'orderIdentifier'
        elif nodeName_ == 'packageType':
            obj_ = PackageType.factory()
            obj_.build(child_)
            self.packageType.append(obj_)
            obj_.original_tagname_ = 'packageType'
        elif nodeName_ == 'size':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'size')
            self.size = fval_
            # validate type PositiveDecimal
            self.validate_PositiveDecimal(self.size)
        elif nodeName_ == 'originatingEvent':
            obj_ = OriginatingEvent.factory()
            obj_.build(child_)
            self.originatingEvent = obj_
            obj_.original_tagname_ = 'originatingEvent'
        elif nodeName_ == 'packageInformation':
            obj_ = PackageInformation.factory()
            obj_.build(child_)
            self.packageInformation = obj_
            obj_.original_tagname_ = 'packageInformation'
# end class PackageHeader


class PhysicalSettlement(GeneratedsSuper):
    """A structure that describes how an option settles into a physical
    trade."""
    member_data_items_ = {
        'resultingTradeIdentifier': MemberSpec_('resultingTradeIdentifier', 'PartyTradeIdentifier', 0),
        'resultingTrade': MemberSpec_('resultingTrade', 'Trade', 0),
        'product': MemberSpec_('product', 'Product', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, resultingTradeIdentifier=None, resultingTrade=None, product=None):
        self.original_tagname_ = None
        self.resultingTradeIdentifier = resultingTradeIdentifier
        self.resultingTrade = resultingTrade
        self.product = product
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalSettlement)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalSettlement.subclass:
            return PhysicalSettlement.subclass(*args_, **kwargs_)
        else:
            return PhysicalSettlement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_resultingTradeIdentifier(self): return self.resultingTradeIdentifier
    def set_resultingTradeIdentifier(self, resultingTradeIdentifier): self.resultingTradeIdentifier = resultingTradeIdentifier
    def get_resultingTrade(self): return self.resultingTrade
    def set_resultingTrade(self, resultingTrade): self.resultingTrade = resultingTrade
    def get_product(self): return self.product
    def set_product(self, product): self.product = product
    def hasContent_(self):
        if (
            self.resultingTradeIdentifier is not None or
            self.resultingTrade is not None or
            self.product is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PhysicalSettlement', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PhysicalSettlement')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PhysicalSettlement', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PhysicalSettlement'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PhysicalSettlement', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.resultingTradeIdentifier is not None:
            self.resultingTradeIdentifier.export(outfile, level, namespace_, name_='resultingTradeIdentifier', pretty_print=pretty_print)
        if self.resultingTrade is not None:
            self.resultingTrade.export(outfile, level, namespace_, name_='resultingTrade', pretty_print=pretty_print)
        if self.product is not None:
            self.product.export(outfile, level, namespace_, name_='product', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'resultingTradeIdentifier':
            obj_ = PartyTradeIdentifier.factory()
            obj_.build(child_)
            self.resultingTradeIdentifier = obj_
            obj_.original_tagname_ = 'resultingTradeIdentifier'
        elif nodeName_ == 'resultingTrade':
            obj_ = Trade.factory()
            obj_.build(child_)
            self.resultingTrade = obj_
            obj_.original_tagname_ = 'resultingTrade'
        elif nodeName_ == 'product':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <product> element')
            self.product = obj_
            obj_.original_tagname_ = 'product'
        elif nodeName_ == 'instrumentTradeDetails':
            obj_ = InstrumentTradeDetails.factory()
            obj_.build(child_)
            self.product = obj_
            obj_.original_tagname_ = 'instrumentTradeDetails'
        elif nodeName_ == 'strategy':
            obj_ = Strategy.factory()
            obj_.build(child_)
            self.product = obj_
            obj_.original_tagname_ = 'strategy'
# end class PhysicalSettlement


class ReportingRegimeIdentifier(GeneratedsSuper):
    """A type that provides identification for reporting regimes."""
    member_data_items_ = {
        'name': MemberSpec_('name', 'ReportingRegimeName', 0),
        'supervisorRegistration': MemberSpec_('supervisorRegistration', 'SupervisorRegistration', 1),
        'supervisorRegistration': MemberSpec_('supervisorRegistration', 'SupervisorRegistration', 1),
        'reportingRole': MemberSpec_('reportingRole', 'ReportingRole', 0),
        'actionType': MemberSpec_('actionType', 'ActionType', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, name=None, supervisorRegistration=None, reportingRole=None, actionType=None):
        self.original_tagname_ = None
        self.name = name
        if supervisorRegistration is None:
            self.supervisorRegistration = []
        else:
            self.supervisorRegistration = supervisorRegistration
        if supervisorRegistration is None:
            self.supervisorRegistration = []
        else:
            self.supervisorRegistration = supervisorRegistration
        self.reportingRole = reportingRole
        self.actionType = actionType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReportingRegimeIdentifier)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReportingRegimeIdentifier.subclass:
            return ReportingRegimeIdentifier.subclass(*args_, **kwargs_)
        else:
            return ReportingRegimeIdentifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_supervisorRegistration(self): return self.supervisorRegistration
    def set_supervisorRegistration(self, supervisorRegistration): self.supervisorRegistration = supervisorRegistration
    def add_supervisorRegistration(self, value): self.supervisorRegistration.append(value)
    def insert_supervisorRegistration_at(self, index, value): self.supervisorRegistration.insert(index, value)
    def replace_supervisorRegistration_at(self, index, value): self.supervisorRegistration[index] = value
    def get_supervisorRegistration(self): return self.supervisorRegistration
    def set_supervisorRegistration(self, supervisorRegistration): self.supervisorRegistration = supervisorRegistration
    def add_supervisorRegistration(self, value): self.supervisorRegistration.append(value)
    def insert_supervisorRegistration_at(self, index, value): self.supervisorRegistration.insert(index, value)
    def replace_supervisorRegistration_at(self, index, value): self.supervisorRegistration[index] = value
    def get_reportingRole(self): return self.reportingRole
    def set_reportingRole(self, reportingRole): self.reportingRole = reportingRole
    def get_actionType(self): return self.actionType
    def set_actionType(self, actionType): self.actionType = actionType
    def hasContent_(self):
        if (
            self.name is not None or
            self.supervisorRegistration or
            self.supervisorRegistration or
            self.reportingRole is not None or
            self.actionType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReportingRegimeIdentifier', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReportingRegimeIdentifier')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReportingRegimeIdentifier', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReportingRegimeIdentifier'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ReportingRegimeIdentifier', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            self.name.export(outfile, level, namespace_, name_='name', pretty_print=pretty_print)
        for supervisorRegistration_ in self.supervisorRegistration:
            supervisorRegistration_.export(outfile, level, namespace_, name_='supervisorRegistration', pretty_print=pretty_print)
        for supervisorRegistration_ in self.supervisorRegistration:
            supervisorRegistration_.export(outfile, level, namespace_, name_='supervisorRegistration', pretty_print=pretty_print)
        if self.reportingRole is not None:
            self.reportingRole.export(outfile, level, namespace_, name_='reportingRole', pretty_print=pretty_print)
        if self.actionType is not None:
            self.actionType.export(outfile, level, namespace_, name_='actionType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            obj_ = ReportingRegimeName.factory()
            obj_.build(child_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'supervisorRegistration':
            obj_ = SupervisorRegistration.factory()
            obj_.build(child_)
            self.supervisorRegistration.append(obj_)
            obj_.original_tagname_ = 'supervisorRegistration'
        elif nodeName_ == 'supervisorRegistration':
            obj_ = SupervisorRegistration.factory()
            obj_.build(child_)
            self.supervisorRegistration.append(obj_)
            obj_.original_tagname_ = 'supervisorRegistration'
        elif nodeName_ == 'reportingRole':
            obj_ = ReportingRole.factory()
            obj_.build(child_)
            self.reportingRole = obj_
            obj_.original_tagname_ = 'reportingRole'
        elif nodeName_ == 'actionType':
            obj_ = ActionType.factory()
            obj_.build(child_)
            self.actionType = obj_
            obj_.original_tagname_ = 'actionType'
# end class ReportingRegimeIdentifier


class RequestedClearingAction(GeneratedsSuper):
    """A type that describes whether a trade is to be cleared."""
    member_data_items_ = {
        'requestedClearingActionScheme': MemberSpec_('requestedClearingActionScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, requestedClearingActionScheme='http://www.fpml.org/coding-scheme/requested-clearing-action', valueOf_=None):
        self.original_tagname_ = None
        self.requestedClearingActionScheme = _cast(None, requestedClearingActionScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RequestedClearingAction)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RequestedClearingAction.subclass:
            return RequestedClearingAction.subclass(*args_, **kwargs_)
        else:
            return RequestedClearingAction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_requestedClearingActionScheme(self): return self.requestedClearingActionScheme
    def set_requestedClearingActionScheme(self, requestedClearingActionScheme): self.requestedClearingActionScheme = requestedClearingActionScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RequestedClearingAction', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RequestedClearingAction')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RequestedClearingAction', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RequestedClearingAction'):
        if self.requestedClearingActionScheme != "http://www.fpml.org/coding-scheme/requested-clearing-action" and 'requestedClearingActionScheme' not in already_processed:
            already_processed.add('requestedClearingActionScheme')
            outfile.write(' requestedClearingActionScheme=%s' % (quote_attrib(self.requestedClearingActionScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RequestedClearingAction', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('requestedClearingActionScheme', node)
        if value is not None and 'requestedClearingActionScheme' not in already_processed:
            already_processed.add('requestedClearingActionScheme')
            self.requestedClearingActionScheme = value
            self.validate_NonEmptyURI(self.requestedClearingActionScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RequestedClearingAction


class RequestedWithdrawalAction(GeneratedsSuper):
    """A type that describes what the requester would like to see done to
    implement the withdrawal, e.g. ExpungeRecords, RetainRecords."""
    member_data_items_ = {
        'requestedWithdrawalActionScheme': MemberSpec_('requestedWithdrawalActionScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, requestedWithdrawalActionScheme='http://www.fpml.org/coding-scheme/requested-withdrawal-action', valueOf_=None):
        self.original_tagname_ = None
        self.requestedWithdrawalActionScheme = _cast(None, requestedWithdrawalActionScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RequestedWithdrawalAction)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RequestedWithdrawalAction.subclass:
            return RequestedWithdrawalAction.subclass(*args_, **kwargs_)
        else:
            return RequestedWithdrawalAction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_requestedWithdrawalActionScheme(self): return self.requestedWithdrawalActionScheme
    def set_requestedWithdrawalActionScheme(self, requestedWithdrawalActionScheme): self.requestedWithdrawalActionScheme = requestedWithdrawalActionScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RequestedWithdrawalAction', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RequestedWithdrawalAction')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RequestedWithdrawalAction', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RequestedWithdrawalAction'):
        if self.requestedWithdrawalActionScheme != "http://www.fpml.org/coding-scheme/requested-withdrawal-action" and 'requestedWithdrawalActionScheme' not in already_processed:
            already_processed.add('requestedWithdrawalActionScheme')
            outfile.write(' requestedWithdrawalActionScheme=%s' % (quote_attrib(self.requestedWithdrawalActionScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RequestedWithdrawalAction', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('requestedWithdrawalActionScheme', node)
        if value is not None and 'requestedWithdrawalActionScheme' not in already_processed:
            already_processed.add('requestedWithdrawalActionScheme')
            self.requestedWithdrawalActionScheme = value
            self.validate_NonEmptyURI(self.requestedWithdrawalActionScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RequestedWithdrawalAction


class TerminatingEvent(GeneratedsSuper):
    """A type that describes why a trade terminated."""
    member_data_items_ = {
        'terminatingEventScheme': MemberSpec_('terminatingEventScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, terminatingEventScheme='http://www.fpml.org/coding-scheme/terminating-event', valueOf_=None):
        self.original_tagname_ = None
        self.terminatingEventScheme = _cast(None, terminatingEventScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TerminatingEvent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TerminatingEvent.subclass:
            return TerminatingEvent.subclass(*args_, **kwargs_)
        else:
            return TerminatingEvent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_terminatingEventScheme(self): return self.terminatingEventScheme
    def set_terminatingEventScheme(self, terminatingEventScheme): self.terminatingEventScheme = terminatingEventScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TerminatingEvent', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TerminatingEvent')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TerminatingEvent', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TerminatingEvent'):
        if self.terminatingEventScheme != "http://www.fpml.org/coding-scheme/terminating-event" and 'terminatingEventScheme' not in already_processed:
            already_processed.add('terminatingEventScheme')
            outfile.write(' terminatingEventScheme=%s' % (quote_attrib(self.terminatingEventScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TerminatingEvent', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('terminatingEventScheme', node)
        if value is not None and 'terminatingEventScheme' not in already_processed:
            already_processed.add('terminatingEventScheme')
            self.terminatingEventScheme = value
            self.validate_NonEmptyURI(self.terminatingEventScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TerminatingEvent


class TradeAmendmentContent(AbstractEvent):
    """A structure describing a negotiated amendment."""
    member_data_items_ = {
        'trade': MemberSpec_('trade', 'Trade', 0),
        'agreementDate': MemberSpec_('agreementDate', 'xsd:date', 0),
        'executionDateTime': MemberSpec_('executionDateTime', 'ExecutionDateTime', 0),
        'effectiveDate': MemberSpec_('effectiveDate', 'xsd:date', 0),
        'payment': MemberSpec_('payment', 'Payment', 1),
    }
    subclass = None
    superclass = AbstractEvent
    def __init__(self, eventIdentifier=None, trade=None, agreementDate=None, executionDateTime=None, effectiveDate=None, payment=None):
        self.original_tagname_ = None
        super(TradeAmendmentContent, self).__init__(eventIdentifier, )
        self.trade = trade
        if isinstance(agreementDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(agreementDate, '%Y-%m-%d').date()
        else:
            initvalue_ = agreementDate
        self.agreementDate = initvalue_
        self.executionDateTime = executionDateTime
        if isinstance(effectiveDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(effectiveDate, '%Y-%m-%d').date()
        else:
            initvalue_ = effectiveDate
        self.effectiveDate = initvalue_
        if payment is None:
            self.payment = []
        else:
            self.payment = payment
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TradeAmendmentContent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TradeAmendmentContent.subclass:
            return TradeAmendmentContent.subclass(*args_, **kwargs_)
        else:
            return TradeAmendmentContent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_trade(self): return self.trade
    def set_trade(self, trade): self.trade = trade
    def get_agreementDate(self): return self.agreementDate
    def set_agreementDate(self, agreementDate): self.agreementDate = agreementDate
    def get_executionDateTime(self): return self.executionDateTime
    def set_executionDateTime(self, executionDateTime): self.executionDateTime = executionDateTime
    def get_effectiveDate(self): return self.effectiveDate
    def set_effectiveDate(self, effectiveDate): self.effectiveDate = effectiveDate
    def get_payment(self): return self.payment
    def set_payment(self, payment): self.payment = payment
    def add_payment(self, value): self.payment.append(value)
    def insert_payment_at(self, index, value): self.payment.insert(index, value)
    def replace_payment_at(self, index, value): self.payment[index] = value
    def hasContent_(self):
        if (
            self.trade is not None or
            self.agreementDate is not None or
            self.executionDateTime is not None or
            self.effectiveDate is not None or
            self.payment or
            super(TradeAmendmentContent, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TradeAmendmentContent', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TradeAmendmentContent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TradeAmendmentContent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TradeAmendmentContent'):
        super(TradeAmendmentContent, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TradeAmendmentContent')
    def exportChildren(self, outfile, level, namespace_='', name_='TradeAmendmentContent', fromsubclass_=False, pretty_print=True):
        super(TradeAmendmentContent, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.trade is not None:
            self.trade.export(outfile, level, namespace_, name_='trade', pretty_print=pretty_print)
        if self.agreementDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sagreementDate>%s</%sagreementDate>%s' % (namespace_, self.gds_format_date(self.agreementDate, input_name='agreementDate'), namespace_, eol_))
        if self.executionDateTime is not None:
            self.executionDateTime.export(outfile, level, namespace_, name_='executionDateTime', pretty_print=pretty_print)
        if self.effectiveDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%seffectiveDate>%s</%seffectiveDate>%s' % (namespace_, self.gds_format_date(self.effectiveDate, input_name='effectiveDate'), namespace_, eol_))
        for payment_ in self.payment:
            payment_.export(outfile, level, namespace_, name_='payment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TradeAmendmentContent, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'trade':
            obj_ = Trade.factory()
            obj_.build(child_)
            self.trade = obj_
            obj_.original_tagname_ = 'trade'
        elif nodeName_ == 'agreementDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.agreementDate = dval_
        elif nodeName_ == 'executionDateTime':
            obj_ = ExecutionDateTime.factory()
            obj_.build(child_)
            self.executionDateTime = obj_
            obj_.original_tagname_ = 'executionDateTime'
        elif nodeName_ == 'effectiveDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.effectiveDate = dval_
        elif nodeName_ == 'payment':
            obj_ = Payment.factory()
            obj_.build(child_)
            self.payment.append(obj_)
            obj_.original_tagname_ = 'payment'
        super(TradeAmendmentContent, self).buildChildren(child_, node, nodeName_, True)
# end class TradeAmendmentContent


class TradeChangeBase(AbstractEvent):
    """A structure describing a trade change."""
    member_data_items_ = {
        'tradeIdentifier': MemberSpec_('tradeIdentifier', 'PartyTradeIdentifier', 1),
        'originalTrade': MemberSpec_('originalTrade', 'Trade', 0),
        'resultingTrade': MemberSpec_('resultingTrade', 'Trade', 0),
        'agreementDate': MemberSpec_('agreementDate', 'xsd:date', 0),
        'executionDateTime': MemberSpec_('executionDateTime', 'ExecutionDateTime', 0),
        'effectiveDate': MemberSpec_('effectiveDate', 'xsd:date', 0),
        'payment': MemberSpec_('payment', 'Payment', 1),
    }
    subclass = None
    superclass = AbstractEvent
    def __init__(self, eventIdentifier=None, tradeIdentifier=None, originalTrade=None, resultingTrade=None, agreementDate=None, executionDateTime=None, effectiveDate=None, payment=None, extensiontype_=None):
        self.original_tagname_ = None
        super(TradeChangeBase, self).__init__(eventIdentifier, extensiontype_, )
        if tradeIdentifier is None:
            self.tradeIdentifier = []
        else:
            self.tradeIdentifier = tradeIdentifier
        self.originalTrade = originalTrade
        self.resultingTrade = resultingTrade
        if isinstance(agreementDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(agreementDate, '%Y-%m-%d').date()
        else:
            initvalue_ = agreementDate
        self.agreementDate = initvalue_
        self.executionDateTime = executionDateTime
        if isinstance(effectiveDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(effectiveDate, '%Y-%m-%d').date()
        else:
            initvalue_ = effectiveDate
        self.effectiveDate = initvalue_
        if payment is None:
            self.payment = []
        else:
            self.payment = payment
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TradeChangeBase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TradeChangeBase.subclass:
            return TradeChangeBase.subclass(*args_, **kwargs_)
        else:
            return TradeChangeBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tradeIdentifier(self): return self.tradeIdentifier
    def set_tradeIdentifier(self, tradeIdentifier): self.tradeIdentifier = tradeIdentifier
    def add_tradeIdentifier(self, value): self.tradeIdentifier.append(value)
    def insert_tradeIdentifier_at(self, index, value): self.tradeIdentifier.insert(index, value)
    def replace_tradeIdentifier_at(self, index, value): self.tradeIdentifier[index] = value
    def get_originalTrade(self): return self.originalTrade
    def set_originalTrade(self, originalTrade): self.originalTrade = originalTrade
    def get_resultingTrade(self): return self.resultingTrade
    def set_resultingTrade(self, resultingTrade): self.resultingTrade = resultingTrade
    def get_agreementDate(self): return self.agreementDate
    def set_agreementDate(self, agreementDate): self.agreementDate = agreementDate
    def get_executionDateTime(self): return self.executionDateTime
    def set_executionDateTime(self, executionDateTime): self.executionDateTime = executionDateTime
    def get_effectiveDate(self): return self.effectiveDate
    def set_effectiveDate(self, effectiveDate): self.effectiveDate = effectiveDate
    def get_payment(self): return self.payment
    def set_payment(self, payment): self.payment = payment
    def add_payment(self, value): self.payment.append(value)
    def insert_payment_at(self, index, value): self.payment.insert(index, value)
    def replace_payment_at(self, index, value): self.payment[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.tradeIdentifier or
            self.originalTrade is not None or
            self.resultingTrade is not None or
            self.agreementDate is not None or
            self.executionDateTime is not None or
            self.effectiveDate is not None or
            self.payment or
            super(TradeChangeBase, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TradeChangeBase', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TradeChangeBase')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TradeChangeBase', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TradeChangeBase'):
        super(TradeChangeBase, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TradeChangeBase')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='TradeChangeBase', fromsubclass_=False, pretty_print=True):
        super(TradeChangeBase, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for tradeIdentifier_ in self.tradeIdentifier:
            tradeIdentifier_.export(outfile, level, namespace_, name_='tradeIdentifier', pretty_print=pretty_print)
        if self.originalTrade is not None:
            self.originalTrade.export(outfile, level, namespace_, name_='originalTrade', pretty_print=pretty_print)
        if self.resultingTrade is not None:
            self.resultingTrade.export(outfile, level, namespace_, name_='resultingTrade', pretty_print=pretty_print)
        if self.agreementDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sagreementDate>%s</%sagreementDate>%s' % (namespace_, self.gds_format_date(self.agreementDate, input_name='agreementDate'), namespace_, eol_))
        if self.executionDateTime is not None:
            self.executionDateTime.export(outfile, level, namespace_, name_='executionDateTime', pretty_print=pretty_print)
        if self.effectiveDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%seffectiveDate>%s</%seffectiveDate>%s' % (namespace_, self.gds_format_date(self.effectiveDate, input_name='effectiveDate'), namespace_, eol_))
        for payment_ in self.payment:
            payment_.export(outfile, level, namespace_, name_='payment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(TradeChangeBase, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tradeIdentifier':
            obj_ = PartyTradeIdentifier.factory()
            obj_.build(child_)
            self.tradeIdentifier.append(obj_)
            obj_.original_tagname_ = 'tradeIdentifier'
        elif nodeName_ == 'originalTrade':
            obj_ = Trade.factory()
            obj_.build(child_)
            self.originalTrade = obj_
            obj_.original_tagname_ = 'originalTrade'
        elif nodeName_ == 'resultingTrade':
            obj_ = Trade.factory()
            obj_.build(child_)
            self.resultingTrade = obj_
            obj_.original_tagname_ = 'resultingTrade'
        elif nodeName_ == 'agreementDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.agreementDate = dval_
        elif nodeName_ == 'executionDateTime':
            obj_ = ExecutionDateTime.factory()
            obj_.build(child_)
            self.executionDateTime = obj_
            obj_.original_tagname_ = 'executionDateTime'
        elif nodeName_ == 'effectiveDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.effectiveDate = dval_
        elif nodeName_ == 'payment':
            obj_ = Payment.factory()
            obj_.build(child_)
            self.payment.append(obj_)
            obj_.original_tagname_ = 'payment'
        super(TradeChangeBase, self).buildChildren(child_, node, nodeName_, True)
# end class TradeChangeBase


class TradeChangeContent(GeneratedsSuper):
    """A structure describing a non-negotiated trade resulting from a
    market event."""
    member_data_items_ = {
        'oldTradeIdentifier': MemberSpec_('oldTradeIdentifier', 'PartyTradeIdentifier', 0),
        'oldTrade': MemberSpec_('oldTrade', 'Trade', 0),
        'trade': MemberSpec_('trade', 'Trade', 0),
        'effectiveDate': MemberSpec_('effectiveDate', 'xsd:date', 0),
        'changeEvent': MemberSpec_('changeEvent', 'ChangeEvent', 0),
        'payment': MemberSpec_('payment', 'Payment', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, oldTradeIdentifier=None, oldTrade=None, trade=None, effectiveDate=None, changeEvent=None, payment=None):
        self.original_tagname_ = None
        self.oldTradeIdentifier = oldTradeIdentifier
        self.oldTrade = oldTrade
        self.trade = trade
        if isinstance(effectiveDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(effectiveDate, '%Y-%m-%d').date()
        else:
            initvalue_ = effectiveDate
        self.effectiveDate = initvalue_
        self.changeEvent = changeEvent
        self.payment = payment
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TradeChangeContent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TradeChangeContent.subclass:
            return TradeChangeContent.subclass(*args_, **kwargs_)
        else:
            return TradeChangeContent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_oldTradeIdentifier(self): return self.oldTradeIdentifier
    def set_oldTradeIdentifier(self, oldTradeIdentifier): self.oldTradeIdentifier = oldTradeIdentifier
    def get_oldTrade(self): return self.oldTrade
    def set_oldTrade(self, oldTrade): self.oldTrade = oldTrade
    def get_trade(self): return self.trade
    def set_trade(self, trade): self.trade = trade
    def get_effectiveDate(self): return self.effectiveDate
    def set_effectiveDate(self, effectiveDate): self.effectiveDate = effectiveDate
    def get_changeEvent(self): return self.changeEvent
    def set_changeEvent(self, changeEvent): self.changeEvent = changeEvent
    def get_payment(self): return self.payment
    def set_payment(self, payment): self.payment = payment
    def hasContent_(self):
        if (
            self.oldTradeIdentifier is not None or
            self.oldTrade is not None or
            self.trade is not None or
            self.effectiveDate is not None or
            self.changeEvent is not None or
            self.payment is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TradeChangeContent', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TradeChangeContent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TradeChangeContent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TradeChangeContent'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TradeChangeContent', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.oldTradeIdentifier is not None:
            self.oldTradeIdentifier.export(outfile, level, namespace_, name_='oldTradeIdentifier', pretty_print=pretty_print)
        if self.oldTrade is not None:
            self.oldTrade.export(outfile, level, namespace_, name_='oldTrade', pretty_print=pretty_print)
        if self.trade is not None:
            self.trade.export(outfile, level, namespace_, name_='trade', pretty_print=pretty_print)
        if self.effectiveDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%seffectiveDate>%s</%seffectiveDate>%s' % (namespace_, self.gds_format_date(self.effectiveDate, input_name='effectiveDate'), namespace_, eol_))
        if self.changeEvent is not None:
            self.changeEvent.export(outfile, level, namespace_, name_='changeEvent', pretty_print=pretty_print)
        if self.payment is not None:
            self.payment.export(outfile, level, namespace_, name_='payment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'oldTradeIdentifier':
            obj_ = PartyTradeIdentifier.factory()
            obj_.build(child_)
            self.oldTradeIdentifier = obj_
            obj_.original_tagname_ = 'oldTradeIdentifier'
        elif nodeName_ == 'oldTrade':
            obj_ = Trade.factory()
            obj_.build(child_)
            self.oldTrade = obj_
            obj_.original_tagname_ = 'oldTrade'
        elif nodeName_ == 'trade':
            obj_ = Trade.factory()
            obj_.build(child_)
            self.trade = obj_
            obj_.original_tagname_ = 'trade'
        elif nodeName_ == 'effectiveDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.effectiveDate = dval_
        elif nodeName_ == 'changeEvent':
            class_obj_ = self.get_class_obj_(child_, ChangeEvent)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.changeEvent = obj_
            obj_.original_tagname_ = 'changeEvent'
        elif nodeName_ == 'basketChange':
            obj_ = BasketChangeEvent.factory()
            obj_.build(child_)
            self.changeEvent = obj_
            obj_.original_tagname_ = 'basketChange'
        elif nodeName_ == 'corporateAction':
            obj_ = CorporateActionEvent.factory()
            obj_.build(child_)
            self.changeEvent = obj_
            obj_.original_tagname_ = 'corporateAction'
        elif nodeName_ == 'indexChange':
            obj_ = IndexChange.factory()
            obj_.build(child_)
            self.changeEvent = obj_
            obj_.original_tagname_ = 'indexChange'
        elif nodeName_ == 'payment':
            obj_ = Payment.factory()
            obj_.build(child_)
            self.payment = obj_
            obj_.original_tagname_ = 'payment'
# end class TradeChangeContent


class TradeLegPriceChange(GeneratedsSuper):
    """A structure describing a change to the size of a single leg or
    stream of a trade."""
    member_data_items_ = {
        'priceReference': MemberSpec_('priceReference', 'Reference', 0),
        'instrumentId': MemberSpec_('instrumentId', 'InstrumentId', 1),
        'priceChangeAmount': MemberSpec_('priceChangeAmount', 'xsd:decimal', 0),
        'newPrice': MemberSpec_('newPrice', 'xsd:decimal', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, priceReference=None, instrumentId=None, priceChangeAmount=None, newPrice=None):
        self.original_tagname_ = None
        self.priceReference = priceReference
        if instrumentId is None:
            self.instrumentId = []
        else:
            self.instrumentId = instrumentId
        self.priceChangeAmount = priceChangeAmount
        self.newPrice = newPrice
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TradeLegPriceChange)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TradeLegPriceChange.subclass:
            return TradeLegPriceChange.subclass(*args_, **kwargs_)
        else:
            return TradeLegPriceChange(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_priceReference(self): return self.priceReference
    def set_priceReference(self, priceReference): self.priceReference = priceReference
    def get_instrumentId(self): return self.instrumentId
    def set_instrumentId(self, instrumentId): self.instrumentId = instrumentId
    def add_instrumentId(self, value): self.instrumentId.append(value)
    def insert_instrumentId_at(self, index, value): self.instrumentId.insert(index, value)
    def replace_instrumentId_at(self, index, value): self.instrumentId[index] = value
    def get_priceChangeAmount(self): return self.priceChangeAmount
    def set_priceChangeAmount(self, priceChangeAmount): self.priceChangeAmount = priceChangeAmount
    def get_newPrice(self): return self.newPrice
    def set_newPrice(self, newPrice): self.newPrice = newPrice
    def hasContent_(self):
        if (
            self.priceReference is not None or
            self.instrumentId or
            self.priceChangeAmount is not None or
            self.newPrice is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TradeLegPriceChange', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TradeLegPriceChange')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TradeLegPriceChange', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TradeLegPriceChange'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TradeLegPriceChange', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.priceReference is not None:
            self.priceReference.export(outfile, level, namespace_, name_='priceReference', pretty_print=pretty_print)
        for instrumentId_ in self.instrumentId:
            instrumentId_.export(outfile, level, namespace_, name_='instrumentId', pretty_print=pretty_print)
        if self.priceChangeAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spriceChangeAmount>%s</%spriceChangeAmount>%s' % (namespace_, self.gds_format_float(self.priceChangeAmount, input_name='priceChangeAmount'), namespace_, eol_))
        if self.newPrice is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snewPrice>%s</%snewPrice>%s' % (namespace_, self.gds_format_float(self.newPrice, input_name='newPrice'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'priceReference':
            obj_ = ReferenceType.factory()
            obj_.build(child_)
            self.priceReference = obj_
            obj_.original_tagname_ = 'priceReference'
        elif nodeName_ == 'instrumentId':
            obj_ = InstrumentId.factory()
            obj_.build(child_)
            self.instrumentId.append(obj_)
            obj_.original_tagname_ = 'instrumentId'
        elif nodeName_ == 'priceChangeAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'priceChangeAmount')
            self.priceChangeAmount = fval_
        elif nodeName_ == 'newPrice':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'newPrice')
            self.newPrice = fval_
# end class TradeLegPriceChange


class TradeLegSizeChange(GeneratedsSuper):
    """A structure describing a change to the size of a single leg or
    stream of a trade."""
    member_data_items_ = {
        'notionalReference': MemberSpec_('notionalReference', 'NotionalReference', 0),
        'changeInNotionalAmount': MemberSpec_('changeInNotionalAmount', 'NonNegativeMoney', 0),
        'outstandingNotionalAmount': MemberSpec_('outstandingNotionalAmount', 'NonNegativeMoney', 0),
        'numberOfOptionsReference': MemberSpec_('numberOfOptionsReference', 'NumberOfOptionsReference', 0),
        'changeInNumberOfOptions': MemberSpec_('changeInNumberOfOptions', 'xsd:decimal', 0),
        'outstandingNumberOfOptions': MemberSpec_('outstandingNumberOfOptions', 'xsd:decimal', 0),
        'numberOfUnitsReference': MemberSpec_('numberOfUnitsReference', 'NumberOfUnitsReference', 0),
        'changeInNumberOfUnits': MemberSpec_('changeInNumberOfUnits', 'xsd:decimal', 0),
        'outstandingNumberOfUnits': MemberSpec_('outstandingNumberOfUnits', 'xsd:decimal', 0),
        'notionalScheduleReference': MemberSpec_('notionalScheduleReference', 'NotionalReference', 0),
        'changeInNotionalSchedule': MemberSpec_('changeInNotionalSchedule', 'NonNegativeAmountSchedule', 0),
        'outstandingNotionalSchedule': MemberSpec_('outstandingNotionalSchedule', 'NonNegativeAmountSchedule', 0),
        'knownAmountReference': MemberSpec_('knownAmountReference', 'AmountReference', 0),
        'changeInKnownAmount': MemberSpec_('changeInKnownAmount', 'NonNegativeMoney', 0),
        'outstandingKnownAmount': MemberSpec_('outstandingKnownAmount', 'NonNegativeMoney', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, notionalReference=None, changeInNotionalAmount=None, outstandingNotionalAmount=None, numberOfOptionsReference=None, changeInNumberOfOptions=None, outstandingNumberOfOptions=None, numberOfUnitsReference=None, changeInNumberOfUnits=None, outstandingNumberOfUnits=None, notionalScheduleReference=None, changeInNotionalSchedule=None, outstandingNotionalSchedule=None, knownAmountReference=None, changeInKnownAmount=None, outstandingKnownAmount=None):
        self.original_tagname_ = None
        self.notionalReference = notionalReference
        self.changeInNotionalAmount = changeInNotionalAmount
        self.outstandingNotionalAmount = outstandingNotionalAmount
        self.numberOfOptionsReference = numberOfOptionsReference
        self.changeInNumberOfOptions = changeInNumberOfOptions
        self.outstandingNumberOfOptions = outstandingNumberOfOptions
        self.numberOfUnitsReference = numberOfUnitsReference
        self.changeInNumberOfUnits = changeInNumberOfUnits
        self.outstandingNumberOfUnits = outstandingNumberOfUnits
        self.notionalScheduleReference = notionalScheduleReference
        self.changeInNotionalSchedule = changeInNotionalSchedule
        self.outstandingNotionalSchedule = outstandingNotionalSchedule
        self.knownAmountReference = knownAmountReference
        self.changeInKnownAmount = changeInKnownAmount
        self.outstandingKnownAmount = outstandingKnownAmount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TradeLegSizeChange)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TradeLegSizeChange.subclass:
            return TradeLegSizeChange.subclass(*args_, **kwargs_)
        else:
            return TradeLegSizeChange(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_notionalReference(self): return self.notionalReference
    def set_notionalReference(self, notionalReference): self.notionalReference = notionalReference
    def get_changeInNotionalAmount(self): return self.changeInNotionalAmount
    def set_changeInNotionalAmount(self, changeInNotionalAmount): self.changeInNotionalAmount = changeInNotionalAmount
    def get_outstandingNotionalAmount(self): return self.outstandingNotionalAmount
    def set_outstandingNotionalAmount(self, outstandingNotionalAmount): self.outstandingNotionalAmount = outstandingNotionalAmount
    def get_numberOfOptionsReference(self): return self.numberOfOptionsReference
    def set_numberOfOptionsReference(self, numberOfOptionsReference): self.numberOfOptionsReference = numberOfOptionsReference
    def get_changeInNumberOfOptions(self): return self.changeInNumberOfOptions
    def set_changeInNumberOfOptions(self, changeInNumberOfOptions): self.changeInNumberOfOptions = changeInNumberOfOptions
    def get_outstandingNumberOfOptions(self): return self.outstandingNumberOfOptions
    def set_outstandingNumberOfOptions(self, outstandingNumberOfOptions): self.outstandingNumberOfOptions = outstandingNumberOfOptions
    def get_numberOfUnitsReference(self): return self.numberOfUnitsReference
    def set_numberOfUnitsReference(self, numberOfUnitsReference): self.numberOfUnitsReference = numberOfUnitsReference
    def get_changeInNumberOfUnits(self): return self.changeInNumberOfUnits
    def set_changeInNumberOfUnits(self, changeInNumberOfUnits): self.changeInNumberOfUnits = changeInNumberOfUnits
    def get_outstandingNumberOfUnits(self): return self.outstandingNumberOfUnits
    def set_outstandingNumberOfUnits(self, outstandingNumberOfUnits): self.outstandingNumberOfUnits = outstandingNumberOfUnits
    def get_notionalScheduleReference(self): return self.notionalScheduleReference
    def set_notionalScheduleReference(self, notionalScheduleReference): self.notionalScheduleReference = notionalScheduleReference
    def get_changeInNotionalSchedule(self): return self.changeInNotionalSchedule
    def set_changeInNotionalSchedule(self, changeInNotionalSchedule): self.changeInNotionalSchedule = changeInNotionalSchedule
    def get_outstandingNotionalSchedule(self): return self.outstandingNotionalSchedule
    def set_outstandingNotionalSchedule(self, outstandingNotionalSchedule): self.outstandingNotionalSchedule = outstandingNotionalSchedule
    def get_knownAmountReference(self): return self.knownAmountReference
    def set_knownAmountReference(self, knownAmountReference): self.knownAmountReference = knownAmountReference
    def get_changeInKnownAmount(self): return self.changeInKnownAmount
    def set_changeInKnownAmount(self, changeInKnownAmount): self.changeInKnownAmount = changeInKnownAmount
    def get_outstandingKnownAmount(self): return self.outstandingKnownAmount
    def set_outstandingKnownAmount(self, outstandingKnownAmount): self.outstandingKnownAmount = outstandingKnownAmount
    def hasContent_(self):
        if (
            self.notionalReference is not None or
            self.changeInNotionalAmount is not None or
            self.outstandingNotionalAmount is not None or
            self.numberOfOptionsReference is not None or
            self.changeInNumberOfOptions is not None or
            self.outstandingNumberOfOptions is not None or
            self.numberOfUnitsReference is not None or
            self.changeInNumberOfUnits is not None or
            self.outstandingNumberOfUnits is not None or
            self.notionalScheduleReference is not None or
            self.changeInNotionalSchedule is not None or
            self.outstandingNotionalSchedule is not None or
            self.knownAmountReference is not None or
            self.changeInKnownAmount is not None or
            self.outstandingKnownAmount is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TradeLegSizeChange', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TradeLegSizeChange')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TradeLegSizeChange', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TradeLegSizeChange'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TradeLegSizeChange', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.notionalReference is not None:
            self.notionalReference.export(outfile, level, namespace_, name_='notionalReference', pretty_print=pretty_print)
        if self.changeInNotionalAmount is not None:
            self.changeInNotionalAmount.export(outfile, level, namespace_, name_='changeInNotionalAmount', pretty_print=pretty_print)
        if self.outstandingNotionalAmount is not None:
            self.outstandingNotionalAmount.export(outfile, level, namespace_, name_='outstandingNotionalAmount', pretty_print=pretty_print)
        if self.numberOfOptionsReference is not None:
            self.numberOfOptionsReference.export(outfile, level, namespace_, name_='numberOfOptionsReference', pretty_print=pretty_print)
        if self.changeInNumberOfOptions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schangeInNumberOfOptions>%s</%schangeInNumberOfOptions>%s' % (namespace_, self.gds_format_float(self.changeInNumberOfOptions, input_name='changeInNumberOfOptions'), namespace_, eol_))
        if self.outstandingNumberOfOptions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soutstandingNumberOfOptions>%s</%soutstandingNumberOfOptions>%s' % (namespace_, self.gds_format_float(self.outstandingNumberOfOptions, input_name='outstandingNumberOfOptions'), namespace_, eol_))
        if self.numberOfUnitsReference is not None:
            self.numberOfUnitsReference.export(outfile, level, namespace_, name_='numberOfUnitsReference', pretty_print=pretty_print)
        if self.changeInNumberOfUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schangeInNumberOfUnits>%s</%schangeInNumberOfUnits>%s' % (namespace_, self.gds_format_float(self.changeInNumberOfUnits, input_name='changeInNumberOfUnits'), namespace_, eol_))
        if self.outstandingNumberOfUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soutstandingNumberOfUnits>%s</%soutstandingNumberOfUnits>%s' % (namespace_, self.gds_format_float(self.outstandingNumberOfUnits, input_name='outstandingNumberOfUnits'), namespace_, eol_))
        if self.notionalScheduleReference is not None:
            self.notionalScheduleReference.export(outfile, level, namespace_, name_='notionalScheduleReference', pretty_print=pretty_print)
        if self.changeInNotionalSchedule is not None:
            self.changeInNotionalSchedule.export(outfile, level, namespace_, name_='changeInNotionalSchedule', pretty_print=pretty_print)
        if self.outstandingNotionalSchedule is not None:
            self.outstandingNotionalSchedule.export(outfile, level, namespace_, name_='outstandingNotionalSchedule', pretty_print=pretty_print)
        if self.knownAmountReference is not None:
            self.knownAmountReference.export(outfile, level, namespace_, name_='knownAmountReference', pretty_print=pretty_print)
        if self.changeInKnownAmount is not None:
            self.changeInKnownAmount.export(outfile, level, namespace_, name_='changeInKnownAmount', pretty_print=pretty_print)
        if self.outstandingKnownAmount is not None:
            self.outstandingKnownAmount.export(outfile, level, namespace_, name_='outstandingKnownAmount', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'notionalReference':
            obj_ = NotionalReference.factory()
            obj_.build(child_)
            self.notionalReference = obj_
            obj_.original_tagname_ = 'notionalReference'
        elif nodeName_ == 'changeInNotionalAmount':
            class_obj_ = self.get_class_obj_(child_, NonNegativeMoney)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.changeInNotionalAmount = obj_
            obj_.original_tagname_ = 'changeInNotionalAmount'
        elif nodeName_ == 'outstandingNotionalAmount':
            class_obj_ = self.get_class_obj_(child_, NonNegativeMoney)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.outstandingNotionalAmount = obj_
            obj_.original_tagname_ = 'outstandingNotionalAmount'
        elif nodeName_ == 'numberOfOptionsReference':
            obj_ = NumberOfOptionsReference.factory()
            obj_.build(child_)
            self.numberOfOptionsReference = obj_
            obj_.original_tagname_ = 'numberOfOptionsReference'
        elif nodeName_ == 'changeInNumberOfOptions':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'changeInNumberOfOptions')
            self.changeInNumberOfOptions = fval_
        elif nodeName_ == 'outstandingNumberOfOptions':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'outstandingNumberOfOptions')
            self.outstandingNumberOfOptions = fval_
        elif nodeName_ == 'numberOfUnitsReference':
            obj_ = NumberOfUnitsReference.factory()
            obj_.build(child_)
            self.numberOfUnitsReference = obj_
            obj_.original_tagname_ = 'numberOfUnitsReference'
        elif nodeName_ == 'changeInNumberOfUnits':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'changeInNumberOfUnits')
            self.changeInNumberOfUnits = fval_
        elif nodeName_ == 'outstandingNumberOfUnits':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'outstandingNumberOfUnits')
            self.outstandingNumberOfUnits = fval_
        elif nodeName_ == 'notionalScheduleReference':
            obj_ = NotionalReference.factory()
            obj_.build(child_)
            self.notionalScheduleReference = obj_
            obj_.original_tagname_ = 'notionalScheduleReference'
        elif nodeName_ == 'changeInNotionalSchedule':
            obj_ = NonNegativeAmountSchedule.factory()
            obj_.build(child_)
            self.changeInNotionalSchedule = obj_
            obj_.original_tagname_ = 'changeInNotionalSchedule'
        elif nodeName_ == 'outstandingNotionalSchedule':
            obj_ = NonNegativeAmountSchedule.factory()
            obj_.build(child_)
            self.outstandingNotionalSchedule = obj_
            obj_.original_tagname_ = 'outstandingNotionalSchedule'
        elif nodeName_ == 'knownAmountReference':
            obj_ = AmountReference.factory()
            obj_.build(child_)
            self.knownAmountReference = obj_
            obj_.original_tagname_ = 'knownAmountReference'
        elif nodeName_ == 'changeInKnownAmount':
            class_obj_ = self.get_class_obj_(child_, NonNegativeMoney)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.changeInKnownAmount = obj_
            obj_.original_tagname_ = 'changeInKnownAmount'
        elif nodeName_ == 'outstandingKnownAmount':
            class_obj_ = self.get_class_obj_(child_, NonNegativeMoney)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.outstandingKnownAmount = obj_
            obj_.original_tagname_ = 'outstandingKnownAmount'
# end class TradeLegSizeChange


class TradeMaturity(GeneratedsSuper):
    """A structure describing a trade maturing."""
    member_data_items_ = {
        'tradeIdentifier': MemberSpec_('tradeIdentifier', 'PartyTradeIdentifier', 1),
        'date': MemberSpec_('date', 'xsd:date', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, tradeIdentifier=None, date=None):
        self.original_tagname_ = None
        if tradeIdentifier is None:
            self.tradeIdentifier = []
        else:
            self.tradeIdentifier = tradeIdentifier
        if isinstance(date, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(date, '%Y-%m-%d').date()
        else:
            initvalue_ = date
        self.date = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TradeMaturity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TradeMaturity.subclass:
            return TradeMaturity.subclass(*args_, **kwargs_)
        else:
            return TradeMaturity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tradeIdentifier(self): return self.tradeIdentifier
    def set_tradeIdentifier(self, tradeIdentifier): self.tradeIdentifier = tradeIdentifier
    def add_tradeIdentifier(self, value): self.tradeIdentifier.append(value)
    def insert_tradeIdentifier_at(self, index, value): self.tradeIdentifier.insert(index, value)
    def replace_tradeIdentifier_at(self, index, value): self.tradeIdentifier[index] = value
    def get_date(self): return self.date
    def set_date(self, date): self.date = date
    def hasContent_(self):
        if (
            self.tradeIdentifier or
            self.date is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TradeMaturity', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TradeMaturity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TradeMaturity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TradeMaturity'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TradeMaturity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for tradeIdentifier_ in self.tradeIdentifier:
            tradeIdentifier_.export(outfile, level, namespace_, name_='tradeIdentifier', pretty_print=pretty_print)
        if self.date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdate>%s</%sdate>%s' % (namespace_, self.gds_format_date(self.date, input_name='date'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tradeIdentifier':
            obj_ = PartyTradeIdentifier.factory()
            obj_.build(child_)
            self.tradeIdentifier.append(obj_)
            obj_.original_tagname_ = 'tradeIdentifier'
        elif nodeName_ == 'date':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.date = dval_
# end class TradeMaturity


class TradeNotionalChange(TradeChangeBase):
    """A structure describing a change to the size of a trade."""
    member_data_items_ = {
        'changeInNotionalAmount': MemberSpec_('changeInNotionalAmount', 'NonNegativeMoney', 1),
        'outstandingNotionalAmount': MemberSpec_('outstandingNotionalAmount', 'NonNegativeMoney', 1),
        'changeInNumberOfOptions': MemberSpec_('changeInNumberOfOptions', 'xsd:decimal', 0),
        'outstandingNumberOfOptions': MemberSpec_('outstandingNumberOfOptions', 'xsd:decimal', 0),
        'changeInNumberOfUnits': MemberSpec_('changeInNumberOfUnits', 'xsd:decimal', 0),
        'outstandingNumberOfUnits': MemberSpec_('outstandingNumberOfUnits', 'xsd:decimal', 0),
        'sizeChange': MemberSpec_('sizeChange', 'TradeLegSizeChange', 1),
        'priceChange': MemberSpec_('priceChange', 'TradeLegPriceChange', 1),
    }
    subclass = None
    superclass = TradeChangeBase
    def __init__(self, eventIdentifier=None, tradeIdentifier=None, originalTrade=None, resultingTrade=None, agreementDate=None, executionDateTime=None, effectiveDate=None, payment=None, changeInNotionalAmount=None, outstandingNotionalAmount=None, changeInNumberOfOptions=None, outstandingNumberOfOptions=None, changeInNumberOfUnits=None, outstandingNumberOfUnits=None, sizeChange=None, priceChange=None):
        self.original_tagname_ = None
        super(TradeNotionalChange, self).__init__(eventIdentifier, tradeIdentifier, originalTrade, resultingTrade, agreementDate, executionDateTime, effectiveDate, payment, )
        if changeInNotionalAmount is None:
            self.changeInNotionalAmount = []
        else:
            self.changeInNotionalAmount = changeInNotionalAmount
        if outstandingNotionalAmount is None:
            self.outstandingNotionalAmount = []
        else:
            self.outstandingNotionalAmount = outstandingNotionalAmount
        self.changeInNumberOfOptions = changeInNumberOfOptions
        self.outstandingNumberOfOptions = outstandingNumberOfOptions
        self.changeInNumberOfUnits = changeInNumberOfUnits
        self.outstandingNumberOfUnits = outstandingNumberOfUnits
        if sizeChange is None:
            self.sizeChange = []
        else:
            self.sizeChange = sizeChange
        if priceChange is None:
            self.priceChange = []
        else:
            self.priceChange = priceChange
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TradeNotionalChange)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TradeNotionalChange.subclass:
            return TradeNotionalChange.subclass(*args_, **kwargs_)
        else:
            return TradeNotionalChange(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_changeInNotionalAmount(self): return self.changeInNotionalAmount
    def set_changeInNotionalAmount(self, changeInNotionalAmount): self.changeInNotionalAmount = changeInNotionalAmount
    def add_changeInNotionalAmount(self, value): self.changeInNotionalAmount.append(value)
    def insert_changeInNotionalAmount_at(self, index, value): self.changeInNotionalAmount.insert(index, value)
    def replace_changeInNotionalAmount_at(self, index, value): self.changeInNotionalAmount[index] = value
    def get_outstandingNotionalAmount(self): return self.outstandingNotionalAmount
    def set_outstandingNotionalAmount(self, outstandingNotionalAmount): self.outstandingNotionalAmount = outstandingNotionalAmount
    def add_outstandingNotionalAmount(self, value): self.outstandingNotionalAmount.append(value)
    def insert_outstandingNotionalAmount_at(self, index, value): self.outstandingNotionalAmount.insert(index, value)
    def replace_outstandingNotionalAmount_at(self, index, value): self.outstandingNotionalAmount[index] = value
    def get_changeInNumberOfOptions(self): return self.changeInNumberOfOptions
    def set_changeInNumberOfOptions(self, changeInNumberOfOptions): self.changeInNumberOfOptions = changeInNumberOfOptions
    def get_outstandingNumberOfOptions(self): return self.outstandingNumberOfOptions
    def set_outstandingNumberOfOptions(self, outstandingNumberOfOptions): self.outstandingNumberOfOptions = outstandingNumberOfOptions
    def get_changeInNumberOfUnits(self): return self.changeInNumberOfUnits
    def set_changeInNumberOfUnits(self, changeInNumberOfUnits): self.changeInNumberOfUnits = changeInNumberOfUnits
    def get_outstandingNumberOfUnits(self): return self.outstandingNumberOfUnits
    def set_outstandingNumberOfUnits(self, outstandingNumberOfUnits): self.outstandingNumberOfUnits = outstandingNumberOfUnits
    def get_sizeChange(self): return self.sizeChange
    def set_sizeChange(self, sizeChange): self.sizeChange = sizeChange
    def add_sizeChange(self, value): self.sizeChange.append(value)
    def insert_sizeChange_at(self, index, value): self.sizeChange.insert(index, value)
    def replace_sizeChange_at(self, index, value): self.sizeChange[index] = value
    def get_priceChange(self): return self.priceChange
    def set_priceChange(self, priceChange): self.priceChange = priceChange
    def add_priceChange(self, value): self.priceChange.append(value)
    def insert_priceChange_at(self, index, value): self.priceChange.insert(index, value)
    def replace_priceChange_at(self, index, value): self.priceChange[index] = value
    def hasContent_(self):
        if (
            self.changeInNotionalAmount or
            self.outstandingNotionalAmount or
            self.changeInNumberOfOptions is not None or
            self.outstandingNumberOfOptions is not None or
            self.changeInNumberOfUnits is not None or
            self.outstandingNumberOfUnits is not None or
            self.sizeChange or
            self.priceChange or
            super(TradeNotionalChange, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TradeNotionalChange', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TradeNotionalChange')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TradeNotionalChange', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TradeNotionalChange'):
        super(TradeNotionalChange, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TradeNotionalChange')
    def exportChildren(self, outfile, level, namespace_='', name_='TradeNotionalChange', fromsubclass_=False, pretty_print=True):
        super(TradeNotionalChange, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for changeInNotionalAmount_ in self.changeInNotionalAmount:
            changeInNotionalAmount_.export(outfile, level, namespace_, name_='changeInNotionalAmount', pretty_print=pretty_print)
        for outstandingNotionalAmount_ in self.outstandingNotionalAmount:
            outstandingNotionalAmount_.export(outfile, level, namespace_, name_='outstandingNotionalAmount', pretty_print=pretty_print)
        if self.changeInNumberOfOptions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schangeInNumberOfOptions>%s</%schangeInNumberOfOptions>%s' % (namespace_, self.gds_format_float(self.changeInNumberOfOptions, input_name='changeInNumberOfOptions'), namespace_, eol_))
        if self.outstandingNumberOfOptions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soutstandingNumberOfOptions>%s</%soutstandingNumberOfOptions>%s' % (namespace_, self.gds_format_float(self.outstandingNumberOfOptions, input_name='outstandingNumberOfOptions'), namespace_, eol_))
        if self.changeInNumberOfUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schangeInNumberOfUnits>%s</%schangeInNumberOfUnits>%s' % (namespace_, self.gds_format_float(self.changeInNumberOfUnits, input_name='changeInNumberOfUnits'), namespace_, eol_))
        if self.outstandingNumberOfUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soutstandingNumberOfUnits>%s</%soutstandingNumberOfUnits>%s' % (namespace_, self.gds_format_float(self.outstandingNumberOfUnits, input_name='outstandingNumberOfUnits'), namespace_, eol_))
        for sizeChange_ in self.sizeChange:
            sizeChange_.export(outfile, level, namespace_, name_='sizeChange', pretty_print=pretty_print)
        for priceChange_ in self.priceChange:
            priceChange_.export(outfile, level, namespace_, name_='priceChange', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TradeNotionalChange, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'changeInNotionalAmount':
            class_obj_ = self.get_class_obj_(child_, NonNegativeMoney)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.changeInNotionalAmount.append(obj_)
            obj_.original_tagname_ = 'changeInNotionalAmount'
        elif nodeName_ == 'outstandingNotionalAmount':
            class_obj_ = self.get_class_obj_(child_, NonNegativeMoney)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.outstandingNotionalAmount.append(obj_)
            obj_.original_tagname_ = 'outstandingNotionalAmount'
        elif nodeName_ == 'changeInNumberOfOptions':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'changeInNumberOfOptions')
            self.changeInNumberOfOptions = fval_
        elif nodeName_ == 'outstandingNumberOfOptions':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'outstandingNumberOfOptions')
            self.outstandingNumberOfOptions = fval_
        elif nodeName_ == 'changeInNumberOfUnits':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'changeInNumberOfUnits')
            self.changeInNumberOfUnits = fval_
        elif nodeName_ == 'outstandingNumberOfUnits':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'outstandingNumberOfUnits')
            self.outstandingNumberOfUnits = fval_
        elif nodeName_ == 'sizeChange':
            obj_ = TradeLegSizeChange.factory()
            obj_.build(child_)
            self.sizeChange.append(obj_)
            obj_.original_tagname_ = 'sizeChange'
        elif nodeName_ == 'priceChange':
            obj_ = TradeLegPriceChange.factory()
            obj_.build(child_)
            self.priceChange.append(obj_)
            obj_.original_tagname_ = 'priceChange'
        super(TradeNotionalChange, self).buildChildren(child_, node, nodeName_, True)
# end class TradeNotionalChange


class TradeNovationContent(AbstractEvent):
    """A structure describing a novation.Choice between identification and
    representation of the new contract.Choice between identification
    and representation of the old contract.Choice between
    identification and representation of the new contract.Choice
    between identification and representation of the new contract."""
    member_data_items_ = {
        'newTradeIdentifier': MemberSpec_('newTradeIdentifier', 'PartyTradeIdentifier', 1),
        'newTrade': MemberSpec_('newTrade', 'Trade', 0),
        'oldTradeIdentifier': MemberSpec_('oldTradeIdentifier', 'PartyTradeIdentifier', 1),
        'oldTrade': MemberSpec_('oldTrade', 'Trade', 0),
        'feeTradeIdentifier': MemberSpec_('feeTradeIdentifier', 'PartyTradeIdentifier', 0),
        'feeTrade': MemberSpec_('feeTrade', 'Trade', 0),
        'newTradeIdentifier': MemberSpec_('newTradeIdentifier', 'PartyTradeIdentifier', 1),
        'newTrade': MemberSpec_('newTrade', 'Trade', 0),
        'feeTradeIdentifier': MemberSpec_('feeTradeIdentifier', 'PartyTradeIdentifier', 0),
        'feeTrade': MemberSpec_('feeTrade', 'Trade', 0),
        'newTradeIdentifier': MemberSpec_('newTradeIdentifier', 'PartyTradeIdentifier', 1),
        'newTrade': MemberSpec_('newTrade', 'Trade', 0),
        'transferor': MemberSpec_('transferor', 'PartyReference', 0),
        'transferorAccount': MemberSpec_('transferorAccount', 'AccountReference', 0),
        'transferee': MemberSpec_('transferee', 'PartyReference', 0),
        'otherTransferee': MemberSpec_('otherTransferee', 'PartyReference', 0),
        'transfereeAccount': MemberSpec_('transfereeAccount', 'AccountReference', 0),
        'otherTransfereeAccount': MemberSpec_('otherTransfereeAccount', 'AccountReference', 0),
        'remainingParty': MemberSpec_('remainingParty', 'PartyReference', 0),
        'remainingPartyAccount': MemberSpec_('remainingPartyAccount', 'AccountReference', 0),
        'otherRemainingParty': MemberSpec_('otherRemainingParty', 'PartyReference', 0),
        'otherRemainingPartyAccount': MemberSpec_('otherRemainingPartyAccount', 'AccountReference', 0),
        'novationDate': MemberSpec_('novationDate', 'xsd:date', 0),
        'executionDateTime': MemberSpec_('executionDateTime', 'ExecutionDateTime', 0),
        'novationTradeDate': MemberSpec_('novationTradeDate', 'xsd:date', 0),
        'novatedAmount': MemberSpec_('novatedAmount', 'Money', 1),
        'remainingAmount': MemberSpec_('remainingAmount', 'Money', 1),
        'novatedNumberOfOptions': MemberSpec_('novatedNumberOfOptions', 'xsd:decimal', 0),
        'remainingNumberOfOptions': MemberSpec_('remainingNumberOfOptions', 'xsd:decimal', 0),
        'novatedNumberOfUnits': MemberSpec_('novatedNumberOfUnits', 'xsd:decimal', 0),
        'remainingNumberOfUnits': MemberSpec_('remainingNumberOfUnits', 'xsd:decimal', 0),
        'novationAmount': MemberSpec_('novationAmount', 'TradeLegSizeChange', 1),
        'fullFirstCalculationPeriod': MemberSpec_('fullFirstCalculationPeriod', 'xsd:boolean', 0),
        'firstPeriodStartDate': MemberSpec_('firstPeriodStartDate', 'FirstPeriodStartDate', 1),
        'nonReliance': MemberSpec_('nonReliance', 'Empty', 0),
        'creditDerivativesNotices': MemberSpec_('creditDerivativesNotices', 'CreditDerivativesNotices', 0),
        'contractualDefinitions': MemberSpec_('contractualDefinitions', 'ContractualDefinitions', 1),
        'contractualTermsSupplement': MemberSpec_('contractualTermsSupplement', 'ContractualTermsSupplement', 1),
        'payment': MemberSpec_('payment', 'Payment', 0),
    }
    subclass = None
    superclass = AbstractEvent
    def __init__(self, eventIdentifier=None, newTradeIdentifier=None, newTrade=None, oldTradeIdentifier=None, oldTrade=None, feeTradeIdentifier=None, feeTrade=None, transferor=None, transferorAccount=None, transferee=None, otherTransferee=None, transfereeAccount=None, otherTransfereeAccount=None, remainingParty=None, remainingPartyAccount=None, otherRemainingParty=None, otherRemainingPartyAccount=None, novationDate=None, executionDateTime=None, novationTradeDate=None, novatedAmount=None, remainingAmount=None, novatedNumberOfOptions=None, remainingNumberOfOptions=None, novatedNumberOfUnits=None, remainingNumberOfUnits=None, novationAmount=None, fullFirstCalculationPeriod=None, firstPeriodStartDate=None, nonReliance=None, creditDerivativesNotices=None, contractualDefinitions=None, contractualTermsSupplement=None, payment=None):
        self.original_tagname_ = None
        super(TradeNovationContent, self).__init__(eventIdentifier, )
        if newTradeIdentifier is None:
            self.newTradeIdentifier = []
        else:
            self.newTradeIdentifier = newTradeIdentifier
        self.newTrade = newTrade
        if oldTradeIdentifier is None:
            self.oldTradeIdentifier = []
        else:
            self.oldTradeIdentifier = oldTradeIdentifier
        self.oldTrade = oldTrade
        self.feeTradeIdentifier = feeTradeIdentifier
        self.feeTrade = feeTrade
        if newTradeIdentifier is None:
            self.newTradeIdentifier = []
        else:
            self.newTradeIdentifier = newTradeIdentifier
        self.newTrade = newTrade
        self.feeTradeIdentifier = feeTradeIdentifier
        self.feeTrade = feeTrade
        if newTradeIdentifier is None:
            self.newTradeIdentifier = []
        else:
            self.newTradeIdentifier = newTradeIdentifier
        self.newTrade = newTrade
        self.transferor = transferor
        self.transferorAccount = transferorAccount
        self.transferee = transferee
        self.otherTransferee = otherTransferee
        self.transfereeAccount = transfereeAccount
        self.otherTransfereeAccount = otherTransfereeAccount
        self.remainingParty = remainingParty
        self.remainingPartyAccount = remainingPartyAccount
        self.otherRemainingParty = otherRemainingParty
        self.otherRemainingPartyAccount = otherRemainingPartyAccount
        if isinstance(novationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(novationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = novationDate
        self.novationDate = initvalue_
        self.executionDateTime = executionDateTime
        if isinstance(novationTradeDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(novationTradeDate, '%Y-%m-%d').date()
        else:
            initvalue_ = novationTradeDate
        self.novationTradeDate = initvalue_
        if novatedAmount is None:
            self.novatedAmount = []
        else:
            self.novatedAmount = novatedAmount
        if remainingAmount is None:
            self.remainingAmount = []
        else:
            self.remainingAmount = remainingAmount
        self.novatedNumberOfOptions = novatedNumberOfOptions
        self.remainingNumberOfOptions = remainingNumberOfOptions
        self.novatedNumberOfUnits = novatedNumberOfUnits
        self.remainingNumberOfUnits = remainingNumberOfUnits
        if novationAmount is None:
            self.novationAmount = []
        else:
            self.novationAmount = novationAmount
        self.fullFirstCalculationPeriod = fullFirstCalculationPeriod
        if firstPeriodStartDate is None:
            self.firstPeriodStartDate = []
        else:
            self.firstPeriodStartDate = firstPeriodStartDate
        self.nonReliance = nonReliance
        self.creditDerivativesNotices = creditDerivativesNotices
        if contractualDefinitions is None:
            self.contractualDefinitions = []
        else:
            self.contractualDefinitions = contractualDefinitions
        if contractualTermsSupplement is None:
            self.contractualTermsSupplement = []
        else:
            self.contractualTermsSupplement = contractualTermsSupplement
        self.payment = payment
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TradeNovationContent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TradeNovationContent.subclass:
            return TradeNovationContent.subclass(*args_, **kwargs_)
        else:
            return TradeNovationContent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_newTradeIdentifier(self): return self.newTradeIdentifier
    def set_newTradeIdentifier(self, newTradeIdentifier): self.newTradeIdentifier = newTradeIdentifier
    def add_newTradeIdentifier(self, value): self.newTradeIdentifier.append(value)
    def insert_newTradeIdentifier_at(self, index, value): self.newTradeIdentifier.insert(index, value)
    def replace_newTradeIdentifier_at(self, index, value): self.newTradeIdentifier[index] = value
    def get_newTrade(self): return self.newTrade
    def set_newTrade(self, newTrade): self.newTrade = newTrade
    def get_oldTradeIdentifier(self): return self.oldTradeIdentifier
    def set_oldTradeIdentifier(self, oldTradeIdentifier): self.oldTradeIdentifier = oldTradeIdentifier
    def add_oldTradeIdentifier(self, value): self.oldTradeIdentifier.append(value)
    def insert_oldTradeIdentifier_at(self, index, value): self.oldTradeIdentifier.insert(index, value)
    def replace_oldTradeIdentifier_at(self, index, value): self.oldTradeIdentifier[index] = value
    def get_oldTrade(self): return self.oldTrade
    def set_oldTrade(self, oldTrade): self.oldTrade = oldTrade
    def get_feeTradeIdentifier(self): return self.feeTradeIdentifier
    def set_feeTradeIdentifier(self, feeTradeIdentifier): self.feeTradeIdentifier = feeTradeIdentifier
    def get_feeTrade(self): return self.feeTrade
    def set_feeTrade(self, feeTrade): self.feeTrade = feeTrade
    def get_newTradeIdentifier(self): return self.newTradeIdentifier
    def set_newTradeIdentifier(self, newTradeIdentifier): self.newTradeIdentifier = newTradeIdentifier
    def add_newTradeIdentifier(self, value): self.newTradeIdentifier.append(value)
    def insert_newTradeIdentifier_at(self, index, value): self.newTradeIdentifier.insert(index, value)
    def replace_newTradeIdentifier_at(self, index, value): self.newTradeIdentifier[index] = value
    def get_newTrade(self): return self.newTrade
    def set_newTrade(self, newTrade): self.newTrade = newTrade
    def get_feeTradeIdentifier(self): return self.feeTradeIdentifier
    def set_feeTradeIdentifier(self, feeTradeIdentifier): self.feeTradeIdentifier = feeTradeIdentifier
    def get_feeTrade(self): return self.feeTrade
    def set_feeTrade(self, feeTrade): self.feeTrade = feeTrade
    def get_newTradeIdentifier(self): return self.newTradeIdentifier
    def set_newTradeIdentifier(self, newTradeIdentifier): self.newTradeIdentifier = newTradeIdentifier
    def add_newTradeIdentifier(self, value): self.newTradeIdentifier.append(value)
    def insert_newTradeIdentifier_at(self, index, value): self.newTradeIdentifier.insert(index, value)
    def replace_newTradeIdentifier_at(self, index, value): self.newTradeIdentifier[index] = value
    def get_newTrade(self): return self.newTrade
    def set_newTrade(self, newTrade): self.newTrade = newTrade
    def get_transferor(self): return self.transferor
    def set_transferor(self, transferor): self.transferor = transferor
    def get_transferorAccount(self): return self.transferorAccount
    def set_transferorAccount(self, transferorAccount): self.transferorAccount = transferorAccount
    def get_transferee(self): return self.transferee
    def set_transferee(self, transferee): self.transferee = transferee
    def get_otherTransferee(self): return self.otherTransferee
    def set_otherTransferee(self, otherTransferee): self.otherTransferee = otherTransferee
    def get_transfereeAccount(self): return self.transfereeAccount
    def set_transfereeAccount(self, transfereeAccount): self.transfereeAccount = transfereeAccount
    def get_otherTransfereeAccount(self): return self.otherTransfereeAccount
    def set_otherTransfereeAccount(self, otherTransfereeAccount): self.otherTransfereeAccount = otherTransfereeAccount
    def get_remainingParty(self): return self.remainingParty
    def set_remainingParty(self, remainingParty): self.remainingParty = remainingParty
    def get_remainingPartyAccount(self): return self.remainingPartyAccount
    def set_remainingPartyAccount(self, remainingPartyAccount): self.remainingPartyAccount = remainingPartyAccount
    def get_otherRemainingParty(self): return self.otherRemainingParty
    def set_otherRemainingParty(self, otherRemainingParty): self.otherRemainingParty = otherRemainingParty
    def get_otherRemainingPartyAccount(self): return self.otherRemainingPartyAccount
    def set_otherRemainingPartyAccount(self, otherRemainingPartyAccount): self.otherRemainingPartyAccount = otherRemainingPartyAccount
    def get_novationDate(self): return self.novationDate
    def set_novationDate(self, novationDate): self.novationDate = novationDate
    def get_executionDateTime(self): return self.executionDateTime
    def set_executionDateTime(self, executionDateTime): self.executionDateTime = executionDateTime
    def get_novationTradeDate(self): return self.novationTradeDate
    def set_novationTradeDate(self, novationTradeDate): self.novationTradeDate = novationTradeDate
    def get_novatedAmount(self): return self.novatedAmount
    def set_novatedAmount(self, novatedAmount): self.novatedAmount = novatedAmount
    def add_novatedAmount(self, value): self.novatedAmount.append(value)
    def insert_novatedAmount_at(self, index, value): self.novatedAmount.insert(index, value)
    def replace_novatedAmount_at(self, index, value): self.novatedAmount[index] = value
    def get_remainingAmount(self): return self.remainingAmount
    def set_remainingAmount(self, remainingAmount): self.remainingAmount = remainingAmount
    def add_remainingAmount(self, value): self.remainingAmount.append(value)
    def insert_remainingAmount_at(self, index, value): self.remainingAmount.insert(index, value)
    def replace_remainingAmount_at(self, index, value): self.remainingAmount[index] = value
    def get_novatedNumberOfOptions(self): return self.novatedNumberOfOptions
    def set_novatedNumberOfOptions(self, novatedNumberOfOptions): self.novatedNumberOfOptions = novatedNumberOfOptions
    def get_remainingNumberOfOptions(self): return self.remainingNumberOfOptions
    def set_remainingNumberOfOptions(self, remainingNumberOfOptions): self.remainingNumberOfOptions = remainingNumberOfOptions
    def get_novatedNumberOfUnits(self): return self.novatedNumberOfUnits
    def set_novatedNumberOfUnits(self, novatedNumberOfUnits): self.novatedNumberOfUnits = novatedNumberOfUnits
    def get_remainingNumberOfUnits(self): return self.remainingNumberOfUnits
    def set_remainingNumberOfUnits(self, remainingNumberOfUnits): self.remainingNumberOfUnits = remainingNumberOfUnits
    def get_novationAmount(self): return self.novationAmount
    def set_novationAmount(self, novationAmount): self.novationAmount = novationAmount
    def add_novationAmount(self, value): self.novationAmount.append(value)
    def insert_novationAmount_at(self, index, value): self.novationAmount.insert(index, value)
    def replace_novationAmount_at(self, index, value): self.novationAmount[index] = value
    def get_fullFirstCalculationPeriod(self): return self.fullFirstCalculationPeriod
    def set_fullFirstCalculationPeriod(self, fullFirstCalculationPeriod): self.fullFirstCalculationPeriod = fullFirstCalculationPeriod
    def get_firstPeriodStartDate(self): return self.firstPeriodStartDate
    def set_firstPeriodStartDate(self, firstPeriodStartDate): self.firstPeriodStartDate = firstPeriodStartDate
    def add_firstPeriodStartDate(self, value): self.firstPeriodStartDate.append(value)
    def insert_firstPeriodStartDate_at(self, index, value): self.firstPeriodStartDate.insert(index, value)
    def replace_firstPeriodStartDate_at(self, index, value): self.firstPeriodStartDate[index] = value
    def get_nonReliance(self): return self.nonReliance
    def set_nonReliance(self, nonReliance): self.nonReliance = nonReliance
    def get_creditDerivativesNotices(self): return self.creditDerivativesNotices
    def set_creditDerivativesNotices(self, creditDerivativesNotices): self.creditDerivativesNotices = creditDerivativesNotices
    def get_contractualDefinitions(self): return self.contractualDefinitions
    def set_contractualDefinitions(self, contractualDefinitions): self.contractualDefinitions = contractualDefinitions
    def add_contractualDefinitions(self, value): self.contractualDefinitions.append(value)
    def insert_contractualDefinitions_at(self, index, value): self.contractualDefinitions.insert(index, value)
    def replace_contractualDefinitions_at(self, index, value): self.contractualDefinitions[index] = value
    def get_contractualTermsSupplement(self): return self.contractualTermsSupplement
    def set_contractualTermsSupplement(self, contractualTermsSupplement): self.contractualTermsSupplement = contractualTermsSupplement
    def add_contractualTermsSupplement(self, value): self.contractualTermsSupplement.append(value)
    def insert_contractualTermsSupplement_at(self, index, value): self.contractualTermsSupplement.insert(index, value)
    def replace_contractualTermsSupplement_at(self, index, value): self.contractualTermsSupplement[index] = value
    def get_payment(self): return self.payment
    def set_payment(self, payment): self.payment = payment
    def hasContent_(self):
        if (
            self.newTradeIdentifier or
            self.newTrade is not None or
            self.oldTradeIdentifier or
            self.oldTrade is not None or
            self.feeTradeIdentifier is not None or
            self.feeTrade is not None or
            self.newTradeIdentifier or
            self.newTrade is not None or
            self.feeTradeIdentifier is not None or
            self.feeTrade is not None or
            self.newTradeIdentifier or
            self.newTrade is not None or
            self.transferor is not None or
            self.transferorAccount is not None or
            self.transferee is not None or
            self.otherTransferee is not None or
            self.transfereeAccount is not None or
            self.otherTransfereeAccount is not None or
            self.remainingParty is not None or
            self.remainingPartyAccount is not None or
            self.otherRemainingParty is not None or
            self.otherRemainingPartyAccount is not None or
            self.novationDate is not None or
            self.executionDateTime is not None or
            self.novationTradeDate is not None or
            self.novatedAmount or
            self.remainingAmount or
            self.novatedNumberOfOptions is not None or
            self.remainingNumberOfOptions is not None or
            self.novatedNumberOfUnits is not None or
            self.remainingNumberOfUnits is not None or
            self.novationAmount or
            self.fullFirstCalculationPeriod is not None or
            self.firstPeriodStartDate or
            self.nonReliance is not None or
            self.creditDerivativesNotices is not None or
            self.contractualDefinitions or
            self.contractualTermsSupplement or
            self.payment is not None or
            super(TradeNovationContent, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TradeNovationContent', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TradeNovationContent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TradeNovationContent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TradeNovationContent'):
        super(TradeNovationContent, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TradeNovationContent')
    def exportChildren(self, outfile, level, namespace_='', name_='TradeNovationContent', fromsubclass_=False, pretty_print=True):
        super(TradeNovationContent, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for newTradeIdentifier_ in self.newTradeIdentifier:
            newTradeIdentifier_.export(outfile, level, namespace_, name_='newTradeIdentifier', pretty_print=pretty_print)
        if self.newTrade is not None:
            self.newTrade.export(outfile, level, namespace_, name_='newTrade', pretty_print=pretty_print)
        for oldTradeIdentifier_ in self.oldTradeIdentifier:
            oldTradeIdentifier_.export(outfile, level, namespace_, name_='oldTradeIdentifier', pretty_print=pretty_print)
        if self.oldTrade is not None:
            self.oldTrade.export(outfile, level, namespace_, name_='oldTrade', pretty_print=pretty_print)
        if self.feeTradeIdentifier is not None:
            self.feeTradeIdentifier.export(outfile, level, namespace_, name_='feeTradeIdentifier', pretty_print=pretty_print)
        if self.feeTrade is not None:
            self.feeTrade.export(outfile, level, namespace_, name_='feeTrade', pretty_print=pretty_print)
        for newTradeIdentifier_ in self.newTradeIdentifier:
            newTradeIdentifier_.export(outfile, level, namespace_, name_='newTradeIdentifier', pretty_print=pretty_print)
        if self.newTrade is not None:
            self.newTrade.export(outfile, level, namespace_, name_='newTrade', pretty_print=pretty_print)
        if self.feeTradeIdentifier is not None:
            self.feeTradeIdentifier.export(outfile, level, namespace_, name_='feeTradeIdentifier', pretty_print=pretty_print)
        if self.feeTrade is not None:
            self.feeTrade.export(outfile, level, namespace_, name_='feeTrade', pretty_print=pretty_print)
        for newTradeIdentifier_ in self.newTradeIdentifier:
            newTradeIdentifier_.export(outfile, level, namespace_, name_='newTradeIdentifier', pretty_print=pretty_print)
        if self.newTrade is not None:
            self.newTrade.export(outfile, level, namespace_, name_='newTrade', pretty_print=pretty_print)
        if self.transferor is not None:
            self.transferor.export(outfile, level, namespace_, name_='transferor', pretty_print=pretty_print)
        if self.transferorAccount is not None:
            self.transferorAccount.export(outfile, level, namespace_, name_='transferorAccount', pretty_print=pretty_print)
        if self.transferee is not None:
            self.transferee.export(outfile, level, namespace_, name_='transferee', pretty_print=pretty_print)
        if self.otherTransferee is not None:
            self.otherTransferee.export(outfile, level, namespace_, name_='otherTransferee', pretty_print=pretty_print)
        if self.transfereeAccount is not None:
            self.transfereeAccount.export(outfile, level, namespace_, name_='transfereeAccount', pretty_print=pretty_print)
        if self.otherTransfereeAccount is not None:
            self.otherTransfereeAccount.export(outfile, level, namespace_, name_='otherTransfereeAccount', pretty_print=pretty_print)
        if self.remainingParty is not None:
            self.remainingParty.export(outfile, level, namespace_, name_='remainingParty', pretty_print=pretty_print)
        if self.remainingPartyAccount is not None:
            self.remainingPartyAccount.export(outfile, level, namespace_, name_='remainingPartyAccount', pretty_print=pretty_print)
        if self.otherRemainingParty is not None:
            self.otherRemainingParty.export(outfile, level, namespace_, name_='otherRemainingParty', pretty_print=pretty_print)
        if self.otherRemainingPartyAccount is not None:
            self.otherRemainingPartyAccount.export(outfile, level, namespace_, name_='otherRemainingPartyAccount', pretty_print=pretty_print)
        if self.novationDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snovationDate>%s</%snovationDate>%s' % (namespace_, self.gds_format_date(self.novationDate, input_name='novationDate'), namespace_, eol_))
        if self.executionDateTime is not None:
            self.executionDateTime.export(outfile, level, namespace_, name_='executionDateTime', pretty_print=pretty_print)
        if self.novationTradeDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snovationTradeDate>%s</%snovationTradeDate>%s' % (namespace_, self.gds_format_date(self.novationTradeDate, input_name='novationTradeDate'), namespace_, eol_))
        for novatedAmount_ in self.novatedAmount:
            novatedAmount_.export(outfile, level, namespace_, name_='novatedAmount', pretty_print=pretty_print)
        for remainingAmount_ in self.remainingAmount:
            remainingAmount_.export(outfile, level, namespace_, name_='remainingAmount', pretty_print=pretty_print)
        if self.novatedNumberOfOptions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snovatedNumberOfOptions>%s</%snovatedNumberOfOptions>%s' % (namespace_, self.gds_format_float(self.novatedNumberOfOptions, input_name='novatedNumberOfOptions'), namespace_, eol_))
        if self.remainingNumberOfOptions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sremainingNumberOfOptions>%s</%sremainingNumberOfOptions>%s' % (namespace_, self.gds_format_float(self.remainingNumberOfOptions, input_name='remainingNumberOfOptions'), namespace_, eol_))
        if self.novatedNumberOfUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snovatedNumberOfUnits>%s</%snovatedNumberOfUnits>%s' % (namespace_, self.gds_format_float(self.novatedNumberOfUnits, input_name='novatedNumberOfUnits'), namespace_, eol_))
        if self.remainingNumberOfUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sremainingNumberOfUnits>%s</%sremainingNumberOfUnits>%s' % (namespace_, self.gds_format_float(self.remainingNumberOfUnits, input_name='remainingNumberOfUnits'), namespace_, eol_))
        for novationAmount_ in self.novationAmount:
            novationAmount_.export(outfile, level, namespace_, name_='novationAmount', pretty_print=pretty_print)
        if self.fullFirstCalculationPeriod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfullFirstCalculationPeriod>%s</%sfullFirstCalculationPeriod>%s' % (namespace_, self.gds_format_boolean(self.fullFirstCalculationPeriod, input_name='fullFirstCalculationPeriod'), namespace_, eol_))
        for firstPeriodStartDate_ in self.firstPeriodStartDate:
            firstPeriodStartDate_.export(outfile, level, namespace_, name_='firstPeriodStartDate', pretty_print=pretty_print)
        if self.nonReliance is not None:
            self.nonReliance.export(outfile, level, namespace_, name_='nonReliance', pretty_print=pretty_print)
        if self.creditDerivativesNotices is not None:
            self.creditDerivativesNotices.export(outfile, level, namespace_, name_='creditDerivativesNotices', pretty_print=pretty_print)
        for contractualDefinitions_ in self.contractualDefinitions:
            contractualDefinitions_.export(outfile, level, namespace_, name_='contractualDefinitions', pretty_print=pretty_print)
        for contractualTermsSupplement_ in self.contractualTermsSupplement:
            contractualTermsSupplement_.export(outfile, level, namespace_, name_='contractualTermsSupplement', pretty_print=pretty_print)
        if self.payment is not None:
            self.payment.export(outfile, level, namespace_, name_='payment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TradeNovationContent, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'newTradeIdentifier':
            obj_ = PartyTradeIdentifier.factory()
            obj_.build(child_)
            self.newTradeIdentifier.append(obj_)
            obj_.original_tagname_ = 'newTradeIdentifier'
        elif nodeName_ == 'newTrade':
            obj_ = Trade.factory()
            obj_.build(child_)
            self.newTrade = obj_
            obj_.original_tagname_ = 'newTrade'
        elif nodeName_ == 'oldTradeIdentifier':
            obj_ = PartyTradeIdentifier.factory()
            obj_.build(child_)
            self.oldTradeIdentifier.append(obj_)
            obj_.original_tagname_ = 'oldTradeIdentifier'
        elif nodeName_ == 'oldTrade':
            obj_ = Trade.factory()
            obj_.build(child_)
            self.oldTrade = obj_
            obj_.original_tagname_ = 'oldTrade'
        elif nodeName_ == 'feeTradeIdentifier':
            obj_ = PartyTradeIdentifier.factory()
            obj_.build(child_)
            self.feeTradeIdentifier = obj_
            obj_.original_tagname_ = 'feeTradeIdentifier'
        elif nodeName_ == 'feeTrade':
            obj_ = Trade.factory()
            obj_.build(child_)
            self.feeTrade = obj_
            obj_.original_tagname_ = 'feeTrade'
        elif nodeName_ == 'newTradeIdentifier':
            obj_ = PartyTradeIdentifier.factory()
            obj_.build(child_)
            self.newTradeIdentifier.append(obj_)
            obj_.original_tagname_ = 'newTradeIdentifier'
        elif nodeName_ == 'newTrade':
            obj_ = Trade.factory()
            obj_.build(child_)
            self.newTrade = obj_
            obj_.original_tagname_ = 'newTrade'
        elif nodeName_ == 'feeTradeIdentifier':
            obj_ = PartyTradeIdentifier.factory()
            obj_.build(child_)
            self.feeTradeIdentifier = obj_
            obj_.original_tagname_ = 'feeTradeIdentifier'
        elif nodeName_ == 'feeTrade':
            obj_ = Trade.factory()
            obj_.build(child_)
            self.feeTrade = obj_
            obj_.original_tagname_ = 'feeTrade'
        elif nodeName_ == 'newTradeIdentifier':
            obj_ = PartyTradeIdentifier.factory()
            obj_.build(child_)
            self.newTradeIdentifier.append(obj_)
            obj_.original_tagname_ = 'newTradeIdentifier'
        elif nodeName_ == 'newTrade':
            obj_ = Trade.factory()
            obj_.build(child_)
            self.newTrade = obj_
            obj_.original_tagname_ = 'newTrade'
        elif nodeName_ == 'transferor':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.transferor = obj_
            obj_.original_tagname_ = 'transferor'
        elif nodeName_ == 'transferorAccount':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.transferorAccount = obj_
            obj_.original_tagname_ = 'transferorAccount'
        elif nodeName_ == 'transferee':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.transferee = obj_
            obj_.original_tagname_ = 'transferee'
        elif nodeName_ == 'otherTransferee':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.otherTransferee = obj_
            obj_.original_tagname_ = 'otherTransferee'
        elif nodeName_ == 'transfereeAccount':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.transfereeAccount = obj_
            obj_.original_tagname_ = 'transfereeAccount'
        elif nodeName_ == 'otherTransfereeAccount':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.otherTransfereeAccount = obj_
            obj_.original_tagname_ = 'otherTransfereeAccount'
        elif nodeName_ == 'remainingParty':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.remainingParty = obj_
            obj_.original_tagname_ = 'remainingParty'
        elif nodeName_ == 'remainingPartyAccount':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.remainingPartyAccount = obj_
            obj_.original_tagname_ = 'remainingPartyAccount'
        elif nodeName_ == 'otherRemainingParty':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.otherRemainingParty = obj_
            obj_.original_tagname_ = 'otherRemainingParty'
        elif nodeName_ == 'otherRemainingPartyAccount':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.otherRemainingPartyAccount = obj_
            obj_.original_tagname_ = 'otherRemainingPartyAccount'
        elif nodeName_ == 'novationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.novationDate = dval_
        elif nodeName_ == 'executionDateTime':
            obj_ = ExecutionDateTime.factory()
            obj_.build(child_)
            self.executionDateTime = obj_
            obj_.original_tagname_ = 'executionDateTime'
        elif nodeName_ == 'novationTradeDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.novationTradeDate = dval_
        elif nodeName_ == 'novatedAmount':
            obj_ = Money.factory()
            obj_.build(child_)
            self.novatedAmount.append(obj_)
            obj_.original_tagname_ = 'novatedAmount'
        elif nodeName_ == 'remainingAmount':
            obj_ = Money.factory()
            obj_.build(child_)
            self.remainingAmount.append(obj_)
            obj_.original_tagname_ = 'remainingAmount'
        elif nodeName_ == 'novatedNumberOfOptions':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'novatedNumberOfOptions')
            self.novatedNumberOfOptions = fval_
        elif nodeName_ == 'remainingNumberOfOptions':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'remainingNumberOfOptions')
            self.remainingNumberOfOptions = fval_
        elif nodeName_ == 'novatedNumberOfUnits':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'novatedNumberOfUnits')
            self.novatedNumberOfUnits = fval_
        elif nodeName_ == 'remainingNumberOfUnits':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'remainingNumberOfUnits')
            self.remainingNumberOfUnits = fval_
        elif nodeName_ == 'novationAmount':
            obj_ = TradeLegSizeChange.factory()
            obj_.build(child_)
            self.novationAmount.append(obj_)
            obj_.original_tagname_ = 'novationAmount'
        elif nodeName_ == 'fullFirstCalculationPeriod':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'fullFirstCalculationPeriod')
            self.fullFirstCalculationPeriod = ival_
        elif nodeName_ == 'firstPeriodStartDate':
            obj_ = FirstPeriodStartDate.factory()
            obj_.build(child_)
            self.firstPeriodStartDate.append(obj_)
            obj_.original_tagname_ = 'firstPeriodStartDate'
        elif nodeName_ == 'nonReliance':
            obj_ = Empty.factory()
            obj_.build(child_)
            self.nonReliance = obj_
            obj_.original_tagname_ = 'nonReliance'
        elif nodeName_ == 'creditDerivativesNotices':
            obj_ = CreditDerivativesNotices.factory()
            obj_.build(child_)
            self.creditDerivativesNotices = obj_
            obj_.original_tagname_ = 'creditDerivativesNotices'
        elif nodeName_ == 'contractualDefinitions':
            obj_ = ContractualDefinitions.factory()
            obj_.build(child_)
            self.contractualDefinitions.append(obj_)
            obj_.original_tagname_ = 'contractualDefinitions'
        elif nodeName_ == 'contractualTermsSupplement':
            obj_ = ContractualTermsSupplement.factory()
            obj_.build(child_)
            self.contractualTermsSupplement.append(obj_)
            obj_.original_tagname_ = 'contractualTermsSupplement'
        elif nodeName_ == 'payment':
            obj_ = Payment.factory()
            obj_.build(child_)
            self.payment = obj_
            obj_.original_tagname_ = 'payment'
        super(TradeNovationContent, self).buildChildren(child_, node, nodeName_, True)
# end class TradeNovationContent


class TradePackage(GeneratedsSuper):
    """A bundle of trades collected together into a single unit for
    reporting."""
    member_data_items_ = {
        'packageHeader': MemberSpec_('packageHeader', 'PackageHeader', 0),
        'trade': MemberSpec_('trade', 'Trade', 1),
        'tradeReferenceInformation': MemberSpec_('tradeReferenceInformation', 'TradeReferenceInformation', 1),
        'tradeIdentifier': MemberSpec_('tradeIdentifier', 'TradeIdentifier', 1),
        'allocations': MemberSpec_('allocations', 'Allocations', 0),
        'approvals': MemberSpec_('approvals', 'Approvals', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, packageHeader=None, trade=None, tradeReferenceInformation=None, tradeIdentifier=None, allocations=None, approvals=None):
        self.original_tagname_ = None
        self.packageHeader = packageHeader
        if trade is None:
            self.trade = []
        else:
            self.trade = trade
        if tradeReferenceInformation is None:
            self.tradeReferenceInformation = []
        else:
            self.tradeReferenceInformation = tradeReferenceInformation
        if tradeIdentifier is None:
            self.tradeIdentifier = []
        else:
            self.tradeIdentifier = tradeIdentifier
        self.allocations = allocations
        self.approvals = approvals
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TradePackage)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TradePackage.subclass:
            return TradePackage.subclass(*args_, **kwargs_)
        else:
            return TradePackage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_packageHeader(self): return self.packageHeader
    def set_packageHeader(self, packageHeader): self.packageHeader = packageHeader
    def get_trade(self): return self.trade
    def set_trade(self, trade): self.trade = trade
    def add_trade(self, value): self.trade.append(value)
    def insert_trade_at(self, index, value): self.trade.insert(index, value)
    def replace_trade_at(self, index, value): self.trade[index] = value
    def get_tradeReferenceInformation(self): return self.tradeReferenceInformation
    def set_tradeReferenceInformation(self, tradeReferenceInformation): self.tradeReferenceInformation = tradeReferenceInformation
    def add_tradeReferenceInformation(self, value): self.tradeReferenceInformation.append(value)
    def insert_tradeReferenceInformation_at(self, index, value): self.tradeReferenceInformation.insert(index, value)
    def replace_tradeReferenceInformation_at(self, index, value): self.tradeReferenceInformation[index] = value
    def get_tradeIdentifier(self): return self.tradeIdentifier
    def set_tradeIdentifier(self, tradeIdentifier): self.tradeIdentifier = tradeIdentifier
    def add_tradeIdentifier(self, value): self.tradeIdentifier.append(value)
    def insert_tradeIdentifier_at(self, index, value): self.tradeIdentifier.insert(index, value)
    def replace_tradeIdentifier_at(self, index, value): self.tradeIdentifier[index] = value
    def get_allocations(self): return self.allocations
    def set_allocations(self, allocations): self.allocations = allocations
    def get_approvals(self): return self.approvals
    def set_approvals(self, approvals): self.approvals = approvals
    def hasContent_(self):
        if (
            self.packageHeader is not None or
            self.trade or
            self.tradeReferenceInformation or
            self.tradeIdentifier or
            self.allocations is not None or
            self.approvals is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TradePackage', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TradePackage')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TradePackage', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TradePackage'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TradePackage', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.packageHeader is not None:
            self.packageHeader.export(outfile, level, namespace_, name_='packageHeader', pretty_print=pretty_print)
        for trade_ in self.trade:
            trade_.export(outfile, level, namespace_, name_='trade', pretty_print=pretty_print)
        for tradeReferenceInformation_ in self.tradeReferenceInformation:
            tradeReferenceInformation_.export(outfile, level, namespace_, name_='tradeReferenceInformation', pretty_print=pretty_print)
        for tradeIdentifier_ in self.tradeIdentifier:
            tradeIdentifier_.export(outfile, level, namespace_, name_='tradeIdentifier', pretty_print=pretty_print)
        if self.allocations is not None:
            self.allocations.export(outfile, level, namespace_, name_='allocations', pretty_print=pretty_print)
        if self.approvals is not None:
            self.approvals.export(outfile, level, namespace_, name_='approvals', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'packageHeader':
            obj_ = PackageHeader.factory()
            obj_.build(child_)
            self.packageHeader = obj_
            obj_.original_tagname_ = 'packageHeader'
        elif nodeName_ == 'trade':
            obj_ = Trade.factory()
            obj_.build(child_)
            self.trade.append(obj_)
            obj_.original_tagname_ = 'trade'
        elif nodeName_ == 'tradeReferenceInformation':
            obj_ = TradeReferenceInformation.factory()
            obj_.build(child_)
            self.tradeReferenceInformation.append(obj_)
            obj_.original_tagname_ = 'tradeReferenceInformation'
        elif nodeName_ == 'tradeIdentifier':
            class_obj_ = self.get_class_obj_(child_, TradeIdentifier)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.tradeIdentifier.append(obj_)
            obj_.original_tagname_ = 'tradeIdentifier'
        elif nodeName_ == 'allocations':
            obj_ = Allocations.factory()
            obj_.build(child_)
            self.allocations = obj_
            obj_.original_tagname_ = 'allocations'
        elif nodeName_ == 'approvals':
            obj_ = Approvals.factory()
            obj_.build(child_)
            self.approvals = obj_
            obj_.original_tagname_ = 'approvals'
# end class TradePackage


class TradeReferenceInformation(GeneratedsSuper):
    """Defines a type that allows trade identifiers and/or trade
    information to be represented for a trade."""
    member_data_items_ = {
        'originatingEvent': MemberSpec_('originatingEvent', 'OriginatingEvent', 0),
        'terminatingEvent': MemberSpec_('terminatingEvent', 'TerminatingEvent', 0),
        'partyTradeIdentifier': MemberSpec_('partyTradeIdentifier', 'PartyTradeIdentifier', 1),
        'partyTradeInformation': MemberSpec_('partyTradeInformation', 'PartyTradeInformation', 1),
        'productType': MemberSpec_('productType', 'ProductType', 0),
        'productId': MemberSpec_('productId', 'ProductId', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, originatingEvent=None, terminatingEvent=None, partyTradeIdentifier=None, partyTradeInformation=None, productType=None, productId=None):
        self.original_tagname_ = None
        self.originatingEvent = originatingEvent
        self.terminatingEvent = terminatingEvent
        if partyTradeIdentifier is None:
            self.partyTradeIdentifier = []
        else:
            self.partyTradeIdentifier = partyTradeIdentifier
        if partyTradeInformation is None:
            self.partyTradeInformation = []
        else:
            self.partyTradeInformation = partyTradeInformation
        self.productType = productType
        self.productId = productId
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TradeReferenceInformation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TradeReferenceInformation.subclass:
            return TradeReferenceInformation.subclass(*args_, **kwargs_)
        else:
            return TradeReferenceInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_originatingEvent(self): return self.originatingEvent
    def set_originatingEvent(self, originatingEvent): self.originatingEvent = originatingEvent
    def get_terminatingEvent(self): return self.terminatingEvent
    def set_terminatingEvent(self, terminatingEvent): self.terminatingEvent = terminatingEvent
    def get_partyTradeIdentifier(self): return self.partyTradeIdentifier
    def set_partyTradeIdentifier(self, partyTradeIdentifier): self.partyTradeIdentifier = partyTradeIdentifier
    def add_partyTradeIdentifier(self, value): self.partyTradeIdentifier.append(value)
    def insert_partyTradeIdentifier_at(self, index, value): self.partyTradeIdentifier.insert(index, value)
    def replace_partyTradeIdentifier_at(self, index, value): self.partyTradeIdentifier[index] = value
    def get_partyTradeInformation(self): return self.partyTradeInformation
    def set_partyTradeInformation(self, partyTradeInformation): self.partyTradeInformation = partyTradeInformation
    def add_partyTradeInformation(self, value): self.partyTradeInformation.append(value)
    def insert_partyTradeInformation_at(self, index, value): self.partyTradeInformation.insert(index, value)
    def replace_partyTradeInformation_at(self, index, value): self.partyTradeInformation[index] = value
    def get_productType(self): return self.productType
    def set_productType(self, productType): self.productType = productType
    def get_productId(self): return self.productId
    def set_productId(self, productId): self.productId = productId
    def hasContent_(self):
        if (
            self.originatingEvent is not None or
            self.terminatingEvent is not None or
            self.partyTradeIdentifier or
            self.partyTradeInformation or
            self.productType is not None or
            self.productId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TradeReferenceInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TradeReferenceInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TradeReferenceInformation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TradeReferenceInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TradeReferenceInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.originatingEvent is not None:
            self.originatingEvent.export(outfile, level, namespace_, name_='originatingEvent', pretty_print=pretty_print)
        if self.terminatingEvent is not None:
            self.terminatingEvent.export(outfile, level, namespace_, name_='terminatingEvent', pretty_print=pretty_print)
        for partyTradeIdentifier_ in self.partyTradeIdentifier:
            partyTradeIdentifier_.export(outfile, level, namespace_, name_='partyTradeIdentifier', pretty_print=pretty_print)
        for partyTradeInformation_ in self.partyTradeInformation:
            partyTradeInformation_.export(outfile, level, namespace_, name_='partyTradeInformation', pretty_print=pretty_print)
        if self.productType is not None:
            self.productType.export(outfile, level, namespace_, name_='productType', pretty_print=pretty_print)
        if self.productId is not None:
            self.productId.export(outfile, level, namespace_, name_='productId', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'originatingEvent':
            obj_ = OriginatingEvent.factory()
            obj_.build(child_)
            self.originatingEvent = obj_
            obj_.original_tagname_ = 'originatingEvent'
        elif nodeName_ == 'terminatingEvent':
            obj_ = TerminatingEvent.factory()
            obj_.build(child_)
            self.terminatingEvent = obj_
            obj_.original_tagname_ = 'terminatingEvent'
        elif nodeName_ == 'partyTradeIdentifier':
            obj_ = PartyTradeIdentifier.factory()
            obj_.build(child_)
            self.partyTradeIdentifier.append(obj_)
            obj_.original_tagname_ = 'partyTradeIdentifier'
        elif nodeName_ == 'partyTradeInformation':
            obj_ = PartyTradeInformation.factory()
            obj_.build(child_)
            self.partyTradeInformation.append(obj_)
            obj_.original_tagname_ = 'partyTradeInformation'
        elif nodeName_ == 'productType':
            obj_ = ProductType.factory()
            obj_.build(child_)
            self.productType = obj_
            obj_.original_tagname_ = 'productType'
        elif nodeName_ == 'productId':
            obj_ = ProductId.factory()
            obj_.build(child_)
            self.productId = obj_
            obj_.original_tagname_ = 'productId'
# end class TradeReferenceInformation


class TradingEventSummary(GeneratedsSuper):
    """A type that records a short form event history of a trade."""
    member_data_items_ = {
        'eventIdentifier': MemberSpec_('eventIdentifier', 'BusinessEventIdentifier', 1),
        'eventType': MemberSpec_('eventType', 'EventType', 0),
        'agreementDate': MemberSpec_('agreementDate', 'xsd:date', 0),
        'executionDateTime': MemberSpec_('executionDateTime', 'ExecutionDateTime', 0),
        'effectiveDate': MemberSpec_('effectiveDate', 'xsd:date', 0),
        'payment': MemberSpec_('payment', 'NonNegativePayment', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, eventIdentifier=None, eventType=None, agreementDate=None, executionDateTime=None, effectiveDate=None, payment=None):
        self.original_tagname_ = None
        if eventIdentifier is None:
            self.eventIdentifier = []
        else:
            self.eventIdentifier = eventIdentifier
        self.eventType = eventType
        if isinstance(agreementDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(agreementDate, '%Y-%m-%d').date()
        else:
            initvalue_ = agreementDate
        self.agreementDate = initvalue_
        self.executionDateTime = executionDateTime
        if isinstance(effectiveDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(effectiveDate, '%Y-%m-%d').date()
        else:
            initvalue_ = effectiveDate
        self.effectiveDate = initvalue_
        self.payment = payment
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TradingEventSummary)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TradingEventSummary.subclass:
            return TradingEventSummary.subclass(*args_, **kwargs_)
        else:
            return TradingEventSummary(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_eventIdentifier(self): return self.eventIdentifier
    def set_eventIdentifier(self, eventIdentifier): self.eventIdentifier = eventIdentifier
    def add_eventIdentifier(self, value): self.eventIdentifier.append(value)
    def insert_eventIdentifier_at(self, index, value): self.eventIdentifier.insert(index, value)
    def replace_eventIdentifier_at(self, index, value): self.eventIdentifier[index] = value
    def get_eventType(self): return self.eventType
    def set_eventType(self, eventType): self.eventType = eventType
    def get_agreementDate(self): return self.agreementDate
    def set_agreementDate(self, agreementDate): self.agreementDate = agreementDate
    def get_executionDateTime(self): return self.executionDateTime
    def set_executionDateTime(self, executionDateTime): self.executionDateTime = executionDateTime
    def get_effectiveDate(self): return self.effectiveDate
    def set_effectiveDate(self, effectiveDate): self.effectiveDate = effectiveDate
    def get_payment(self): return self.payment
    def set_payment(self, payment): self.payment = payment
    def hasContent_(self):
        if (
            self.eventIdentifier or
            self.eventType is not None or
            self.agreementDate is not None or
            self.executionDateTime is not None or
            self.effectiveDate is not None or
            self.payment is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TradingEventSummary', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TradingEventSummary')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TradingEventSummary', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TradingEventSummary'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TradingEventSummary', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for eventIdentifier_ in self.eventIdentifier:
            eventIdentifier_.export(outfile, level, namespace_, name_='eventIdentifier', pretty_print=pretty_print)
        if self.eventType is not None:
            self.eventType.export(outfile, level, namespace_, name_='eventType', pretty_print=pretty_print)
        if self.agreementDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sagreementDate>%s</%sagreementDate>%s' % (namespace_, self.gds_format_date(self.agreementDate, input_name='agreementDate'), namespace_, eol_))
        if self.executionDateTime is not None:
            self.executionDateTime.export(outfile, level, namespace_, name_='executionDateTime', pretty_print=pretty_print)
        if self.effectiveDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%seffectiveDate>%s</%seffectiveDate>%s' % (namespace_, self.gds_format_date(self.effectiveDate, input_name='effectiveDate'), namespace_, eol_))
        if self.payment is not None:
            self.payment.export(outfile, level, namespace_, name_='payment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'eventIdentifier':
            obj_ = BusinessEventIdentifier.factory()
            obj_.build(child_)
            self.eventIdentifier.append(obj_)
            obj_.original_tagname_ = 'eventIdentifier'
        elif nodeName_ == 'eventType':
            obj_ = EventType.factory()
            obj_.build(child_)
            self.eventType = obj_
            obj_.original_tagname_ = 'eventType'
        elif nodeName_ == 'agreementDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.agreementDate = dval_
        elif nodeName_ == 'executionDateTime':
            obj_ = ExecutionDateTime.factory()
            obj_.build(child_)
            self.executionDateTime = obj_
            obj_.original_tagname_ = 'executionDateTime'
        elif nodeName_ == 'effectiveDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.effectiveDate = dval_
        elif nodeName_ == 'payment':
            obj_ = NonNegativePayment.factory()
            obj_.build(child_)
            self.payment = obj_
            obj_.original_tagname_ = 'payment'
# end class TradingEventSummary


class TriggerRateObservation(GeneratedsSuper):
    member_data_items_ = {
        'observationDate': MemberSpec_('observationDate', 'xsd:date', 0),
        'observationTime': MemberSpec_('observationTime', 'BusinessCenterTime', 0),
        'informationSource': MemberSpec_('informationSource', 'InformationSource', 0),
        'triggerRate': MemberSpec_('triggerRate', 'xsd:decimal', 0),
        'quotedCurrencyPair': MemberSpec_('quotedCurrencyPair', 'QuotedCurrencyPair', 0),
        'observedRate': MemberSpec_('observedRate', 'xsd:decimal', 0),
        'triggerPrice': MemberSpec_('triggerPrice', 'PositiveMoney', 0),
        'observedPrice': MemberSpec_('observedPrice', 'PositiveMoney', 0),
        'triggerCondition': MemberSpec_('triggerCondition', ['TriggerConditionEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, observationDate=None, observationTime=None, informationSource=None, triggerRate=None, quotedCurrencyPair=None, observedRate=None, triggerPrice=None, observedPrice=None, triggerCondition=None, extensiontype_=None):
        self.original_tagname_ = None
        if isinstance(observationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(observationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = observationDate
        self.observationDate = initvalue_
        self.observationTime = observationTime
        self.informationSource = informationSource
        self.triggerRate = triggerRate
        self.quotedCurrencyPair = quotedCurrencyPair
        self.observedRate = observedRate
        self.triggerPrice = triggerPrice
        self.observedPrice = observedPrice
        self.triggerCondition = triggerCondition
        self.validate_TriggerConditionEnum(self.triggerCondition)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TriggerRateObservation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TriggerRateObservation.subclass:
            return TriggerRateObservation.subclass(*args_, **kwargs_)
        else:
            return TriggerRateObservation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_observationDate(self): return self.observationDate
    def set_observationDate(self, observationDate): self.observationDate = observationDate
    def get_observationTime(self): return self.observationTime
    def set_observationTime(self, observationTime): self.observationTime = observationTime
    def get_informationSource(self): return self.informationSource
    def set_informationSource(self, informationSource): self.informationSource = informationSource
    def get_triggerRate(self): return self.triggerRate
    def set_triggerRate(self, triggerRate): self.triggerRate = triggerRate
    def get_quotedCurrencyPair(self): return self.quotedCurrencyPair
    def set_quotedCurrencyPair(self, quotedCurrencyPair): self.quotedCurrencyPair = quotedCurrencyPair
    def get_observedRate(self): return self.observedRate
    def set_observedRate(self, observedRate): self.observedRate = observedRate
    def get_triggerPrice(self): return self.triggerPrice
    def set_triggerPrice(self, triggerPrice): self.triggerPrice = triggerPrice
    def get_observedPrice(self): return self.observedPrice
    def set_observedPrice(self, observedPrice): self.observedPrice = observedPrice
    def get_triggerCondition(self): return self.triggerCondition
    def set_triggerCondition(self, triggerCondition): self.triggerCondition = triggerCondition
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_TriggerConditionEnum(self, value):
        # Validate type TriggerConditionEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AtOrAbove', 'AtOrBelow', 'Above', 'Below']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TriggerConditionEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on TriggerConditionEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.observationDate is not None or
            self.observationTime is not None or
            self.informationSource is not None or
            self.triggerRate is not None or
            self.quotedCurrencyPair is not None or
            self.observedRate is not None or
            self.triggerPrice is not None or
            self.observedPrice is not None or
            self.triggerCondition is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TriggerRateObservation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TriggerRateObservation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TriggerRateObservation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TriggerRateObservation'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TriggerRateObservation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.observationDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sobservationDate>%s</%sobservationDate>%s' % (namespace_, self.gds_format_date(self.observationDate, input_name='observationDate'), namespace_, eol_))
        if self.observationTime is not None:
            self.observationTime.export(outfile, level, namespace_, name_='observationTime', pretty_print=pretty_print)
        if self.informationSource is not None:
            self.informationSource.export(outfile, level, namespace_, name_='informationSource', pretty_print=pretty_print)
        if self.triggerRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%striggerRate>%s</%striggerRate>%s' % (namespace_, self.gds_format_float(self.triggerRate, input_name='triggerRate'), namespace_, eol_))
        if self.quotedCurrencyPair is not None:
            self.quotedCurrencyPair.export(outfile, level, namespace_, name_='quotedCurrencyPair', pretty_print=pretty_print)
        if self.observedRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sobservedRate>%s</%sobservedRate>%s' % (namespace_, self.gds_format_float(self.observedRate, input_name='observedRate'), namespace_, eol_))
        if self.triggerPrice is not None:
            self.triggerPrice.export(outfile, level, namespace_, name_='triggerPrice', pretty_print=pretty_print)
        if self.observedPrice is not None:
            self.observedPrice.export(outfile, level, namespace_, name_='observedPrice', pretty_print=pretty_print)
        if self.triggerCondition is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%striggerCondition>%s</%striggerCondition>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.triggerCondition), input_name='triggerCondition')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'observationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.observationDate = dval_
        elif nodeName_ == 'observationTime':
            obj_ = BusinessCenterTime.factory()
            obj_.build(child_)
            self.observationTime = obj_
            obj_.original_tagname_ = 'observationTime'
        elif nodeName_ == 'informationSource':
            class_obj_ = self.get_class_obj_(child_, InformationSource)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.informationSource = obj_
            obj_.original_tagname_ = 'informationSource'
        elif nodeName_ == 'triggerRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'triggerRate')
            self.triggerRate = fval_
        elif nodeName_ == 'quotedCurrencyPair':
            obj_ = QuotedCurrencyPair.factory()
            obj_.build(child_)
            self.quotedCurrencyPair = obj_
            obj_.original_tagname_ = 'quotedCurrencyPair'
        elif nodeName_ == 'observedRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'observedRate')
            self.observedRate = fval_
        elif nodeName_ == 'triggerPrice':
            obj_ = PositiveMoney.factory()
            obj_.build(child_)
            self.triggerPrice = obj_
            obj_.original_tagname_ = 'triggerPrice'
        elif nodeName_ == 'observedPrice':
            obj_ = PositiveMoney.factory()
            obj_.build(child_)
            self.observedPrice = obj_
            obj_.original_tagname_ = 'observedPrice'
        elif nodeName_ == 'triggerCondition':
            triggerCondition_ = child_.text
            triggerCondition_ = re_.sub(String_cleanup_pat_, " ", triggerCondition_).strip()
            triggerCondition_ = self.gds_validate_string(triggerCondition_, node, 'triggerCondition')
            self.triggerCondition = triggerCondition_
            # validate type TriggerConditionEnum
            self.validate_TriggerConditionEnum(self.triggerCondition)
# end class TriggerRateObservation


class Velocity(GeneratedsSuper):
    member_data_items_ = {
        'periodMultiplier': MemberSpec_('periodMultiplier', 'xsd:integer', 0),
        'period': MemberSpec_('period', ['PeriodTimeEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, periodMultiplier=None, period=None):
        self.original_tagname_ = None
        self.periodMultiplier = periodMultiplier
        self.period = period
        self.validate_PeriodTimeEnum(self.period)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Velocity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Velocity.subclass:
            return Velocity.subclass(*args_, **kwargs_)
        else:
            return Velocity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_periodMultiplier(self): return self.periodMultiplier
    def set_periodMultiplier(self, periodMultiplier): self.periodMultiplier = periodMultiplier
    def get_period(self): return self.period
    def set_period(self, period): self.period = period
    def validate_PeriodTimeEnum(self, value):
        # Validate type PeriodTimeEnum, a restriction on Token.
        pass
    def hasContent_(self):
        if (
            self.periodMultiplier is not None or
            self.period is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Velocity', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Velocity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Velocity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Velocity'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Velocity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.periodMultiplier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%speriodMultiplier>%s</%speriodMultiplier>%s' % (namespace_, self.gds_format_integer(self.periodMultiplier, input_name='periodMultiplier'), namespace_, eol_))
        if self.period is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%speriod>%s</%speriod>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.period), input_name='period')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'periodMultiplier':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'periodMultiplier')
            self.periodMultiplier = ival_
        elif nodeName_ == 'period':
            period_ = child_.text
            period_ = re_.sub(String_cleanup_pat_, " ", period_).strip()
            period_ = self.gds_validate_string(period_, node, 'period')
            self.period = period_
            # validate type PeriodTimeEnum
            self.validate_PeriodTimeEnum(self.period)
# end class Velocity


class Withdrawal(GeneratedsSuper):
    """A structure describing the removal of a trade from a service, such
    as a reporting service."""
    member_data_items_ = {
        'partyTradeIdentifier': MemberSpec_('partyTradeIdentifier', 'PartyTradeIdentifier', 1),
        'partyTradeInformation': MemberSpec_('partyTradeInformation', 'WithdrawalPartyTradeInformation', 1),
        'effectiveDate': MemberSpec_('effectiveDate', 'xsd:date', 0),
        'requestedAction': MemberSpec_('requestedAction', 'RequestedWithdrawalAction', 0),
        'reason': MemberSpec_('reason', 'WithdrawalReason', 1),
        'reportingRegime': MemberSpec_('reportingRegime', 'ReportingRegimeIdentifier', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, partyTradeIdentifier=None, partyTradeInformation=None, effectiveDate=None, requestedAction=None, reason=None, reportingRegime=None):
        self.original_tagname_ = None
        if partyTradeIdentifier is None:
            self.partyTradeIdentifier = []
        else:
            self.partyTradeIdentifier = partyTradeIdentifier
        if partyTradeInformation is None:
            self.partyTradeInformation = []
        else:
            self.partyTradeInformation = partyTradeInformation
        if isinstance(effectiveDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(effectiveDate, '%Y-%m-%d').date()
        else:
            initvalue_ = effectiveDate
        self.effectiveDate = initvalue_
        self.requestedAction = requestedAction
        if reason is None:
            self.reason = []
        else:
            self.reason = reason
        if reportingRegime is None:
            self.reportingRegime = []
        else:
            self.reportingRegime = reportingRegime
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Withdrawal)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Withdrawal.subclass:
            return Withdrawal.subclass(*args_, **kwargs_)
        else:
            return Withdrawal(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyTradeIdentifier(self): return self.partyTradeIdentifier
    def set_partyTradeIdentifier(self, partyTradeIdentifier): self.partyTradeIdentifier = partyTradeIdentifier
    def add_partyTradeIdentifier(self, value): self.partyTradeIdentifier.append(value)
    def insert_partyTradeIdentifier_at(self, index, value): self.partyTradeIdentifier.insert(index, value)
    def replace_partyTradeIdentifier_at(self, index, value): self.partyTradeIdentifier[index] = value
    def get_partyTradeInformation(self): return self.partyTradeInformation
    def set_partyTradeInformation(self, partyTradeInformation): self.partyTradeInformation = partyTradeInformation
    def add_partyTradeInformation(self, value): self.partyTradeInformation.append(value)
    def insert_partyTradeInformation_at(self, index, value): self.partyTradeInformation.insert(index, value)
    def replace_partyTradeInformation_at(self, index, value): self.partyTradeInformation[index] = value
    def get_effectiveDate(self): return self.effectiveDate
    def set_effectiveDate(self, effectiveDate): self.effectiveDate = effectiveDate
    def get_requestedAction(self): return self.requestedAction
    def set_requestedAction(self, requestedAction): self.requestedAction = requestedAction
    def get_reason(self): return self.reason
    def set_reason(self, reason): self.reason = reason
    def add_reason(self, value): self.reason.append(value)
    def insert_reason_at(self, index, value): self.reason.insert(index, value)
    def replace_reason_at(self, index, value): self.reason[index] = value
    def get_reportingRegime(self): return self.reportingRegime
    def set_reportingRegime(self, reportingRegime): self.reportingRegime = reportingRegime
    def add_reportingRegime(self, value): self.reportingRegime.append(value)
    def insert_reportingRegime_at(self, index, value): self.reportingRegime.insert(index, value)
    def replace_reportingRegime_at(self, index, value): self.reportingRegime[index] = value
    def hasContent_(self):
        if (
            self.partyTradeIdentifier or
            self.partyTradeInformation or
            self.effectiveDate is not None or
            self.requestedAction is not None or
            self.reason or
            self.reportingRegime
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Withdrawal', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Withdrawal')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Withdrawal', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Withdrawal'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Withdrawal', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for partyTradeIdentifier_ in self.partyTradeIdentifier:
            partyTradeIdentifier_.export(outfile, level, namespace_, name_='partyTradeIdentifier', pretty_print=pretty_print)
        for partyTradeInformation_ in self.partyTradeInformation:
            partyTradeInformation_.export(outfile, level, namespace_, name_='partyTradeInformation', pretty_print=pretty_print)
        if self.effectiveDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%seffectiveDate>%s</%seffectiveDate>%s' % (namespace_, self.gds_format_date(self.effectiveDate, input_name='effectiveDate'), namespace_, eol_))
        if self.requestedAction is not None:
            self.requestedAction.export(outfile, level, namespace_, name_='requestedAction', pretty_print=pretty_print)
        for reason_ in self.reason:
            reason_.export(outfile, level, namespace_, name_='reason', pretty_print=pretty_print)
        for reportingRegime_ in self.reportingRegime:
            reportingRegime_.export(outfile, level, namespace_, name_='reportingRegime', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'partyTradeIdentifier':
            obj_ = PartyTradeIdentifier.factory()
            obj_.build(child_)
            self.partyTradeIdentifier.append(obj_)
            obj_.original_tagname_ = 'partyTradeIdentifier'
        elif nodeName_ == 'partyTradeInformation':
            obj_ = WithdrawalPartyTradeInformation.factory()
            obj_.build(child_)
            self.partyTradeInformation.append(obj_)
            obj_.original_tagname_ = 'partyTradeInformation'
        elif nodeName_ == 'effectiveDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.effectiveDate = dval_
        elif nodeName_ == 'requestedAction':
            obj_ = RequestedWithdrawalAction.factory()
            obj_.build(child_)
            self.requestedAction = obj_
            obj_.original_tagname_ = 'requestedAction'
        elif nodeName_ == 'reason':
            obj_ = WithdrawalReason.factory()
            obj_.build(child_)
            self.reason.append(obj_)
            obj_.original_tagname_ = 'reason'
        elif nodeName_ == 'reportingRegime':
            obj_ = ReportingRegimeIdentifier.factory()
            obj_.build(child_)
            self.reportingRegime.append(obj_)
            obj_.original_tagname_ = 'reportingRegime'
# end class Withdrawal


class WithdrawalPartyTradeInformation(GeneratedsSuper):
    """A type defining party-specific additional information that may be
    recorded against a trade, for withdrawal purposes."""
    member_data_items_ = {
        'partyReference': MemberSpec_('partyReference', 'PartyReference', 0),
        'accountReference': MemberSpec_('accountReference', 'AccountReference', 0),
        'relatedParty': MemberSpec_('relatedParty', 'RelatedParty', 1),
        'reportingRegime': MemberSpec_('reportingRegime', 'ReportingRegimeIdentifier', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, partyReference=None, accountReference=None, relatedParty=None, reportingRegime=None):
        self.original_tagname_ = None
        self.partyReference = partyReference
        self.accountReference = accountReference
        if relatedParty is None:
            self.relatedParty = []
        else:
            self.relatedParty = relatedParty
        if reportingRegime is None:
            self.reportingRegime = []
        else:
            self.reportingRegime = reportingRegime
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WithdrawalPartyTradeInformation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WithdrawalPartyTradeInformation.subclass:
            return WithdrawalPartyTradeInformation.subclass(*args_, **kwargs_)
        else:
            return WithdrawalPartyTradeInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyReference(self): return self.partyReference
    def set_partyReference(self, partyReference): self.partyReference = partyReference
    def get_accountReference(self): return self.accountReference
    def set_accountReference(self, accountReference): self.accountReference = accountReference
    def get_relatedParty(self): return self.relatedParty
    def set_relatedParty(self, relatedParty): self.relatedParty = relatedParty
    def add_relatedParty(self, value): self.relatedParty.append(value)
    def insert_relatedParty_at(self, index, value): self.relatedParty.insert(index, value)
    def replace_relatedParty_at(self, index, value): self.relatedParty[index] = value
    def get_reportingRegime(self): return self.reportingRegime
    def set_reportingRegime(self, reportingRegime): self.reportingRegime = reportingRegime
    def add_reportingRegime(self, value): self.reportingRegime.append(value)
    def insert_reportingRegime_at(self, index, value): self.reportingRegime.insert(index, value)
    def replace_reportingRegime_at(self, index, value): self.reportingRegime[index] = value
    def hasContent_(self):
        if (
            self.partyReference is not None or
            self.accountReference is not None or
            self.relatedParty or
            self.reportingRegime
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='WithdrawalPartyTradeInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WithdrawalPartyTradeInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='WithdrawalPartyTradeInformation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='WithdrawalPartyTradeInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='WithdrawalPartyTradeInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.partyReference is not None:
            self.partyReference.export(outfile, level, namespace_, name_='partyReference', pretty_print=pretty_print)
        if self.accountReference is not None:
            self.accountReference.export(outfile, level, namespace_, name_='accountReference', pretty_print=pretty_print)
        for relatedParty_ in self.relatedParty:
            relatedParty_.export(outfile, level, namespace_, name_='relatedParty', pretty_print=pretty_print)
        for reportingRegime_ in self.reportingRegime:
            reportingRegime_.export(outfile, level, namespace_, name_='reportingRegime', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'partyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.partyReference = obj_
            obj_.original_tagname_ = 'partyReference'
        elif nodeName_ == 'accountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.accountReference = obj_
            obj_.original_tagname_ = 'accountReference'
        elif nodeName_ == 'relatedParty':
            obj_ = RelatedParty.factory()
            obj_.build(child_)
            self.relatedParty.append(obj_)
            obj_.original_tagname_ = 'relatedParty'
        elif nodeName_ == 'reportingRegime':
            obj_ = ReportingRegimeIdentifier.factory()
            obj_.build(child_)
            self.reportingRegime.append(obj_)
            obj_.original_tagname_ = 'reportingRegime'
# end class WithdrawalPartyTradeInformation


class WithdrawalReason(GeneratedsSuper):
    """A type that describes why a trade was withdrawn."""
    member_data_items_ = {
        'withdrawalReasonScheme': MemberSpec_('withdrawalReasonScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, withdrawalReasonScheme='http://www.fpml.org/coding-scheme/withdrawal-reason', valueOf_=None):
        self.original_tagname_ = None
        self.withdrawalReasonScheme = _cast(None, withdrawalReasonScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WithdrawalReason)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WithdrawalReason.subclass:
            return WithdrawalReason.subclass(*args_, **kwargs_)
        else:
            return WithdrawalReason(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_withdrawalReasonScheme(self): return self.withdrawalReasonScheme
    def set_withdrawalReasonScheme(self, withdrawalReasonScheme): self.withdrawalReasonScheme = withdrawalReasonScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='WithdrawalReason', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WithdrawalReason')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='WithdrawalReason', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='WithdrawalReason'):
        if self.withdrawalReasonScheme != "http://www.fpml.org/coding-scheme/withdrawal-reason" and 'withdrawalReasonScheme' not in already_processed:
            already_processed.add('withdrawalReasonScheme')
            outfile.write(' withdrawalReasonScheme=%s' % (quote_attrib(self.withdrawalReasonScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='WithdrawalReason', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('withdrawalReasonScheme', node)
        if value is not None and 'withdrawalReasonScheme' not in already_processed:
            already_processed.add('withdrawalReasonScheme')
            self.withdrawalReasonScheme = value
            self.validate_NonEmptyURI(self.withdrawalReasonScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WithdrawalReason


class AdditionalData(GeneratedsSuper):
    """Provides extra information not represented in the model that may be
    useful in processing the message i.e. diagnosing the reason for
    failure."""
    member_data_items_ = {
        'mimeType': MemberSpec_('mimeType', 'MimeType', 0),
        'string': MemberSpec_('string', ['String', 'xsd:string'], 0),
        'hexadecimalBinary': MemberSpec_('hexadecimalBinary', 'xsd:hexBinary', 0),
        'base64Binary': MemberSpec_('base64Binary', 'xsd:base64Binary', 0),
        'originalMessage': MemberSpec_('originalMessage', 'originalMessageType', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, mimeType=None, string=None, hexadecimalBinary=None, base64Binary=None, originalMessage=None):
        self.original_tagname_ = None
        self.mimeType = mimeType
        self.string = string
        self.validate_String(self.string)
        self.hexadecimalBinary = hexadecimalBinary
        self.base64Binary = base64Binary
        self.originalMessage = originalMessage
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdditionalData)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdditionalData.subclass:
            return AdditionalData.subclass(*args_, **kwargs_)
        else:
            return AdditionalData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mimeType(self): return self.mimeType
    def set_mimeType(self, mimeType): self.mimeType = mimeType
    def get_string(self): return self.string
    def set_string(self, string): self.string = string
    def get_hexadecimalBinary(self): return self.hexadecimalBinary
    def set_hexadecimalBinary(self, hexadecimalBinary): self.hexadecimalBinary = hexadecimalBinary
    def get_base64Binary(self): return self.base64Binary
    def set_base64Binary(self, base64Binary): self.base64Binary = base64Binary
    def get_originalMessage(self): return self.originalMessage
    def set_originalMessage(self, originalMessage): self.originalMessage = originalMessage
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.mimeType is not None or
            self.string is not None or
            self.hexadecimalBinary is not None or
            self.base64Binary is not None or
            self.originalMessage is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AdditionalData', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdditionalData')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AdditionalData', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AdditionalData'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AdditionalData', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.mimeType is not None:
            self.mimeType.export(outfile, level, namespace_, name_='mimeType', pretty_print=pretty_print)
        if self.string is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstring>%s</%sstring>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.string), input_name='string')), namespace_, eol_))
        if self.hexadecimalBinary is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shexadecimalBinary>%s</%shexadecimalBinary>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.hexadecimalBinary), input_name='hexadecimalBinary')), namespace_, eol_))
        if self.base64Binary is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbase64Binary>%s</%sbase64Binary>%s' % (namespace_, self.gds_format_base64(self.base64Binary, input_name='base64Binary'), namespace_, eol_))
        if self.originalMessage is not None:
            self.originalMessage.export(outfile, level, namespace_, name_='originalMessage', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'mimeType':
            obj_ = MimeType.factory()
            obj_.build(child_)
            self.mimeType = obj_
            obj_.original_tagname_ = 'mimeType'
        elif nodeName_ == 'string':
            string_ = child_.text
            string_ = self.gds_validate_string(string_, node, 'string')
            self.string = string_
            # validate type String
            self.validate_String(self.string)
        elif nodeName_ == 'hexadecimalBinary':
            hexadecimalBinary_ = child_.text
            hexadecimalBinary_ = self.gds_validate_string(hexadecimalBinary_, node, 'hexadecimalBinary')
            self.hexadecimalBinary = hexadecimalBinary_
        elif nodeName_ == 'base64Binary':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'base64Binary')
            else:
                bval_ = None
            self.base64Binary = bval_
        elif nodeName_ == 'originalMessage':
            obj_ = originalMessageType.factory()
            obj_.build(child_)
            self.originalMessage = obj_
            obj_.original_tagname_ = 'originalMessage'
# end class AdditionalData


class BusinessProcess(GeneratedsSuper):
    """A type that can be used to identify the type of business process in
    a request. Examples include Allocation, Clearing, Confirmation,
    etc."""
    member_data_items_ = {
        'businessProcessScheme': MemberSpec_('businessProcessScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, businessProcessScheme='http://www.fpml.org/coding-scheme/business-process', valueOf_=None):
        self.original_tagname_ = None
        self.businessProcessScheme = _cast(None, businessProcessScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BusinessProcess)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BusinessProcess.subclass:
            return BusinessProcess.subclass(*args_, **kwargs_)
        else:
            return BusinessProcess(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_businessProcessScheme(self): return self.businessProcessScheme
    def set_businessProcessScheme(self, businessProcessScheme): self.businessProcessScheme = businessProcessScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BusinessProcess', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BusinessProcess')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BusinessProcess', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BusinessProcess'):
        if self.businessProcessScheme != "http://www.fpml.org/coding-scheme/business-process" and 'businessProcessScheme' not in already_processed:
            already_processed.add('businessProcessScheme')
            outfile.write(' businessProcessScheme=%s' % (quote_attrib(self.businessProcessScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BusinessProcess', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('businessProcessScheme', node)
        if value is not None and 'businessProcessScheme' not in already_processed:
            already_processed.add('businessProcessScheme')
            self.businessProcessScheme = value
            self.validate_NonEmptyURI(self.businessProcessScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BusinessProcess


class CorrelationId(GeneratedsSuper):
    """A type defining a correlation identifier and qualifying scheme"""
    member_data_items_ = {
        'correlationIdScheme': MemberSpec_('correlationIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, correlationIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.correlationIdScheme = _cast(None, correlationIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CorrelationId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CorrelationId.subclass:
            return CorrelationId.subclass(*args_, **kwargs_)
        else:
            return CorrelationId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_correlationIdScheme(self): return self.correlationIdScheme
    def set_correlationIdScheme(self, correlationIdScheme): self.correlationIdScheme = correlationIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CorrelationId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CorrelationId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CorrelationId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CorrelationId'):
        if self.correlationIdScheme is not None and 'correlationIdScheme' not in already_processed:
            already_processed.add('correlationIdScheme')
            outfile.write(' correlationIdScheme=%s' % (quote_attrib(self.correlationIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CorrelationId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('correlationIdScheme', node)
        if value is not None and 'correlationIdScheme' not in already_processed:
            already_processed.add('correlationIdScheme')
            self.correlationIdScheme = value
            self.validate_NonEmptyURI(self.correlationIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CorrelationId


class EventIdentifier(GeneratedsSuper):
    """Identification of a business event, for example through its
    correlation id or a business identifier."""
    member_data_items_ = {
        'correlationId': MemberSpec_('correlationId', 'CorrelationId', 0),
        'sequenceNumber': MemberSpec_('sequenceNumber', 'xsd:positiveInteger', 0),
        'tradeIdentifier': MemberSpec_('tradeIdentifier', 'TradeIdentifier', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, correlationId=None, sequenceNumber=None, tradeIdentifier=None):
        self.original_tagname_ = None
        self.correlationId = correlationId
        self.sequenceNumber = sequenceNumber
        self.tradeIdentifier = tradeIdentifier
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EventIdentifier)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EventIdentifier.subclass:
            return EventIdentifier.subclass(*args_, **kwargs_)
        else:
            return EventIdentifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_correlationId(self): return self.correlationId
    def set_correlationId(self, correlationId): self.correlationId = correlationId
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def get_tradeIdentifier(self): return self.tradeIdentifier
    def set_tradeIdentifier(self, tradeIdentifier): self.tradeIdentifier = tradeIdentifier
    def hasContent_(self):
        if (
            self.correlationId is not None or
            self.sequenceNumber is not None or
            self.tradeIdentifier is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EventIdentifier', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EventIdentifier')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EventIdentifier', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EventIdentifier'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EventIdentifier', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.correlationId is not None:
            self.correlationId.export(outfile, level, namespace_, name_='correlationId', pretty_print=pretty_print)
        if self.sequenceNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssequenceNumber>%s</%ssequenceNumber>%s' % (namespace_, self.gds_format_integer(self.sequenceNumber, input_name='sequenceNumber'), namespace_, eol_))
        if self.tradeIdentifier is not None:
            self.tradeIdentifier.export(outfile, level, namespace_, name_='tradeIdentifier', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'correlationId':
            obj_ = CorrelationId.factory()
            obj_.build(child_)
            self.correlationId = obj_
            obj_.original_tagname_ = 'correlationId'
        elif nodeName_ == 'sequenceNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'sequenceNumber')
            self.sequenceNumber = ival_
        elif nodeName_ == 'tradeIdentifier':
            class_obj_ = self.get_class_obj_(child_, TradeIdentifier)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.tradeIdentifier = obj_
            obj_.original_tagname_ = 'tradeIdentifier'
# end class EventIdentifier


class EventStatus(GeneratedsSuper):
    """A coding scheme used to describe the matching/confirmation status of
    a trade, post-trade event, position, or cash flows."""
    member_data_items_ = {
        'eventStatusScheme': MemberSpec_('eventStatusScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, eventStatusScheme='http://www.fpml.org/coding-scheme/event-status', valueOf_=None):
        self.original_tagname_ = None
        self.eventStatusScheme = _cast(None, eventStatusScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EventStatus)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EventStatus.subclass:
            return EventStatus.subclass(*args_, **kwargs_)
        else:
            return EventStatus(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_eventStatusScheme(self): return self.eventStatusScheme
    def set_eventStatusScheme(self, eventStatusScheme): self.eventStatusScheme = eventStatusScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EventStatus', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EventStatus')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EventStatus', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EventStatus'):
        if self.eventStatusScheme != "http://www.fpml.org/coding-scheme/event-status" and 'eventStatusScheme' not in already_processed:
            already_processed.add('eventStatusScheme')
            outfile.write(' eventStatusScheme=%s' % (quote_attrib(self.eventStatusScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EventStatus', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('eventStatusScheme', node)
        if value is not None and 'eventStatusScheme' not in already_processed:
            already_processed.add('eventStatusScheme')
            self.eventStatusScheme = value
            self.validate_NonEmptyURI(self.eventStatusScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EventStatus


class EventStatusItem(GeneratedsSuper):
    """A type used in event status enquiry messages which relates an event
    identifier to its current status value."""
    member_data_items_ = {
        'eventIdentifier': MemberSpec_('eventIdentifier', 'EventIdentifier', 0),
        'status': MemberSpec_('status', 'EventStatus', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, eventIdentifier=None, status=None):
        self.original_tagname_ = None
        self.eventIdentifier = eventIdentifier
        self.status = status
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EventStatusItem)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EventStatusItem.subclass:
            return EventStatusItem.subclass(*args_, **kwargs_)
        else:
            return EventStatusItem(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_eventIdentifier(self): return self.eventIdentifier
    def set_eventIdentifier(self, eventIdentifier): self.eventIdentifier = eventIdentifier
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def hasContent_(self):
        if (
            self.eventIdentifier is not None or
            self.status is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EventStatusItem', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EventStatusItem')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EventStatusItem', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EventStatusItem'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EventStatusItem', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.eventIdentifier is not None:
            self.eventIdentifier.export(outfile, level, namespace_, name_='eventIdentifier', pretty_print=pretty_print)
        if self.status is not None:
            self.status.export(outfile, level, namespace_, name_='status', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'eventIdentifier':
            obj_ = EventIdentifier.factory()
            obj_.build(child_)
            self.eventIdentifier = obj_
            obj_.original_tagname_ = 'eventIdentifier'
        elif nodeName_ == 'status':
            obj_ = EventStatus.factory()
            obj_.build(child_)
            self.status = obj_
            obj_.original_tagname_ = 'status'
# end class EventStatusItem


class MessageAddress(GeneratedsSuper):
    """The data type used for identifying a message address."""
    member_data_items_ = {
        'messageAddressScheme': MemberSpec_('messageAddressScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, messageAddressScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.messageAddressScheme = _cast(None, messageAddressScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MessageAddress)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MessageAddress.subclass:
            return MessageAddress.subclass(*args_, **kwargs_)
        else:
            return MessageAddress(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_messageAddressScheme(self): return self.messageAddressScheme
    def set_messageAddressScheme(self, messageAddressScheme): self.messageAddressScheme = messageAddressScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MessageAddress', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MessageAddress')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MessageAddress', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MessageAddress'):
        if self.messageAddressScheme is not None and 'messageAddressScheme' not in already_processed:
            already_processed.add('messageAddressScheme')
            outfile.write(' messageAddressScheme=%s' % (quote_attrib(self.messageAddressScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MessageAddress', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('messageAddressScheme', node)
        if value is not None and 'messageAddressScheme' not in already_processed:
            already_processed.add('messageAddressScheme')
            self.messageAddressScheme = value
            self.validate_NonEmptyURI(self.messageAddressScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MessageAddress


class MessageHeader(GeneratedsSuper):
    """A type defining the content model for a generic message header that
    is refined by its derived classes."""
    member_data_items_ = {
        'messageId': MemberSpec_('messageId', 'MessageId', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, messageId=None, extensiontype_=None):
        self.original_tagname_ = None
        self.messageId = messageId
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MessageHeader)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MessageHeader.subclass:
            return MessageHeader.subclass(*args_, **kwargs_)
        else:
            return MessageHeader(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_messageId(self): return self.messageId
    def set_messageId(self, messageId): self.messageId = messageId
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.messageId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MessageHeader', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MessageHeader')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MessageHeader', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MessageHeader'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MessageHeader', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.messageId is not None:
            self.messageId.export(outfile, level, namespace_, name_='messageId', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'messageId':
            obj_ = MessageId.factory()
            obj_.build(child_)
            self.messageId = obj_
            obj_.original_tagname_ = 'messageId'
# end class MessageHeader


class MessageId(GeneratedsSuper):
    """The data type use for message identifiers."""
    member_data_items_ = {
        'messageIdScheme': MemberSpec_('messageIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, messageIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.messageIdScheme = _cast(None, messageIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MessageId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MessageId.subclass:
            return MessageId.subclass(*args_, **kwargs_)
        else:
            return MessageId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_messageIdScheme(self): return self.messageIdScheme
    def set_messageIdScheme(self, messageIdScheme): self.messageIdScheme = messageIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MessageId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MessageId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MessageId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MessageId'):
        if self.messageIdScheme is not None and 'messageIdScheme' not in already_processed:
            already_processed.add('messageIdScheme')
            outfile.write(' messageIdScheme=%s' % (quote_attrib(self.messageIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MessageId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('messageIdScheme', node)
        if value is not None and 'messageIdScheme' not in already_processed:
            already_processed.add('messageIdScheme')
            self.messageIdScheme = value
            self.validate_NonEmptyURI(self.messageIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MessageId


class NotificationMessageHeader(MessageHeader):
    """A type that refines the generic message header to match the
    requirements of a NotificationMessage."""
    member_data_items_ = {
        'inReplyTo': MemberSpec_('inReplyTo', 'MessageId', 0),
        'sentBy': MemberSpec_('sentBy', 'MessageAddress', 0),
        'sendTo': MemberSpec_('sendTo', 'MessageAddress', 1),
        'copyTo': MemberSpec_('copyTo', 'MessageAddress', 1),
        'creationTimestamp': MemberSpec_('creationTimestamp', 'xsd:dateTime', 0),
        'expiryTimestamp': MemberSpec_('expiryTimestamp', 'xsd:dateTime', 0),
        'implementationSpecification': MemberSpec_('implementationSpecification', 'ImplementationSpecification', 0),
        'partyMessageInformation': MemberSpec_('partyMessageInformation', 'PartyMessageInformation', 1),
        'Signature': MemberSpec_('Signature', 'SignatureType', 1),
    }
    subclass = None
    superclass = MessageHeader
    def __init__(self, messageId=None, inReplyTo=None, sentBy=None, sendTo=None, copyTo=None, creationTimestamp=None, expiryTimestamp=None, implementationSpecification=None, partyMessageInformation=None, Signature=None):
        self.original_tagname_ = None
        super(NotificationMessageHeader, self).__init__(messageId, )
        self.inReplyTo = inReplyTo
        self.sentBy = sentBy
        if sendTo is None:
            self.sendTo = []
        else:
            self.sendTo = sendTo
        if copyTo is None:
            self.copyTo = []
        else:
            self.copyTo = copyTo
        if isinstance(creationTimestamp, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(creationTimestamp, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = creationTimestamp
        self.creationTimestamp = initvalue_
        if isinstance(expiryTimestamp, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(expiryTimestamp, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = expiryTimestamp
        self.expiryTimestamp = initvalue_
        self.implementationSpecification = implementationSpecification
        if partyMessageInformation is None:
            self.partyMessageInformation = []
        else:
            self.partyMessageInformation = partyMessageInformation
        if Signature is None:
            self.Signature = []
        else:
            self.Signature = Signature
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NotificationMessageHeader)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NotificationMessageHeader.subclass:
            return NotificationMessageHeader.subclass(*args_, **kwargs_)
        else:
            return NotificationMessageHeader(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_inReplyTo(self): return self.inReplyTo
    def set_inReplyTo(self, inReplyTo): self.inReplyTo = inReplyTo
    def get_sentBy(self): return self.sentBy
    def set_sentBy(self, sentBy): self.sentBy = sentBy
    def get_sendTo(self): return self.sendTo
    def set_sendTo(self, sendTo): self.sendTo = sendTo
    def add_sendTo(self, value): self.sendTo.append(value)
    def insert_sendTo_at(self, index, value): self.sendTo.insert(index, value)
    def replace_sendTo_at(self, index, value): self.sendTo[index] = value
    def get_copyTo(self): return self.copyTo
    def set_copyTo(self, copyTo): self.copyTo = copyTo
    def add_copyTo(self, value): self.copyTo.append(value)
    def insert_copyTo_at(self, index, value): self.copyTo.insert(index, value)
    def replace_copyTo_at(self, index, value): self.copyTo[index] = value
    def get_creationTimestamp(self): return self.creationTimestamp
    def set_creationTimestamp(self, creationTimestamp): self.creationTimestamp = creationTimestamp
    def get_expiryTimestamp(self): return self.expiryTimestamp
    def set_expiryTimestamp(self, expiryTimestamp): self.expiryTimestamp = expiryTimestamp
    def get_implementationSpecification(self): return self.implementationSpecification
    def set_implementationSpecification(self, implementationSpecification): self.implementationSpecification = implementationSpecification
    def get_partyMessageInformation(self): return self.partyMessageInformation
    def set_partyMessageInformation(self, partyMessageInformation): self.partyMessageInformation = partyMessageInformation
    def add_partyMessageInformation(self, value): self.partyMessageInformation.append(value)
    def insert_partyMessageInformation_at(self, index, value): self.partyMessageInformation.insert(index, value)
    def replace_partyMessageInformation_at(self, index, value): self.partyMessageInformation[index] = value
    def get_Signature(self): return self.Signature
    def set_Signature(self, Signature): self.Signature = Signature
    def add_Signature(self, value): self.Signature.append(value)
    def insert_Signature_at(self, index, value): self.Signature.insert(index, value)
    def replace_Signature_at(self, index, value): self.Signature[index] = value
    def hasContent_(self):
        if (
            self.inReplyTo is not None or
            self.sentBy is not None or
            self.sendTo or
            self.copyTo or
            self.creationTimestamp is not None or
            self.expiryTimestamp is not None or
            self.implementationSpecification is not None or
            self.partyMessageInformation or
            self.Signature or
            super(NotificationMessageHeader, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NotificationMessageHeader', namespacedef_=' xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NotificationMessageHeader')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NotificationMessageHeader', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NotificationMessageHeader'):
        super(NotificationMessageHeader, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NotificationMessageHeader')
    def exportChildren(self, outfile, level, namespace_='', name_='NotificationMessageHeader', fromsubclass_=False, pretty_print=True):
        super(NotificationMessageHeader, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.inReplyTo is not None:
            self.inReplyTo.export(outfile, level, namespace_, name_='inReplyTo', pretty_print=pretty_print)
        if self.sentBy is not None:
            self.sentBy.export(outfile, level, namespace_, name_='sentBy', pretty_print=pretty_print)
        for sendTo_ in self.sendTo:
            sendTo_.export(outfile, level, namespace_, name_='sendTo', pretty_print=pretty_print)
        for copyTo_ in self.copyTo:
            copyTo_.export(outfile, level, namespace_, name_='copyTo', pretty_print=pretty_print)
        if self.creationTimestamp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%screationTimestamp>%s</%screationTimestamp>%s' % (namespace_, self.gds_format_datetime(self.creationTimestamp, input_name='creationTimestamp'), namespace_, eol_))
        if self.expiryTimestamp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexpiryTimestamp>%s</%sexpiryTimestamp>%s' % (namespace_, self.gds_format_datetime(self.expiryTimestamp, input_name='expiryTimestamp'), namespace_, eol_))
        if self.implementationSpecification is not None:
            self.implementationSpecification.export(outfile, level, namespace_, name_='implementationSpecification', pretty_print=pretty_print)
        for partyMessageInformation_ in self.partyMessageInformation:
            partyMessageInformation_.export(outfile, level, namespace_, name_='partyMessageInformation', pretty_print=pretty_print)
        for Signature_ in self.Signature:
            Signature_.export(outfile, level, namespace_='dsig:', name_='Signature', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NotificationMessageHeader, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'inReplyTo':
            obj_ = MessageId.factory()
            obj_.build(child_)
            self.inReplyTo = obj_
            obj_.original_tagname_ = 'inReplyTo'
        elif nodeName_ == 'sentBy':
            obj_ = MessageAddress.factory()
            obj_.build(child_)
            self.sentBy = obj_
            obj_.original_tagname_ = 'sentBy'
        elif nodeName_ == 'sendTo':
            obj_ = MessageAddress.factory()
            obj_.build(child_)
            self.sendTo.append(obj_)
            obj_.original_tagname_ = 'sendTo'
        elif nodeName_ == 'copyTo':
            obj_ = MessageAddress.factory()
            obj_.build(child_)
            self.copyTo.append(obj_)
            obj_.original_tagname_ = 'copyTo'
        elif nodeName_ == 'creationTimestamp':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.creationTimestamp = dval_
        elif nodeName_ == 'expiryTimestamp':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.expiryTimestamp = dval_
        elif nodeName_ == 'implementationSpecification':
            obj_ = ImplementationSpecification.factory()
            obj_.build(child_)
            self.implementationSpecification = obj_
            obj_.original_tagname_ = 'implementationSpecification'
        elif nodeName_ == 'partyMessageInformation':
            obj_ = PartyMessageInformation.factory()
            obj_.build(child_)
            self.partyMessageInformation.append(obj_)
            obj_.original_tagname_ = 'partyMessageInformation'
        elif nodeName_ == 'Signature':
            obj_ = SignatureType.factory()
            obj_.build(child_)
            self.Signature.append(obj_)
            obj_.original_tagname_ = 'Signature'
        super(NotificationMessageHeader, self).buildChildren(child_, node, nodeName_, True)
# end class NotificationMessageHeader


class ImplementationSpecification(GeneratedsSuper):
    """A version of a specification document used by the message generator
    to format the document."""
    member_data_items_ = {
        'name': MemberSpec_('name', ['NormalizedString', 'xsd:normalizedString'], 0),
        'version': MemberSpec_('version', 'ImplementationSpecificationVersion', 0),
        'date': MemberSpec_('date', 'xsd:date', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, name=None, version=None, date=None):
        self.original_tagname_ = None
        self.name = name
        self.validate_NormalizedString(self.name)
        self.version = version
        if isinstance(date, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(date, '%Y-%m-%d').date()
        else:
            initvalue_ = date
        self.date = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ImplementationSpecification)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ImplementationSpecification.subclass:
            return ImplementationSpecification.subclass(*args_, **kwargs_)
        else:
            return ImplementationSpecification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_date(self): return self.date
    def set_date(self, date): self.date = date
    def validate_NormalizedString(self, value):
        # Validate type NormalizedString, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NormalizedString' % {"value" : value} )
    def hasContent_(self):
        if (
            self.name is not None or
            self.version is not None or
            self.date is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ImplementationSpecification', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ImplementationSpecification')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ImplementationSpecification', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ImplementationSpecification'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ImplementationSpecification', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespace_, eol_))
        if self.version is not None:
            self.version.export(outfile, level, namespace_, name_='version', pretty_print=pretty_print)
        if self.date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdate>%s</%sdate>%s' % (namespace_, self.gds_format_date(self.date, input_name='date'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
            # validate type NormalizedString
            self.validate_NormalizedString(self.name)
        elif nodeName_ == 'version':
            obj_ = ImplementationSpecificationVersion.factory()
            obj_.build(child_)
            self.version = obj_
            obj_.original_tagname_ = 'version'
        elif nodeName_ == 'date':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.date = dval_
# end class ImplementationSpecification


class ImplementationSpecificationVersion(GeneratedsSuper):
    member_data_items_ = {
        'implementationSpecificationVersionScheme': MemberSpec_('implementationSpecificationVersionScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, implementationSpecificationVersionScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.implementationSpecificationVersionScheme = _cast(None, implementationSpecificationVersionScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ImplementationSpecificationVersion)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ImplementationSpecificationVersion.subclass:
            return ImplementationSpecificationVersion.subclass(*args_, **kwargs_)
        else:
            return ImplementationSpecificationVersion(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_implementationSpecificationVersionScheme(self): return self.implementationSpecificationVersionScheme
    def set_implementationSpecificationVersionScheme(self, implementationSpecificationVersionScheme): self.implementationSpecificationVersionScheme = implementationSpecificationVersionScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ImplementationSpecificationVersion', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ImplementationSpecificationVersion')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ImplementationSpecificationVersion', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ImplementationSpecificationVersion'):
        if self.implementationSpecificationVersionScheme is not None and 'implementationSpecificationVersionScheme' not in already_processed:
            already_processed.add('implementationSpecificationVersionScheme')
            outfile.write(' implementationSpecificationVersionScheme=%s' % (quote_attrib(self.implementationSpecificationVersionScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ImplementationSpecificationVersion', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('implementationSpecificationVersionScheme', node)
        if value is not None and 'implementationSpecificationVersionScheme' not in already_processed:
            already_processed.add('implementationSpecificationVersionScheme')
            self.implementationSpecificationVersionScheme = value
            self.validate_NonEmptyURI(self.implementationSpecificationVersionScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ImplementationSpecificationVersion


class PartyMessageInformation(GeneratedsSuper):
    """A type defining additional information that may be recorded against
    a message."""
    member_data_items_ = {
        'partyReference': MemberSpec_('partyReference', 'PartyReference', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, partyReference=None):
        self.original_tagname_ = None
        self.partyReference = partyReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyMessageInformation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyMessageInformation.subclass:
            return PartyMessageInformation.subclass(*args_, **kwargs_)
        else:
            return PartyMessageInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyReference(self): return self.partyReference
    def set_partyReference(self, partyReference): self.partyReference = partyReference
    def hasContent_(self):
        if (
            self.partyReference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartyMessageInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyMessageInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartyMessageInformation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyMessageInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PartyMessageInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.partyReference is not None:
            self.partyReference.export(outfile, level, namespace_, name_='partyReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'partyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.partyReference = obj_
            obj_.original_tagname_ = 'partyReference'
# end class PartyMessageInformation


class PortfolioReferenceBase(GeneratedsSuper):
    """A structure used to identify a portfolio in a message."""
    member_data_items_ = {
        'portfolioName': MemberSpec_('portfolioName', 'PortfolioName', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, portfolioName=None, extensiontype_=None):
        self.original_tagname_ = None
        self.portfolioName = portfolioName
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PortfolioReferenceBase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PortfolioReferenceBase.subclass:
            return PortfolioReferenceBase.subclass(*args_, **kwargs_)
        else:
            return PortfolioReferenceBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_portfolioName(self): return self.portfolioName
    def set_portfolioName(self, portfolioName): self.portfolioName = portfolioName
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.portfolioName is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PortfolioReferenceBase', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PortfolioReferenceBase')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PortfolioReferenceBase', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PortfolioReferenceBase'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PortfolioReferenceBase', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.portfolioName is not None:
            self.portfolioName.export(outfile, level, namespace_, name_='portfolioName', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'portfolioName':
            obj_ = PortfolioName.factory()
            obj_.build(child_)
            self.portfolioName = obj_
            obj_.original_tagname_ = 'portfolioName'
# end class PortfolioReferenceBase


class ProblemLocation(GeneratedsSuper):
    """Provides a lexical location (i.e. a line number and character for
    bad XML) or an XPath location (i.e. place to identify the bad
    location for valid XML).The value of the locationType attribute
    defines which type of location has been given. It may take the
    values 'lexical' or 'xpath'."""
    member_data_items_ = {
        'locationType': MemberSpec_('locationType', 'Token', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, locationType=None, valueOf_=None):
        self.original_tagname_ = None
        self.locationType = _cast(None, locationType)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProblemLocation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProblemLocation.subclass:
            return ProblemLocation.subclass(*args_, **kwargs_)
        else:
            return ProblemLocation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_locationType(self): return self.locationType
    def set_locationType(self, locationType): self.locationType = locationType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_Token(self, value):
        # Validate type Token, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Token' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ProblemLocation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProblemLocation')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ProblemLocation', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProblemLocation'):
        if self.locationType is not None and 'locationType' not in already_processed:
            already_processed.add('locationType')
            outfile.write(' locationType=%s' % (quote_attrib(self.locationType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ProblemLocation', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('locationType', node)
        if value is not None and 'locationType' not in already_processed:
            already_processed.add('locationType')
            self.locationType = value
            self.locationType = ' '.join(self.locationType.split())
            self.validate_Token(self.locationType)    # validate type Token
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ProblemLocation


class Reason(GeneratedsSuper):
    """A type defining a content model for describing the nature and
    possible location of a error within a previous message."""
    member_data_items_ = {
        'reasonCode': MemberSpec_('reasonCode', 'ReasonCode', 0),
        'location': MemberSpec_('location', 'ProblemLocation', 0),
        'description': MemberSpec_('description', ['String', 'xsd:string'], 0),
        'validationRuleId': MemberSpec_('validationRuleId', 'Validation', 0),
        'additionalData': MemberSpec_('additionalData', 'AdditionalData', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, reasonCode=None, location=None, description=None, validationRuleId=None, additionalData=None):
        self.original_tagname_ = None
        self.reasonCode = reasonCode
        self.location = location
        self.description = description
        self.validate_String(self.description)
        self.validationRuleId = validationRuleId
        if additionalData is None:
            self.additionalData = []
        else:
            self.additionalData = additionalData
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Reason)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Reason.subclass:
            return Reason.subclass(*args_, **kwargs_)
        else:
            return Reason(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_reasonCode(self): return self.reasonCode
    def set_reasonCode(self, reasonCode): self.reasonCode = reasonCode
    def get_location(self): return self.location
    def set_location(self, location): self.location = location
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_validationRuleId(self): return self.validationRuleId
    def set_validationRuleId(self, validationRuleId): self.validationRuleId = validationRuleId
    def get_additionalData(self): return self.additionalData
    def set_additionalData(self, additionalData): self.additionalData = additionalData
    def add_additionalData(self, value): self.additionalData.append(value)
    def insert_additionalData_at(self, index, value): self.additionalData.insert(index, value)
    def replace_additionalData_at(self, index, value): self.additionalData[index] = value
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.reasonCode is not None or
            self.location is not None or
            self.description is not None or
            self.validationRuleId is not None or
            self.additionalData
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Reason', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Reason')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Reason', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Reason'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Reason', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.reasonCode is not None:
            self.reasonCode.export(outfile, level, namespace_, name_='reasonCode', pretty_print=pretty_print)
        if self.location is not None:
            self.location.export(outfile, level, namespace_, name_='location', pretty_print=pretty_print)
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespace_, eol_))
        if self.validationRuleId is not None:
            self.validationRuleId.export(outfile, level, namespace_, name_='validationRuleId', pretty_print=pretty_print)
        for additionalData_ in self.additionalData:
            additionalData_.export(outfile, level, namespace_, name_='additionalData', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'reasonCode':
            obj_ = ReasonCode.factory()
            obj_.build(child_)
            self.reasonCode = obj_
            obj_.original_tagname_ = 'reasonCode'
        elif nodeName_ == 'location':
            obj_ = ProblemLocation.factory()
            obj_.build(child_)
            self.location = obj_
            obj_.original_tagname_ = 'location'
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
            # validate type String
            self.validate_String(self.description)
        elif nodeName_ == 'validationRuleId':
            obj_ = Validation.factory()
            obj_.build(child_)
            self.validationRuleId = obj_
            obj_.original_tagname_ = 'validationRuleId'
        elif nodeName_ == 'additionalData':
            obj_ = AdditionalData.factory()
            obj_.build(child_)
            self.additionalData.append(obj_)
            obj_.original_tagname_ = 'additionalData'
# end class Reason


class ReasonCode(GeneratedsSuper):
    """Defines a list of machine interpretable error codes."""
    member_data_items_ = {
        'reasonCodeScheme': MemberSpec_('reasonCodeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, reasonCodeScheme='http://www.fpml.org/coding-scheme/reason-code', valueOf_=None):
        self.original_tagname_ = None
        self.reasonCodeScheme = _cast(None, reasonCodeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReasonCode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReasonCode.subclass:
            return ReasonCode.subclass(*args_, **kwargs_)
        else:
            return ReasonCode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_reasonCodeScheme(self): return self.reasonCodeScheme
    def set_reasonCodeScheme(self, reasonCodeScheme): self.reasonCodeScheme = reasonCodeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReasonCode', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReasonCode')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReasonCode', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReasonCode'):
        if self.reasonCodeScheme != "http://www.fpml.org/coding-scheme/reason-code" and 'reasonCodeScheme' not in already_processed:
            already_processed.add('reasonCodeScheme')
            outfile.write(' reasonCodeScheme=%s' % (quote_attrib(self.reasonCodeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ReasonCode', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('reasonCodeScheme', node)
        if value is not None and 'reasonCodeScheme' not in already_processed:
            already_processed.add('reasonCodeScheme')
            self.reasonCodeScheme = value
            self.validate_NonEmptyURI(self.reasonCodeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReasonCode


class RequestMessageHeader(MessageHeader):
    """A type refining the generic message header content to make it
    specific to request messages."""
    member_data_items_ = {
        'sentBy': MemberSpec_('sentBy', 'MessageAddress', 0),
        'sendTo': MemberSpec_('sendTo', 'MessageAddress', 1),
        'copyTo': MemberSpec_('copyTo', 'MessageAddress', 1),
        'creationTimestamp': MemberSpec_('creationTimestamp', 'xsd:dateTime', 0),
        'expiryTimestamp': MemberSpec_('expiryTimestamp', 'xsd:dateTime', 0),
        'implementationSpecification': MemberSpec_('implementationSpecification', 'ImplementationSpecification', 0),
        'partyMessageInformation': MemberSpec_('partyMessageInformation', 'PartyMessageInformation', 1),
        'Signature': MemberSpec_('Signature', 'SignatureType', 1),
    }
    subclass = None
    superclass = MessageHeader
    def __init__(self, messageId=None, sentBy=None, sendTo=None, copyTo=None, creationTimestamp=None, expiryTimestamp=None, implementationSpecification=None, partyMessageInformation=None, Signature=None):
        self.original_tagname_ = None
        super(RequestMessageHeader, self).__init__(messageId, )
        self.sentBy = sentBy
        if sendTo is None:
            self.sendTo = []
        else:
            self.sendTo = sendTo
        if copyTo is None:
            self.copyTo = []
        else:
            self.copyTo = copyTo
        if isinstance(creationTimestamp, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(creationTimestamp, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = creationTimestamp
        self.creationTimestamp = initvalue_
        if isinstance(expiryTimestamp, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(expiryTimestamp, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = expiryTimestamp
        self.expiryTimestamp = initvalue_
        self.implementationSpecification = implementationSpecification
        if partyMessageInformation is None:
            self.partyMessageInformation = []
        else:
            self.partyMessageInformation = partyMessageInformation
        if Signature is None:
            self.Signature = []
        else:
            self.Signature = Signature
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RequestMessageHeader)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RequestMessageHeader.subclass:
            return RequestMessageHeader.subclass(*args_, **kwargs_)
        else:
            return RequestMessageHeader(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sentBy(self): return self.sentBy
    def set_sentBy(self, sentBy): self.sentBy = sentBy
    def get_sendTo(self): return self.sendTo
    def set_sendTo(self, sendTo): self.sendTo = sendTo
    def add_sendTo(self, value): self.sendTo.append(value)
    def insert_sendTo_at(self, index, value): self.sendTo.insert(index, value)
    def replace_sendTo_at(self, index, value): self.sendTo[index] = value
    def get_copyTo(self): return self.copyTo
    def set_copyTo(self, copyTo): self.copyTo = copyTo
    def add_copyTo(self, value): self.copyTo.append(value)
    def insert_copyTo_at(self, index, value): self.copyTo.insert(index, value)
    def replace_copyTo_at(self, index, value): self.copyTo[index] = value
    def get_creationTimestamp(self): return self.creationTimestamp
    def set_creationTimestamp(self, creationTimestamp): self.creationTimestamp = creationTimestamp
    def get_expiryTimestamp(self): return self.expiryTimestamp
    def set_expiryTimestamp(self, expiryTimestamp): self.expiryTimestamp = expiryTimestamp
    def get_implementationSpecification(self): return self.implementationSpecification
    def set_implementationSpecification(self, implementationSpecification): self.implementationSpecification = implementationSpecification
    def get_partyMessageInformation(self): return self.partyMessageInformation
    def set_partyMessageInformation(self, partyMessageInformation): self.partyMessageInformation = partyMessageInformation
    def add_partyMessageInformation(self, value): self.partyMessageInformation.append(value)
    def insert_partyMessageInformation_at(self, index, value): self.partyMessageInformation.insert(index, value)
    def replace_partyMessageInformation_at(self, index, value): self.partyMessageInformation[index] = value
    def get_Signature(self): return self.Signature
    def set_Signature(self, Signature): self.Signature = Signature
    def add_Signature(self, value): self.Signature.append(value)
    def insert_Signature_at(self, index, value): self.Signature.insert(index, value)
    def replace_Signature_at(self, index, value): self.Signature[index] = value
    def hasContent_(self):
        if (
            self.sentBy is not None or
            self.sendTo or
            self.copyTo or
            self.creationTimestamp is not None or
            self.expiryTimestamp is not None or
            self.implementationSpecification is not None or
            self.partyMessageInformation or
            self.Signature or
            super(RequestMessageHeader, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RequestMessageHeader', namespacedef_=' xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RequestMessageHeader')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RequestMessageHeader', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RequestMessageHeader'):
        super(RequestMessageHeader, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RequestMessageHeader')
    def exportChildren(self, outfile, level, namespace_='', name_='RequestMessageHeader', fromsubclass_=False, pretty_print=True):
        super(RequestMessageHeader, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.sentBy is not None:
            self.sentBy.export(outfile, level, namespace_, name_='sentBy', pretty_print=pretty_print)
        for sendTo_ in self.sendTo:
            sendTo_.export(outfile, level, namespace_, name_='sendTo', pretty_print=pretty_print)
        for copyTo_ in self.copyTo:
            copyTo_.export(outfile, level, namespace_, name_='copyTo', pretty_print=pretty_print)
        if self.creationTimestamp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%screationTimestamp>%s</%screationTimestamp>%s' % (namespace_, self.gds_format_datetime(self.creationTimestamp, input_name='creationTimestamp'), namespace_, eol_))
        if self.expiryTimestamp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexpiryTimestamp>%s</%sexpiryTimestamp>%s' % (namespace_, self.gds_format_datetime(self.expiryTimestamp, input_name='expiryTimestamp'), namespace_, eol_))
        if self.implementationSpecification is not None:
            self.implementationSpecification.export(outfile, level, namespace_, name_='implementationSpecification', pretty_print=pretty_print)
        for partyMessageInformation_ in self.partyMessageInformation:
            partyMessageInformation_.export(outfile, level, namespace_, name_='partyMessageInformation', pretty_print=pretty_print)
        for Signature_ in self.Signature:
            Signature_.export(outfile, level, namespace_='dsig:', name_='Signature', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RequestMessageHeader, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'sentBy':
            obj_ = MessageAddress.factory()
            obj_.build(child_)
            self.sentBy = obj_
            obj_.original_tagname_ = 'sentBy'
        elif nodeName_ == 'sendTo':
            obj_ = MessageAddress.factory()
            obj_.build(child_)
            self.sendTo.append(obj_)
            obj_.original_tagname_ = 'sendTo'
        elif nodeName_ == 'copyTo':
            obj_ = MessageAddress.factory()
            obj_.build(child_)
            self.copyTo.append(obj_)
            obj_.original_tagname_ = 'copyTo'
        elif nodeName_ == 'creationTimestamp':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.creationTimestamp = dval_
        elif nodeName_ == 'expiryTimestamp':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.expiryTimestamp = dval_
        elif nodeName_ == 'implementationSpecification':
            obj_ = ImplementationSpecification.factory()
            obj_.build(child_)
            self.implementationSpecification = obj_
            obj_.original_tagname_ = 'implementationSpecification'
        elif nodeName_ == 'partyMessageInformation':
            obj_ = PartyMessageInformation.factory()
            obj_.build(child_)
            self.partyMessageInformation.append(obj_)
            obj_.original_tagname_ = 'partyMessageInformation'
        elif nodeName_ == 'Signature':
            obj_ = SignatureType.factory()
            obj_.build(child_)
            self.Signature.append(obj_)
            obj_.original_tagname_ = 'Signature'
        super(RequestMessageHeader, self).buildChildren(child_, node, nodeName_, True)
# end class RequestMessageHeader


class ReportId(GeneratedsSuper):
    """A type that can be used to hold an identifier for a report instance."""
    member_data_items_ = {
        'reportIdScheme': MemberSpec_('reportIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, reportIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.reportIdScheme = _cast(None, reportIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReportId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReportId.subclass:
            return ReportId.subclass(*args_, **kwargs_)
        else:
            return ReportId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_reportIdScheme(self): return self.reportIdScheme
    def set_reportIdScheme(self, reportIdScheme): self.reportIdScheme = reportIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReportId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReportId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReportId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReportId'):
        if self.reportIdScheme is not None and 'reportIdScheme' not in already_processed:
            already_processed.add('reportIdScheme')
            outfile.write(' reportIdScheme=%s' % (quote_attrib(self.reportIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ReportId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('reportIdScheme', node)
        if value is not None and 'reportIdScheme' not in already_processed:
            already_processed.add('reportIdScheme')
            self.reportIdScheme = value
            self.validate_NonEmptyURI(self.reportIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReportId


class ReportSectionIdentification(GeneratedsSuper):
    """A type that allows the specific report and section to be identified."""
    member_data_items_ = {
        'reportId': MemberSpec_('reportId', 'ReportId', 0),
        'sectionNumber': MemberSpec_('sectionNumber', 'xsd:positiveInteger', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, reportId=None, sectionNumber=None, extensiontype_=None):
        self.original_tagname_ = None
        self.reportId = reportId
        self.sectionNumber = sectionNumber
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReportSectionIdentification)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReportSectionIdentification.subclass:
            return ReportSectionIdentification.subclass(*args_, **kwargs_)
        else:
            return ReportSectionIdentification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_reportId(self): return self.reportId
    def set_reportId(self, reportId): self.reportId = reportId
    def get_sectionNumber(self): return self.sectionNumber
    def set_sectionNumber(self, sectionNumber): self.sectionNumber = sectionNumber
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.reportId is not None or
            self.sectionNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReportSectionIdentification', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReportSectionIdentification')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReportSectionIdentification', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReportSectionIdentification'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ReportSectionIdentification', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.reportId is not None:
            self.reportId.export(outfile, level, namespace_, name_='reportId', pretty_print=pretty_print)
        if self.sectionNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssectionNumber>%s</%ssectionNumber>%s' % (namespace_, self.gds_format_integer(self.sectionNumber, input_name='sectionNumber'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'reportId':
            obj_ = ReportId.factory()
            obj_.build(child_)
            self.reportId = obj_
            obj_.original_tagname_ = 'reportId'
        elif nodeName_ == 'sectionNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'sectionNumber')
            self.sectionNumber = ival_
# end class ReportSectionIdentification


class ResponseMessageHeader(MessageHeader):
    """A type refining the generic message header to make it specific to
    response messages."""
    member_data_items_ = {
        'inReplyTo': MemberSpec_('inReplyTo', 'MessageId', 0),
        'sentBy': MemberSpec_('sentBy', 'MessageAddress', 0),
        'sendTo': MemberSpec_('sendTo', 'MessageAddress', 1),
        'copyTo': MemberSpec_('copyTo', 'MessageAddress', 1),
        'creationTimestamp': MemberSpec_('creationTimestamp', 'xsd:dateTime', 0),
        'expiryTimestamp': MemberSpec_('expiryTimestamp', 'xsd:dateTime', 0),
        'implementationSpecification': MemberSpec_('implementationSpecification', 'ImplementationSpecification', 0),
        'partyMessageInformation': MemberSpec_('partyMessageInformation', 'PartyMessageInformation', 1),
        'Signature': MemberSpec_('Signature', 'SignatureType', 1),
    }
    subclass = None
    superclass = MessageHeader
    def __init__(self, messageId=None, inReplyTo=None, sentBy=None, sendTo=None, copyTo=None, creationTimestamp=None, expiryTimestamp=None, implementationSpecification=None, partyMessageInformation=None, Signature=None):
        self.original_tagname_ = None
        super(ResponseMessageHeader, self).__init__(messageId, )
        self.inReplyTo = inReplyTo
        self.sentBy = sentBy
        if sendTo is None:
            self.sendTo = []
        else:
            self.sendTo = sendTo
        if copyTo is None:
            self.copyTo = []
        else:
            self.copyTo = copyTo
        if isinstance(creationTimestamp, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(creationTimestamp, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = creationTimestamp
        self.creationTimestamp = initvalue_
        if isinstance(expiryTimestamp, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(expiryTimestamp, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = expiryTimestamp
        self.expiryTimestamp = initvalue_
        self.implementationSpecification = implementationSpecification
        if partyMessageInformation is None:
            self.partyMessageInformation = []
        else:
            self.partyMessageInformation = partyMessageInformation
        if Signature is None:
            self.Signature = []
        else:
            self.Signature = Signature
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResponseMessageHeader)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResponseMessageHeader.subclass:
            return ResponseMessageHeader.subclass(*args_, **kwargs_)
        else:
            return ResponseMessageHeader(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_inReplyTo(self): return self.inReplyTo
    def set_inReplyTo(self, inReplyTo): self.inReplyTo = inReplyTo
    def get_sentBy(self): return self.sentBy
    def set_sentBy(self, sentBy): self.sentBy = sentBy
    def get_sendTo(self): return self.sendTo
    def set_sendTo(self, sendTo): self.sendTo = sendTo
    def add_sendTo(self, value): self.sendTo.append(value)
    def insert_sendTo_at(self, index, value): self.sendTo.insert(index, value)
    def replace_sendTo_at(self, index, value): self.sendTo[index] = value
    def get_copyTo(self): return self.copyTo
    def set_copyTo(self, copyTo): self.copyTo = copyTo
    def add_copyTo(self, value): self.copyTo.append(value)
    def insert_copyTo_at(self, index, value): self.copyTo.insert(index, value)
    def replace_copyTo_at(self, index, value): self.copyTo[index] = value
    def get_creationTimestamp(self): return self.creationTimestamp
    def set_creationTimestamp(self, creationTimestamp): self.creationTimestamp = creationTimestamp
    def get_expiryTimestamp(self): return self.expiryTimestamp
    def set_expiryTimestamp(self, expiryTimestamp): self.expiryTimestamp = expiryTimestamp
    def get_implementationSpecification(self): return self.implementationSpecification
    def set_implementationSpecification(self, implementationSpecification): self.implementationSpecification = implementationSpecification
    def get_partyMessageInformation(self): return self.partyMessageInformation
    def set_partyMessageInformation(self, partyMessageInformation): self.partyMessageInformation = partyMessageInformation
    def add_partyMessageInformation(self, value): self.partyMessageInformation.append(value)
    def insert_partyMessageInformation_at(self, index, value): self.partyMessageInformation.insert(index, value)
    def replace_partyMessageInformation_at(self, index, value): self.partyMessageInformation[index] = value
    def get_Signature(self): return self.Signature
    def set_Signature(self, Signature): self.Signature = Signature
    def add_Signature(self, value): self.Signature.append(value)
    def insert_Signature_at(self, index, value): self.Signature.insert(index, value)
    def replace_Signature_at(self, index, value): self.Signature[index] = value
    def hasContent_(self):
        if (
            self.inReplyTo is not None or
            self.sentBy is not None or
            self.sendTo or
            self.copyTo or
            self.creationTimestamp is not None or
            self.expiryTimestamp is not None or
            self.implementationSpecification is not None or
            self.partyMessageInformation or
            self.Signature or
            super(ResponseMessageHeader, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ResponseMessageHeader', namespacedef_=' xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResponseMessageHeader')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ResponseMessageHeader', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ResponseMessageHeader'):
        super(ResponseMessageHeader, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ResponseMessageHeader')
    def exportChildren(self, outfile, level, namespace_='', name_='ResponseMessageHeader', fromsubclass_=False, pretty_print=True):
        super(ResponseMessageHeader, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.inReplyTo is not None:
            self.inReplyTo.export(outfile, level, namespace_, name_='inReplyTo', pretty_print=pretty_print)
        if self.sentBy is not None:
            self.sentBy.export(outfile, level, namespace_, name_='sentBy', pretty_print=pretty_print)
        for sendTo_ in self.sendTo:
            sendTo_.export(outfile, level, namespace_, name_='sendTo', pretty_print=pretty_print)
        for copyTo_ in self.copyTo:
            copyTo_.export(outfile, level, namespace_, name_='copyTo', pretty_print=pretty_print)
        if self.creationTimestamp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%screationTimestamp>%s</%screationTimestamp>%s' % (namespace_, self.gds_format_datetime(self.creationTimestamp, input_name='creationTimestamp'), namespace_, eol_))
        if self.expiryTimestamp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexpiryTimestamp>%s</%sexpiryTimestamp>%s' % (namespace_, self.gds_format_datetime(self.expiryTimestamp, input_name='expiryTimestamp'), namespace_, eol_))
        if self.implementationSpecification is not None:
            self.implementationSpecification.export(outfile, level, namespace_, name_='implementationSpecification', pretty_print=pretty_print)
        for partyMessageInformation_ in self.partyMessageInformation:
            partyMessageInformation_.export(outfile, level, namespace_, name_='partyMessageInformation', pretty_print=pretty_print)
        for Signature_ in self.Signature:
            Signature_.export(outfile, level, namespace_='dsig:', name_='Signature', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ResponseMessageHeader, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'inReplyTo':
            obj_ = MessageId.factory()
            obj_.build(child_)
            self.inReplyTo = obj_
            obj_.original_tagname_ = 'inReplyTo'
        elif nodeName_ == 'sentBy':
            obj_ = MessageAddress.factory()
            obj_.build(child_)
            self.sentBy = obj_
            obj_.original_tagname_ = 'sentBy'
        elif nodeName_ == 'sendTo':
            obj_ = MessageAddress.factory()
            obj_.build(child_)
            self.sendTo.append(obj_)
            obj_.original_tagname_ = 'sendTo'
        elif nodeName_ == 'copyTo':
            obj_ = MessageAddress.factory()
            obj_.build(child_)
            self.copyTo.append(obj_)
            obj_.original_tagname_ = 'copyTo'
        elif nodeName_ == 'creationTimestamp':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.creationTimestamp = dval_
        elif nodeName_ == 'expiryTimestamp':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.expiryTimestamp = dval_
        elif nodeName_ == 'implementationSpecification':
            obj_ = ImplementationSpecification.factory()
            obj_.build(child_)
            self.implementationSpecification = obj_
            obj_.original_tagname_ = 'implementationSpecification'
        elif nodeName_ == 'partyMessageInformation':
            obj_ = PartyMessageInformation.factory()
            obj_.build(child_)
            self.partyMessageInformation.append(obj_)
            obj_.original_tagname_ = 'partyMessageInformation'
        elif nodeName_ == 'Signature':
            obj_ = SignatureType.factory()
            obj_.build(child_)
            self.Signature.append(obj_)
            obj_.original_tagname_ = 'Signature'
        super(ResponseMessageHeader, self).buildChildren(child_, node, nodeName_, True)
# end class ResponseMessageHeader


class ServiceAdvisory(GeneratedsSuper):
    """A type defining the content model for a human-readable notification
    to the users of a service."""
    member_data_items_ = {
        'category': MemberSpec_('category', 'ServiceAdvisoryCategory', 0),
        'description': MemberSpec_('description', ['String', 'xsd:string'], 0),
        'effectiveFrom': MemberSpec_('effectiveFrom', 'xsd:dateTime', 0),
        'effectiveTo': MemberSpec_('effectiveTo', 'xsd:dateTime', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, category=None, description=None, effectiveFrom=None, effectiveTo=None):
        self.original_tagname_ = None
        self.category = category
        self.description = description
        self.validate_String(self.description)
        if isinstance(effectiveFrom, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(effectiveFrom, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = effectiveFrom
        self.effectiveFrom = initvalue_
        if isinstance(effectiveTo, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(effectiveTo, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = effectiveTo
        self.effectiveTo = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceAdvisory)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceAdvisory.subclass:
            return ServiceAdvisory.subclass(*args_, **kwargs_)
        else:
            return ServiceAdvisory(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_category(self): return self.category
    def set_category(self, category): self.category = category
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_effectiveFrom(self): return self.effectiveFrom
    def set_effectiveFrom(self, effectiveFrom): self.effectiveFrom = effectiveFrom
    def get_effectiveTo(self): return self.effectiveTo
    def set_effectiveTo(self, effectiveTo): self.effectiveTo = effectiveTo
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.category is not None or
            self.description is not None or
            self.effectiveFrom is not None or
            self.effectiveTo is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ServiceAdvisory', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceAdvisory')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ServiceAdvisory', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ServiceAdvisory'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ServiceAdvisory', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.category is not None:
            self.category.export(outfile, level, namespace_, name_='category', pretty_print=pretty_print)
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespace_, eol_))
        if self.effectiveFrom is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%seffectiveFrom>%s</%seffectiveFrom>%s' % (namespace_, self.gds_format_datetime(self.effectiveFrom, input_name='effectiveFrom'), namespace_, eol_))
        if self.effectiveTo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%seffectiveTo>%s</%seffectiveTo>%s' % (namespace_, self.gds_format_datetime(self.effectiveTo, input_name='effectiveTo'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'category':
            obj_ = ServiceAdvisoryCategory.factory()
            obj_.build(child_)
            self.category = obj_
            obj_.original_tagname_ = 'category'
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
            # validate type String
            self.validate_String(self.description)
        elif nodeName_ == 'effectiveFrom':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.effectiveFrom = dval_
        elif nodeName_ == 'effectiveTo':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.effectiveTo = dval_
# end class ServiceAdvisory


class ServiceAdvisoryCategory(GeneratedsSuper):
    """A type that can be used to describe the category of an advisory
    message, e.g.. Availability, Rules, Products, etc., etc.."""
    member_data_items_ = {
        'serviceAdvisoryCategoryScheme': MemberSpec_('serviceAdvisoryCategoryScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, serviceAdvisoryCategoryScheme='http://www.fpml.org/coding-scheme/service-advisory-category', valueOf_=None):
        self.original_tagname_ = None
        self.serviceAdvisoryCategoryScheme = _cast(None, serviceAdvisoryCategoryScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceAdvisoryCategory)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceAdvisoryCategory.subclass:
            return ServiceAdvisoryCategory.subclass(*args_, **kwargs_)
        else:
            return ServiceAdvisoryCategory(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_serviceAdvisoryCategoryScheme(self): return self.serviceAdvisoryCategoryScheme
    def set_serviceAdvisoryCategoryScheme(self, serviceAdvisoryCategoryScheme): self.serviceAdvisoryCategoryScheme = serviceAdvisoryCategoryScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ServiceAdvisoryCategory', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceAdvisoryCategory')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ServiceAdvisoryCategory', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ServiceAdvisoryCategory'):
        if self.serviceAdvisoryCategoryScheme != "http://www.fpml.org/coding-scheme/service-advisory-category" and 'serviceAdvisoryCategoryScheme' not in already_processed:
            already_processed.add('serviceAdvisoryCategoryScheme')
            outfile.write(' serviceAdvisoryCategoryScheme=%s' % (quote_attrib(self.serviceAdvisoryCategoryScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ServiceAdvisoryCategory', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('serviceAdvisoryCategoryScheme', node)
        if value is not None and 'serviceAdvisoryCategoryScheme' not in already_processed:
            already_processed.add('serviceAdvisoryCategoryScheme')
            self.serviceAdvisoryCategoryScheme = value
            self.validate_NonEmptyURI(self.serviceAdvisoryCategoryScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ServiceAdvisoryCategory


class ServiceProcessingCycle(GeneratedsSuper):
    """A type that can be used to describe the processing phase of a
    service. For example, EndOfDay, Intraday."""
    member_data_items_ = {
        'serviceProcessingCycleScheme': MemberSpec_('serviceProcessingCycleScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, serviceProcessingCycleScheme='http://www.fpml.org/coding-scheme/service-processing-cycle', valueOf_=None):
        self.original_tagname_ = None
        self.serviceProcessingCycleScheme = _cast(None, serviceProcessingCycleScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceProcessingCycle)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceProcessingCycle.subclass:
            return ServiceProcessingCycle.subclass(*args_, **kwargs_)
        else:
            return ServiceProcessingCycle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_serviceProcessingCycleScheme(self): return self.serviceProcessingCycleScheme
    def set_serviceProcessingCycleScheme(self, serviceProcessingCycleScheme): self.serviceProcessingCycleScheme = serviceProcessingCycleScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ServiceProcessingCycle', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceProcessingCycle')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ServiceProcessingCycle', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ServiceProcessingCycle'):
        if self.serviceProcessingCycleScheme != "http://www.fpml.org/coding-scheme/service-processing-cycle" and 'serviceProcessingCycleScheme' not in already_processed:
            already_processed.add('serviceProcessingCycleScheme')
            outfile.write(' serviceProcessingCycleScheme=%s' % (quote_attrib(self.serviceProcessingCycleScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ServiceProcessingCycle', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('serviceProcessingCycleScheme', node)
        if value is not None and 'serviceProcessingCycleScheme' not in already_processed:
            already_processed.add('serviceProcessingCycleScheme')
            self.serviceProcessingCycleScheme = value
            self.validate_NonEmptyURI(self.serviceProcessingCycleScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ServiceProcessingCycle


class ServiceProcessingEvent(GeneratedsSuper):
    """A type that can be used to describe a stage or step in processing
    provided by a service, for example processing completed."""
    member_data_items_ = {
        'serviceProcessingEventScheme': MemberSpec_('serviceProcessingEventScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, serviceProcessingEventScheme='http://www.fpml.org/coding-scheme/service-processing-event', valueOf_=None):
        self.original_tagname_ = None
        self.serviceProcessingEventScheme = _cast(None, serviceProcessingEventScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceProcessingEvent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceProcessingEvent.subclass:
            return ServiceProcessingEvent.subclass(*args_, **kwargs_)
        else:
            return ServiceProcessingEvent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_serviceProcessingEventScheme(self): return self.serviceProcessingEventScheme
    def set_serviceProcessingEventScheme(self, serviceProcessingEventScheme): self.serviceProcessingEventScheme = serviceProcessingEventScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ServiceProcessingEvent', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceProcessingEvent')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ServiceProcessingEvent', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ServiceProcessingEvent'):
        if self.serviceProcessingEventScheme != "http://www.fpml.org/coding-scheme/service-processing-event" and 'serviceProcessingEventScheme' not in already_processed:
            already_processed.add('serviceProcessingEventScheme')
            outfile.write(' serviceProcessingEventScheme=%s' % (quote_attrib(self.serviceProcessingEventScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ServiceProcessingEvent', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('serviceProcessingEventScheme', node)
        if value is not None and 'serviceProcessingEventScheme' not in already_processed:
            already_processed.add('serviceProcessingEventScheme')
            self.serviceProcessingEventScheme = value
            self.validate_NonEmptyURI(self.serviceProcessingEventScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ServiceProcessingEvent


class ServiceProcessingStatus(GeneratedsSuper):
    """A type defining the content model for report on the status of the
    processing by a service. In the future we may wish to provide
    some kind of scope or other qualification for the event, e.g.
    the currencies, products, or books to which it applies."""
    member_data_items_ = {
        'cycle': MemberSpec_('cycle', 'ServiceProcessingCycle', 0),
        'step': MemberSpec_('step', 'ServiceProcessingStep', 0),
        'event': MemberSpec_('event', 'ServiceProcessingEvent', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, cycle=None, step=None, event=None):
        self.original_tagname_ = None
        self.cycle = cycle
        self.step = step
        self.event = event
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceProcessingStatus)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceProcessingStatus.subclass:
            return ServiceProcessingStatus.subclass(*args_, **kwargs_)
        else:
            return ServiceProcessingStatus(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cycle(self): return self.cycle
    def set_cycle(self, cycle): self.cycle = cycle
    def get_step(self): return self.step
    def set_step(self, step): self.step = step
    def get_event(self): return self.event
    def set_event(self, event): self.event = event
    def hasContent_(self):
        if (
            self.cycle is not None or
            self.step is not None or
            self.event is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ServiceProcessingStatus', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceProcessingStatus')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ServiceProcessingStatus', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ServiceProcessingStatus'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ServiceProcessingStatus', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cycle is not None:
            self.cycle.export(outfile, level, namespace_, name_='cycle', pretty_print=pretty_print)
        if self.step is not None:
            self.step.export(outfile, level, namespace_, name_='step', pretty_print=pretty_print)
        if self.event is not None:
            self.event.export(outfile, level, namespace_, name_='event', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cycle':
            obj_ = ServiceProcessingCycle.factory()
            obj_.build(child_)
            self.cycle = obj_
            obj_.original_tagname_ = 'cycle'
        elif nodeName_ == 'step':
            obj_ = ServiceProcessingStep.factory()
            obj_.build(child_)
            self.step = obj_
            obj_.original_tagname_ = 'step'
        elif nodeName_ == 'event':
            obj_ = ServiceProcessingEvent.factory()
            obj_.build(child_)
            self.event = obj_
            obj_.original_tagname_ = 'event'
# end class ServiceProcessingStatus


class ServiceProcessingStep(GeneratedsSuper):
    """A type that can be used to describe what stage of processing a
    service is in. For example, Netting or Valuation."""
    member_data_items_ = {
        'serviceProcessingStep': MemberSpec_('serviceProcessingStep', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, serviceProcessingStep='http://www.fpml.org/coding-scheme/service-processing-step', valueOf_=None):
        self.original_tagname_ = None
        self.serviceProcessingStep = _cast(None, serviceProcessingStep)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceProcessingStep)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceProcessingStep.subclass:
            return ServiceProcessingStep.subclass(*args_, **kwargs_)
        else:
            return ServiceProcessingStep(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_serviceProcessingStep(self): return self.serviceProcessingStep
    def set_serviceProcessingStep(self, serviceProcessingStep): self.serviceProcessingStep = serviceProcessingStep
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ServiceProcessingStep', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceProcessingStep')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ServiceProcessingStep', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ServiceProcessingStep'):
        if self.serviceProcessingStep != "http://www.fpml.org/coding-scheme/service-processing-step" and 'serviceProcessingStep' not in already_processed:
            already_processed.add('serviceProcessingStep')
            outfile.write(' serviceProcessingStep=%s' % (quote_attrib(self.serviceProcessingStep), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ServiceProcessingStep', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('serviceProcessingStep', node)
        if value is not None and 'serviceProcessingStep' not in already_processed:
            already_processed.add('serviceProcessingStep')
            self.serviceProcessingStep = value
            self.validate_NonEmptyURI(self.serviceProcessingStep)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ServiceProcessingStep


class ServiceStatus(GeneratedsSuper):
    """A type that can be used to describe the availability or other state
    of a service, e.g. Available, Unavaialble."""
    member_data_items_ = {
        'serviceStatusScheme': MemberSpec_('serviceStatusScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, serviceStatusScheme='http://www.fpml.org/coding-scheme/service-status', valueOf_=None):
        self.original_tagname_ = None
        self.serviceStatusScheme = _cast(None, serviceStatusScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceStatus)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceStatus.subclass:
            return ServiceStatus.subclass(*args_, **kwargs_)
        else:
            return ServiceStatus(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_serviceStatusScheme(self): return self.serviceStatusScheme
    def set_serviceStatusScheme(self, serviceStatusScheme): self.serviceStatusScheme = serviceStatusScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ServiceStatus', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceStatus')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ServiceStatus', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ServiceStatus'):
        if self.serviceStatusScheme != "http://www.fpml.org/coding-scheme/service-status" and 'serviceStatusScheme' not in already_processed:
            already_processed.add('serviceStatusScheme')
            outfile.write(' serviceStatusScheme=%s' % (quote_attrib(self.serviceStatusScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ServiceStatus', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('serviceStatusScheme', node)
        if value is not None and 'serviceStatusScheme' not in already_processed:
            already_processed.add('serviceStatusScheme')
            self.serviceStatusScheme = value
            self.validate_NonEmptyURI(self.serviceStatusScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ServiceStatus


class UnprocessedElementWrapper(GeneratedsSuper):
    """A type holding a structure that is unvalidated"""
    member_data_items_ = {
        '': MemberSpec_('', 'xsd:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None):
        self.original_tagname_ = None
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UnprocessedElementWrapper)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UnprocessedElementWrapper.subclass:
            return UnprocessedElementWrapper.subclass(*args_, **kwargs_)
        else:
            return UnprocessedElementWrapper(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def hasContent_(self):
        if (
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='UnprocessedElementWrapper', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UnprocessedElementWrapper')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='UnprocessedElementWrapper', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UnprocessedElementWrapper'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='UnprocessedElementWrapper', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'UnprocessedElementWrapper')
        if obj_ is not None:
            self.set_anytypeobjs_(obj_)
# end class UnprocessedElementWrapper


class VerificationStatus(GeneratedsSuper):
    """The verification status of the position as reported by the sender
    (Verified, Disputed)."""
    member_data_items_ = {
        'verificationStatusScheme': MemberSpec_('verificationStatusScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, verificationStatusScheme='http://www.fpml.org/coding-scheme/verification-status', valueOf_=None):
        self.original_tagname_ = None
        self.verificationStatusScheme = _cast(None, verificationStatusScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VerificationStatus)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VerificationStatus.subclass:
            return VerificationStatus.subclass(*args_, **kwargs_)
        else:
            return VerificationStatus(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_verificationStatusScheme(self): return self.verificationStatusScheme
    def set_verificationStatusScheme(self, verificationStatusScheme): self.verificationStatusScheme = verificationStatusScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VerificationStatus', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VerificationStatus')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VerificationStatus', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VerificationStatus'):
        if self.verificationStatusScheme != "http://www.fpml.org/coding-scheme/verification-status" and 'verificationStatusScheme' not in already_processed:
            already_processed.add('verificationStatusScheme')
            outfile.write(' verificationStatusScheme=%s' % (quote_attrib(self.verificationStatusScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='VerificationStatus', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('verificationStatusScheme', node)
        if value is not None and 'verificationStatusScheme' not in already_processed:
            already_processed.add('verificationStatusScheme')
            self.verificationStatusScheme = value
            self.validate_NonEmptyURI(self.verificationStatusScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VerificationStatus


class Algorithm(GeneratedsSuper):
    member_data_items_ = {
        'name': MemberSpec_('name', 'xsd:token', 0),
        'role': MemberSpec_('role', 'AlgorithmRole', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, name=None, role=None):
        self.original_tagname_ = None
        self.name = name
        self.role = role
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Algorithm)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Algorithm.subclass:
            return Algorithm.subclass(*args_, **kwargs_)
        else:
            return Algorithm(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def hasContent_(self):
        if (
            self.name is not None or
            self.role is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Algorithm', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Algorithm')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Algorithm', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Algorithm'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Algorithm', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespace_, eol_))
        if self.role is not None:
            self.role.export(outfile, level, namespace_, name_='role', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'role':
            obj_ = AlgorithmRole.factory()
            obj_.build(child_)
            self.role = obj_
            obj_.original_tagname_ = 'role'
# end class Algorithm


class AlgorithmRole(GeneratedsSuper):
    """A type describing a role played by an algorithm in one or more
    transactions. Examples include roles such as TradingDecision,
    RoutingDecision. This can be extended to provide custom roles."""
    member_data_items_ = {
        'algorithmRoleScheme': MemberSpec_('algorithmRoleScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, algorithmRoleScheme='http://www.fpml.org/coding-scheme/algorithm-role', valueOf_=None):
        self.original_tagname_ = None
        self.algorithmRoleScheme = _cast(None, algorithmRoleScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AlgorithmRole)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AlgorithmRole.subclass:
            return AlgorithmRole.subclass(*args_, **kwargs_)
        else:
            return AlgorithmRole(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_algorithmRoleScheme(self): return self.algorithmRoleScheme
    def set_algorithmRoleScheme(self, algorithmRoleScheme): self.algorithmRoleScheme = algorithmRoleScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AlgorithmRole', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AlgorithmRole')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AlgorithmRole', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AlgorithmRole'):
        if self.algorithmRoleScheme != "http://www.fpml.org/coding-scheme/algorithm-role" and 'algorithmRoleScheme' not in already_processed:
            already_processed.add('algorithmRoleScheme')
            outfile.write(' algorithmRoleScheme=%s' % (quote_attrib(self.algorithmRoleScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AlgorithmRole', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('algorithmRoleScheme', node)
        if value is not None and 'algorithmRoleScheme' not in already_processed:
            already_processed.add('algorithmRoleScheme')
            self.algorithmRoleScheme = value
            self.validate_NonEmptyURI(self.algorithmRoleScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AlgorithmRole


class Allocation(GeneratedsSuper):
    member_data_items_ = {
        'allocationTradeId': MemberSpec_('allocationTradeId', 'TradeIdentifier', 1),
        'partyReference': MemberSpec_('partyReference', 'PartyReference', 0),
        'accountReference': MemberSpec_('accountReference', 'AccountReference', 0),
        'allocatedFraction': MemberSpec_('allocatedFraction', 'xsd:decimal', 0),
        'allocatedNotional': MemberSpec_('allocatedNotional', 'Money', 1),
        'collateral': MemberSpec_('collateral', 'Collateral', 0),
        'creditChargeAmount': MemberSpec_('creditChargeAmount', 'Money', 0),
        'approvals': MemberSpec_('approvals', 'Approvals', 0),
        'masterConfirmationDate': MemberSpec_('masterConfirmationDate', 'xsd:date', 0),
        'relatedParty': MemberSpec_('relatedParty', 'RelatedParty', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, allocationTradeId=None, partyReference=None, accountReference=None, allocatedFraction=None, allocatedNotional=None, collateral=None, creditChargeAmount=None, approvals=None, masterConfirmationDate=None, relatedParty=None):
        self.original_tagname_ = None
        if allocationTradeId is None:
            self.allocationTradeId = []
        else:
            self.allocationTradeId = allocationTradeId
        self.partyReference = partyReference
        self.accountReference = accountReference
        self.allocatedFraction = allocatedFraction
        if allocatedNotional is None:
            self.allocatedNotional = []
        else:
            self.allocatedNotional = allocatedNotional
        self.collateral = collateral
        self.creditChargeAmount = creditChargeAmount
        self.approvals = approvals
        if isinstance(masterConfirmationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(masterConfirmationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = masterConfirmationDate
        self.masterConfirmationDate = initvalue_
        if relatedParty is None:
            self.relatedParty = []
        else:
            self.relatedParty = relatedParty
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Allocation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Allocation.subclass:
            return Allocation.subclass(*args_, **kwargs_)
        else:
            return Allocation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_allocationTradeId(self): return self.allocationTradeId
    def set_allocationTradeId(self, allocationTradeId): self.allocationTradeId = allocationTradeId
    def add_allocationTradeId(self, value): self.allocationTradeId.append(value)
    def insert_allocationTradeId_at(self, index, value): self.allocationTradeId.insert(index, value)
    def replace_allocationTradeId_at(self, index, value): self.allocationTradeId[index] = value
    def get_partyReference(self): return self.partyReference
    def set_partyReference(self, partyReference): self.partyReference = partyReference
    def get_accountReference(self): return self.accountReference
    def set_accountReference(self, accountReference): self.accountReference = accountReference
    def get_allocatedFraction(self): return self.allocatedFraction
    def set_allocatedFraction(self, allocatedFraction): self.allocatedFraction = allocatedFraction
    def get_allocatedNotional(self): return self.allocatedNotional
    def set_allocatedNotional(self, allocatedNotional): self.allocatedNotional = allocatedNotional
    def add_allocatedNotional(self, value): self.allocatedNotional.append(value)
    def insert_allocatedNotional_at(self, index, value): self.allocatedNotional.insert(index, value)
    def replace_allocatedNotional_at(self, index, value): self.allocatedNotional[index] = value
    def get_collateral(self): return self.collateral
    def set_collateral(self, collateral): self.collateral = collateral
    def get_creditChargeAmount(self): return self.creditChargeAmount
    def set_creditChargeAmount(self, creditChargeAmount): self.creditChargeAmount = creditChargeAmount
    def get_approvals(self): return self.approvals
    def set_approvals(self, approvals): self.approvals = approvals
    def get_masterConfirmationDate(self): return self.masterConfirmationDate
    def set_masterConfirmationDate(self, masterConfirmationDate): self.masterConfirmationDate = masterConfirmationDate
    def get_relatedParty(self): return self.relatedParty
    def set_relatedParty(self, relatedParty): self.relatedParty = relatedParty
    def add_relatedParty(self, value): self.relatedParty.append(value)
    def insert_relatedParty_at(self, index, value): self.relatedParty.insert(index, value)
    def replace_relatedParty_at(self, index, value): self.relatedParty[index] = value
    def hasContent_(self):
        if (
            self.allocationTradeId or
            self.partyReference is not None or
            self.accountReference is not None or
            self.allocatedFraction is not None or
            self.allocatedNotional or
            self.collateral is not None or
            self.creditChargeAmount is not None or
            self.approvals is not None or
            self.masterConfirmationDate is not None or
            self.relatedParty
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Allocation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Allocation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Allocation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Allocation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Allocation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for allocationTradeId_ in self.allocationTradeId:
            allocationTradeId_.export(outfile, level, namespace_, name_='allocationTradeId', pretty_print=pretty_print)
        if self.partyReference is not None:
            self.partyReference.export(outfile, level, namespace_, name_='partyReference', pretty_print=pretty_print)
        if self.accountReference is not None:
            self.accountReference.export(outfile, level, namespace_, name_='accountReference', pretty_print=pretty_print)
        if self.allocatedFraction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sallocatedFraction>%s</%sallocatedFraction>%s' % (namespace_, self.gds_format_float(self.allocatedFraction, input_name='allocatedFraction'), namespace_, eol_))
        for allocatedNotional_ in self.allocatedNotional:
            allocatedNotional_.export(outfile, level, namespace_, name_='allocatedNotional', pretty_print=pretty_print)
        if self.collateral is not None:
            self.collateral.export(outfile, level, namespace_, name_='collateral', pretty_print=pretty_print)
        if self.creditChargeAmount is not None:
            self.creditChargeAmount.export(outfile, level, namespace_, name_='creditChargeAmount', pretty_print=pretty_print)
        if self.approvals is not None:
            self.approvals.export(outfile, level, namespace_, name_='approvals', pretty_print=pretty_print)
        if self.masterConfirmationDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smasterConfirmationDate>%s</%smasterConfirmationDate>%s' % (namespace_, self.gds_format_date(self.masterConfirmationDate, input_name='masterConfirmationDate'), namespace_, eol_))
        for relatedParty_ in self.relatedParty:
            relatedParty_.export(outfile, level, namespace_, name_='relatedParty', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'allocationTradeId':
            class_obj_ = self.get_class_obj_(child_, TradeIdentifier)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.allocationTradeId.append(obj_)
            obj_.original_tagname_ = 'allocationTradeId'
        elif nodeName_ == 'partyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.partyReference = obj_
            obj_.original_tagname_ = 'partyReference'
        elif nodeName_ == 'accountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.accountReference = obj_
            obj_.original_tagname_ = 'accountReference'
        elif nodeName_ == 'allocatedFraction':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'allocatedFraction')
            self.allocatedFraction = fval_
        elif nodeName_ == 'allocatedNotional':
            obj_ = Money.factory()
            obj_.build(child_)
            self.allocatedNotional.append(obj_)
            obj_.original_tagname_ = 'allocatedNotional'
        elif nodeName_ == 'collateral':
            obj_ = Collateral.factory()
            obj_.build(child_)
            self.collateral = obj_
            obj_.original_tagname_ = 'collateral'
        elif nodeName_ == 'creditChargeAmount':
            obj_ = Money.factory()
            obj_.build(child_)
            self.creditChargeAmount = obj_
            obj_.original_tagname_ = 'creditChargeAmount'
        elif nodeName_ == 'approvals':
            obj_ = Approvals.factory()
            obj_.build(child_)
            self.approvals = obj_
            obj_.original_tagname_ = 'approvals'
        elif nodeName_ == 'masterConfirmationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.masterConfirmationDate = dval_
        elif nodeName_ == 'relatedParty':
            obj_ = RelatedParty.factory()
            obj_.build(child_)
            self.relatedParty.append(obj_)
            obj_.original_tagname_ = 'relatedParty'
# end class Allocation


class AllocationReportingStatus(GeneratedsSuper):
    """Code that describes what type of allocation applies to the trade.
    Options include Unallocated, PreAllocation, PostAllocation."""
    member_data_items_ = {
        'allocationReportingStatusScheme': MemberSpec_('allocationReportingStatusScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, allocationReportingStatusScheme='http://www.fpml.org/coding-scheme/allocation-reporting-status', valueOf_=None):
        self.original_tagname_ = None
        self.allocationReportingStatusScheme = _cast(None, allocationReportingStatusScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AllocationReportingStatus)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AllocationReportingStatus.subclass:
            return AllocationReportingStatus.subclass(*args_, **kwargs_)
        else:
            return AllocationReportingStatus(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_allocationReportingStatusScheme(self): return self.allocationReportingStatusScheme
    def set_allocationReportingStatusScheme(self, allocationReportingStatusScheme): self.allocationReportingStatusScheme = allocationReportingStatusScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AllocationReportingStatus', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AllocationReportingStatus')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AllocationReportingStatus', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AllocationReportingStatus'):
        if self.allocationReportingStatusScheme != "http://www.fpml.org/coding-scheme/allocation-reporting-status" and 'allocationReportingStatusScheme' not in already_processed:
            already_processed.add('allocationReportingStatusScheme')
            outfile.write(' allocationReportingStatusScheme=%s' % (quote_attrib(self.allocationReportingStatusScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AllocationReportingStatus', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('allocationReportingStatusScheme', node)
        if value is not None and 'allocationReportingStatusScheme' not in already_processed:
            already_processed.add('allocationReportingStatusScheme')
            self.allocationReportingStatusScheme = value
            self.validate_NonEmptyURI(self.allocationReportingStatusScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AllocationReportingStatus


class Allocations(GeneratedsSuper):
    """The allocations for a single side of a trade."""
    member_data_items_ = {
        'allocatingPartyReference': MemberSpec_('allocatingPartyReference', 'PartyReference', 0),
        'allocation': MemberSpec_('allocation', 'Allocation', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, allocatingPartyReference=None, allocation=None):
        self.original_tagname_ = None
        self.allocatingPartyReference = allocatingPartyReference
        if allocation is None:
            self.allocation = []
        else:
            self.allocation = allocation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Allocations)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Allocations.subclass:
            return Allocations.subclass(*args_, **kwargs_)
        else:
            return Allocations(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_allocatingPartyReference(self): return self.allocatingPartyReference
    def set_allocatingPartyReference(self, allocatingPartyReference): self.allocatingPartyReference = allocatingPartyReference
    def get_allocation(self): return self.allocation
    def set_allocation(self, allocation): self.allocation = allocation
    def add_allocation(self, value): self.allocation.append(value)
    def insert_allocation_at(self, index, value): self.allocation.insert(index, value)
    def replace_allocation_at(self, index, value): self.allocation[index] = value
    def hasContent_(self):
        if (
            self.allocatingPartyReference is not None or
            self.allocation
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Allocations', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Allocations')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Allocations', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Allocations'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Allocations', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.allocatingPartyReference is not None:
            self.allocatingPartyReference.export(outfile, level, namespace_, name_='allocatingPartyReference', pretty_print=pretty_print)
        for allocation_ in self.allocation:
            allocation_.export(outfile, level, namespace_, name_='allocation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'allocatingPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.allocatingPartyReference = obj_
            obj_.original_tagname_ = 'allocatingPartyReference'
        elif nodeName_ == 'allocation':
            obj_ = Allocation.factory()
            obj_.build(child_)
            self.allocation.append(obj_)
            obj_.original_tagname_ = 'allocation'
# end class Allocations


class Approval(GeneratedsSuper):
    """A specific approval state in the workflow."""
    member_data_items_ = {
        'type_': MemberSpec_('type_', 'ApprovalType', 0),
        'status': MemberSpec_('status', ['NormalizedString', 'xsd:normalizedString'], 0),
        'approver': MemberSpec_('approver', 'PersonId', 0),
        'approvingPartyReference': MemberSpec_('approvingPartyReference', 'PartyReference', 0),
        'approvedPartyReference': MemberSpec_('approvedPartyReference', 'PartyReference', 0),
        'approvalId': MemberSpec_('approvalId', 'ApprovalId', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, type_=None, status=None, approver=None, approvingPartyReference=None, approvedPartyReference=None, approvalId=None):
        self.original_tagname_ = None
        self.type_ = type_
        self.status = status
        self.validate_NormalizedString(self.status)
        self.approver = approver
        self.approvingPartyReference = approvingPartyReference
        self.approvedPartyReference = approvedPartyReference
        self.approvalId = approvalId
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Approval)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Approval.subclass:
            return Approval.subclass(*args_, **kwargs_)
        else:
            return Approval(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_approver(self): return self.approver
    def set_approver(self, approver): self.approver = approver
    def get_approvingPartyReference(self): return self.approvingPartyReference
    def set_approvingPartyReference(self, approvingPartyReference): self.approvingPartyReference = approvingPartyReference
    def get_approvedPartyReference(self): return self.approvedPartyReference
    def set_approvedPartyReference(self, approvedPartyReference): self.approvedPartyReference = approvedPartyReference
    def get_approvalId(self): return self.approvalId
    def set_approvalId(self, approvalId): self.approvalId = approvalId
    def validate_NormalizedString(self, value):
        # Validate type NormalizedString, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NormalizedString' % {"value" : value} )
    def hasContent_(self):
        if (
            self.type_ is not None or
            self.status is not None or
            self.approver is not None or
            self.approvingPartyReference is not None or
            self.approvedPartyReference is not None or
            self.approvalId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Approval', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Approval')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Approval', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Approval'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Approval', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            self.type_.export(outfile, level, namespace_, name_='type', pretty_print=pretty_print)
        if self.status is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstatus>%s</%sstatus>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.status), input_name='status')), namespace_, eol_))
        if self.approver is not None:
            self.approver.export(outfile, level, namespace_, name_='approver', pretty_print=pretty_print)
        if self.approvingPartyReference is not None:
            self.approvingPartyReference.export(outfile, level, namespace_, name_='approvingPartyReference', pretty_print=pretty_print)
        if self.approvedPartyReference is not None:
            self.approvedPartyReference.export(outfile, level, namespace_, name_='approvedPartyReference', pretty_print=pretty_print)
        if self.approvalId is not None:
            self.approvalId.export(outfile, level, namespace_, name_='approvalId', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            obj_ = ApprovalType.factory()
            obj_.build(child_)
            self.type_ = obj_
            obj_.original_tagname_ = 'type'
        elif nodeName_ == 'status':
            status_ = child_.text
            status_ = self.gds_validate_string(status_, node, 'status')
            self.status = status_
            # validate type NormalizedString
            self.validate_NormalizedString(self.status)
        elif nodeName_ == 'approver':
            obj_ = PersonId.factory()
            obj_.build(child_)
            self.approver = obj_
            obj_.original_tagname_ = 'approver'
        elif nodeName_ == 'approvingPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.approvingPartyReference = obj_
            obj_.original_tagname_ = 'approvingPartyReference'
        elif nodeName_ == 'approvedPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.approvedPartyReference = obj_
            obj_.original_tagname_ = 'approvedPartyReference'
        elif nodeName_ == 'approvalId':
            obj_ = ApprovalId.factory()
            obj_.build(child_)
            self.approvalId = obj_
            obj_.original_tagname_ = 'approvalId'
# end class Approval


class ApprovalId(GeneratedsSuper):
    """An approval identifier allocated by a party. FpML does not define
    the domain values associated with this element."""
    member_data_items_ = {
        'approvalIdScheme': MemberSpec_('approvalIdScheme', 'NonEmptyURI', 0),
        'id': MemberSpec_('id', 'xsd:string', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, approvalIdScheme=None, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.approvalIdScheme = _cast(None, approvalIdScheme)
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ApprovalId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ApprovalId.subclass:
            return ApprovalId.subclass(*args_, **kwargs_)
        else:
            return ApprovalId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_approvalIdScheme(self): return self.approvalIdScheme
    def set_approvalIdScheme(self, approvalIdScheme): self.approvalIdScheme = approvalIdScheme
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ApprovalId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ApprovalId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ApprovalId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ApprovalId'):
        if self.approvalIdScheme is not None and 'approvalIdScheme' not in already_processed:
            already_processed.add('approvalIdScheme')
            outfile.write(' approvalIdScheme=%s' % (quote_attrib(self.approvalIdScheme), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ApprovalId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('approvalIdScheme', node)
        if value is not None and 'approvalIdScheme' not in already_processed:
            already_processed.add('approvalIdScheme')
            self.approvalIdScheme = value
            self.validate_NonEmptyURI(self.approvalIdScheme)    # validate type NonEmptyURI
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ApprovalId


class Approvals(GeneratedsSuper):
    member_data_items_ = {
        'approval': MemberSpec_('approval', 'Approval', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, approval=None):
        self.original_tagname_ = None
        if approval is None:
            self.approval = []
        else:
            self.approval = approval
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Approvals)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Approvals.subclass:
            return Approvals.subclass(*args_, **kwargs_)
        else:
            return Approvals(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_approval(self): return self.approval
    def set_approval(self, approval): self.approval = approval
    def add_approval(self, value): self.approval.append(value)
    def insert_approval_at(self, index, value): self.approval.insert(index, value)
    def replace_approval_at(self, index, value): self.approval[index] = value
    def hasContent_(self):
        if (
            self.approval
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Approvals', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Approvals')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Approvals', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Approvals'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Approvals', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for approval_ in self.approval:
            approval_.export(outfile, level, namespace_, name_='approval', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'approval':
            obj_ = Approval.factory()
            obj_.build(child_)
            self.approval.append(obj_)
            obj_.original_tagname_ = 'approval'
# end class Approvals


class ApprovalType(GeneratedsSuper):
    """A type that qualifies the type of approval."""
    member_data_items_ = {
        'approvalTypeScheme': MemberSpec_('approvalTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, approvalTypeScheme='http://www.fpml.org/coding-scheme/approval-type', valueOf_=None):
        self.original_tagname_ = None
        self.approvalTypeScheme = _cast(None, approvalTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ApprovalType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ApprovalType.subclass:
            return ApprovalType.subclass(*args_, **kwargs_)
        else:
            return ApprovalType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_approvalTypeScheme(self): return self.approvalTypeScheme
    def set_approvalTypeScheme(self, approvalTypeScheme): self.approvalTypeScheme = approvalTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ApprovalType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ApprovalType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ApprovalType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ApprovalType'):
        if self.approvalTypeScheme != "http://www.fpml.org/coding-scheme/approval-type" and 'approvalTypeScheme' not in already_processed:
            already_processed.add('approvalTypeScheme')
            outfile.write(' approvalTypeScheme=%s' % (quote_attrib(self.approvalTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ApprovalType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('approvalTypeScheme', node)
        if value is not None and 'approvalTypeScheme' not in already_processed:
            already_processed.add('approvalTypeScheme')
            self.approvalTypeScheme = value
            self.validate_NonEmptyURI(self.approvalTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ApprovalType


class ClearingStatusValue(GeneratedsSuper):
    """The current status value of a clearing request."""
    member_data_items_ = {
        'clearingStatusScheme': MemberSpec_('clearingStatusScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, clearingStatusScheme='http://www.fpml.org/coding-scheme/clearing-status', valueOf_=None):
        self.original_tagname_ = None
        self.clearingStatusScheme = _cast(None, clearingStatusScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClearingStatusValue)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClearingStatusValue.subclass:
            return ClearingStatusValue.subclass(*args_, **kwargs_)
        else:
            return ClearingStatusValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_clearingStatusScheme(self): return self.clearingStatusScheme
    def set_clearingStatusScheme(self, clearingStatusScheme): self.clearingStatusScheme = clearingStatusScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ClearingStatusValue', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ClearingStatusValue')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ClearingStatusValue', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ClearingStatusValue'):
        if self.clearingStatusScheme != "http://www.fpml.org/coding-scheme/clearing-status" and 'clearingStatusScheme' not in already_processed:
            already_processed.add('clearingStatusScheme')
            outfile.write(' clearingStatusScheme=%s' % (quote_attrib(self.clearingStatusScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ClearingStatusValue', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('clearingStatusScheme', node)
        if value is not None and 'clearingStatusScheme' not in already_processed:
            already_processed.add('clearingStatusScheme')
            self.clearingStatusScheme = value
            self.validate_NonEmptyURI(self.clearingStatusScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ClearingStatusValue


class CollateralizationType(GeneratedsSuper):
    """Code that describes what type of collateral is posted by a party to
    a transaction. Options include Uncollateralized, Partial, Full,
    One-Way."""
    member_data_items_ = {
        'collateralTypeScheme': MemberSpec_('collateralTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, collateralTypeScheme='http://www.fpml.org/coding-scheme/collateral-type', valueOf_=None):
        self.original_tagname_ = None
        self.collateralTypeScheme = _cast(None, collateralTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CollateralizationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CollateralizationType.subclass:
            return CollateralizationType.subclass(*args_, **kwargs_)
        else:
            return CollateralizationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_collateralTypeScheme(self): return self.collateralTypeScheme
    def set_collateralTypeScheme(self, collateralTypeScheme): self.collateralTypeScheme = collateralTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CollateralizationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CollateralizationType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CollateralizationType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CollateralizationType'):
        if self.collateralTypeScheme != "http://www.fpml.org/coding-scheme/collateral-type" and 'collateralTypeScheme' not in already_processed:
            already_processed.add('collateralTypeScheme')
            outfile.write(' collateralTypeScheme=%s' % (quote_attrib(self.collateralTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CollateralizationType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('collateralTypeScheme', node)
        if value is not None and 'collateralTypeScheme' not in already_processed:
            already_processed.add('collateralTypeScheme')
            self.collateralTypeScheme = value
            self.validate_NonEmptyURI(self.collateralTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CollateralizationType


class ConfirmationMethod(GeneratedsSuper):
    """A type used to represent the type of mechanism that can be used to
    confirm a trade."""
    member_data_items_ = {
        'confirmationMethodScheme': MemberSpec_('confirmationMethodScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, confirmationMethodScheme='http://www.fpml.org/coding-scheme/confirmation-method', valueOf_=None):
        self.original_tagname_ = None
        self.confirmationMethodScheme = _cast(None, confirmationMethodScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConfirmationMethod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConfirmationMethod.subclass:
            return ConfirmationMethod.subclass(*args_, **kwargs_)
        else:
            return ConfirmationMethod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_confirmationMethodScheme(self): return self.confirmationMethodScheme
    def set_confirmationMethodScheme(self, confirmationMethodScheme): self.confirmationMethodScheme = confirmationMethodScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ConfirmationMethod', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConfirmationMethod')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ConfirmationMethod', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConfirmationMethod'):
        if self.confirmationMethodScheme != "http://www.fpml.org/coding-scheme/confirmation-method" and 'confirmationMethodScheme' not in already_processed:
            already_processed.add('confirmationMethodScheme')
            outfile.write(' confirmationMethodScheme=%s' % (quote_attrib(self.confirmationMethodScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ConfirmationMethod', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('confirmationMethodScheme', node)
        if value is not None and 'confirmationMethodScheme' not in already_processed:
            already_processed.add('confirmationMethodScheme')
            self.confirmationMethodScheme = value
            self.validate_NonEmptyURI(self.confirmationMethodScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ConfirmationMethod


class ContractId(GeneratedsSuper):
    """A contact id identifier allocated by a party. FpML does not define
    the domain values associated with this element."""
    member_data_items_ = {
        'contractIdScheme': MemberSpec_('contractIdScheme', 'NonEmptyURI', 0),
        'id': MemberSpec_('id', 'xsd:string', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, contractIdScheme=None, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.contractIdScheme = _cast(None, contractIdScheme)
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContractId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContractId.subclass:
            return ContractId.subclass(*args_, **kwargs_)
        else:
            return ContractId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_contractIdScheme(self): return self.contractIdScheme
    def set_contractIdScheme(self, contractIdScheme): self.contractIdScheme = contractIdScheme
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ContractId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContractId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ContractId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContractId'):
        if self.contractIdScheme is not None and 'contractIdScheme' not in already_processed:
            already_processed.add('contractIdScheme')
            outfile.write(' contractIdScheme=%s' % (quote_attrib(self.contractIdScheme), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ContractId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('contractIdScheme', node)
        if value is not None and 'contractIdScheme' not in already_processed:
            already_processed.add('contractIdScheme')
            self.contractIdScheme = value
            self.validate_NonEmptyURI(self.contractIdScheme)    # validate type NonEmptyURI
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ContractId


class ContractIdentifier(GeneratedsSuper):
    """A type defining a contract identifier issued by the indicated
    party.Where the legal activity is to agree a contract of
    variation then the business process should be to modify a
    contract. This is a contract in its own right and not a version
    of a previous contract. Where the business process is to replace
    and supersede a contract then you have a new contract and a
    contract version should not be used."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'partyReference': MemberSpec_('partyReference', 'PartyReference', 0),
        'contractId': MemberSpec_('contractId', 'ContractId', 1),
        'versionedContractId': MemberSpec_('versionedContractId', 'VersionedContractId', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, partyReference=None, contractId=None, versionedContractId=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.partyReference = partyReference
        if contractId is None:
            self.contractId = []
        else:
            self.contractId = contractId
        if versionedContractId is None:
            self.versionedContractId = []
        else:
            self.versionedContractId = versionedContractId
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContractIdentifier)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContractIdentifier.subclass:
            return ContractIdentifier.subclass(*args_, **kwargs_)
        else:
            return ContractIdentifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyReference(self): return self.partyReference
    def set_partyReference(self, partyReference): self.partyReference = partyReference
    def get_contractId(self): return self.contractId
    def set_contractId(self, contractId): self.contractId = contractId
    def add_contractId(self, value): self.contractId.append(value)
    def insert_contractId_at(self, index, value): self.contractId.insert(index, value)
    def replace_contractId_at(self, index, value): self.contractId[index] = value
    def get_versionedContractId(self): return self.versionedContractId
    def set_versionedContractId(self, versionedContractId): self.versionedContractId = versionedContractId
    def add_versionedContractId(self, value): self.versionedContractId.append(value)
    def insert_versionedContractId_at(self, index, value): self.versionedContractId.insert(index, value)
    def replace_versionedContractId_at(self, index, value): self.versionedContractId[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.partyReference is not None or
            self.contractId or
            self.versionedContractId
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ContractIdentifier', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContractIdentifier')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ContractIdentifier', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContractIdentifier'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ContractIdentifier', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.partyReference is not None:
            self.partyReference.export(outfile, level, namespace_, name_='partyReference', pretty_print=pretty_print)
        for contractId_ in self.contractId:
            contractId_.export(outfile, level, namespace_, name_='contractId', pretty_print=pretty_print)
        for versionedContractId_ in self.versionedContractId:
            versionedContractId_.export(outfile, level, namespace_, name_='versionedContractId', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'partyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.partyReference = obj_
            obj_.original_tagname_ = 'partyReference'
        elif nodeName_ == 'contractId':
            obj_ = ContractId.factory()
            obj_.build(child_)
            self.contractId.append(obj_)
            obj_.original_tagname_ = 'contractId'
        elif nodeName_ == 'versionedContractId':
            obj_ = VersionedContractId.factory()
            obj_.build(child_)
            self.versionedContractId.append(obj_)
            obj_.original_tagname_ = 'versionedContractId'
# end class ContractIdentifier


class CreditDerivativesNotices(GeneratedsSuper):
    member_data_items_ = {
        'creditEvent': MemberSpec_('creditEvent', 'xsd:boolean', 0),
        'publiclyAvailableInformation': MemberSpec_('publiclyAvailableInformation', 'xsd:boolean', 0),
        'physicalSettlement': MemberSpec_('physicalSettlement', 'xsd:boolean', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, creditEvent=None, publiclyAvailableInformation=None, physicalSettlement=None):
        self.original_tagname_ = None
        self.creditEvent = creditEvent
        self.publiclyAvailableInformation = publiclyAvailableInformation
        self.physicalSettlement = physicalSettlement
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditDerivativesNotices)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditDerivativesNotices.subclass:
            return CreditDerivativesNotices.subclass(*args_, **kwargs_)
        else:
            return CreditDerivativesNotices(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_creditEvent(self): return self.creditEvent
    def set_creditEvent(self, creditEvent): self.creditEvent = creditEvent
    def get_publiclyAvailableInformation(self): return self.publiclyAvailableInformation
    def set_publiclyAvailableInformation(self, publiclyAvailableInformation): self.publiclyAvailableInformation = publiclyAvailableInformation
    def get_physicalSettlement(self): return self.physicalSettlement
    def set_physicalSettlement(self, physicalSettlement): self.physicalSettlement = physicalSettlement
    def hasContent_(self):
        if (
            self.creditEvent is not None or
            self.publiclyAvailableInformation is not None or
            self.physicalSettlement is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditDerivativesNotices', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditDerivativesNotices')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditDerivativesNotices', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditDerivativesNotices'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CreditDerivativesNotices', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.creditEvent is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%screditEvent>%s</%screditEvent>%s' % (namespace_, self.gds_format_boolean(self.creditEvent, input_name='creditEvent'), namespace_, eol_))
        if self.publiclyAvailableInformation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spubliclyAvailableInformation>%s</%spubliclyAvailableInformation>%s' % (namespace_, self.gds_format_boolean(self.publiclyAvailableInformation, input_name='publiclyAvailableInformation'), namespace_, eol_))
        if self.physicalSettlement is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sphysicalSettlement>%s</%sphysicalSettlement>%s' % (namespace_, self.gds_format_boolean(self.physicalSettlement, input_name='physicalSettlement'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'creditEvent':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'creditEvent')
            self.creditEvent = ival_
        elif nodeName_ == 'publiclyAvailableInformation':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'publiclyAvailableInformation')
            self.publiclyAvailableInformation = ival_
        elif nodeName_ == 'physicalSettlement':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'physicalSettlement')
            self.physicalSettlement = ival_
# end class CreditDerivativesNotices


class CreditDocument(GeneratedsSuper):
    """A credit arrangement used in support of swaps trading."""
    member_data_items_ = {
        'creditDocumentScheme': MemberSpec_('creditDocumentScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, creditDocumentScheme='http://www.fpml.org/coding-scheme/credit-document', valueOf_=None):
        self.original_tagname_ = None
        self.creditDocumentScheme = _cast(None, creditDocumentScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditDocument)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditDocument.subclass:
            return CreditDocument.subclass(*args_, **kwargs_)
        else:
            return CreditDocument(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_creditDocumentScheme(self): return self.creditDocumentScheme
    def set_creditDocumentScheme(self, creditDocumentScheme): self.creditDocumentScheme = creditDocumentScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditDocument', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditDocument')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditDocument', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditDocument'):
        if self.creditDocumentScheme != "http://www.fpml.org/coding-scheme/credit-document" and 'creditDocumentScheme' not in already_processed:
            already_processed.add('creditDocumentScheme')
            outfile.write(' creditDocumentScheme=%s' % (quote_attrib(self.creditDocumentScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CreditDocument', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('creditDocumentScheme', node)
        if value is not None and 'creditDocumentScheme' not in already_processed:
            already_processed.add('creditDocumentScheme')
            self.creditDocumentScheme = value
            self.validate_NonEmptyURI(self.creditDocumentScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CreditDocument


class Document(GeneratedsSuper):
    """The abstract base type from which all FpML compliant messages and
    documents must be derived."""
    member_data_items_ = {
        'fpmlVersion': MemberSpec_('fpmlVersion', 'Token', 0),
        'expectedBuild': MemberSpec_('expectedBuild', 'xsd:positiveInteger', 0),
        'actualBuild': MemberSpec_('actualBuild', 'xsd:positiveInteger', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, fpmlVersion=None, expectedBuild=None, actualBuild=None, extensiontype_=None):
        self.original_tagname_ = None
        self.fpmlVersion = _cast(None, fpmlVersion)
        self.expectedBuild = _cast(int, expectedBuild)
        self.actualBuild = _cast(int, actualBuild)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Document)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Document.subclass:
            return Document.subclass(*args_, **kwargs_)
        else:
            return Document(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fpmlVersion(self): return self.fpmlVersion
    def set_fpmlVersion(self, fpmlVersion): self.fpmlVersion = fpmlVersion
    def get_expectedBuild(self): return self.expectedBuild
    def set_expectedBuild(self, expectedBuild): self.expectedBuild = expectedBuild
    def get_actualBuild(self): return self.actualBuild
    def set_actualBuild(self, actualBuild): self.actualBuild = actualBuild
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_Token(self, value):
        # Validate type Token, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Token' % {"value" : value} )
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Document', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Document')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Document', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Document'):
        if self.fpmlVersion is not None and 'fpmlVersion' not in already_processed:
            already_processed.add('fpmlVersion')
            outfile.write(' fpmlVersion=%s' % (quote_attrib(self.fpmlVersion), ))
        if self.expectedBuild is not None and 'expectedBuild' not in already_processed:
            already_processed.add('expectedBuild')
            outfile.write(' expectedBuild="%s"' % self.gds_format_integer(self.expectedBuild, input_name='expectedBuild'))
        if self.actualBuild is not None and 'actualBuild' not in already_processed:
            already_processed.add('actualBuild')
            outfile.write(' actualBuild="%s"' % self.gds_format_integer(self.actualBuild, input_name='actualBuild'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Document', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fpmlVersion', node)
        if value is not None and 'fpmlVersion' not in already_processed:
            already_processed.add('fpmlVersion')
            self.fpmlVersion = value
            self.fpmlVersion = ' '.join(self.fpmlVersion.split())
            self.validate_Token(self.fpmlVersion)    # validate type Token
        value = find_attr_value_('expectedBuild', node)
        if value is not None and 'expectedBuild' not in already_processed:
            already_processed.add('expectedBuild')
            try:
                self.expectedBuild = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.expectedBuild <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('actualBuild', node)
        if value is not None and 'actualBuild' not in already_processed:
            already_processed.add('actualBuild')
            try:
                self.actualBuild = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.actualBuild <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Document


class EndUserExceptionDeclaration(GeneratedsSuper):
    """Records supporting information justifying an end user exception
    under 17 CFR part 39."""
    member_data_items_ = {
        'creditDocument': MemberSpec_('creditDocument', 'CreditDocument', 1),
        'organizationCharacteristic': MemberSpec_('organizationCharacteristic', 'OrganizationCharacteristic', 1),
        'transactionCharacteristic': MemberSpec_('transactionCharacteristic', 'TransactionCharacteristic', 1),
        'supervisorRegistration': MemberSpec_('supervisorRegistration', 'SupervisorRegistration', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, creditDocument=None, organizationCharacteristic=None, transactionCharacteristic=None, supervisorRegistration=None):
        self.original_tagname_ = None
        if creditDocument is None:
            self.creditDocument = []
        else:
            self.creditDocument = creditDocument
        if organizationCharacteristic is None:
            self.organizationCharacteristic = []
        else:
            self.organizationCharacteristic = organizationCharacteristic
        if transactionCharacteristic is None:
            self.transactionCharacteristic = []
        else:
            self.transactionCharacteristic = transactionCharacteristic
        if supervisorRegistration is None:
            self.supervisorRegistration = []
        else:
            self.supervisorRegistration = supervisorRegistration
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EndUserExceptionDeclaration)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EndUserExceptionDeclaration.subclass:
            return EndUserExceptionDeclaration.subclass(*args_, **kwargs_)
        else:
            return EndUserExceptionDeclaration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_creditDocument(self): return self.creditDocument
    def set_creditDocument(self, creditDocument): self.creditDocument = creditDocument
    def add_creditDocument(self, value): self.creditDocument.append(value)
    def insert_creditDocument_at(self, index, value): self.creditDocument.insert(index, value)
    def replace_creditDocument_at(self, index, value): self.creditDocument[index] = value
    def get_organizationCharacteristic(self): return self.organizationCharacteristic
    def set_organizationCharacteristic(self, organizationCharacteristic): self.organizationCharacteristic = organizationCharacteristic
    def add_organizationCharacteristic(self, value): self.organizationCharacteristic.append(value)
    def insert_organizationCharacteristic_at(self, index, value): self.organizationCharacteristic.insert(index, value)
    def replace_organizationCharacteristic_at(self, index, value): self.organizationCharacteristic[index] = value
    def get_transactionCharacteristic(self): return self.transactionCharacteristic
    def set_transactionCharacteristic(self, transactionCharacteristic): self.transactionCharacteristic = transactionCharacteristic
    def add_transactionCharacteristic(self, value): self.transactionCharacteristic.append(value)
    def insert_transactionCharacteristic_at(self, index, value): self.transactionCharacteristic.insert(index, value)
    def replace_transactionCharacteristic_at(self, index, value): self.transactionCharacteristic[index] = value
    def get_supervisorRegistration(self): return self.supervisorRegistration
    def set_supervisorRegistration(self, supervisorRegistration): self.supervisorRegistration = supervisorRegistration
    def add_supervisorRegistration(self, value): self.supervisorRegistration.append(value)
    def insert_supervisorRegistration_at(self, index, value): self.supervisorRegistration.insert(index, value)
    def replace_supervisorRegistration_at(self, index, value): self.supervisorRegistration[index] = value
    def hasContent_(self):
        if (
            self.creditDocument or
            self.organizationCharacteristic or
            self.transactionCharacteristic or
            self.supervisorRegistration
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EndUserExceptionDeclaration', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EndUserExceptionDeclaration')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EndUserExceptionDeclaration', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EndUserExceptionDeclaration'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EndUserExceptionDeclaration', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for creditDocument_ in self.creditDocument:
            creditDocument_.export(outfile, level, namespace_, name_='creditDocument', pretty_print=pretty_print)
        for organizationCharacteristic_ in self.organizationCharacteristic:
            organizationCharacteristic_.export(outfile, level, namespace_, name_='organizationCharacteristic', pretty_print=pretty_print)
        for transactionCharacteristic_ in self.transactionCharacteristic:
            transactionCharacteristic_.export(outfile, level, namespace_, name_='transactionCharacteristic', pretty_print=pretty_print)
        for supervisorRegistration_ in self.supervisorRegistration:
            supervisorRegistration_.export(outfile, level, namespace_, name_='supervisorRegistration', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'creditDocument':
            obj_ = CreditDocument.factory()
            obj_.build(child_)
            self.creditDocument.append(obj_)
            obj_.original_tagname_ = 'creditDocument'
        elif nodeName_ == 'organizationCharacteristic':
            obj_ = OrganizationCharacteristic.factory()
            obj_.build(child_)
            self.organizationCharacteristic.append(obj_)
            obj_.original_tagname_ = 'organizationCharacteristic'
        elif nodeName_ == 'transactionCharacteristic':
            obj_ = TransactionCharacteristic.factory()
            obj_.build(child_)
            self.transactionCharacteristic.append(obj_)
            obj_.original_tagname_ = 'transactionCharacteristic'
        elif nodeName_ == 'supervisorRegistration':
            obj_ = SupervisorRegistration.factory()
            obj_.build(child_)
            self.supervisorRegistration.append(obj_)
            obj_.original_tagname_ = 'supervisorRegistration'
# end class EndUserExceptionDeclaration


class EntityClassification(GeneratedsSuper):
    """A type describing the entity of a party, for example Financial,
    NonFinancial etc."""
    member_data_items_ = {
        'entityClassificationScheme': MemberSpec_('entityClassificationScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, entityClassificationScheme='http://www.fpml.org/coding-scheme/entity-classification', valueOf_=None):
        self.original_tagname_ = None
        self.entityClassificationScheme = _cast(None, entityClassificationScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntityClassification)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntityClassification.subclass:
            return EntityClassification.subclass(*args_, **kwargs_)
        else:
            return EntityClassification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_entityClassificationScheme(self): return self.entityClassificationScheme
    def set_entityClassificationScheme(self, entityClassificationScheme): self.entityClassificationScheme = entityClassificationScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EntityClassification', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityClassification')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EntityClassification', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EntityClassification'):
        if self.entityClassificationScheme != "http://www.fpml.org/coding-scheme/entity-classification" and 'entityClassificationScheme' not in already_processed:
            already_processed.add('entityClassificationScheme')
            outfile.write(' entityClassificationScheme=%s' % (quote_attrib(self.entityClassificationScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EntityClassification', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('entityClassificationScheme', node)
        if value is not None and 'entityClassificationScheme' not in already_processed:
            already_processed.add('entityClassificationScheme')
            self.entityClassificationScheme = value
            self.validate_NonEmptyURI(self.entityClassificationScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntityClassification


class ExecutionDateTime(GeneratedsSuper):
    """A type defining the trade execution date time and the source of it.
    For use inside containing types which already have a Reference
    to a Party that has assigned this trade execution date
    time.Identification of the source (e.g. clock id) generating the
    execution date time."""
    member_data_items_ = {
        'executionDateTimeScheme': MemberSpec_('executionDateTimeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', 'xsd:dateTime', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, executionDateTimeScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.executionDateTimeScheme = _cast(None, executionDateTimeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExecutionDateTime)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExecutionDateTime.subclass:
            return ExecutionDateTime.subclass(*args_, **kwargs_)
        else:
            return ExecutionDateTime(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_executionDateTimeScheme(self): return self.executionDateTimeScheme
    def set_executionDateTimeScheme(self, executionDateTimeScheme): self.executionDateTimeScheme = executionDateTimeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExecutionDateTime', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExecutionDateTime')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExecutionDateTime', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExecutionDateTime'):
        if self.executionDateTimeScheme is not None and 'executionDateTimeScheme' not in already_processed:
            already_processed.add('executionDateTimeScheme')
            outfile.write(' executionDateTimeScheme=%s' % (quote_attrib(self.executionDateTimeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ExecutionDateTime', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('executionDateTimeScheme', node)
        if value is not None and 'executionDateTimeScheme' not in already_processed:
            already_processed.add('executionDateTimeScheme')
            self.executionDateTimeScheme = value
            self.validate_NonEmptyURI(self.executionDateTimeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ExecutionDateTime


class ExecutionType(GeneratedsSuper):
    """A type used to represent the type of market where a trade can be
    executed."""
    member_data_items_ = {
        'executionTypeScheme': MemberSpec_('executionTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, executionTypeScheme='http://www.fpml.org/coding-scheme/execution-type', valueOf_=None):
        self.original_tagname_ = None
        self.executionTypeScheme = _cast(None, executionTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExecutionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExecutionType.subclass:
            return ExecutionType.subclass(*args_, **kwargs_)
        else:
            return ExecutionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_executionTypeScheme(self): return self.executionTypeScheme
    def set_executionTypeScheme(self, executionTypeScheme): self.executionTypeScheme = executionTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExecutionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExecutionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExecutionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExecutionType'):
        if self.executionTypeScheme != "http://www.fpml.org/coding-scheme/execution-type" and 'executionTypeScheme' not in already_processed:
            already_processed.add('executionTypeScheme')
            outfile.write(' executionTypeScheme=%s' % (quote_attrib(self.executionTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ExecutionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('executionTypeScheme', node)
        if value is not None and 'executionTypeScheme' not in already_processed:
            already_processed.add('executionTypeScheme')
            self.executionTypeScheme = value
            self.validate_NonEmptyURI(self.executionTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ExecutionType


class ExecutionVenueType(GeneratedsSuper):
    """A type used to represent the type of market where a trade can be
    executed."""
    member_data_items_ = {
        'executionVenueTypeScheme': MemberSpec_('executionVenueTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, executionVenueTypeScheme='http://www.fpml.org/coding-scheme/execution-venue-type', valueOf_=None):
        self.original_tagname_ = None
        self.executionVenueTypeScheme = _cast(None, executionVenueTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExecutionVenueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExecutionVenueType.subclass:
            return ExecutionVenueType.subclass(*args_, **kwargs_)
        else:
            return ExecutionVenueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_executionVenueTypeScheme(self): return self.executionVenueTypeScheme
    def set_executionVenueTypeScheme(self, executionVenueTypeScheme): self.executionVenueTypeScheme = executionVenueTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExecutionVenueType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExecutionVenueType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExecutionVenueType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExecutionVenueType'):
        if self.executionVenueTypeScheme != "http://www.fpml.org/coding-scheme/execution-venue-type" and 'executionVenueTypeScheme' not in already_processed:
            already_processed.add('executionVenueTypeScheme')
            outfile.write(' executionVenueTypeScheme=%s' % (quote_attrib(self.executionVenueTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ExecutionVenueType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('executionVenueTypeScheme', node)
        if value is not None and 'executionVenueTypeScheme' not in already_processed:
            already_processed.add('executionVenueTypeScheme')
            self.executionVenueTypeScheme = value
            self.validate_NonEmptyURI(self.executionVenueTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ExecutionVenueType


class FacilityExecutionExceptionDeclaration(GeneratedsSuper):
    """Provides supporting evidence when a party invoked exception to not
    execute the trade on facility such as SEF and DCM even though
    the particular product is mandated to execute on a SEF."""
    member_data_items_ = {
        'reason': MemberSpec_('reason', ['Token', 'xsd:token'], 1),
        'organizationCharacteristic': MemberSpec_('organizationCharacteristic', 'OrganizationCharacteristic', 1),
        'transactionCharacteristic': MemberSpec_('transactionCharacteristic', 'TransactionCharacteristic', 1),
        'supervisorRegistration': MemberSpec_('supervisorRegistration', 'SupervisorRegistration', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, reason=None, organizationCharacteristic=None, transactionCharacteristic=None, supervisorRegistration=None):
        self.original_tagname_ = None
        if reason is None:
            self.reason = []
        else:
            self.reason = reason
        if organizationCharacteristic is None:
            self.organizationCharacteristic = []
        else:
            self.organizationCharacteristic = organizationCharacteristic
        if transactionCharacteristic is None:
            self.transactionCharacteristic = []
        else:
            self.transactionCharacteristic = transactionCharacteristic
        if supervisorRegistration is None:
            self.supervisorRegistration = []
        else:
            self.supervisorRegistration = supervisorRegistration
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FacilityExecutionExceptionDeclaration)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FacilityExecutionExceptionDeclaration.subclass:
            return FacilityExecutionExceptionDeclaration.subclass(*args_, **kwargs_)
        else:
            return FacilityExecutionExceptionDeclaration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_reason(self): return self.reason
    def set_reason(self, reason): self.reason = reason
    def add_reason(self, value): self.reason.append(value)
    def insert_reason_at(self, index, value): self.reason.insert(index, value)
    def replace_reason_at(self, index, value): self.reason[index] = value
    def get_organizationCharacteristic(self): return self.organizationCharacteristic
    def set_organizationCharacteristic(self, organizationCharacteristic): self.organizationCharacteristic = organizationCharacteristic
    def add_organizationCharacteristic(self, value): self.organizationCharacteristic.append(value)
    def insert_organizationCharacteristic_at(self, index, value): self.organizationCharacteristic.insert(index, value)
    def replace_organizationCharacteristic_at(self, index, value): self.organizationCharacteristic[index] = value
    def get_transactionCharacteristic(self): return self.transactionCharacteristic
    def set_transactionCharacteristic(self, transactionCharacteristic): self.transactionCharacteristic = transactionCharacteristic
    def add_transactionCharacteristic(self, value): self.transactionCharacteristic.append(value)
    def insert_transactionCharacteristic_at(self, index, value): self.transactionCharacteristic.insert(index, value)
    def replace_transactionCharacteristic_at(self, index, value): self.transactionCharacteristic[index] = value
    def get_supervisorRegistration(self): return self.supervisorRegistration
    def set_supervisorRegistration(self, supervisorRegistration): self.supervisorRegistration = supervisorRegistration
    def add_supervisorRegistration(self, value): self.supervisorRegistration.append(value)
    def insert_supervisorRegistration_at(self, index, value): self.supervisorRegistration.insert(index, value)
    def replace_supervisorRegistration_at(self, index, value): self.supervisorRegistration[index] = value
    def validate_Token(self, value):
        # Validate type Token, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Token' % {"value" : value} )
    def hasContent_(self):
        if (
            self.reason or
            self.organizationCharacteristic or
            self.transactionCharacteristic or
            self.supervisorRegistration
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FacilityExecutionExceptionDeclaration', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FacilityExecutionExceptionDeclaration')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FacilityExecutionExceptionDeclaration', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FacilityExecutionExceptionDeclaration'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FacilityExecutionExceptionDeclaration', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for reason_ in self.reason:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreason>%s</%sreason>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(reason_), input_name='reason')), namespace_, eol_))
        for organizationCharacteristic_ in self.organizationCharacteristic:
            organizationCharacteristic_.export(outfile, level, namespace_, name_='organizationCharacteristic', pretty_print=pretty_print)
        for transactionCharacteristic_ in self.transactionCharacteristic:
            transactionCharacteristic_.export(outfile, level, namespace_, name_='transactionCharacteristic', pretty_print=pretty_print)
        for supervisorRegistration_ in self.supervisorRegistration:
            supervisorRegistration_.export(outfile, level, namespace_, name_='supervisorRegistration', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'reason':
            reason_ = child_.text
            reason_ = re_.sub(String_cleanup_pat_, " ", reason_).strip()
            reason_ = self.gds_validate_string(reason_, node, 'reason')
            self.reason.append(reason_)
            # validate type Token
            self.validate_Token(self.reason[-1])
        elif nodeName_ == 'organizationCharacteristic':
            obj_ = OrganizationCharacteristic.factory()
            obj_.build(child_)
            self.organizationCharacteristic.append(obj_)
            obj_.original_tagname_ = 'organizationCharacteristic'
        elif nodeName_ == 'transactionCharacteristic':
            obj_ = TransactionCharacteristic.factory()
            obj_.build(child_)
            self.transactionCharacteristic.append(obj_)
            obj_.original_tagname_ = 'transactionCharacteristic'
        elif nodeName_ == 'supervisorRegistration':
            obj_ = SupervisorRegistration.factory()
            obj_.build(child_)
            self.supervisorRegistration.append(obj_)
            obj_.original_tagname_ = 'supervisorRegistration'
# end class FacilityExecutionExceptionDeclaration


class FirstPeriodStartDate(GeneratedsSuper):
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
        'valueOf_': MemberSpec_('valueOf_', 'xsd:date', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, href=None, valueOf_=None):
        self.original_tagname_ = None
        self.href = _cast(None, href)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FirstPeriodStartDate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FirstPeriodStartDate.subclass:
            return FirstPeriodStartDate.subclass(*args_, **kwargs_)
        else:
            return FirstPeriodStartDate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FirstPeriodStartDate', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FirstPeriodStartDate')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FirstPeriodStartDate', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FirstPeriodStartDate'):
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='FirstPeriodStartDate', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FirstPeriodStartDate


class InstrumentTradeQuantity(GeneratedsSuper):
    """A structure describing the amount of an instrument that was traded."""
    member_data_items_ = {
        'number': MemberSpec_('number', 'xsd:decimal', 0),
        'nominal': MemberSpec_('nominal', 'Money', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, number=None, nominal=None):
        self.original_tagname_ = None
        self.number = number
        self.nominal = nominal
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InstrumentTradeQuantity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InstrumentTradeQuantity.subclass:
            return InstrumentTradeQuantity.subclass(*args_, **kwargs_)
        else:
            return InstrumentTradeQuantity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_number(self): return self.number
    def set_number(self, number): self.number = number
    def get_nominal(self): return self.nominal
    def set_nominal(self, nominal): self.nominal = nominal
    def hasContent_(self):
        if (
            self.number is not None or
            self.nominal is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InstrumentTradeQuantity', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InstrumentTradeQuantity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InstrumentTradeQuantity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InstrumentTradeQuantity'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='InstrumentTradeQuantity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.number is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumber>%s</%snumber>%s' % (namespace_, self.gds_format_float(self.number, input_name='number'), namespace_, eol_))
        if self.nominal is not None:
            self.nominal.export(outfile, level, namespace_, name_='nominal', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'number':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'number')
            self.number = fval_
        elif nodeName_ == 'nominal':
            obj_ = Money.factory()
            obj_.build(child_)
            self.nominal = obj_
            obj_.original_tagname_ = 'nominal'
# end class InstrumentTradeQuantity


class InstrumentTradePricing(GeneratedsSuper):
    """A structure describing the price paid for the instrument."""
    member_data_items_ = {
        'quote': MemberSpec_('quote', 'BasicQuotation', 1),
        'couponStartDate': MemberSpec_('couponStartDate', 'xsd:date', 0),
        'exDividendDate': MemberSpec_('exDividendDate', 'xsd:date', 0),
        'tradedFlatOfAccrued': MemberSpec_('tradedFlatOfAccrued', 'xsd:boolean', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, quote=None, couponStartDate=None, exDividendDate=None, tradedFlatOfAccrued=None):
        self.original_tagname_ = None
        if quote is None:
            self.quote = []
        else:
            self.quote = quote
        if isinstance(couponStartDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(couponStartDate, '%Y-%m-%d').date()
        else:
            initvalue_ = couponStartDate
        self.couponStartDate = initvalue_
        if isinstance(exDividendDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(exDividendDate, '%Y-%m-%d').date()
        else:
            initvalue_ = exDividendDate
        self.exDividendDate = initvalue_
        self.tradedFlatOfAccrued = tradedFlatOfAccrued
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InstrumentTradePricing)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InstrumentTradePricing.subclass:
            return InstrumentTradePricing.subclass(*args_, **kwargs_)
        else:
            return InstrumentTradePricing(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_quote(self): return self.quote
    def set_quote(self, quote): self.quote = quote
    def add_quote(self, value): self.quote.append(value)
    def insert_quote_at(self, index, value): self.quote.insert(index, value)
    def replace_quote_at(self, index, value): self.quote[index] = value
    def get_couponStartDate(self): return self.couponStartDate
    def set_couponStartDate(self, couponStartDate): self.couponStartDate = couponStartDate
    def get_exDividendDate(self): return self.exDividendDate
    def set_exDividendDate(self, exDividendDate): self.exDividendDate = exDividendDate
    def get_tradedFlatOfAccrued(self): return self.tradedFlatOfAccrued
    def set_tradedFlatOfAccrued(self, tradedFlatOfAccrued): self.tradedFlatOfAccrued = tradedFlatOfAccrued
    def hasContent_(self):
        if (
            self.quote or
            self.couponStartDate is not None or
            self.exDividendDate is not None or
            self.tradedFlatOfAccrued is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InstrumentTradePricing', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InstrumentTradePricing')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InstrumentTradePricing', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InstrumentTradePricing'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='InstrumentTradePricing', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for quote_ in self.quote:
            quote_.export(outfile, level, namespace_, name_='quote', pretty_print=pretty_print)
        if self.couponStartDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scouponStartDate>%s</%scouponStartDate>%s' % (namespace_, self.gds_format_date(self.couponStartDate, input_name='couponStartDate'), namespace_, eol_))
        if self.exDividendDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexDividendDate>%s</%sexDividendDate>%s' % (namespace_, self.gds_format_date(self.exDividendDate, input_name='exDividendDate'), namespace_, eol_))
        if self.tradedFlatOfAccrued is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stradedFlatOfAccrued>%s</%stradedFlatOfAccrued>%s' % (namespace_, self.gds_format_boolean(self.tradedFlatOfAccrued, input_name='tradedFlatOfAccrued'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'quote':
            obj_ = BasicQuotation.factory()
            obj_.build(child_)
            self.quote.append(obj_)
            obj_.original_tagname_ = 'quote'
        elif nodeName_ == 'couponStartDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.couponStartDate = dval_
        elif nodeName_ == 'exDividendDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.exDividendDate = dval_
        elif nodeName_ == 'tradedFlatOfAccrued':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'tradedFlatOfAccrued')
            self.tradedFlatOfAccrued = ival_
# end class InstrumentTradePricing


class InstrumentTradePrincipal(GeneratedsSuper):
    """A structure describing the value in "native" currency of an
    instrument that was traded."""
    member_data_items_ = {
        'principalAmount': MemberSpec_('principalAmount', 'NetAndGross', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, principalAmount=None):
        self.original_tagname_ = None
        self.principalAmount = principalAmount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InstrumentTradePrincipal)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InstrumentTradePrincipal.subclass:
            return InstrumentTradePrincipal.subclass(*args_, **kwargs_)
        else:
            return InstrumentTradePrincipal(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_principalAmount(self): return self.principalAmount
    def set_principalAmount(self, principalAmount): self.principalAmount = principalAmount
    def hasContent_(self):
        if (
            self.principalAmount is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InstrumentTradePrincipal', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InstrumentTradePrincipal')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InstrumentTradePrincipal', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InstrumentTradePrincipal'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='InstrumentTradePrincipal', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.principalAmount is not None:
            self.principalAmount.export(outfile, level, namespace_, name_='principalAmount', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'principalAmount':
            obj_ = NetAndGross.factory()
            obj_.build(child_)
            self.principalAmount = obj_
            obj_.original_tagname_ = 'principalAmount'
# end class InstrumentTradePrincipal


class LegalDocument(Document):
    """A structure describing the legal document."""
    member_data_items_ = {
        'documentHeader': MemberSpec_('documentHeader', 'LegalDocumentHeader', 0),
        'contractualDocument': MemberSpec_('contractualDocument', 'ContractualDocument', 0),
        'party': MemberSpec_('party', 'Party', 1),
        'account': MemberSpec_('account', 'Account', 1),
    }
    subclass = None
    superclass = Document
    def __init__(self, fpmlVersion=None, expectedBuild=None, actualBuild=None, documentHeader=None, contractualDocument=None, party=None, account=None):
        self.original_tagname_ = None
        super(LegalDocument, self).__init__(fpmlVersion, expectedBuild, actualBuild, )
        self.documentHeader = documentHeader
        self.contractualDocument = contractualDocument
        if party is None:
            self.party = []
        else:
            self.party = party
        if account is None:
            self.account = []
        else:
            self.account = account
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LegalDocument)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LegalDocument.subclass:
            return LegalDocument.subclass(*args_, **kwargs_)
        else:
            return LegalDocument(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_documentHeader(self): return self.documentHeader
    def set_documentHeader(self, documentHeader): self.documentHeader = documentHeader
    def get_contractualDocument(self): return self.contractualDocument
    def set_contractualDocument(self, contractualDocument): self.contractualDocument = contractualDocument
    def get_party(self): return self.party
    def set_party(self, party): self.party = party
    def add_party(self, value): self.party.append(value)
    def insert_party_at(self, index, value): self.party.insert(index, value)
    def replace_party_at(self, index, value): self.party[index] = value
    def get_account(self): return self.account
    def set_account(self, account): self.account = account
    def add_account(self, value): self.account.append(value)
    def insert_account_at(self, index, value): self.account.insert(index, value)
    def replace_account_at(self, index, value): self.account[index] = value
    def hasContent_(self):
        if (
            self.documentHeader is not None or
            self.contractualDocument is not None or
            self.party or
            self.account or
            super(LegalDocument, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LegalDocument', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LegalDocument')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LegalDocument', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LegalDocument'):
        super(LegalDocument, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LegalDocument')
    def exportChildren(self, outfile, level, namespace_='', name_='LegalDocument', fromsubclass_=False, pretty_print=True):
        super(LegalDocument, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.documentHeader is not None:
            self.documentHeader.export(outfile, level, namespace_, name_='documentHeader', pretty_print=pretty_print)
        if self.contractualDocument is not None:
            self.contractualDocument.export(outfile, level, namespace_, name_='contractualDocument', pretty_print=pretty_print)
        for party_ in self.party:
            party_.export(outfile, level, namespace_, name_='party', pretty_print=pretty_print)
        for account_ in self.account:
            account_.export(outfile, level, namespace_, name_='account', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LegalDocument, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'documentHeader':
            obj_ = LegalDocumentHeader.factory()
            obj_.build(child_)
            self.documentHeader = obj_
            obj_.original_tagname_ = 'documentHeader'
        elif nodeName_ == 'contractualDocument':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <contractualDocument> element')
            self.contractualDocument = obj_
            obj_.original_tagname_ = 'contractualDocument'
        elif nodeName_ == 'standardCsa':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <standardCsa> element')
            self.contractualDocument = obj_
            obj_.original_tagname_ = 'standardCsa'
        elif nodeName_ == 'standardCsa2013EnglishLaw':
            obj_ = StandardCreditSupportAnnex2013EnglishLaw.factory()
            obj_.build(child_)
            self.standardCsa = obj_
            obj_.original_tagname_ = 'standardCsa2013EnglishLaw'
        elif nodeName_ == 'standardCsa2014EnglishLaw':
            obj_ = StandardCreditSupportAnnex2014EnglishLaw.factory()
            obj_.build(child_)
            self.standardCsa = obj_
            obj_.original_tagname_ = 'standardCsa2014EnglishLaw'
        elif nodeName_ == 'standardCsa2013NewYorkLaw':
            obj_ = StandardCreditSupportAnnex2013NewYorkLaw.factory()
            obj_.build(child_)
            self.standardCsa = obj_
            obj_.original_tagname_ = 'standardCsa2013NewYorkLaw'
        elif nodeName_ == 'standardCsa2014NewYorkLaw':
            obj_ = StandardCreditSupportAnnex2014NewYorkLaw.factory()
            obj_.build(child_)
            self.standardCsa = obj_
            obj_.original_tagname_ = 'standardCsa2014NewYorkLaw'
        elif nodeName_ == 'party':
            obj_ = Party.factory()
            obj_.build(child_)
            self.party.append(obj_)
            obj_.original_tagname_ = 'party'
        elif nodeName_ == 'account':
            obj_ = Account.factory()
            obj_.build(child_)
            self.account.append(obj_)
            obj_.original_tagname_ = 'account'
        super(LegalDocument, self).buildChildren(child_, node, nodeName_, True)
# end class LegalDocument


class LinkId(GeneratedsSuper):
    """The data type used for link identifiers."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'linkIdScheme': MemberSpec_('linkIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, linkIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.linkIdScheme = _cast(None, linkIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LinkId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LinkId.subclass:
            return LinkId.subclass(*args_, **kwargs_)
        else:
            return LinkId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_linkIdScheme(self): return self.linkIdScheme
    def set_linkIdScheme(self, linkIdScheme): self.linkIdScheme = linkIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LinkId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinkId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LinkId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LinkId'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.linkIdScheme is not None and 'linkIdScheme' not in already_processed:
            already_processed.add('linkIdScheme')
            outfile.write(' linkIdScheme=%s' % (quote_attrib(self.linkIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LinkId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('linkIdScheme', node)
        if value is not None and 'linkIdScheme' not in already_processed:
            already_processed.add('linkIdScheme')
            self.linkIdScheme = value
            self.validate_NonEmptyURI(self.linkIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LinkId


class NetAndGross(GeneratedsSuper):
    """A structure including a net and/or a gross amount and possibly fees
    and commissions."""
    member_data_items_ = {
        'net': MemberSpec_('net', 'xsd:decimal', 0),
        'gross': MemberSpec_('gross', 'xsd:decimal', 0),
        'net': MemberSpec_('net', 'xsd:decimal', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, net=None, gross=None):
        self.original_tagname_ = None
        self.net = net
        self.gross = gross
        self.net = net
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NetAndGross)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NetAndGross.subclass:
            return NetAndGross.subclass(*args_, **kwargs_)
        else:
            return NetAndGross(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_net(self): return self.net
    def set_net(self, net): self.net = net
    def get_gross(self): return self.gross
    def set_gross(self, gross): self.gross = gross
    def get_net(self): return self.net
    def set_net(self, net): self.net = net
    def hasContent_(self):
        if (
            self.net is not None or
            self.gross is not None or
            self.net is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NetAndGross', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NetAndGross')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NetAndGross', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NetAndGross'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NetAndGross', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.net is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snet>%s</%snet>%s' % (namespace_, self.gds_format_float(self.net, input_name='net'), namespace_, eol_))
        if self.gross is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgross>%s</%sgross>%s' % (namespace_, self.gds_format_float(self.gross, input_name='gross'), namespace_, eol_))
        if self.net is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snet>%s</%snet>%s' % (namespace_, self.gds_format_float(self.net, input_name='net'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'net':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'net')
            self.net = fval_
        elif nodeName_ == 'gross':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'gross')
            self.gross = fval_
        elif nodeName_ == 'net':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'net')
            self.net = fval_
# end class NetAndGross


class OrderId(GeneratedsSuper):
    """A type that an identifier for an order."""
    member_data_items_ = {
        'orderIdScheme': MemberSpec_('orderIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, orderIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.orderIdScheme = _cast(None, orderIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OrderId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OrderId.subclass:
            return OrderId.subclass(*args_, **kwargs_)
        else:
            return OrderId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_orderIdScheme(self): return self.orderIdScheme
    def set_orderIdScheme(self, orderIdScheme): self.orderIdScheme = orderIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OrderId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OrderId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OrderId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OrderId'):
        if self.orderIdScheme is not None and 'orderIdScheme' not in already_processed:
            already_processed.add('orderIdScheme')
            outfile.write(' orderIdScheme=%s' % (quote_attrib(self.orderIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OrderId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('orderIdScheme', node)
        if value is not None and 'orderIdScheme' not in already_processed:
            already_processed.add('orderIdScheme')
            self.orderIdScheme = value
            self.validate_NonEmptyURI(self.orderIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OrderId


class OrderIdentifier(GeneratedsSuper):
    """A type that an order's identifier(s)."""
    member_data_items_ = {
        'orderId': MemberSpec_('orderId', 'OrderId', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, orderId=None):
        self.original_tagname_ = None
        self.orderId = orderId
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OrderIdentifier)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OrderIdentifier.subclass:
            return OrderIdentifier.subclass(*args_, **kwargs_)
        else:
            return OrderIdentifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_orderId(self): return self.orderId
    def set_orderId(self, orderId): self.orderId = orderId
    def hasContent_(self):
        if (
            self.orderId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OrderIdentifier', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OrderIdentifier')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OrderIdentifier', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OrderIdentifier'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OrderIdentifier', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orderId is not None:
            self.orderId.export(outfile, level, namespace_, name_='orderId', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orderId':
            obj_ = OrderId.factory()
            obj_.build(child_)
            self.orderId = obj_
            obj_.original_tagname_ = 'orderId'
# end class OrderIdentifier


class OrganizationCharacteristic(GeneratedsSuper):
    """A characteristic of an organization used in declaring an end-user
    exception."""
    member_data_items_ = {
        'organizationCharacteristicScheme': MemberSpec_('organizationCharacteristicScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, organizationCharacteristicScheme='http://www.fpml.org/coding-scheme/organization-characteristic', valueOf_=None):
        self.original_tagname_ = None
        self.organizationCharacteristicScheme = _cast(None, organizationCharacteristicScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OrganizationCharacteristic)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OrganizationCharacteristic.subclass:
            return OrganizationCharacteristic.subclass(*args_, **kwargs_)
        else:
            return OrganizationCharacteristic(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_organizationCharacteristicScheme(self): return self.organizationCharacteristicScheme
    def set_organizationCharacteristicScheme(self, organizationCharacteristicScheme): self.organizationCharacteristicScheme = organizationCharacteristicScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OrganizationCharacteristic', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OrganizationCharacteristic')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OrganizationCharacteristic', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OrganizationCharacteristic'):
        if self.organizationCharacteristicScheme != "http://www.fpml.org/coding-scheme/organization-characteristic" and 'organizationCharacteristicScheme' not in already_processed:
            already_processed.add('organizationCharacteristicScheme')
            outfile.write(' organizationCharacteristicScheme=%s' % (quote_attrib(self.organizationCharacteristicScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OrganizationCharacteristic', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('organizationCharacteristicScheme', node)
        if value is not None and 'organizationCharacteristicScheme' not in already_processed:
            already_processed.add('organizationCharacteristicScheme')
            self.organizationCharacteristicScheme = value
            self.validate_NonEmptyURI(self.organizationCharacteristicScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OrganizationCharacteristic


class OtcClassification(GeneratedsSuper):
    """Indicator as to the type of transaction in accordance with Articles
    20(3)(a) and 21(5)(a) of Regulation (EU) 600/2014."""
    member_data_items_ = {
        'otcClassificationScheme': MemberSpec_('otcClassificationScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, otcClassificationScheme='http://www.fpml.org/coding-scheme/mifir/otc-classification', valueOf_=None):
        self.original_tagname_ = None
        self.otcClassificationScheme = _cast(None, otcClassificationScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OtcClassification)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OtcClassification.subclass:
            return OtcClassification.subclass(*args_, **kwargs_)
        else:
            return OtcClassification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_otcClassificationScheme(self): return self.otcClassificationScheme
    def set_otcClassificationScheme(self, otcClassificationScheme): self.otcClassificationScheme = otcClassificationScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OtcClassification', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OtcClassification')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OtcClassification', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OtcClassification'):
        if self.otcClassificationScheme != "http://www.fpml.org/coding-scheme/mifir/otc-classification" and 'otcClassificationScheme' not in already_processed:
            already_processed.add('otcClassificationScheme')
            outfile.write(' otcClassificationScheme=%s' % (quote_attrib(self.otcClassificationScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OtcClassification', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('otcClassificationScheme', node)
        if value is not None and 'otcClassificationScheme' not in already_processed:
            already_processed.add('otcClassificationScheme')
            self.otcClassificationScheme = value
            self.validate_NonEmptyURI(self.otcClassificationScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OtcClassification


class PackageInformation(GeneratedsSuper):
    """A type defining additional information that may be recorded against
    a package of trades."""
    member_data_items_ = {
        'relatedParty': MemberSpec_('relatedParty', 'RelatedParty', 1),
        'category': MemberSpec_('category', 'TradeCategory', 1),
        'executionDateTime': MemberSpec_('executionDateTime', 'ExecutionDateTime', 0),
        'timestamps': MemberSpec_('timestamps', 'TradeProcessingTimestamps', 0),
        'intentToAllocate': MemberSpec_('intentToAllocate', 'xsd:boolean', 0),
        'allocationStatus': MemberSpec_('allocationStatus', 'AllocationReportingStatus', 0),
        'intentToClear': MemberSpec_('intentToClear', 'xsd:boolean', 0),
        'clearingStatus': MemberSpec_('clearingStatus', 'ClearingStatusValue', 0),
        'executionVenueType': MemberSpec_('executionVenueType', 'ExecutionVenueType', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, relatedParty=None, category=None, executionDateTime=None, timestamps=None, intentToAllocate=None, allocationStatus=None, intentToClear=None, clearingStatus=None, executionVenueType=None):
        self.original_tagname_ = None
        if relatedParty is None:
            self.relatedParty = []
        else:
            self.relatedParty = relatedParty
        if category is None:
            self.category = []
        else:
            self.category = category
        self.executionDateTime = executionDateTime
        self.timestamps = timestamps
        self.intentToAllocate = intentToAllocate
        self.allocationStatus = allocationStatus
        self.intentToClear = intentToClear
        self.clearingStatus = clearingStatus
        self.executionVenueType = executionVenueType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PackageInformation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PackageInformation.subclass:
            return PackageInformation.subclass(*args_, **kwargs_)
        else:
            return PackageInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_relatedParty(self): return self.relatedParty
    def set_relatedParty(self, relatedParty): self.relatedParty = relatedParty
    def add_relatedParty(self, value): self.relatedParty.append(value)
    def insert_relatedParty_at(self, index, value): self.relatedParty.insert(index, value)
    def replace_relatedParty_at(self, index, value): self.relatedParty[index] = value
    def get_category(self): return self.category
    def set_category(self, category): self.category = category
    def add_category(self, value): self.category.append(value)
    def insert_category_at(self, index, value): self.category.insert(index, value)
    def replace_category_at(self, index, value): self.category[index] = value
    def get_executionDateTime(self): return self.executionDateTime
    def set_executionDateTime(self, executionDateTime): self.executionDateTime = executionDateTime
    def get_timestamps(self): return self.timestamps
    def set_timestamps(self, timestamps): self.timestamps = timestamps
    def get_intentToAllocate(self): return self.intentToAllocate
    def set_intentToAllocate(self, intentToAllocate): self.intentToAllocate = intentToAllocate
    def get_allocationStatus(self): return self.allocationStatus
    def set_allocationStatus(self, allocationStatus): self.allocationStatus = allocationStatus
    def get_intentToClear(self): return self.intentToClear
    def set_intentToClear(self, intentToClear): self.intentToClear = intentToClear
    def get_clearingStatus(self): return self.clearingStatus
    def set_clearingStatus(self, clearingStatus): self.clearingStatus = clearingStatus
    def get_executionVenueType(self): return self.executionVenueType
    def set_executionVenueType(self, executionVenueType): self.executionVenueType = executionVenueType
    def hasContent_(self):
        if (
            self.relatedParty or
            self.category or
            self.executionDateTime is not None or
            self.timestamps is not None or
            self.intentToAllocate is not None or
            self.allocationStatus is not None or
            self.intentToClear is not None or
            self.clearingStatus is not None or
            self.executionVenueType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PackageInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PackageInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PackageInformation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PackageInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PackageInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for relatedParty_ in self.relatedParty:
            relatedParty_.export(outfile, level, namespace_, name_='relatedParty', pretty_print=pretty_print)
        for category_ in self.category:
            category_.export(outfile, level, namespace_, name_='category', pretty_print=pretty_print)
        if self.executionDateTime is not None:
            self.executionDateTime.export(outfile, level, namespace_, name_='executionDateTime', pretty_print=pretty_print)
        if self.timestamps is not None:
            self.timestamps.export(outfile, level, namespace_, name_='timestamps', pretty_print=pretty_print)
        if self.intentToAllocate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sintentToAllocate>%s</%sintentToAllocate>%s' % (namespace_, self.gds_format_boolean(self.intentToAllocate, input_name='intentToAllocate'), namespace_, eol_))
        if self.allocationStatus is not None:
            self.allocationStatus.export(outfile, level, namespace_, name_='allocationStatus', pretty_print=pretty_print)
        if self.intentToClear is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sintentToClear>%s</%sintentToClear>%s' % (namespace_, self.gds_format_boolean(self.intentToClear, input_name='intentToClear'), namespace_, eol_))
        if self.clearingStatus is not None:
            self.clearingStatus.export(outfile, level, namespace_, name_='clearingStatus', pretty_print=pretty_print)
        if self.executionVenueType is not None:
            self.executionVenueType.export(outfile, level, namespace_, name_='executionVenueType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'relatedParty':
            obj_ = RelatedParty.factory()
            obj_.build(child_)
            self.relatedParty.append(obj_)
            obj_.original_tagname_ = 'relatedParty'
        elif nodeName_ == 'category':
            obj_ = TradeCategory.factory()
            obj_.build(child_)
            self.category.append(obj_)
            obj_.original_tagname_ = 'category'
        elif nodeName_ == 'executionDateTime':
            obj_ = ExecutionDateTime.factory()
            obj_.build(child_)
            self.executionDateTime = obj_
            obj_.original_tagname_ = 'executionDateTime'
        elif nodeName_ == 'timestamps':
            obj_ = TradeProcessingTimestamps.factory()
            obj_.build(child_)
            self.timestamps = obj_
            obj_.original_tagname_ = 'timestamps'
        elif nodeName_ == 'intentToAllocate':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'intentToAllocate')
            self.intentToAllocate = ival_
        elif nodeName_ == 'allocationStatus':
            obj_ = AllocationReportingStatus.factory()
            obj_.build(child_)
            self.allocationStatus = obj_
            obj_.original_tagname_ = 'allocationStatus'
        elif nodeName_ == 'intentToClear':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'intentToClear')
            self.intentToClear = ival_
        elif nodeName_ == 'clearingStatus':
            obj_ = ClearingStatusValue.factory()
            obj_.build(child_)
            self.clearingStatus = obj_
            obj_.original_tagname_ = 'clearingStatus'
        elif nodeName_ == 'executionVenueType':
            obj_ = ExecutionVenueType.factory()
            obj_.build(child_)
            self.executionVenueType = obj_
            obj_.original_tagname_ = 'executionVenueType'
# end class PackageInformation


class PackageSummary(GeneratedsSuper):
    """Summary information about a trade package."""
    member_data_items_ = {
        'packageIdentifier': MemberSpec_('packageIdentifier', 'IssuerTradeId', 0),
        'orderIdentifier': MemberSpec_('orderIdentifier', 'OrderIdentifier', 0),
        'packageType': MemberSpec_('packageType', 'PackageType', 1),
        'size': MemberSpec_('size', ['PositiveDecimal', 'xsd:decimal'], 0),
        'sequenceNumber': MemberSpec_('sequenceNumber', ['PositiveDecimal', 'xsd:decimal'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, packageIdentifier=None, orderIdentifier=None, packageType=None, size=None, sequenceNumber=None):
        self.original_tagname_ = None
        self.packageIdentifier = packageIdentifier
        self.orderIdentifier = orderIdentifier
        if packageType is None:
            self.packageType = []
        else:
            self.packageType = packageType
        self.size = size
        self.validate_PositiveDecimal(self.size)
        self.sequenceNumber = sequenceNumber
        self.validate_PositiveDecimal(self.sequenceNumber)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PackageSummary)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PackageSummary.subclass:
            return PackageSummary.subclass(*args_, **kwargs_)
        else:
            return PackageSummary(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_packageIdentifier(self): return self.packageIdentifier
    def set_packageIdentifier(self, packageIdentifier): self.packageIdentifier = packageIdentifier
    def get_orderIdentifier(self): return self.orderIdentifier
    def set_orderIdentifier(self, orderIdentifier): self.orderIdentifier = orderIdentifier
    def get_packageType(self): return self.packageType
    def set_packageType(self, packageType): self.packageType = packageType
    def add_packageType(self, value): self.packageType.append(value)
    def insert_packageType_at(self, index, value): self.packageType.insert(index, value)
    def replace_packageType_at(self, index, value): self.packageType[index] = value
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def validate_PositiveDecimal(self, value):
        # Validate type PositiveDecimal, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value <= 0:
                warnings_.warn('Value "%(value)s" does not match xsd minExclusive restriction on PositiveDecimal' % {"value" : value} )
    def hasContent_(self):
        if (
            self.packageIdentifier is not None or
            self.orderIdentifier is not None or
            self.packageType or
            self.size is not None or
            self.sequenceNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PackageSummary', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PackageSummary')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PackageSummary', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PackageSummary'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PackageSummary', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.packageIdentifier is not None:
            self.packageIdentifier.export(outfile, level, namespace_, name_='packageIdentifier', pretty_print=pretty_print)
        if self.orderIdentifier is not None:
            self.orderIdentifier.export(outfile, level, namespace_, name_='orderIdentifier', pretty_print=pretty_print)
        for packageType_ in self.packageType:
            packageType_.export(outfile, level, namespace_, name_='packageType', pretty_print=pretty_print)
        if self.size is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssize>%s</%ssize>%s' % (namespace_, self.gds_format_float(self.size, input_name='size'), namespace_, eol_))
        if self.sequenceNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssequenceNumber>%s</%ssequenceNumber>%s' % (namespace_, self.gds_format_float(self.sequenceNumber, input_name='sequenceNumber'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'packageIdentifier':
            obj_ = IssuerTradeId.factory()
            obj_.build(child_)
            self.packageIdentifier = obj_
            obj_.original_tagname_ = 'packageIdentifier'
        elif nodeName_ == 'orderIdentifier':
            obj_ = OrderIdentifier.factory()
            obj_.build(child_)
            self.orderIdentifier = obj_
            obj_.original_tagname_ = 'orderIdentifier'
        elif nodeName_ == 'packageType':
            obj_ = PackageType.factory()
            obj_.build(child_)
            self.packageType.append(obj_)
            obj_.original_tagname_ = 'packageType'
        elif nodeName_ == 'size':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'size')
            self.size = fval_
            # validate type PositiveDecimal
            self.validate_PositiveDecimal(self.size)
        elif nodeName_ == 'sequenceNumber':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'sequenceNumber')
            self.sequenceNumber = fval_
            # validate type PositiveDecimal
            self.validate_PositiveDecimal(self.sequenceNumber)
# end class PackageSummary


class PackageType(GeneratedsSuper):
    """A type that describes what thpe of package this is, e.g. Butterfly."""
    member_data_items_ = {
        'packageTypeScheme': MemberSpec_('packageTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, packageTypeScheme='http://www.fpml.org/coding-scheme/package-type', valueOf_=None):
        self.original_tagname_ = None
        self.packageTypeScheme = _cast(None, packageTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PackageType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PackageType.subclass:
            return PackageType.subclass(*args_, **kwargs_)
        else:
            return PackageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_packageTypeScheme(self): return self.packageTypeScheme
    def set_packageTypeScheme(self, packageTypeScheme): self.packageTypeScheme = packageTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PackageType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PackageType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PackageType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PackageType'):
        if self.packageTypeScheme != "http://www.fpml.org/coding-scheme/package-type" and 'packageTypeScheme' not in already_processed:
            already_processed.add('packageTypeScheme')
            outfile.write(' packageTypeScheme=%s' % (quote_attrib(self.packageTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PackageType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('packageTypeScheme', node)
        if value is not None and 'packageTypeScheme' not in already_processed:
            already_processed.add('packageTypeScheme')
            self.packageTypeScheme = value
            self.validate_NonEmptyURI(self.packageTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PackageType


class PartyEntityClassification(GeneratedsSuper):
    """A type that specifies the classification of a party."""
    member_data_items_ = {
        'partyReference': MemberSpec_('partyReference', 'PartyReference', 0),
        'entityClassification': MemberSpec_('entityClassification', 'EntityClassification', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, partyReference=None, entityClassification=None):
        self.original_tagname_ = None
        self.partyReference = partyReference
        self.entityClassification = entityClassification
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyEntityClassification)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyEntityClassification.subclass:
            return PartyEntityClassification.subclass(*args_, **kwargs_)
        else:
            return PartyEntityClassification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyReference(self): return self.partyReference
    def set_partyReference(self, partyReference): self.partyReference = partyReference
    def get_entityClassification(self): return self.entityClassification
    def set_entityClassification(self, entityClassification): self.entityClassification = entityClassification
    def hasContent_(self):
        if (
            self.partyReference is not None or
            self.entityClassification is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartyEntityClassification', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyEntityClassification')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartyEntityClassification', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyEntityClassification'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PartyEntityClassification', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.partyReference is not None:
            self.partyReference.export(outfile, level, namespace_, name_='partyReference', pretty_print=pretty_print)
        if self.entityClassification is not None:
            self.entityClassification.export(outfile, level, namespace_, name_='entityClassification', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'partyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.partyReference = obj_
            obj_.original_tagname_ = 'partyReference'
        elif nodeName_ == 'entityClassification':
            obj_ = EntityClassification.factory()
            obj_.build(child_)
            self.entityClassification = obj_
            obj_.original_tagname_ = 'entityClassification'
# end class PartyEntityClassification


class PartyPortfolioName(GeneratedsSuper):
    """A type to represent a portfolio name for a particular party."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'partyReference': MemberSpec_('partyReference', 'PartyReference', 0),
        'portfolioName': MemberSpec_('portfolioName', 'PortfolioName', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, partyReference=None, portfolioName=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.partyReference = partyReference
        if portfolioName is None:
            self.portfolioName = []
        else:
            self.portfolioName = portfolioName
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyPortfolioName)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyPortfolioName.subclass:
            return PartyPortfolioName.subclass(*args_, **kwargs_)
        else:
            return PartyPortfolioName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyReference(self): return self.partyReference
    def set_partyReference(self, partyReference): self.partyReference = partyReference
    def get_portfolioName(self): return self.portfolioName
    def set_portfolioName(self, portfolioName): self.portfolioName = portfolioName
    def add_portfolioName(self, value): self.portfolioName.append(value)
    def insert_portfolioName_at(self, index, value): self.portfolioName.insert(index, value)
    def replace_portfolioName_at(self, index, value): self.portfolioName[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.partyReference is not None or
            self.portfolioName
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartyPortfolioName', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyPortfolioName')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartyPortfolioName', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyPortfolioName'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PartyPortfolioName', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.partyReference is not None:
            self.partyReference.export(outfile, level, namespace_, name_='partyReference', pretty_print=pretty_print)
        for portfolioName_ in self.portfolioName:
            portfolioName_.export(outfile, level, namespace_, name_='portfolioName', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'partyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.partyReference = obj_
            obj_.original_tagname_ = 'partyReference'
        elif nodeName_ == 'portfolioName':
            obj_ = PortfolioName.factory()
            obj_.build(child_)
            self.portfolioName.append(obj_)
            obj_.original_tagname_ = 'portfolioName'
# end class PartyPortfolioName


class PartyRelationshipType(GeneratedsSuper):
    """A type containing a code representing how two parties are related,
    e.g. Affiliated, Intragroup, None."""
    member_data_items_ = {
        'partyRelationshipTypeScheme': MemberSpec_('partyRelationshipTypeScheme', 'NonEmptyURI', 0),
        'id': MemberSpec_('id', 'xsd:string', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, partyRelationshipTypeScheme='http://www.fpml.org/coding-scheme/party-relationship-type', id=None, valueOf_=None):
        self.original_tagname_ = None
        self.partyRelationshipTypeScheme = _cast(None, partyRelationshipTypeScheme)
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyRelationshipType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyRelationshipType.subclass:
            return PartyRelationshipType.subclass(*args_, **kwargs_)
        else:
            return PartyRelationshipType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyRelationshipTypeScheme(self): return self.partyRelationshipTypeScheme
    def set_partyRelationshipTypeScheme(self, partyRelationshipTypeScheme): self.partyRelationshipTypeScheme = partyRelationshipTypeScheme
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartyRelationshipType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyRelationshipType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartyRelationshipType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyRelationshipType'):
        if self.partyRelationshipTypeScheme != "http://www.fpml.org/coding-scheme/party-relationship-type" and 'partyRelationshipTypeScheme' not in already_processed:
            already_processed.add('partyRelationshipTypeScheme')
            outfile.write(' partyRelationshipTypeScheme=%s' % (quote_attrib(self.partyRelationshipTypeScheme), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PartyRelationshipType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partyRelationshipTypeScheme', node)
        if value is not None and 'partyRelationshipTypeScheme' not in already_processed:
            already_processed.add('partyRelationshipTypeScheme')
            self.partyRelationshipTypeScheme = value
            self.validate_NonEmptyURI(self.partyRelationshipTypeScheme)    # validate type NonEmptyURI
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PartyRelationshipType


class PartyTradeIdentifiers(GeneratedsSuper):
    """A type containing multiple partyTradeIdentifier."""
    member_data_items_ = {
        'partyTradeIdentifier': MemberSpec_('partyTradeIdentifier', 'PartyTradeIdentifier', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, partyTradeIdentifier=None):
        self.original_tagname_ = None
        if partyTradeIdentifier is None:
            self.partyTradeIdentifier = []
        else:
            self.partyTradeIdentifier = partyTradeIdentifier
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyTradeIdentifiers)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyTradeIdentifiers.subclass:
            return PartyTradeIdentifiers.subclass(*args_, **kwargs_)
        else:
            return PartyTradeIdentifiers(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyTradeIdentifier(self): return self.partyTradeIdentifier
    def set_partyTradeIdentifier(self, partyTradeIdentifier): self.partyTradeIdentifier = partyTradeIdentifier
    def add_partyTradeIdentifier(self, value): self.partyTradeIdentifier.append(value)
    def insert_partyTradeIdentifier_at(self, index, value): self.partyTradeIdentifier.insert(index, value)
    def replace_partyTradeIdentifier_at(self, index, value): self.partyTradeIdentifier[index] = value
    def hasContent_(self):
        if (
            self.partyTradeIdentifier
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartyTradeIdentifiers', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyTradeIdentifiers')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartyTradeIdentifiers', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyTradeIdentifiers'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PartyTradeIdentifiers', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for partyTradeIdentifier_ in self.partyTradeIdentifier:
            partyTradeIdentifier_.export(outfile, level, namespace_, name_='partyTradeIdentifier', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'partyTradeIdentifier':
            obj_ = PartyTradeIdentifier.factory()
            obj_.build(child_)
            self.partyTradeIdentifier.append(obj_)
            obj_.original_tagname_ = 'partyTradeIdentifier'
# end class PartyTradeIdentifiers


class PartyTradeInformation(GeneratedsSuper):
    """A type defining party-specific additional information that may be
    recorded against a trade."""
    member_data_items_ = {
        'partyReference': MemberSpec_('partyReference', 'PartyReference', 0),
        'accountReference': MemberSpec_('accountReference', 'AccountReference', 0),
        'relatedParty': MemberSpec_('relatedParty', 'RelatedParty', 1),
        'reportingRole': MemberSpec_('reportingRole', 'ReportingRole', 0),
        'description': MemberSpec_('description', ['String', 'xsd:string'], 0),
        'unit': MemberSpec_('unit', 'Unit', 1),
        'relatedBusinessUnit': MemberSpec_('relatedBusinessUnit', 'RelatedBusinessUnit', 1),
        'relatedPerson': MemberSpec_('relatedPerson', 'RelatedPerson', 1),
        'algorithm': MemberSpec_('algorithm', 'Algorithm', 1),
        'isAccountingHedge': MemberSpec_('isAccountingHedge', 'xsd:boolean', 0),
        'category': MemberSpec_('category', 'TradeCategory', 1),
        'trader': MemberSpec_('trader', 'Trader', 1),
        'executionDateTime': MemberSpec_('executionDateTime', 'ExecutionDateTime', 0),
        'timestamps': MemberSpec_('timestamps', 'TradeProcessingTimestamps', 0),
        'intentToAllocate': MemberSpec_('intentToAllocate', 'xsd:boolean', 0),
        'allocationStatus': MemberSpec_('allocationStatus', 'AllocationReportingStatus', 0),
        'intentToClear': MemberSpec_('intentToClear', 'xsd:boolean', 0),
        'clearingStatus': MemberSpec_('clearingStatus', 'ClearingStatusValue', 0),
        'collateralizationType': MemberSpec_('collateralizationType', 'CollateralizationType', 0),
        'collateralPortfolio': MemberSpec_('collateralPortfolio', 'PortfolioName', 0),
        'reportingRegime': MemberSpec_('reportingRegime', 'ReportingRegime', 1),
        'endUserException': MemberSpec_('endUserException', 'xsd:boolean', 0),
        'endUserExceptionReason': MemberSpec_('endUserExceptionReason', 'ClearingExceptionReason', 0),
        'endUserExceptionDeclaration': MemberSpec_('endUserExceptionDeclaration', 'EndUserExceptionDeclaration', 0),
        'nonStandardTerms': MemberSpec_('nonStandardTerms', 'xsd:boolean', 0),
        'offMarketPrice': MemberSpec_('offMarketPrice', 'xsd:boolean', 0),
        'pricingContext': MemberSpec_('pricingContext', 'PricingContext', 0),
        'largeSizeTrade': MemberSpec_('largeSizeTrade', 'xsd:boolean', 0),
        'executionType': MemberSpec_('executionType', 'ExecutionType', 0),
        'executionVenueType': MemberSpec_('executionVenueType', 'ExecutionVenueType', 0),
        'verificationMethod': MemberSpec_('verificationMethod', 'VerificationMethod', 0),
        'confirmationMethod': MemberSpec_('confirmationMethod', 'ConfirmationMethod', 0),
        'compressedTrade': MemberSpec_('compressedTrade', 'xsd:boolean', 0),
        'isSecuritiesFinancing': MemberSpec_('isSecuritiesFinancing', 'xsd:boolean', 0),
        'notionalChange': MemberSpec_('notionalChange', ['NotionalChangeEnum', 'xsd:token'], 0),
        'otcClassification': MemberSpec_('otcClassification', 'OtcClassification', 0),
        'tradingWaiver': MemberSpec_('tradingWaiver', 'TradingWaiver', 0),
        'shortSale': MemberSpec_('shortSale', 'ShortSale', 0),
        'isCommodityHedge': MemberSpec_('isCommodityHedge', 'xsd:boolean', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, partyReference=None, accountReference=None, relatedParty=None, reportingRole=None, description=None, unit=None, relatedBusinessUnit=None, relatedPerson=None, algorithm=None, isAccountingHedge=None, category=None, trader=None, executionDateTime=None, timestamps=None, intentToAllocate=None, allocationStatus=None, intentToClear=None, clearingStatus=None, collateralizationType=None, collateralPortfolio=None, reportingRegime=None, endUserException=None, endUserExceptionReason=None, endUserExceptionDeclaration=None, nonStandardTerms=None, offMarketPrice=None, pricingContext=None, largeSizeTrade=None, executionType=None, executionVenueType=None, verificationMethod=None, confirmationMethod=None, compressedTrade=None, isSecuritiesFinancing=None, notionalChange=None, otcClassification=None, tradingWaiver=None, shortSale=None, isCommodityHedge=None):
        self.original_tagname_ = None
        self.partyReference = partyReference
        self.accountReference = accountReference
        if relatedParty is None:
            self.relatedParty = []
        else:
            self.relatedParty = relatedParty
        self.reportingRole = reportingRole
        self.description = description
        self.validate_String(self.description)
        if unit is None:
            self.unit = []
        else:
            self.unit = unit
        if relatedBusinessUnit is None:
            self.relatedBusinessUnit = []
        else:
            self.relatedBusinessUnit = relatedBusinessUnit
        if relatedPerson is None:
            self.relatedPerson = []
        else:
            self.relatedPerson = relatedPerson
        if algorithm is None:
            self.algorithm = []
        else:
            self.algorithm = algorithm
        self.isAccountingHedge = isAccountingHedge
        if category is None:
            self.category = []
        else:
            self.category = category
        if trader is None:
            self.trader = []
        else:
            self.trader = trader
        self.executionDateTime = executionDateTime
        self.timestamps = timestamps
        self.intentToAllocate = intentToAllocate
        self.allocationStatus = allocationStatus
        self.intentToClear = intentToClear
        self.clearingStatus = clearingStatus
        self.collateralizationType = collateralizationType
        self.collateralPortfolio = collateralPortfolio
        if reportingRegime is None:
            self.reportingRegime = []
        else:
            self.reportingRegime = reportingRegime
        self.endUserException = endUserException
        self.endUserExceptionReason = endUserExceptionReason
        self.endUserExceptionDeclaration = endUserExceptionDeclaration
        self.nonStandardTerms = nonStandardTerms
        self.offMarketPrice = offMarketPrice
        self.pricingContext = pricingContext
        self.largeSizeTrade = largeSizeTrade
        self.executionType = executionType
        self.executionVenueType = executionVenueType
        self.verificationMethod = verificationMethod
        self.confirmationMethod = confirmationMethod
        self.compressedTrade = compressedTrade
        self.isSecuritiesFinancing = isSecuritiesFinancing
        self.notionalChange = notionalChange
        self.validate_NotionalChangeEnum(self.notionalChange)
        self.otcClassification = otcClassification
        self.tradingWaiver = tradingWaiver
        self.shortSale = shortSale
        self.isCommodityHedge = isCommodityHedge
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyTradeInformation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyTradeInformation.subclass:
            return PartyTradeInformation.subclass(*args_, **kwargs_)
        else:
            return PartyTradeInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyReference(self): return self.partyReference
    def set_partyReference(self, partyReference): self.partyReference = partyReference
    def get_accountReference(self): return self.accountReference
    def set_accountReference(self, accountReference): self.accountReference = accountReference
    def get_relatedParty(self): return self.relatedParty
    def set_relatedParty(self, relatedParty): self.relatedParty = relatedParty
    def add_relatedParty(self, value): self.relatedParty.append(value)
    def insert_relatedParty_at(self, index, value): self.relatedParty.insert(index, value)
    def replace_relatedParty_at(self, index, value): self.relatedParty[index] = value
    def get_reportingRole(self): return self.reportingRole
    def set_reportingRole(self, reportingRole): self.reportingRole = reportingRole
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def add_unit(self, value): self.unit.append(value)
    def insert_unit_at(self, index, value): self.unit.insert(index, value)
    def replace_unit_at(self, index, value): self.unit[index] = value
    def get_relatedBusinessUnit(self): return self.relatedBusinessUnit
    def set_relatedBusinessUnit(self, relatedBusinessUnit): self.relatedBusinessUnit = relatedBusinessUnit
    def add_relatedBusinessUnit(self, value): self.relatedBusinessUnit.append(value)
    def insert_relatedBusinessUnit_at(self, index, value): self.relatedBusinessUnit.insert(index, value)
    def replace_relatedBusinessUnit_at(self, index, value): self.relatedBusinessUnit[index] = value
    def get_relatedPerson(self): return self.relatedPerson
    def set_relatedPerson(self, relatedPerson): self.relatedPerson = relatedPerson
    def add_relatedPerson(self, value): self.relatedPerson.append(value)
    def insert_relatedPerson_at(self, index, value): self.relatedPerson.insert(index, value)
    def replace_relatedPerson_at(self, index, value): self.relatedPerson[index] = value
    def get_algorithm(self): return self.algorithm
    def set_algorithm(self, algorithm): self.algorithm = algorithm
    def add_algorithm(self, value): self.algorithm.append(value)
    def insert_algorithm_at(self, index, value): self.algorithm.insert(index, value)
    def replace_algorithm_at(self, index, value): self.algorithm[index] = value
    def get_isAccountingHedge(self): return self.isAccountingHedge
    def set_isAccountingHedge(self, isAccountingHedge): self.isAccountingHedge = isAccountingHedge
    def get_category(self): return self.category
    def set_category(self, category): self.category = category
    def add_category(self, value): self.category.append(value)
    def insert_category_at(self, index, value): self.category.insert(index, value)
    def replace_category_at(self, index, value): self.category[index] = value
    def get_trader(self): return self.trader
    def set_trader(self, trader): self.trader = trader
    def add_trader(self, value): self.trader.append(value)
    def insert_trader_at(self, index, value): self.trader.insert(index, value)
    def replace_trader_at(self, index, value): self.trader[index] = value
    def get_executionDateTime(self): return self.executionDateTime
    def set_executionDateTime(self, executionDateTime): self.executionDateTime = executionDateTime
    def get_timestamps(self): return self.timestamps
    def set_timestamps(self, timestamps): self.timestamps = timestamps
    def get_intentToAllocate(self): return self.intentToAllocate
    def set_intentToAllocate(self, intentToAllocate): self.intentToAllocate = intentToAllocate
    def get_allocationStatus(self): return self.allocationStatus
    def set_allocationStatus(self, allocationStatus): self.allocationStatus = allocationStatus
    def get_intentToClear(self): return self.intentToClear
    def set_intentToClear(self, intentToClear): self.intentToClear = intentToClear
    def get_clearingStatus(self): return self.clearingStatus
    def set_clearingStatus(self, clearingStatus): self.clearingStatus = clearingStatus
    def get_collateralizationType(self): return self.collateralizationType
    def set_collateralizationType(self, collateralizationType): self.collateralizationType = collateralizationType
    def get_collateralPortfolio(self): return self.collateralPortfolio
    def set_collateralPortfolio(self, collateralPortfolio): self.collateralPortfolio = collateralPortfolio
    def get_reportingRegime(self): return self.reportingRegime
    def set_reportingRegime(self, reportingRegime): self.reportingRegime = reportingRegime
    def add_reportingRegime(self, value): self.reportingRegime.append(value)
    def insert_reportingRegime_at(self, index, value): self.reportingRegime.insert(index, value)
    def replace_reportingRegime_at(self, index, value): self.reportingRegime[index] = value
    def get_endUserException(self): return self.endUserException
    def set_endUserException(self, endUserException): self.endUserException = endUserException
    def get_endUserExceptionReason(self): return self.endUserExceptionReason
    def set_endUserExceptionReason(self, endUserExceptionReason): self.endUserExceptionReason = endUserExceptionReason
    def get_endUserExceptionDeclaration(self): return self.endUserExceptionDeclaration
    def set_endUserExceptionDeclaration(self, endUserExceptionDeclaration): self.endUserExceptionDeclaration = endUserExceptionDeclaration
    def get_nonStandardTerms(self): return self.nonStandardTerms
    def set_nonStandardTerms(self, nonStandardTerms): self.nonStandardTerms = nonStandardTerms
    def get_offMarketPrice(self): return self.offMarketPrice
    def set_offMarketPrice(self, offMarketPrice): self.offMarketPrice = offMarketPrice
    def get_pricingContext(self): return self.pricingContext
    def set_pricingContext(self, pricingContext): self.pricingContext = pricingContext
    def get_largeSizeTrade(self): return self.largeSizeTrade
    def set_largeSizeTrade(self, largeSizeTrade): self.largeSizeTrade = largeSizeTrade
    def get_executionType(self): return self.executionType
    def set_executionType(self, executionType): self.executionType = executionType
    def get_executionVenueType(self): return self.executionVenueType
    def set_executionVenueType(self, executionVenueType): self.executionVenueType = executionVenueType
    def get_verificationMethod(self): return self.verificationMethod
    def set_verificationMethod(self, verificationMethod): self.verificationMethod = verificationMethod
    def get_confirmationMethod(self): return self.confirmationMethod
    def set_confirmationMethod(self, confirmationMethod): self.confirmationMethod = confirmationMethod
    def get_compressedTrade(self): return self.compressedTrade
    def set_compressedTrade(self, compressedTrade): self.compressedTrade = compressedTrade
    def get_isSecuritiesFinancing(self): return self.isSecuritiesFinancing
    def set_isSecuritiesFinancing(self, isSecuritiesFinancing): self.isSecuritiesFinancing = isSecuritiesFinancing
    def get_notionalChange(self): return self.notionalChange
    def set_notionalChange(self, notionalChange): self.notionalChange = notionalChange
    def get_otcClassification(self): return self.otcClassification
    def set_otcClassification(self, otcClassification): self.otcClassification = otcClassification
    def get_tradingWaiver(self): return self.tradingWaiver
    def set_tradingWaiver(self, tradingWaiver): self.tradingWaiver = tradingWaiver
    def get_shortSale(self): return self.shortSale
    def set_shortSale(self, shortSale): self.shortSale = shortSale
    def get_isCommodityHedge(self): return self.isCommodityHedge
    def set_isCommodityHedge(self, isCommodityHedge): self.isCommodityHedge = isCommodityHedge
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def validate_NotionalChangeEnum(self, value):
        # Validate type NotionalChangeEnum, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Increase', 'Decrease']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on NotionalChangeEnum' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.partyReference is not None or
            self.accountReference is not None or
            self.relatedParty or
            self.reportingRole is not None or
            self.description is not None or
            self.unit or
            self.relatedBusinessUnit or
            self.relatedPerson or
            self.algorithm or
            self.isAccountingHedge is not None or
            self.category or
            self.trader or
            self.executionDateTime is not None or
            self.timestamps is not None or
            self.intentToAllocate is not None or
            self.allocationStatus is not None or
            self.intentToClear is not None or
            self.clearingStatus is not None or
            self.collateralizationType is not None or
            self.collateralPortfolio is not None or
            self.reportingRegime or
            self.endUserException is not None or
            self.endUserExceptionReason is not None or
            self.endUserExceptionDeclaration is not None or
            self.nonStandardTerms is not None or
            self.offMarketPrice is not None or
            self.pricingContext is not None or
            self.largeSizeTrade is not None or
            self.executionType is not None or
            self.executionVenueType is not None or
            self.verificationMethod is not None or
            self.confirmationMethod is not None or
            self.compressedTrade is not None or
            self.isSecuritiesFinancing is not None or
            self.notionalChange is not None or
            self.otcClassification is not None or
            self.tradingWaiver is not None or
            self.shortSale is not None or
            self.isCommodityHedge is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartyTradeInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyTradeInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartyTradeInformation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyTradeInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PartyTradeInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.partyReference is not None:
            self.partyReference.export(outfile, level, namespace_, name_='partyReference', pretty_print=pretty_print)
        if self.accountReference is not None:
            self.accountReference.export(outfile, level, namespace_, name_='accountReference', pretty_print=pretty_print)
        for relatedParty_ in self.relatedParty:
            relatedParty_.export(outfile, level, namespace_, name_='relatedParty', pretty_print=pretty_print)
        if self.reportingRole is not None:
            self.reportingRole.export(outfile, level, namespace_, name_='reportingRole', pretty_print=pretty_print)
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespace_, eol_))
        for unit_ in self.unit:
            unit_.export(outfile, level, namespace_, name_='unit', pretty_print=pretty_print)
        for relatedBusinessUnit_ in self.relatedBusinessUnit:
            relatedBusinessUnit_.export(outfile, level, namespace_, name_='relatedBusinessUnit', pretty_print=pretty_print)
        for relatedPerson_ in self.relatedPerson:
            relatedPerson_.export(outfile, level, namespace_, name_='relatedPerson', pretty_print=pretty_print)
        for algorithm_ in self.algorithm:
            algorithm_.export(outfile, level, namespace_, name_='algorithm', pretty_print=pretty_print)
        if self.isAccountingHedge is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sisAccountingHedge>%s</%sisAccountingHedge>%s' % (namespace_, self.gds_format_boolean(self.isAccountingHedge, input_name='isAccountingHedge'), namespace_, eol_))
        for category_ in self.category:
            category_.export(outfile, level, namespace_, name_='category', pretty_print=pretty_print)
        for trader_ in self.trader:
            trader_.export(outfile, level, namespace_, name_='trader', pretty_print=pretty_print)
        if self.executionDateTime is not None:
            self.executionDateTime.export(outfile, level, namespace_, name_='executionDateTime', pretty_print=pretty_print)
        if self.timestamps is not None:
            self.timestamps.export(outfile, level, namespace_, name_='timestamps', pretty_print=pretty_print)
        if self.intentToAllocate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sintentToAllocate>%s</%sintentToAllocate>%s' % (namespace_, self.gds_format_boolean(self.intentToAllocate, input_name='intentToAllocate'), namespace_, eol_))
        if self.allocationStatus is not None:
            self.allocationStatus.export(outfile, level, namespace_, name_='allocationStatus', pretty_print=pretty_print)
        if self.intentToClear is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sintentToClear>%s</%sintentToClear>%s' % (namespace_, self.gds_format_boolean(self.intentToClear, input_name='intentToClear'), namespace_, eol_))
        if self.clearingStatus is not None:
            self.clearingStatus.export(outfile, level, namespace_, name_='clearingStatus', pretty_print=pretty_print)
        if self.collateralizationType is not None:
            self.collateralizationType.export(outfile, level, namespace_, name_='collateralizationType', pretty_print=pretty_print)
        if self.collateralPortfolio is not None:
            self.collateralPortfolio.export(outfile, level, namespace_, name_='collateralPortfolio', pretty_print=pretty_print)
        for reportingRegime_ in self.reportingRegime:
            reportingRegime_.export(outfile, level, namespace_, name_='reportingRegime', pretty_print=pretty_print)
        if self.endUserException is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sendUserException>%s</%sendUserException>%s' % (namespace_, self.gds_format_boolean(self.endUserException, input_name='endUserException'), namespace_, eol_))
        if self.endUserExceptionReason is not None:
            self.endUserExceptionReason.export(outfile, level, namespace_, name_='endUserExceptionReason', pretty_print=pretty_print)
        if self.endUserExceptionDeclaration is not None:
            self.endUserExceptionDeclaration.export(outfile, level, namespace_, name_='endUserExceptionDeclaration', pretty_print=pretty_print)
        if self.nonStandardTerms is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snonStandardTerms>%s</%snonStandardTerms>%s' % (namespace_, self.gds_format_boolean(self.nonStandardTerms, input_name='nonStandardTerms'), namespace_, eol_))
        if self.offMarketPrice is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soffMarketPrice>%s</%soffMarketPrice>%s' % (namespace_, self.gds_format_boolean(self.offMarketPrice, input_name='offMarketPrice'), namespace_, eol_))
        if self.pricingContext is not None:
            self.pricingContext.export(outfile, level, namespace_, name_='pricingContext', pretty_print=pretty_print)
        if self.largeSizeTrade is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slargeSizeTrade>%s</%slargeSizeTrade>%s' % (namespace_, self.gds_format_boolean(self.largeSizeTrade, input_name='largeSizeTrade'), namespace_, eol_))
        if self.executionType is not None:
            self.executionType.export(outfile, level, namespace_, name_='executionType', pretty_print=pretty_print)
        if self.executionVenueType is not None:
            self.executionVenueType.export(outfile, level, namespace_, name_='executionVenueType', pretty_print=pretty_print)
        if self.verificationMethod is not None:
            self.verificationMethod.export(outfile, level, namespace_, name_='verificationMethod', pretty_print=pretty_print)
        if self.confirmationMethod is not None:
            self.confirmationMethod.export(outfile, level, namespace_, name_='confirmationMethod', pretty_print=pretty_print)
        if self.compressedTrade is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scompressedTrade>%s</%scompressedTrade>%s' % (namespace_, self.gds_format_boolean(self.compressedTrade, input_name='compressedTrade'), namespace_, eol_))
        if self.isSecuritiesFinancing is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sisSecuritiesFinancing>%s</%sisSecuritiesFinancing>%s' % (namespace_, self.gds_format_boolean(self.isSecuritiesFinancing, input_name='isSecuritiesFinancing'), namespace_, eol_))
        if self.notionalChange is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snotionalChange>%s</%snotionalChange>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.notionalChange), input_name='notionalChange')), namespace_, eol_))
        if self.otcClassification is not None:
            self.otcClassification.export(outfile, level, namespace_, name_='otcClassification', pretty_print=pretty_print)
        if self.tradingWaiver is not None:
            self.tradingWaiver.export(outfile, level, namespace_, name_='tradingWaiver', pretty_print=pretty_print)
        if self.shortSale is not None:
            self.shortSale.export(outfile, level, namespace_, name_='shortSale', pretty_print=pretty_print)
        if self.isCommodityHedge is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sisCommodityHedge>%s</%sisCommodityHedge>%s' % (namespace_, self.gds_format_boolean(self.isCommodityHedge, input_name='isCommodityHedge'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'partyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.partyReference = obj_
            obj_.original_tagname_ = 'partyReference'
        elif nodeName_ == 'accountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.accountReference = obj_
            obj_.original_tagname_ = 'accountReference'
        elif nodeName_ == 'relatedParty':
            obj_ = RelatedParty.factory()
            obj_.build(child_)
            self.relatedParty.append(obj_)
            obj_.original_tagname_ = 'relatedParty'
        elif nodeName_ == 'reportingRole':
            obj_ = ReportingRole.factory()
            obj_.build(child_)
            self.reportingRole = obj_
            obj_.original_tagname_ = 'reportingRole'
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
            # validate type String
            self.validate_String(self.description)
        elif nodeName_ == 'unit':
            obj_ = Unit.factory()
            obj_.build(child_)
            self.unit.append(obj_)
            obj_.original_tagname_ = 'unit'
        elif nodeName_ == 'relatedBusinessUnit':
            obj_ = RelatedBusinessUnit.factory()
            obj_.build(child_)
            self.relatedBusinessUnit.append(obj_)
            obj_.original_tagname_ = 'relatedBusinessUnit'
        elif nodeName_ == 'relatedPerson':
            obj_ = RelatedPerson.factory()
            obj_.build(child_)
            self.relatedPerson.append(obj_)
            obj_.original_tagname_ = 'relatedPerson'
        elif nodeName_ == 'algorithm':
            obj_ = Algorithm.factory()
            obj_.build(child_)
            self.algorithm.append(obj_)
            obj_.original_tagname_ = 'algorithm'
        elif nodeName_ == 'isAccountingHedge':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'isAccountingHedge')
            self.isAccountingHedge = ival_
        elif nodeName_ == 'category':
            obj_ = TradeCategory.factory()
            obj_.build(child_)
            self.category.append(obj_)
            obj_.original_tagname_ = 'category'
        elif nodeName_ == 'trader':
            obj_ = Trader.factory()
            obj_.build(child_)
            self.trader.append(obj_)
            obj_.original_tagname_ = 'trader'
        elif nodeName_ == 'executionDateTime':
            obj_ = ExecutionDateTime.factory()
            obj_.build(child_)
            self.executionDateTime = obj_
            obj_.original_tagname_ = 'executionDateTime'
        elif nodeName_ == 'timestamps':
            obj_ = TradeProcessingTimestamps.factory()
            obj_.build(child_)
            self.timestamps = obj_
            obj_.original_tagname_ = 'timestamps'
        elif nodeName_ == 'intentToAllocate':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'intentToAllocate')
            self.intentToAllocate = ival_
        elif nodeName_ == 'allocationStatus':
            obj_ = AllocationReportingStatus.factory()
            obj_.build(child_)
            self.allocationStatus = obj_
            obj_.original_tagname_ = 'allocationStatus'
        elif nodeName_ == 'intentToClear':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'intentToClear')
            self.intentToClear = ival_
        elif nodeName_ == 'clearingStatus':
            obj_ = ClearingStatusValue.factory()
            obj_.build(child_)
            self.clearingStatus = obj_
            obj_.original_tagname_ = 'clearingStatus'
        elif nodeName_ == 'collateralizationType':
            obj_ = CollateralizationType.factory()
            obj_.build(child_)
            self.collateralizationType = obj_
            obj_.original_tagname_ = 'collateralizationType'
        elif nodeName_ == 'collateralPortfolio':
            obj_ = PortfolioName.factory()
            obj_.build(child_)
            self.collateralPortfolio = obj_
            obj_.original_tagname_ = 'collateralPortfolio'
        elif nodeName_ == 'reportingRegime':
            obj_ = ReportingRegime.factory()
            obj_.build(child_)
            self.reportingRegime.append(obj_)
            obj_.original_tagname_ = 'reportingRegime'
        elif nodeName_ == 'endUserException':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'endUserException')
            self.endUserException = ival_
        elif nodeName_ == 'endUserExceptionReason':
            obj_ = ClearingExceptionReason.factory()
            obj_.build(child_)
            self.endUserExceptionReason = obj_
            obj_.original_tagname_ = 'endUserExceptionReason'
        elif nodeName_ == 'endUserExceptionDeclaration':
            obj_ = EndUserExceptionDeclaration.factory()
            obj_.build(child_)
            self.endUserExceptionDeclaration = obj_
            obj_.original_tagname_ = 'endUserExceptionDeclaration'
        elif nodeName_ == 'nonStandardTerms':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'nonStandardTerms')
            self.nonStandardTerms = ival_
        elif nodeName_ == 'offMarketPrice':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'offMarketPrice')
            self.offMarketPrice = ival_
        elif nodeName_ == 'pricingContext':
            obj_ = PricingContext.factory()
            obj_.build(child_)
            self.pricingContext = obj_
            obj_.original_tagname_ = 'pricingContext'
        elif nodeName_ == 'largeSizeTrade':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'largeSizeTrade')
            self.largeSizeTrade = ival_
        elif nodeName_ == 'executionType':
            obj_ = ExecutionType.factory()
            obj_.build(child_)
            self.executionType = obj_
            obj_.original_tagname_ = 'executionType'
        elif nodeName_ == 'executionVenueType':
            obj_ = ExecutionVenueType.factory()
            obj_.build(child_)
            self.executionVenueType = obj_
            obj_.original_tagname_ = 'executionVenueType'
        elif nodeName_ == 'verificationMethod':
            obj_ = VerificationMethod.factory()
            obj_.build(child_)
            self.verificationMethod = obj_
            obj_.original_tagname_ = 'verificationMethod'
        elif nodeName_ == 'confirmationMethod':
            obj_ = ConfirmationMethod.factory()
            obj_.build(child_)
            self.confirmationMethod = obj_
            obj_.original_tagname_ = 'confirmationMethod'
        elif nodeName_ == 'compressedTrade':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'compressedTrade')
            self.compressedTrade = ival_
        elif nodeName_ == 'isSecuritiesFinancing':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'isSecuritiesFinancing')
            self.isSecuritiesFinancing = ival_
        elif nodeName_ == 'notionalChange':
            notionalChange_ = child_.text
            notionalChange_ = re_.sub(String_cleanup_pat_, " ", notionalChange_).strip()
            notionalChange_ = self.gds_validate_string(notionalChange_, node, 'notionalChange')
            self.notionalChange = notionalChange_
            # validate type NotionalChangeEnum
            self.validate_NotionalChangeEnum(self.notionalChange)
        elif nodeName_ == 'otcClassification':
            obj_ = OtcClassification.factory()
            obj_.build(child_)
            self.otcClassification = obj_
            obj_.original_tagname_ = 'otcClassification'
        elif nodeName_ == 'tradingWaiver':
            obj_ = TradingWaiver.factory()
            obj_.build(child_)
            self.tradingWaiver = obj_
            obj_.original_tagname_ = 'tradingWaiver'
        elif nodeName_ == 'shortSale':
            obj_ = ShortSale.factory()
            obj_.build(child_)
            self.shortSale = obj_
            obj_.original_tagname_ = 'shortSale'
        elif nodeName_ == 'isCommodityHedge':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'isCommodityHedge')
            self.isCommodityHedge = ival_
# end class PartyTradeInformation


class Portfolio(GeneratedsSuper):
    """A type representing an arbitary grouping of trade references."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'partyPortfolioName': MemberSpec_('partyPortfolioName', 'PartyPortfolioName', 0),
        'tradeId': MemberSpec_('tradeId', 'TradeId', 1),
        'partyTradeIdentifier': MemberSpec_('partyTradeIdentifier', 'PartyTradeIdentifier', 1),
        'portfolio': MemberSpec_('portfolio', 'Portfolio', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, partyPortfolioName=None, tradeId=None, partyTradeIdentifier=None, portfolio=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.partyPortfolioName = partyPortfolioName
        if tradeId is None:
            self.tradeId = []
        else:
            self.tradeId = tradeId
        if partyTradeIdentifier is None:
            self.partyTradeIdentifier = []
        else:
            self.partyTradeIdentifier = partyTradeIdentifier
        if portfolio is None:
            self.portfolio = []
        else:
            self.portfolio = portfolio
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Portfolio)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Portfolio.subclass:
            return Portfolio.subclass(*args_, **kwargs_)
        else:
            return Portfolio(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyPortfolioName(self): return self.partyPortfolioName
    def set_partyPortfolioName(self, partyPortfolioName): self.partyPortfolioName = partyPortfolioName
    def get_tradeId(self): return self.tradeId
    def set_tradeId(self, tradeId): self.tradeId = tradeId
    def add_tradeId(self, value): self.tradeId.append(value)
    def insert_tradeId_at(self, index, value): self.tradeId.insert(index, value)
    def replace_tradeId_at(self, index, value): self.tradeId[index] = value
    def get_partyTradeIdentifier(self): return self.partyTradeIdentifier
    def set_partyTradeIdentifier(self, partyTradeIdentifier): self.partyTradeIdentifier = partyTradeIdentifier
    def add_partyTradeIdentifier(self, value): self.partyTradeIdentifier.append(value)
    def insert_partyTradeIdentifier_at(self, index, value): self.partyTradeIdentifier.insert(index, value)
    def replace_partyTradeIdentifier_at(self, index, value): self.partyTradeIdentifier[index] = value
    def get_portfolio(self): return self.portfolio
    def set_portfolio(self, portfolio): self.portfolio = portfolio
    def add_portfolio(self, value): self.portfolio.append(value)
    def insert_portfolio_at(self, index, value): self.portfolio.insert(index, value)
    def replace_portfolio_at(self, index, value): self.portfolio[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.partyPortfolioName is not None or
            self.tradeId or
            self.partyTradeIdentifier or
            self.portfolio
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Portfolio', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Portfolio')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Portfolio', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Portfolio'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Portfolio', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.partyPortfolioName is not None:
            self.partyPortfolioName.export(outfile, level, namespace_, name_='partyPortfolioName', pretty_print=pretty_print)
        for tradeId_ in self.tradeId:
            tradeId_.export(outfile, level, namespace_, name_='tradeId', pretty_print=pretty_print)
        for partyTradeIdentifier_ in self.partyTradeIdentifier:
            partyTradeIdentifier_.export(outfile, level, namespace_, name_='partyTradeIdentifier', pretty_print=pretty_print)
        for portfolio_ in self.portfolio:
            portfolio_.export(outfile, level, namespace_, name_='portfolio', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'partyPortfolioName':
            obj_ = PartyPortfolioName.factory()
            obj_.build(child_)
            self.partyPortfolioName = obj_
            obj_.original_tagname_ = 'partyPortfolioName'
        elif nodeName_ == 'tradeId':
            obj_ = TradeId.factory()
            obj_.build(child_)
            self.tradeId.append(obj_)
            obj_.original_tagname_ = 'tradeId'
        elif nodeName_ == 'partyTradeIdentifier':
            obj_ = PartyTradeIdentifier.factory()
            obj_.build(child_)
            self.partyTradeIdentifier.append(obj_)
            obj_.original_tagname_ = 'partyTradeIdentifier'
        elif nodeName_ == 'portfolio':
            class_obj_ = self.get_class_obj_(child_, Portfolio)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.portfolio.append(obj_)
            obj_.original_tagname_ = 'portfolio'
# end class Portfolio


class ClearingExceptionReason(GeneratedsSuper):
    """The reason a trade is exempted from a clearing mandate."""
    member_data_items_ = {
        'clearingExceptionReasonScheme': MemberSpec_('clearingExceptionReasonScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, clearingExceptionReasonScheme='http://www.fpml.org/coding-scheme/clearing-exception-reason', valueOf_=None):
        self.original_tagname_ = None
        self.clearingExceptionReasonScheme = _cast(None, clearingExceptionReasonScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClearingExceptionReason)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClearingExceptionReason.subclass:
            return ClearingExceptionReason.subclass(*args_, **kwargs_)
        else:
            return ClearingExceptionReason(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_clearingExceptionReasonScheme(self): return self.clearingExceptionReasonScheme
    def set_clearingExceptionReasonScheme(self, clearingExceptionReasonScheme): self.clearingExceptionReasonScheme = clearingExceptionReasonScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ClearingExceptionReason', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ClearingExceptionReason')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ClearingExceptionReason', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ClearingExceptionReason'):
        if self.clearingExceptionReasonScheme != "http://www.fpml.org/coding-scheme/clearing-exception-reason" and 'clearingExceptionReasonScheme' not in already_processed:
            already_processed.add('clearingExceptionReasonScheme')
            outfile.write(' clearingExceptionReasonScheme=%s' % (quote_attrib(self.clearingExceptionReasonScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ClearingExceptionReason', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('clearingExceptionReasonScheme', node)
        if value is not None and 'clearingExceptionReasonScheme' not in already_processed:
            already_processed.add('clearingExceptionReasonScheme')
            self.clearingExceptionReasonScheme = value
            self.validate_NonEmptyURI(self.clearingExceptionReasonScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ClearingExceptionReason


class PortfolioName(GeneratedsSuper):
    """The data type used for portfolio names."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'portfolioNameScheme': MemberSpec_('portfolioNameScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, portfolioNameScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.portfolioNameScheme = _cast(None, portfolioNameScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PortfolioName)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PortfolioName.subclass:
            return PortfolioName.subclass(*args_, **kwargs_)
        else:
            return PortfolioName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_portfolioNameScheme(self): return self.portfolioNameScheme
    def set_portfolioNameScheme(self, portfolioNameScheme): self.portfolioNameScheme = portfolioNameScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PortfolioName', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PortfolioName')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PortfolioName', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PortfolioName'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.portfolioNameScheme is not None and 'portfolioNameScheme' not in already_processed:
            already_processed.add('portfolioNameScheme')
            outfile.write(' portfolioNameScheme=%s' % (quote_attrib(self.portfolioNameScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PortfolioName', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('portfolioNameScheme', node)
        if value is not None and 'portfolioNameScheme' not in already_processed:
            already_processed.add('portfolioNameScheme')
            self.portfolioNameScheme = value
            self.validate_NonEmptyURI(self.portfolioNameScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PortfolioName


class PricingContext(GeneratedsSuper):
    """The reason a trade's price does not reflect the current market
    price."""
    member_data_items_ = {
        'PricingContextScheme': MemberSpec_('PricingContextScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, PricingContextScheme='http://www.fpml.org/coding-scheme/pricing-context', valueOf_=None):
        self.original_tagname_ = None
        self.PricingContextScheme = _cast(None, PricingContextScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PricingContext)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PricingContext.subclass:
            return PricingContext.subclass(*args_, **kwargs_)
        else:
            return PricingContext(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PricingContextScheme(self): return self.PricingContextScheme
    def set_PricingContextScheme(self, PricingContextScheme): self.PricingContextScheme = PricingContextScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PricingContext', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PricingContext')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PricingContext', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PricingContext'):
        if self.PricingContextScheme != "http://www.fpml.org/coding-scheme/pricing-context" and 'PricingContextScheme' not in already_processed:
            already_processed.add('PricingContextScheme')
            outfile.write(' PricingContextScheme=%s' % (quote_attrib(self.PricingContextScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PricingContext', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('PricingContextScheme', node)
        if value is not None and 'PricingContextScheme' not in already_processed:
            already_processed.add('PricingContextScheme')
            self.PricingContextScheme = value
            self.validate_NonEmptyURI(self.PricingContextScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PricingContext


class ProductComponentIdentifier(GeneratedsSuper):
    """Deprecated: A type defining a USI for the a subproduct component of
    a strategy."""
    member_data_items_ = {
        'premiumProductReference': MemberSpec_('premiumProductReference', 'ProductReference', 0),
        'issuer': MemberSpec_('issuer', 'IssuerId', 0),
        'tradeId': MemberSpec_('tradeId', 'TradeId', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, premiumProductReference=None, issuer=None, tradeId=None):
        self.original_tagname_ = None
        self.premiumProductReference = premiumProductReference
        self.issuer = issuer
        self.tradeId = tradeId
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductComponentIdentifier)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductComponentIdentifier.subclass:
            return ProductComponentIdentifier.subclass(*args_, **kwargs_)
        else:
            return ProductComponentIdentifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_premiumProductReference(self): return self.premiumProductReference
    def set_premiumProductReference(self, premiumProductReference): self.premiumProductReference = premiumProductReference
    def get_issuer(self): return self.issuer
    def set_issuer(self, issuer): self.issuer = issuer
    def get_tradeId(self): return self.tradeId
    def set_tradeId(self, tradeId): self.tradeId = tradeId
    def hasContent_(self):
        if (
            self.premiumProductReference is not None or
            self.issuer is not None or
            self.tradeId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ProductComponentIdentifier', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductComponentIdentifier')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ProductComponentIdentifier', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProductComponentIdentifier'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ProductComponentIdentifier', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.premiumProductReference is not None:
            self.premiumProductReference.export(outfile, level, namespace_, name_='premiumProductReference', pretty_print=pretty_print)
        if self.issuer is not None:
            self.issuer.export(outfile, level, namespace_, name_='issuer', pretty_print=pretty_print)
        if self.tradeId is not None:
            self.tradeId.export(outfile, level, namespace_, name_='tradeId', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'premiumProductReference':
            obj_ = ProductReference.factory()
            obj_.build(child_)
            self.premiumProductReference = obj_
            obj_.original_tagname_ = 'premiumProductReference'
        elif nodeName_ == 'issuer':
            obj_ = IssuerId.factory()
            obj_.build(child_)
            self.issuer = obj_
            obj_.original_tagname_ = 'issuer'
        elif nodeName_ == 'tradeId':
            obj_ = TradeId.factory()
            obj_.build(child_)
            self.tradeId = obj_
            obj_.original_tagname_ = 'tradeId'
# end class ProductComponentIdentifier


class QueryParameter(GeneratedsSuper):
    """A type representing criteria for defining a query portfolio. The
    criteria are made up of a QueryParameterId, QueryParameterValue
    and QueryParameterOperator."""
    member_data_items_ = {
        'queryParameterId': MemberSpec_('queryParameterId', 'QueryParameterId', 0),
        'queryParameterValue': MemberSpec_('queryParameterValue', ['NormalizedString', 'xsd:normalizedString'], 0),
        'queryParameterOperator': MemberSpec_('queryParameterOperator', 'QueryParameterOperator', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, queryParameterId=None, queryParameterValue=None, queryParameterOperator=None):
        self.original_tagname_ = None
        self.queryParameterId = queryParameterId
        self.queryParameterValue = queryParameterValue
        self.validate_NormalizedString(self.queryParameterValue)
        self.queryParameterOperator = queryParameterOperator
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QueryParameter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QueryParameter.subclass:
            return QueryParameter.subclass(*args_, **kwargs_)
        else:
            return QueryParameter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_queryParameterId(self): return self.queryParameterId
    def set_queryParameterId(self, queryParameterId): self.queryParameterId = queryParameterId
    def get_queryParameterValue(self): return self.queryParameterValue
    def set_queryParameterValue(self, queryParameterValue): self.queryParameterValue = queryParameterValue
    def get_queryParameterOperator(self): return self.queryParameterOperator
    def set_queryParameterOperator(self, queryParameterOperator): self.queryParameterOperator = queryParameterOperator
    def validate_NormalizedString(self, value):
        # Validate type NormalizedString, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NormalizedString' % {"value" : value} )
    def hasContent_(self):
        if (
            self.queryParameterId is not None or
            self.queryParameterValue is not None or
            self.queryParameterOperator is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryParameter', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryParameter')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryParameter', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryParameter'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='QueryParameter', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.queryParameterId is not None:
            self.queryParameterId.export(outfile, level, namespace_, name_='queryParameterId', pretty_print=pretty_print)
        if self.queryParameterValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%squeryParameterValue>%s</%squeryParameterValue>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.queryParameterValue), input_name='queryParameterValue')), namespace_, eol_))
        if self.queryParameterOperator is not None:
            self.queryParameterOperator.export(outfile, level, namespace_, name_='queryParameterOperator', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'queryParameterId':
            obj_ = QueryParameterId.factory()
            obj_.build(child_)
            self.queryParameterId = obj_
            obj_.original_tagname_ = 'queryParameterId'
        elif nodeName_ == 'queryParameterValue':
            queryParameterValue_ = child_.text
            queryParameterValue_ = self.gds_validate_string(queryParameterValue_, node, 'queryParameterValue')
            self.queryParameterValue = queryParameterValue_
            # validate type NormalizedString
            self.validate_NormalizedString(self.queryParameterValue)
        elif nodeName_ == 'queryParameterOperator':
            obj_ = QueryParameterOperator.factory()
            obj_.build(child_)
            self.queryParameterOperator = obj_
            obj_.original_tagname_ = 'queryParameterOperator'
# end class QueryParameter


class QueryParameterId(GeneratedsSuper):
    """A type representing an identifier for a parameter describing a query
    portfolio. An identifier can be anything from a product name
    like swap to a termination date."""
    member_data_items_ = {
        'queryParameterIdScheme': MemberSpec_('queryParameterIdScheme', 'NonEmptyURI', 0),
        'id': MemberSpec_('id', 'xsd:string', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, queryParameterIdScheme=None, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.queryParameterIdScheme = _cast(None, queryParameterIdScheme)
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QueryParameterId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QueryParameterId.subclass:
            return QueryParameterId.subclass(*args_, **kwargs_)
        else:
            return QueryParameterId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_queryParameterIdScheme(self): return self.queryParameterIdScheme
    def set_queryParameterIdScheme(self, queryParameterIdScheme): self.queryParameterIdScheme = queryParameterIdScheme
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryParameterId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryParameterId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryParameterId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryParameterId'):
        if self.queryParameterIdScheme is not None and 'queryParameterIdScheme' not in already_processed:
            already_processed.add('queryParameterIdScheme')
            outfile.write(' queryParameterIdScheme=%s' % (quote_attrib(self.queryParameterIdScheme), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryParameterId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('queryParameterIdScheme', node)
        if value is not None and 'queryParameterIdScheme' not in already_processed:
            already_processed.add('queryParameterIdScheme')
            self.queryParameterIdScheme = value
            self.validate_NonEmptyURI(self.queryParameterIdScheme)    # validate type NonEmptyURI
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class QueryParameterId


class QueryParameterOperator(GeneratedsSuper):
    """A type representing an operator describing the relationship of a
    value to its corresponding identifier for a parameter describing
    a query portfolio. Possible relationships include equals, not
    equals, less than, greater than. Possible operators are listed
    in the queryParameterOperatorScheme."""
    member_data_items_ = {
        'queryParameterOperatorScheme': MemberSpec_('queryParameterOperatorScheme', 'NonEmptyURI', 0),
        'id': MemberSpec_('id', 'xsd:string', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, queryParameterOperatorScheme='http://www.fpml.org/coding-scheme/query-parameter-operator', id=None, valueOf_=None):
        self.original_tagname_ = None
        self.queryParameterOperatorScheme = _cast(None, queryParameterOperatorScheme)
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QueryParameterOperator)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QueryParameterOperator.subclass:
            return QueryParameterOperator.subclass(*args_, **kwargs_)
        else:
            return QueryParameterOperator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_queryParameterOperatorScheme(self): return self.queryParameterOperatorScheme
    def set_queryParameterOperatorScheme(self, queryParameterOperatorScheme): self.queryParameterOperatorScheme = queryParameterOperatorScheme
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryParameterOperator', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryParameterOperator')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryParameterOperator', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryParameterOperator'):
        if self.queryParameterOperatorScheme != "http://www.fpml.org/coding-scheme/query-parameter-operator" and 'queryParameterOperatorScheme' not in already_processed:
            already_processed.add('queryParameterOperatorScheme')
            outfile.write(' queryParameterOperatorScheme=%s' % (quote_attrib(self.queryParameterOperatorScheme), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryParameterOperator', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('queryParameterOperatorScheme', node)
        if value is not None and 'queryParameterOperatorScheme' not in already_processed:
            already_processed.add('queryParameterOperatorScheme')
            self.queryParameterOperatorScheme = value
            self.validate_NonEmptyURI(self.queryParameterOperatorScheme)    # validate type NonEmptyURI
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class QueryParameterOperator


class QueryPortfolio(Portfolio):
    """A type representing a portfolio obtained by querying the set of
    trades held in a repository. It contains trades matching the
    intersection of all criteria specified using one or more
    queryParameters or trades matching the union of two or more
    child queryPortfolios."""
    member_data_items_ = {
        'queryParameter': MemberSpec_('queryParameter', 'QueryParameter', 1),
    }
    subclass = None
    superclass = Portfolio
    def __init__(self, id=None, partyPortfolioName=None, tradeId=None, partyTradeIdentifier=None, portfolio=None, queryParameter=None):
        self.original_tagname_ = None
        super(QueryPortfolio, self).__init__(id, partyPortfolioName, tradeId, partyTradeIdentifier, portfolio, )
        if queryParameter is None:
            self.queryParameter = []
        else:
            self.queryParameter = queryParameter
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QueryPortfolio)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QueryPortfolio.subclass:
            return QueryPortfolio.subclass(*args_, **kwargs_)
        else:
            return QueryPortfolio(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_queryParameter(self): return self.queryParameter
    def set_queryParameter(self, queryParameter): self.queryParameter = queryParameter
    def add_queryParameter(self, value): self.queryParameter.append(value)
    def insert_queryParameter_at(self, index, value): self.queryParameter.insert(index, value)
    def replace_queryParameter_at(self, index, value): self.queryParameter[index] = value
    def hasContent_(self):
        if (
            self.queryParameter or
            super(QueryPortfolio, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryPortfolio', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryPortfolio')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryPortfolio', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryPortfolio'):
        super(QueryPortfolio, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryPortfolio')
    def exportChildren(self, outfile, level, namespace_='', name_='QueryPortfolio', fromsubclass_=False, pretty_print=True):
        super(QueryPortfolio, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for queryParameter_ in self.queryParameter:
            queryParameter_.export(outfile, level, namespace_, name_='queryParameter', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(QueryPortfolio, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'queryParameter':
            obj_ = QueryParameter.factory()
            obj_.build(child_)
            self.queryParameter.append(obj_)
            obj_.original_tagname_ = 'queryParameter'
        super(QueryPortfolio, self).buildChildren(child_, node, nodeName_, True)
# end class QueryPortfolio


class RegulatorId(GeneratedsSuper):
    """An ID assigned by a regulator to an organization registered with it.
    (NOTE: should this just by represented by an alternate party
    ID?)"""
    member_data_items_ = {
        'regulatorIdScheme': MemberSpec_('regulatorIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, regulatorIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.regulatorIdScheme = _cast(None, regulatorIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RegulatorId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RegulatorId.subclass:
            return RegulatorId.subclass(*args_, **kwargs_)
        else:
            return RegulatorId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_regulatorIdScheme(self): return self.regulatorIdScheme
    def set_regulatorIdScheme(self, regulatorIdScheme): self.regulatorIdScheme = regulatorIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RegulatorId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RegulatorId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RegulatorId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RegulatorId'):
        if self.regulatorIdScheme is not None and 'regulatorIdScheme' not in already_processed:
            already_processed.add('regulatorIdScheme')
            outfile.write(' regulatorIdScheme=%s' % (quote_attrib(self.regulatorIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RegulatorId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('regulatorIdScheme', node)
        if value is not None and 'regulatorIdScheme' not in already_processed:
            already_processed.add('regulatorIdScheme')
            self.regulatorIdScheme = value
            self.validate_NonEmptyURI(self.regulatorIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RegulatorId


class ReportingPurpose(GeneratedsSuper):
    """A value that explains the reason or purpose that information is
    being reported. Examples might include RealTimePublic reporting,
    PrimaryEconomicTerms reporting, Confirmation reporting, or
    Snapshot reporting."""
    member_data_items_ = {
        'reportingPurposeScheme': MemberSpec_('reportingPurposeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, reportingPurposeScheme='http://www.fpml.org/coding-scheme/reporting-purpose', valueOf_=None):
        self.original_tagname_ = None
        self.reportingPurposeScheme = _cast(None, reportingPurposeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReportingPurpose)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReportingPurpose.subclass:
            return ReportingPurpose.subclass(*args_, **kwargs_)
        else:
            return ReportingPurpose(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_reportingPurposeScheme(self): return self.reportingPurposeScheme
    def set_reportingPurposeScheme(self, reportingPurposeScheme): self.reportingPurposeScheme = reportingPurposeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReportingPurpose', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReportingPurpose')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReportingPurpose', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReportingPurpose'):
        if self.reportingPurposeScheme != "http://www.fpml.org/coding-scheme/reporting-purpose" and 'reportingPurposeScheme' not in already_processed:
            already_processed.add('reportingPurposeScheme')
            outfile.write(' reportingPurposeScheme=%s' % (quote_attrib(self.reportingPurposeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ReportingPurpose', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('reportingPurposeScheme', node)
        if value is not None and 'reportingPurposeScheme' not in already_processed:
            already_processed.add('reportingPurposeScheme')
            self.reportingPurposeScheme = value
            self.validate_NonEmptyURI(self.reportingPurposeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReportingPurpose


class ReportingRegime(GeneratedsSuper):
    """Provides information about how the information in this message is
    applicable to a regulatory reporting process."""
    member_data_items_ = {
        'name': MemberSpec_('name', 'ReportingRegimeName', 0),
        'supervisorRegistration': MemberSpec_('supervisorRegistration', 'SupervisorRegistration', 1),
        'supervisorRegistration': MemberSpec_('supervisorRegistration', 'SupervisorRegistration', 1),
        'reportingRole': MemberSpec_('reportingRole', 'ReportingRole', 0),
        'reportingPurpose': MemberSpec_('reportingPurpose', 'ReportingPurpose', 1),
        'mandatorilyClearable': MemberSpec_('mandatorilyClearable', 'xsd:boolean', 0),
        'mandatoryFacilityExecution': MemberSpec_('mandatoryFacilityExecution', 'xsd:boolean', 0),
        'mandatoryFacilityExecutionException': MemberSpec_('mandatoryFacilityExecutionException', 'xsd:boolean', 0),
        'mandatoryFacilityExecutionExceptionDeclaration': MemberSpec_('mandatoryFacilityExecutionExceptionDeclaration', 'FacilityExecutionExceptionDeclaration', 0),
        'exceedsClearingThreshold': MemberSpec_('exceedsClearingThreshold', 'xsd:boolean', 0),
        'entityClassification': MemberSpec_('entityClassification', 'EntityClassification', 0),
        'partyEntityClassification': MemberSpec_('partyEntityClassification', 'PartyEntityClassification', 1),
        'tradePartyRelationshipType': MemberSpec_('tradePartyRelationshipType', 'PartyRelationshipType', 0),
        'actionType': MemberSpec_('actionType', 'ActionType', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, name=None, supervisorRegistration=None, reportingRole=None, reportingPurpose=None, mandatorilyClearable=None, mandatoryFacilityExecution=None, mandatoryFacilityExecutionException=None, mandatoryFacilityExecutionExceptionDeclaration=None, exceedsClearingThreshold=None, entityClassification=None, partyEntityClassification=None, tradePartyRelationshipType=None, actionType=None):
        self.original_tagname_ = None
        self.name = name
        if supervisorRegistration is None:
            self.supervisorRegistration = []
        else:
            self.supervisorRegistration = supervisorRegistration
        if supervisorRegistration is None:
            self.supervisorRegistration = []
        else:
            self.supervisorRegistration = supervisorRegistration
        self.reportingRole = reportingRole
        if reportingPurpose is None:
            self.reportingPurpose = []
        else:
            self.reportingPurpose = reportingPurpose
        self.mandatorilyClearable = mandatorilyClearable
        self.mandatoryFacilityExecution = mandatoryFacilityExecution
        self.mandatoryFacilityExecutionException = mandatoryFacilityExecutionException
        self.mandatoryFacilityExecutionExceptionDeclaration = mandatoryFacilityExecutionExceptionDeclaration
        self.exceedsClearingThreshold = exceedsClearingThreshold
        self.entityClassification = entityClassification
        if partyEntityClassification is None:
            self.partyEntityClassification = []
        else:
            self.partyEntityClassification = partyEntityClassification
        self.tradePartyRelationshipType = tradePartyRelationshipType
        self.actionType = actionType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReportingRegime)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReportingRegime.subclass:
            return ReportingRegime.subclass(*args_, **kwargs_)
        else:
            return ReportingRegime(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_supervisorRegistration(self): return self.supervisorRegistration
    def set_supervisorRegistration(self, supervisorRegistration): self.supervisorRegistration = supervisorRegistration
    def add_supervisorRegistration(self, value): self.supervisorRegistration.append(value)
    def insert_supervisorRegistration_at(self, index, value): self.supervisorRegistration.insert(index, value)
    def replace_supervisorRegistration_at(self, index, value): self.supervisorRegistration[index] = value
    def get_supervisorRegistration(self): return self.supervisorRegistration
    def set_supervisorRegistration(self, supervisorRegistration): self.supervisorRegistration = supervisorRegistration
    def add_supervisorRegistration(self, value): self.supervisorRegistration.append(value)
    def insert_supervisorRegistration_at(self, index, value): self.supervisorRegistration.insert(index, value)
    def replace_supervisorRegistration_at(self, index, value): self.supervisorRegistration[index] = value
    def get_reportingRole(self): return self.reportingRole
    def set_reportingRole(self, reportingRole): self.reportingRole = reportingRole
    def get_reportingPurpose(self): return self.reportingPurpose
    def set_reportingPurpose(self, reportingPurpose): self.reportingPurpose = reportingPurpose
    def add_reportingPurpose(self, value): self.reportingPurpose.append(value)
    def insert_reportingPurpose_at(self, index, value): self.reportingPurpose.insert(index, value)
    def replace_reportingPurpose_at(self, index, value): self.reportingPurpose[index] = value
    def get_mandatorilyClearable(self): return self.mandatorilyClearable
    def set_mandatorilyClearable(self, mandatorilyClearable): self.mandatorilyClearable = mandatorilyClearable
    def get_mandatoryFacilityExecution(self): return self.mandatoryFacilityExecution
    def set_mandatoryFacilityExecution(self, mandatoryFacilityExecution): self.mandatoryFacilityExecution = mandatoryFacilityExecution
    def get_mandatoryFacilityExecutionException(self): return self.mandatoryFacilityExecutionException
    def set_mandatoryFacilityExecutionException(self, mandatoryFacilityExecutionException): self.mandatoryFacilityExecutionException = mandatoryFacilityExecutionException
    def get_mandatoryFacilityExecutionExceptionDeclaration(self): return self.mandatoryFacilityExecutionExceptionDeclaration
    def set_mandatoryFacilityExecutionExceptionDeclaration(self, mandatoryFacilityExecutionExceptionDeclaration): self.mandatoryFacilityExecutionExceptionDeclaration = mandatoryFacilityExecutionExceptionDeclaration
    def get_exceedsClearingThreshold(self): return self.exceedsClearingThreshold
    def set_exceedsClearingThreshold(self, exceedsClearingThreshold): self.exceedsClearingThreshold = exceedsClearingThreshold
    def get_entityClassification(self): return self.entityClassification
    def set_entityClassification(self, entityClassification): self.entityClassification = entityClassification
    def get_partyEntityClassification(self): return self.partyEntityClassification
    def set_partyEntityClassification(self, partyEntityClassification): self.partyEntityClassification = partyEntityClassification
    def add_partyEntityClassification(self, value): self.partyEntityClassification.append(value)
    def insert_partyEntityClassification_at(self, index, value): self.partyEntityClassification.insert(index, value)
    def replace_partyEntityClassification_at(self, index, value): self.partyEntityClassification[index] = value
    def get_tradePartyRelationshipType(self): return self.tradePartyRelationshipType
    def set_tradePartyRelationshipType(self, tradePartyRelationshipType): self.tradePartyRelationshipType = tradePartyRelationshipType
    def get_actionType(self): return self.actionType
    def set_actionType(self, actionType): self.actionType = actionType
    def hasContent_(self):
        if (
            self.name is not None or
            self.supervisorRegistration or
            self.supervisorRegistration or
            self.reportingRole is not None or
            self.reportingPurpose or
            self.mandatorilyClearable is not None or
            self.mandatoryFacilityExecution is not None or
            self.mandatoryFacilityExecutionException is not None or
            self.mandatoryFacilityExecutionExceptionDeclaration is not None or
            self.exceedsClearingThreshold is not None or
            self.entityClassification is not None or
            self.partyEntityClassification or
            self.tradePartyRelationshipType is not None or
            self.actionType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReportingRegime', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReportingRegime')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReportingRegime', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReportingRegime'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ReportingRegime', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            self.name.export(outfile, level, namespace_, name_='name', pretty_print=pretty_print)
        for supervisorRegistration_ in self.supervisorRegistration:
            supervisorRegistration_.export(outfile, level, namespace_, name_='supervisorRegistration', pretty_print=pretty_print)
        for supervisorRegistration_ in self.supervisorRegistration:
            supervisorRegistration_.export(outfile, level, namespace_, name_='supervisorRegistration', pretty_print=pretty_print)
        if self.reportingRole is not None:
            self.reportingRole.export(outfile, level, namespace_, name_='reportingRole', pretty_print=pretty_print)
        for reportingPurpose_ in self.reportingPurpose:
            reportingPurpose_.export(outfile, level, namespace_, name_='reportingPurpose', pretty_print=pretty_print)
        if self.mandatorilyClearable is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smandatorilyClearable>%s</%smandatorilyClearable>%s' % (namespace_, self.gds_format_boolean(self.mandatorilyClearable, input_name='mandatorilyClearable'), namespace_, eol_))
        if self.mandatoryFacilityExecution is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smandatoryFacilityExecution>%s</%smandatoryFacilityExecution>%s' % (namespace_, self.gds_format_boolean(self.mandatoryFacilityExecution, input_name='mandatoryFacilityExecution'), namespace_, eol_))
        if self.mandatoryFacilityExecutionException is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smandatoryFacilityExecutionException>%s</%smandatoryFacilityExecutionException>%s' % (namespace_, self.gds_format_boolean(self.mandatoryFacilityExecutionException, input_name='mandatoryFacilityExecutionException'), namespace_, eol_))
        if self.mandatoryFacilityExecutionExceptionDeclaration is not None:
            self.mandatoryFacilityExecutionExceptionDeclaration.export(outfile, level, namespace_, name_='mandatoryFacilityExecutionExceptionDeclaration', pretty_print=pretty_print)
        if self.exceedsClearingThreshold is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexceedsClearingThreshold>%s</%sexceedsClearingThreshold>%s' % (namespace_, self.gds_format_boolean(self.exceedsClearingThreshold, input_name='exceedsClearingThreshold'), namespace_, eol_))
        if self.entityClassification is not None:
            self.entityClassification.export(outfile, level, namespace_, name_='entityClassification', pretty_print=pretty_print)
        for partyEntityClassification_ in self.partyEntityClassification:
            partyEntityClassification_.export(outfile, level, namespace_, name_='partyEntityClassification', pretty_print=pretty_print)
        if self.tradePartyRelationshipType is not None:
            self.tradePartyRelationshipType.export(outfile, level, namespace_, name_='tradePartyRelationshipType', pretty_print=pretty_print)
        if self.actionType is not None:
            self.actionType.export(outfile, level, namespace_, name_='actionType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            obj_ = ReportingRegimeName.factory()
            obj_.build(child_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'supervisorRegistration':
            obj_ = SupervisorRegistration.factory()
            obj_.build(child_)
            self.supervisorRegistration.append(obj_)
            obj_.original_tagname_ = 'supervisorRegistration'
        elif nodeName_ == 'supervisorRegistration':
            obj_ = SupervisorRegistration.factory()
            obj_.build(child_)
            self.supervisorRegistration.append(obj_)
            obj_.original_tagname_ = 'supervisorRegistration'
        elif nodeName_ == 'reportingRole':
            obj_ = ReportingRole.factory()
            obj_.build(child_)
            self.reportingRole = obj_
            obj_.original_tagname_ = 'reportingRole'
        elif nodeName_ == 'reportingPurpose':
            obj_ = ReportingPurpose.factory()
            obj_.build(child_)
            self.reportingPurpose.append(obj_)
            obj_.original_tagname_ = 'reportingPurpose'
        elif nodeName_ == 'mandatorilyClearable':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'mandatorilyClearable')
            self.mandatorilyClearable = ival_
        elif nodeName_ == 'mandatoryFacilityExecution':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'mandatoryFacilityExecution')
            self.mandatoryFacilityExecution = ival_
        elif nodeName_ == 'mandatoryFacilityExecutionException':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'mandatoryFacilityExecutionException')
            self.mandatoryFacilityExecutionException = ival_
        elif nodeName_ == 'mandatoryFacilityExecutionExceptionDeclaration':
            obj_ = FacilityExecutionExceptionDeclaration.factory()
            obj_.build(child_)
            self.mandatoryFacilityExecutionExceptionDeclaration = obj_
            obj_.original_tagname_ = 'mandatoryFacilityExecutionExceptionDeclaration'
        elif nodeName_ == 'exceedsClearingThreshold':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'exceedsClearingThreshold')
            self.exceedsClearingThreshold = ival_
        elif nodeName_ == 'entityClassification':
            obj_ = EntityClassification.factory()
            obj_.build(child_)
            self.entityClassification = obj_
            obj_.original_tagname_ = 'entityClassification'
        elif nodeName_ == 'partyEntityClassification':
            obj_ = PartyEntityClassification.factory()
            obj_.build(child_)
            self.partyEntityClassification.append(obj_)
            obj_.original_tagname_ = 'partyEntityClassification'
        elif nodeName_ == 'tradePartyRelationshipType':
            obj_ = PartyRelationshipType.factory()
            obj_.build(child_)
            self.tradePartyRelationshipType = obj_
            obj_.original_tagname_ = 'tradePartyRelationshipType'
        elif nodeName_ == 'actionType':
            obj_ = ActionType.factory()
            obj_.build(child_)
            self.actionType = obj_
            obj_.original_tagname_ = 'actionType'
# end class ReportingRegime


class ReportingRole(GeneratedsSuper):
    """A type containing a code representing the role of a party in a
    report, e.g. the originator, the recipient, the counterparty,
    etc. This is used to clarify which participant's information is
    being reported."""
    member_data_items_ = {
        'reportingRoleScheme': MemberSpec_('reportingRoleScheme', 'NonEmptyURI', 0),
        'id': MemberSpec_('id', 'xsd:string', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, reportingRoleScheme='http://www.fpml.org/coding-scheme/reporting-role', id=None, valueOf_=None):
        self.original_tagname_ = None
        self.reportingRoleScheme = _cast(None, reportingRoleScheme)
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReportingRole)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReportingRole.subclass:
            return ReportingRole.subclass(*args_, **kwargs_)
        else:
            return ReportingRole(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_reportingRoleScheme(self): return self.reportingRoleScheme
    def set_reportingRoleScheme(self, reportingRoleScheme): self.reportingRoleScheme = reportingRoleScheme
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReportingRole', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReportingRole')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReportingRole', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReportingRole'):
        if self.reportingRoleScheme != "http://www.fpml.org/coding-scheme/reporting-role" and 'reportingRoleScheme' not in already_processed:
            already_processed.add('reportingRoleScheme')
            outfile.write(' reportingRoleScheme=%s' % (quote_attrib(self.reportingRoleScheme), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ReportingRole', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('reportingRoleScheme', node)
        if value is not None and 'reportingRoleScheme' not in already_processed:
            already_processed.add('reportingRoleScheme')
            self.reportingRoleScheme = value
            self.validate_NonEmptyURI(self.reportingRoleScheme)    # validate type NonEmptyURI
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReportingRole


class ShortSale(GeneratedsSuper):
    """A short sale concluded by an investment firm on its own behalf or on
    behalf of a client, as described in Article 11."""
    member_data_items_ = {
        'shortSaleScheme': MemberSpec_('shortSaleScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, shortSaleScheme='http://www.fpml.org/coding-scheme/mifir/short-sale', valueOf_=None):
        self.original_tagname_ = None
        self.shortSaleScheme = _cast(None, shortSaleScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShortSale)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShortSale.subclass:
            return ShortSale.subclass(*args_, **kwargs_)
        else:
            return ShortSale(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_shortSaleScheme(self): return self.shortSaleScheme
    def set_shortSaleScheme(self, shortSaleScheme): self.shortSaleScheme = shortSaleScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ShortSale', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShortSale')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ShortSale', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ShortSale'):
        if self.shortSaleScheme != "http://www.fpml.org/coding-scheme/mifir/short-sale" and 'shortSaleScheme' not in already_processed:
            already_processed.add('shortSaleScheme')
            outfile.write(' shortSaleScheme=%s' % (quote_attrib(self.shortSaleScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ShortSale', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('shortSaleScheme', node)
        if value is not None and 'shortSaleScheme' not in already_processed:
            already_processed.add('shortSaleScheme')
            self.shortSaleScheme = value
            self.validate_NonEmptyURI(self.shortSaleScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ShortSale


class StrategyComponentIdentification(GeneratedsSuper):
    """Associates trade identifiers with components of a strategy."""
    member_data_items_ = {
        'tradeIdentifierReference': MemberSpec_('tradeIdentifierReference', 'PartyTradeIdentifierReference', 1),
        'componentReference': MemberSpec_('componentReference', 'ProductReference', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, tradeIdentifierReference=None, componentReference=None):
        self.original_tagname_ = None
        if tradeIdentifierReference is None:
            self.tradeIdentifierReference = []
        else:
            self.tradeIdentifierReference = tradeIdentifierReference
        self.componentReference = componentReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrategyComponentIdentification)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrategyComponentIdentification.subclass:
            return StrategyComponentIdentification.subclass(*args_, **kwargs_)
        else:
            return StrategyComponentIdentification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tradeIdentifierReference(self): return self.tradeIdentifierReference
    def set_tradeIdentifierReference(self, tradeIdentifierReference): self.tradeIdentifierReference = tradeIdentifierReference
    def add_tradeIdentifierReference(self, value): self.tradeIdentifierReference.append(value)
    def insert_tradeIdentifierReference_at(self, index, value): self.tradeIdentifierReference.insert(index, value)
    def replace_tradeIdentifierReference_at(self, index, value): self.tradeIdentifierReference[index] = value
    def get_componentReference(self): return self.componentReference
    def set_componentReference(self, componentReference): self.componentReference = componentReference
    def hasContent_(self):
        if (
            self.tradeIdentifierReference or
            self.componentReference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StrategyComponentIdentification', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StrategyComponentIdentification')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StrategyComponentIdentification', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StrategyComponentIdentification'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StrategyComponentIdentification', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for tradeIdentifierReference_ in self.tradeIdentifierReference:
            tradeIdentifierReference_.export(outfile, level, namespace_, name_='tradeIdentifierReference', pretty_print=pretty_print)
        if self.componentReference is not None:
            self.componentReference.export(outfile, level, namespace_, name_='componentReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tradeIdentifierReference':
            obj_ = PartyTradeIdentifierReference.factory()
            obj_.build(child_)
            self.tradeIdentifierReference.append(obj_)
            obj_.original_tagname_ = 'tradeIdentifierReference'
        elif nodeName_ == 'componentReference':
            obj_ = ProductReference.factory()
            obj_.build(child_)
            self.componentReference = obj_
            obj_.original_tagname_ = 'componentReference'
# end class StrategyComponentIdentification


class SupervisorRegistration(GeneratedsSuper):
    """Provides information about a regulator or other supervisory body
    that an organization is registered with."""
    member_data_items_ = {
        'supervisoryBody': MemberSpec_('supervisoryBody', 'SupervisoryBody', 0),
        'registrationNumber': MemberSpec_('registrationNumber', 'RegulatorId', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, supervisoryBody=None, registrationNumber=None):
        self.original_tagname_ = None
        self.supervisoryBody = supervisoryBody
        self.registrationNumber = registrationNumber
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SupervisorRegistration)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SupervisorRegistration.subclass:
            return SupervisorRegistration.subclass(*args_, **kwargs_)
        else:
            return SupervisorRegistration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_supervisoryBody(self): return self.supervisoryBody
    def set_supervisoryBody(self, supervisoryBody): self.supervisoryBody = supervisoryBody
    def get_registrationNumber(self): return self.registrationNumber
    def set_registrationNumber(self, registrationNumber): self.registrationNumber = registrationNumber
    def hasContent_(self):
        if (
            self.supervisoryBody is not None or
            self.registrationNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SupervisorRegistration', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SupervisorRegistration')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SupervisorRegistration', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SupervisorRegistration'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SupervisorRegistration', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.supervisoryBody is not None:
            self.supervisoryBody.export(outfile, level, namespace_, name_='supervisoryBody', pretty_print=pretty_print)
        if self.registrationNumber is not None:
            self.registrationNumber.export(outfile, level, namespace_, name_='registrationNumber', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'supervisoryBody':
            obj_ = SupervisoryBody.factory()
            obj_.build(child_)
            self.supervisoryBody = obj_
            obj_.original_tagname_ = 'supervisoryBody'
        elif nodeName_ == 'registrationNumber':
            obj_ = RegulatorId.factory()
            obj_.build(child_)
            self.registrationNumber = obj_
            obj_.original_tagname_ = 'registrationNumber'
# end class SupervisorRegistration


class TimestampTypeScheme(GeneratedsSuper):
    """The type or meaning of a timestamp."""
    member_data_items_ = {
        'timestampScheme': MemberSpec_('timestampScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, timestampScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.timestampScheme = _cast(None, timestampScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimestampTypeScheme)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimestampTypeScheme.subclass:
            return TimestampTypeScheme.subclass(*args_, **kwargs_)
        else:
            return TimestampTypeScheme(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_timestampScheme(self): return self.timestampScheme
    def set_timestampScheme(self, timestampScheme): self.timestampScheme = timestampScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TimestampTypeScheme', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimestampTypeScheme')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TimestampTypeScheme', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimestampTypeScheme'):
        if self.timestampScheme is not None and 'timestampScheme' not in already_processed:
            already_processed.add('timestampScheme')
            outfile.write(' timestampScheme=%s' % (quote_attrib(self.timestampScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TimestampTypeScheme', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('timestampScheme', node)
        if value is not None and 'timestampScheme' not in already_processed:
            already_processed.add('timestampScheme')
            self.timestampScheme = value
            self.validate_NonEmptyURI(self.timestampScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TimestampTypeScheme


class Trade(GeneratedsSuper):
    """A type defining an FpML trade."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'tradeHeader': MemberSpec_('tradeHeader', 'TradeHeader', 0),
        'product': MemberSpec_('product', 'Product', 0),
        'otherPartyPayment': MemberSpec_('otherPartyPayment', 'Payment', 1),
        'brokerPartyReference': MemberSpec_('brokerPartyReference', 'PartyReference', 1),
        'calculationAgent': MemberSpec_('calculationAgent', 'CalculationAgent', 0),
        'calculationAgentBusinessCenter': MemberSpec_('calculationAgentBusinessCenter', 'BusinessCenter', 0),
        'determiningParty': MemberSpec_('determiningParty', 'PartyReference', 1),
        'barrierDeterminationAgent': MemberSpec_('barrierDeterminationAgent', 'PartyReference', 0),
        'hedgingParty': MemberSpec_('hedgingParty', 'PartyReference', 1),
        'collateral': MemberSpec_('collateral', 'Collateral', 0),
        'documentation': MemberSpec_('documentation', 'Documentation', 0),
        'governingLaw': MemberSpec_('governingLaw', 'GoverningLaw', 0),
        'allocations': MemberSpec_('allocations', 'Allocations', 1),
        'approvals': MemberSpec_('approvals', 'Approvals', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, tradeHeader=None, product=None, otherPartyPayment=None, brokerPartyReference=None, calculationAgent=None, calculationAgentBusinessCenter=None, determiningParty=None, barrierDeterminationAgent=None, hedgingParty=None, collateral=None, documentation=None, governingLaw=None, allocations=None, approvals=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.tradeHeader = tradeHeader
        self.product = product
        if otherPartyPayment is None:
            self.otherPartyPayment = []
        else:
            self.otherPartyPayment = otherPartyPayment
        if brokerPartyReference is None:
            self.brokerPartyReference = []
        else:
            self.brokerPartyReference = brokerPartyReference
        self.calculationAgent = calculationAgent
        self.calculationAgentBusinessCenter = calculationAgentBusinessCenter
        if determiningParty is None:
            self.determiningParty = []
        else:
            self.determiningParty = determiningParty
        self.barrierDeterminationAgent = barrierDeterminationAgent
        if hedgingParty is None:
            self.hedgingParty = []
        else:
            self.hedgingParty = hedgingParty
        self.collateral = collateral
        self.documentation = documentation
        self.governingLaw = governingLaw
        if allocations is None:
            self.allocations = []
        else:
            self.allocations = allocations
        self.approvals = approvals
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Trade)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Trade.subclass:
            return Trade.subclass(*args_, **kwargs_)
        else:
            return Trade(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tradeHeader(self): return self.tradeHeader
    def set_tradeHeader(self, tradeHeader): self.tradeHeader = tradeHeader
    def get_product(self): return self.product
    def set_product(self, product): self.product = product
    def get_otherPartyPayment(self): return self.otherPartyPayment
    def set_otherPartyPayment(self, otherPartyPayment): self.otherPartyPayment = otherPartyPayment
    def add_otherPartyPayment(self, value): self.otherPartyPayment.append(value)
    def insert_otherPartyPayment_at(self, index, value): self.otherPartyPayment.insert(index, value)
    def replace_otherPartyPayment_at(self, index, value): self.otherPartyPayment[index] = value
    def get_brokerPartyReference(self): return self.brokerPartyReference
    def set_brokerPartyReference(self, brokerPartyReference): self.brokerPartyReference = brokerPartyReference
    def add_brokerPartyReference(self, value): self.brokerPartyReference.append(value)
    def insert_brokerPartyReference_at(self, index, value): self.brokerPartyReference.insert(index, value)
    def replace_brokerPartyReference_at(self, index, value): self.brokerPartyReference[index] = value
    def get_calculationAgent(self): return self.calculationAgent
    def set_calculationAgent(self, calculationAgent): self.calculationAgent = calculationAgent
    def get_calculationAgentBusinessCenter(self): return self.calculationAgentBusinessCenter
    def set_calculationAgentBusinessCenter(self, calculationAgentBusinessCenter): self.calculationAgentBusinessCenter = calculationAgentBusinessCenter
    def get_determiningParty(self): return self.determiningParty
    def set_determiningParty(self, determiningParty): self.determiningParty = determiningParty
    def add_determiningParty(self, value): self.determiningParty.append(value)
    def insert_determiningParty_at(self, index, value): self.determiningParty.insert(index, value)
    def replace_determiningParty_at(self, index, value): self.determiningParty[index] = value
    def get_barrierDeterminationAgent(self): return self.barrierDeterminationAgent
    def set_barrierDeterminationAgent(self, barrierDeterminationAgent): self.barrierDeterminationAgent = barrierDeterminationAgent
    def get_hedgingParty(self): return self.hedgingParty
    def set_hedgingParty(self, hedgingParty): self.hedgingParty = hedgingParty
    def add_hedgingParty(self, value): self.hedgingParty.append(value)
    def insert_hedgingParty_at(self, index, value): self.hedgingParty.insert(index, value)
    def replace_hedgingParty_at(self, index, value): self.hedgingParty[index] = value
    def get_collateral(self): return self.collateral
    def set_collateral(self, collateral): self.collateral = collateral
    def get_documentation(self): return self.documentation
    def set_documentation(self, documentation): self.documentation = documentation
    def get_governingLaw(self): return self.governingLaw
    def set_governingLaw(self, governingLaw): self.governingLaw = governingLaw
    def get_allocations(self): return self.allocations
    def set_allocations(self, allocations): self.allocations = allocations
    def add_allocations(self, value): self.allocations.append(value)
    def insert_allocations_at(self, index, value): self.allocations.insert(index, value)
    def replace_allocations_at(self, index, value): self.allocations[index] = value
    def get_approvals(self): return self.approvals
    def set_approvals(self, approvals): self.approvals = approvals
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.tradeHeader is not None or
            self.product is not None or
            self.otherPartyPayment or
            self.brokerPartyReference or
            self.calculationAgent is not None or
            self.calculationAgentBusinessCenter is not None or
            self.determiningParty or
            self.barrierDeterminationAgent is not None or
            self.hedgingParty or
            self.collateral is not None or
            self.documentation is not None or
            self.governingLaw is not None or
            self.allocations or
            self.approvals is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Trade', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Trade')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Trade', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Trade'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Trade', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tradeHeader is not None:
            self.tradeHeader.export(outfile, level, namespace_, name_='tradeHeader', pretty_print=pretty_print)
        if self.product is not None:
            self.product.export(outfile, level, namespace_, name_='product', pretty_print=pretty_print)
        for otherPartyPayment_ in self.otherPartyPayment:
            otherPartyPayment_.export(outfile, level, namespace_, name_='otherPartyPayment', pretty_print=pretty_print)
        for brokerPartyReference_ in self.brokerPartyReference:
            brokerPartyReference_.export(outfile, level, namespace_, name_='brokerPartyReference', pretty_print=pretty_print)
        if self.calculationAgent is not None:
            self.calculationAgent.export(outfile, level, namespace_, name_='calculationAgent', pretty_print=pretty_print)
        if self.calculationAgentBusinessCenter is not None:
            self.calculationAgentBusinessCenter.export(outfile, level, namespace_, name_='calculationAgentBusinessCenter', pretty_print=pretty_print)
        for determiningParty_ in self.determiningParty:
            determiningParty_.export(outfile, level, namespace_, name_='determiningParty', pretty_print=pretty_print)
        if self.barrierDeterminationAgent is not None:
            self.barrierDeterminationAgent.export(outfile, level, namespace_, name_='barrierDeterminationAgent', pretty_print=pretty_print)
        for hedgingParty_ in self.hedgingParty:
            hedgingParty_.export(outfile, level, namespace_, name_='hedgingParty', pretty_print=pretty_print)
        if self.collateral is not None:
            self.collateral.export(outfile, level, namespace_, name_='collateral', pretty_print=pretty_print)
        if self.documentation is not None:
            self.documentation.export(outfile, level, namespace_, name_='documentation', pretty_print=pretty_print)
        if self.governingLaw is not None:
            self.governingLaw.export(outfile, level, namespace_, name_='governingLaw', pretty_print=pretty_print)
        for allocations_ in self.allocations:
            allocations_.export(outfile, level, namespace_, name_='allocations', pretty_print=pretty_print)
        if self.approvals is not None:
            self.approvals.export(outfile, level, namespace_, name_='approvals', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tradeHeader':
            obj_ = TradeHeader.factory()
            obj_.build(child_)
            self.tradeHeader = obj_
            obj_.original_tagname_ = 'tradeHeader'
        elif nodeName_ == 'product':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <product> element')
            self.product = obj_
            obj_.original_tagname_ = 'product'
        elif nodeName_ == 'instrumentTradeDetails':
            obj_ = InstrumentTradeDetails.factory()
            obj_.build(child_)
            self.product = obj_
            obj_.original_tagname_ = 'instrumentTradeDetails'
        elif nodeName_ == 'strategy':
            obj_ = Strategy.factory()
            obj_.build(child_)
            self.product = obj_
            obj_.original_tagname_ = 'strategy'
        elif nodeName_ == 'otherPartyPayment':
            obj_ = Payment.factory()
            obj_.build(child_)
            self.otherPartyPayment.append(obj_)
            obj_.original_tagname_ = 'otherPartyPayment'
        elif nodeName_ == 'brokerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.brokerPartyReference.append(obj_)
            obj_.original_tagname_ = 'brokerPartyReference'
        elif nodeName_ == 'calculationAgent':
            obj_ = CalculationAgent.factory()
            obj_.build(child_)
            self.calculationAgent = obj_
            obj_.original_tagname_ = 'calculationAgent'
        elif nodeName_ == 'calculationAgentBusinessCenter':
            obj_ = BusinessCenter.factory()
            obj_.build(child_)
            self.calculationAgentBusinessCenter = obj_
            obj_.original_tagname_ = 'calculationAgentBusinessCenter'
        elif nodeName_ == 'determiningParty':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.determiningParty.append(obj_)
            obj_.original_tagname_ = 'determiningParty'
        elif nodeName_ == 'barrierDeterminationAgent':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.barrierDeterminationAgent = obj_
            obj_.original_tagname_ = 'barrierDeterminationAgent'
        elif nodeName_ == 'hedgingParty':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.hedgingParty.append(obj_)
            obj_.original_tagname_ = 'hedgingParty'
        elif nodeName_ == 'collateral':
            obj_ = Collateral.factory()
            obj_.build(child_)
            self.collateral = obj_
            obj_.original_tagname_ = 'collateral'
        elif nodeName_ == 'documentation':
            obj_ = Documentation.factory()
            obj_.build(child_)
            self.documentation = obj_
            obj_.original_tagname_ = 'documentation'
        elif nodeName_ == 'governingLaw':
            obj_ = GoverningLaw.factory()
            obj_.build(child_)
            self.governingLaw = obj_
            obj_.original_tagname_ = 'governingLaw'
        elif nodeName_ == 'allocations':
            obj_ = Allocations.factory()
            obj_.build(child_)
            self.allocations.append(obj_)
            obj_.original_tagname_ = 'allocations'
        elif nodeName_ == 'approvals':
            obj_ = Approvals.factory()
            obj_.build(child_)
            self.approvals = obj_
            obj_.original_tagname_ = 'approvals'
# end class Trade


class TradeCategory(GeneratedsSuper):
    """A scheme used to categorize positions."""
    member_data_items_ = {
        'categoryScheme': MemberSpec_('categoryScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, categoryScheme='http://www.fpml.org/coding-scheme/org-type-category', valueOf_=None):
        self.original_tagname_ = None
        self.categoryScheme = _cast(None, categoryScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TradeCategory)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TradeCategory.subclass:
            return TradeCategory.subclass(*args_, **kwargs_)
        else:
            return TradeCategory(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_categoryScheme(self): return self.categoryScheme
    def set_categoryScheme(self, categoryScheme): self.categoryScheme = categoryScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TradeCategory', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TradeCategory')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TradeCategory', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TradeCategory'):
        if self.categoryScheme != "http://www.fpml.org/coding-scheme/org-type-category" and 'categoryScheme' not in already_processed:
            already_processed.add('categoryScheme')
            outfile.write(' categoryScheme=%s' % (quote_attrib(self.categoryScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TradeCategory', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('categoryScheme', node)
        if value is not None and 'categoryScheme' not in already_processed:
            already_processed.add('categoryScheme')
            self.categoryScheme = value
            self.validate_NonEmptyURI(self.categoryScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TradeCategory


class TradeDifference(GeneratedsSuper):
    """A type used to record the details of a difference between two
    business objects/"""
    member_data_items_ = {
        'differenceType': MemberSpec_('differenceType', ['DifferenceTypeEnum', 'Token', 'xsd:token'], 0),
        'differenceSeverity': MemberSpec_('differenceSeverity', ['DifferenceSeverityEnum', 'Token', 'xsd:token'], 0),
        'element': MemberSpec_('element', ['String', 'xsd:string'], 0),
        'basePath': MemberSpec_('basePath', ['String', 'xsd:string'], 0),
        'baseValue': MemberSpec_('baseValue', ['String', 'xsd:string'], 0),
        'otherPath': MemberSpec_('otherPath', ['String', 'xsd:string'], 0),
        'otherValue': MemberSpec_('otherValue', ['String', 'xsd:string'], 0),
        'missingElement': MemberSpec_('missingElement', ['String', 'xsd:string'], 1),
        'extraElement': MemberSpec_('extraElement', ['String', 'xsd:string'], 1),
        'message': MemberSpec_('message', ['String', 'xsd:string'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, differenceType=None, differenceSeverity=None, element=None, basePath=None, baseValue=None, otherPath=None, otherValue=None, missingElement=None, extraElement=None, message=None):
        self.original_tagname_ = None
        self.differenceType = differenceType
        self.validate_DifferenceTypeEnum(self.differenceType)
        self.differenceSeverity = differenceSeverity
        self.validate_DifferenceSeverityEnum(self.differenceSeverity)
        self.element = element
        self.validate_String(self.element)
        self.basePath = basePath
        self.validate_String(self.basePath)
        self.baseValue = baseValue
        self.validate_String(self.baseValue)
        self.otherPath = otherPath
        self.validate_String(self.otherPath)
        self.otherValue = otherValue
        self.validate_String(self.otherValue)
        if missingElement is None:
            self.missingElement = []
        else:
            self.missingElement = missingElement
        if extraElement is None:
            self.extraElement = []
        else:
            self.extraElement = extraElement
        self.message = message
        self.validate_String(self.message)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TradeDifference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TradeDifference.subclass:
            return TradeDifference.subclass(*args_, **kwargs_)
        else:
            return TradeDifference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_differenceType(self): return self.differenceType
    def set_differenceType(self, differenceType): self.differenceType = differenceType
    def get_differenceSeverity(self): return self.differenceSeverity
    def set_differenceSeverity(self, differenceSeverity): self.differenceSeverity = differenceSeverity
    def get_element(self): return self.element
    def set_element(self, element): self.element = element
    def get_basePath(self): return self.basePath
    def set_basePath(self, basePath): self.basePath = basePath
    def get_baseValue(self): return self.baseValue
    def set_baseValue(self, baseValue): self.baseValue = baseValue
    def get_otherPath(self): return self.otherPath
    def set_otherPath(self, otherPath): self.otherPath = otherPath
    def get_otherValue(self): return self.otherValue
    def set_otherValue(self, otherValue): self.otherValue = otherValue
    def get_missingElement(self): return self.missingElement
    def set_missingElement(self, missingElement): self.missingElement = missingElement
    def add_missingElement(self, value): self.missingElement.append(value)
    def insert_missingElement_at(self, index, value): self.missingElement.insert(index, value)
    def replace_missingElement_at(self, index, value): self.missingElement[index] = value
    def get_extraElement(self): return self.extraElement
    def set_extraElement(self, extraElement): self.extraElement = extraElement
    def add_extraElement(self, value): self.extraElement.append(value)
    def insert_extraElement_at(self, index, value): self.extraElement.insert(index, value)
    def replace_extraElement_at(self, index, value): self.extraElement[index] = value
    def get_message(self): return self.message
    def set_message(self, message): self.message = message
    def validate_DifferenceTypeEnum(self, value):
        # Validate type DifferenceTypeEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Value', 'Reference', 'Structure', 'Scheme']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DifferenceTypeEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on DifferenceTypeEnum' % {"value" : value} )
    def validate_DifferenceSeverityEnum(self, value):
        # Validate type DifferenceSeverityEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Warning', 'Error']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DifferenceSeverityEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on DifferenceSeverityEnum' % {"value" : value} )
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.differenceType is not None or
            self.differenceSeverity is not None or
            self.element is not None or
            self.basePath is not None or
            self.baseValue is not None or
            self.otherPath is not None or
            self.otherValue is not None or
            self.missingElement or
            self.extraElement or
            self.message is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TradeDifference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TradeDifference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TradeDifference', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TradeDifference'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TradeDifference', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.differenceType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdifferenceType>%s</%sdifferenceType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.differenceType), input_name='differenceType')), namespace_, eol_))
        if self.differenceSeverity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdifferenceSeverity>%s</%sdifferenceSeverity>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.differenceSeverity), input_name='differenceSeverity')), namespace_, eol_))
        if self.element is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%selement>%s</%selement>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.element), input_name='element')), namespace_, eol_))
        if self.basePath is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbasePath>%s</%sbasePath>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.basePath), input_name='basePath')), namespace_, eol_))
        if self.baseValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbaseValue>%s</%sbaseValue>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.baseValue), input_name='baseValue')), namespace_, eol_))
        if self.otherPath is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sotherPath>%s</%sotherPath>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.otherPath), input_name='otherPath')), namespace_, eol_))
        if self.otherValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sotherValue>%s</%sotherValue>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.otherValue), input_name='otherValue')), namespace_, eol_))
        for missingElement_ in self.missingElement:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smissingElement>%s</%smissingElement>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(missingElement_), input_name='missingElement')), namespace_, eol_))
        for extraElement_ in self.extraElement:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sextraElement>%s</%sextraElement>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(extraElement_), input_name='extraElement')), namespace_, eol_))
        if self.message is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smessage>%s</%smessage>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.message), input_name='message')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'differenceType':
            differenceType_ = child_.text
            differenceType_ = re_.sub(String_cleanup_pat_, " ", differenceType_).strip()
            differenceType_ = self.gds_validate_string(differenceType_, node, 'differenceType')
            self.differenceType = differenceType_
            # validate type DifferenceTypeEnum
            self.validate_DifferenceTypeEnum(self.differenceType)
        elif nodeName_ == 'differenceSeverity':
            differenceSeverity_ = child_.text
            differenceSeverity_ = re_.sub(String_cleanup_pat_, " ", differenceSeverity_).strip()
            differenceSeverity_ = self.gds_validate_string(differenceSeverity_, node, 'differenceSeverity')
            self.differenceSeverity = differenceSeverity_
            # validate type DifferenceSeverityEnum
            self.validate_DifferenceSeverityEnum(self.differenceSeverity)
        elif nodeName_ == 'element':
            element_ = child_.text
            element_ = self.gds_validate_string(element_, node, 'element')
            self.element = element_
            # validate type String
            self.validate_String(self.element)
        elif nodeName_ == 'basePath':
            basePath_ = child_.text
            basePath_ = self.gds_validate_string(basePath_, node, 'basePath')
            self.basePath = basePath_
            # validate type String
            self.validate_String(self.basePath)
        elif nodeName_ == 'baseValue':
            baseValue_ = child_.text
            baseValue_ = self.gds_validate_string(baseValue_, node, 'baseValue')
            self.baseValue = baseValue_
            # validate type String
            self.validate_String(self.baseValue)
        elif nodeName_ == 'otherPath':
            otherPath_ = child_.text
            otherPath_ = self.gds_validate_string(otherPath_, node, 'otherPath')
            self.otherPath = otherPath_
            # validate type String
            self.validate_String(self.otherPath)
        elif nodeName_ == 'otherValue':
            otherValue_ = child_.text
            otherValue_ = self.gds_validate_string(otherValue_, node, 'otherValue')
            self.otherValue = otherValue_
            # validate type String
            self.validate_String(self.otherValue)
        elif nodeName_ == 'missingElement':
            missingElement_ = child_.text
            missingElement_ = self.gds_validate_string(missingElement_, node, 'missingElement')
            self.missingElement.append(missingElement_)
            # validate type String
            self.validate_String(self.missingElement[-1])
        elif nodeName_ == 'extraElement':
            extraElement_ = child_.text
            extraElement_ = self.gds_validate_string(extraElement_, node, 'extraElement')
            self.extraElement.append(extraElement_)
            # validate type String
            self.validate_String(self.extraElement[-1])
        elif nodeName_ == 'message':
            message_ = child_.text
            message_ = self.gds_validate_string(message_, node, 'message')
            self.message = message_
            # validate type String
            self.validate_String(self.message)
# end class TradeDifference


class TradeHeader(GeneratedsSuper):
    """A type defining trade related information which is not product
    specific."""
    member_data_items_ = {
        'partyTradeIdentifier': MemberSpec_('partyTradeIdentifier', 'PartyTradeIdentifier', 1),
        'tradeInformation': MemberSpec_('tradeInformation', 'TradeInformation', 0),
        'partyTradeInformation': MemberSpec_('partyTradeInformation', 'PartyTradeInformation', 1),
        'originatingPackage': MemberSpec_('originatingPackage', 'PackageSummary', 0),
        'tradeDate': MemberSpec_('tradeDate', 'IdentifiedDate', 0),
        'clearedDate': MemberSpec_('clearedDate', 'IdentifiedDate', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, partyTradeIdentifier=None, tradeInformation=None, partyTradeInformation=None, originatingPackage=None, tradeDate=None, clearedDate=None):
        self.original_tagname_ = None
        if partyTradeIdentifier is None:
            self.partyTradeIdentifier = []
        else:
            self.partyTradeIdentifier = partyTradeIdentifier
        self.tradeInformation = tradeInformation
        if partyTradeInformation is None:
            self.partyTradeInformation = []
        else:
            self.partyTradeInformation = partyTradeInformation
        self.originatingPackage = originatingPackage
        self.tradeDate = tradeDate
        self.clearedDate = clearedDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TradeHeader)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TradeHeader.subclass:
            return TradeHeader.subclass(*args_, **kwargs_)
        else:
            return TradeHeader(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyTradeIdentifier(self): return self.partyTradeIdentifier
    def set_partyTradeIdentifier(self, partyTradeIdentifier): self.partyTradeIdentifier = partyTradeIdentifier
    def add_partyTradeIdentifier(self, value): self.partyTradeIdentifier.append(value)
    def insert_partyTradeIdentifier_at(self, index, value): self.partyTradeIdentifier.insert(index, value)
    def replace_partyTradeIdentifier_at(self, index, value): self.partyTradeIdentifier[index] = value
    def get_tradeInformation(self): return self.tradeInformation
    def set_tradeInformation(self, tradeInformation): self.tradeInformation = tradeInformation
    def get_partyTradeInformation(self): return self.partyTradeInformation
    def set_partyTradeInformation(self, partyTradeInformation): self.partyTradeInformation = partyTradeInformation
    def add_partyTradeInformation(self, value): self.partyTradeInformation.append(value)
    def insert_partyTradeInformation_at(self, index, value): self.partyTradeInformation.insert(index, value)
    def replace_partyTradeInformation_at(self, index, value): self.partyTradeInformation[index] = value
    def get_originatingPackage(self): return self.originatingPackage
    def set_originatingPackage(self, originatingPackage): self.originatingPackage = originatingPackage
    def get_tradeDate(self): return self.tradeDate
    def set_tradeDate(self, tradeDate): self.tradeDate = tradeDate
    def get_clearedDate(self): return self.clearedDate
    def set_clearedDate(self, clearedDate): self.clearedDate = clearedDate
    def hasContent_(self):
        if (
            self.partyTradeIdentifier or
            self.tradeInformation is not None or
            self.partyTradeInformation or
            self.originatingPackage is not None or
            self.tradeDate is not None or
            self.clearedDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TradeHeader', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TradeHeader')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TradeHeader', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TradeHeader'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TradeHeader', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for partyTradeIdentifier_ in self.partyTradeIdentifier:
            partyTradeIdentifier_.export(outfile, level, namespace_, name_='partyTradeIdentifier', pretty_print=pretty_print)
        if self.tradeInformation is not None:
            self.tradeInformation.export(outfile, level, namespace_, name_='tradeInformation', pretty_print=pretty_print)
        for partyTradeInformation_ in self.partyTradeInformation:
            partyTradeInformation_.export(outfile, level, namespace_, name_='partyTradeInformation', pretty_print=pretty_print)
        if self.originatingPackage is not None:
            self.originatingPackage.export(outfile, level, namespace_, name_='originatingPackage', pretty_print=pretty_print)
        if self.tradeDate is not None:
            self.tradeDate.export(outfile, level, namespace_, name_='tradeDate', pretty_print=pretty_print)
        if self.clearedDate is not None:
            self.clearedDate.export(outfile, level, namespace_, name_='clearedDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'partyTradeIdentifier':
            obj_ = PartyTradeIdentifier.factory()
            obj_.build(child_)
            self.partyTradeIdentifier.append(obj_)
            obj_.original_tagname_ = 'partyTradeIdentifier'
        elif nodeName_ == 'tradeInformation':
            obj_ = TradeInformation.factory()
            obj_.build(child_)
            self.tradeInformation = obj_
            obj_.original_tagname_ = 'tradeInformation'
        elif nodeName_ == 'partyTradeInformation':
            obj_ = PartyTradeInformation.factory()
            obj_.build(child_)
            self.partyTradeInformation.append(obj_)
            obj_.original_tagname_ = 'partyTradeInformation'
        elif nodeName_ == 'originatingPackage':
            obj_ = PackageSummary.factory()
            obj_.build(child_)
            self.originatingPackage = obj_
            obj_.original_tagname_ = 'originatingPackage'
        elif nodeName_ == 'tradeDate':
            obj_ = IdentifiedDate.factory()
            obj_.build(child_)
            self.tradeDate = obj_
            obj_.original_tagname_ = 'tradeDate'
        elif nodeName_ == 'clearedDate':
            obj_ = IdentifiedDate.factory()
            obj_.build(child_)
            self.clearedDate = obj_
            obj_.original_tagname_ = 'clearedDate'
# end class TradeHeader


class TradeIdentifier(GeneratedsSuper):
    """A type defining a trade identifier issued by the indicated party."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'issuer': MemberSpec_('issuer', 'IssuerId', 0),
        'tradeId': MemberSpec_('tradeId', 'TradeId', 0),
        'partyReference': MemberSpec_('partyReference', 'PartyReference', 0),
        'accountReference': MemberSpec_('accountReference', 'AccountReference', 0),
        'reportingRole': MemberSpec_('reportingRole', 'ReportingRole', 0),
        'tradeId': MemberSpec_('tradeId', 'TradeId', 1),
        'versionedTradeId': MemberSpec_('versionedTradeId', 'VersionedTradeId', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, issuer=None, tradeId=None, partyReference=None, accountReference=None, reportingRole=None, versionedTradeId=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.issuer = issuer
        self.tradeId = tradeId
        self.partyReference = partyReference
        self.accountReference = accountReference
        self.reportingRole = reportingRole
        if tradeId is None:
            self.tradeId = []
        else:
            self.tradeId = tradeId
        if versionedTradeId is None:
            self.versionedTradeId = []
        else:
            self.versionedTradeId = versionedTradeId
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TradeIdentifier)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TradeIdentifier.subclass:
            return TradeIdentifier.subclass(*args_, **kwargs_)
        else:
            return TradeIdentifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_issuer(self): return self.issuer
    def set_issuer(self, issuer): self.issuer = issuer
    def get_tradeId(self): return self.tradeId
    def set_tradeId(self, tradeId): self.tradeId = tradeId
    def get_partyReference(self): return self.partyReference
    def set_partyReference(self, partyReference): self.partyReference = partyReference
    def get_accountReference(self): return self.accountReference
    def set_accountReference(self, accountReference): self.accountReference = accountReference
    def get_reportingRole(self): return self.reportingRole
    def set_reportingRole(self, reportingRole): self.reportingRole = reportingRole
    def get_tradeId(self): return self.tradeId
    def set_tradeId(self, tradeId): self.tradeId = tradeId
    def add_tradeId(self, value): self.tradeId.append(value)
    def insert_tradeId_at(self, index, value): self.tradeId.insert(index, value)
    def replace_tradeId_at(self, index, value): self.tradeId[index] = value
    def get_versionedTradeId(self): return self.versionedTradeId
    def set_versionedTradeId(self, versionedTradeId): self.versionedTradeId = versionedTradeId
    def add_versionedTradeId(self, value): self.versionedTradeId.append(value)
    def insert_versionedTradeId_at(self, index, value): self.versionedTradeId.insert(index, value)
    def replace_versionedTradeId_at(self, index, value): self.versionedTradeId[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.issuer is not None or
            self.tradeId is not None or
            self.partyReference is not None or
            self.accountReference is not None or
            self.reportingRole is not None or
            self.tradeId or
            self.versionedTradeId
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TradeIdentifier', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TradeIdentifier')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TradeIdentifier', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TradeIdentifier'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='TradeIdentifier', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.issuer is not None:
            self.issuer.export(outfile, level, namespace_, name_='issuer', pretty_print=pretty_print)
        if self.tradeId is not None:
            self.tradeId.export(outfile, level, namespace_, name_='tradeId', pretty_print=pretty_print)
        if self.partyReference is not None:
            self.partyReference.export(outfile, level, namespace_, name_='partyReference', pretty_print=pretty_print)
        if self.accountReference is not None:
            self.accountReference.export(outfile, level, namespace_, name_='accountReference', pretty_print=pretty_print)
        if self.reportingRole is not None:
            self.reportingRole.export(outfile, level, namespace_, name_='reportingRole', pretty_print=pretty_print)
        for tradeId_ in self.tradeId:
            tradeId_.export(outfile, level, namespace_, name_='tradeId', pretty_print=pretty_print)
        for versionedTradeId_ in self.versionedTradeId:
            versionedTradeId_.export(outfile, level, namespace_, name_='versionedTradeId', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'issuer':
            obj_ = IssuerId.factory()
            obj_.build(child_)
            self.issuer = obj_
            obj_.original_tagname_ = 'issuer'
        elif nodeName_ == 'tradeId':
            obj_ = TradeId.factory()
            obj_.build(child_)
            self.tradeId = obj_
            obj_.original_tagname_ = 'tradeId'
        elif nodeName_ == 'partyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.partyReference = obj_
            obj_.original_tagname_ = 'partyReference'
        elif nodeName_ == 'accountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.accountReference = obj_
            obj_.original_tagname_ = 'accountReference'
        elif nodeName_ == 'reportingRole':
            obj_ = ReportingRole.factory()
            obj_.build(child_)
            self.reportingRole = obj_
            obj_.original_tagname_ = 'reportingRole'
        elif nodeName_ == 'tradeId':
            obj_ = TradeId.factory()
            obj_.build(child_)
            self.tradeId.append(obj_)
            obj_.original_tagname_ = 'tradeId'
        elif nodeName_ == 'versionedTradeId':
            obj_ = VersionedTradeId.factory()
            obj_.build(child_)
            self.versionedTradeId.append(obj_)
            obj_.original_tagname_ = 'versionedTradeId'
# end class TradeIdentifier


class TradeInformation(GeneratedsSuper):
    """A type defining additional information that may be recorded against
    a trade."""
    member_data_items_ = {
        'relatedParty': MemberSpec_('relatedParty', 'RelatedParty', 1),
        'reportingRole': MemberSpec_('reportingRole', 'ReportingRole', 0),
        'description': MemberSpec_('description', ['String', 'xsd:string'], 0),
        'unit': MemberSpec_('unit', 'Unit', 1),
        'relatedBusinessUnit': MemberSpec_('relatedBusinessUnit', 'RelatedBusinessUnit', 1),
        'relatedPerson': MemberSpec_('relatedPerson', 'RelatedPerson', 1),
        'isAccountingHedge': MemberSpec_('isAccountingHedge', 'xsd:boolean', 0),
        'category': MemberSpec_('category', 'TradeCategory', 1),
        'trader': MemberSpec_('trader', 'Trader', 1),
        'executionDateTime': MemberSpec_('executionDateTime', 'ExecutionDateTime', 0),
        'timestamps': MemberSpec_('timestamps', 'TradeProcessingTimestamps', 0),
        'intentToAllocate': MemberSpec_('intentToAllocate', 'xsd:boolean', 0),
        'allocationStatus': MemberSpec_('allocationStatus', 'AllocationReportingStatus', 0),
        'intentToClear': MemberSpec_('intentToClear', 'xsd:boolean', 0),
        'clearingStatus': MemberSpec_('clearingStatus', 'ClearingStatusValue', 0),
        'collateralizationType': MemberSpec_('collateralizationType', 'CollateralizationType', 0),
        'reportingRegime': MemberSpec_('reportingRegime', 'ReportingRegime', 1),
        'endUserException': MemberSpec_('endUserException', 'xsd:boolean', 0),
        'endUserExceptionDeclaration': MemberSpec_('endUserExceptionDeclaration', 'EndUserExceptionDeclaration', 0),
        'nonStandardTerms': MemberSpec_('nonStandardTerms', 'xsd:boolean', 0),
        'offMarketPrice': MemberSpec_('offMarketPrice', 'xsd:boolean', 0),
        'pricingContext': MemberSpec_('pricingContext', 'PricingContext', 0),
        'largeSizeTrade': MemberSpec_('largeSizeTrade', 'xsd:boolean', 0),
        'executionType': MemberSpec_('executionType', 'ExecutionType', 0),
        'executionVenueType': MemberSpec_('executionVenueType', 'ExecutionVenueType', 0),
        'verificationMethod': MemberSpec_('verificationMethod', 'VerificationMethod', 0),
        'confirmationMethod': MemberSpec_('confirmationMethod', 'ConfirmationMethod', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, relatedParty=None, reportingRole=None, description=None, unit=None, relatedBusinessUnit=None, relatedPerson=None, isAccountingHedge=None, category=None, trader=None, executionDateTime=None, timestamps=None, intentToAllocate=None, allocationStatus=None, intentToClear=None, clearingStatus=None, collateralizationType=None, reportingRegime=None, endUserException=None, endUserExceptionDeclaration=None, nonStandardTerms=None, offMarketPrice=None, pricingContext=None, largeSizeTrade=None, executionType=None, executionVenueType=None, verificationMethod=None, confirmationMethod=None):
        self.original_tagname_ = None
        if relatedParty is None:
            self.relatedParty = []
        else:
            self.relatedParty = relatedParty
        self.reportingRole = reportingRole
        self.description = description
        self.validate_String(self.description)
        if unit is None:
            self.unit = []
        else:
            self.unit = unit
        if relatedBusinessUnit is None:
            self.relatedBusinessUnit = []
        else:
            self.relatedBusinessUnit = relatedBusinessUnit
        if relatedPerson is None:
            self.relatedPerson = []
        else:
            self.relatedPerson = relatedPerson
        self.isAccountingHedge = isAccountingHedge
        if category is None:
            self.category = []
        else:
            self.category = category
        if trader is None:
            self.trader = []
        else:
            self.trader = trader
        self.executionDateTime = executionDateTime
        self.timestamps = timestamps
        self.intentToAllocate = intentToAllocate
        self.allocationStatus = allocationStatus
        self.intentToClear = intentToClear
        self.clearingStatus = clearingStatus
        self.collateralizationType = collateralizationType
        if reportingRegime is None:
            self.reportingRegime = []
        else:
            self.reportingRegime = reportingRegime
        self.endUserException = endUserException
        self.endUserExceptionDeclaration = endUserExceptionDeclaration
        self.nonStandardTerms = nonStandardTerms
        self.offMarketPrice = offMarketPrice
        self.pricingContext = pricingContext
        self.largeSizeTrade = largeSizeTrade
        self.executionType = executionType
        self.executionVenueType = executionVenueType
        self.verificationMethod = verificationMethod
        self.confirmationMethod = confirmationMethod
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TradeInformation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TradeInformation.subclass:
            return TradeInformation.subclass(*args_, **kwargs_)
        else:
            return TradeInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_relatedParty(self): return self.relatedParty
    def set_relatedParty(self, relatedParty): self.relatedParty = relatedParty
    def add_relatedParty(self, value): self.relatedParty.append(value)
    def insert_relatedParty_at(self, index, value): self.relatedParty.insert(index, value)
    def replace_relatedParty_at(self, index, value): self.relatedParty[index] = value
    def get_reportingRole(self): return self.reportingRole
    def set_reportingRole(self, reportingRole): self.reportingRole = reportingRole
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def add_unit(self, value): self.unit.append(value)
    def insert_unit_at(self, index, value): self.unit.insert(index, value)
    def replace_unit_at(self, index, value): self.unit[index] = value
    def get_relatedBusinessUnit(self): return self.relatedBusinessUnit
    def set_relatedBusinessUnit(self, relatedBusinessUnit): self.relatedBusinessUnit = relatedBusinessUnit
    def add_relatedBusinessUnit(self, value): self.relatedBusinessUnit.append(value)
    def insert_relatedBusinessUnit_at(self, index, value): self.relatedBusinessUnit.insert(index, value)
    def replace_relatedBusinessUnit_at(self, index, value): self.relatedBusinessUnit[index] = value
    def get_relatedPerson(self): return self.relatedPerson
    def set_relatedPerson(self, relatedPerson): self.relatedPerson = relatedPerson
    def add_relatedPerson(self, value): self.relatedPerson.append(value)
    def insert_relatedPerson_at(self, index, value): self.relatedPerson.insert(index, value)
    def replace_relatedPerson_at(self, index, value): self.relatedPerson[index] = value
    def get_isAccountingHedge(self): return self.isAccountingHedge
    def set_isAccountingHedge(self, isAccountingHedge): self.isAccountingHedge = isAccountingHedge
    def get_category(self): return self.category
    def set_category(self, category): self.category = category
    def add_category(self, value): self.category.append(value)
    def insert_category_at(self, index, value): self.category.insert(index, value)
    def replace_category_at(self, index, value): self.category[index] = value
    def get_trader(self): return self.trader
    def set_trader(self, trader): self.trader = trader
    def add_trader(self, value): self.trader.append(value)
    def insert_trader_at(self, index, value): self.trader.insert(index, value)
    def replace_trader_at(self, index, value): self.trader[index] = value
    def get_executionDateTime(self): return self.executionDateTime
    def set_executionDateTime(self, executionDateTime): self.executionDateTime = executionDateTime
    def get_timestamps(self): return self.timestamps
    def set_timestamps(self, timestamps): self.timestamps = timestamps
    def get_intentToAllocate(self): return self.intentToAllocate
    def set_intentToAllocate(self, intentToAllocate): self.intentToAllocate = intentToAllocate
    def get_allocationStatus(self): return self.allocationStatus
    def set_allocationStatus(self, allocationStatus): self.allocationStatus = allocationStatus
    def get_intentToClear(self): return self.intentToClear
    def set_intentToClear(self, intentToClear): self.intentToClear = intentToClear
    def get_clearingStatus(self): return self.clearingStatus
    def set_clearingStatus(self, clearingStatus): self.clearingStatus = clearingStatus
    def get_collateralizationType(self): return self.collateralizationType
    def set_collateralizationType(self, collateralizationType): self.collateralizationType = collateralizationType
    def get_reportingRegime(self): return self.reportingRegime
    def set_reportingRegime(self, reportingRegime): self.reportingRegime = reportingRegime
    def add_reportingRegime(self, value): self.reportingRegime.append(value)
    def insert_reportingRegime_at(self, index, value): self.reportingRegime.insert(index, value)
    def replace_reportingRegime_at(self, index, value): self.reportingRegime[index] = value
    def get_endUserException(self): return self.endUserException
    def set_endUserException(self, endUserException): self.endUserException = endUserException
    def get_endUserExceptionDeclaration(self): return self.endUserExceptionDeclaration
    def set_endUserExceptionDeclaration(self, endUserExceptionDeclaration): self.endUserExceptionDeclaration = endUserExceptionDeclaration
    def get_nonStandardTerms(self): return self.nonStandardTerms
    def set_nonStandardTerms(self, nonStandardTerms): self.nonStandardTerms = nonStandardTerms
    def get_offMarketPrice(self): return self.offMarketPrice
    def set_offMarketPrice(self, offMarketPrice): self.offMarketPrice = offMarketPrice
    def get_pricingContext(self): return self.pricingContext
    def set_pricingContext(self, pricingContext): self.pricingContext = pricingContext
    def get_largeSizeTrade(self): return self.largeSizeTrade
    def set_largeSizeTrade(self, largeSizeTrade): self.largeSizeTrade = largeSizeTrade
    def get_executionType(self): return self.executionType
    def set_executionType(self, executionType): self.executionType = executionType
    def get_executionVenueType(self): return self.executionVenueType
    def set_executionVenueType(self, executionVenueType): self.executionVenueType = executionVenueType
    def get_verificationMethod(self): return self.verificationMethod
    def set_verificationMethod(self, verificationMethod): self.verificationMethod = verificationMethod
    def get_confirmationMethod(self): return self.confirmationMethod
    def set_confirmationMethod(self, confirmationMethod): self.confirmationMethod = confirmationMethod
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.relatedParty or
            self.reportingRole is not None or
            self.description is not None or
            self.unit or
            self.relatedBusinessUnit or
            self.relatedPerson or
            self.isAccountingHedge is not None or
            self.category or
            self.trader or
            self.executionDateTime is not None or
            self.timestamps is not None or
            self.intentToAllocate is not None or
            self.allocationStatus is not None or
            self.intentToClear is not None or
            self.clearingStatus is not None or
            self.collateralizationType is not None or
            self.reportingRegime or
            self.endUserException is not None or
            self.endUserExceptionDeclaration is not None or
            self.nonStandardTerms is not None or
            self.offMarketPrice is not None or
            self.pricingContext is not None or
            self.largeSizeTrade is not None or
            self.executionType is not None or
            self.executionVenueType is not None or
            self.verificationMethod is not None or
            self.confirmationMethod is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TradeInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TradeInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TradeInformation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TradeInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TradeInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for relatedParty_ in self.relatedParty:
            relatedParty_.export(outfile, level, namespace_, name_='relatedParty', pretty_print=pretty_print)
        if self.reportingRole is not None:
            self.reportingRole.export(outfile, level, namespace_, name_='reportingRole', pretty_print=pretty_print)
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespace_, eol_))
        for unit_ in self.unit:
            unit_.export(outfile, level, namespace_, name_='unit', pretty_print=pretty_print)
        for relatedBusinessUnit_ in self.relatedBusinessUnit:
            relatedBusinessUnit_.export(outfile, level, namespace_, name_='relatedBusinessUnit', pretty_print=pretty_print)
        for relatedPerson_ in self.relatedPerson:
            relatedPerson_.export(outfile, level, namespace_, name_='relatedPerson', pretty_print=pretty_print)
        if self.isAccountingHedge is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sisAccountingHedge>%s</%sisAccountingHedge>%s' % (namespace_, self.gds_format_boolean(self.isAccountingHedge, input_name='isAccountingHedge'), namespace_, eol_))
        for category_ in self.category:
            category_.export(outfile, level, namespace_, name_='category', pretty_print=pretty_print)
        for trader_ in self.trader:
            trader_.export(outfile, level, namespace_, name_='trader', pretty_print=pretty_print)
        if self.executionDateTime is not None:
            self.executionDateTime.export(outfile, level, namespace_, name_='executionDateTime', pretty_print=pretty_print)
        if self.timestamps is not None:
            self.timestamps.export(outfile, level, namespace_, name_='timestamps', pretty_print=pretty_print)
        if self.intentToAllocate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sintentToAllocate>%s</%sintentToAllocate>%s' % (namespace_, self.gds_format_boolean(self.intentToAllocate, input_name='intentToAllocate'), namespace_, eol_))
        if self.allocationStatus is not None:
            self.allocationStatus.export(outfile, level, namespace_, name_='allocationStatus', pretty_print=pretty_print)
        if self.intentToClear is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sintentToClear>%s</%sintentToClear>%s' % (namespace_, self.gds_format_boolean(self.intentToClear, input_name='intentToClear'), namespace_, eol_))
        if self.clearingStatus is not None:
            self.clearingStatus.export(outfile, level, namespace_, name_='clearingStatus', pretty_print=pretty_print)
        if self.collateralizationType is not None:
            self.collateralizationType.export(outfile, level, namespace_, name_='collateralizationType', pretty_print=pretty_print)
        for reportingRegime_ in self.reportingRegime:
            reportingRegime_.export(outfile, level, namespace_, name_='reportingRegime', pretty_print=pretty_print)
        if self.endUserException is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sendUserException>%s</%sendUserException>%s' % (namespace_, self.gds_format_boolean(self.endUserException, input_name='endUserException'), namespace_, eol_))
        if self.endUserExceptionDeclaration is not None:
            self.endUserExceptionDeclaration.export(outfile, level, namespace_, name_='endUserExceptionDeclaration', pretty_print=pretty_print)
        if self.nonStandardTerms is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snonStandardTerms>%s</%snonStandardTerms>%s' % (namespace_, self.gds_format_boolean(self.nonStandardTerms, input_name='nonStandardTerms'), namespace_, eol_))
        if self.offMarketPrice is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soffMarketPrice>%s</%soffMarketPrice>%s' % (namespace_, self.gds_format_boolean(self.offMarketPrice, input_name='offMarketPrice'), namespace_, eol_))
        if self.pricingContext is not None:
            self.pricingContext.export(outfile, level, namespace_, name_='pricingContext', pretty_print=pretty_print)
        if self.largeSizeTrade is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slargeSizeTrade>%s</%slargeSizeTrade>%s' % (namespace_, self.gds_format_boolean(self.largeSizeTrade, input_name='largeSizeTrade'), namespace_, eol_))
        if self.executionType is not None:
            self.executionType.export(outfile, level, namespace_, name_='executionType', pretty_print=pretty_print)
        if self.executionVenueType is not None:
            self.executionVenueType.export(outfile, level, namespace_, name_='executionVenueType', pretty_print=pretty_print)
        if self.verificationMethod is not None:
            self.verificationMethod.export(outfile, level, namespace_, name_='verificationMethod', pretty_print=pretty_print)
        if self.confirmationMethod is not None:
            self.confirmationMethod.export(outfile, level, namespace_, name_='confirmationMethod', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'relatedParty':
            obj_ = RelatedParty.factory()
            obj_.build(child_)
            self.relatedParty.append(obj_)
            obj_.original_tagname_ = 'relatedParty'
        elif nodeName_ == 'reportingRole':
            obj_ = ReportingRole.factory()
            obj_.build(child_)
            self.reportingRole = obj_
            obj_.original_tagname_ = 'reportingRole'
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
            # validate type String
            self.validate_String(self.description)
        elif nodeName_ == 'unit':
            obj_ = Unit.factory()
            obj_.build(child_)
            self.unit.append(obj_)
            obj_.original_tagname_ = 'unit'
        elif nodeName_ == 'relatedBusinessUnit':
            obj_ = RelatedBusinessUnit.factory()
            obj_.build(child_)
            self.relatedBusinessUnit.append(obj_)
            obj_.original_tagname_ = 'relatedBusinessUnit'
        elif nodeName_ == 'relatedPerson':
            obj_ = RelatedPerson.factory()
            obj_.build(child_)
            self.relatedPerson.append(obj_)
            obj_.original_tagname_ = 'relatedPerson'
        elif nodeName_ == 'isAccountingHedge':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'isAccountingHedge')
            self.isAccountingHedge = ival_
        elif nodeName_ == 'category':
            obj_ = TradeCategory.factory()
            obj_.build(child_)
            self.category.append(obj_)
            obj_.original_tagname_ = 'category'
        elif nodeName_ == 'trader':
            obj_ = Trader.factory()
            obj_.build(child_)
            self.trader.append(obj_)
            obj_.original_tagname_ = 'trader'
        elif nodeName_ == 'executionDateTime':
            obj_ = ExecutionDateTime.factory()
            obj_.build(child_)
            self.executionDateTime = obj_
            obj_.original_tagname_ = 'executionDateTime'
        elif nodeName_ == 'timestamps':
            obj_ = TradeProcessingTimestamps.factory()
            obj_.build(child_)
            self.timestamps = obj_
            obj_.original_tagname_ = 'timestamps'
        elif nodeName_ == 'intentToAllocate':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'intentToAllocate')
            self.intentToAllocate = ival_
        elif nodeName_ == 'allocationStatus':
            obj_ = AllocationReportingStatus.factory()
            obj_.build(child_)
            self.allocationStatus = obj_
            obj_.original_tagname_ = 'allocationStatus'
        elif nodeName_ == 'intentToClear':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'intentToClear')
            self.intentToClear = ival_
        elif nodeName_ == 'clearingStatus':
            obj_ = ClearingStatusValue.factory()
            obj_.build(child_)
            self.clearingStatus = obj_
            obj_.original_tagname_ = 'clearingStatus'
        elif nodeName_ == 'collateralizationType':
            obj_ = CollateralizationType.factory()
            obj_.build(child_)
            self.collateralizationType = obj_
            obj_.original_tagname_ = 'collateralizationType'
        elif nodeName_ == 'reportingRegime':
            obj_ = ReportingRegime.factory()
            obj_.build(child_)
            self.reportingRegime.append(obj_)
            obj_.original_tagname_ = 'reportingRegime'
        elif nodeName_ == 'endUserException':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'endUserException')
            self.endUserException = ival_
        elif nodeName_ == 'endUserExceptionDeclaration':
            obj_ = EndUserExceptionDeclaration.factory()
            obj_.build(child_)
            self.endUserExceptionDeclaration = obj_
            obj_.original_tagname_ = 'endUserExceptionDeclaration'
        elif nodeName_ == 'nonStandardTerms':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'nonStandardTerms')
            self.nonStandardTerms = ival_
        elif nodeName_ == 'offMarketPrice':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'offMarketPrice')
            self.offMarketPrice = ival_
        elif nodeName_ == 'pricingContext':
            obj_ = PricingContext.factory()
            obj_.build(child_)
            self.pricingContext = obj_
            obj_.original_tagname_ = 'pricingContext'
        elif nodeName_ == 'largeSizeTrade':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'largeSizeTrade')
            self.largeSizeTrade = ival_
        elif nodeName_ == 'executionType':
            obj_ = ExecutionType.factory()
            obj_.build(child_)
            self.executionType = obj_
            obj_.original_tagname_ = 'executionType'
        elif nodeName_ == 'executionVenueType':
            obj_ = ExecutionVenueType.factory()
            obj_.build(child_)
            self.executionVenueType = obj_
            obj_.original_tagname_ = 'executionVenueType'
        elif nodeName_ == 'verificationMethod':
            obj_ = VerificationMethod.factory()
            obj_.build(child_)
            self.verificationMethod = obj_
            obj_.original_tagname_ = 'verificationMethod'
        elif nodeName_ == 'confirmationMethod':
            obj_ = ConfirmationMethod.factory()
            obj_.build(child_)
            self.confirmationMethod = obj_
            obj_.original_tagname_ = 'confirmationMethod'
# end class TradeInformation


class TradeProcessingTimestamps(GeneratedsSuper):
    """Allows timing information about when a trade was processed and
    reported to be recorded."""
    member_data_items_ = {
        'orderEntered': MemberSpec_('orderEntered', 'xsd:dateTime', 0),
        'orderSubmitted': MemberSpec_('orderSubmitted', 'xsd:dateTime', 0),
        'publiclyReported': MemberSpec_('publiclyReported', 'xsd:dateTime', 0),
        'publicReportUpdated': MemberSpec_('publicReportUpdated', 'xsd:dateTime', 0),
        'nonpubliclyReported': MemberSpec_('nonpubliclyReported', 'xsd:dateTime', 0),
        'nonpublicReportUpdated': MemberSpec_('nonpublicReportUpdated', 'xsd:dateTime', 0),
        'submittedForConfirmation': MemberSpec_('submittedForConfirmation', 'xsd:dateTime', 0),
        'updatedForConfirmation': MemberSpec_('updatedForConfirmation', 'xsd:dateTime', 0),
        'confirmed': MemberSpec_('confirmed', 'xsd:dateTime', 0),
        'submittedForClearing': MemberSpec_('submittedForClearing', 'xsd:dateTime', 0),
        'updatedForClearing': MemberSpec_('updatedForClearing', 'xsd:dateTime', 0),
        'cleared': MemberSpec_('cleared', 'xsd:dateTime', 0),
        'allocationsSubmitted': MemberSpec_('allocationsSubmitted', 'xsd:dateTime', 0),
        'allocationsUpdated': MemberSpec_('allocationsUpdated', 'xsd:dateTime', 0),
        'allocationsCompleted': MemberSpec_('allocationsCompleted', 'xsd:dateTime', 0),
        'timestamp': MemberSpec_('timestamp', 'TradeTimestamp', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, orderEntered=None, orderSubmitted=None, publiclyReported=None, publicReportUpdated=None, nonpubliclyReported=None, nonpublicReportUpdated=None, submittedForConfirmation=None, updatedForConfirmation=None, confirmed=None, submittedForClearing=None, updatedForClearing=None, cleared=None, allocationsSubmitted=None, allocationsUpdated=None, allocationsCompleted=None, timestamp=None):
        self.original_tagname_ = None
        if isinstance(orderEntered, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(orderEntered, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = orderEntered
        self.orderEntered = initvalue_
        if isinstance(orderSubmitted, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(orderSubmitted, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = orderSubmitted
        self.orderSubmitted = initvalue_
        if isinstance(publiclyReported, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(publiclyReported, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = publiclyReported
        self.publiclyReported = initvalue_
        if isinstance(publicReportUpdated, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(publicReportUpdated, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = publicReportUpdated
        self.publicReportUpdated = initvalue_
        if isinstance(nonpubliclyReported, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(nonpubliclyReported, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = nonpubliclyReported
        self.nonpubliclyReported = initvalue_
        if isinstance(nonpublicReportUpdated, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(nonpublicReportUpdated, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = nonpublicReportUpdated
        self.nonpublicReportUpdated = initvalue_
        if isinstance(submittedForConfirmation, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(submittedForConfirmation, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = submittedForConfirmation
        self.submittedForConfirmation = initvalue_
        if isinstance(updatedForConfirmation, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(updatedForConfirmation, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = updatedForConfirmation
        self.updatedForConfirmation = initvalue_
        if isinstance(confirmed, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(confirmed, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = confirmed
        self.confirmed = initvalue_
        if isinstance(submittedForClearing, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(submittedForClearing, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = submittedForClearing
        self.submittedForClearing = initvalue_
        if isinstance(updatedForClearing, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(updatedForClearing, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = updatedForClearing
        self.updatedForClearing = initvalue_
        if isinstance(cleared, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(cleared, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = cleared
        self.cleared = initvalue_
        if isinstance(allocationsSubmitted, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(allocationsSubmitted, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = allocationsSubmitted
        self.allocationsSubmitted = initvalue_
        if isinstance(allocationsUpdated, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(allocationsUpdated, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = allocationsUpdated
        self.allocationsUpdated = initvalue_
        if isinstance(allocationsCompleted, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(allocationsCompleted, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = allocationsCompleted
        self.allocationsCompleted = initvalue_
        if timestamp is None:
            self.timestamp = []
        else:
            self.timestamp = timestamp
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TradeProcessingTimestamps)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TradeProcessingTimestamps.subclass:
            return TradeProcessingTimestamps.subclass(*args_, **kwargs_)
        else:
            return TradeProcessingTimestamps(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_orderEntered(self): return self.orderEntered
    def set_orderEntered(self, orderEntered): self.orderEntered = orderEntered
    def get_orderSubmitted(self): return self.orderSubmitted
    def set_orderSubmitted(self, orderSubmitted): self.orderSubmitted = orderSubmitted
    def get_publiclyReported(self): return self.publiclyReported
    def set_publiclyReported(self, publiclyReported): self.publiclyReported = publiclyReported
    def get_publicReportUpdated(self): return self.publicReportUpdated
    def set_publicReportUpdated(self, publicReportUpdated): self.publicReportUpdated = publicReportUpdated
    def get_nonpubliclyReported(self): return self.nonpubliclyReported
    def set_nonpubliclyReported(self, nonpubliclyReported): self.nonpubliclyReported = nonpubliclyReported
    def get_nonpublicReportUpdated(self): return self.nonpublicReportUpdated
    def set_nonpublicReportUpdated(self, nonpublicReportUpdated): self.nonpublicReportUpdated = nonpublicReportUpdated
    def get_submittedForConfirmation(self): return self.submittedForConfirmation
    def set_submittedForConfirmation(self, submittedForConfirmation): self.submittedForConfirmation = submittedForConfirmation
    def get_updatedForConfirmation(self): return self.updatedForConfirmation
    def set_updatedForConfirmation(self, updatedForConfirmation): self.updatedForConfirmation = updatedForConfirmation
    def get_confirmed(self): return self.confirmed
    def set_confirmed(self, confirmed): self.confirmed = confirmed
    def get_submittedForClearing(self): return self.submittedForClearing
    def set_submittedForClearing(self, submittedForClearing): self.submittedForClearing = submittedForClearing
    def get_updatedForClearing(self): return self.updatedForClearing
    def set_updatedForClearing(self, updatedForClearing): self.updatedForClearing = updatedForClearing
    def get_cleared(self): return self.cleared
    def set_cleared(self, cleared): self.cleared = cleared
    def get_allocationsSubmitted(self): return self.allocationsSubmitted
    def set_allocationsSubmitted(self, allocationsSubmitted): self.allocationsSubmitted = allocationsSubmitted
    def get_allocationsUpdated(self): return self.allocationsUpdated
    def set_allocationsUpdated(self, allocationsUpdated): self.allocationsUpdated = allocationsUpdated
    def get_allocationsCompleted(self): return self.allocationsCompleted
    def set_allocationsCompleted(self, allocationsCompleted): self.allocationsCompleted = allocationsCompleted
    def get_timestamp(self): return self.timestamp
    def set_timestamp(self, timestamp): self.timestamp = timestamp
    def add_timestamp(self, value): self.timestamp.append(value)
    def insert_timestamp_at(self, index, value): self.timestamp.insert(index, value)
    def replace_timestamp_at(self, index, value): self.timestamp[index] = value
    def hasContent_(self):
        if (
            self.orderEntered is not None or
            self.orderSubmitted is not None or
            self.publiclyReported is not None or
            self.publicReportUpdated is not None or
            self.nonpubliclyReported is not None or
            self.nonpublicReportUpdated is not None or
            self.submittedForConfirmation is not None or
            self.updatedForConfirmation is not None or
            self.confirmed is not None or
            self.submittedForClearing is not None or
            self.updatedForClearing is not None or
            self.cleared is not None or
            self.allocationsSubmitted is not None or
            self.allocationsUpdated is not None or
            self.allocationsCompleted is not None or
            self.timestamp
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TradeProcessingTimestamps', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TradeProcessingTimestamps')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TradeProcessingTimestamps', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TradeProcessingTimestamps'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TradeProcessingTimestamps', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orderEntered is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorderEntered>%s</%sorderEntered>%s' % (namespace_, self.gds_format_datetime(self.orderEntered, input_name='orderEntered'), namespace_, eol_))
        if self.orderSubmitted is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorderSubmitted>%s</%sorderSubmitted>%s' % (namespace_, self.gds_format_datetime(self.orderSubmitted, input_name='orderSubmitted'), namespace_, eol_))
        if self.publiclyReported is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spubliclyReported>%s</%spubliclyReported>%s' % (namespace_, self.gds_format_datetime(self.publiclyReported, input_name='publiclyReported'), namespace_, eol_))
        if self.publicReportUpdated is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spublicReportUpdated>%s</%spublicReportUpdated>%s' % (namespace_, self.gds_format_datetime(self.publicReportUpdated, input_name='publicReportUpdated'), namespace_, eol_))
        if self.nonpubliclyReported is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snonpubliclyReported>%s</%snonpubliclyReported>%s' % (namespace_, self.gds_format_datetime(self.nonpubliclyReported, input_name='nonpubliclyReported'), namespace_, eol_))
        if self.nonpublicReportUpdated is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snonpublicReportUpdated>%s</%snonpublicReportUpdated>%s' % (namespace_, self.gds_format_datetime(self.nonpublicReportUpdated, input_name='nonpublicReportUpdated'), namespace_, eol_))
        if self.submittedForConfirmation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssubmittedForConfirmation>%s</%ssubmittedForConfirmation>%s' % (namespace_, self.gds_format_datetime(self.submittedForConfirmation, input_name='submittedForConfirmation'), namespace_, eol_))
        if self.updatedForConfirmation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%supdatedForConfirmation>%s</%supdatedForConfirmation>%s' % (namespace_, self.gds_format_datetime(self.updatedForConfirmation, input_name='updatedForConfirmation'), namespace_, eol_))
        if self.confirmed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sconfirmed>%s</%sconfirmed>%s' % (namespace_, self.gds_format_datetime(self.confirmed, input_name='confirmed'), namespace_, eol_))
        if self.submittedForClearing is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssubmittedForClearing>%s</%ssubmittedForClearing>%s' % (namespace_, self.gds_format_datetime(self.submittedForClearing, input_name='submittedForClearing'), namespace_, eol_))
        if self.updatedForClearing is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%supdatedForClearing>%s</%supdatedForClearing>%s' % (namespace_, self.gds_format_datetime(self.updatedForClearing, input_name='updatedForClearing'), namespace_, eol_))
        if self.cleared is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scleared>%s</%scleared>%s' % (namespace_, self.gds_format_datetime(self.cleared, input_name='cleared'), namespace_, eol_))
        if self.allocationsSubmitted is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sallocationsSubmitted>%s</%sallocationsSubmitted>%s' % (namespace_, self.gds_format_datetime(self.allocationsSubmitted, input_name='allocationsSubmitted'), namespace_, eol_))
        if self.allocationsUpdated is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sallocationsUpdated>%s</%sallocationsUpdated>%s' % (namespace_, self.gds_format_datetime(self.allocationsUpdated, input_name='allocationsUpdated'), namespace_, eol_))
        if self.allocationsCompleted is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sallocationsCompleted>%s</%sallocationsCompleted>%s' % (namespace_, self.gds_format_datetime(self.allocationsCompleted, input_name='allocationsCompleted'), namespace_, eol_))
        for timestamp_ in self.timestamp:
            timestamp_.export(outfile, level, namespace_, name_='timestamp', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orderEntered':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.orderEntered = dval_
        elif nodeName_ == 'orderSubmitted':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.orderSubmitted = dval_
        elif nodeName_ == 'publiclyReported':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.publiclyReported = dval_
        elif nodeName_ == 'publicReportUpdated':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.publicReportUpdated = dval_
        elif nodeName_ == 'nonpubliclyReported':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.nonpubliclyReported = dval_
        elif nodeName_ == 'nonpublicReportUpdated':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.nonpublicReportUpdated = dval_
        elif nodeName_ == 'submittedForConfirmation':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.submittedForConfirmation = dval_
        elif nodeName_ == 'updatedForConfirmation':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.updatedForConfirmation = dval_
        elif nodeName_ == 'confirmed':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.confirmed = dval_
        elif nodeName_ == 'submittedForClearing':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.submittedForClearing = dval_
        elif nodeName_ == 'updatedForClearing':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.updatedForClearing = dval_
        elif nodeName_ == 'cleared':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.cleared = dval_
        elif nodeName_ == 'allocationsSubmitted':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.allocationsSubmitted = dval_
        elif nodeName_ == 'allocationsUpdated':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.allocationsUpdated = dval_
        elif nodeName_ == 'allocationsCompleted':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.allocationsCompleted = dval_
        elif nodeName_ == 'timestamp':
            obj_ = TradeTimestamp.factory()
            obj_.build(child_)
            self.timestamp.append(obj_)
            obj_.original_tagname_ = 'timestamp'
# end class TradeProcessingTimestamps


class Trader(GeneratedsSuper):
    member_data_items_ = {
        'traderScheme': MemberSpec_('traderScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, traderScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.traderScheme = _cast(None, traderScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Trader)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Trader.subclass:
            return Trader.subclass(*args_, **kwargs_)
        else:
            return Trader(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_traderScheme(self): return self.traderScheme
    def set_traderScheme(self, traderScheme): self.traderScheme = traderScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Trader', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Trader')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Trader', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Trader'):
        if self.traderScheme is not None and 'traderScheme' not in already_processed:
            already_processed.add('traderScheme')
            outfile.write(' traderScheme=%s' % (quote_attrib(self.traderScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Trader', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('traderScheme', node)
        if value is not None and 'traderScheme' not in already_processed:
            already_processed.add('traderScheme')
            self.traderScheme = value
            self.validate_NonEmptyURI(self.traderScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Trader


class TradeTimestamp(GeneratedsSuper):
    """A generic trade timestamp"""
    member_data_items_ = {
        'type_': MemberSpec_('type_', 'TimestampTypeScheme', 0),
        'value': MemberSpec_('value', 'xsd:dateTime', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, type_=None, value=None):
        self.original_tagname_ = None
        self.type_ = type_
        if isinstance(value, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(value, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = value
        self.value = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TradeTimestamp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TradeTimestamp.subclass:
            return TradeTimestamp.subclass(*args_, **kwargs_)
        else:
            return TradeTimestamp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (
            self.type_ is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TradeTimestamp', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TradeTimestamp')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TradeTimestamp', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TradeTimestamp'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TradeTimestamp', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            self.type_.export(outfile, level, namespace_, name_='type', pretty_print=pretty_print)
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_datetime(self.value, input_name='value'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            obj_ = TimestampTypeScheme.factory()
            obj_.build(child_)
            self.type_ = obj_
            obj_.original_tagname_ = 'type'
        elif nodeName_ == 'value':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.value = dval_
# end class TradeTimestamp


class TradingWaiver(GeneratedsSuper):
    """Indication as to whether the transaction was executed under a pre-
    trade waiver in accordance with Articles 4 and 9 of Regulation
    (EU) 600/2014."""
    member_data_items_ = {
        'tradingWaiverScheme': MemberSpec_('tradingWaiverScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, tradingWaiverScheme='http://www.fpml.org/coding-scheme/mifir/trading-waiver', valueOf_=None):
        self.original_tagname_ = None
        self.tradingWaiverScheme = _cast(None, tradingWaiverScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TradingWaiver)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TradingWaiver.subclass:
            return TradingWaiver.subclass(*args_, **kwargs_)
        else:
            return TradingWaiver(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tradingWaiverScheme(self): return self.tradingWaiverScheme
    def set_tradingWaiverScheme(self, tradingWaiverScheme): self.tradingWaiverScheme = tradingWaiverScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TradingWaiver', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TradingWaiver')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TradingWaiver', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TradingWaiver'):
        if self.tradingWaiverScheme != "http://www.fpml.org/coding-scheme/mifir/trading-waiver" and 'tradingWaiverScheme' not in already_processed:
            already_processed.add('tradingWaiverScheme')
            outfile.write(' tradingWaiverScheme=%s' % (quote_attrib(self.tradingWaiverScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TradingWaiver', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('tradingWaiverScheme', node)
        if value is not None and 'tradingWaiverScheme' not in already_processed:
            already_processed.add('tradingWaiverScheme')
            self.tradingWaiverScheme = value
            self.validate_NonEmptyURI(self.tradingWaiverScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TradingWaiver


class TransactionCharacteristic(GeneratedsSuper):
    """A characteristic of a transaction used in declaring an end-user
    exception."""
    member_data_items_ = {
        'transactionCharacteristicScheme': MemberSpec_('transactionCharacteristicScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, transactionCharacteristicScheme='http://www.fpml.org/coding-scheme/transaction-characteristic', valueOf_=None):
        self.original_tagname_ = None
        self.transactionCharacteristicScheme = _cast(None, transactionCharacteristicScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransactionCharacteristic)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransactionCharacteristic.subclass:
            return TransactionCharacteristic.subclass(*args_, **kwargs_)
        else:
            return TransactionCharacteristic(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_transactionCharacteristicScheme(self): return self.transactionCharacteristicScheme
    def set_transactionCharacteristicScheme(self, transactionCharacteristicScheme): self.transactionCharacteristicScheme = transactionCharacteristicScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TransactionCharacteristic', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TransactionCharacteristic')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TransactionCharacteristic', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TransactionCharacteristic'):
        if self.transactionCharacteristicScheme != "http://www.fpml.org/coding-scheme/transaction-characteristic" and 'transactionCharacteristicScheme' not in already_processed:
            already_processed.add('transactionCharacteristicScheme')
            outfile.write(' transactionCharacteristicScheme=%s' % (quote_attrib(self.transactionCharacteristicScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TransactionCharacteristic', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('transactionCharacteristicScheme', node)
        if value is not None and 'transactionCharacteristicScheme' not in already_processed:
            already_processed.add('transactionCharacteristicScheme')
            self.transactionCharacteristicScheme = value
            self.validate_NonEmptyURI(self.transactionCharacteristicScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TransactionCharacteristic


class Validation(GeneratedsSuper):
    """A reference identifying a rule within a validation scheme."""
    member_data_items_ = {
        'validationScheme': MemberSpec_('validationScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, validationScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.validationScheme = _cast(None, validationScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Validation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Validation.subclass:
            return Validation.subclass(*args_, **kwargs_)
        else:
            return Validation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_validationScheme(self): return self.validationScheme
    def set_validationScheme(self, validationScheme): self.validationScheme = validationScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Validation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Validation')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Validation', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Validation'):
        if self.validationScheme is not None and 'validationScheme' not in already_processed:
            already_processed.add('validationScheme')
            outfile.write(' validationScheme=%s' % (quote_attrib(self.validationScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Validation', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('validationScheme', node)
        if value is not None and 'validationScheme' not in already_processed:
            already_processed.add('validationScheme')
            self.validationScheme = value
            self.validate_NonEmptyURI(self.validationScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Validation


class VerificationMethod(GeneratedsSuper):
    """A type used to represent the type of mechanism that can be used to
    verify a trade."""
    member_data_items_ = {
        'verificationMethodScheme': MemberSpec_('verificationMethodScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, verificationMethodScheme='http://www.fpml.org/coding-scheme/verification-method', valueOf_=None):
        self.original_tagname_ = None
        self.verificationMethodScheme = _cast(None, verificationMethodScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VerificationMethod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VerificationMethod.subclass:
            return VerificationMethod.subclass(*args_, **kwargs_)
        else:
            return VerificationMethod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_verificationMethodScheme(self): return self.verificationMethodScheme
    def set_verificationMethodScheme(self, verificationMethodScheme): self.verificationMethodScheme = verificationMethodScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VerificationMethod', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VerificationMethod')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VerificationMethod', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VerificationMethod'):
        if self.verificationMethodScheme != "http://www.fpml.org/coding-scheme/verification-method" and 'verificationMethodScheme' not in already_processed:
            already_processed.add('verificationMethodScheme')
            outfile.write(' verificationMethodScheme=%s' % (quote_attrib(self.verificationMethodScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='VerificationMethod', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('verificationMethodScheme', node)
        if value is not None and 'verificationMethodScheme' not in already_processed:
            already_processed.add('verificationMethodScheme')
            self.verificationMethodScheme = value
            self.validate_NonEmptyURI(self.verificationMethodScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VerificationMethod


class VersionedContractId(GeneratedsSuper):
    """Contract Id with Version Support"""
    member_data_items_ = {
        'contractId': MemberSpec_('contractId', 'ContractId', 0),
        'version': MemberSpec_('version', 'xsd:nonNegativeInteger', 0),
        'effectiveDate': MemberSpec_('effectiveDate', 'IdentifiedDate', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, contractId=None, version=None, effectiveDate=None):
        self.original_tagname_ = None
        self.contractId = contractId
        self.version = version
        self.effectiveDate = effectiveDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VersionedContractId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VersionedContractId.subclass:
            return VersionedContractId.subclass(*args_, **kwargs_)
        else:
            return VersionedContractId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_contractId(self): return self.contractId
    def set_contractId(self, contractId): self.contractId = contractId
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_effectiveDate(self): return self.effectiveDate
    def set_effectiveDate(self, effectiveDate): self.effectiveDate = effectiveDate
    def hasContent_(self):
        if (
            self.contractId is not None or
            self.version is not None or
            self.effectiveDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VersionedContractId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VersionedContractId')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VersionedContractId', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VersionedContractId'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VersionedContractId', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.contractId is not None:
            self.contractId.export(outfile, level, namespace_, name_='contractId', pretty_print=pretty_print)
        if self.version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sversion>%s</%sversion>%s' % (namespace_, self.gds_format_integer(self.version, input_name='version'), namespace_, eol_))
        if self.effectiveDate is not None:
            self.effectiveDate.export(outfile, level, namespace_, name_='effectiveDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'contractId':
            obj_ = ContractId.factory()
            obj_.build(child_)
            self.contractId = obj_
            obj_.original_tagname_ = 'contractId'
        elif nodeName_ == 'version':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'version')
            self.version = ival_
        elif nodeName_ == 'effectiveDate':
            obj_ = IdentifiedDate.factory()
            obj_.build(child_)
            self.effectiveDate = obj_
            obj_.original_tagname_ = 'effectiveDate'
# end class VersionedContractId


class VersionedTradeId(GeneratedsSuper):
    """Trade Id with Version Support"""
    member_data_items_ = {
        'tradeId': MemberSpec_('tradeId', 'TradeId', 0),
        'version': MemberSpec_('version', 'xsd:nonNegativeInteger', 0),
        'effectiveDate': MemberSpec_('effectiveDate', 'IdentifiedDate', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, tradeId=None, version=None, effectiveDate=None):
        self.original_tagname_ = None
        self.tradeId = tradeId
        self.version = version
        self.effectiveDate = effectiveDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VersionedTradeId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VersionedTradeId.subclass:
            return VersionedTradeId.subclass(*args_, **kwargs_)
        else:
            return VersionedTradeId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tradeId(self): return self.tradeId
    def set_tradeId(self, tradeId): self.tradeId = tradeId
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_effectiveDate(self): return self.effectiveDate
    def set_effectiveDate(self, effectiveDate): self.effectiveDate = effectiveDate
    def hasContent_(self):
        if (
            self.tradeId is not None or
            self.version is not None or
            self.effectiveDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VersionedTradeId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VersionedTradeId')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VersionedTradeId', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VersionedTradeId'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VersionedTradeId', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tradeId is not None:
            self.tradeId.export(outfile, level, namespace_, name_='tradeId', pretty_print=pretty_print)
        if self.version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sversion>%s</%sversion>%s' % (namespace_, self.gds_format_integer(self.version, input_name='version'), namespace_, eol_))
        if self.effectiveDate is not None:
            self.effectiveDate.export(outfile, level, namespace_, name_='effectiveDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tradeId':
            obj_ = TradeId.factory()
            obj_.build(child_)
            self.tradeId = obj_
            obj_.original_tagname_ = 'tradeId'
        elif nodeName_ == 'version':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'version')
            self.version = ival_
        elif nodeName_ == 'effectiveDate':
            obj_ = IdentifiedDate.factory()
            obj_.build(child_)
            self.effectiveDate = obj_
            obj_.original_tagname_ = 'effectiveDate'
# end class VersionedTradeId


class ActualPrice(GeneratedsSuper):
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'currency': MemberSpec_('currency', 'Currency', 0),
        'amount': MemberSpec_('amount', 'xsd:decimal', 0),
        'priceExpression': MemberSpec_('priceExpression', ['PriceExpressionEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, currency=None, amount=None, priceExpression=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.currency = currency
        self.amount = amount
        self.priceExpression = priceExpression
        self.validate_PriceExpressionEnum(self.priceExpression)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ActualPrice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ActualPrice.subclass:
            return ActualPrice.subclass(*args_, **kwargs_)
        else:
            return ActualPrice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_amount(self): return self.amount
    def set_amount(self, amount): self.amount = amount
    def get_priceExpression(self): return self.priceExpression
    def set_priceExpression(self, priceExpression): self.priceExpression = priceExpression
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_PriceExpressionEnum(self, value):
        # Validate type PriceExpressionEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AbsoluteTerms', 'PercentageOfNotional']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PriceExpressionEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on PriceExpressionEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.currency is not None or
            self.amount is not None or
            self.priceExpression is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ActualPrice', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActualPrice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ActualPrice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ActualPrice'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ActualPrice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.currency is not None:
            self.currency.export(outfile, level, namespace_, name_='currency', pretty_print=pretty_print)
        if self.amount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%samount>%s</%samount>%s' % (namespace_, self.gds_format_float(self.amount, input_name='amount'), namespace_, eol_))
        if self.priceExpression is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spriceExpression>%s</%spriceExpression>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.priceExpression), input_name='priceExpression')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'currency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'amount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'amount')
            self.amount = fval_
        elif nodeName_ == 'priceExpression':
            priceExpression_ = child_.text
            priceExpression_ = re_.sub(String_cleanup_pat_, " ", priceExpression_).strip()
            priceExpression_ = self.gds_validate_string(priceExpression_, node, 'priceExpression')
            self.priceExpression = priceExpression_
            # validate type PriceExpressionEnum
            self.validate_PriceExpressionEnum(self.priceExpression)
# end class ActualPrice


class Asset(GeneratedsSuper):
    """Abstract base class for all underlying assets."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Asset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Asset.subclass:
            return Asset.subclass(*args_, **kwargs_)
        else:
            return Asset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Asset', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Asset')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Asset', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Asset'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Asset', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Asset


class AssetMeasureType(GeneratedsSuper):
    """A scheme identifying the types of measures that can be used to
    describe an asset."""
    member_data_items_ = {
        'assetMeasureScheme': MemberSpec_('assetMeasureScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, assetMeasureScheme='http://www.fpml.org/coding-scheme/asset-measure', valueOf_=None):
        self.original_tagname_ = None
        self.assetMeasureScheme = _cast(None, assetMeasureScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AssetMeasureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AssetMeasureType.subclass:
            return AssetMeasureType.subclass(*args_, **kwargs_)
        else:
            return AssetMeasureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_assetMeasureScheme(self): return self.assetMeasureScheme
    def set_assetMeasureScheme(self, assetMeasureScheme): self.assetMeasureScheme = assetMeasureScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AssetMeasureType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AssetMeasureType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AssetMeasureType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AssetMeasureType'):
        if self.assetMeasureScheme != "http://www.fpml.org/coding-scheme/asset-measure" and 'assetMeasureScheme' not in already_processed:
            already_processed.add('assetMeasureScheme')
            outfile.write(' assetMeasureScheme=%s' % (quote_attrib(self.assetMeasureScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AssetMeasureType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('assetMeasureScheme', node)
        if value is not None and 'assetMeasureScheme' not in already_processed:
            already_processed.add('assetMeasureScheme')
            self.assetMeasureScheme = value
            self.validate_NonEmptyURI(self.assetMeasureScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AssetMeasureType


class AssetPool(GeneratedsSuper):
    """Characterise the asset pool behind an asset backed bond."""
    member_data_items_ = {
        'version': MemberSpec_('version', 'xsd:nonNegativeInteger', 0),
        'effectiveDate': MemberSpec_('effectiveDate', 'IdentifiedDate', 0),
        'initialFactor': MemberSpec_('initialFactor', 'xsd:decimal', 0),
        'currentFactor': MemberSpec_('currentFactor', 'xsd:decimal', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, version=None, effectiveDate=None, initialFactor=None, currentFactor=None):
        self.original_tagname_ = None
        self.version = version
        self.effectiveDate = effectiveDate
        self.initialFactor = initialFactor
        self.currentFactor = currentFactor
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AssetPool)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AssetPool.subclass:
            return AssetPool.subclass(*args_, **kwargs_)
        else:
            return AssetPool(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_effectiveDate(self): return self.effectiveDate
    def set_effectiveDate(self, effectiveDate): self.effectiveDate = effectiveDate
    def get_initialFactor(self): return self.initialFactor
    def set_initialFactor(self, initialFactor): self.initialFactor = initialFactor
    def get_currentFactor(self): return self.currentFactor
    def set_currentFactor(self, currentFactor): self.currentFactor = currentFactor
    def hasContent_(self):
        if (
            self.version is not None or
            self.effectiveDate is not None or
            self.initialFactor is not None or
            self.currentFactor is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AssetPool', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AssetPool')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AssetPool', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AssetPool'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AssetPool', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sversion>%s</%sversion>%s' % (namespace_, self.gds_format_integer(self.version, input_name='version'), namespace_, eol_))
        if self.effectiveDate is not None:
            self.effectiveDate.export(outfile, level, namespace_, name_='effectiveDate', pretty_print=pretty_print)
        if self.initialFactor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinitialFactor>%s</%sinitialFactor>%s' % (namespace_, self.gds_format_float(self.initialFactor, input_name='initialFactor'), namespace_, eol_))
        if self.currentFactor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scurrentFactor>%s</%scurrentFactor>%s' % (namespace_, self.gds_format_float(self.currentFactor, input_name='currentFactor'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'version':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'version')
            self.version = ival_
        elif nodeName_ == 'effectiveDate':
            obj_ = IdentifiedDate.factory()
            obj_.build(child_)
            self.effectiveDate = obj_
            obj_.original_tagname_ = 'effectiveDate'
        elif nodeName_ == 'initialFactor':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'initialFactor')
            self.initialFactor = fval_
        elif nodeName_ == 'currentFactor':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'currentFactor')
            self.currentFactor = fval_
# end class AssetPool


class BasicQuotation(GeneratedsSuper):
    """Some kind of numerical measure about an asset, eg. its NPV, together
    with characteristics of that measure."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'value': MemberSpec_('value', 'xsd:decimal', 0),
        'measureType': MemberSpec_('measureType', 'AssetMeasureType', 0),
        'quoteUnits': MemberSpec_('quoteUnits', 'PriceQuoteUnits', 0),
        'side': MemberSpec_('side', ['QuotationSideEnum', 'Token', 'xsd:token'], 0),
        'currency': MemberSpec_('currency', 'Currency', 0),
        'currencyType': MemberSpec_('currencyType', 'ReportingCurrencyType', 0),
        'timing': MemberSpec_('timing', 'QuoteTiming', 0),
        'businessCenter': MemberSpec_('businessCenter', 'BusinessCenter', 0),
        'exchangeId': MemberSpec_('exchangeId', 'ExchangeId', 0),
        'informationSource': MemberSpec_('informationSource', 'InformationSource', 1),
        'pricingModel': MemberSpec_('pricingModel', 'PricingModel', 0),
        'time': MemberSpec_('time', 'xsd:dateTime', 0),
        'valuationDate': MemberSpec_('valuationDate', 'xsd:date', 0),
        'expiryTime': MemberSpec_('expiryTime', 'xsd:dateTime', 0),
        'cashflowType': MemberSpec_('cashflowType', 'CashflowType', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, value=None, measureType=None, quoteUnits=None, side=None, currency=None, currencyType=None, timing=None, businessCenter=None, exchangeId=None, informationSource=None, pricingModel=None, time=None, valuationDate=None, expiryTime=None, cashflowType=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.value = value
        self.measureType = measureType
        self.quoteUnits = quoteUnits
        self.side = side
        self.validate_QuotationSideEnum(self.side)
        self.currency = currency
        self.currencyType = currencyType
        self.timing = timing
        self.businessCenter = businessCenter
        self.exchangeId = exchangeId
        if informationSource is None:
            self.informationSource = []
        else:
            self.informationSource = informationSource
        self.pricingModel = pricingModel
        if isinstance(time, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(time, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = time
        self.time = initvalue_
        if isinstance(valuationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(valuationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = valuationDate
        self.valuationDate = initvalue_
        if isinstance(expiryTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(expiryTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = expiryTime
        self.expiryTime = initvalue_
        self.cashflowType = cashflowType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BasicQuotation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BasicQuotation.subclass:
            return BasicQuotation.subclass(*args_, **kwargs_)
        else:
            return BasicQuotation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_measureType(self): return self.measureType
    def set_measureType(self, measureType): self.measureType = measureType
    def get_quoteUnits(self): return self.quoteUnits
    def set_quoteUnits(self, quoteUnits): self.quoteUnits = quoteUnits
    def get_side(self): return self.side
    def set_side(self, side): self.side = side
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_currencyType(self): return self.currencyType
    def set_currencyType(self, currencyType): self.currencyType = currencyType
    def get_timing(self): return self.timing
    def set_timing(self, timing): self.timing = timing
    def get_businessCenter(self): return self.businessCenter
    def set_businessCenter(self, businessCenter): self.businessCenter = businessCenter
    def get_exchangeId(self): return self.exchangeId
    def set_exchangeId(self, exchangeId): self.exchangeId = exchangeId
    def get_informationSource(self): return self.informationSource
    def set_informationSource(self, informationSource): self.informationSource = informationSource
    def add_informationSource(self, value): self.informationSource.append(value)
    def insert_informationSource_at(self, index, value): self.informationSource.insert(index, value)
    def replace_informationSource_at(self, index, value): self.informationSource[index] = value
    def get_pricingModel(self): return self.pricingModel
    def set_pricingModel(self, pricingModel): self.pricingModel = pricingModel
    def get_time(self): return self.time
    def set_time(self, time): self.time = time
    def get_valuationDate(self): return self.valuationDate
    def set_valuationDate(self, valuationDate): self.valuationDate = valuationDate
    def get_expiryTime(self): return self.expiryTime
    def set_expiryTime(self, expiryTime): self.expiryTime = expiryTime
    def get_cashflowType(self): return self.cashflowType
    def set_cashflowType(self, cashflowType): self.cashflowType = cashflowType
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_QuotationSideEnum(self, value):
        # Validate type QuotationSideEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Bid', 'Ask', 'Mid']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on QuotationSideEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on QuotationSideEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.value is not None or
            self.measureType is not None or
            self.quoteUnits is not None or
            self.side is not None or
            self.currency is not None or
            self.currencyType is not None or
            self.timing is not None or
            self.businessCenter is not None or
            self.exchangeId is not None or
            self.informationSource or
            self.pricingModel is not None or
            self.time is not None or
            self.valuationDate is not None or
            self.expiryTime is not None or
            self.cashflowType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BasicQuotation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BasicQuotation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BasicQuotation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BasicQuotation'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BasicQuotation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_float(self.value, input_name='value'), namespace_, eol_))
        if self.measureType is not None:
            self.measureType.export(outfile, level, namespace_, name_='measureType', pretty_print=pretty_print)
        if self.quoteUnits is not None:
            self.quoteUnits.export(outfile, level, namespace_, name_='quoteUnits', pretty_print=pretty_print)
        if self.side is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sside>%s</%sside>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.side), input_name='side')), namespace_, eol_))
        if self.currency is not None:
            self.currency.export(outfile, level, namespace_, name_='currency', pretty_print=pretty_print)
        if self.currencyType is not None:
            self.currencyType.export(outfile, level, namespace_, name_='currencyType', pretty_print=pretty_print)
        if self.timing is not None:
            self.timing.export(outfile, level, namespace_, name_='timing', pretty_print=pretty_print)
        if self.businessCenter is not None:
            self.businessCenter.export(outfile, level, namespace_, name_='businessCenter', pretty_print=pretty_print)
        if self.exchangeId is not None:
            self.exchangeId.export(outfile, level, namespace_, name_='exchangeId', pretty_print=pretty_print)
        for informationSource_ in self.informationSource:
            informationSource_.export(outfile, level, namespace_, name_='informationSource', pretty_print=pretty_print)
        if self.pricingModel is not None:
            self.pricingModel.export(outfile, level, namespace_, name_='pricingModel', pretty_print=pretty_print)
        if self.time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stime>%s</%stime>%s' % (namespace_, self.gds_format_datetime(self.time, input_name='time'), namespace_, eol_))
        if self.valuationDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svaluationDate>%s</%svaluationDate>%s' % (namespace_, self.gds_format_date(self.valuationDate, input_name='valuationDate'), namespace_, eol_))
        if self.expiryTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexpiryTime>%s</%sexpiryTime>%s' % (namespace_, self.gds_format_datetime(self.expiryTime, input_name='expiryTime'), namespace_, eol_))
        if self.cashflowType is not None:
            self.cashflowType.export(outfile, level, namespace_, name_='cashflowType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'value':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'value')
            self.value = fval_
        elif nodeName_ == 'measureType':
            obj_ = AssetMeasureType.factory()
            obj_.build(child_)
            self.measureType = obj_
            obj_.original_tagname_ = 'measureType'
        elif nodeName_ == 'quoteUnits':
            obj_ = PriceQuoteUnits.factory()
            obj_.build(child_)
            self.quoteUnits = obj_
            obj_.original_tagname_ = 'quoteUnits'
        elif nodeName_ == 'side':
            side_ = child_.text
            side_ = re_.sub(String_cleanup_pat_, " ", side_).strip()
            side_ = self.gds_validate_string(side_, node, 'side')
            self.side = side_
            # validate type QuotationSideEnum
            self.validate_QuotationSideEnum(self.side)
        elif nodeName_ == 'currency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'currencyType':
            obj_ = ReportingCurrencyType.factory()
            obj_.build(child_)
            self.currencyType = obj_
            obj_.original_tagname_ = 'currencyType'
        elif nodeName_ == 'timing':
            obj_ = QuoteTiming.factory()
            obj_.build(child_)
            self.timing = obj_
            obj_.original_tagname_ = 'timing'
        elif nodeName_ == 'businessCenter':
            obj_ = BusinessCenter.factory()
            obj_.build(child_)
            self.businessCenter = obj_
            obj_.original_tagname_ = 'businessCenter'
        elif nodeName_ == 'exchangeId':
            obj_ = ExchangeId.factory()
            obj_.build(child_)
            self.exchangeId = obj_
            obj_.original_tagname_ = 'exchangeId'
        elif nodeName_ == 'informationSource':
            class_obj_ = self.get_class_obj_(child_, InformationSource)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.informationSource.append(obj_)
            obj_.original_tagname_ = 'informationSource'
        elif nodeName_ == 'pricingModel':
            obj_ = PricingModel.factory()
            obj_.build(child_)
            self.pricingModel = obj_
            obj_.original_tagname_ = 'pricingModel'
        elif nodeName_ == 'time':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.time = dval_
        elif nodeName_ == 'valuationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.valuationDate = dval_
        elif nodeName_ == 'expiryTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.expiryTime = dval_
        elif nodeName_ == 'cashflowType':
            obj_ = CashflowType.factory()
            obj_.build(child_)
            self.cashflowType = obj_
            obj_.original_tagname_ = 'cashflowType'
# end class BasicQuotation


class Basket(Asset):
    """A type describing the underlyer features of a basket swap. Each of
    the basket constituents are described through an embedded
    component, the basketConstituentsType."""
    member_data_items_ = {
        'openUnits': MemberSpec_('openUnits', 'xsd:decimal', 0),
        'basketConstituent': MemberSpec_('basketConstituent', 'BasketConstituent', 1),
        'basketDivisor': MemberSpec_('basketDivisor', 'xsd:decimal', 0),
        'basketVersion': MemberSpec_('basketVersion', 'xsd:nonNegativeInteger', 0),
        'basketName': MemberSpec_('basketName', 'BasketName', 0),
        'basketId': MemberSpec_('basketId', 'BasketId', 1),
        'basketId': MemberSpec_('basketId', 'BasketId', 1),
        'basketCurrency': MemberSpec_('basketCurrency', 'Currency', 0),
    }
    subclass = None
    superclass = Asset
    def __init__(self, id=None, openUnits=None, basketConstituent=None, basketDivisor=None, basketVersion=None, basketName=None, basketId=None, basketCurrency=None):
        self.original_tagname_ = None
        super(Basket, self).__init__(id, )
        self.openUnits = openUnits
        if basketConstituent is None:
            self.basketConstituent = []
        else:
            self.basketConstituent = basketConstituent
        self.basketDivisor = basketDivisor
        self.basketVersion = basketVersion
        self.basketName = basketName
        if basketId is None:
            self.basketId = []
        else:
            self.basketId = basketId
        if basketId is None:
            self.basketId = []
        else:
            self.basketId = basketId
        self.basketCurrency = basketCurrency
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Basket)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Basket.subclass:
            return Basket.subclass(*args_, **kwargs_)
        else:
            return Basket(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_openUnits(self): return self.openUnits
    def set_openUnits(self, openUnits): self.openUnits = openUnits
    def get_basketConstituent(self): return self.basketConstituent
    def set_basketConstituent(self, basketConstituent): self.basketConstituent = basketConstituent
    def add_basketConstituent(self, value): self.basketConstituent.append(value)
    def insert_basketConstituent_at(self, index, value): self.basketConstituent.insert(index, value)
    def replace_basketConstituent_at(self, index, value): self.basketConstituent[index] = value
    def get_basketDivisor(self): return self.basketDivisor
    def set_basketDivisor(self, basketDivisor): self.basketDivisor = basketDivisor
    def get_basketVersion(self): return self.basketVersion
    def set_basketVersion(self, basketVersion): self.basketVersion = basketVersion
    def get_basketName(self): return self.basketName
    def set_basketName(self, basketName): self.basketName = basketName
    def get_basketId(self): return self.basketId
    def set_basketId(self, basketId): self.basketId = basketId
    def add_basketId(self, value): self.basketId.append(value)
    def insert_basketId_at(self, index, value): self.basketId.insert(index, value)
    def replace_basketId_at(self, index, value): self.basketId[index] = value
    def get_basketId(self): return self.basketId
    def set_basketId(self, basketId): self.basketId = basketId
    def add_basketId(self, value): self.basketId.append(value)
    def insert_basketId_at(self, index, value): self.basketId.insert(index, value)
    def replace_basketId_at(self, index, value): self.basketId[index] = value
    def get_basketCurrency(self): return self.basketCurrency
    def set_basketCurrency(self, basketCurrency): self.basketCurrency = basketCurrency
    def hasContent_(self):
        if (
            self.openUnits is not None or
            self.basketConstituent or
            self.basketDivisor is not None or
            self.basketVersion is not None or
            self.basketName is not None or
            self.basketId or
            self.basketId or
            self.basketCurrency is not None or
            super(Basket, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Basket', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Basket')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Basket', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Basket'):
        super(Basket, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Basket')
    def exportChildren(self, outfile, level, namespace_='', name_='Basket', fromsubclass_=False, pretty_print=True):
        super(Basket, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.openUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sopenUnits>%s</%sopenUnits>%s' % (namespace_, self.gds_format_float(self.openUnits, input_name='openUnits'), namespace_, eol_))
        for basketConstituent_ in self.basketConstituent:
            basketConstituent_.export(outfile, level, namespace_, name_='basketConstituent', pretty_print=pretty_print)
        if self.basketDivisor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbasketDivisor>%s</%sbasketDivisor>%s' % (namespace_, self.gds_format_float(self.basketDivisor, input_name='basketDivisor'), namespace_, eol_))
        if self.basketVersion is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbasketVersion>%s</%sbasketVersion>%s' % (namespace_, self.gds_format_integer(self.basketVersion, input_name='basketVersion'), namespace_, eol_))
        if self.basketName is not None:
            self.basketName.export(outfile, level, namespace_, name_='basketName', pretty_print=pretty_print)
        for basketId_ in self.basketId:
            basketId_.export(outfile, level, namespace_, name_='basketId', pretty_print=pretty_print)
        for basketId_ in self.basketId:
            basketId_.export(outfile, level, namespace_, name_='basketId', pretty_print=pretty_print)
        if self.basketCurrency is not None:
            self.basketCurrency.export(outfile, level, namespace_, name_='basketCurrency', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Basket, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'openUnits':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'openUnits')
            self.openUnits = fval_
        elif nodeName_ == 'basketConstituent':
            obj_ = BasketConstituent.factory()
            obj_.build(child_)
            self.basketConstituent.append(obj_)
            obj_.original_tagname_ = 'basketConstituent'
        elif nodeName_ == 'basketDivisor':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'basketDivisor')
            self.basketDivisor = fval_
        elif nodeName_ == 'basketVersion':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'basketVersion')
            self.basketVersion = ival_
        elif nodeName_ == 'basketName':
            obj_ = BasketName.factory()
            obj_.build(child_)
            self.basketName = obj_
            obj_.original_tagname_ = 'basketName'
        elif nodeName_ == 'basketId':
            obj_ = BasketId.factory()
            obj_.build(child_)
            self.basketId.append(obj_)
            obj_.original_tagname_ = 'basketId'
        elif nodeName_ == 'basketId':
            obj_ = BasketId.factory()
            obj_.build(child_)
            self.basketId.append(obj_)
            obj_.original_tagname_ = 'basketId'
        elif nodeName_ == 'basketCurrency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.basketCurrency = obj_
            obj_.original_tagname_ = 'basketCurrency'
        super(Basket, self).buildChildren(child_, node, nodeName_, True)
# end class Basket


class BasketConstituent(GeneratedsSuper):
    """A type describing each of the constituents of a basket."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'payerPartyReference': MemberSpec_('payerPartyReference', 'PartyReference', 0),
        'payerAccountReference': MemberSpec_('payerAccountReference', 'AccountReference', 0),
        'receiverPartyReference': MemberSpec_('receiverPartyReference', 'PartyReference', 0),
        'receiverAccountReference': MemberSpec_('receiverAccountReference', 'AccountReference', 0),
        'underlyingAsset': MemberSpec_('underlyingAsset', 'Asset', 0),
        'constituentWeight': MemberSpec_('constituentWeight', 'ConstituentWeight', 0),
        'dividendPayout': MemberSpec_('dividendPayout', 'DividendPayout', 0),
        'underlyerPrice': MemberSpec_('underlyerPrice', 'Price', 0),
        'underlyerNotional': MemberSpec_('underlyerNotional', 'Money', 0),
        'underlyerSpread': MemberSpec_('underlyerSpread', 'SpreadScheduleReference', 0),
        'couponPayment': MemberSpec_('couponPayment', 'PendingPayment', 0),
        'underlyerFinancing': MemberSpec_('underlyerFinancing', 'UnderlyerInterestLeg', 0),
        'underlyerLoanRate': MemberSpec_('underlyerLoanRate', 'UnderlyerLoanRate', 0),
        'underlyerCollateral': MemberSpec_('underlyerCollateral', 'Collateral', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, underlyingAsset=None, constituentWeight=None, dividendPayout=None, underlyerPrice=None, underlyerNotional=None, underlyerSpread=None, couponPayment=None, underlyerFinancing=None, underlyerLoanRate=None, underlyerCollateral=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.payerPartyReference = payerPartyReference
        self.payerAccountReference = payerAccountReference
        self.receiverPartyReference = receiverPartyReference
        self.receiverAccountReference = receiverAccountReference
        self.underlyingAsset = underlyingAsset
        self.constituentWeight = constituentWeight
        self.dividendPayout = dividendPayout
        self.underlyerPrice = underlyerPrice
        self.underlyerNotional = underlyerNotional
        self.underlyerSpread = underlyerSpread
        self.couponPayment = couponPayment
        self.underlyerFinancing = underlyerFinancing
        self.underlyerLoanRate = underlyerLoanRate
        self.underlyerCollateral = underlyerCollateral
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BasketConstituent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BasketConstituent.subclass:
            return BasketConstituent.subclass(*args_, **kwargs_)
        else:
            return BasketConstituent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_payerPartyReference(self): return self.payerPartyReference
    def set_payerPartyReference(self, payerPartyReference): self.payerPartyReference = payerPartyReference
    def get_payerAccountReference(self): return self.payerAccountReference
    def set_payerAccountReference(self, payerAccountReference): self.payerAccountReference = payerAccountReference
    def get_receiverPartyReference(self): return self.receiverPartyReference
    def set_receiverPartyReference(self, receiverPartyReference): self.receiverPartyReference = receiverPartyReference
    def get_receiverAccountReference(self): return self.receiverAccountReference
    def set_receiverAccountReference(self, receiverAccountReference): self.receiverAccountReference = receiverAccountReference
    def get_underlyingAsset(self): return self.underlyingAsset
    def set_underlyingAsset(self, underlyingAsset): self.underlyingAsset = underlyingAsset
    def get_constituentWeight(self): return self.constituentWeight
    def set_constituentWeight(self, constituentWeight): self.constituentWeight = constituentWeight
    def get_dividendPayout(self): return self.dividendPayout
    def set_dividendPayout(self, dividendPayout): self.dividendPayout = dividendPayout
    def get_underlyerPrice(self): return self.underlyerPrice
    def set_underlyerPrice(self, underlyerPrice): self.underlyerPrice = underlyerPrice
    def get_underlyerNotional(self): return self.underlyerNotional
    def set_underlyerNotional(self, underlyerNotional): self.underlyerNotional = underlyerNotional
    def get_underlyerSpread(self): return self.underlyerSpread
    def set_underlyerSpread(self, underlyerSpread): self.underlyerSpread = underlyerSpread
    def get_couponPayment(self): return self.couponPayment
    def set_couponPayment(self, couponPayment): self.couponPayment = couponPayment
    def get_underlyerFinancing(self): return self.underlyerFinancing
    def set_underlyerFinancing(self, underlyerFinancing): self.underlyerFinancing = underlyerFinancing
    def get_underlyerLoanRate(self): return self.underlyerLoanRate
    def set_underlyerLoanRate(self, underlyerLoanRate): self.underlyerLoanRate = underlyerLoanRate
    def get_underlyerCollateral(self): return self.underlyerCollateral
    def set_underlyerCollateral(self, underlyerCollateral): self.underlyerCollateral = underlyerCollateral
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.payerPartyReference is not None or
            self.payerAccountReference is not None or
            self.receiverPartyReference is not None or
            self.receiverAccountReference is not None or
            self.underlyingAsset is not None or
            self.constituentWeight is not None or
            self.dividendPayout is not None or
            self.underlyerPrice is not None or
            self.underlyerNotional is not None or
            self.underlyerSpread is not None or
            self.couponPayment is not None or
            self.underlyerFinancing is not None or
            self.underlyerLoanRate is not None or
            self.underlyerCollateral is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BasketConstituent', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BasketConstituent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BasketConstituent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BasketConstituent'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BasketConstituent', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.payerPartyReference is not None:
            self.payerPartyReference.export(outfile, level, namespace_, name_='payerPartyReference', pretty_print=pretty_print)
        if self.payerAccountReference is not None:
            self.payerAccountReference.export(outfile, level, namespace_, name_='payerAccountReference', pretty_print=pretty_print)
        if self.receiverPartyReference is not None:
            self.receiverPartyReference.export(outfile, level, namespace_, name_='receiverPartyReference', pretty_print=pretty_print)
        if self.receiverAccountReference is not None:
            self.receiverAccountReference.export(outfile, level, namespace_, name_='receiverAccountReference', pretty_print=pretty_print)
        if self.underlyingAsset is not None:
            self.underlyingAsset.export(outfile, level, namespace_, name_='underlyingAsset', pretty_print=pretty_print)
        if self.constituentWeight is not None:
            self.constituentWeight.export(outfile, level, namespace_, name_='constituentWeight', pretty_print=pretty_print)
        if self.dividendPayout is not None:
            self.dividendPayout.export(outfile, level, namespace_, name_='dividendPayout', pretty_print=pretty_print)
        if self.underlyerPrice is not None:
            self.underlyerPrice.export(outfile, level, namespace_, name_='underlyerPrice', pretty_print=pretty_print)
        if self.underlyerNotional is not None:
            self.underlyerNotional.export(outfile, level, namespace_, name_='underlyerNotional', pretty_print=pretty_print)
        if self.underlyerSpread is not None:
            self.underlyerSpread.export(outfile, level, namespace_, name_='underlyerSpread', pretty_print=pretty_print)
        if self.couponPayment is not None:
            self.couponPayment.export(outfile, level, namespace_, name_='couponPayment', pretty_print=pretty_print)
        if self.underlyerFinancing is not None:
            self.underlyerFinancing.export(outfile, level, namespace_, name_='underlyerFinancing', pretty_print=pretty_print)
        if self.underlyerLoanRate is not None:
            self.underlyerLoanRate.export(outfile, level, namespace_, name_='underlyerLoanRate', pretty_print=pretty_print)
        if self.underlyerCollateral is not None:
            self.underlyerCollateral.export(outfile, level, namespace_, name_='underlyerCollateral', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'payerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.payerPartyReference = obj_
            obj_.original_tagname_ = 'payerPartyReference'
        elif nodeName_ == 'payerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.payerAccountReference = obj_
            obj_.original_tagname_ = 'payerAccountReference'
        elif nodeName_ == 'receiverPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.receiverPartyReference = obj_
            obj_.original_tagname_ = 'receiverPartyReference'
        elif nodeName_ == 'receiverAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.receiverAccountReference = obj_
            obj_.original_tagname_ = 'receiverAccountReference'
        elif nodeName_ == 'underlyingAsset':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <underlyingAsset> element')
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'underlyingAsset'
        elif nodeName_ == 'basket':
            obj_ = Basket.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'basket'
        elif nodeName_ == 'bond':
            class_obj_ = self.get_class_obj_(child_, Bond)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'bond'
        elif nodeName_ == 'cash':
            obj_ = Cash.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'cash'
        elif nodeName_ == 'commodity':
            obj_ = Commodity.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'commodity'
        elif nodeName_ == 'convertibleBond':
            obj_ = ConvertibleBond.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'convertibleBond'
        elif nodeName_ == 'equity':
            obj_ = EquityAsset.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'equity'
        elif nodeName_ == 'exchangeTradedFund':
            obj_ = ExchangeTradedFund.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'exchangeTradedFund'
        elif nodeName_ == 'future':
            obj_ = Future.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'future'
        elif nodeName_ == 'index':
            obj_ = Index.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'index'
        elif nodeName_ == 'loan':
            obj_ = Loan.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'loan'
        elif nodeName_ == 'mortgage':
            obj_ = Mortgage.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'mortgage'
        elif nodeName_ == 'mutualFund':
            obj_ = MutualFund.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'mutualFund'
        elif nodeName_ == 'option':
            obj_ = ExchangeTradedOption.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'option'
        elif nodeName_ == 'constituentWeight':
            obj_ = ConstituentWeight.factory()
            obj_.build(child_)
            self.constituentWeight = obj_
            obj_.original_tagname_ = 'constituentWeight'
        elif nodeName_ == 'dividendPayout':
            obj_ = DividendPayout.factory()
            obj_.build(child_)
            self.dividendPayout = obj_
            obj_.original_tagname_ = 'dividendPayout'
        elif nodeName_ == 'underlyerPrice':
            obj_ = Price.factory()
            obj_.build(child_)
            self.underlyerPrice = obj_
            obj_.original_tagname_ = 'underlyerPrice'
        elif nodeName_ == 'underlyerNotional':
            obj_ = Money.factory()
            obj_.build(child_)
            self.underlyerNotional = obj_
            obj_.original_tagname_ = 'underlyerNotional'
        elif nodeName_ == 'underlyerSpread':
            obj_ = SpreadScheduleReference.factory()
            obj_.build(child_)
            self.underlyerSpread = obj_
            obj_.original_tagname_ = 'underlyerSpread'
        elif nodeName_ == 'couponPayment':
            obj_ = PendingPayment.factory()
            obj_.build(child_)
            self.couponPayment = obj_
            obj_.original_tagname_ = 'couponPayment'
        elif nodeName_ == 'underlyerFinancing':
            obj_ = UnderlyerInterestLeg.factory()
            obj_.build(child_)
            self.underlyerFinancing = obj_
            obj_.original_tagname_ = 'underlyerFinancing'
        elif nodeName_ == 'underlyerLoanRate':
            obj_ = UnderlyerLoanRate.factory()
            obj_.build(child_)
            self.underlyerLoanRate = obj_
            obj_.original_tagname_ = 'underlyerLoanRate'
        elif nodeName_ == 'underlyerCollateral':
            obj_ = Collateral.factory()
            obj_.build(child_)
            self.underlyerCollateral = obj_
            obj_.original_tagname_ = 'underlyerCollateral'
# end class BasketConstituent


class BasketId(GeneratedsSuper):
    member_data_items_ = {
        'basketIdScheme': MemberSpec_('basketIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, basketIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.basketIdScheme = _cast(None, basketIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BasketId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BasketId.subclass:
            return BasketId.subclass(*args_, **kwargs_)
        else:
            return BasketId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_basketIdScheme(self): return self.basketIdScheme
    def set_basketIdScheme(self, basketIdScheme): self.basketIdScheme = basketIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BasketId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BasketId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BasketId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BasketId'):
        if self.basketIdScheme is not None and 'basketIdScheme' not in already_processed:
            already_processed.add('basketIdScheme')
            outfile.write(' basketIdScheme=%s' % (quote_attrib(self.basketIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BasketId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('basketIdScheme', node)
        if value is not None and 'basketIdScheme' not in already_processed:
            already_processed.add('basketIdScheme')
            self.basketIdScheme = value
            self.validate_NonEmptyURI(self.basketIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BasketId


class BasketName(GeneratedsSuper):
    member_data_items_ = {
        'basketNameScheme': MemberSpec_('basketNameScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, basketNameScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.basketNameScheme = _cast(None, basketNameScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BasketName)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BasketName.subclass:
            return BasketName.subclass(*args_, **kwargs_)
        else:
            return BasketName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_basketNameScheme(self): return self.basketNameScheme
    def set_basketNameScheme(self, basketNameScheme): self.basketNameScheme = basketNameScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BasketName', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BasketName')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BasketName', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BasketName'):
        if self.basketNameScheme is not None and 'basketNameScheme' not in already_processed:
            already_processed.add('basketNameScheme')
            outfile.write(' basketNameScheme=%s' % (quote_attrib(self.basketNameScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BasketName', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('basketNameScheme', node)
        if value is not None and 'basketNameScheme' not in already_processed:
            already_processed.add('basketNameScheme')
            self.basketNameScheme = value
            self.validate_NonEmptyURI(self.basketNameScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BasketName


class Cash(Asset):
    member_data_items_ = {
        'instrumentId': MemberSpec_('instrumentId', 'InstrumentId', 1),
        'description': MemberSpec_('description', ['String', 'xsd:string'], 0),
        'currency': MemberSpec_('currency', 'Currency', 0),
    }
    subclass = None
    superclass = Asset
    def __init__(self, id=None, instrumentId=None, description=None, currency=None):
        self.original_tagname_ = None
        super(Cash, self).__init__(id, )
        if instrumentId is None:
            self.instrumentId = []
        else:
            self.instrumentId = instrumentId
        self.description = description
        self.validate_String(self.description)
        self.currency = currency
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Cash)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Cash.subclass:
            return Cash.subclass(*args_, **kwargs_)
        else:
            return Cash(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_instrumentId(self): return self.instrumentId
    def set_instrumentId(self, instrumentId): self.instrumentId = instrumentId
    def add_instrumentId(self, value): self.instrumentId.append(value)
    def insert_instrumentId_at(self, index, value): self.instrumentId.insert(index, value)
    def replace_instrumentId_at(self, index, value): self.instrumentId[index] = value
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.instrumentId or
            self.description is not None or
            self.currency is not None or
            super(Cash, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Cash', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Cash')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Cash', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Cash'):
        super(Cash, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Cash')
    def exportChildren(self, outfile, level, namespace_='', name_='Cash', fromsubclass_=False, pretty_print=True):
        super(Cash, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for instrumentId_ in self.instrumentId:
            instrumentId_.export(outfile, level, namespace_, name_='instrumentId', pretty_print=pretty_print)
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespace_, eol_))
        if self.currency is not None:
            self.currency.export(outfile, level, namespace_, name_='currency', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Cash, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'instrumentId':
            obj_ = InstrumentId.factory()
            obj_.build(child_)
            self.instrumentId.append(obj_)
            obj_.original_tagname_ = 'instrumentId'
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
            # validate type String
            self.validate_String(self.description)
        elif nodeName_ == 'currency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        super(Cash, self).buildChildren(child_, node, nodeName_, True)
# end class Cash


class Commission(GeneratedsSuper):
    """A type describing the commission that will be charged for each of
    the hedge transactions."""
    member_data_items_ = {
        'commissionDenomination': MemberSpec_('commissionDenomination', ['CommissionDenominationEnum', 'Token', 'xsd:token'], 0),
        'commissionAmount': MemberSpec_('commissionAmount', 'xsd:decimal', 0),
        'currency': MemberSpec_('currency', 'Currency', 0),
        'commissionPerTrade': MemberSpec_('commissionPerTrade', 'xsd:decimal', 0),
        'fxRate': MemberSpec_('fxRate', 'FxRate', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, commissionDenomination=None, commissionAmount=None, currency=None, commissionPerTrade=None, fxRate=None):
        self.original_tagname_ = None
        self.commissionDenomination = commissionDenomination
        self.validate_CommissionDenominationEnum(self.commissionDenomination)
        self.commissionAmount = commissionAmount
        self.currency = currency
        self.commissionPerTrade = commissionPerTrade
        if fxRate is None:
            self.fxRate = []
        else:
            self.fxRate = fxRate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Commission)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Commission.subclass:
            return Commission.subclass(*args_, **kwargs_)
        else:
            return Commission(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commissionDenomination(self): return self.commissionDenomination
    def set_commissionDenomination(self, commissionDenomination): self.commissionDenomination = commissionDenomination
    def get_commissionAmount(self): return self.commissionAmount
    def set_commissionAmount(self, commissionAmount): self.commissionAmount = commissionAmount
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_commissionPerTrade(self): return self.commissionPerTrade
    def set_commissionPerTrade(self, commissionPerTrade): self.commissionPerTrade = commissionPerTrade
    def get_fxRate(self): return self.fxRate
    def set_fxRate(self, fxRate): self.fxRate = fxRate
    def add_fxRate(self, value): self.fxRate.append(value)
    def insert_fxRate_at(self, index, value): self.fxRate.insert(index, value)
    def replace_fxRate_at(self, index, value): self.fxRate[index] = value
    def validate_CommissionDenominationEnum(self, value):
        # Validate type CommissionDenominationEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['BPS', 'Percentage', 'CentsPerShare', 'FixedAmount']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CommissionDenominationEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on CommissionDenominationEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.commissionDenomination is not None or
            self.commissionAmount is not None or
            self.currency is not None or
            self.commissionPerTrade is not None or
            self.fxRate
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Commission', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Commission')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Commission', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Commission'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Commission', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.commissionDenomination is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scommissionDenomination>%s</%scommissionDenomination>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.commissionDenomination), input_name='commissionDenomination')), namespace_, eol_))
        if self.commissionAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scommissionAmount>%s</%scommissionAmount>%s' % (namespace_, self.gds_format_float(self.commissionAmount, input_name='commissionAmount'), namespace_, eol_))
        if self.currency is not None:
            self.currency.export(outfile, level, namespace_, name_='currency', pretty_print=pretty_print)
        if self.commissionPerTrade is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scommissionPerTrade>%s</%scommissionPerTrade>%s' % (namespace_, self.gds_format_float(self.commissionPerTrade, input_name='commissionPerTrade'), namespace_, eol_))
        for fxRate_ in self.fxRate:
            fxRate_.export(outfile, level, namespace_, name_='fxRate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'commissionDenomination':
            commissionDenomination_ = child_.text
            commissionDenomination_ = re_.sub(String_cleanup_pat_, " ", commissionDenomination_).strip()
            commissionDenomination_ = self.gds_validate_string(commissionDenomination_, node, 'commissionDenomination')
            self.commissionDenomination = commissionDenomination_
            # validate type CommissionDenominationEnum
            self.validate_CommissionDenominationEnum(self.commissionDenomination)
        elif nodeName_ == 'commissionAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'commissionAmount')
            self.commissionAmount = fval_
        elif nodeName_ == 'currency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'commissionPerTrade':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'commissionPerTrade')
            self.commissionPerTrade = fval_
        elif nodeName_ == 'fxRate':
            obj_ = FxRate.factory()
            obj_.build(child_)
            self.fxRate.append(obj_)
            obj_.original_tagname_ = 'fxRate'
# end class Commission


class CommodityBase(GeneratedsSuper):
    member_data_items_ = {
        'commodityBaseScheme': MemberSpec_('commodityBaseScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, commodityBaseScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.commodityBaseScheme = _cast(None, commodityBaseScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityBase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityBase.subclass:
            return CommodityBase.subclass(*args_, **kwargs_)
        else:
            return CommodityBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commodityBaseScheme(self): return self.commodityBaseScheme
    def set_commodityBaseScheme(self, commodityBaseScheme): self.commodityBaseScheme = commodityBaseScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityBase', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityBase')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityBase', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityBase'):
        if self.commodityBaseScheme is not None and 'commodityBaseScheme' not in already_processed:
            already_processed.add('commodityBaseScheme')
            outfile.write(' commodityBaseScheme=%s' % (quote_attrib(self.commodityBaseScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityBase', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('commodityBaseScheme', node)
        if value is not None and 'commodityBaseScheme' not in already_processed:
            already_processed.add('commodityBaseScheme')
            self.commodityBaseScheme = value
            self.validate_NonEmptyURI(self.commodityBaseScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CommodityBase


class CommodityBusinessCalendar(GeneratedsSuper):
    """Defines a commodity business day calendar."""
    member_data_items_ = {
        'commodityBusinessCalendarScheme': MemberSpec_('commodityBusinessCalendarScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, commodityBusinessCalendarScheme='http://www.fpml.org/coding-scheme/commodity-business-calendar', valueOf_=None):
        self.original_tagname_ = None
        self.commodityBusinessCalendarScheme = _cast(None, commodityBusinessCalendarScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityBusinessCalendar)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityBusinessCalendar.subclass:
            return CommodityBusinessCalendar.subclass(*args_, **kwargs_)
        else:
            return CommodityBusinessCalendar(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commodityBusinessCalendarScheme(self): return self.commodityBusinessCalendarScheme
    def set_commodityBusinessCalendarScheme(self, commodityBusinessCalendarScheme): self.commodityBusinessCalendarScheme = commodityBusinessCalendarScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityBusinessCalendar', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityBusinessCalendar')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityBusinessCalendar', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityBusinessCalendar'):
        if self.commodityBusinessCalendarScheme != "http://www.fpml.org/coding-scheme/commodity-business-calendar" and 'commodityBusinessCalendarScheme' not in already_processed:
            already_processed.add('commodityBusinessCalendarScheme')
            outfile.write(' commodityBusinessCalendarScheme=%s' % (quote_attrib(self.commodityBusinessCalendarScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityBusinessCalendar', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('commodityBusinessCalendarScheme', node)
        if value is not None and 'commodityBusinessCalendarScheme' not in already_processed:
            already_processed.add('commodityBusinessCalendarScheme')
            self.commodityBusinessCalendarScheme = value
            self.validate_NonEmptyURI(self.commodityBusinessCalendarScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CommodityBusinessCalendar


class CommodityDetails(GeneratedsSuper):
    member_data_items_ = {
        'commodityDetailsScheme': MemberSpec_('commodityDetailsScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, commodityDetailsScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.commodityDetailsScheme = _cast(None, commodityDetailsScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityDetails)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityDetails.subclass:
            return CommodityDetails.subclass(*args_, **kwargs_)
        else:
            return CommodityDetails(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commodityDetailsScheme(self): return self.commodityDetailsScheme
    def set_commodityDetailsScheme(self, commodityDetailsScheme): self.commodityDetailsScheme = commodityDetailsScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityDetails', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityDetails')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityDetails', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityDetails'):
        if self.commodityDetailsScheme is not None and 'commodityDetailsScheme' not in already_processed:
            already_processed.add('commodityDetailsScheme')
            outfile.write(' commodityDetailsScheme=%s' % (quote_attrib(self.commodityDetailsScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityDetails', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('commodityDetailsScheme', node)
        if value is not None and 'commodityDetailsScheme' not in already_processed:
            already_processed.add('commodityDetailsScheme')
            self.commodityDetailsScheme = value
            self.validate_NonEmptyURI(self.commodityDetailsScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CommodityDetails


class CommodityInformationProvider(GeneratedsSuper):
    """The publication in which the rate, price, index or factor is to be
    found. (e.g Gas Daily, Platts Bloomberg.)"""
    member_data_items_ = {
        'informationProviderScheme': MemberSpec_('informationProviderScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, informationProviderScheme='http://www.fpml.org/coding-scheme/commodity-information-provider', valueOf_=None):
        self.original_tagname_ = None
        self.informationProviderScheme = _cast(None, informationProviderScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityInformationProvider)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityInformationProvider.subclass:
            return CommodityInformationProvider.subclass(*args_, **kwargs_)
        else:
            return CommodityInformationProvider(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_informationProviderScheme(self): return self.informationProviderScheme
    def set_informationProviderScheme(self, informationProviderScheme): self.informationProviderScheme = informationProviderScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityInformationProvider', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityInformationProvider')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityInformationProvider', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityInformationProvider'):
        if self.informationProviderScheme != "http://www.fpml.org/coding-scheme/commodity-information-provider" and 'informationProviderScheme' not in already_processed:
            already_processed.add('informationProviderScheme')
            outfile.write(' informationProviderScheme=%s' % (quote_attrib(self.informationProviderScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityInformationProvider', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('informationProviderScheme', node)
        if value is not None and 'informationProviderScheme' not in already_processed:
            already_processed.add('informationProviderScheme')
            self.informationProviderScheme = value
            self.validate_NonEmptyURI(self.informationProviderScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CommodityInformationProvider


class CommodityInformationSource(GeneratedsSuper):
    """A type defining the source of a commodity rate, price or index or of
    a market rate or of a conversion factor (e.g. a fx conversion
    factor)."""
    member_data_items_ = {
        'rateSource': MemberSpec_('rateSource', 'CommodityInformationProvider', 0),
        'rateSourcePage': MemberSpec_('rateSourcePage', 'RateSourcePage', 0),
        'rateSourcePageHeading': MemberSpec_('rateSourcePageHeading', ['String', 'xsd:string'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, rateSource=None, rateSourcePage=None, rateSourcePageHeading=None):
        self.original_tagname_ = None
        self.rateSource = rateSource
        self.rateSourcePage = rateSourcePage
        self.rateSourcePageHeading = rateSourcePageHeading
        self.validate_String(self.rateSourcePageHeading)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityInformationSource)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityInformationSource.subclass:
            return CommodityInformationSource.subclass(*args_, **kwargs_)
        else:
            return CommodityInformationSource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rateSource(self): return self.rateSource
    def set_rateSource(self, rateSource): self.rateSource = rateSource
    def get_rateSourcePage(self): return self.rateSourcePage
    def set_rateSourcePage(self, rateSourcePage): self.rateSourcePage = rateSourcePage
    def get_rateSourcePageHeading(self): return self.rateSourcePageHeading
    def set_rateSourcePageHeading(self, rateSourcePageHeading): self.rateSourcePageHeading = rateSourcePageHeading
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.rateSource is not None or
            self.rateSourcePage is not None or
            self.rateSourcePageHeading is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityInformationSource', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityInformationSource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityInformationSource', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityInformationSource'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityInformationSource', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.rateSource is not None:
            self.rateSource.export(outfile, level, namespace_, name_='rateSource', pretty_print=pretty_print)
        if self.rateSourcePage is not None:
            self.rateSourcePage.export(outfile, level, namespace_, name_='rateSourcePage', pretty_print=pretty_print)
        if self.rateSourcePageHeading is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srateSourcePageHeading>%s</%srateSourcePageHeading>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.rateSourcePageHeading), input_name='rateSourcePageHeading')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'rateSource':
            obj_ = CommodityInformationProvider.factory()
            obj_.build(child_)
            self.rateSource = obj_
            obj_.original_tagname_ = 'rateSource'
        elif nodeName_ == 'rateSourcePage':
            obj_ = RateSourcePage.factory()
            obj_.build(child_)
            self.rateSourcePage = obj_
            obj_.original_tagname_ = 'rateSourcePage'
        elif nodeName_ == 'rateSourcePageHeading':
            rateSourcePageHeading_ = child_.text
            rateSourcePageHeading_ = self.gds_validate_string(rateSourcePageHeading_, node, 'rateSourcePageHeading')
            self.rateSourcePageHeading = rateSourcePageHeading_
            # validate type String
            self.validate_String(self.rateSourcePageHeading)
# end class CommodityInformationSource


class ConstituentWeight(GeneratedsSuper):
    """A type describing the weight of each of the underlyer constituent
    within the basket, either in absolute or relative terms."""
    member_data_items_ = {
        'openUnits': MemberSpec_('openUnits', 'xsd:decimal', 0),
        'basketPercentage': MemberSpec_('basketPercentage', ['RestrictedPercentage', 'xsd:decimal'], 0),
        'basketAmount': MemberSpec_('basketAmount', 'Money', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, openUnits=None, basketPercentage=None, basketAmount=None):
        self.original_tagname_ = None
        self.openUnits = openUnits
        self.basketPercentage = basketPercentage
        self.validate_RestrictedPercentage(self.basketPercentage)
        self.basketAmount = basketAmount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConstituentWeight)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConstituentWeight.subclass:
            return ConstituentWeight.subclass(*args_, **kwargs_)
        else:
            return ConstituentWeight(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_openUnits(self): return self.openUnits
    def set_openUnits(self, openUnits): self.openUnits = openUnits
    def get_basketPercentage(self): return self.basketPercentage
    def set_basketPercentage(self, basketPercentage): self.basketPercentage = basketPercentage
    def get_basketAmount(self): return self.basketAmount
    def set_basketAmount(self, basketAmount): self.basketAmount = basketAmount
    def validate_RestrictedPercentage(self, value):
        # Validate type RestrictedPercentage, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on RestrictedPercentage' % {"value" : value} )
            if value > 1:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on RestrictedPercentage' % {"value" : value} )
    def hasContent_(self):
        if (
            self.openUnits is not None or
            self.basketPercentage is not None or
            self.basketAmount is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ConstituentWeight', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConstituentWeight')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ConstituentWeight', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConstituentWeight'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ConstituentWeight', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.openUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sopenUnits>%s</%sopenUnits>%s' % (namespace_, self.gds_format_float(self.openUnits, input_name='openUnits'), namespace_, eol_))
        if self.basketPercentage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbasketPercentage>%s</%sbasketPercentage>%s' % (namespace_, self.gds_format_float(self.basketPercentage, input_name='basketPercentage'), namespace_, eol_))
        if self.basketAmount is not None:
            self.basketAmount.export(outfile, level, namespace_, name_='basketAmount', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'openUnits':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'openUnits')
            self.openUnits = fval_
        elif nodeName_ == 'basketPercentage':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'basketPercentage')
            self.basketPercentage = fval_
            # validate type RestrictedPercentage
            self.validate_RestrictedPercentage(self.basketPercentage)
        elif nodeName_ == 'basketAmount':
            obj_ = Money.factory()
            obj_.build(child_)
            self.basketAmount = obj_
            obj_.original_tagname_ = 'basketAmount'
# end class ConstituentWeight


class CouponType(GeneratedsSuper):
    """Defines a scheme of values for specifiying if the bond has a
    variable coupon, step-up/down coupon or a zero-coupon."""
    member_data_items_ = {
        'couponTypeScheme': MemberSpec_('couponTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, couponTypeScheme='http://www.fpml.org/coding-scheme/coupon-type', valueOf_=None):
        self.original_tagname_ = None
        self.couponTypeScheme = _cast(None, couponTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CouponType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CouponType.subclass:
            return CouponType.subclass(*args_, **kwargs_)
        else:
            return CouponType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_couponTypeScheme(self): return self.couponTypeScheme
    def set_couponTypeScheme(self, couponTypeScheme): self.couponTypeScheme = couponTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CouponType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CouponType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CouponType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CouponType'):
        if self.couponTypeScheme != "http://www.fpml.org/coding-scheme/coupon-type" and 'couponTypeScheme' not in already_processed:
            already_processed.add('couponTypeScheme')
            outfile.write(' couponTypeScheme=%s' % (quote_attrib(self.couponTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CouponType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('couponTypeScheme', node)
        if value is not None and 'couponTypeScheme' not in already_processed:
            already_processed.add('couponTypeScheme')
            self.couponTypeScheme = value
            self.validate_NonEmptyURI(self.couponTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CouponType


class DeliveryNearby(GeneratedsSuper):
    """A type defines nearest Delivery Date of the underlying Commodity of
    expiration of the futures contract."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'deliveryNearbyMultiplier': MemberSpec_('deliveryNearbyMultiplier', 'xsd:positiveInteger', 0),
        'deliveryNearbyType': MemberSpec_('deliveryNearbyType', ['DeliveryNearbyTypeEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, deliveryNearbyMultiplier=None, deliveryNearbyType=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.deliveryNearbyMultiplier = deliveryNearbyMultiplier
        self.deliveryNearbyType = deliveryNearbyType
        self.validate_DeliveryNearbyTypeEnum(self.deliveryNearbyType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DeliveryNearby)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DeliveryNearby.subclass:
            return DeliveryNearby.subclass(*args_, **kwargs_)
        else:
            return DeliveryNearby(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_deliveryNearbyMultiplier(self): return self.deliveryNearbyMultiplier
    def set_deliveryNearbyMultiplier(self, deliveryNearbyMultiplier): self.deliveryNearbyMultiplier = deliveryNearbyMultiplier
    def get_deliveryNearbyType(self): return self.deliveryNearbyType
    def set_deliveryNearbyType(self, deliveryNearbyType): self.deliveryNearbyType = deliveryNearbyType
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_DeliveryNearbyTypeEnum(self, value):
        # Validate type DeliveryNearbyTypeEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CalculationPeriod', 'NearbyMonth', 'NearbyWeek']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeliveryNearbyTypeEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on DeliveryNearbyTypeEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.deliveryNearbyMultiplier is not None or
            self.deliveryNearbyType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DeliveryNearby', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeliveryNearby')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DeliveryNearby', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DeliveryNearby'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DeliveryNearby', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.deliveryNearbyMultiplier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdeliveryNearbyMultiplier>%s</%sdeliveryNearbyMultiplier>%s' % (namespace_, self.gds_format_integer(self.deliveryNearbyMultiplier, input_name='deliveryNearbyMultiplier'), namespace_, eol_))
        if self.deliveryNearbyType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdeliveryNearbyType>%s</%sdeliveryNearbyType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.deliveryNearbyType), input_name='deliveryNearbyType')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'deliveryNearbyMultiplier':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'deliveryNearbyMultiplier')
            self.deliveryNearbyMultiplier = ival_
        elif nodeName_ == 'deliveryNearbyType':
            deliveryNearbyType_ = child_.text
            deliveryNearbyType_ = re_.sub(String_cleanup_pat_, " ", deliveryNearbyType_).strip()
            deliveryNearbyType_ = self.gds_validate_string(deliveryNearbyType_, node, 'deliveryNearbyType')
            self.deliveryNearbyType = deliveryNearbyType_
            # validate type DeliveryNearbyTypeEnum
            self.validate_DeliveryNearbyTypeEnum(self.deliveryNearbyType)
# end class DeliveryNearby


class DividendPayout(GeneratedsSuper):
    """A type describing the dividend payout ratio associated with an
    equity underlyer. In certain cases the actual ratio is not known
    on trade inception, and only general conditions are then
    specified.A sequence group to describe the total, cash, and non
    cash dividend payout ratio associated with an equity underlyer.
    In certain cases the actual ratio is not known on trade
    inception, and only general conditions are then specified. Good
    practice is to specify only two of the three values, to avoid
    any inconsistency"""
    member_data_items_ = {
        'dividendPayoutRatio': MemberSpec_('dividendPayoutRatio', 'xsd:decimal', 0),
        'dividendPayoutRatioCash': MemberSpec_('dividendPayoutRatioCash', 'xsd:decimal', 0),
        'dividendPayoutRatioNonCash': MemberSpec_('dividendPayoutRatioNonCash', 'xsd:decimal', 0),
        'dividendPayoutConditions': MemberSpec_('dividendPayoutConditions', ['String', 'xsd:string'], 0),
        'dividendPayment': MemberSpec_('dividendPayment', 'PendingPayment', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, dividendPayoutRatio=None, dividendPayoutRatioCash=None, dividendPayoutRatioNonCash=None, dividendPayoutConditions=None, dividendPayment=None):
        self.original_tagname_ = None
        self.dividendPayoutRatio = dividendPayoutRatio
        self.dividendPayoutRatioCash = dividendPayoutRatioCash
        self.dividendPayoutRatioNonCash = dividendPayoutRatioNonCash
        self.dividendPayoutConditions = dividendPayoutConditions
        self.validate_String(self.dividendPayoutConditions)
        if dividendPayment is None:
            self.dividendPayment = []
        else:
            self.dividendPayment = dividendPayment
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DividendPayout)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DividendPayout.subclass:
            return DividendPayout.subclass(*args_, **kwargs_)
        else:
            return DividendPayout(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dividendPayoutRatio(self): return self.dividendPayoutRatio
    def set_dividendPayoutRatio(self, dividendPayoutRatio): self.dividendPayoutRatio = dividendPayoutRatio
    def get_dividendPayoutRatioCash(self): return self.dividendPayoutRatioCash
    def set_dividendPayoutRatioCash(self, dividendPayoutRatioCash): self.dividendPayoutRatioCash = dividendPayoutRatioCash
    def get_dividendPayoutRatioNonCash(self): return self.dividendPayoutRatioNonCash
    def set_dividendPayoutRatioNonCash(self, dividendPayoutRatioNonCash): self.dividendPayoutRatioNonCash = dividendPayoutRatioNonCash
    def get_dividendPayoutConditions(self): return self.dividendPayoutConditions
    def set_dividendPayoutConditions(self, dividendPayoutConditions): self.dividendPayoutConditions = dividendPayoutConditions
    def get_dividendPayment(self): return self.dividendPayment
    def set_dividendPayment(self, dividendPayment): self.dividendPayment = dividendPayment
    def add_dividendPayment(self, value): self.dividendPayment.append(value)
    def insert_dividendPayment_at(self, index, value): self.dividendPayment.insert(index, value)
    def replace_dividendPayment_at(self, index, value): self.dividendPayment[index] = value
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.dividendPayoutRatio is not None or
            self.dividendPayoutRatioCash is not None or
            self.dividendPayoutRatioNonCash is not None or
            self.dividendPayoutConditions is not None or
            self.dividendPayment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DividendPayout', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DividendPayout')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DividendPayout', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DividendPayout'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DividendPayout', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dividendPayoutRatio is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdividendPayoutRatio>%s</%sdividendPayoutRatio>%s' % (namespace_, self.gds_format_float(self.dividendPayoutRatio, input_name='dividendPayoutRatio'), namespace_, eol_))
        if self.dividendPayoutRatioCash is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdividendPayoutRatioCash>%s</%sdividendPayoutRatioCash>%s' % (namespace_, self.gds_format_float(self.dividendPayoutRatioCash, input_name='dividendPayoutRatioCash'), namespace_, eol_))
        if self.dividendPayoutRatioNonCash is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdividendPayoutRatioNonCash>%s</%sdividendPayoutRatioNonCash>%s' % (namespace_, self.gds_format_float(self.dividendPayoutRatioNonCash, input_name='dividendPayoutRatioNonCash'), namespace_, eol_))
        if self.dividendPayoutConditions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdividendPayoutConditions>%s</%sdividendPayoutConditions>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.dividendPayoutConditions), input_name='dividendPayoutConditions')), namespace_, eol_))
        for dividendPayment_ in self.dividendPayment:
            dividendPayment_.export(outfile, level, namespace_, name_='dividendPayment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dividendPayoutRatio':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'dividendPayoutRatio')
            self.dividendPayoutRatio = fval_
        elif nodeName_ == 'dividendPayoutRatioCash':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'dividendPayoutRatioCash')
            self.dividendPayoutRatioCash = fval_
        elif nodeName_ == 'dividendPayoutRatioNonCash':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'dividendPayoutRatioNonCash')
            self.dividendPayoutRatioNonCash = fval_
        elif nodeName_ == 'dividendPayoutConditions':
            dividendPayoutConditions_ = child_.text
            dividendPayoutConditions_ = self.gds_validate_string(dividendPayoutConditions_, node, 'dividendPayoutConditions')
            self.dividendPayoutConditions = dividendPayoutConditions_
            # validate type String
            self.validate_String(self.dividendPayoutConditions)
        elif nodeName_ == 'dividendPayment':
            obj_ = PendingPayment.factory()
            obj_.build(child_)
            self.dividendPayment.append(obj_)
            obj_.original_tagname_ = 'dividendPayment'
# end class DividendPayout


class FacilityType(GeneratedsSuper):
    """A type describing the type of loan facility."""
    member_data_items_ = {
        'facilityTypeScheme': MemberSpec_('facilityTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, facilityTypeScheme='http://www.fpml.org/coding-scheme/facility-type', valueOf_=None):
        self.original_tagname_ = None
        self.facilityTypeScheme = _cast(None, facilityTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FacilityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FacilityType.subclass:
            return FacilityType.subclass(*args_, **kwargs_)
        else:
            return FacilityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_facilityTypeScheme(self): return self.facilityTypeScheme
    def set_facilityTypeScheme(self, facilityTypeScheme): self.facilityTypeScheme = facilityTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FacilityType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FacilityType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FacilityType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FacilityType'):
        if self.facilityTypeScheme != "http://www.fpml.org/coding-scheme/facility-type" and 'facilityTypeScheme' not in already_processed:
            already_processed.add('facilityTypeScheme')
            outfile.write(' facilityTypeScheme=%s' % (quote_attrib(self.facilityTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='FacilityType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('facilityTypeScheme', node)
        if value is not None and 'facilityTypeScheme' not in already_processed:
            already_processed.add('facilityTypeScheme')
            self.facilityTypeScheme = value
            self.validate_NonEmptyURI(self.facilityTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FacilityType


class FutureId(GeneratedsSuper):
    """A type defining a short form unique identifier for a future
    contract."""
    member_data_items_ = {
        'futureIdScheme': MemberSpec_('futureIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, futureIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.futureIdScheme = _cast(None, futureIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FutureId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FutureId.subclass:
            return FutureId.subclass(*args_, **kwargs_)
        else:
            return FutureId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_futureIdScheme(self): return self.futureIdScheme
    def set_futureIdScheme(self, futureIdScheme): self.futureIdScheme = futureIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FutureId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FutureId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FutureId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FutureId'):
        if self.futureIdScheme is not None and 'futureIdScheme' not in already_processed:
            already_processed.add('futureIdScheme')
            outfile.write(' futureIdScheme=%s' % (quote_attrib(self.futureIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='FutureId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('futureIdScheme', node)
        if value is not None and 'futureIdScheme' not in already_processed:
            already_processed.add('futureIdScheme')
            self.futureIdScheme = value
            self.validate_NonEmptyURI(self.futureIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FutureId


class FxConversion(GeneratedsSuper):
    member_data_items_ = {
        'amountRelativeTo': MemberSpec_('amountRelativeTo', 'AmountReference', 0),
        'fxRate': MemberSpec_('fxRate', 'FxRate', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, amountRelativeTo=None, fxRate=None):
        self.original_tagname_ = None
        self.amountRelativeTo = amountRelativeTo
        if fxRate is None:
            self.fxRate = []
        else:
            self.fxRate = fxRate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FxConversion)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FxConversion.subclass:
            return FxConversion.subclass(*args_, **kwargs_)
        else:
            return FxConversion(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_amountRelativeTo(self): return self.amountRelativeTo
    def set_amountRelativeTo(self, amountRelativeTo): self.amountRelativeTo = amountRelativeTo
    def get_fxRate(self): return self.fxRate
    def set_fxRate(self, fxRate): self.fxRate = fxRate
    def add_fxRate(self, value): self.fxRate.append(value)
    def insert_fxRate_at(self, index, value): self.fxRate.insert(index, value)
    def replace_fxRate_at(self, index, value): self.fxRate[index] = value
    def hasContent_(self):
        if (
            self.amountRelativeTo is not None or
            self.fxRate
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FxConversion', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FxConversion')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FxConversion', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FxConversion'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FxConversion', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.amountRelativeTo is not None:
            self.amountRelativeTo.export(outfile, level, namespace_, name_='amountRelativeTo', pretty_print=pretty_print)
        for fxRate_ in self.fxRate:
            fxRate_.export(outfile, level, namespace_, name_='fxRate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'amountRelativeTo':
            obj_ = AmountReference.factory()
            obj_.build(child_)
            self.amountRelativeTo = obj_
            obj_.original_tagname_ = 'amountRelativeTo'
        elif nodeName_ == 'fxRate':
            obj_ = FxRate.factory()
            obj_.build(child_)
            self.fxRate.append(obj_)
            obj_.original_tagname_ = 'fxRate'
# end class FxConversion


class IdentifiedAsset(Asset):
    """A generic type describing an identified asset."""
    member_data_items_ = {
        'instrumentId': MemberSpec_('instrumentId', 'InstrumentId', 1),
        'description': MemberSpec_('description', ['String', 'xsd:string'], 0),
    }
    subclass = None
    superclass = Asset
    def __init__(self, id=None, instrumentId=None, description=None, extensiontype_=None):
        self.original_tagname_ = None
        super(IdentifiedAsset, self).__init__(id, extensiontype_, )
        if instrumentId is None:
            self.instrumentId = []
        else:
            self.instrumentId = instrumentId
        self.description = description
        self.validate_String(self.description)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IdentifiedAsset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IdentifiedAsset.subclass:
            return IdentifiedAsset.subclass(*args_, **kwargs_)
        else:
            return IdentifiedAsset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_instrumentId(self): return self.instrumentId
    def set_instrumentId(self, instrumentId): self.instrumentId = instrumentId
    def add_instrumentId(self, value): self.instrumentId.append(value)
    def insert_instrumentId_at(self, index, value): self.instrumentId.insert(index, value)
    def replace_instrumentId_at(self, index, value): self.instrumentId[index] = value
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.instrumentId or
            self.description is not None or
            super(IdentifiedAsset, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IdentifiedAsset', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifiedAsset')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IdentifiedAsset', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IdentifiedAsset'):
        super(IdentifiedAsset, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifiedAsset')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='IdentifiedAsset', fromsubclass_=False, pretty_print=True):
        super(IdentifiedAsset, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for instrumentId_ in self.instrumentId:
            instrumentId_.export(outfile, level, namespace_, name_='instrumentId', pretty_print=pretty_print)
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(IdentifiedAsset, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'instrumentId':
            obj_ = InstrumentId.factory()
            obj_.build(child_)
            self.instrumentId.append(obj_)
            obj_.original_tagname_ = 'instrumentId'
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
            # validate type String
            self.validate_String(self.description)
        super(IdentifiedAsset, self).buildChildren(child_, node, nodeName_, True)
# end class IdentifiedAsset


class Lien(GeneratedsSuper):
    """A type describing the liens associated with a loan facility."""
    member_data_items_ = {
        'lienScheme': MemberSpec_('lienScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, lienScheme='http://www.fpml.org/coding-scheme/designated-priority', valueOf_=None):
        self.original_tagname_ = None
        self.lienScheme = _cast(None, lienScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Lien)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Lien.subclass:
            return Lien.subclass(*args_, **kwargs_)
        else:
            return Lien(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lienScheme(self): return self.lienScheme
    def set_lienScheme(self, lienScheme): self.lienScheme = lienScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Lien', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Lien')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Lien', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Lien'):
        if self.lienScheme != "http://www.fpml.org/coding-scheme/designated-priority" and 'lienScheme' not in already_processed:
            already_processed.add('lienScheme')
            outfile.write(' lienScheme=%s' % (quote_attrib(self.lienScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Lien', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lienScheme', node)
        if value is not None and 'lienScheme' not in already_processed:
            already_processed.add('lienScheme')
            self.lienScheme = value
            self.validate_NonEmptyURI(self.lienScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Lien


class MortgageSector(GeneratedsSuper):
    """A type describing the typology of mortgage obligations."""
    member_data_items_ = {
        'mortgageSectorScheme': MemberSpec_('mortgageSectorScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, mortgageSectorScheme='http://www.fpml.org/coding-scheme/mortgage-sector', valueOf_=None):
        self.original_tagname_ = None
        self.mortgageSectorScheme = _cast(None, mortgageSectorScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MortgageSector)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MortgageSector.subclass:
            return MortgageSector.subclass(*args_, **kwargs_)
        else:
            return MortgageSector(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mortgageSectorScheme(self): return self.mortgageSectorScheme
    def set_mortgageSectorScheme(self, mortgageSectorScheme): self.mortgageSectorScheme = mortgageSectorScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MortgageSector', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MortgageSector')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MortgageSector', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MortgageSector'):
        if self.mortgageSectorScheme != "http://www.fpml.org/coding-scheme/mortgage-sector" and 'mortgageSectorScheme' not in already_processed:
            already_processed.add('mortgageSectorScheme')
            outfile.write(' mortgageSectorScheme=%s' % (quote_attrib(self.mortgageSectorScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MortgageSector', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mortgageSectorScheme', node)
        if value is not None and 'mortgageSectorScheme' not in already_processed:
            already_processed.add('mortgageSectorScheme')
            self.mortgageSectorScheme = value
            self.validate_NonEmptyURI(self.mortgageSectorScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MortgageSector


class Price(GeneratedsSuper):
    """A type describing the strike price."""
    member_data_items_ = {
        'commission': MemberSpec_('commission', 'Commission', 0),
        'determinationMethod': MemberSpec_('determinationMethod', 'DeterminationMethod', 0),
        'grossPrice': MemberSpec_('grossPrice', 'ActualPrice', 0),
        'netPrice': MemberSpec_('netPrice', 'ActualPrice', 0),
        'accruedInterestPrice': MemberSpec_('accruedInterestPrice', 'xsd:decimal', 0),
        'fxConversion': MemberSpec_('fxConversion', 'FxConversion', 0),
        'amountRelativeTo': MemberSpec_('amountRelativeTo', 'AmountReference', 0),
        'grossPrice': MemberSpec_('grossPrice', 'ActualPrice', 0),
        'netPrice': MemberSpec_('netPrice', 'ActualPrice', 0),
        'accruedInterestPrice': MemberSpec_('accruedInterestPrice', 'xsd:decimal', 0),
        'fxConversion': MemberSpec_('fxConversion', 'FxConversion', 0),
        'cleanNetPrice': MemberSpec_('cleanNetPrice', 'xsd:decimal', 0),
        'quotationCharacteristics': MemberSpec_('quotationCharacteristics', 'QuotationCharacteristics', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, commission=None, determinationMethod=None, grossPrice=None, netPrice=None, accruedInterestPrice=None, fxConversion=None, amountRelativeTo=None, cleanNetPrice=None, quotationCharacteristics=None):
        self.original_tagname_ = None
        self.commission = commission
        self.determinationMethod = determinationMethod
        self.grossPrice = grossPrice
        self.netPrice = netPrice
        self.accruedInterestPrice = accruedInterestPrice
        self.fxConversion = fxConversion
        self.amountRelativeTo = amountRelativeTo
        self.grossPrice = grossPrice
        self.netPrice = netPrice
        self.accruedInterestPrice = accruedInterestPrice
        self.fxConversion = fxConversion
        self.cleanNetPrice = cleanNetPrice
        self.quotationCharacteristics = quotationCharacteristics
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Price)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Price.subclass:
            return Price.subclass(*args_, **kwargs_)
        else:
            return Price(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commission(self): return self.commission
    def set_commission(self, commission): self.commission = commission
    def get_determinationMethod(self): return self.determinationMethod
    def set_determinationMethod(self, determinationMethod): self.determinationMethod = determinationMethod
    def get_grossPrice(self): return self.grossPrice
    def set_grossPrice(self, grossPrice): self.grossPrice = grossPrice
    def get_netPrice(self): return self.netPrice
    def set_netPrice(self, netPrice): self.netPrice = netPrice
    def get_accruedInterestPrice(self): return self.accruedInterestPrice
    def set_accruedInterestPrice(self, accruedInterestPrice): self.accruedInterestPrice = accruedInterestPrice
    def get_fxConversion(self): return self.fxConversion
    def set_fxConversion(self, fxConversion): self.fxConversion = fxConversion
    def get_amountRelativeTo(self): return self.amountRelativeTo
    def set_amountRelativeTo(self, amountRelativeTo): self.amountRelativeTo = amountRelativeTo
    def get_grossPrice(self): return self.grossPrice
    def set_grossPrice(self, grossPrice): self.grossPrice = grossPrice
    def get_netPrice(self): return self.netPrice
    def set_netPrice(self, netPrice): self.netPrice = netPrice
    def get_accruedInterestPrice(self): return self.accruedInterestPrice
    def set_accruedInterestPrice(self, accruedInterestPrice): self.accruedInterestPrice = accruedInterestPrice
    def get_fxConversion(self): return self.fxConversion
    def set_fxConversion(self, fxConversion): self.fxConversion = fxConversion
    def get_cleanNetPrice(self): return self.cleanNetPrice
    def set_cleanNetPrice(self, cleanNetPrice): self.cleanNetPrice = cleanNetPrice
    def get_quotationCharacteristics(self): return self.quotationCharacteristics
    def set_quotationCharacteristics(self, quotationCharacteristics): self.quotationCharacteristics = quotationCharacteristics
    def hasContent_(self):
        if (
            self.commission is not None or
            self.determinationMethod is not None or
            self.grossPrice is not None or
            self.netPrice is not None or
            self.accruedInterestPrice is not None or
            self.fxConversion is not None or
            self.amountRelativeTo is not None or
            self.grossPrice is not None or
            self.netPrice is not None or
            self.accruedInterestPrice is not None or
            self.fxConversion is not None or
            self.cleanNetPrice is not None or
            self.quotationCharacteristics is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Price', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Price')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Price', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Price'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Price', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.commission is not None:
            self.commission.export(outfile, level, namespace_, name_='commission', pretty_print=pretty_print)
        if self.determinationMethod is not None:
            self.determinationMethod.export(outfile, level, namespace_, name_='determinationMethod', pretty_print=pretty_print)
        if self.grossPrice is not None:
            self.grossPrice.export(outfile, level, namespace_, name_='grossPrice', pretty_print=pretty_print)
        if self.netPrice is not None:
            self.netPrice.export(outfile, level, namespace_, name_='netPrice', pretty_print=pretty_print)
        if self.accruedInterestPrice is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saccruedInterestPrice>%s</%saccruedInterestPrice>%s' % (namespace_, self.gds_format_float(self.accruedInterestPrice, input_name='accruedInterestPrice'), namespace_, eol_))
        if self.fxConversion is not None:
            self.fxConversion.export(outfile, level, namespace_, name_='fxConversion', pretty_print=pretty_print)
        if self.amountRelativeTo is not None:
            self.amountRelativeTo.export(outfile, level, namespace_, name_='amountRelativeTo', pretty_print=pretty_print)
        if self.grossPrice is not None:
            self.grossPrice.export(outfile, level, namespace_, name_='grossPrice', pretty_print=pretty_print)
        if self.netPrice is not None:
            self.netPrice.export(outfile, level, namespace_, name_='netPrice', pretty_print=pretty_print)
        if self.accruedInterestPrice is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saccruedInterestPrice>%s</%saccruedInterestPrice>%s' % (namespace_, self.gds_format_float(self.accruedInterestPrice, input_name='accruedInterestPrice'), namespace_, eol_))
        if self.fxConversion is not None:
            self.fxConversion.export(outfile, level, namespace_, name_='fxConversion', pretty_print=pretty_print)
        if self.cleanNetPrice is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scleanNetPrice>%s</%scleanNetPrice>%s' % (namespace_, self.gds_format_float(self.cleanNetPrice, input_name='cleanNetPrice'), namespace_, eol_))
        if self.quotationCharacteristics is not None:
            self.quotationCharacteristics.export(outfile, level, namespace_, name_='quotationCharacteristics', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'commission':
            obj_ = Commission.factory()
            obj_.build(child_)
            self.commission = obj_
            obj_.original_tagname_ = 'commission'
        elif nodeName_ == 'determinationMethod':
            obj_ = DeterminationMethod.factory()
            obj_.build(child_)
            self.determinationMethod = obj_
            obj_.original_tagname_ = 'determinationMethod'
        elif nodeName_ == 'grossPrice':
            obj_ = ActualPrice.factory()
            obj_.build(child_)
            self.grossPrice = obj_
            obj_.original_tagname_ = 'grossPrice'
        elif nodeName_ == 'netPrice':
            obj_ = ActualPrice.factory()
            obj_.build(child_)
            self.netPrice = obj_
            obj_.original_tagname_ = 'netPrice'
        elif nodeName_ == 'accruedInterestPrice':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'accruedInterestPrice')
            self.accruedInterestPrice = fval_
        elif nodeName_ == 'fxConversion':
            obj_ = FxConversion.factory()
            obj_.build(child_)
            self.fxConversion = obj_
            obj_.original_tagname_ = 'fxConversion'
        elif nodeName_ == 'amountRelativeTo':
            obj_ = AmountReference.factory()
            obj_.build(child_)
            self.amountRelativeTo = obj_
            obj_.original_tagname_ = 'amountRelativeTo'
        elif nodeName_ == 'grossPrice':
            obj_ = ActualPrice.factory()
            obj_.build(child_)
            self.grossPrice = obj_
            obj_.original_tagname_ = 'grossPrice'
        elif nodeName_ == 'netPrice':
            obj_ = ActualPrice.factory()
            obj_.build(child_)
            self.netPrice = obj_
            obj_.original_tagname_ = 'netPrice'
        elif nodeName_ == 'accruedInterestPrice':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'accruedInterestPrice')
            self.accruedInterestPrice = fval_
        elif nodeName_ == 'fxConversion':
            obj_ = FxConversion.factory()
            obj_.build(child_)
            self.fxConversion = obj_
            obj_.original_tagname_ = 'fxConversion'
        elif nodeName_ == 'cleanNetPrice':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'cleanNetPrice')
            self.cleanNetPrice = fval_
        elif nodeName_ == 'quotationCharacteristics':
            obj_ = QuotationCharacteristics.factory()
            obj_.build(child_)
            self.quotationCharacteristics = obj_
            obj_.original_tagname_ = 'quotationCharacteristics'
# end class Price


class PriceQuoteUnits(GeneratedsSuper):
    """The units in which a price is quoted."""
    member_data_items_ = {
        'priceQuoteUnitsScheme': MemberSpec_('priceQuoteUnitsScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, priceQuoteUnitsScheme='http://www.fpml.org/coding-scheme/price-quote-units', valueOf_=None):
        self.original_tagname_ = None
        self.priceQuoteUnitsScheme = _cast(None, priceQuoteUnitsScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PriceQuoteUnits)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PriceQuoteUnits.subclass:
            return PriceQuoteUnits.subclass(*args_, **kwargs_)
        else:
            return PriceQuoteUnits(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_priceQuoteUnitsScheme(self): return self.priceQuoteUnitsScheme
    def set_priceQuoteUnitsScheme(self, priceQuoteUnitsScheme): self.priceQuoteUnitsScheme = priceQuoteUnitsScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PriceQuoteUnits', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PriceQuoteUnits')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PriceQuoteUnits', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PriceQuoteUnits'):
        if self.priceQuoteUnitsScheme != "http://www.fpml.org/coding-scheme/price-quote-units" and 'priceQuoteUnitsScheme' not in already_processed:
            already_processed.add('priceQuoteUnitsScheme')
            outfile.write(' priceQuoteUnitsScheme=%s' % (quote_attrib(self.priceQuoteUnitsScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PriceQuoteUnits', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('priceQuoteUnitsScheme', node)
        if value is not None and 'priceQuoteUnitsScheme' not in already_processed:
            already_processed.add('priceQuoteUnitsScheme')
            self.priceQuoteUnitsScheme = value
            self.validate_NonEmptyURI(self.priceQuoteUnitsScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PriceQuoteUnits


class PricingModel(GeneratedsSuper):
    """A scheme identifying the types of pricing model used to evaluate the
    price of an asset. Examples include Intrinsic, ClosedForm,
    MonteCarlo, BackwardInduction."""
    member_data_items_ = {
        'pricingModelScheme': MemberSpec_('pricingModelScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, pricingModelScheme='http://www.fpml.org/coding-scheme/pricing-model', valueOf_=None):
        self.original_tagname_ = None
        self.pricingModelScheme = _cast(None, pricingModelScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PricingModel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PricingModel.subclass:
            return PricingModel.subclass(*args_, **kwargs_)
        else:
            return PricingModel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pricingModelScheme(self): return self.pricingModelScheme
    def set_pricingModelScheme(self, pricingModelScheme): self.pricingModelScheme = pricingModelScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PricingModel', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PricingModel')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PricingModel', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PricingModel'):
        if self.pricingModelScheme != "http://www.fpml.org/coding-scheme/pricing-model" and 'pricingModelScheme' not in already_processed:
            already_processed.add('pricingModelScheme')
            outfile.write(' pricingModelScheme=%s' % (quote_attrib(self.pricingModelScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PricingModel', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pricingModelScheme', node)
        if value is not None and 'pricingModelScheme' not in already_processed:
            already_processed.add('pricingModelScheme')
            self.pricingModelScheme = value
            self.validate_NonEmptyURI(self.pricingModelScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PricingModel


class QuantityUnit(GeneratedsSuper):
    member_data_items_ = {
        'quantityUnitScheme': MemberSpec_('quantityUnitScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, quantityUnitScheme='http://www.fpml.org/coding-scheme/price-quote-units', valueOf_=None):
        self.original_tagname_ = None
        self.quantityUnitScheme = _cast(None, quantityUnitScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QuantityUnit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QuantityUnit.subclass:
            return QuantityUnit.subclass(*args_, **kwargs_)
        else:
            return QuantityUnit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_quantityUnitScheme(self): return self.quantityUnitScheme
    def set_quantityUnitScheme(self, quantityUnitScheme): self.quantityUnitScheme = quantityUnitScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QuantityUnit', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QuantityUnit')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QuantityUnit', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QuantityUnit'):
        if self.quantityUnitScheme != "http://www.fpml.org/coding-scheme/price-quote-units" and 'quantityUnitScheme' not in already_processed:
            already_processed.add('quantityUnitScheme')
            outfile.write(' quantityUnitScheme=%s' % (quote_attrib(self.quantityUnitScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QuantityUnit', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('quantityUnitScheme', node)
        if value is not None and 'quantityUnitScheme' not in already_processed:
            already_processed.add('quantityUnitScheme')
            self.quantityUnitScheme = value
            self.validate_NonEmptyURI(self.quantityUnitScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class QuantityUnit


class QuotationCharacteristics(GeneratedsSuper):
    """A type representing a set of characteristics that describe a
    quotation."""
    member_data_items_ = {
        'measureType': MemberSpec_('measureType', 'AssetMeasureType', 0),
        'quoteUnits': MemberSpec_('quoteUnits', 'PriceQuoteUnits', 0),
        'side': MemberSpec_('side', ['QuotationSideEnum', 'Token', 'xsd:token'], 0),
        'currency': MemberSpec_('currency', 'Currency', 0),
        'currencyType': MemberSpec_('currencyType', 'ReportingCurrencyType', 0),
        'timing': MemberSpec_('timing', 'QuoteTiming', 0),
        'businessCenter': MemberSpec_('businessCenter', 'BusinessCenter', 0),
        'exchangeId': MemberSpec_('exchangeId', 'ExchangeId', 0),
        'informationSource': MemberSpec_('informationSource', 'InformationSource', 1),
        'pricingModel': MemberSpec_('pricingModel', 'PricingModel', 0),
        'time': MemberSpec_('time', 'xsd:dateTime', 0),
        'valuationDate': MemberSpec_('valuationDate', 'xsd:date', 0),
        'expiryTime': MemberSpec_('expiryTime', 'xsd:dateTime', 0),
        'cashflowType': MemberSpec_('cashflowType', 'CashflowType', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, measureType=None, quoteUnits=None, side=None, currency=None, currencyType=None, timing=None, businessCenter=None, exchangeId=None, informationSource=None, pricingModel=None, time=None, valuationDate=None, expiryTime=None, cashflowType=None):
        self.original_tagname_ = None
        self.measureType = measureType
        self.quoteUnits = quoteUnits
        self.side = side
        self.validate_QuotationSideEnum(self.side)
        self.currency = currency
        self.currencyType = currencyType
        self.timing = timing
        self.businessCenter = businessCenter
        self.exchangeId = exchangeId
        if informationSource is None:
            self.informationSource = []
        else:
            self.informationSource = informationSource
        self.pricingModel = pricingModel
        if isinstance(time, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(time, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = time
        self.time = initvalue_
        if isinstance(valuationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(valuationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = valuationDate
        self.valuationDate = initvalue_
        if isinstance(expiryTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(expiryTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = expiryTime
        self.expiryTime = initvalue_
        self.cashflowType = cashflowType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QuotationCharacteristics)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QuotationCharacteristics.subclass:
            return QuotationCharacteristics.subclass(*args_, **kwargs_)
        else:
            return QuotationCharacteristics(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_measureType(self): return self.measureType
    def set_measureType(self, measureType): self.measureType = measureType
    def get_quoteUnits(self): return self.quoteUnits
    def set_quoteUnits(self, quoteUnits): self.quoteUnits = quoteUnits
    def get_side(self): return self.side
    def set_side(self, side): self.side = side
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_currencyType(self): return self.currencyType
    def set_currencyType(self, currencyType): self.currencyType = currencyType
    def get_timing(self): return self.timing
    def set_timing(self, timing): self.timing = timing
    def get_businessCenter(self): return self.businessCenter
    def set_businessCenter(self, businessCenter): self.businessCenter = businessCenter
    def get_exchangeId(self): return self.exchangeId
    def set_exchangeId(self, exchangeId): self.exchangeId = exchangeId
    def get_informationSource(self): return self.informationSource
    def set_informationSource(self, informationSource): self.informationSource = informationSource
    def add_informationSource(self, value): self.informationSource.append(value)
    def insert_informationSource_at(self, index, value): self.informationSource.insert(index, value)
    def replace_informationSource_at(self, index, value): self.informationSource[index] = value
    def get_pricingModel(self): return self.pricingModel
    def set_pricingModel(self, pricingModel): self.pricingModel = pricingModel
    def get_time(self): return self.time
    def set_time(self, time): self.time = time
    def get_valuationDate(self): return self.valuationDate
    def set_valuationDate(self, valuationDate): self.valuationDate = valuationDate
    def get_expiryTime(self): return self.expiryTime
    def set_expiryTime(self, expiryTime): self.expiryTime = expiryTime
    def get_cashflowType(self): return self.cashflowType
    def set_cashflowType(self, cashflowType): self.cashflowType = cashflowType
    def validate_QuotationSideEnum(self, value):
        # Validate type QuotationSideEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Bid', 'Ask', 'Mid']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on QuotationSideEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on QuotationSideEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.measureType is not None or
            self.quoteUnits is not None or
            self.side is not None or
            self.currency is not None or
            self.currencyType is not None or
            self.timing is not None or
            self.businessCenter is not None or
            self.exchangeId is not None or
            self.informationSource or
            self.pricingModel is not None or
            self.time is not None or
            self.valuationDate is not None or
            self.expiryTime is not None or
            self.cashflowType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QuotationCharacteristics', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QuotationCharacteristics')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QuotationCharacteristics', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QuotationCharacteristics'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='QuotationCharacteristics', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.measureType is not None:
            self.measureType.export(outfile, level, namespace_, name_='measureType', pretty_print=pretty_print)
        if self.quoteUnits is not None:
            self.quoteUnits.export(outfile, level, namespace_, name_='quoteUnits', pretty_print=pretty_print)
        if self.side is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sside>%s</%sside>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.side), input_name='side')), namespace_, eol_))
        if self.currency is not None:
            self.currency.export(outfile, level, namespace_, name_='currency', pretty_print=pretty_print)
        if self.currencyType is not None:
            self.currencyType.export(outfile, level, namespace_, name_='currencyType', pretty_print=pretty_print)
        if self.timing is not None:
            self.timing.export(outfile, level, namespace_, name_='timing', pretty_print=pretty_print)
        if self.businessCenter is not None:
            self.businessCenter.export(outfile, level, namespace_, name_='businessCenter', pretty_print=pretty_print)
        if self.exchangeId is not None:
            self.exchangeId.export(outfile, level, namespace_, name_='exchangeId', pretty_print=pretty_print)
        for informationSource_ in self.informationSource:
            informationSource_.export(outfile, level, namespace_, name_='informationSource', pretty_print=pretty_print)
        if self.pricingModel is not None:
            self.pricingModel.export(outfile, level, namespace_, name_='pricingModel', pretty_print=pretty_print)
        if self.time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stime>%s</%stime>%s' % (namespace_, self.gds_format_datetime(self.time, input_name='time'), namespace_, eol_))
        if self.valuationDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svaluationDate>%s</%svaluationDate>%s' % (namespace_, self.gds_format_date(self.valuationDate, input_name='valuationDate'), namespace_, eol_))
        if self.expiryTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexpiryTime>%s</%sexpiryTime>%s' % (namespace_, self.gds_format_datetime(self.expiryTime, input_name='expiryTime'), namespace_, eol_))
        if self.cashflowType is not None:
            self.cashflowType.export(outfile, level, namespace_, name_='cashflowType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'measureType':
            obj_ = AssetMeasureType.factory()
            obj_.build(child_)
            self.measureType = obj_
            obj_.original_tagname_ = 'measureType'
        elif nodeName_ == 'quoteUnits':
            obj_ = PriceQuoteUnits.factory()
            obj_.build(child_)
            self.quoteUnits = obj_
            obj_.original_tagname_ = 'quoteUnits'
        elif nodeName_ == 'side':
            side_ = child_.text
            side_ = re_.sub(String_cleanup_pat_, " ", side_).strip()
            side_ = self.gds_validate_string(side_, node, 'side')
            self.side = side_
            # validate type QuotationSideEnum
            self.validate_QuotationSideEnum(self.side)
        elif nodeName_ == 'currency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'currencyType':
            obj_ = ReportingCurrencyType.factory()
            obj_.build(child_)
            self.currencyType = obj_
            obj_.original_tagname_ = 'currencyType'
        elif nodeName_ == 'timing':
            obj_ = QuoteTiming.factory()
            obj_.build(child_)
            self.timing = obj_
            obj_.original_tagname_ = 'timing'
        elif nodeName_ == 'businessCenter':
            obj_ = BusinessCenter.factory()
            obj_.build(child_)
            self.businessCenter = obj_
            obj_.original_tagname_ = 'businessCenter'
        elif nodeName_ == 'exchangeId':
            obj_ = ExchangeId.factory()
            obj_.build(child_)
            self.exchangeId = obj_
            obj_.original_tagname_ = 'exchangeId'
        elif nodeName_ == 'informationSource':
            class_obj_ = self.get_class_obj_(child_, InformationSource)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.informationSource.append(obj_)
            obj_.original_tagname_ = 'informationSource'
        elif nodeName_ == 'pricingModel':
            obj_ = PricingModel.factory()
            obj_.build(child_)
            self.pricingModel = obj_
            obj_.original_tagname_ = 'pricingModel'
        elif nodeName_ == 'time':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.time = dval_
        elif nodeName_ == 'valuationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.valuationDate = dval_
        elif nodeName_ == 'expiryTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.expiryTime = dval_
        elif nodeName_ == 'cashflowType':
            obj_ = CashflowType.factory()
            obj_.build(child_)
            self.cashflowType = obj_
            obj_.original_tagname_ = 'cashflowType'
# end class QuotationCharacteristics


class QuoteTiming(GeneratedsSuper):
    """The type of the time of the quote."""
    member_data_items_ = {
        'quoteTimingScheme': MemberSpec_('quoteTimingScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, quoteTimingScheme='http://www.fpml.org/coding-scheme/quote-timing', valueOf_=None):
        self.original_tagname_ = None
        self.quoteTimingScheme = _cast(None, quoteTimingScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QuoteTiming)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QuoteTiming.subclass:
            return QuoteTiming.subclass(*args_, **kwargs_)
        else:
            return QuoteTiming(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_quoteTimingScheme(self): return self.quoteTimingScheme
    def set_quoteTimingScheme(self, quoteTimingScheme): self.quoteTimingScheme = quoteTimingScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QuoteTiming', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QuoteTiming')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QuoteTiming', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QuoteTiming'):
        if self.quoteTimingScheme != "http://www.fpml.org/coding-scheme/quote-timing" and 'quoteTimingScheme' not in already_processed:
            already_processed.add('quoteTimingScheme')
            outfile.write(' quoteTimingScheme=%s' % (quote_attrib(self.quoteTimingScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QuoteTiming', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('quoteTimingScheme', node)
        if value is not None and 'quoteTimingScheme' not in already_processed:
            already_processed.add('quoteTimingScheme')
            self.quoteTimingScheme = value
            self.validate_NonEmptyURI(self.quoteTimingScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class QuoteTiming


class ReportingCurrencyType(GeneratedsSuper):
    """A scheme identifying the type of currency that was used to report
    the value of an asset. For example, this could contain values
    like SettlementCurrency, QuoteCurrency, UnitCurrency, etc."""
    member_data_items_ = {
        'reportingCurrencyTypeScheme': MemberSpec_('reportingCurrencyTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, reportingCurrencyTypeScheme='http://www.fpml.org/coding-scheme/reporting-currency-type', valueOf_=None):
        self.original_tagname_ = None
        self.reportingCurrencyTypeScheme = _cast(None, reportingCurrencyTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReportingCurrencyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReportingCurrencyType.subclass:
            return ReportingCurrencyType.subclass(*args_, **kwargs_)
        else:
            return ReportingCurrencyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_reportingCurrencyTypeScheme(self): return self.reportingCurrencyTypeScheme
    def set_reportingCurrencyTypeScheme(self, reportingCurrencyTypeScheme): self.reportingCurrencyTypeScheme = reportingCurrencyTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReportingCurrencyType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReportingCurrencyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReportingCurrencyType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReportingCurrencyType'):
        if self.reportingCurrencyTypeScheme != "http://www.fpml.org/coding-scheme/reporting-currency-type" and 'reportingCurrencyTypeScheme' not in already_processed:
            already_processed.add('reportingCurrencyTypeScheme')
            outfile.write(' reportingCurrencyTypeScheme=%s' % (quote_attrib(self.reportingCurrencyTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ReportingCurrencyType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('reportingCurrencyTypeScheme', node)
        if value is not None and 'reportingCurrencyTypeScheme' not in already_processed:
            already_processed.add('reportingCurrencyTypeScheme')
            self.reportingCurrencyTypeScheme = value
            self.validate_NonEmptyURI(self.reportingCurrencyTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReportingCurrencyType


class SingleUnderlyer(GeneratedsSuper):
    """A type describing a single underlyer"""
    member_data_items_ = {
        'underlyingAsset': MemberSpec_('underlyingAsset', 'Asset', 0),
        'openUnits': MemberSpec_('openUnits', 'xsd:decimal', 0),
        'dividendPayout': MemberSpec_('dividendPayout', 'DividendPayout', 0),
        'couponPayment': MemberSpec_('couponPayment', 'PendingPayment', 0),
        'averageDailyTradingVolume': MemberSpec_('averageDailyTradingVolume', 'AverageDailyTradingVolumeLimit', 0),
        'depositoryReceipt': MemberSpec_('depositoryReceipt', 'xsd:boolean', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, underlyingAsset=None, openUnits=None, dividendPayout=None, couponPayment=None, averageDailyTradingVolume=None, depositoryReceipt=None):
        self.original_tagname_ = None
        self.underlyingAsset = underlyingAsset
        self.openUnits = openUnits
        self.dividendPayout = dividendPayout
        self.couponPayment = couponPayment
        self.averageDailyTradingVolume = averageDailyTradingVolume
        self.depositoryReceipt = depositoryReceipt
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SingleUnderlyer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SingleUnderlyer.subclass:
            return SingleUnderlyer.subclass(*args_, **kwargs_)
        else:
            return SingleUnderlyer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_underlyingAsset(self): return self.underlyingAsset
    def set_underlyingAsset(self, underlyingAsset): self.underlyingAsset = underlyingAsset
    def get_openUnits(self): return self.openUnits
    def set_openUnits(self, openUnits): self.openUnits = openUnits
    def get_dividendPayout(self): return self.dividendPayout
    def set_dividendPayout(self, dividendPayout): self.dividendPayout = dividendPayout
    def get_couponPayment(self): return self.couponPayment
    def set_couponPayment(self, couponPayment): self.couponPayment = couponPayment
    def get_averageDailyTradingVolume(self): return self.averageDailyTradingVolume
    def set_averageDailyTradingVolume(self, averageDailyTradingVolume): self.averageDailyTradingVolume = averageDailyTradingVolume
    def get_depositoryReceipt(self): return self.depositoryReceipt
    def set_depositoryReceipt(self, depositoryReceipt): self.depositoryReceipt = depositoryReceipt
    def hasContent_(self):
        if (
            self.underlyingAsset is not None or
            self.openUnits is not None or
            self.dividendPayout is not None or
            self.couponPayment is not None or
            self.averageDailyTradingVolume is not None or
            self.depositoryReceipt is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SingleUnderlyer', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SingleUnderlyer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SingleUnderlyer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SingleUnderlyer'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SingleUnderlyer', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.underlyingAsset is not None:
            self.underlyingAsset.export(outfile, level, namespace_, name_='underlyingAsset', pretty_print=pretty_print)
        if self.openUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sopenUnits>%s</%sopenUnits>%s' % (namespace_, self.gds_format_float(self.openUnits, input_name='openUnits'), namespace_, eol_))
        if self.dividendPayout is not None:
            self.dividendPayout.export(outfile, level, namespace_, name_='dividendPayout', pretty_print=pretty_print)
        if self.couponPayment is not None:
            self.couponPayment.export(outfile, level, namespace_, name_='couponPayment', pretty_print=pretty_print)
        if self.averageDailyTradingVolume is not None:
            self.averageDailyTradingVolume.export(outfile, level, namespace_, name_='averageDailyTradingVolume', pretty_print=pretty_print)
        if self.depositoryReceipt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdepositoryReceipt>%s</%sdepositoryReceipt>%s' % (namespace_, self.gds_format_boolean(self.depositoryReceipt, input_name='depositoryReceipt'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'underlyingAsset':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <underlyingAsset> element')
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'underlyingAsset'
        elif nodeName_ == 'basket':
            obj_ = Basket.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'basket'
        elif nodeName_ == 'bond':
            class_obj_ = self.get_class_obj_(child_, Bond)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'bond'
        elif nodeName_ == 'cash':
            obj_ = Cash.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'cash'
        elif nodeName_ == 'commodity':
            obj_ = Commodity.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'commodity'
        elif nodeName_ == 'convertibleBond':
            obj_ = ConvertibleBond.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'convertibleBond'
        elif nodeName_ == 'equity':
            obj_ = EquityAsset.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'equity'
        elif nodeName_ == 'exchangeTradedFund':
            obj_ = ExchangeTradedFund.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'exchangeTradedFund'
        elif nodeName_ == 'future':
            obj_ = Future.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'future'
        elif nodeName_ == 'index':
            obj_ = Index.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'index'
        elif nodeName_ == 'loan':
            obj_ = Loan.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'loan'
        elif nodeName_ == 'mortgage':
            obj_ = Mortgage.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'mortgage'
        elif nodeName_ == 'mutualFund':
            obj_ = MutualFund.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'mutualFund'
        elif nodeName_ == 'option':
            obj_ = ExchangeTradedOption.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'option'
        elif nodeName_ == 'openUnits':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'openUnits')
            self.openUnits = fval_
        elif nodeName_ == 'dividendPayout':
            obj_ = DividendPayout.factory()
            obj_.build(child_)
            self.dividendPayout = obj_
            obj_.original_tagname_ = 'dividendPayout'
        elif nodeName_ == 'couponPayment':
            obj_ = PendingPayment.factory()
            obj_.build(child_)
            self.couponPayment = obj_
            obj_.original_tagname_ = 'couponPayment'
        elif nodeName_ == 'averageDailyTradingVolume':
            obj_ = AverageDailyTradingVolumeLimit.factory()
            obj_.build(child_)
            self.averageDailyTradingVolume = obj_
            obj_.original_tagname_ = 'averageDailyTradingVolume'
        elif nodeName_ == 'depositoryReceipt':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'depositoryReceipt')
            self.depositoryReceipt = ival_
# end class SingleUnderlyer


class Underlyer(GeneratedsSuper):
    """A type describing the whole set of possible underlyers: single
    underlyers or multiple underlyers, each of these having either
    security or index components."""
    member_data_items_ = {
        'singleUnderlyer': MemberSpec_('singleUnderlyer', 'SingleUnderlyer', 0),
        'basket': MemberSpec_('basket', 'Basket', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, singleUnderlyer=None, basket=None):
        self.original_tagname_ = None
        self.singleUnderlyer = singleUnderlyer
        self.basket = basket
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Underlyer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Underlyer.subclass:
            return Underlyer.subclass(*args_, **kwargs_)
        else:
            return Underlyer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_singleUnderlyer(self): return self.singleUnderlyer
    def set_singleUnderlyer(self, singleUnderlyer): self.singleUnderlyer = singleUnderlyer
    def get_basket(self): return self.basket
    def set_basket(self, basket): self.basket = basket
    def hasContent_(self):
        if (
            self.singleUnderlyer is not None or
            self.basket is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Underlyer', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Underlyer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Underlyer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Underlyer'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Underlyer', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.singleUnderlyer is not None:
            self.singleUnderlyer.export(outfile, level, namespace_, name_='singleUnderlyer', pretty_print=pretty_print)
        if self.basket is not None:
            self.basket.export(outfile, level, namespace_, name_='basket', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'singleUnderlyer':
            obj_ = SingleUnderlyer.factory()
            obj_.build(child_)
            self.singleUnderlyer = obj_
            obj_.original_tagname_ = 'singleUnderlyer'
        elif nodeName_ == 'basket':
            obj_ = Basket.factory()
            obj_.build(child_)
            self.basket = obj_
            obj_.original_tagname_ = 'basket'
# end class Underlyer


class UnderlyingAsset(IdentifiedAsset):
    """Abstract base class for all underlying assets."""
    member_data_items_ = {
        'currency': MemberSpec_('currency', 'IdentifiedCurrency', 0),
        'exchangeId': MemberSpec_('exchangeId', 'ExchangeId', 0),
        'clearanceSystem': MemberSpec_('clearanceSystem', 'ClearanceSystem', 0),
        'definition': MemberSpec_('definition', 'ProductReference', 0),
    }
    subclass = None
    superclass = IdentifiedAsset
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, extensiontype_=None):
        self.original_tagname_ = None
        super(UnderlyingAsset, self).__init__(id, instrumentId, description, extensiontype_, )
        self.currency = currency
        self.exchangeId = exchangeId
        self.clearanceSystem = clearanceSystem
        self.definition = definition
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UnderlyingAsset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UnderlyingAsset.subclass:
            return UnderlyingAsset.subclass(*args_, **kwargs_)
        else:
            return UnderlyingAsset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_exchangeId(self): return self.exchangeId
    def set_exchangeId(self, exchangeId): self.exchangeId = exchangeId
    def get_clearanceSystem(self): return self.clearanceSystem
    def set_clearanceSystem(self, clearanceSystem): self.clearanceSystem = clearanceSystem
    def get_definition(self): return self.definition
    def set_definition(self, definition): self.definition = definition
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.currency is not None or
            self.exchangeId is not None or
            self.clearanceSystem is not None or
            self.definition is not None or
            super(UnderlyingAsset, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='UnderlyingAsset', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UnderlyingAsset')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='UnderlyingAsset', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UnderlyingAsset'):
        super(UnderlyingAsset, self).exportAttributes(outfile, level, already_processed, namespace_, name_='UnderlyingAsset')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='UnderlyingAsset', fromsubclass_=False, pretty_print=True):
        super(UnderlyingAsset, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.currency is not None:
            self.currency.export(outfile, level, namespace_, name_='currency', pretty_print=pretty_print)
        if self.exchangeId is not None:
            self.exchangeId.export(outfile, level, namespace_, name_='exchangeId', pretty_print=pretty_print)
        if self.clearanceSystem is not None:
            self.clearanceSystem.export(outfile, level, namespace_, name_='clearanceSystem', pretty_print=pretty_print)
        if self.definition is not None:
            self.definition.export(outfile, level, namespace_, name_='definition', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(UnderlyingAsset, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'currency':
            obj_ = IdentifiedCurrency.factory()
            obj_.build(child_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'exchangeId':
            obj_ = ExchangeId.factory()
            obj_.build(child_)
            self.exchangeId = obj_
            obj_.original_tagname_ = 'exchangeId'
        elif nodeName_ == 'clearanceSystem':
            obj_ = ClearanceSystem.factory()
            obj_.build(child_)
            self.clearanceSystem = obj_
            obj_.original_tagname_ = 'clearanceSystem'
        elif nodeName_ == 'definition':
            obj_ = ProductReference.factory()
            obj_.build(child_)
            self.definition = obj_
            obj_.original_tagname_ = 'definition'
        super(UnderlyingAsset, self).buildChildren(child_, node, nodeName_, True)
# end class UnderlyingAsset


class UnderlyingAssetTranche(GeneratedsSuper):
    member_data_items_ = {
        'loanTrancheScheme': MemberSpec_('loanTrancheScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, loanTrancheScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.loanTrancheScheme = _cast(None, loanTrancheScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UnderlyingAssetTranche)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UnderlyingAssetTranche.subclass:
            return UnderlyingAssetTranche.subclass(*args_, **kwargs_)
        else:
            return UnderlyingAssetTranche(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_loanTrancheScheme(self): return self.loanTrancheScheme
    def set_loanTrancheScheme(self, loanTrancheScheme): self.loanTrancheScheme = loanTrancheScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='UnderlyingAssetTranche', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UnderlyingAssetTranche')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='UnderlyingAssetTranche', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UnderlyingAssetTranche'):
        if self.loanTrancheScheme is not None and 'loanTrancheScheme' not in already_processed:
            already_processed.add('loanTrancheScheme')
            outfile.write(' loanTrancheScheme=%s' % (quote_attrib(self.loanTrancheScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='UnderlyingAssetTranche', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('loanTrancheScheme', node)
        if value is not None and 'loanTrancheScheme' not in already_processed:
            already_processed.add('loanTrancheScheme')
            self.loanTrancheScheme = value
            self.validate_NonEmptyURI(self.loanTrancheScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class UnderlyingAssetTranche


class UnderlyerLoanRate(GeneratedsSuper):
    """Defines stock loan information where this is required per underlyer.
    You must not duplicate infromation within dividend conditions at
    transaction level"""
    member_data_items_ = {
        'lossOfStockBorrow': MemberSpec_('lossOfStockBorrow', 'xsd:boolean', 0),
        'maximumStockLoanRate': MemberSpec_('maximumStockLoanRate', ['RestrictedPercentage', 'xsd:decimal'], 0),
        'increasedCostOfStockBorrow': MemberSpec_('increasedCostOfStockBorrow', 'xsd:boolean', 0),
        'initialStockLoanRate': MemberSpec_('initialStockLoanRate', ['RestrictedPercentage', 'xsd:decimal'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, lossOfStockBorrow=None, maximumStockLoanRate=None, increasedCostOfStockBorrow=None, initialStockLoanRate=None):
        self.original_tagname_ = None
        self.lossOfStockBorrow = lossOfStockBorrow
        self.maximumStockLoanRate = maximumStockLoanRate
        self.validate_RestrictedPercentage(self.maximumStockLoanRate)
        self.increasedCostOfStockBorrow = increasedCostOfStockBorrow
        self.initialStockLoanRate = initialStockLoanRate
        self.validate_RestrictedPercentage(self.initialStockLoanRate)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UnderlyerLoanRate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UnderlyerLoanRate.subclass:
            return UnderlyerLoanRate.subclass(*args_, **kwargs_)
        else:
            return UnderlyerLoanRate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lossOfStockBorrow(self): return self.lossOfStockBorrow
    def set_lossOfStockBorrow(self, lossOfStockBorrow): self.lossOfStockBorrow = lossOfStockBorrow
    def get_maximumStockLoanRate(self): return self.maximumStockLoanRate
    def set_maximumStockLoanRate(self, maximumStockLoanRate): self.maximumStockLoanRate = maximumStockLoanRate
    def get_increasedCostOfStockBorrow(self): return self.increasedCostOfStockBorrow
    def set_increasedCostOfStockBorrow(self, increasedCostOfStockBorrow): self.increasedCostOfStockBorrow = increasedCostOfStockBorrow
    def get_initialStockLoanRate(self): return self.initialStockLoanRate
    def set_initialStockLoanRate(self, initialStockLoanRate): self.initialStockLoanRate = initialStockLoanRate
    def validate_RestrictedPercentage(self, value):
        # Validate type RestrictedPercentage, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on RestrictedPercentage' % {"value" : value} )
            if value > 1:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on RestrictedPercentage' % {"value" : value} )
    def hasContent_(self):
        if (
            self.lossOfStockBorrow is not None or
            self.maximumStockLoanRate is not None or
            self.increasedCostOfStockBorrow is not None or
            self.initialStockLoanRate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='UnderlyerLoanRate', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UnderlyerLoanRate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='UnderlyerLoanRate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UnderlyerLoanRate'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='UnderlyerLoanRate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.lossOfStockBorrow is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slossOfStockBorrow>%s</%slossOfStockBorrow>%s' % (namespace_, self.gds_format_boolean(self.lossOfStockBorrow, input_name='lossOfStockBorrow'), namespace_, eol_))
        if self.maximumStockLoanRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaximumStockLoanRate>%s</%smaximumStockLoanRate>%s' % (namespace_, self.gds_format_float(self.maximumStockLoanRate, input_name='maximumStockLoanRate'), namespace_, eol_))
        if self.increasedCostOfStockBorrow is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sincreasedCostOfStockBorrow>%s</%sincreasedCostOfStockBorrow>%s' % (namespace_, self.gds_format_boolean(self.increasedCostOfStockBorrow, input_name='increasedCostOfStockBorrow'), namespace_, eol_))
        if self.initialStockLoanRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinitialStockLoanRate>%s</%sinitialStockLoanRate>%s' % (namespace_, self.gds_format_float(self.initialStockLoanRate, input_name='initialStockLoanRate'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'lossOfStockBorrow':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'lossOfStockBorrow')
            self.lossOfStockBorrow = ival_
        elif nodeName_ == 'maximumStockLoanRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'maximumStockLoanRate')
            self.maximumStockLoanRate = fval_
            # validate type RestrictedPercentage
            self.validate_RestrictedPercentage(self.maximumStockLoanRate)
        elif nodeName_ == 'increasedCostOfStockBorrow':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'increasedCostOfStockBorrow')
            self.increasedCostOfStockBorrow = ival_
        elif nodeName_ == 'initialStockLoanRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'initialStockLoanRate')
            self.initialStockLoanRate = fval_
            # validate type RestrictedPercentage
            self.validate_RestrictedPercentage(self.initialStockLoanRate)
# end class UnderlyerLoanRate


class Account(GeneratedsSuper):
    """A generic account that represents any party's account at another
    party. Parties may be identified by the account at another
    party.The unique identifier for the account within the document."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'accountId': MemberSpec_('accountId', 'AccountId', 1),
        'accountName': MemberSpec_('accountName', 'AccountName', 0),
        'accountType': MemberSpec_('accountType', 'AccountType', 0),
        'accountBeneficiary': MemberSpec_('accountBeneficiary', 'PartyReference', 0),
        'servicingParty': MemberSpec_('servicingParty', 'PartyReference', 0),
        'servicingParty': MemberSpec_('servicingParty', 'PartyReference', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, accountId=None, accountName=None, accountType=None, accountBeneficiary=None, servicingParty=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if accountId is None:
            self.accountId = []
        else:
            self.accountId = accountId
        self.accountName = accountName
        self.accountType = accountType
        self.accountBeneficiary = accountBeneficiary
        self.servicingParty = servicingParty
        self.servicingParty = servicingParty
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Account)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Account.subclass:
            return Account.subclass(*args_, **kwargs_)
        else:
            return Account(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_accountId(self): return self.accountId
    def set_accountId(self, accountId): self.accountId = accountId
    def add_accountId(self, value): self.accountId.append(value)
    def insert_accountId_at(self, index, value): self.accountId.insert(index, value)
    def replace_accountId_at(self, index, value): self.accountId[index] = value
    def get_accountName(self): return self.accountName
    def set_accountName(self, accountName): self.accountName = accountName
    def get_accountType(self): return self.accountType
    def set_accountType(self, accountType): self.accountType = accountType
    def get_accountBeneficiary(self): return self.accountBeneficiary
    def set_accountBeneficiary(self, accountBeneficiary): self.accountBeneficiary = accountBeneficiary
    def get_servicingParty(self): return self.servicingParty
    def set_servicingParty(self, servicingParty): self.servicingParty = servicingParty
    def get_servicingParty(self): return self.servicingParty
    def set_servicingParty(self, servicingParty): self.servicingParty = servicingParty
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.accountId or
            self.accountName is not None or
            self.accountType is not None or
            self.accountBeneficiary is not None or
            self.servicingParty is not None or
            self.servicingParty is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Account', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Account')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Account', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Account'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Account', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for accountId_ in self.accountId:
            accountId_.export(outfile, level, namespace_, name_='accountId', pretty_print=pretty_print)
        if self.accountName is not None:
            self.accountName.export(outfile, level, namespace_, name_='accountName', pretty_print=pretty_print)
        if self.accountType is not None:
            self.accountType.export(outfile, level, namespace_, name_='accountType', pretty_print=pretty_print)
        if self.accountBeneficiary is not None:
            self.accountBeneficiary.export(outfile, level, namespace_, name_='accountBeneficiary', pretty_print=pretty_print)
        if self.servicingParty is not None:
            self.servicingParty.export(outfile, level, namespace_, name_='servicingParty', pretty_print=pretty_print)
        if self.servicingParty is not None:
            self.servicingParty.export(outfile, level, namespace_, name_='servicingParty', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'accountId':
            obj_ = AccountId.factory()
            obj_.build(child_)
            self.accountId.append(obj_)
            obj_.original_tagname_ = 'accountId'
        elif nodeName_ == 'accountName':
            obj_ = AccountName.factory()
            obj_.build(child_)
            self.accountName = obj_
            obj_.original_tagname_ = 'accountName'
        elif nodeName_ == 'accountType':
            obj_ = AccountType.factory()
            obj_.build(child_)
            self.accountType = obj_
            obj_.original_tagname_ = 'accountType'
        elif nodeName_ == 'accountBeneficiary':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.accountBeneficiary = obj_
            obj_.original_tagname_ = 'accountBeneficiary'
        elif nodeName_ == 'servicingParty':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.servicingParty = obj_
            obj_.original_tagname_ = 'servicingParty'
        elif nodeName_ == 'servicingParty':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.servicingParty = obj_
            obj_.original_tagname_ = 'servicingParty'
# end class Account


class AccountId(GeneratedsSuper):
    """The data type used for account identifiers.The identifier scheme
    used with this accountId. A unique URI to determine the
    authoritative issuer of these identifiers."""
    member_data_items_ = {
        'accountIdScheme': MemberSpec_('accountIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, accountIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.accountIdScheme = _cast(None, accountIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AccountId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AccountId.subclass:
            return AccountId.subclass(*args_, **kwargs_)
        else:
            return AccountId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_accountIdScheme(self): return self.accountIdScheme
    def set_accountIdScheme(self, accountIdScheme): self.accountIdScheme = accountIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AccountId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AccountId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AccountId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AccountId'):
        if self.accountIdScheme is not None and 'accountIdScheme' not in already_processed:
            already_processed.add('accountIdScheme')
            outfile.write(' accountIdScheme=%s' % (quote_attrib(self.accountIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AccountId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('accountIdScheme', node)
        if value is not None and 'accountIdScheme' not in already_processed:
            already_processed.add('accountIdScheme')
            self.accountIdScheme = value
            self.validate_NonEmptyURI(self.accountIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AccountId


class AccountName(GeneratedsSuper):
    """The data type used for the name of the account.The identifier scheme
    used with this accountName. A unique URI to determine the source
    of the account name."""
    member_data_items_ = {
        'accountNameScheme': MemberSpec_('accountNameScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, accountNameScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.accountNameScheme = _cast(None, accountNameScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AccountName)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AccountName.subclass:
            return AccountName.subclass(*args_, **kwargs_)
        else:
            return AccountName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_accountNameScheme(self): return self.accountNameScheme
    def set_accountNameScheme(self, accountNameScheme): self.accountNameScheme = accountNameScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AccountName', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AccountName')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AccountName', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AccountName'):
        if self.accountNameScheme is not None and 'accountNameScheme' not in already_processed:
            already_processed.add('accountNameScheme')
            outfile.write(' accountNameScheme=%s' % (quote_attrib(self.accountNameScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AccountName', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('accountNameScheme', node)
        if value is not None and 'accountNameScheme' not in already_processed:
            already_processed.add('accountNameScheme')
            self.accountNameScheme = value
            self.validate_NonEmptyURI(self.accountNameScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AccountName


class AccountType(GeneratedsSuper):
    """The data type used for account type.The identifier scheme used with
    this accountType. A unique URI to determine the the type of
    account."""
    member_data_items_ = {
        'accountTypeScheme': MemberSpec_('accountTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, accountTypeScheme='http://www.fpml.org/coding-scheme/account-type', valueOf_=None):
        self.original_tagname_ = None
        self.accountTypeScheme = _cast(None, accountTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AccountType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AccountType.subclass:
            return AccountType.subclass(*args_, **kwargs_)
        else:
            return AccountType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_accountTypeScheme(self): return self.accountTypeScheme
    def set_accountTypeScheme(self, accountTypeScheme): self.accountTypeScheme = accountTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AccountType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AccountType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AccountType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AccountType'):
        if self.accountTypeScheme != "http://www.fpml.org/coding-scheme/account-type" and 'accountTypeScheme' not in already_processed:
            already_processed.add('accountTypeScheme')
            outfile.write(' accountTypeScheme=%s' % (quote_attrib(self.accountTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AccountType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('accountTypeScheme', node)
        if value is not None and 'accountTypeScheme' not in already_processed:
            already_processed.add('accountTypeScheme')
            self.accountTypeScheme = value
            self.validate_NonEmptyURI(self.accountTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AccountType


class ActionType(GeneratedsSuper):
    """The data type used for ESMA action type.The identifier scheme used
    with this actionType. A unique URI to determine the the type of
    action."""
    member_data_items_ = {
        'actionTypeScheme': MemberSpec_('actionTypeScheme', 'xsd:anyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, actionTypeScheme='http://www.fpml.org/coding-scheme/action-type', valueOf_=None):
        self.original_tagname_ = None
        self.actionTypeScheme = _cast(None, actionTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ActionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ActionType.subclass:
            return ActionType.subclass(*args_, **kwargs_)
        else:
            return ActionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_actionTypeScheme(self): return self.actionTypeScheme
    def set_actionTypeScheme(self, actionTypeScheme): self.actionTypeScheme = actionTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ActionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ActionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ActionType'):
        if self.actionTypeScheme != "http://www.fpml.org/coding-scheme/action-type" and 'actionTypeScheme' not in already_processed:
            already_processed.add('actionTypeScheme')
            outfile.write(' actionTypeScheme=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actionTypeScheme), input_name='actionTypeScheme')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ActionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('actionTypeScheme', node)
        if value is not None and 'actionTypeScheme' not in already_processed:
            already_processed.add('actionTypeScheme')
            self.actionTypeScheme = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ActionType


class Address(GeneratedsSuper):
    """A type that represents a physical postal address."""
    member_data_items_ = {
        'streetAddress': MemberSpec_('streetAddress', 'StreetAddress', 0),
        'city': MemberSpec_('city', ['String', 'xsd:string'], 0),
        'state': MemberSpec_('state', ['String', 'xsd:string'], 0),
        'country': MemberSpec_('country', 'CountryCode', 0),
        'postalCode': MemberSpec_('postalCode', ['String', 'xsd:string'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, streetAddress=None, city=None, state=None, country=None, postalCode=None):
        self.original_tagname_ = None
        self.streetAddress = streetAddress
        self.city = city
        self.validate_String(self.city)
        self.state = state
        self.validate_String(self.state)
        self.country = country
        self.postalCode = postalCode
        self.validate_String(self.postalCode)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Address)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Address.subclass:
            return Address.subclass(*args_, **kwargs_)
        else:
            return Address(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_streetAddress(self): return self.streetAddress
    def set_streetAddress(self, streetAddress): self.streetAddress = streetAddress
    def get_city(self): return self.city
    def set_city(self, city): self.city = city
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def get_country(self): return self.country
    def set_country(self, country): self.country = country
    def get_postalCode(self): return self.postalCode
    def set_postalCode(self, postalCode): self.postalCode = postalCode
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.streetAddress is not None or
            self.city is not None or
            self.state is not None or
            self.country is not None or
            self.postalCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Address', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Address')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Address', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Address'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Address', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.streetAddress is not None:
            self.streetAddress.export(outfile, level, namespace_, name_='streetAddress', pretty_print=pretty_print)
        if self.city is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scity>%s</%scity>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.city), input_name='city')), namespace_, eol_))
        if self.state is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstate>%s</%sstate>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.state), input_name='state')), namespace_, eol_))
        if self.country is not None:
            self.country.export(outfile, level, namespace_, name_='country', pretty_print=pretty_print)
        if self.postalCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spostalCode>%s</%spostalCode>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.postalCode), input_name='postalCode')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'streetAddress':
            obj_ = StreetAddress.factory()
            obj_.build(child_)
            self.streetAddress = obj_
            obj_.original_tagname_ = 'streetAddress'
        elif nodeName_ == 'city':
            city_ = child_.text
            city_ = self.gds_validate_string(city_, node, 'city')
            self.city = city_
            # validate type String
            self.validate_String(self.city)
        elif nodeName_ == 'state':
            state_ = child_.text
            state_ = self.gds_validate_string(state_, node, 'state')
            self.state = state_
            # validate type String
            self.validate_String(self.state)
        elif nodeName_ == 'country':
            obj_ = CountryCode.factory()
            obj_.build(child_)
            self.country = obj_
            obj_.original_tagname_ = 'country'
        elif nodeName_ == 'postalCode':
            postalCode_ = child_.text
            postalCode_ = self.gds_validate_string(postalCode_, node, 'postalCode')
            self.postalCode = postalCode_
            # validate type String
            self.validate_String(self.postalCode)
# end class Address


class AdjustableDate(GeneratedsSuper):
    """A type for defining a date that shall be subject to adjustment if it
    would otherwise fall on a day that is not a business day in the
    specified business centers, together with the convention for
    adjusting the date."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'unadjustedDate': MemberSpec_('unadjustedDate', 'IdentifiedDate', 0),
        'dateAdjustments': MemberSpec_('dateAdjustments', 'BusinessDayAdjustments', 0),
        'adjustedDate': MemberSpec_('adjustedDate', 'IdentifiedDate', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, unadjustedDate=None, dateAdjustments=None, adjustedDate=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.unadjustedDate = unadjustedDate
        self.dateAdjustments = dateAdjustments
        self.adjustedDate = adjustedDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdjustableDate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdjustableDate.subclass:
            return AdjustableDate.subclass(*args_, **kwargs_)
        else:
            return AdjustableDate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unadjustedDate(self): return self.unadjustedDate
    def set_unadjustedDate(self, unadjustedDate): self.unadjustedDate = unadjustedDate
    def get_dateAdjustments(self): return self.dateAdjustments
    def set_dateAdjustments(self, dateAdjustments): self.dateAdjustments = dateAdjustments
    def get_adjustedDate(self): return self.adjustedDate
    def set_adjustedDate(self, adjustedDate): self.adjustedDate = adjustedDate
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.unadjustedDate is not None or
            self.dateAdjustments is not None or
            self.adjustedDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AdjustableDate', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdjustableDate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AdjustableDate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AdjustableDate'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AdjustableDate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.unadjustedDate is not None:
            self.unadjustedDate.export(outfile, level, namespace_, name_='unadjustedDate', pretty_print=pretty_print)
        if self.dateAdjustments is not None:
            self.dateAdjustments.export(outfile, level, namespace_, name_='dateAdjustments', pretty_print=pretty_print)
        if self.adjustedDate is not None:
            self.adjustedDate.export(outfile, level, namespace_, name_='adjustedDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'unadjustedDate':
            obj_ = IdentifiedDate.factory()
            obj_.build(child_)
            self.unadjustedDate = obj_
            obj_.original_tagname_ = 'unadjustedDate'
        elif nodeName_ == 'dateAdjustments':
            obj_ = BusinessDayAdjustments.factory()
            obj_.build(child_)
            self.dateAdjustments = obj_
            obj_.original_tagname_ = 'dateAdjustments'
        elif nodeName_ == 'adjustedDate':
            obj_ = IdentifiedDate.factory()
            obj_.build(child_)
            self.adjustedDate = obj_
            obj_.original_tagname_ = 'adjustedDate'
# end class AdjustableDate


class AdjustableDate2(GeneratedsSuper):
    """A type that is different from AdjustableDate in two regards. First,
    date adjustments can be specified with either a dateAdjustments
    element or a reference to an existing dateAdjustments element.
    Second, it does not require the specification of date
    adjustments."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'unadjustedDate': MemberSpec_('unadjustedDate', 'IdentifiedDate', 0),
        'dateAdjustments': MemberSpec_('dateAdjustments', 'BusinessDayAdjustments', 0),
        'dateAdjustmentsReference': MemberSpec_('dateAdjustmentsReference', 'BusinessDayAdjustmentsReference', 0),
        'adjustedDate': MemberSpec_('adjustedDate', 'IdentifiedDate', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, unadjustedDate=None, dateAdjustments=None, dateAdjustmentsReference=None, adjustedDate=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.unadjustedDate = unadjustedDate
        self.dateAdjustments = dateAdjustments
        self.dateAdjustmentsReference = dateAdjustmentsReference
        self.adjustedDate = adjustedDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdjustableDate2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdjustableDate2.subclass:
            return AdjustableDate2.subclass(*args_, **kwargs_)
        else:
            return AdjustableDate2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unadjustedDate(self): return self.unadjustedDate
    def set_unadjustedDate(self, unadjustedDate): self.unadjustedDate = unadjustedDate
    def get_dateAdjustments(self): return self.dateAdjustments
    def set_dateAdjustments(self, dateAdjustments): self.dateAdjustments = dateAdjustments
    def get_dateAdjustmentsReference(self): return self.dateAdjustmentsReference
    def set_dateAdjustmentsReference(self, dateAdjustmentsReference): self.dateAdjustmentsReference = dateAdjustmentsReference
    def get_adjustedDate(self): return self.adjustedDate
    def set_adjustedDate(self, adjustedDate): self.adjustedDate = adjustedDate
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.unadjustedDate is not None or
            self.dateAdjustments is not None or
            self.dateAdjustmentsReference is not None or
            self.adjustedDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AdjustableDate2', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdjustableDate2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AdjustableDate2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AdjustableDate2'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AdjustableDate2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.unadjustedDate is not None:
            self.unadjustedDate.export(outfile, level, namespace_, name_='unadjustedDate', pretty_print=pretty_print)
        if self.dateAdjustments is not None:
            self.dateAdjustments.export(outfile, level, namespace_, name_='dateAdjustments', pretty_print=pretty_print)
        if self.dateAdjustmentsReference is not None:
            self.dateAdjustmentsReference.export(outfile, level, namespace_, name_='dateAdjustmentsReference', pretty_print=pretty_print)
        if self.adjustedDate is not None:
            self.adjustedDate.export(outfile, level, namespace_, name_='adjustedDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'unadjustedDate':
            obj_ = IdentifiedDate.factory()
            obj_.build(child_)
            self.unadjustedDate = obj_
            obj_.original_tagname_ = 'unadjustedDate'
        elif nodeName_ == 'dateAdjustments':
            obj_ = BusinessDayAdjustments.factory()
            obj_.build(child_)
            self.dateAdjustments = obj_
            obj_.original_tagname_ = 'dateAdjustments'
        elif nodeName_ == 'dateAdjustmentsReference':
            obj_ = BusinessDayAdjustmentsReference.factory()
            obj_.build(child_)
            self.dateAdjustmentsReference = obj_
            obj_.original_tagname_ = 'dateAdjustmentsReference'
        elif nodeName_ == 'adjustedDate':
            obj_ = IdentifiedDate.factory()
            obj_.build(child_)
            self.adjustedDate = obj_
            obj_.original_tagname_ = 'adjustedDate'
# end class AdjustableDate2


class AdjustableDates(GeneratedsSuper):
    """A type for defining a series of dates that shall be subject to
    adjustment if they would otherwise fall on a day that is not a
    business day in the specified business centers, together with
    the convention for adjusting the dates."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'unadjustedDate': MemberSpec_('unadjustedDate', 'IdentifiedDate', 1),
        'dateAdjustments': MemberSpec_('dateAdjustments', 'BusinessDayAdjustments', 0),
        'adjustedDate': MemberSpec_('adjustedDate', 'IdentifiedDate', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, unadjustedDate=None, dateAdjustments=None, adjustedDate=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if unadjustedDate is None:
            self.unadjustedDate = []
        else:
            self.unadjustedDate = unadjustedDate
        self.dateAdjustments = dateAdjustments
        if adjustedDate is None:
            self.adjustedDate = []
        else:
            self.adjustedDate = adjustedDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdjustableDates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdjustableDates.subclass:
            return AdjustableDates.subclass(*args_, **kwargs_)
        else:
            return AdjustableDates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unadjustedDate(self): return self.unadjustedDate
    def set_unadjustedDate(self, unadjustedDate): self.unadjustedDate = unadjustedDate
    def add_unadjustedDate(self, value): self.unadjustedDate.append(value)
    def insert_unadjustedDate_at(self, index, value): self.unadjustedDate.insert(index, value)
    def replace_unadjustedDate_at(self, index, value): self.unadjustedDate[index] = value
    def get_dateAdjustments(self): return self.dateAdjustments
    def set_dateAdjustments(self, dateAdjustments): self.dateAdjustments = dateAdjustments
    def get_adjustedDate(self): return self.adjustedDate
    def set_adjustedDate(self, adjustedDate): self.adjustedDate = adjustedDate
    def add_adjustedDate(self, value): self.adjustedDate.append(value)
    def insert_adjustedDate_at(self, index, value): self.adjustedDate.insert(index, value)
    def replace_adjustedDate_at(self, index, value): self.adjustedDate[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.unadjustedDate or
            self.dateAdjustments is not None or
            self.adjustedDate
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AdjustableDates', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdjustableDates')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AdjustableDates', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AdjustableDates'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AdjustableDates', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for unadjustedDate_ in self.unadjustedDate:
            unadjustedDate_.export(outfile, level, namespace_, name_='unadjustedDate', pretty_print=pretty_print)
        if self.dateAdjustments is not None:
            self.dateAdjustments.export(outfile, level, namespace_, name_='dateAdjustments', pretty_print=pretty_print)
        for adjustedDate_ in self.adjustedDate:
            adjustedDate_.export(outfile, level, namespace_, name_='adjustedDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'unadjustedDate':
            obj_ = IdentifiedDate.factory()
            obj_.build(child_)
            self.unadjustedDate.append(obj_)
            obj_.original_tagname_ = 'unadjustedDate'
        elif nodeName_ == 'dateAdjustments':
            obj_ = BusinessDayAdjustments.factory()
            obj_.build(child_)
            self.dateAdjustments = obj_
            obj_.original_tagname_ = 'dateAdjustments'
        elif nodeName_ == 'adjustedDate':
            obj_ = IdentifiedDate.factory()
            obj_.build(child_)
            self.adjustedDate.append(obj_)
            obj_.original_tagname_ = 'adjustedDate'
# end class AdjustableDates


class AdjustableDatesOrRelativeDateOffset(GeneratedsSuper):
    """A type for defining a series of dates, either as a list of
    adjustable dates, or a as a repeating sequence from a base date"""
    member_data_items_ = {
        'adjustableDates': MemberSpec_('adjustableDates', 'AdjustableDates', 0),
        'relativeDate': MemberSpec_('relativeDate', 'RelativeDateOffset', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, adjustableDates=None, relativeDate=None):
        self.original_tagname_ = None
        self.adjustableDates = adjustableDates
        self.relativeDate = relativeDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdjustableDatesOrRelativeDateOffset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdjustableDatesOrRelativeDateOffset.subclass:
            return AdjustableDatesOrRelativeDateOffset.subclass(*args_, **kwargs_)
        else:
            return AdjustableDatesOrRelativeDateOffset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_adjustableDates(self): return self.adjustableDates
    def set_adjustableDates(self, adjustableDates): self.adjustableDates = adjustableDates
    def get_relativeDate(self): return self.relativeDate
    def set_relativeDate(self, relativeDate): self.relativeDate = relativeDate
    def hasContent_(self):
        if (
            self.adjustableDates is not None or
            self.relativeDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AdjustableDatesOrRelativeDateOffset', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdjustableDatesOrRelativeDateOffset')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AdjustableDatesOrRelativeDateOffset', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AdjustableDatesOrRelativeDateOffset'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AdjustableDatesOrRelativeDateOffset', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.adjustableDates is not None:
            self.adjustableDates.export(outfile, level, namespace_, name_='adjustableDates', pretty_print=pretty_print)
        if self.relativeDate is not None:
            self.relativeDate.export(outfile, level, namespace_, name_='relativeDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'adjustableDates':
            obj_ = AdjustableDates.factory()
            obj_.build(child_)
            self.adjustableDates = obj_
            obj_.original_tagname_ = 'adjustableDates'
        elif nodeName_ == 'relativeDate':
            class_obj_ = self.get_class_obj_(child_, RelativeDateOffset)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.relativeDate = obj_
            obj_.original_tagname_ = 'relativeDate'
# end class AdjustableDatesOrRelativeDateOffset


class AdjustableOrAdjustedDate(GeneratedsSuper):
    """A type for defining a date that shall be subject to adjustment if it
    would otherwise fall on a day that is not a business day in the
    specified business centers, together with the convention for
    adjusting the date."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'unadjustedDate': MemberSpec_('unadjustedDate', 'IdentifiedDate', 0),
        'dateAdjustments': MemberSpec_('dateAdjustments', 'BusinessDayAdjustments', 0),
        'adjustedDate': MemberSpec_('adjustedDate', 'IdentifiedDate', 0),
        'adjustedDate': MemberSpec_('adjustedDate', 'IdentifiedDate', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, unadjustedDate=None, dateAdjustments=None, adjustedDate=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.unadjustedDate = unadjustedDate
        self.dateAdjustments = dateAdjustments
        self.adjustedDate = adjustedDate
        self.adjustedDate = adjustedDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdjustableOrAdjustedDate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdjustableOrAdjustedDate.subclass:
            return AdjustableOrAdjustedDate.subclass(*args_, **kwargs_)
        else:
            return AdjustableOrAdjustedDate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unadjustedDate(self): return self.unadjustedDate
    def set_unadjustedDate(self, unadjustedDate): self.unadjustedDate = unadjustedDate
    def get_dateAdjustments(self): return self.dateAdjustments
    def set_dateAdjustments(self, dateAdjustments): self.dateAdjustments = dateAdjustments
    def get_adjustedDate(self): return self.adjustedDate
    def set_adjustedDate(self, adjustedDate): self.adjustedDate = adjustedDate
    def get_adjustedDate(self): return self.adjustedDate
    def set_adjustedDate(self, adjustedDate): self.adjustedDate = adjustedDate
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.unadjustedDate is not None or
            self.dateAdjustments is not None or
            self.adjustedDate is not None or
            self.adjustedDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AdjustableOrAdjustedDate', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdjustableOrAdjustedDate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AdjustableOrAdjustedDate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AdjustableOrAdjustedDate'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AdjustableOrAdjustedDate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.unadjustedDate is not None:
            self.unadjustedDate.export(outfile, level, namespace_, name_='unadjustedDate', pretty_print=pretty_print)
        if self.dateAdjustments is not None:
            self.dateAdjustments.export(outfile, level, namespace_, name_='dateAdjustments', pretty_print=pretty_print)
        if self.adjustedDate is not None:
            self.adjustedDate.export(outfile, level, namespace_, name_='adjustedDate', pretty_print=pretty_print)
        if self.adjustedDate is not None:
            self.adjustedDate.export(outfile, level, namespace_, name_='adjustedDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'unadjustedDate':
            obj_ = IdentifiedDate.factory()
            obj_.build(child_)
            self.unadjustedDate = obj_
            obj_.original_tagname_ = 'unadjustedDate'
        elif nodeName_ == 'dateAdjustments':
            obj_ = BusinessDayAdjustments.factory()
            obj_.build(child_)
            self.dateAdjustments = obj_
            obj_.original_tagname_ = 'dateAdjustments'
        elif nodeName_ == 'adjustedDate':
            obj_ = IdentifiedDate.factory()
            obj_.build(child_)
            self.adjustedDate = obj_
            obj_.original_tagname_ = 'adjustedDate'
        elif nodeName_ == 'adjustedDate':
            obj_ = IdentifiedDate.factory()
            obj_.build(child_)
            self.adjustedDate = obj_
            obj_.original_tagname_ = 'adjustedDate'
# end class AdjustableOrAdjustedDate


class AdjustableOrRelativeDate(GeneratedsSuper):
    """A type giving the choice between defining a date as an explicit date
    together with applicable adjustments or as relative to some
    other (anchor) date."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'adjustableDate': MemberSpec_('adjustableDate', 'AdjustableDate', 0),
        'relativeDate': MemberSpec_('relativeDate', 'RelativeDateOffset', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, adjustableDate=None, relativeDate=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.adjustableDate = adjustableDate
        self.relativeDate = relativeDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdjustableOrRelativeDate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdjustableOrRelativeDate.subclass:
            return AdjustableOrRelativeDate.subclass(*args_, **kwargs_)
        else:
            return AdjustableOrRelativeDate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_adjustableDate(self): return self.adjustableDate
    def set_adjustableDate(self, adjustableDate): self.adjustableDate = adjustableDate
    def get_relativeDate(self): return self.relativeDate
    def set_relativeDate(self, relativeDate): self.relativeDate = relativeDate
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.adjustableDate is not None or
            self.relativeDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AdjustableOrRelativeDate', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdjustableOrRelativeDate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AdjustableOrRelativeDate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AdjustableOrRelativeDate'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AdjustableOrRelativeDate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.adjustableDate is not None:
            self.adjustableDate.export(outfile, level, namespace_, name_='adjustableDate', pretty_print=pretty_print)
        if self.relativeDate is not None:
            self.relativeDate.export(outfile, level, namespace_, name_='relativeDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'adjustableDate':
            obj_ = AdjustableDate.factory()
            obj_.build(child_)
            self.adjustableDate = obj_
            obj_.original_tagname_ = 'adjustableDate'
        elif nodeName_ == 'relativeDate':
            class_obj_ = self.get_class_obj_(child_, RelativeDateOffset)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.relativeDate = obj_
            obj_.original_tagname_ = 'relativeDate'
# end class AdjustableOrRelativeDate


class AdjustableOrRelativeDates(GeneratedsSuper):
    """A type giving the choice between defining a series of dates as an
    explicit list of dates together with applicable adjustments or
    as relative to some other series of (anchor) dates."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'adjustableDates': MemberSpec_('adjustableDates', 'AdjustableDates', 0),
        'relativeDates': MemberSpec_('relativeDates', 'RelativeDates', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, adjustableDates=None, relativeDates=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.adjustableDates = adjustableDates
        self.relativeDates = relativeDates
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdjustableOrRelativeDates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdjustableOrRelativeDates.subclass:
            return AdjustableOrRelativeDates.subclass(*args_, **kwargs_)
        else:
            return AdjustableOrRelativeDates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_adjustableDates(self): return self.adjustableDates
    def set_adjustableDates(self, adjustableDates): self.adjustableDates = adjustableDates
    def get_relativeDates(self): return self.relativeDates
    def set_relativeDates(self, relativeDates): self.relativeDates = relativeDates
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.adjustableDates is not None or
            self.relativeDates is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AdjustableOrRelativeDates', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdjustableOrRelativeDates')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AdjustableOrRelativeDates', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AdjustableOrRelativeDates'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AdjustableOrRelativeDates', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.adjustableDates is not None:
            self.adjustableDates.export(outfile, level, namespace_, name_='adjustableDates', pretty_print=pretty_print)
        if self.relativeDates is not None:
            self.relativeDates.export(outfile, level, namespace_, name_='relativeDates', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'adjustableDates':
            obj_ = AdjustableDates.factory()
            obj_.build(child_)
            self.adjustableDates = obj_
            obj_.original_tagname_ = 'adjustableDates'
        elif nodeName_ == 'relativeDates':
            obj_ = RelativeDates.factory()
            obj_.build(child_)
            self.relativeDates = obj_
            obj_.original_tagname_ = 'relativeDates'
# end class AdjustableOrRelativeDates


class AdjustableRelativeOrPeriodicDates(GeneratedsSuper):
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'adjustableDates': MemberSpec_('adjustableDates', 'AdjustableDates', 0),
        'relativeDates': MemberSpec_('relativeDates', 'RelativeDates', 0),
        'relativeDateSequence': MemberSpec_('relativeDateSequence', 'RelativeDateSequence', 0),
        'periodicDates': MemberSpec_('periodicDates', 'PeriodicDates', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, adjustableDates=None, relativeDates=None, relativeDateSequence=None, periodicDates=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.adjustableDates = adjustableDates
        self.relativeDates = relativeDates
        self.relativeDateSequence = relativeDateSequence
        self.periodicDates = periodicDates
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdjustableRelativeOrPeriodicDates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdjustableRelativeOrPeriodicDates.subclass:
            return AdjustableRelativeOrPeriodicDates.subclass(*args_, **kwargs_)
        else:
            return AdjustableRelativeOrPeriodicDates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_adjustableDates(self): return self.adjustableDates
    def set_adjustableDates(self, adjustableDates): self.adjustableDates = adjustableDates
    def get_relativeDates(self): return self.relativeDates
    def set_relativeDates(self, relativeDates): self.relativeDates = relativeDates
    def get_relativeDateSequence(self): return self.relativeDateSequence
    def set_relativeDateSequence(self, relativeDateSequence): self.relativeDateSequence = relativeDateSequence
    def get_periodicDates(self): return self.periodicDates
    def set_periodicDates(self, periodicDates): self.periodicDates = periodicDates
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.adjustableDates is not None or
            self.relativeDates is not None or
            self.relativeDateSequence is not None or
            self.periodicDates is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AdjustableRelativeOrPeriodicDates', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdjustableRelativeOrPeriodicDates')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AdjustableRelativeOrPeriodicDates', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AdjustableRelativeOrPeriodicDates'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AdjustableRelativeOrPeriodicDates', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.adjustableDates is not None:
            self.adjustableDates.export(outfile, level, namespace_, name_='adjustableDates', pretty_print=pretty_print)
        if self.relativeDates is not None:
            self.relativeDates.export(outfile, level, namespace_, name_='relativeDates', pretty_print=pretty_print)
        if self.relativeDateSequence is not None:
            self.relativeDateSequence.export(outfile, level, namespace_, name_='relativeDateSequence', pretty_print=pretty_print)
        if self.periodicDates is not None:
            self.periodicDates.export(outfile, level, namespace_, name_='periodicDates', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'adjustableDates':
            obj_ = AdjustableDates.factory()
            obj_.build(child_)
            self.adjustableDates = obj_
            obj_.original_tagname_ = 'adjustableDates'
        elif nodeName_ == 'relativeDates':
            obj_ = RelativeDates.factory()
            obj_.build(child_)
            self.relativeDates = obj_
            obj_.original_tagname_ = 'relativeDates'
        elif nodeName_ == 'relativeDateSequence':
            obj_ = RelativeDateSequence.factory()
            obj_.build(child_)
            self.relativeDateSequence = obj_
            obj_.original_tagname_ = 'relativeDateSequence'
        elif nodeName_ == 'periodicDates':
            obj_ = PeriodicDates.factory()
            obj_.build(child_)
            self.periodicDates = obj_
            obj_.original_tagname_ = 'periodicDates'
# end class AdjustableRelativeOrPeriodicDates


class AdjustableRelativeOrPeriodicDates2(GeneratedsSuper):
    """A type giving the choice between defining a series of dates as an
    explicit list of dates together with applicable adjustments, or
    as relative to some other series of (anchor) dates, or as a set
    of factors to specify periodic occurences."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'adjustableDates': MemberSpec_('adjustableDates', 'AdjustableDates', 0),
        'relativeDates': MemberSpec_('relativeDates', 'RelativeDates', 0),
        'periodicDates': MemberSpec_('periodicDates', 'PeriodicDates', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, adjustableDates=None, relativeDates=None, periodicDates=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.adjustableDates = adjustableDates
        self.relativeDates = relativeDates
        self.periodicDates = periodicDates
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdjustableRelativeOrPeriodicDates2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdjustableRelativeOrPeriodicDates2.subclass:
            return AdjustableRelativeOrPeriodicDates2.subclass(*args_, **kwargs_)
        else:
            return AdjustableRelativeOrPeriodicDates2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_adjustableDates(self): return self.adjustableDates
    def set_adjustableDates(self, adjustableDates): self.adjustableDates = adjustableDates
    def get_relativeDates(self): return self.relativeDates
    def set_relativeDates(self, relativeDates): self.relativeDates = relativeDates
    def get_periodicDates(self): return self.periodicDates
    def set_periodicDates(self, periodicDates): self.periodicDates = periodicDates
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.adjustableDates is not None or
            self.relativeDates is not None or
            self.periodicDates is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AdjustableRelativeOrPeriodicDates2', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdjustableRelativeOrPeriodicDates2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AdjustableRelativeOrPeriodicDates2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AdjustableRelativeOrPeriodicDates2'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AdjustableRelativeOrPeriodicDates2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.adjustableDates is not None:
            self.adjustableDates.export(outfile, level, namespace_, name_='adjustableDates', pretty_print=pretty_print)
        if self.relativeDates is not None:
            self.relativeDates.export(outfile, level, namespace_, name_='relativeDates', pretty_print=pretty_print)
        if self.periodicDates is not None:
            self.periodicDates.export(outfile, level, namespace_, name_='periodicDates', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'adjustableDates':
            obj_ = AdjustableDates.factory()
            obj_.build(child_)
            self.adjustableDates = obj_
            obj_.original_tagname_ = 'adjustableDates'
        elif nodeName_ == 'relativeDates':
            obj_ = RelativeDates.factory()
            obj_.build(child_)
            self.relativeDates = obj_
            obj_.original_tagname_ = 'relativeDates'
        elif nodeName_ == 'periodicDates':
            obj_ = PeriodicDates.factory()
            obj_.build(child_)
            self.periodicDates = obj_
            obj_.original_tagname_ = 'periodicDates'
# end class AdjustableRelativeOrPeriodicDates2


class AgreementType(GeneratedsSuper):
    member_data_items_ = {
        'agreementTypeScheme': MemberSpec_('agreementTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, agreementTypeScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.agreementTypeScheme = _cast(None, agreementTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AgreementType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AgreementType.subclass:
            return AgreementType.subclass(*args_, **kwargs_)
        else:
            return AgreementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_agreementTypeScheme(self): return self.agreementTypeScheme
    def set_agreementTypeScheme(self, agreementTypeScheme): self.agreementTypeScheme = agreementTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AgreementType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AgreementType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AgreementType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AgreementType'):
        if self.agreementTypeScheme is not None and 'agreementTypeScheme' not in already_processed:
            already_processed.add('agreementTypeScheme')
            outfile.write(' agreementTypeScheme=%s' % (quote_attrib(self.agreementTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AgreementType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('agreementTypeScheme', node)
        if value is not None and 'agreementTypeScheme' not in already_processed:
            already_processed.add('agreementTypeScheme')
            self.agreementTypeScheme = value
            self.validate_NonEmptyURI(self.agreementTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AgreementType


class AgreementVersion(GeneratedsSuper):
    member_data_items_ = {
        'agreementVersionScheme': MemberSpec_('agreementVersionScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, agreementVersionScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.agreementVersionScheme = _cast(None, agreementVersionScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AgreementVersion)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AgreementVersion.subclass:
            return AgreementVersion.subclass(*args_, **kwargs_)
        else:
            return AgreementVersion(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_agreementVersionScheme(self): return self.agreementVersionScheme
    def set_agreementVersionScheme(self, agreementVersionScheme): self.agreementVersionScheme = agreementVersionScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AgreementVersion', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AgreementVersion')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AgreementVersion', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AgreementVersion'):
        if self.agreementVersionScheme is not None and 'agreementVersionScheme' not in already_processed:
            already_processed.add('agreementVersionScheme')
            outfile.write(' agreementVersionScheme=%s' % (quote_attrib(self.agreementVersionScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AgreementVersion', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('agreementVersionScheme', node)
        if value is not None and 'agreementVersionScheme' not in already_processed:
            already_processed.add('agreementVersionScheme')
            self.agreementVersionScheme = value
            self.validate_NonEmptyURI(self.agreementVersionScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AgreementVersion


class AssetClass(GeneratedsSuper):
    member_data_items_ = {
        'assetClassScheme': MemberSpec_('assetClassScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, assetClassScheme='http://www.fpml.org/coding-scheme/asset-class', valueOf_=None):
        self.original_tagname_ = None
        self.assetClassScheme = _cast(None, assetClassScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AssetClass)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AssetClass.subclass:
            return AssetClass.subclass(*args_, **kwargs_)
        else:
            return AssetClass(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_assetClassScheme(self): return self.assetClassScheme
    def set_assetClassScheme(self, assetClassScheme): self.assetClassScheme = assetClassScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AssetClass', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AssetClass')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AssetClass', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AssetClass'):
        if self.assetClassScheme != "http://www.fpml.org/coding-scheme/asset-class" and 'assetClassScheme' not in already_processed:
            already_processed.add('assetClassScheme')
            outfile.write(' assetClassScheme=%s' % (quote_attrib(self.assetClassScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AssetClass', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('assetClassScheme', node)
        if value is not None and 'assetClassScheme' not in already_processed:
            already_processed.add('assetClassScheme')
            self.assetClassScheme = value
            self.validate_NonEmptyURI(self.assetClassScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AssetClass


class AutomaticExercise(GeneratedsSuper):
    """A type to define automatic exercise of a swaption. With automatic
    exercise the option is deemed to have exercised if it is in the
    money by more than the threshold amount on the exercise date."""
    member_data_items_ = {
        'thresholdRate': MemberSpec_('thresholdRate', 'xsd:decimal', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, thresholdRate=None):
        self.original_tagname_ = None
        self.thresholdRate = thresholdRate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AutomaticExercise)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AutomaticExercise.subclass:
            return AutomaticExercise.subclass(*args_, **kwargs_)
        else:
            return AutomaticExercise(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_thresholdRate(self): return self.thresholdRate
    def set_thresholdRate(self, thresholdRate): self.thresholdRate = thresholdRate
    def hasContent_(self):
        if (
            self.thresholdRate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AutomaticExercise', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AutomaticExercise')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AutomaticExercise', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AutomaticExercise'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AutomaticExercise', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.thresholdRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sthresholdRate>%s</%sthresholdRate>%s' % (namespace_, self.gds_format_float(self.thresholdRate, input_name='thresholdRate'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'thresholdRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'thresholdRate')
            self.thresholdRate = fval_
# end class AutomaticExercise


class AverageDailyTradingVolumeLimit(GeneratedsSuper):
    """To indicate the limitation percentage and limitation period."""
    member_data_items_ = {
        'limitationPercentage': MemberSpec_('limitationPercentage', ['RestrictedPercentage', 'xsd:decimal'], 0),
        'limitationPeriod': MemberSpec_('limitationPeriod', 'xsd:nonNegativeInteger', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, limitationPercentage=None, limitationPeriod=None):
        self.original_tagname_ = None
        self.limitationPercentage = limitationPercentage
        self.validate_RestrictedPercentage(self.limitationPercentage)
        self.limitationPeriod = limitationPeriod
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AverageDailyTradingVolumeLimit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AverageDailyTradingVolumeLimit.subclass:
            return AverageDailyTradingVolumeLimit.subclass(*args_, **kwargs_)
        else:
            return AverageDailyTradingVolumeLimit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_limitationPercentage(self): return self.limitationPercentage
    def set_limitationPercentage(self, limitationPercentage): self.limitationPercentage = limitationPercentage
    def get_limitationPeriod(self): return self.limitationPeriod
    def set_limitationPeriod(self, limitationPeriod): self.limitationPeriod = limitationPeriod
    def validate_RestrictedPercentage(self, value):
        # Validate type RestrictedPercentage, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on RestrictedPercentage' % {"value" : value} )
            if value > 1:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on RestrictedPercentage' % {"value" : value} )
    def hasContent_(self):
        if (
            self.limitationPercentage is not None or
            self.limitationPeriod is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AverageDailyTradingVolumeLimit', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AverageDailyTradingVolumeLimit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AverageDailyTradingVolumeLimit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AverageDailyTradingVolumeLimit'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AverageDailyTradingVolumeLimit', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.limitationPercentage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slimitationPercentage>%s</%slimitationPercentage>%s' % (namespace_, self.gds_format_float(self.limitationPercentage, input_name='limitationPercentage'), namespace_, eol_))
        if self.limitationPeriod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slimitationPeriod>%s</%slimitationPeriod>%s' % (namespace_, self.gds_format_integer(self.limitationPeriod, input_name='limitationPeriod'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'limitationPercentage':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'limitationPercentage')
            self.limitationPercentage = fval_
            # validate type RestrictedPercentage
            self.validate_RestrictedPercentage(self.limitationPercentage)
        elif nodeName_ == 'limitationPeriod':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'limitationPeriod')
            self.limitationPeriod = ival_
# end class AverageDailyTradingVolumeLimit


class Beneficiary(GeneratedsSuper):
    """A type defining the beneficiary of the funds."""
    member_data_items_ = {
        'routingIds': MemberSpec_('routingIds', 'RoutingIds', 0),
        'routingExplicitDetails': MemberSpec_('routingExplicitDetails', 'RoutingExplicitDetails', 0),
        'routingIdsAndExplicitDetails': MemberSpec_('routingIdsAndExplicitDetails', 'RoutingIdsAndExplicitDetails', 0),
        'beneficiaryPartyReference': MemberSpec_('beneficiaryPartyReference', 'PartyReference', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, routingIds=None, routingExplicitDetails=None, routingIdsAndExplicitDetails=None, beneficiaryPartyReference=None):
        self.original_tagname_ = None
        self.routingIds = routingIds
        self.routingExplicitDetails = routingExplicitDetails
        self.routingIdsAndExplicitDetails = routingIdsAndExplicitDetails
        self.beneficiaryPartyReference = beneficiaryPartyReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Beneficiary)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Beneficiary.subclass:
            return Beneficiary.subclass(*args_, **kwargs_)
        else:
            return Beneficiary(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_routingIds(self): return self.routingIds
    def set_routingIds(self, routingIds): self.routingIds = routingIds
    def get_routingExplicitDetails(self): return self.routingExplicitDetails
    def set_routingExplicitDetails(self, routingExplicitDetails): self.routingExplicitDetails = routingExplicitDetails
    def get_routingIdsAndExplicitDetails(self): return self.routingIdsAndExplicitDetails
    def set_routingIdsAndExplicitDetails(self, routingIdsAndExplicitDetails): self.routingIdsAndExplicitDetails = routingIdsAndExplicitDetails
    def get_beneficiaryPartyReference(self): return self.beneficiaryPartyReference
    def set_beneficiaryPartyReference(self, beneficiaryPartyReference): self.beneficiaryPartyReference = beneficiaryPartyReference
    def hasContent_(self):
        if (
            self.routingIds is not None or
            self.routingExplicitDetails is not None or
            self.routingIdsAndExplicitDetails is not None or
            self.beneficiaryPartyReference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Beneficiary', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Beneficiary')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Beneficiary', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Beneficiary'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Beneficiary', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.routingIds is not None:
            self.routingIds.export(outfile, level, namespace_, name_='routingIds', pretty_print=pretty_print)
        if self.routingExplicitDetails is not None:
            self.routingExplicitDetails.export(outfile, level, namespace_, name_='routingExplicitDetails', pretty_print=pretty_print)
        if self.routingIdsAndExplicitDetails is not None:
            self.routingIdsAndExplicitDetails.export(outfile, level, namespace_, name_='routingIdsAndExplicitDetails', pretty_print=pretty_print)
        if self.beneficiaryPartyReference is not None:
            self.beneficiaryPartyReference.export(outfile, level, namespace_, name_='beneficiaryPartyReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'routingIds':
            obj_ = RoutingIds.factory()
            obj_.build(child_)
            self.routingIds = obj_
            obj_.original_tagname_ = 'routingIds'
        elif nodeName_ == 'routingExplicitDetails':
            obj_ = RoutingExplicitDetails.factory()
            obj_.build(child_)
            self.routingExplicitDetails = obj_
            obj_.original_tagname_ = 'routingExplicitDetails'
        elif nodeName_ == 'routingIdsAndExplicitDetails':
            obj_ = RoutingIdsAndExplicitDetails.factory()
            obj_.build(child_)
            self.routingIdsAndExplicitDetails = obj_
            obj_.original_tagname_ = 'routingIdsAndExplicitDetails'
        elif nodeName_ == 'beneficiaryPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.beneficiaryPartyReference = obj_
            obj_.original_tagname_ = 'beneficiaryPartyReference'
# end class Beneficiary


class BrokerConfirmation(GeneratedsSuper):
    """Identifies the market sector in which the trade has been arranged."""
    member_data_items_ = {
        'brokerConfirmationType': MemberSpec_('brokerConfirmationType', 'BrokerConfirmationType', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, brokerConfirmationType=None):
        self.original_tagname_ = None
        self.brokerConfirmationType = brokerConfirmationType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BrokerConfirmation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BrokerConfirmation.subclass:
            return BrokerConfirmation.subclass(*args_, **kwargs_)
        else:
            return BrokerConfirmation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_brokerConfirmationType(self): return self.brokerConfirmationType
    def set_brokerConfirmationType(self, brokerConfirmationType): self.brokerConfirmationType = brokerConfirmationType
    def hasContent_(self):
        if (
            self.brokerConfirmationType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BrokerConfirmation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BrokerConfirmation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BrokerConfirmation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BrokerConfirmation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BrokerConfirmation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.brokerConfirmationType is not None:
            self.brokerConfirmationType.export(outfile, level, namespace_, name_='brokerConfirmationType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'brokerConfirmationType':
            obj_ = BrokerConfirmationType.factory()
            obj_.build(child_)
            self.brokerConfirmationType = obj_
            obj_.original_tagname_ = 'brokerConfirmationType'
# end class BrokerConfirmation


class BrokerConfirmationType(GeneratedsSuper):
    """Identifies the market sector in which the trade has been arranged."""
    member_data_items_ = {
        'brokerConfirmationTypeScheme': MemberSpec_('brokerConfirmationTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, brokerConfirmationTypeScheme='http://www.fpml.org/coding-scheme/broker-confirmation-type', valueOf_=None):
        self.original_tagname_ = None
        self.brokerConfirmationTypeScheme = _cast(None, brokerConfirmationTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BrokerConfirmationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BrokerConfirmationType.subclass:
            return BrokerConfirmationType.subclass(*args_, **kwargs_)
        else:
            return BrokerConfirmationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_brokerConfirmationTypeScheme(self): return self.brokerConfirmationTypeScheme
    def set_brokerConfirmationTypeScheme(self, brokerConfirmationTypeScheme): self.brokerConfirmationTypeScheme = brokerConfirmationTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BrokerConfirmationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BrokerConfirmationType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BrokerConfirmationType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BrokerConfirmationType'):
        if self.brokerConfirmationTypeScheme != "http://www.fpml.org/coding-scheme/broker-confirmation-type" and 'brokerConfirmationTypeScheme' not in already_processed:
            already_processed.add('brokerConfirmationTypeScheme')
            outfile.write(' brokerConfirmationTypeScheme=%s' % (quote_attrib(self.brokerConfirmationTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BrokerConfirmationType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('brokerConfirmationTypeScheme', node)
        if value is not None and 'brokerConfirmationTypeScheme' not in already_processed:
            already_processed.add('brokerConfirmationTypeScheme')
            self.brokerConfirmationTypeScheme = value
            self.validate_NonEmptyURI(self.brokerConfirmationTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BrokerConfirmationType


class BusinessCenter(GeneratedsSuper):
    """A code identifying a business day calendar location. A business day
    calendar location is drawn from the list identified by the
    business day calendar location scheme."""
    member_data_items_ = {
        'businessCenterScheme': MemberSpec_('businessCenterScheme', 'NonEmptyURI', 0),
        'id': MemberSpec_('id', 'xsd:string', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, businessCenterScheme='http://www.fpml.org/coding-scheme/business-center', id=None, valueOf_=None):
        self.original_tagname_ = None
        self.businessCenterScheme = _cast(None, businessCenterScheme)
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BusinessCenter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BusinessCenter.subclass:
            return BusinessCenter.subclass(*args_, **kwargs_)
        else:
            return BusinessCenter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_businessCenterScheme(self): return self.businessCenterScheme
    def set_businessCenterScheme(self, businessCenterScheme): self.businessCenterScheme = businessCenterScheme
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BusinessCenter', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BusinessCenter')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BusinessCenter', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BusinessCenter'):
        if self.businessCenterScheme != "http://www.fpml.org/coding-scheme/business-center" and 'businessCenterScheme' not in already_processed:
            already_processed.add('businessCenterScheme')
            outfile.write(' businessCenterScheme=%s' % (quote_attrib(self.businessCenterScheme), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BusinessCenter', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('businessCenterScheme', node)
        if value is not None and 'businessCenterScheme' not in already_processed:
            already_processed.add('businessCenterScheme')
            self.businessCenterScheme = value
            self.validate_NonEmptyURI(self.businessCenterScheme)    # validate type NonEmptyURI
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BusinessCenter


class BusinessCenters(GeneratedsSuper):
    """A type for defining business day calendar used in determining
    whether a day is a business day or not. A list of business day
    calendar locations may be ordered in the document alphabetically
    based on business day calendar location code. An FpML document
    containing an unordered business day calendar location list is
    still regarded as a conformant document."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'businessCenter': MemberSpec_('businessCenter', 'BusinessCenter', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, businessCenter=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if businessCenter is None:
            self.businessCenter = []
        else:
            self.businessCenter = businessCenter
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BusinessCenters)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BusinessCenters.subclass:
            return BusinessCenters.subclass(*args_, **kwargs_)
        else:
            return BusinessCenters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_businessCenter(self): return self.businessCenter
    def set_businessCenter(self, businessCenter): self.businessCenter = businessCenter
    def add_businessCenter(self, value): self.businessCenter.append(value)
    def insert_businessCenter_at(self, index, value): self.businessCenter.insert(index, value)
    def replace_businessCenter_at(self, index, value): self.businessCenter[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.businessCenter
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BusinessCenters', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BusinessCenters')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BusinessCenters', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BusinessCenters'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BusinessCenters', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for businessCenter_ in self.businessCenter:
            businessCenter_.export(outfile, level, namespace_, name_='businessCenter', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'businessCenter':
            obj_ = BusinessCenter.factory()
            obj_.build(child_)
            self.businessCenter.append(obj_)
            obj_.original_tagname_ = 'businessCenter'
# end class BusinessCenters


class BusinessCenterTime(GeneratedsSuper):
    """A type for defining a time with respect to a business day calendar
    location. For example, 11:00am London time."""
    member_data_items_ = {
        'hourMinuteTime': MemberSpec_('hourMinuteTime', ['HourMinuteTime', 'xsd:time'], 0),
        'businessCenter': MemberSpec_('businessCenter', 'BusinessCenter', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, hourMinuteTime=None, businessCenter=None):
        self.original_tagname_ = None
        if isinstance(hourMinuteTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(hourMinuteTime, '%H:%M:%S').time()
        else:
            initvalue_ = hourMinuteTime
        self.hourMinuteTime = initvalue_
        self.businessCenter = businessCenter
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BusinessCenterTime)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BusinessCenterTime.subclass:
            return BusinessCenterTime.subclass(*args_, **kwargs_)
        else:
            return BusinessCenterTime(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_hourMinuteTime(self): return self.hourMinuteTime
    def set_hourMinuteTime(self, hourMinuteTime): self.hourMinuteTime = hourMinuteTime
    def get_businessCenter(self): return self.businessCenter
    def set_businessCenter(self, businessCenter): self.businessCenter = businessCenter
    def validate_HourMinuteTime(self, value):
        # Validate type HourMinuteTime, a restriction on xsd:time.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_HourMinuteTime_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_HourMinuteTime_patterns_, ))
    validate_HourMinuteTime_patterns_ = [['^[0-2][0-9]:[0-5][0-9]:00$']]
    def hasContent_(self):
        if (
            self.hourMinuteTime is not None or
            self.businessCenter is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BusinessCenterTime', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BusinessCenterTime')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BusinessCenterTime', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BusinessCenterTime'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BusinessCenterTime', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.hourMinuteTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shourMinuteTime>%s</%shourMinuteTime>%s' % (namespace_, self.gds_format_time(self.hourMinuteTime, input_name='hourMinuteTime'), namespace_, eol_))
        if self.businessCenter is not None:
            self.businessCenter.export(outfile, level, namespace_, name_='businessCenter', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'hourMinuteTime':
            sval_ = child_.text
            dval_ = self.gds_parse_time(sval_)
            self.hourMinuteTime = dval_
            # validate type HourMinuteTime
            self.validate_HourMinuteTime(self.hourMinuteTime)
        elif nodeName_ == 'businessCenter':
            obj_ = BusinessCenter.factory()
            obj_.build(child_)
            self.businessCenter = obj_
            obj_.original_tagname_ = 'businessCenter'
# end class BusinessCenterTime


class BusinessDayAdjustments(GeneratedsSuper):
    """A type defining the business day convention and financial business
    centers used for adjusting any relevant date if it would
    otherwise fall on a day that is not a business day in the
    specified business centers."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'businessDayConvention': MemberSpec_('businessDayConvention', ['BusinessDayConventionEnum', 'Token', 'xsd:token'], 0),
        'businessCentersReference': MemberSpec_('businessCentersReference', 'BusinessCentersReference', 0),
        'businessCenters': MemberSpec_('businessCenters', 'BusinessCenters', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, businessDayConvention=None, businessCentersReference=None, businessCenters=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.businessDayConvention = businessDayConvention
        self.validate_BusinessDayConventionEnum(self.businessDayConvention)
        self.businessCentersReference = businessCentersReference
        self.businessCenters = businessCenters
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BusinessDayAdjustments)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BusinessDayAdjustments.subclass:
            return BusinessDayAdjustments.subclass(*args_, **kwargs_)
        else:
            return BusinessDayAdjustments(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_businessDayConvention(self): return self.businessDayConvention
    def set_businessDayConvention(self, businessDayConvention): self.businessDayConvention = businessDayConvention
    def get_businessCentersReference(self): return self.businessCentersReference
    def set_businessCentersReference(self, businessCentersReference): self.businessCentersReference = businessCentersReference
    def get_businessCenters(self): return self.businessCenters
    def set_businessCenters(self, businessCenters): self.businessCenters = businessCenters
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_BusinessDayConventionEnum(self, value):
        # Validate type BusinessDayConventionEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FOLLOWING', 'FRN', 'MODFOLLOWING', 'PRECEDING', 'MODPRECEDING', 'NEAREST', 'NONE', 'NotApplicable']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on BusinessDayConventionEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on BusinessDayConventionEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.businessDayConvention is not None or
            self.businessCentersReference is not None or
            self.businessCenters is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BusinessDayAdjustments', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BusinessDayAdjustments')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BusinessDayAdjustments', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BusinessDayAdjustments'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BusinessDayAdjustments', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.businessDayConvention is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbusinessDayConvention>%s</%sbusinessDayConvention>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.businessDayConvention), input_name='businessDayConvention')), namespace_, eol_))
        if self.businessCentersReference is not None:
            self.businessCentersReference.export(outfile, level, namespace_, name_='businessCentersReference', pretty_print=pretty_print)
        if self.businessCenters is not None:
            self.businessCenters.export(outfile, level, namespace_, name_='businessCenters', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'businessDayConvention':
            businessDayConvention_ = child_.text
            businessDayConvention_ = re_.sub(String_cleanup_pat_, " ", businessDayConvention_).strip()
            businessDayConvention_ = self.gds_validate_string(businessDayConvention_, node, 'businessDayConvention')
            self.businessDayConvention = businessDayConvention_
            # validate type BusinessDayConventionEnum
            self.validate_BusinessDayConventionEnum(self.businessDayConvention)
        elif nodeName_ == 'businessCentersReference':
            obj_ = BusinessCentersReference.factory()
            obj_.build(child_)
            self.businessCentersReference = obj_
            obj_.original_tagname_ = 'businessCentersReference'
        elif nodeName_ == 'businessCenters':
            obj_ = BusinessCenters.factory()
            obj_.build(child_)
            self.businessCenters = obj_
            obj_.original_tagname_ = 'businessCenters'
# end class BusinessDayAdjustments


class BusinessUnit(GeneratedsSuper):
    """A type that represents information about a unit within an
    organization."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'name': MemberSpec_('name', ['String', 'xsd:string'], 0),
        'businessUnitId': MemberSpec_('businessUnitId', 'Unit', 0),
        'contactInfo': MemberSpec_('contactInfo', 'ContactInformation', 0),
        'country': MemberSpec_('country', 'CountryCode', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, businessUnitId=None, contactInfo=None, country=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.name = name
        self.validate_String(self.name)
        self.businessUnitId = businessUnitId
        self.contactInfo = contactInfo
        self.country = country
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BusinessUnit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BusinessUnit.subclass:
            return BusinessUnit.subclass(*args_, **kwargs_)
        else:
            return BusinessUnit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_businessUnitId(self): return self.businessUnitId
    def set_businessUnitId(self, businessUnitId): self.businessUnitId = businessUnitId
    def get_contactInfo(self): return self.contactInfo
    def set_contactInfo(self, contactInfo): self.contactInfo = contactInfo
    def get_country(self): return self.country
    def set_country(self, country): self.country = country
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.name is not None or
            self.businessUnitId is not None or
            self.contactInfo is not None or
            self.country is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BusinessUnit', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BusinessUnit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BusinessUnit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BusinessUnit'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BusinessUnit', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespace_, eol_))
        if self.businessUnitId is not None:
            self.businessUnitId.export(outfile, level, namespace_, name_='businessUnitId', pretty_print=pretty_print)
        if self.contactInfo is not None:
            self.contactInfo.export(outfile, level, namespace_, name_='contactInfo', pretty_print=pretty_print)
        if self.country is not None:
            self.country.export(outfile, level, namespace_, name_='country', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
            # validate type String
            self.validate_String(self.name)
        elif nodeName_ == 'businessUnitId':
            obj_ = Unit.factory()
            obj_.build(child_)
            self.businessUnitId = obj_
            obj_.original_tagname_ = 'businessUnitId'
        elif nodeName_ == 'contactInfo':
            obj_ = ContactInformation.factory()
            obj_.build(child_)
            self.contactInfo = obj_
            obj_.original_tagname_ = 'contactInfo'
        elif nodeName_ == 'country':
            obj_ = CountryCode.factory()
            obj_.build(child_)
            self.country = obj_
            obj_.original_tagname_ = 'country'
# end class BusinessUnit


class BusinessUnitRole(GeneratedsSuper):
    """A type describing a role played by a unit in one or more
    transactions. Examples include roles such as Trader, Collateral,
    Confirmation, Settlement, etc. This can be extended to provide
    custom roles."""
    member_data_items_ = {
        'unitRoleScheme': MemberSpec_('unitRoleScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, unitRoleScheme='http://www.fpml.org/coding-scheme/unit-role', valueOf_=None):
        self.original_tagname_ = None
        self.unitRoleScheme = _cast(None, unitRoleScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BusinessUnitRole)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BusinessUnitRole.subclass:
            return BusinessUnitRole.subclass(*args_, **kwargs_)
        else:
            return BusinessUnitRole(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unitRoleScheme(self): return self.unitRoleScheme
    def set_unitRoleScheme(self, unitRoleScheme): self.unitRoleScheme = unitRoleScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BusinessUnitRole', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BusinessUnitRole')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BusinessUnitRole', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BusinessUnitRole'):
        if self.unitRoleScheme != "http://www.fpml.org/coding-scheme/unit-role" and 'unitRoleScheme' not in already_processed:
            already_processed.add('unitRoleScheme')
            outfile.write(' unitRoleScheme=%s' % (quote_attrib(self.unitRoleScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BusinessUnitRole', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unitRoleScheme', node)
        if value is not None and 'unitRoleScheme' not in already_processed:
            already_processed.add('unitRoleScheme')
            self.unitRoleScheme = value
            self.validate_NonEmptyURI(self.unitRoleScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BusinessUnitRole


class CalculationAgent(GeneratedsSuper):
    """A type defining the ISDA calculation agent responsible for
    performing duties as defined in the applicable product
    definitions."""
    member_data_items_ = {
        'calculationAgentPartyReference': MemberSpec_('calculationAgentPartyReference', 'PartyReference', 1),
        'calculationAgentParty': MemberSpec_('calculationAgentParty', ['CalculationAgentPartyEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, calculationAgentPartyReference=None, calculationAgentParty=None):
        self.original_tagname_ = None
        if calculationAgentPartyReference is None:
            self.calculationAgentPartyReference = []
        else:
            self.calculationAgentPartyReference = calculationAgentPartyReference
        self.calculationAgentParty = calculationAgentParty
        self.validate_CalculationAgentPartyEnum(self.calculationAgentParty)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CalculationAgent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CalculationAgent.subclass:
            return CalculationAgent.subclass(*args_, **kwargs_)
        else:
            return CalculationAgent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_calculationAgentPartyReference(self): return self.calculationAgentPartyReference
    def set_calculationAgentPartyReference(self, calculationAgentPartyReference): self.calculationAgentPartyReference = calculationAgentPartyReference
    def add_calculationAgentPartyReference(self, value): self.calculationAgentPartyReference.append(value)
    def insert_calculationAgentPartyReference_at(self, index, value): self.calculationAgentPartyReference.insert(index, value)
    def replace_calculationAgentPartyReference_at(self, index, value): self.calculationAgentPartyReference[index] = value
    def get_calculationAgentParty(self): return self.calculationAgentParty
    def set_calculationAgentParty(self, calculationAgentParty): self.calculationAgentParty = calculationAgentParty
    def validate_CalculationAgentPartyEnum(self, value):
        # Validate type CalculationAgentPartyEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ExercisingParty', 'NonExercisingParty', 'AsSpecifiedInMasterAgreement', 'AsSpecifiedInStandardTermsSupplement', 'Both']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CalculationAgentPartyEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on CalculationAgentPartyEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.calculationAgentPartyReference or
            self.calculationAgentParty is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CalculationAgent', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CalculationAgent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CalculationAgent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CalculationAgent'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CalculationAgent', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for calculationAgentPartyReference_ in self.calculationAgentPartyReference:
            calculationAgentPartyReference_.export(outfile, level, namespace_, name_='calculationAgentPartyReference', pretty_print=pretty_print)
        if self.calculationAgentParty is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scalculationAgentParty>%s</%scalculationAgentParty>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.calculationAgentParty), input_name='calculationAgentParty')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'calculationAgentPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.calculationAgentPartyReference.append(obj_)
            obj_.original_tagname_ = 'calculationAgentPartyReference'
        elif nodeName_ == 'calculationAgentParty':
            calculationAgentParty_ = child_.text
            calculationAgentParty_ = re_.sub(String_cleanup_pat_, " ", calculationAgentParty_).strip()
            calculationAgentParty_ = self.gds_validate_string(calculationAgentParty_, node, 'calculationAgentParty')
            self.calculationAgentParty = calculationAgentParty_
            # validate type CalculationAgentPartyEnum
            self.validate_CalculationAgentPartyEnum(self.calculationAgentParty)
# end class CalculationAgent


class CashflowId(GeneratedsSuper):
    """An identifier used to identify a single component cashflow."""
    member_data_items_ = {
        'cashflowIdScheme': MemberSpec_('cashflowIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, cashflowIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.cashflowIdScheme = _cast(None, cashflowIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CashflowId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CashflowId.subclass:
            return CashflowId.subclass(*args_, **kwargs_)
        else:
            return CashflowId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cashflowIdScheme(self): return self.cashflowIdScheme
    def set_cashflowIdScheme(self, cashflowIdScheme): self.cashflowIdScheme = cashflowIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CashflowId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CashflowId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CashflowId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CashflowId'):
        if self.cashflowIdScheme is not None and 'cashflowIdScheme' not in already_processed:
            already_processed.add('cashflowIdScheme')
            outfile.write(' cashflowIdScheme=%s' % (quote_attrib(self.cashflowIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CashflowId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('cashflowIdScheme', node)
        if value is not None and 'cashflowIdScheme' not in already_processed:
            already_processed.add('cashflowIdScheme')
            self.cashflowIdScheme = value
            self.validate_NonEmptyURI(self.cashflowIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CashflowId


class CashflowNotional(GeneratedsSuper):
    """The notional/principal value/quantity/volume used to compute the
    cashflow."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'currency': MemberSpec_('currency', 'Currency', 0),
        'units': MemberSpec_('units', ['NormalizedString', 'xsd:normalizedString'], 0),
        'amount': MemberSpec_('amount', 'xsd:decimal', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, currency=None, units=None, amount=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.currency = currency
        self.units = units
        self.validate_NormalizedString(self.units)
        self.amount = amount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CashflowNotional)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CashflowNotional.subclass:
            return CashflowNotional.subclass(*args_, **kwargs_)
        else:
            return CashflowNotional(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_units(self): return self.units
    def set_units(self, units): self.units = units
    def get_amount(self): return self.amount
    def set_amount(self, amount): self.amount = amount
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_NormalizedString(self, value):
        # Validate type NormalizedString, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NormalizedString' % {"value" : value} )
    def hasContent_(self):
        if (
            self.currency is not None or
            self.units is not None or
            self.amount is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CashflowNotional', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CashflowNotional')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CashflowNotional', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CashflowNotional'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CashflowNotional', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.currency is not None:
            self.currency.export(outfile, level, namespace_, name_='currency', pretty_print=pretty_print)
        if self.units is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sunits>%s</%sunits>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.units), input_name='units')), namespace_, eol_))
        if self.amount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%samount>%s</%samount>%s' % (namespace_, self.gds_format_float(self.amount, input_name='amount'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'currency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'units':
            units_ = child_.text
            units_ = self.gds_validate_string(units_, node, 'units')
            self.units = units_
            # validate type NormalizedString
            self.validate_NormalizedString(self.units)
        elif nodeName_ == 'amount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'amount')
            self.amount = fval_
# end class CashflowNotional


class CashflowType(GeneratedsSuper):
    """A coding scheme used to describe the type or purpose of a cash flow
    or cash flow component."""
    member_data_items_ = {
        'cashflowTypeScheme': MemberSpec_('cashflowTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, cashflowTypeScheme='http://www.fpml.org/coding-scheme/cashflow-type', valueOf_=None):
        self.original_tagname_ = None
        self.cashflowTypeScheme = _cast(None, cashflowTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CashflowType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CashflowType.subclass:
            return CashflowType.subclass(*args_, **kwargs_)
        else:
            return CashflowType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cashflowTypeScheme(self): return self.cashflowTypeScheme
    def set_cashflowTypeScheme(self, cashflowTypeScheme): self.cashflowTypeScheme = cashflowTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CashflowType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CashflowType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CashflowType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CashflowType'):
        if self.cashflowTypeScheme != "http://www.fpml.org/coding-scheme/cashflow-type" and 'cashflowTypeScheme' not in already_processed:
            already_processed.add('cashflowTypeScheme')
            outfile.write(' cashflowTypeScheme=%s' % (quote_attrib(self.cashflowTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CashflowType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('cashflowTypeScheme', node)
        if value is not None and 'cashflowTypeScheme' not in already_processed:
            already_processed.add('cashflowTypeScheme')
            self.cashflowTypeScheme = value
            self.validate_NonEmptyURI(self.cashflowTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CashflowType


class CashSettlementReferenceBanks(GeneratedsSuper):
    """A type defining the list of reference institutions polled for
    relevant rates or prices when determining the cash settlement
    amount for a product where cash settlement is applicable."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'referenceBank': MemberSpec_('referenceBank', 'ReferenceBank', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, referenceBank=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if referenceBank is None:
            self.referenceBank = []
        else:
            self.referenceBank = referenceBank
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CashSettlementReferenceBanks)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CashSettlementReferenceBanks.subclass:
            return CashSettlementReferenceBanks.subclass(*args_, **kwargs_)
        else:
            return CashSettlementReferenceBanks(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_referenceBank(self): return self.referenceBank
    def set_referenceBank(self, referenceBank): self.referenceBank = referenceBank
    def add_referenceBank(self, value): self.referenceBank.append(value)
    def insert_referenceBank_at(self, index, value): self.referenceBank.insert(index, value)
    def replace_referenceBank_at(self, index, value): self.referenceBank[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.referenceBank
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CashSettlementReferenceBanks', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CashSettlementReferenceBanks')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CashSettlementReferenceBanks', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CashSettlementReferenceBanks'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CashSettlementReferenceBanks', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for referenceBank_ in self.referenceBank:
            referenceBank_.export(outfile, level, namespace_, name_='referenceBank', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'referenceBank':
            obj_ = ReferenceBank.factory()
            obj_.build(child_)
            self.referenceBank.append(obj_)
            obj_.original_tagname_ = 'referenceBank'
# end class CashSettlementReferenceBanks


class ClearanceSystem(GeneratedsSuper):
    """Unless otherwise specified, the principal clearance system
    customarily used for settling trades in the relevant underlying."""
    member_data_items_ = {
        'clearanceSystemScheme': MemberSpec_('clearanceSystemScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, clearanceSystemScheme='http://www.fpml.org/coding-scheme/clearance-system', valueOf_=None):
        self.original_tagname_ = None
        self.clearanceSystemScheme = _cast(None, clearanceSystemScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClearanceSystem)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClearanceSystem.subclass:
            return ClearanceSystem.subclass(*args_, **kwargs_)
        else:
            return ClearanceSystem(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_clearanceSystemScheme(self): return self.clearanceSystemScheme
    def set_clearanceSystemScheme(self, clearanceSystemScheme): self.clearanceSystemScheme = clearanceSystemScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ClearanceSystem', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ClearanceSystem')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ClearanceSystem', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ClearanceSystem'):
        if self.clearanceSystemScheme != "http://www.fpml.org/coding-scheme/clearance-system" and 'clearanceSystemScheme' not in already_processed:
            already_processed.add('clearanceSystemScheme')
            outfile.write(' clearanceSystemScheme=%s' % (quote_attrib(self.clearanceSystemScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ClearanceSystem', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('clearanceSystemScheme', node)
        if value is not None and 'clearanceSystemScheme' not in already_processed:
            already_processed.add('clearanceSystemScheme')
            self.clearanceSystemScheme = value
            self.validate_NonEmptyURI(self.clearanceSystemScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ClearanceSystem


class SwaptionPhysicalSettlement(GeneratedsSuper):
    member_data_items_ = {
        'clearedPhysicalSettlement': MemberSpec_('clearedPhysicalSettlement', 'xsd:boolean', 0),
        'predeterminedClearingOrganizationPartyReference': MemberSpec_('predeterminedClearingOrganizationPartyReference', 'PartyReference', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, clearedPhysicalSettlement=None, predeterminedClearingOrganizationPartyReference=None):
        self.original_tagname_ = None
        self.clearedPhysicalSettlement = clearedPhysicalSettlement
        self.predeterminedClearingOrganizationPartyReference = predeterminedClearingOrganizationPartyReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SwaptionPhysicalSettlement)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SwaptionPhysicalSettlement.subclass:
            return SwaptionPhysicalSettlement.subclass(*args_, **kwargs_)
        else:
            return SwaptionPhysicalSettlement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_clearedPhysicalSettlement(self): return self.clearedPhysicalSettlement
    def set_clearedPhysicalSettlement(self, clearedPhysicalSettlement): self.clearedPhysicalSettlement = clearedPhysicalSettlement
    def get_predeterminedClearingOrganizationPartyReference(self): return self.predeterminedClearingOrganizationPartyReference
    def set_predeterminedClearingOrganizationPartyReference(self, predeterminedClearingOrganizationPartyReference): self.predeterminedClearingOrganizationPartyReference = predeterminedClearingOrganizationPartyReference
    def hasContent_(self):
        if (
            self.clearedPhysicalSettlement is not None or
            self.predeterminedClearingOrganizationPartyReference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SwaptionPhysicalSettlement', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SwaptionPhysicalSettlement')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SwaptionPhysicalSettlement', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SwaptionPhysicalSettlement'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SwaptionPhysicalSettlement', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.clearedPhysicalSettlement is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sclearedPhysicalSettlement>%s</%sclearedPhysicalSettlement>%s' % (namespace_, self.gds_format_boolean(self.clearedPhysicalSettlement, input_name='clearedPhysicalSettlement'), namespace_, eol_))
        if self.predeterminedClearingOrganizationPartyReference is not None:
            self.predeterminedClearingOrganizationPartyReference.export(outfile, level, namespace_, name_='predeterminedClearingOrganizationPartyReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'clearedPhysicalSettlement':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'clearedPhysicalSettlement')
            self.clearedPhysicalSettlement = ival_
        elif nodeName_ == 'predeterminedClearingOrganizationPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.predeterminedClearingOrganizationPartyReference = obj_
            obj_.original_tagname_ = 'predeterminedClearingOrganizationPartyReference'
# end class SwaptionPhysicalSettlement


class Collateral(GeneratedsSuper):
    """A type for defining the obligations of the counterparty subject to
    credit support requirements."""
    member_data_items_ = {
        'independentAmount': MemberSpec_('independentAmount', 'IndependentAmount', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, independentAmount=None):
        self.original_tagname_ = None
        self.independentAmount = independentAmount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Collateral)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Collateral.subclass:
            return Collateral.subclass(*args_, **kwargs_)
        else:
            return Collateral(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_independentAmount(self): return self.independentAmount
    def set_independentAmount(self, independentAmount): self.independentAmount = independentAmount
    def hasContent_(self):
        if (
            self.independentAmount is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Collateral', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Collateral')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Collateral', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Collateral'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Collateral', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.independentAmount is not None:
            self.independentAmount.export(outfile, level, namespace_, name_='independentAmount', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'independentAmount':
            obj_ = IndependentAmount.factory()
            obj_.build(child_)
            self.independentAmount = obj_
            obj_.original_tagname_ = 'independentAmount'
# end class Collateral


class CollateralValueAllocation(GeneratedsSuper):
    member_data_items_ = {
        'type_': MemberSpec_('type_', ['CollateralValueAllocationEnum', 'Token', 'xsd:token'], 0),
        'value': MemberSpec_('value', 'Money', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, type_=None, value=None):
        self.original_tagname_ = None
        self.type_ = type_
        self.validate_CollateralValueAllocationEnum(self.type_)
        if value is None:
            self.value = []
        else:
            self.value = value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CollateralValueAllocation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CollateralValueAllocation.subclass:
            return CollateralValueAllocation.subclass(*args_, **kwargs_)
        else:
            return CollateralValueAllocation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value_at(self, index, value): self.value.insert(index, value)
    def replace_value_at(self, index, value): self.value[index] = value
    def validate_CollateralValueAllocationEnum(self, value):
        # Validate type CollateralValueAllocationEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Buffer', 'Full', 'ExcessOverMargin', 'Margin']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CollateralValueAllocationEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on CollateralValueAllocationEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.type_ is not None or
            self.value
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CollateralValueAllocation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CollateralValueAllocation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CollateralValueAllocation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CollateralValueAllocation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CollateralValueAllocation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stype>%s</%stype>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.type_), input_name='type')), namespace_, eol_))
        for value_ in self.value:
            value_.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            type_ = child_.text
            type_ = re_.sub(String_cleanup_pat_, " ", type_).strip()
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
            # validate type CollateralValueAllocationEnum
            self.validate_CollateralValueAllocationEnum(self.type_)
        elif nodeName_ == 'value':
            obj_ = Money.factory()
            obj_.build(child_)
            self.value.append(obj_)
            obj_.original_tagname_ = 'value'
# end class CollateralValueAllocation


class ContactInformation(GeneratedsSuper):
    """A type that represents how to contact an individual or organization."""
    member_data_items_ = {
        'telephone': MemberSpec_('telephone', 'TelephoneNumber', 1),
        'email': MemberSpec_('email', ['NormalizedString', 'xsd:normalizedString'], 1),
        'address': MemberSpec_('address', 'Address', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, telephone=None, email=None, address=None):
        self.original_tagname_ = None
        if telephone is None:
            self.telephone = []
        else:
            self.telephone = telephone
        if email is None:
            self.email = []
        else:
            self.email = email
        self.address = address
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContactInformation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContactInformation.subclass:
            return ContactInformation.subclass(*args_, **kwargs_)
        else:
            return ContactInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_telephone(self): return self.telephone
    def set_telephone(self, telephone): self.telephone = telephone
    def add_telephone(self, value): self.telephone.append(value)
    def insert_telephone_at(self, index, value): self.telephone.insert(index, value)
    def replace_telephone_at(self, index, value): self.telephone[index] = value
    def get_email(self): return self.email
    def set_email(self, email): self.email = email
    def add_email(self, value): self.email.append(value)
    def insert_email_at(self, index, value): self.email.insert(index, value)
    def replace_email_at(self, index, value): self.email[index] = value
    def get_address(self): return self.address
    def set_address(self, address): self.address = address
    def validate_NormalizedString(self, value):
        # Validate type NormalizedString, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NormalizedString' % {"value" : value} )
    def hasContent_(self):
        if (
            self.telephone or
            self.email or
            self.address is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ContactInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContactInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ContactInformation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContactInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ContactInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for telephone_ in self.telephone:
            telephone_.export(outfile, level, namespace_, name_='telephone', pretty_print=pretty_print)
        for email_ in self.email:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%semail>%s</%semail>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(email_), input_name='email')), namespace_, eol_))
        if self.address is not None:
            self.address.export(outfile, level, namespace_, name_='address', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'telephone':
            obj_ = TelephoneNumber.factory()
            obj_.build(child_)
            self.telephone.append(obj_)
            obj_.original_tagname_ = 'telephone'
        elif nodeName_ == 'email':
            email_ = child_.text
            email_ = self.gds_validate_string(email_, node, 'email')
            self.email.append(email_)
            # validate type NormalizedString
            self.validate_NormalizedString(self.email[-1])
        elif nodeName_ == 'address':
            obj_ = Address.factory()
            obj_.build(child_)
            self.address = obj_
            obj_.original_tagname_ = 'address'
# end class ContactInformation


class ContractualDefinitions(GeneratedsSuper):
    """The definitions, such as those published by ISDA, that will define
    the terms of the trade."""
    member_data_items_ = {
        'contractualDefinitionsScheme': MemberSpec_('contractualDefinitionsScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, contractualDefinitionsScheme='http://www.fpml.org/coding-scheme/contractual-definitions', valueOf_=None):
        self.original_tagname_ = None
        self.contractualDefinitionsScheme = _cast(None, contractualDefinitionsScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContractualDefinitions)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContractualDefinitions.subclass:
            return ContractualDefinitions.subclass(*args_, **kwargs_)
        else:
            return ContractualDefinitions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_contractualDefinitionsScheme(self): return self.contractualDefinitionsScheme
    def set_contractualDefinitionsScheme(self, contractualDefinitionsScheme): self.contractualDefinitionsScheme = contractualDefinitionsScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ContractualDefinitions', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContractualDefinitions')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ContractualDefinitions', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContractualDefinitions'):
        if self.contractualDefinitionsScheme != "http://www.fpml.org/coding-scheme/contractual-definitions" and 'contractualDefinitionsScheme' not in already_processed:
            already_processed.add('contractualDefinitionsScheme')
            outfile.write(' contractualDefinitionsScheme=%s' % (quote_attrib(self.contractualDefinitionsScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ContractualDefinitions', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('contractualDefinitionsScheme', node)
        if value is not None and 'contractualDefinitionsScheme' not in already_processed:
            already_processed.add('contractualDefinitionsScheme')
            self.contractualDefinitionsScheme = value
            self.validate_NonEmptyURI(self.contractualDefinitionsScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ContractualDefinitions


class ContractualMatrix(GeneratedsSuper):
    member_data_items_ = {
        'matrixType': MemberSpec_('matrixType', 'MatrixType', 0),
        'publicationDate': MemberSpec_('publicationDate', 'xsd:date', 0),
        'matrixTerm': MemberSpec_('matrixTerm', 'MatrixTerm', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, matrixType=None, publicationDate=None, matrixTerm=None):
        self.original_tagname_ = None
        self.matrixType = matrixType
        if isinstance(publicationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(publicationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = publicationDate
        self.publicationDate = initvalue_
        self.matrixTerm = matrixTerm
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContractualMatrix)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContractualMatrix.subclass:
            return ContractualMatrix.subclass(*args_, **kwargs_)
        else:
            return ContractualMatrix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_matrixType(self): return self.matrixType
    def set_matrixType(self, matrixType): self.matrixType = matrixType
    def get_publicationDate(self): return self.publicationDate
    def set_publicationDate(self, publicationDate): self.publicationDate = publicationDate
    def get_matrixTerm(self): return self.matrixTerm
    def set_matrixTerm(self, matrixTerm): self.matrixTerm = matrixTerm
    def hasContent_(self):
        if (
            self.matrixType is not None or
            self.publicationDate is not None or
            self.matrixTerm is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ContractualMatrix', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContractualMatrix')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ContractualMatrix', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContractualMatrix'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ContractualMatrix', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.matrixType is not None:
            self.matrixType.export(outfile, level, namespace_, name_='matrixType', pretty_print=pretty_print)
        if self.publicationDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spublicationDate>%s</%spublicationDate>%s' % (namespace_, self.gds_format_date(self.publicationDate, input_name='publicationDate'), namespace_, eol_))
        if self.matrixTerm is not None:
            self.matrixTerm.export(outfile, level, namespace_, name_='matrixTerm', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'matrixType':
            obj_ = MatrixType.factory()
            obj_.build(child_)
            self.matrixType = obj_
            obj_.original_tagname_ = 'matrixType'
        elif nodeName_ == 'publicationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.publicationDate = dval_
        elif nodeName_ == 'matrixTerm':
            obj_ = MatrixTerm.factory()
            obj_.build(child_)
            self.matrixTerm = obj_
            obj_.original_tagname_ = 'matrixTerm'
# end class ContractualMatrix


class ContractualSupplement(GeneratedsSuper):
    """A contractual supplement (such as those published by ISDA) that will
    apply to the trade."""
    member_data_items_ = {
        'contractualSupplementScheme': MemberSpec_('contractualSupplementScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, contractualSupplementScheme='http://www.fpml.org/coding-scheme/contractual-supplement', valueOf_=None):
        self.original_tagname_ = None
        self.contractualSupplementScheme = _cast(None, contractualSupplementScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContractualSupplement)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContractualSupplement.subclass:
            return ContractualSupplement.subclass(*args_, **kwargs_)
        else:
            return ContractualSupplement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_contractualSupplementScheme(self): return self.contractualSupplementScheme
    def set_contractualSupplementScheme(self, contractualSupplementScheme): self.contractualSupplementScheme = contractualSupplementScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ContractualSupplement', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContractualSupplement')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ContractualSupplement', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContractualSupplement'):
        if self.contractualSupplementScheme != "http://www.fpml.org/coding-scheme/contractual-supplement" and 'contractualSupplementScheme' not in already_processed:
            already_processed.add('contractualSupplementScheme')
            outfile.write(' contractualSupplementScheme=%s' % (quote_attrib(self.contractualSupplementScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ContractualSupplement', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('contractualSupplementScheme', node)
        if value is not None and 'contractualSupplementScheme' not in already_processed:
            already_processed.add('contractualSupplementScheme')
            self.contractualSupplementScheme = value
            self.validate_NonEmptyURI(self.contractualSupplementScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ContractualSupplement


class ContractualTermsSupplement(GeneratedsSuper):
    """A contractual supplement (such as those published by ISDA) and its
    publication date that will apply to the trade."""
    member_data_items_ = {
        'type_': MemberSpec_('type_', 'ContractualSupplement', 0),
        'publicationDate': MemberSpec_('publicationDate', 'xsd:date', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, type_=None, publicationDate=None):
        self.original_tagname_ = None
        self.type_ = type_
        if isinstance(publicationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(publicationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = publicationDate
        self.publicationDate = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContractualTermsSupplement)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContractualTermsSupplement.subclass:
            return ContractualTermsSupplement.subclass(*args_, **kwargs_)
        else:
            return ContractualTermsSupplement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_publicationDate(self): return self.publicationDate
    def set_publicationDate(self, publicationDate): self.publicationDate = publicationDate
    def hasContent_(self):
        if (
            self.type_ is not None or
            self.publicationDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ContractualTermsSupplement', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContractualTermsSupplement')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ContractualTermsSupplement', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContractualTermsSupplement'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ContractualTermsSupplement', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            self.type_.export(outfile, level, namespace_, name_='type', pretty_print=pretty_print)
        if self.publicationDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spublicationDate>%s</%spublicationDate>%s' % (namespace_, self.gds_format_date(self.publicationDate, input_name='publicationDate'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            obj_ = ContractualSupplement.factory()
            obj_.build(child_)
            self.type_ = obj_
            obj_.original_tagname_ = 'type'
        elif nodeName_ == 'publicationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.publicationDate = dval_
# end class ContractualTermsSupplement


class CorrespondentInformation(GeneratedsSuper):
    """A type that describes the information to identify a correspondent
    bank that will make delivery of the funds on the paying bank's
    behalf in the country where the payment is to be made."""
    member_data_items_ = {
        'routingIds': MemberSpec_('routingIds', 'RoutingIds', 0),
        'routingExplicitDetails': MemberSpec_('routingExplicitDetails', 'RoutingExplicitDetails', 0),
        'routingIdsAndExplicitDetails': MemberSpec_('routingIdsAndExplicitDetails', 'RoutingIdsAndExplicitDetails', 0),
        'correspondentPartyReference': MemberSpec_('correspondentPartyReference', 'PartyReference', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, routingIds=None, routingExplicitDetails=None, routingIdsAndExplicitDetails=None, correspondentPartyReference=None):
        self.original_tagname_ = None
        self.routingIds = routingIds
        self.routingExplicitDetails = routingExplicitDetails
        self.routingIdsAndExplicitDetails = routingIdsAndExplicitDetails
        self.correspondentPartyReference = correspondentPartyReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CorrespondentInformation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CorrespondentInformation.subclass:
            return CorrespondentInformation.subclass(*args_, **kwargs_)
        else:
            return CorrespondentInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_routingIds(self): return self.routingIds
    def set_routingIds(self, routingIds): self.routingIds = routingIds
    def get_routingExplicitDetails(self): return self.routingExplicitDetails
    def set_routingExplicitDetails(self, routingExplicitDetails): self.routingExplicitDetails = routingExplicitDetails
    def get_routingIdsAndExplicitDetails(self): return self.routingIdsAndExplicitDetails
    def set_routingIdsAndExplicitDetails(self, routingIdsAndExplicitDetails): self.routingIdsAndExplicitDetails = routingIdsAndExplicitDetails
    def get_correspondentPartyReference(self): return self.correspondentPartyReference
    def set_correspondentPartyReference(self, correspondentPartyReference): self.correspondentPartyReference = correspondentPartyReference
    def hasContent_(self):
        if (
            self.routingIds is not None or
            self.routingExplicitDetails is not None or
            self.routingIdsAndExplicitDetails is not None or
            self.correspondentPartyReference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CorrespondentInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CorrespondentInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CorrespondentInformation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CorrespondentInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CorrespondentInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.routingIds is not None:
            self.routingIds.export(outfile, level, namespace_, name_='routingIds', pretty_print=pretty_print)
        if self.routingExplicitDetails is not None:
            self.routingExplicitDetails.export(outfile, level, namespace_, name_='routingExplicitDetails', pretty_print=pretty_print)
        if self.routingIdsAndExplicitDetails is not None:
            self.routingIdsAndExplicitDetails.export(outfile, level, namespace_, name_='routingIdsAndExplicitDetails', pretty_print=pretty_print)
        if self.correspondentPartyReference is not None:
            self.correspondentPartyReference.export(outfile, level, namespace_, name_='correspondentPartyReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'routingIds':
            obj_ = RoutingIds.factory()
            obj_.build(child_)
            self.routingIds = obj_
            obj_.original_tagname_ = 'routingIds'
        elif nodeName_ == 'routingExplicitDetails':
            obj_ = RoutingExplicitDetails.factory()
            obj_.build(child_)
            self.routingExplicitDetails = obj_
            obj_.original_tagname_ = 'routingExplicitDetails'
        elif nodeName_ == 'routingIdsAndExplicitDetails':
            obj_ = RoutingIdsAndExplicitDetails.factory()
            obj_.build(child_)
            self.routingIdsAndExplicitDetails = obj_
            obj_.original_tagname_ = 'routingIdsAndExplicitDetails'
        elif nodeName_ == 'correspondentPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.correspondentPartyReference = obj_
            obj_.original_tagname_ = 'correspondentPartyReference'
# end class CorrespondentInformation


class CountryCode(GeneratedsSuper):
    """The code representation of a country or an area of special
    sovereignty. By default it is a valid 2 character country code
    as defined by the ISO standard 3166-1 alpha-2 - Codes for
    representation of countries
    http://www.niso.org/standards/resources/3166.html."""
    member_data_items_ = {
        'countryScheme': MemberSpec_('countryScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, countryScheme='http://www.fpml.org/coding-scheme/external/iso3166', valueOf_=None):
        self.original_tagname_ = None
        self.countryScheme = _cast(None, countryScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CountryCode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CountryCode.subclass:
            return CountryCode.subclass(*args_, **kwargs_)
        else:
            return CountryCode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_countryScheme(self): return self.countryScheme
    def set_countryScheme(self, countryScheme): self.countryScheme = countryScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CountryCode', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CountryCode')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CountryCode', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CountryCode'):
        if self.countryScheme != "http://www.fpml.org/coding-scheme/external/iso3166" and 'countryScheme' not in already_processed:
            already_processed.add('countryScheme')
            outfile.write(' countryScheme=%s' % (quote_attrib(self.countryScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CountryCode', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('countryScheme', node)
        if value is not None and 'countryScheme' not in already_processed:
            already_processed.add('countryScheme')
            self.countryScheme = value
            self.validate_NonEmptyURI(self.countryScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CountryCode


class CreditSeniority(GeneratedsSuper):
    """The repayment precedence of a debt
    instrument.creditSeniorityTradingScheme overrides
    creditSeniorityScheme when the underlyer defines the reference
    obligation used in a single name credit default swap trade."""
    member_data_items_ = {
        'creditSeniorityScheme': MemberSpec_('creditSeniorityScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, creditSeniorityScheme='http://www.fpml.org/coding-scheme/credit-seniority', valueOf_=None):
        self.original_tagname_ = None
        self.creditSeniorityScheme = _cast(None, creditSeniorityScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditSeniority)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditSeniority.subclass:
            return CreditSeniority.subclass(*args_, **kwargs_)
        else:
            return CreditSeniority(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_creditSeniorityScheme(self): return self.creditSeniorityScheme
    def set_creditSeniorityScheme(self, creditSeniorityScheme): self.creditSeniorityScheme = creditSeniorityScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditSeniority', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditSeniority')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditSeniority', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditSeniority'):
        if self.creditSeniorityScheme != "http://www.fpml.org/coding-scheme/credit-seniority" and 'creditSeniorityScheme' not in already_processed:
            already_processed.add('creditSeniorityScheme')
            outfile.write(' creditSeniorityScheme=%s' % (quote_attrib(self.creditSeniorityScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CreditSeniority', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('creditSeniorityScheme', node)
        if value is not None and 'creditSeniorityScheme' not in already_processed:
            already_processed.add('creditSeniorityScheme')
            self.creditSeniorityScheme = value
            self.validate_NonEmptyURI(self.creditSeniorityScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CreditSeniority


class CreditSupportAgreement(GeneratedsSuper):
    """The agreement executed between the parties and intended to govern
    collateral arrangement for all OTC derivatives transactions
    between those parties."""
    member_data_items_ = {
        'type_': MemberSpec_('type_', 'CreditSupportAgreementType', 0),
        'date': MemberSpec_('date', 'xsd:date', 0),
        'identifier': MemberSpec_('identifier', 'CreditSupportAgreementIdentifier', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, type_=None, date=None, identifier=None):
        self.original_tagname_ = None
        self.type_ = type_
        if isinstance(date, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(date, '%Y-%m-%d').date()
        else:
            initvalue_ = date
        self.date = initvalue_
        self.identifier = identifier
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditSupportAgreement)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditSupportAgreement.subclass:
            return CreditSupportAgreement.subclass(*args_, **kwargs_)
        else:
            return CreditSupportAgreement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_date(self): return self.date
    def set_date(self, date): self.date = date
    def get_identifier(self): return self.identifier
    def set_identifier(self, identifier): self.identifier = identifier
    def hasContent_(self):
        if (
            self.type_ is not None or
            self.date is not None or
            self.identifier is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditSupportAgreement', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditSupportAgreement')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditSupportAgreement', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditSupportAgreement'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CreditSupportAgreement', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            self.type_.export(outfile, level, namespace_, name_='type', pretty_print=pretty_print)
        if self.date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdate>%s</%sdate>%s' % (namespace_, self.gds_format_date(self.date, input_name='date'), namespace_, eol_))
        if self.identifier is not None:
            self.identifier.export(outfile, level, namespace_, name_='identifier', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            obj_ = CreditSupportAgreementType.factory()
            obj_.build(child_)
            self.type_ = obj_
            obj_.original_tagname_ = 'type'
        elif nodeName_ == 'date':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.date = dval_
        elif nodeName_ == 'identifier':
            obj_ = CreditSupportAgreementIdentifier.factory()
            obj_.build(child_)
            self.identifier = obj_
            obj_.original_tagname_ = 'identifier'
# end class CreditSupportAgreement


class CreditSupportAgreementIdentifier(GeneratedsSuper):
    member_data_items_ = {
        'creditSupportAgreementIdScheme': MemberSpec_('creditSupportAgreementIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, creditSupportAgreementIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.creditSupportAgreementIdScheme = _cast(None, creditSupportAgreementIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditSupportAgreementIdentifier)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditSupportAgreementIdentifier.subclass:
            return CreditSupportAgreementIdentifier.subclass(*args_, **kwargs_)
        else:
            return CreditSupportAgreementIdentifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_creditSupportAgreementIdScheme(self): return self.creditSupportAgreementIdScheme
    def set_creditSupportAgreementIdScheme(self, creditSupportAgreementIdScheme): self.creditSupportAgreementIdScheme = creditSupportAgreementIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditSupportAgreementIdentifier', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditSupportAgreementIdentifier')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditSupportAgreementIdentifier', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditSupportAgreementIdentifier'):
        if self.creditSupportAgreementIdScheme is not None and 'creditSupportAgreementIdScheme' not in already_processed:
            already_processed.add('creditSupportAgreementIdScheme')
            outfile.write(' creditSupportAgreementIdScheme=%s' % (quote_attrib(self.creditSupportAgreementIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CreditSupportAgreementIdentifier', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('creditSupportAgreementIdScheme', node)
        if value is not None and 'creditSupportAgreementIdScheme' not in already_processed:
            already_processed.add('creditSupportAgreementIdScheme')
            self.creditSupportAgreementIdScheme = value
            self.validate_NonEmptyURI(self.creditSupportAgreementIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CreditSupportAgreementIdentifier


class CreditSupportAgreementType(GeneratedsSuper):
    member_data_items_ = {
        'creditSupportAgreementTypeScheme': MemberSpec_('creditSupportAgreementTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, creditSupportAgreementTypeScheme='http://www.fpml.org/coding-scheme/credit-support-agreement-type', valueOf_=None):
        self.original_tagname_ = None
        self.creditSupportAgreementTypeScheme = _cast(None, creditSupportAgreementTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditSupportAgreementType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditSupportAgreementType.subclass:
            return CreditSupportAgreementType.subclass(*args_, **kwargs_)
        else:
            return CreditSupportAgreementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_creditSupportAgreementTypeScheme(self): return self.creditSupportAgreementTypeScheme
    def set_creditSupportAgreementTypeScheme(self, creditSupportAgreementTypeScheme): self.creditSupportAgreementTypeScheme = creditSupportAgreementTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditSupportAgreementType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditSupportAgreementType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditSupportAgreementType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditSupportAgreementType'):
        if self.creditSupportAgreementTypeScheme != "http://www.fpml.org/coding-scheme/credit-support-agreement-type" and 'creditSupportAgreementTypeScheme' not in already_processed:
            already_processed.add('creditSupportAgreementTypeScheme')
            outfile.write(' creditSupportAgreementTypeScheme=%s' % (quote_attrib(self.creditSupportAgreementTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CreditSupportAgreementType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('creditSupportAgreementTypeScheme', node)
        if value is not None and 'creditSupportAgreementTypeScheme' not in already_processed:
            already_processed.add('creditSupportAgreementTypeScheme')
            self.creditSupportAgreementTypeScheme = value
            self.validate_NonEmptyURI(self.creditSupportAgreementTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CreditSupportAgreementType


class CreditRating(GeneratedsSuper):
    """A party's credit rating."""
    member_data_items_ = {
        'creditRatingScheme': MemberSpec_('creditRatingScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, creditRatingScheme='http://www.fpml.org/coding-scheme/external/moodys', valueOf_=None):
        self.original_tagname_ = None
        self.creditRatingScheme = _cast(None, creditRatingScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditRating)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditRating.subclass:
            return CreditRating.subclass(*args_, **kwargs_)
        else:
            return CreditRating(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_creditRatingScheme(self): return self.creditRatingScheme
    def set_creditRatingScheme(self, creditRatingScheme): self.creditRatingScheme = creditRatingScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditRating', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditRating')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditRating', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditRating'):
        if self.creditRatingScheme != "http://www.fpml.org/coding-scheme/external/moodys" and 'creditRatingScheme' not in already_processed:
            already_processed.add('creditRatingScheme')
            outfile.write(' creditRatingScheme=%s' % (quote_attrib(self.creditRatingScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CreditRating', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('creditRatingScheme', node)
        if value is not None and 'creditRatingScheme' not in already_processed:
            already_processed.add('creditRatingScheme')
            self.creditRatingScheme = value
            self.validate_NonEmptyURI(self.creditRatingScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CreditRating


class Currency(GeneratedsSuper):
    """The code representation of a currency or fund. By default it is a
    valid currency code as defined by the ISO standard 4217 - Codes
    for representation of currencies and funds
    http://www.iso.org/iso/en/prods-
    services/popstds/currencycodeslist.html."""
    member_data_items_ = {
        'currencyScheme': MemberSpec_('currencyScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, currencyScheme='http://www.fpml.org/coding-scheme/external/iso4217-2001-08-15', valueOf_=None, extensiontype_=None):
        self.original_tagname_ = None
        self.currencyScheme = _cast(None, currencyScheme)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Currency)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Currency.subclass:
            return Currency.subclass(*args_, **kwargs_)
        else:
            return Currency(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_currencyScheme(self): return self.currencyScheme
    def set_currencyScheme(self, currencyScheme): self.currencyScheme = currencyScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Currency', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Currency')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Currency', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Currency'):
        if self.currencyScheme != "http://www.fpml.org/coding-scheme/external/iso4217-2001-08-15" and 'currencyScheme' not in already_processed:
            already_processed.add('currencyScheme')
            outfile.write(' currencyScheme=%s' % (quote_attrib(self.currencyScheme), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Currency', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('currencyScheme', node)
        if value is not None and 'currencyScheme' not in already_processed:
            already_processed.add('currencyScheme')
            self.currencyScheme = value
            self.validate_NonEmptyURI(self.currencyScheme)    # validate type NonEmptyURI
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Currency


class DateList(GeneratedsSuper):
    """List of Dates"""
    member_data_items_ = {
        'date': MemberSpec_('date', 'xsd:date', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, date=None):
        self.original_tagname_ = None
        if date is None:
            self.date = []
        else:
            self.date = date
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DateList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DateList.subclass:
            return DateList.subclass(*args_, **kwargs_)
        else:
            return DateList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_date(self): return self.date
    def set_date(self, date): self.date = date
    def add_date(self, value): self.date.append(value)
    def insert_date_at(self, index, value): self.date.insert(index, value)
    def replace_date_at(self, index, value): self.date[index] = value
    def hasContent_(self):
        if (
            self.date
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DateList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DateList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DateList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DateList'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DateList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for date_ in self.date:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdate>%s</%sdate>%s' % (namespace_, self.gds_format_date(date_, input_name='date'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'date':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.date.append(dval_)
# end class DateList


class DateRange(GeneratedsSuper):
    """A type defining a contiguous series of calendar dates. The date
    range is defined as all the dates between and including the
    first and the last date. The first date must fall before the
    last date."""
    member_data_items_ = {
        'unadjustedFirstDate': MemberSpec_('unadjustedFirstDate', 'xsd:date', 0),
        'unadjustedLastDate': MemberSpec_('unadjustedLastDate', 'xsd:date', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, unadjustedFirstDate=None, unadjustedLastDate=None, extensiontype_=None):
        self.original_tagname_ = None
        if isinstance(unadjustedFirstDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(unadjustedFirstDate, '%Y-%m-%d').date()
        else:
            initvalue_ = unadjustedFirstDate
        self.unadjustedFirstDate = initvalue_
        if isinstance(unadjustedLastDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(unadjustedLastDate, '%Y-%m-%d').date()
        else:
            initvalue_ = unadjustedLastDate
        self.unadjustedLastDate = initvalue_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DateRange)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DateRange.subclass:
            return DateRange.subclass(*args_, **kwargs_)
        else:
            return DateRange(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unadjustedFirstDate(self): return self.unadjustedFirstDate
    def set_unadjustedFirstDate(self, unadjustedFirstDate): self.unadjustedFirstDate = unadjustedFirstDate
    def get_unadjustedLastDate(self): return self.unadjustedLastDate
    def set_unadjustedLastDate(self, unadjustedLastDate): self.unadjustedLastDate = unadjustedLastDate
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.unadjustedFirstDate is not None or
            self.unadjustedLastDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DateRange', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DateRange')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DateRange', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DateRange'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DateRange', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.unadjustedFirstDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sunadjustedFirstDate>%s</%sunadjustedFirstDate>%s' % (namespace_, self.gds_format_date(self.unadjustedFirstDate, input_name='unadjustedFirstDate'), namespace_, eol_))
        if self.unadjustedLastDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sunadjustedLastDate>%s</%sunadjustedLastDate>%s' % (namespace_, self.gds_format_date(self.unadjustedLastDate, input_name='unadjustedLastDate'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'unadjustedFirstDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.unadjustedFirstDate = dval_
        elif nodeName_ == 'unadjustedLastDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.unadjustedLastDate = dval_
# end class DateRange


class DateTimeList(GeneratedsSuper):
    """List of DateTimes"""
    member_data_items_ = {
        'dateTime': MemberSpec_('dateTime', 'xsd:dateTime', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, dateTime=None):
        self.original_tagname_ = None
        if dateTime is None:
            self.dateTime = []
        else:
            self.dateTime = dateTime
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DateTimeList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DateTimeList.subclass:
            return DateTimeList.subclass(*args_, **kwargs_)
        else:
            return DateTimeList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dateTime(self): return self.dateTime
    def set_dateTime(self, dateTime): self.dateTime = dateTime
    def add_dateTime(self, value): self.dateTime.append(value)
    def insert_dateTime_at(self, index, value): self.dateTime.insert(index, value)
    def replace_dateTime_at(self, index, value): self.dateTime[index] = value
    def hasContent_(self):
        if (
            self.dateTime
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DateTimeList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DateTimeList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DateTimeList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DateTimeList'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DateTimeList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for dateTime_ in self.dateTime:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdateTime>%s</%sdateTime>%s' % (namespace_, self.gds_format_datetime(dateTime_, input_name='dateTime'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.dateTime.append(dval_)
# end class DateTimeList


class DayCountFraction(GeneratedsSuper):
    """The specification for how the number of days between two dates is
    calculated for purposes of calculation of a fixed or floating
    payment amount and the basis for how many days are assumed to be
    in a year. Day Count Fraction is an ISDA term. The equivalent
    AFB (Association Francaise de Banques) term is Calculation
    Basis."""
    member_data_items_ = {
        'dayCountFractionScheme': MemberSpec_('dayCountFractionScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, dayCountFractionScheme='http://www.fpml.org/coding-scheme/day-count-fraction', valueOf_=None):
        self.original_tagname_ = None
        self.dayCountFractionScheme = _cast(None, dayCountFractionScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DayCountFraction)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DayCountFraction.subclass:
            return DayCountFraction.subclass(*args_, **kwargs_)
        else:
            return DayCountFraction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dayCountFractionScheme(self): return self.dayCountFractionScheme
    def set_dayCountFractionScheme(self, dayCountFractionScheme): self.dayCountFractionScheme = dayCountFractionScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DayCountFraction', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DayCountFraction')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DayCountFraction', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DayCountFraction'):
        if self.dayCountFractionScheme != "http://www.fpml.org/coding-scheme/day-count-fraction" and 'dayCountFractionScheme' not in already_processed:
            already_processed.add('dayCountFractionScheme')
            outfile.write(' dayCountFractionScheme=%s' % (quote_attrib(self.dayCountFractionScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DayCountFraction', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dayCountFractionScheme', node)
        if value is not None and 'dayCountFractionScheme' not in already_processed:
            already_processed.add('dayCountFractionScheme')
            self.dayCountFractionScheme = value
            self.validate_NonEmptyURI(self.dayCountFractionScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DayCountFraction


class DeterminationMethod(GeneratedsSuper):
    """Coding scheme that specifies the method according to which an amount
    or a date is determined."""
    member_data_items_ = {
        'determinationMethodScheme': MemberSpec_('determinationMethodScheme', 'NonEmptyURI', 0),
        'id': MemberSpec_('id', 'xsd:string', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, determinationMethodScheme='http://www.fpml.org/coding-scheme/determination-method', id=None, valueOf_=None):
        self.original_tagname_ = None
        self.determinationMethodScheme = _cast(None, determinationMethodScheme)
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DeterminationMethod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DeterminationMethod.subclass:
            return DeterminationMethod.subclass(*args_, **kwargs_)
        else:
            return DeterminationMethod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_determinationMethodScheme(self): return self.determinationMethodScheme
    def set_determinationMethodScheme(self, determinationMethodScheme): self.determinationMethodScheme = determinationMethodScheme
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DeterminationMethod', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeterminationMethod')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DeterminationMethod', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DeterminationMethod'):
        if self.determinationMethodScheme != "http://www.fpml.org/coding-scheme/determination-method" and 'determinationMethodScheme' not in already_processed:
            already_processed.add('determinationMethodScheme')
            outfile.write(' determinationMethodScheme=%s' % (quote_attrib(self.determinationMethodScheme), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DeterminationMethod', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('determinationMethodScheme', node)
        if value is not None and 'determinationMethodScheme' not in already_processed:
            already_processed.add('determinationMethodScheme')
            self.determinationMethodScheme = value
            self.validate_NonEmptyURI(self.determinationMethodScheme)    # validate type NonEmptyURI
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DeterminationMethod


class Documentation(GeneratedsSuper):
    """An entity for defining the definitions that govern the document and
    should include the year and type of definitions referenced,
    along with any relevant documentation (such as master agreement)
    and the date it was signed."""
    member_data_items_ = {
        'masterAgreement': MemberSpec_('masterAgreement', 'MasterAgreement', 0),
        'masterConfirmation': MemberSpec_('masterConfirmation', 'MasterConfirmation', 0),
        'brokerConfirmation': MemberSpec_('brokerConfirmation', 'BrokerConfirmation', 0),
        'contractualDefinitions': MemberSpec_('contractualDefinitions', 'ContractualDefinitions', 1),
        'contractualTermsSupplement': MemberSpec_('contractualTermsSupplement', 'ContractualTermsSupplement', 1),
        'contractualMatrix': MemberSpec_('contractualMatrix', 'ContractualMatrix', 1),
        'creditSupportAgreement': MemberSpec_('creditSupportAgreement', 'CreditSupportAgreement', 0),
        'attachment': MemberSpec_('attachment', 'Resource', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, masterAgreement=None, masterConfirmation=None, brokerConfirmation=None, contractualDefinitions=None, contractualTermsSupplement=None, contractualMatrix=None, creditSupportAgreement=None, attachment=None):
        self.original_tagname_ = None
        self.masterAgreement = masterAgreement
        self.masterConfirmation = masterConfirmation
        self.brokerConfirmation = brokerConfirmation
        if contractualDefinitions is None:
            self.contractualDefinitions = []
        else:
            self.contractualDefinitions = contractualDefinitions
        if contractualTermsSupplement is None:
            self.contractualTermsSupplement = []
        else:
            self.contractualTermsSupplement = contractualTermsSupplement
        if contractualMatrix is None:
            self.contractualMatrix = []
        else:
            self.contractualMatrix = contractualMatrix
        self.creditSupportAgreement = creditSupportAgreement
        if attachment is None:
            self.attachment = []
        else:
            self.attachment = attachment
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Documentation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Documentation.subclass:
            return Documentation.subclass(*args_, **kwargs_)
        else:
            return Documentation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_masterAgreement(self): return self.masterAgreement
    def set_masterAgreement(self, masterAgreement): self.masterAgreement = masterAgreement
    def get_masterConfirmation(self): return self.masterConfirmation
    def set_masterConfirmation(self, masterConfirmation): self.masterConfirmation = masterConfirmation
    def get_brokerConfirmation(self): return self.brokerConfirmation
    def set_brokerConfirmation(self, brokerConfirmation): self.brokerConfirmation = brokerConfirmation
    def get_contractualDefinitions(self): return self.contractualDefinitions
    def set_contractualDefinitions(self, contractualDefinitions): self.contractualDefinitions = contractualDefinitions
    def add_contractualDefinitions(self, value): self.contractualDefinitions.append(value)
    def insert_contractualDefinitions_at(self, index, value): self.contractualDefinitions.insert(index, value)
    def replace_contractualDefinitions_at(self, index, value): self.contractualDefinitions[index] = value
    def get_contractualTermsSupplement(self): return self.contractualTermsSupplement
    def set_contractualTermsSupplement(self, contractualTermsSupplement): self.contractualTermsSupplement = contractualTermsSupplement
    def add_contractualTermsSupplement(self, value): self.contractualTermsSupplement.append(value)
    def insert_contractualTermsSupplement_at(self, index, value): self.contractualTermsSupplement.insert(index, value)
    def replace_contractualTermsSupplement_at(self, index, value): self.contractualTermsSupplement[index] = value
    def get_contractualMatrix(self): return self.contractualMatrix
    def set_contractualMatrix(self, contractualMatrix): self.contractualMatrix = contractualMatrix
    def add_contractualMatrix(self, value): self.contractualMatrix.append(value)
    def insert_contractualMatrix_at(self, index, value): self.contractualMatrix.insert(index, value)
    def replace_contractualMatrix_at(self, index, value): self.contractualMatrix[index] = value
    def get_creditSupportAgreement(self): return self.creditSupportAgreement
    def set_creditSupportAgreement(self, creditSupportAgreement): self.creditSupportAgreement = creditSupportAgreement
    def get_attachment(self): return self.attachment
    def set_attachment(self, attachment): self.attachment = attachment
    def add_attachment(self, value): self.attachment.append(value)
    def insert_attachment_at(self, index, value): self.attachment.insert(index, value)
    def replace_attachment_at(self, index, value): self.attachment[index] = value
    def hasContent_(self):
        if (
            self.masterAgreement is not None or
            self.masterConfirmation is not None or
            self.brokerConfirmation is not None or
            self.contractualDefinitions or
            self.contractualTermsSupplement or
            self.contractualMatrix or
            self.creditSupportAgreement is not None or
            self.attachment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Documentation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Documentation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Documentation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Documentation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Documentation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.masterAgreement is not None:
            self.masterAgreement.export(outfile, level, namespace_, name_='masterAgreement', pretty_print=pretty_print)
        if self.masterConfirmation is not None:
            self.masterConfirmation.export(outfile, level, namespace_, name_='masterConfirmation', pretty_print=pretty_print)
        if self.brokerConfirmation is not None:
            self.brokerConfirmation.export(outfile, level, namespace_, name_='brokerConfirmation', pretty_print=pretty_print)
        for contractualDefinitions_ in self.contractualDefinitions:
            contractualDefinitions_.export(outfile, level, namespace_, name_='contractualDefinitions', pretty_print=pretty_print)
        for contractualTermsSupplement_ in self.contractualTermsSupplement:
            contractualTermsSupplement_.export(outfile, level, namespace_, name_='contractualTermsSupplement', pretty_print=pretty_print)
        for contractualMatrix_ in self.contractualMatrix:
            contractualMatrix_.export(outfile, level, namespace_, name_='contractualMatrix', pretty_print=pretty_print)
        if self.creditSupportAgreement is not None:
            self.creditSupportAgreement.export(outfile, level, namespace_, name_='creditSupportAgreement', pretty_print=pretty_print)
        for attachment_ in self.attachment:
            attachment_.export(outfile, level, namespace_, name_='attachment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'masterAgreement':
            obj_ = MasterAgreement.factory()
            obj_.build(child_)
            self.masterAgreement = obj_
            obj_.original_tagname_ = 'masterAgreement'
        elif nodeName_ == 'masterConfirmation':
            obj_ = MasterConfirmation.factory()
            obj_.build(child_)
            self.masterConfirmation = obj_
            obj_.original_tagname_ = 'masterConfirmation'
        elif nodeName_ == 'brokerConfirmation':
            obj_ = BrokerConfirmation.factory()
            obj_.build(child_)
            self.brokerConfirmation = obj_
            obj_.original_tagname_ = 'brokerConfirmation'
        elif nodeName_ == 'contractualDefinitions':
            obj_ = ContractualDefinitions.factory()
            obj_.build(child_)
            self.contractualDefinitions.append(obj_)
            obj_.original_tagname_ = 'contractualDefinitions'
        elif nodeName_ == 'contractualTermsSupplement':
            obj_ = ContractualTermsSupplement.factory()
            obj_.build(child_)
            self.contractualTermsSupplement.append(obj_)
            obj_.original_tagname_ = 'contractualTermsSupplement'
        elif nodeName_ == 'contractualMatrix':
            obj_ = ContractualMatrix.factory()
            obj_.build(child_)
            self.contractualMatrix.append(obj_)
            obj_.original_tagname_ = 'contractualMatrix'
        elif nodeName_ == 'creditSupportAgreement':
            obj_ = CreditSupportAgreement.factory()
            obj_.build(child_)
            self.creditSupportAgreement = obj_
            obj_.original_tagname_ = 'creditSupportAgreement'
        elif nodeName_ == 'attachment':
            obj_ = Resource.factory()
            obj_.build(child_)
            self.attachment.append(obj_)
            obj_.original_tagname_ = 'attachment'
# end class Documentation


class EmbeddedOptionType(GeneratedsSuper):
    """A flexible description of the type or characteristics of an option
    embbedded within another product. For example, a cancelable
    provision or an optional early termination provision.The type
    scheme used with this option type."""
    member_data_items_ = {
        'embeddedOptionTypeScheme': MemberSpec_('embeddedOptionTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, embeddedOptionTypeScheme='http://www.fpml.org/coding-scheme/embedded-option-type', valueOf_=None):
        self.original_tagname_ = None
        self.embeddedOptionTypeScheme = _cast(None, embeddedOptionTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EmbeddedOptionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EmbeddedOptionType.subclass:
            return EmbeddedOptionType.subclass(*args_, **kwargs_)
        else:
            return EmbeddedOptionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_embeddedOptionTypeScheme(self): return self.embeddedOptionTypeScheme
    def set_embeddedOptionTypeScheme(self, embeddedOptionTypeScheme): self.embeddedOptionTypeScheme = embeddedOptionTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EmbeddedOptionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EmbeddedOptionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EmbeddedOptionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EmbeddedOptionType'):
        if self.embeddedOptionTypeScheme != "http://www.fpml.org/coding-scheme/embedded-option-type" and 'embeddedOptionTypeScheme' not in already_processed:
            already_processed.add('embeddedOptionTypeScheme')
            outfile.write(' embeddedOptionTypeScheme=%s' % (quote_attrib(self.embeddedOptionTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EmbeddedOptionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('embeddedOptionTypeScheme', node)
        if value is not None and 'embeddedOptionTypeScheme' not in already_processed:
            already_processed.add('embeddedOptionTypeScheme')
            self.embeddedOptionTypeScheme = value
            self.validate_NonEmptyURI(self.embeddedOptionTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EmbeddedOptionType


class Empty(GeneratedsSuper):
    """A special type meant to be used for elements with no content and no
    attributes."""
    member_data_items_ = {
    }
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Empty)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Empty.subclass:
            return Empty.subclass(*args_, **kwargs_)
        else:
            return Empty(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Empty', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Empty')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Empty', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Empty'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Empty', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Empty


class EntityId(GeneratedsSuper):
    """A legal entity identifier (e.g. RED entity code)."""
    member_data_items_ = {
        'entityIdScheme': MemberSpec_('entityIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, entityIdScheme='http://www.fpml.org/coding-scheme/external/entity-id-RED-1-0', valueOf_=None):
        self.original_tagname_ = None
        self.entityIdScheme = _cast(None, entityIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntityId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntityId.subclass:
            return EntityId.subclass(*args_, **kwargs_)
        else:
            return EntityId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_entityIdScheme(self): return self.entityIdScheme
    def set_entityIdScheme(self, entityIdScheme): self.entityIdScheme = entityIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EntityId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EntityId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EntityId'):
        if self.entityIdScheme != "http://www.fpml.org/coding-scheme/external/entity-id-RED-1-0" and 'entityIdScheme' not in already_processed:
            already_processed.add('entityIdScheme')
            outfile.write(' entityIdScheme=%s' % (quote_attrib(self.entityIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EntityId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('entityIdScheme', node)
        if value is not None and 'entityIdScheme' not in already_processed:
            already_processed.add('entityIdScheme')
            self.entityIdScheme = value
            self.validate_NonEmptyURI(self.entityIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntityId


class EntityName(GeneratedsSuper):
    """The name of the reference entity. A free format string. FpML does
    not define usage rules for this element."""
    member_data_items_ = {
        'entityNameScheme': MemberSpec_('entityNameScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, entityNameScheme='http://www.fpml.org/coding-scheme/external/entity-name-RED-1-0', valueOf_=None):
        self.original_tagname_ = None
        self.entityNameScheme = _cast(None, entityNameScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntityName)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntityName.subclass:
            return EntityName.subclass(*args_, **kwargs_)
        else:
            return EntityName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_entityNameScheme(self): return self.entityNameScheme
    def set_entityNameScheme(self, entityNameScheme): self.entityNameScheme = entityNameScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EntityName', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityName')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EntityName', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EntityName'):
        if self.entityNameScheme != "http://www.fpml.org/coding-scheme/external/entity-name-RED-1-0" and 'entityNameScheme' not in already_processed:
            already_processed.add('entityNameScheme')
            outfile.write(' entityNameScheme=%s' % (quote_attrib(self.entityNameScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EntityName', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('entityNameScheme', node)
        if value is not None and 'entityNameScheme' not in already_processed:
            already_processed.add('entityNameScheme')
            self.entityNameScheme = value
            self.validate_NonEmptyURI(self.entityNameScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntityName


class ExchangeId(GeneratedsSuper):
    """A short form unique identifier for an exchange. If the element is
    not present then the exchange shall be the primary exchange on
    which the underlying is listed. The term "Exchange" is assumed
    to have the meaning as defined in the ISDA 2002 Equity
    Derivatives Definitions."""
    member_data_items_ = {
        'exchangeIdScheme': MemberSpec_('exchangeIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, exchangeIdScheme='http://www.fpml.org/coding-scheme/external/exchange-id-MIC-1-0', valueOf_=None):
        self.original_tagname_ = None
        self.exchangeIdScheme = _cast(None, exchangeIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExchangeId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExchangeId.subclass:
            return ExchangeId.subclass(*args_, **kwargs_)
        else:
            return ExchangeId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_exchangeIdScheme(self): return self.exchangeIdScheme
    def set_exchangeIdScheme(self, exchangeIdScheme): self.exchangeIdScheme = exchangeIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExchangeId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExchangeId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExchangeId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExchangeId'):
        if self.exchangeIdScheme != "http://www.fpml.org/coding-scheme/external/exchange-id-MIC-1-0" and 'exchangeIdScheme' not in already_processed:
            already_processed.add('exchangeIdScheme')
            outfile.write(' exchangeIdScheme=%s' % (quote_attrib(self.exchangeIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ExchangeId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('exchangeIdScheme', node)
        if value is not None and 'exchangeIdScheme' not in already_processed:
            already_processed.add('exchangeIdScheme')
            self.exchangeIdScheme = value
            self.validate_NonEmptyURI(self.exchangeIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ExchangeId


class Exercise(GeneratedsSuper):
    """The abstract base class for all types which define way in which
    options may be exercised."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Exercise)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Exercise.subclass:
            return Exercise.subclass(*args_, **kwargs_)
        else:
            return Exercise(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Exercise', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Exercise')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Exercise', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Exercise'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Exercise', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Exercise


class ExerciseFee(GeneratedsSuper):
    """A type defining the fee payable on exercise of an option. This fee
    may be defined as an amount or a percentage of the notional
    exercised."""
    member_data_items_ = {
        'payerPartyReference': MemberSpec_('payerPartyReference', 'PartyReference', 0),
        'payerAccountReference': MemberSpec_('payerAccountReference', 'AccountReference', 0),
        'receiverPartyReference': MemberSpec_('receiverPartyReference', 'PartyReference', 0),
        'receiverAccountReference': MemberSpec_('receiverAccountReference', 'AccountReference', 0),
        'notionalReference': MemberSpec_('notionalReference', 'NotionalReference', 0),
        'feeAmount': MemberSpec_('feeAmount', 'xsd:decimal', 0),
        'feeRate': MemberSpec_('feeRate', 'xsd:decimal', 0),
        'feePaymentDate': MemberSpec_('feePaymentDate', 'RelativeDateOffset', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, notionalReference=None, feeAmount=None, feeRate=None, feePaymentDate=None):
        self.original_tagname_ = None
        self.payerPartyReference = payerPartyReference
        self.payerAccountReference = payerAccountReference
        self.receiverPartyReference = receiverPartyReference
        self.receiverAccountReference = receiverAccountReference
        self.notionalReference = notionalReference
        self.feeAmount = feeAmount
        self.feeRate = feeRate
        self.feePaymentDate = feePaymentDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExerciseFee)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExerciseFee.subclass:
            return ExerciseFee.subclass(*args_, **kwargs_)
        else:
            return ExerciseFee(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_payerPartyReference(self): return self.payerPartyReference
    def set_payerPartyReference(self, payerPartyReference): self.payerPartyReference = payerPartyReference
    def get_payerAccountReference(self): return self.payerAccountReference
    def set_payerAccountReference(self, payerAccountReference): self.payerAccountReference = payerAccountReference
    def get_receiverPartyReference(self): return self.receiverPartyReference
    def set_receiverPartyReference(self, receiverPartyReference): self.receiverPartyReference = receiverPartyReference
    def get_receiverAccountReference(self): return self.receiverAccountReference
    def set_receiverAccountReference(self, receiverAccountReference): self.receiverAccountReference = receiverAccountReference
    def get_notionalReference(self): return self.notionalReference
    def set_notionalReference(self, notionalReference): self.notionalReference = notionalReference
    def get_feeAmount(self): return self.feeAmount
    def set_feeAmount(self, feeAmount): self.feeAmount = feeAmount
    def get_feeRate(self): return self.feeRate
    def set_feeRate(self, feeRate): self.feeRate = feeRate
    def get_feePaymentDate(self): return self.feePaymentDate
    def set_feePaymentDate(self, feePaymentDate): self.feePaymentDate = feePaymentDate
    def hasContent_(self):
        if (
            self.payerPartyReference is not None or
            self.payerAccountReference is not None or
            self.receiverPartyReference is not None or
            self.receiverAccountReference is not None or
            self.notionalReference is not None or
            self.feeAmount is not None or
            self.feeRate is not None or
            self.feePaymentDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExerciseFee', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExerciseFee')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExerciseFee', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExerciseFee'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ExerciseFee', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.payerPartyReference is not None:
            self.payerPartyReference.export(outfile, level, namespace_, name_='payerPartyReference', pretty_print=pretty_print)
        if self.payerAccountReference is not None:
            self.payerAccountReference.export(outfile, level, namespace_, name_='payerAccountReference', pretty_print=pretty_print)
        if self.receiverPartyReference is not None:
            self.receiverPartyReference.export(outfile, level, namespace_, name_='receiverPartyReference', pretty_print=pretty_print)
        if self.receiverAccountReference is not None:
            self.receiverAccountReference.export(outfile, level, namespace_, name_='receiverAccountReference', pretty_print=pretty_print)
        if self.notionalReference is not None:
            self.notionalReference.export(outfile, level, namespace_, name_='notionalReference', pretty_print=pretty_print)
        if self.feeAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfeeAmount>%s</%sfeeAmount>%s' % (namespace_, self.gds_format_float(self.feeAmount, input_name='feeAmount'), namespace_, eol_))
        if self.feeRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfeeRate>%s</%sfeeRate>%s' % (namespace_, self.gds_format_float(self.feeRate, input_name='feeRate'), namespace_, eol_))
        if self.feePaymentDate is not None:
            self.feePaymentDate.export(outfile, level, namespace_, name_='feePaymentDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'payerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.payerPartyReference = obj_
            obj_.original_tagname_ = 'payerPartyReference'
        elif nodeName_ == 'payerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.payerAccountReference = obj_
            obj_.original_tagname_ = 'payerAccountReference'
        elif nodeName_ == 'receiverPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.receiverPartyReference = obj_
            obj_.original_tagname_ = 'receiverPartyReference'
        elif nodeName_ == 'receiverAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.receiverAccountReference = obj_
            obj_.original_tagname_ = 'receiverAccountReference'
        elif nodeName_ == 'notionalReference':
            obj_ = NotionalReference.factory()
            obj_.build(child_)
            self.notionalReference = obj_
            obj_.original_tagname_ = 'notionalReference'
        elif nodeName_ == 'feeAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'feeAmount')
            self.feeAmount = fval_
        elif nodeName_ == 'feeRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'feeRate')
            self.feeRate = fval_
        elif nodeName_ == 'feePaymentDate':
            class_obj_ = self.get_class_obj_(child_, RelativeDateOffset)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.feePaymentDate = obj_
            obj_.original_tagname_ = 'feePaymentDate'
# end class ExerciseFee


class ExerciseFeeSchedule(GeneratedsSuper):
    """A type to define a fee or schedule of fees to be payable on the
    exercise of an option. This fee may be defined as an amount or a
    percentage of the notional exercised."""
    member_data_items_ = {
        'payerPartyReference': MemberSpec_('payerPartyReference', 'PartyReference', 0),
        'payerAccountReference': MemberSpec_('payerAccountReference', 'AccountReference', 0),
        'receiverPartyReference': MemberSpec_('receiverPartyReference', 'PartyReference', 0),
        'receiverAccountReference': MemberSpec_('receiverAccountReference', 'AccountReference', 0),
        'notionalReference': MemberSpec_('notionalReference', 'ScheduleReference', 0),
        'feeAmountSchedule': MemberSpec_('feeAmountSchedule', 'AmountSchedule', 0),
        'feeRateSchedule': MemberSpec_('feeRateSchedule', 'Schedule', 0),
        'feePaymentDate': MemberSpec_('feePaymentDate', 'RelativeDateOffset', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, notionalReference=None, feeAmountSchedule=None, feeRateSchedule=None, feePaymentDate=None):
        self.original_tagname_ = None
        self.payerPartyReference = payerPartyReference
        self.payerAccountReference = payerAccountReference
        self.receiverPartyReference = receiverPartyReference
        self.receiverAccountReference = receiverAccountReference
        self.notionalReference = notionalReference
        self.feeAmountSchedule = feeAmountSchedule
        self.feeRateSchedule = feeRateSchedule
        self.feePaymentDate = feePaymentDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExerciseFeeSchedule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExerciseFeeSchedule.subclass:
            return ExerciseFeeSchedule.subclass(*args_, **kwargs_)
        else:
            return ExerciseFeeSchedule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_payerPartyReference(self): return self.payerPartyReference
    def set_payerPartyReference(self, payerPartyReference): self.payerPartyReference = payerPartyReference
    def get_payerAccountReference(self): return self.payerAccountReference
    def set_payerAccountReference(self, payerAccountReference): self.payerAccountReference = payerAccountReference
    def get_receiverPartyReference(self): return self.receiverPartyReference
    def set_receiverPartyReference(self, receiverPartyReference): self.receiverPartyReference = receiverPartyReference
    def get_receiverAccountReference(self): return self.receiverAccountReference
    def set_receiverAccountReference(self, receiverAccountReference): self.receiverAccountReference = receiverAccountReference
    def get_notionalReference(self): return self.notionalReference
    def set_notionalReference(self, notionalReference): self.notionalReference = notionalReference
    def get_feeAmountSchedule(self): return self.feeAmountSchedule
    def set_feeAmountSchedule(self, feeAmountSchedule): self.feeAmountSchedule = feeAmountSchedule
    def get_feeRateSchedule(self): return self.feeRateSchedule
    def set_feeRateSchedule(self, feeRateSchedule): self.feeRateSchedule = feeRateSchedule
    def get_feePaymentDate(self): return self.feePaymentDate
    def set_feePaymentDate(self, feePaymentDate): self.feePaymentDate = feePaymentDate
    def hasContent_(self):
        if (
            self.payerPartyReference is not None or
            self.payerAccountReference is not None or
            self.receiverPartyReference is not None or
            self.receiverAccountReference is not None or
            self.notionalReference is not None or
            self.feeAmountSchedule is not None or
            self.feeRateSchedule is not None or
            self.feePaymentDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExerciseFeeSchedule', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExerciseFeeSchedule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExerciseFeeSchedule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExerciseFeeSchedule'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ExerciseFeeSchedule', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.payerPartyReference is not None:
            self.payerPartyReference.export(outfile, level, namespace_, name_='payerPartyReference', pretty_print=pretty_print)
        if self.payerAccountReference is not None:
            self.payerAccountReference.export(outfile, level, namespace_, name_='payerAccountReference', pretty_print=pretty_print)
        if self.receiverPartyReference is not None:
            self.receiverPartyReference.export(outfile, level, namespace_, name_='receiverPartyReference', pretty_print=pretty_print)
        if self.receiverAccountReference is not None:
            self.receiverAccountReference.export(outfile, level, namespace_, name_='receiverAccountReference', pretty_print=pretty_print)
        if self.notionalReference is not None:
            self.notionalReference.export(outfile, level, namespace_, name_='notionalReference', pretty_print=pretty_print)
        if self.feeAmountSchedule is not None:
            self.feeAmountSchedule.export(outfile, level, namespace_, name_='feeAmountSchedule', pretty_print=pretty_print)
        if self.feeRateSchedule is not None:
            self.feeRateSchedule.export(outfile, level, namespace_, name_='feeRateSchedule', pretty_print=pretty_print)
        if self.feePaymentDate is not None:
            self.feePaymentDate.export(outfile, level, namespace_, name_='feePaymentDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'payerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.payerPartyReference = obj_
            obj_.original_tagname_ = 'payerPartyReference'
        elif nodeName_ == 'payerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.payerAccountReference = obj_
            obj_.original_tagname_ = 'payerAccountReference'
        elif nodeName_ == 'receiverPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.receiverPartyReference = obj_
            obj_.original_tagname_ = 'receiverPartyReference'
        elif nodeName_ == 'receiverAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.receiverAccountReference = obj_
            obj_.original_tagname_ = 'receiverAccountReference'
        elif nodeName_ == 'notionalReference':
            obj_ = ScheduleReference.factory()
            obj_.build(child_)
            self.notionalReference = obj_
            obj_.original_tagname_ = 'notionalReference'
        elif nodeName_ == 'feeAmountSchedule':
            obj_ = AmountSchedule.factory()
            obj_.build(child_)
            self.feeAmountSchedule = obj_
            obj_.original_tagname_ = 'feeAmountSchedule'
        elif nodeName_ == 'feeRateSchedule':
            class_obj_ = self.get_class_obj_(child_, Schedule)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.feeRateSchedule = obj_
            obj_.original_tagname_ = 'feeRateSchedule'
        elif nodeName_ == 'feePaymentDate':
            class_obj_ = self.get_class_obj_(child_, RelativeDateOffset)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.feePaymentDate = obj_
            obj_.original_tagname_ = 'feePaymentDate'
# end class ExerciseFeeSchedule


class ExerciseNotice(GeneratedsSuper):
    """A type defining to whom and where notice of execution should be
    given. The partyReference refers to one of the principal parties
    of the trade. If present the exerciseNoticePartyReference refers
    to a party, other than the principal party, to whome notice
    should be given."""
    member_data_items_ = {
        'partyReference': MemberSpec_('partyReference', 'PartyReference', 0),
        'exerciseNoticePartyReference': MemberSpec_('exerciseNoticePartyReference', 'PartyReference', 0),
        'businessCenter': MemberSpec_('businessCenter', 'BusinessCenter', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, partyReference=None, exerciseNoticePartyReference=None, businessCenter=None):
        self.original_tagname_ = None
        self.partyReference = partyReference
        self.exerciseNoticePartyReference = exerciseNoticePartyReference
        self.businessCenter = businessCenter
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExerciseNotice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExerciseNotice.subclass:
            return ExerciseNotice.subclass(*args_, **kwargs_)
        else:
            return ExerciseNotice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyReference(self): return self.partyReference
    def set_partyReference(self, partyReference): self.partyReference = partyReference
    def get_exerciseNoticePartyReference(self): return self.exerciseNoticePartyReference
    def set_exerciseNoticePartyReference(self, exerciseNoticePartyReference): self.exerciseNoticePartyReference = exerciseNoticePartyReference
    def get_businessCenter(self): return self.businessCenter
    def set_businessCenter(self, businessCenter): self.businessCenter = businessCenter
    def hasContent_(self):
        if (
            self.partyReference is not None or
            self.exerciseNoticePartyReference is not None or
            self.businessCenter is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExerciseNotice', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExerciseNotice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExerciseNotice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExerciseNotice'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ExerciseNotice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.partyReference is not None:
            self.partyReference.export(outfile, level, namespace_, name_='partyReference', pretty_print=pretty_print)
        if self.exerciseNoticePartyReference is not None:
            self.exerciseNoticePartyReference.export(outfile, level, namespace_, name_='exerciseNoticePartyReference', pretty_print=pretty_print)
        if self.businessCenter is not None:
            self.businessCenter.export(outfile, level, namespace_, name_='businessCenter', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'partyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.partyReference = obj_
            obj_.original_tagname_ = 'partyReference'
        elif nodeName_ == 'exerciseNoticePartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.exerciseNoticePartyReference = obj_
            obj_.original_tagname_ = 'exerciseNoticePartyReference'
        elif nodeName_ == 'businessCenter':
            obj_ = BusinessCenter.factory()
            obj_.build(child_)
            self.businessCenter = obj_
            obj_.original_tagname_ = 'businessCenter'
# end class ExerciseNotice


class ExerciseProcedure(GeneratedsSuper):
    """A type describing how notice of exercise should be given. This can
    be either manual or automatic."""
    member_data_items_ = {
        'manualExercise': MemberSpec_('manualExercise', 'ManualExercise', 0),
        'automaticExercise': MemberSpec_('automaticExercise', 'AutomaticExercise', 0),
        'followUpConfirmation': MemberSpec_('followUpConfirmation', 'xsd:boolean', 0),
        'limitedRightToConfirm': MemberSpec_('limitedRightToConfirm', 'xsd:boolean', 0),
        'splitTicket': MemberSpec_('splitTicket', 'xsd:boolean', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, manualExercise=None, automaticExercise=None, followUpConfirmation=None, limitedRightToConfirm=None, splitTicket=None):
        self.original_tagname_ = None
        self.manualExercise = manualExercise
        self.automaticExercise = automaticExercise
        self.followUpConfirmation = followUpConfirmation
        self.limitedRightToConfirm = limitedRightToConfirm
        self.splitTicket = splitTicket
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExerciseProcedure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExerciseProcedure.subclass:
            return ExerciseProcedure.subclass(*args_, **kwargs_)
        else:
            return ExerciseProcedure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_manualExercise(self): return self.manualExercise
    def set_manualExercise(self, manualExercise): self.manualExercise = manualExercise
    def get_automaticExercise(self): return self.automaticExercise
    def set_automaticExercise(self, automaticExercise): self.automaticExercise = automaticExercise
    def get_followUpConfirmation(self): return self.followUpConfirmation
    def set_followUpConfirmation(self, followUpConfirmation): self.followUpConfirmation = followUpConfirmation
    def get_limitedRightToConfirm(self): return self.limitedRightToConfirm
    def set_limitedRightToConfirm(self, limitedRightToConfirm): self.limitedRightToConfirm = limitedRightToConfirm
    def get_splitTicket(self): return self.splitTicket
    def set_splitTicket(self, splitTicket): self.splitTicket = splitTicket
    def hasContent_(self):
        if (
            self.manualExercise is not None or
            self.automaticExercise is not None or
            self.followUpConfirmation is not None or
            self.limitedRightToConfirm is not None or
            self.splitTicket is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExerciseProcedure', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExerciseProcedure')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExerciseProcedure', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExerciseProcedure'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ExerciseProcedure', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.manualExercise is not None:
            self.manualExercise.export(outfile, level, namespace_, name_='manualExercise', pretty_print=pretty_print)
        if self.automaticExercise is not None:
            self.automaticExercise.export(outfile, level, namespace_, name_='automaticExercise', pretty_print=pretty_print)
        if self.followUpConfirmation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfollowUpConfirmation>%s</%sfollowUpConfirmation>%s' % (namespace_, self.gds_format_boolean(self.followUpConfirmation, input_name='followUpConfirmation'), namespace_, eol_))
        if self.limitedRightToConfirm is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slimitedRightToConfirm>%s</%slimitedRightToConfirm>%s' % (namespace_, self.gds_format_boolean(self.limitedRightToConfirm, input_name='limitedRightToConfirm'), namespace_, eol_))
        if self.splitTicket is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssplitTicket>%s</%ssplitTicket>%s' % (namespace_, self.gds_format_boolean(self.splitTicket, input_name='splitTicket'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'manualExercise':
            obj_ = ManualExercise.factory()
            obj_.build(child_)
            self.manualExercise = obj_
            obj_.original_tagname_ = 'manualExercise'
        elif nodeName_ == 'automaticExercise':
            obj_ = AutomaticExercise.factory()
            obj_.build(child_)
            self.automaticExercise = obj_
            obj_.original_tagname_ = 'automaticExercise'
        elif nodeName_ == 'followUpConfirmation':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'followUpConfirmation')
            self.followUpConfirmation = ival_
        elif nodeName_ == 'limitedRightToConfirm':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'limitedRightToConfirm')
            self.limitedRightToConfirm = ival_
        elif nodeName_ == 'splitTicket':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'splitTicket')
            self.splitTicket = ival_
# end class ExerciseProcedure


class ExerciseProcedureOption(GeneratedsSuper):
    """A type describing how notice of exercise should be given. This can
    be either manual or automatic."""
    member_data_items_ = {
        'manualExercise': MemberSpec_('manualExercise', 'Empty', 0),
        'automaticExercise': MemberSpec_('automaticExercise', 'Empty', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, manualExercise=None, automaticExercise=None):
        self.original_tagname_ = None
        self.manualExercise = manualExercise
        self.automaticExercise = automaticExercise
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExerciseProcedureOption)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExerciseProcedureOption.subclass:
            return ExerciseProcedureOption.subclass(*args_, **kwargs_)
        else:
            return ExerciseProcedureOption(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_manualExercise(self): return self.manualExercise
    def set_manualExercise(self, manualExercise): self.manualExercise = manualExercise
    def get_automaticExercise(self): return self.automaticExercise
    def set_automaticExercise(self, automaticExercise): self.automaticExercise = automaticExercise
    def hasContent_(self):
        if (
            self.manualExercise is not None or
            self.automaticExercise is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExerciseProcedureOption', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExerciseProcedureOption')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExerciseProcedureOption', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExerciseProcedureOption'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ExerciseProcedureOption', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.manualExercise is not None:
            self.manualExercise.export(outfile, level, namespace_, name_='manualExercise', pretty_print=pretty_print)
        if self.automaticExercise is not None:
            self.automaticExercise.export(outfile, level, namespace_, name_='automaticExercise', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'manualExercise':
            obj_ = Empty.factory()
            obj_.build(child_)
            self.manualExercise = obj_
            obj_.original_tagname_ = 'manualExercise'
        elif nodeName_ == 'automaticExercise':
            obj_ = Empty.factory()
            obj_.build(child_)
            self.automaticExercise = obj_
            obj_.original_tagname_ = 'automaticExercise'
# end class ExerciseProcedureOption


class FloatingRateIndex(GeneratedsSuper):
    """The ISDA Floating Rate Option, i.e. the floating rate index."""
    member_data_items_ = {
        'floatingRateIndexScheme': MemberSpec_('floatingRateIndexScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, floatingRateIndexScheme='http://www.fpml.org/coding-scheme/floating-rate-index', valueOf_=None):
        self.original_tagname_ = None
        self.floatingRateIndexScheme = _cast(None, floatingRateIndexScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FloatingRateIndex)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FloatingRateIndex.subclass:
            return FloatingRateIndex.subclass(*args_, **kwargs_)
        else:
            return FloatingRateIndex(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_floatingRateIndexScheme(self): return self.floatingRateIndexScheme
    def set_floatingRateIndexScheme(self, floatingRateIndexScheme): self.floatingRateIndexScheme = floatingRateIndexScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FloatingRateIndex', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FloatingRateIndex')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FloatingRateIndex', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FloatingRateIndex'):
        if self.floatingRateIndexScheme != "http://www.fpml.org/coding-scheme/floating-rate-index" and 'floatingRateIndexScheme' not in already_processed:
            already_processed.add('floatingRateIndexScheme')
            outfile.write(' floatingRateIndexScheme=%s' % (quote_attrib(self.floatingRateIndexScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='FloatingRateIndex', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('floatingRateIndexScheme', node)
        if value is not None and 'floatingRateIndexScheme' not in already_processed:
            already_processed.add('floatingRateIndexScheme')
            self.floatingRateIndexScheme = value
            self.validate_NonEmptyURI(self.floatingRateIndexScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FloatingRateIndex


class ForecastRateIndex(GeneratedsSuper):
    """A type defining a rate index."""
    member_data_items_ = {
        'floatingRateIndex': MemberSpec_('floatingRateIndex', 'FloatingRateIndex', 0),
        'indexTenor': MemberSpec_('indexTenor', 'Period', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, floatingRateIndex=None, indexTenor=None):
        self.original_tagname_ = None
        self.floatingRateIndex = floatingRateIndex
        self.indexTenor = indexTenor
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ForecastRateIndex)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ForecastRateIndex.subclass:
            return ForecastRateIndex.subclass(*args_, **kwargs_)
        else:
            return ForecastRateIndex(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_floatingRateIndex(self): return self.floatingRateIndex
    def set_floatingRateIndex(self, floatingRateIndex): self.floatingRateIndex = floatingRateIndex
    def get_indexTenor(self): return self.indexTenor
    def set_indexTenor(self, indexTenor): self.indexTenor = indexTenor
    def hasContent_(self):
        if (
            self.floatingRateIndex is not None or
            self.indexTenor is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ForecastRateIndex', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ForecastRateIndex')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ForecastRateIndex', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ForecastRateIndex'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ForecastRateIndex', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.floatingRateIndex is not None:
            self.floatingRateIndex.export(outfile, level, namespace_, name_='floatingRateIndex', pretty_print=pretty_print)
        if self.indexTenor is not None:
            self.indexTenor.export(outfile, level, namespace_, name_='indexTenor', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'floatingRateIndex':
            obj_ = FloatingRateIndex.factory()
            obj_.build(child_)
            self.floatingRateIndex = obj_
            obj_.original_tagname_ = 'floatingRateIndex'
        elif nodeName_ == 'indexTenor':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.indexTenor = obj_
            obj_.original_tagname_ = 'indexTenor'
# end class ForecastRateIndex


class Formula(GeneratedsSuper):
    """A type describing a financial formula, with its description and
    components."""
    member_data_items_ = {
        'formulaDescription': MemberSpec_('formulaDescription', ['String', 'xsd:string'], 0),
        'math': MemberSpec_('math', 'Math', 0),
        'formulaComponent': MemberSpec_('formulaComponent', 'FormulaComponent', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, formulaDescription=None, math=None, formulaComponent=None):
        self.original_tagname_ = None
        self.formulaDescription = formulaDescription
        self.validate_String(self.formulaDescription)
        self.math = math
        if formulaComponent is None:
            self.formulaComponent = []
        else:
            self.formulaComponent = formulaComponent
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Formula)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Formula.subclass:
            return Formula.subclass(*args_, **kwargs_)
        else:
            return Formula(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_formulaDescription(self): return self.formulaDescription
    def set_formulaDescription(self, formulaDescription): self.formulaDescription = formulaDescription
    def get_math(self): return self.math
    def set_math(self, math): self.math = math
    def get_formulaComponent(self): return self.formulaComponent
    def set_formulaComponent(self, formulaComponent): self.formulaComponent = formulaComponent
    def add_formulaComponent(self, value): self.formulaComponent.append(value)
    def insert_formulaComponent_at(self, index, value): self.formulaComponent.insert(index, value)
    def replace_formulaComponent_at(self, index, value): self.formulaComponent[index] = value
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.formulaDescription is not None or
            self.math is not None or
            self.formulaComponent
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Formula', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Formula')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Formula', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Formula'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Formula', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.formulaDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sformulaDescription>%s</%sformulaDescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.formulaDescription), input_name='formulaDescription')), namespace_, eol_))
        if self.math is not None:
            self.math.export(outfile, level, namespace_, name_='math', pretty_print=pretty_print)
        for formulaComponent_ in self.formulaComponent:
            formulaComponent_.export(outfile, level, namespace_, name_='formulaComponent', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'formulaDescription':
            formulaDescription_ = child_.text
            formulaDescription_ = self.gds_validate_string(formulaDescription_, node, 'formulaDescription')
            self.formulaDescription = formulaDescription_
            # validate type String
            self.validate_String(self.formulaDescription)
        elif nodeName_ == 'math':
            obj_ = Math.factory()
            obj_.build(child_)
            self.math = obj_
            obj_.original_tagname_ = 'math'
        elif nodeName_ == 'formulaComponent':
            obj_ = FormulaComponent.factory()
            obj_.build(child_)
            self.formulaComponent.append(obj_)
            obj_.original_tagname_ = 'formulaComponent'
# end class Formula


class FormulaComponent(GeneratedsSuper):
    """Elements describing the components of the formula. The name
    attribute points to a value used in the math element. The href
    attribute points to a numeric value defined elsewhere in the
    document that is used by the formula component."""
    member_data_items_ = {
        'name': MemberSpec_('name', 'NormalizedString', 0),
        'componentDescription': MemberSpec_('componentDescription', ['String', 'xsd:string'], 0),
        'formula': MemberSpec_('formula', 'Formula', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, name=None, componentDescription=None, formula=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.componentDescription = componentDescription
        self.validate_String(self.componentDescription)
        self.formula = formula
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FormulaComponent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FormulaComponent.subclass:
            return FormulaComponent.subclass(*args_, **kwargs_)
        else:
            return FormulaComponent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_componentDescription(self): return self.componentDescription
    def set_componentDescription(self, componentDescription): self.componentDescription = componentDescription
    def get_formula(self): return self.formula
    def set_formula(self, formula): self.formula = formula
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def validate_NormalizedString(self, value):
        # Validate type NormalizedString, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NormalizedString' % {"value" : value} )
    def hasContent_(self):
        if (
            self.componentDescription is not None or
            self.formula is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FormulaComponent', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FormulaComponent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FormulaComponent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FormulaComponent'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (quote_attrib(self.name), ))
    def exportChildren(self, outfile, level, namespace_='', name_='FormulaComponent', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.componentDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomponentDescription>%s</%scomponentDescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.componentDescription), input_name='componentDescription')), namespace_, eol_))
        if self.formula is not None:
            self.formula.export(outfile, level, namespace_, name_='formula', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_NormalizedString(self.name)    # validate type NormalizedString
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'componentDescription':
            componentDescription_ = child_.text
            componentDescription_ = self.gds_validate_string(componentDescription_, node, 'componentDescription')
            self.componentDescription = componentDescription_
            # validate type String
            self.validate_String(self.componentDescription)
        elif nodeName_ == 'formula':
            obj_ = Formula.factory()
            obj_.build(child_)
            self.formula = obj_
            obj_.original_tagname_ = 'formula'
# end class FormulaComponent


class Frequency(GeneratedsSuper):
    """A type defining a time frequency, e.g. one day, three months. Used
    for specifying payment or calculation frequencies at which the
    value T (Term) is applicable."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'periodMultiplier': MemberSpec_('periodMultiplier', 'xsd:positiveInteger', 0),
        'period': MemberSpec_('period', ['PeriodExtendedEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, periodMultiplier=None, period=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.periodMultiplier = periodMultiplier
        self.period = period
        self.validate_PeriodExtendedEnum(self.period)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Frequency)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Frequency.subclass:
            return Frequency.subclass(*args_, **kwargs_)
        else:
            return Frequency(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_periodMultiplier(self): return self.periodMultiplier
    def set_periodMultiplier(self, periodMultiplier): self.periodMultiplier = periodMultiplier
    def get_period(self): return self.period
    def set_period(self, period): self.period = period
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_PeriodExtendedEnum(self, value):
        # Validate type PeriodExtendedEnum, a restriction on Token.
        pass
    def hasContent_(self):
        if (
            self.periodMultiplier is not None or
            self.period is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Frequency', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Frequency')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Frequency', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Frequency'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Frequency', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.periodMultiplier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%speriodMultiplier>%s</%speriodMultiplier>%s' % (namespace_, self.gds_format_integer(self.periodMultiplier, input_name='periodMultiplier'), namespace_, eol_))
        if self.period is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%speriod>%s</%speriod>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.period), input_name='period')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'periodMultiplier':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'periodMultiplier')
            self.periodMultiplier = ival_
        elif nodeName_ == 'period':
            period_ = child_.text
            period_ = re_.sub(String_cleanup_pat_, " ", period_).strip()
            period_ = self.gds_validate_string(period_, node, 'period')
            self.period = period_
            # validate type PeriodExtendedEnum
            self.validate_PeriodExtendedEnum(self.period)
# end class Frequency


class FxCashSettlement(GeneratedsSuper):
    """A type that is used for describing cash settlement of an option /
    non deliverable forward. It includes the currency to settle into
    together with the fixings required to calculate the currency
    amount."""
    member_data_items_ = {
        'settlementCurrency': MemberSpec_('settlementCurrency', 'Currency', 0),
        'referenceCurrency': MemberSpec_('referenceCurrency', 'Currency', 0),
        'notionalAmount': MemberSpec_('notionalAmount', 'PositiveMoney', 0),
        'fixing': MemberSpec_('fixing', 'FxFixing', 1),
        'rateSourceFixing': MemberSpec_('rateSourceFixing', 'FxRateSourceFixing', 1),
        'settlementDate': MemberSpec_('settlementDate', 'AdjustableDate', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, settlementCurrency=None, referenceCurrency=None, notionalAmount=None, fixing=None, rateSourceFixing=None, settlementDate=None):
        self.original_tagname_ = None
        self.settlementCurrency = settlementCurrency
        self.referenceCurrency = referenceCurrency
        self.notionalAmount = notionalAmount
        if fixing is None:
            self.fixing = []
        else:
            self.fixing = fixing
        if rateSourceFixing is None:
            self.rateSourceFixing = []
        else:
            self.rateSourceFixing = rateSourceFixing
        self.settlementDate = settlementDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FxCashSettlement)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FxCashSettlement.subclass:
            return FxCashSettlement.subclass(*args_, **kwargs_)
        else:
            return FxCashSettlement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_settlementCurrency(self): return self.settlementCurrency
    def set_settlementCurrency(self, settlementCurrency): self.settlementCurrency = settlementCurrency
    def get_referenceCurrency(self): return self.referenceCurrency
    def set_referenceCurrency(self, referenceCurrency): self.referenceCurrency = referenceCurrency
    def get_notionalAmount(self): return self.notionalAmount
    def set_notionalAmount(self, notionalAmount): self.notionalAmount = notionalAmount
    def get_fixing(self): return self.fixing
    def set_fixing(self, fixing): self.fixing = fixing
    def add_fixing(self, value): self.fixing.append(value)
    def insert_fixing_at(self, index, value): self.fixing.insert(index, value)
    def replace_fixing_at(self, index, value): self.fixing[index] = value
    def get_rateSourceFixing(self): return self.rateSourceFixing
    def set_rateSourceFixing(self, rateSourceFixing): self.rateSourceFixing = rateSourceFixing
    def add_rateSourceFixing(self, value): self.rateSourceFixing.append(value)
    def insert_rateSourceFixing_at(self, index, value): self.rateSourceFixing.insert(index, value)
    def replace_rateSourceFixing_at(self, index, value): self.rateSourceFixing[index] = value
    def get_settlementDate(self): return self.settlementDate
    def set_settlementDate(self, settlementDate): self.settlementDate = settlementDate
    def hasContent_(self):
        if (
            self.settlementCurrency is not None or
            self.referenceCurrency is not None or
            self.notionalAmount is not None or
            self.fixing or
            self.rateSourceFixing or
            self.settlementDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FxCashSettlement', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FxCashSettlement')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FxCashSettlement', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FxCashSettlement'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FxCashSettlement', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.settlementCurrency is not None:
            self.settlementCurrency.export(outfile, level, namespace_, name_='settlementCurrency', pretty_print=pretty_print)
        if self.referenceCurrency is not None:
            self.referenceCurrency.export(outfile, level, namespace_, name_='referenceCurrency', pretty_print=pretty_print)
        if self.notionalAmount is not None:
            self.notionalAmount.export(outfile, level, namespace_, name_='notionalAmount', pretty_print=pretty_print)
        for fixing_ in self.fixing:
            fixing_.export(outfile, level, namespace_, name_='fixing', pretty_print=pretty_print)
        for rateSourceFixing_ in self.rateSourceFixing:
            rateSourceFixing_.export(outfile, level, namespace_, name_='rateSourceFixing', pretty_print=pretty_print)
        if self.settlementDate is not None:
            self.settlementDate.export(outfile, level, namespace_, name_='settlementDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'settlementCurrency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.settlementCurrency = obj_
            obj_.original_tagname_ = 'settlementCurrency'
        elif nodeName_ == 'referenceCurrency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.referenceCurrency = obj_
            obj_.original_tagname_ = 'referenceCurrency'
        elif nodeName_ == 'notionalAmount':
            obj_ = PositiveMoney.factory()
            obj_.build(child_)
            self.notionalAmount = obj_
            obj_.original_tagname_ = 'notionalAmount'
        elif nodeName_ == 'fixing':
            obj_ = FxFixing.factory()
            obj_.build(child_)
            self.fixing.append(obj_)
            obj_.original_tagname_ = 'fixing'
        elif nodeName_ == 'rateSourceFixing':
            obj_ = FxRateSourceFixing.factory()
            obj_.build(child_)
            self.rateSourceFixing.append(obj_)
            obj_.original_tagname_ = 'rateSourceFixing'
        elif nodeName_ == 'settlementDate':
            obj_ = AdjustableDate.factory()
            obj_.build(child_)
            self.settlementDate = obj_
            obj_.original_tagname_ = 'settlementDate'
# end class FxCashSettlement


class FxCashSettlementSimple(GeneratedsSuper):
    """A type that is used for describing cash settlement of a variance or
    volatility swap option. It includes the settlement currency
    together with the spot currency exchange required to calculate
    the settlement currency amount."""
    member_data_items_ = {
        'settlementCurrency': MemberSpec_('settlementCurrency', 'Currency', 0),
        'referenceCurrency': MemberSpec_('referenceCurrency', 'Currency', 0),
        'fixing': MemberSpec_('fixing', 'FxFixing', 1),
        'rateSourceFixing': MemberSpec_('rateSourceFixing', 'FxRateSourceFixing', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, settlementCurrency=None, referenceCurrency=None, fixing=None, rateSourceFixing=None):
        self.original_tagname_ = None
        self.settlementCurrency = settlementCurrency
        self.referenceCurrency = referenceCurrency
        if fixing is None:
            self.fixing = []
        else:
            self.fixing = fixing
        if rateSourceFixing is None:
            self.rateSourceFixing = []
        else:
            self.rateSourceFixing = rateSourceFixing
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FxCashSettlementSimple)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FxCashSettlementSimple.subclass:
            return FxCashSettlementSimple.subclass(*args_, **kwargs_)
        else:
            return FxCashSettlementSimple(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_settlementCurrency(self): return self.settlementCurrency
    def set_settlementCurrency(self, settlementCurrency): self.settlementCurrency = settlementCurrency
    def get_referenceCurrency(self): return self.referenceCurrency
    def set_referenceCurrency(self, referenceCurrency): self.referenceCurrency = referenceCurrency
    def get_fixing(self): return self.fixing
    def set_fixing(self, fixing): self.fixing = fixing
    def add_fixing(self, value): self.fixing.append(value)
    def insert_fixing_at(self, index, value): self.fixing.insert(index, value)
    def replace_fixing_at(self, index, value): self.fixing[index] = value
    def get_rateSourceFixing(self): return self.rateSourceFixing
    def set_rateSourceFixing(self, rateSourceFixing): self.rateSourceFixing = rateSourceFixing
    def add_rateSourceFixing(self, value): self.rateSourceFixing.append(value)
    def insert_rateSourceFixing_at(self, index, value): self.rateSourceFixing.insert(index, value)
    def replace_rateSourceFixing_at(self, index, value): self.rateSourceFixing[index] = value
    def hasContent_(self):
        if (
            self.settlementCurrency is not None or
            self.referenceCurrency is not None or
            self.fixing or
            self.rateSourceFixing
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FxCashSettlementSimple', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FxCashSettlementSimple')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FxCashSettlementSimple', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FxCashSettlementSimple'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FxCashSettlementSimple', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.settlementCurrency is not None:
            self.settlementCurrency.export(outfile, level, namespace_, name_='settlementCurrency', pretty_print=pretty_print)
        if self.referenceCurrency is not None:
            self.referenceCurrency.export(outfile, level, namespace_, name_='referenceCurrency', pretty_print=pretty_print)
        for fixing_ in self.fixing:
            fixing_.export(outfile, level, namespace_, name_='fixing', pretty_print=pretty_print)
        for rateSourceFixing_ in self.rateSourceFixing:
            rateSourceFixing_.export(outfile, level, namespace_, name_='rateSourceFixing', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'settlementCurrency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.settlementCurrency = obj_
            obj_.original_tagname_ = 'settlementCurrency'
        elif nodeName_ == 'referenceCurrency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.referenceCurrency = obj_
            obj_.original_tagname_ = 'referenceCurrency'
        elif nodeName_ == 'fixing':
            obj_ = FxFixing.factory()
            obj_.build(child_)
            self.fixing.append(obj_)
            obj_.original_tagname_ = 'fixing'
        elif nodeName_ == 'rateSourceFixing':
            obj_ = FxRateSourceFixing.factory()
            obj_.build(child_)
            self.rateSourceFixing.append(obj_)
            obj_.original_tagname_ = 'rateSourceFixing'
# end class FxCashSettlementSimple


class FxFixing(GeneratedsSuper):
    """A type that specifies the source for and timing of a fixing of an
    exchange rate. This is used in the agreement of non-deliverable
    forward trades as well as various types of FX OTC options that
    require observations against a particular rate."""
    member_data_items_ = {
        'quotedCurrencyPair': MemberSpec_('quotedCurrencyPair', 'QuotedCurrencyPair', 0),
        'fixingDate': MemberSpec_('fixingDate', 'xsd:date', 0),
        'fxSpotRateSource': MemberSpec_('fxSpotRateSource', 'FxSpotRateSource', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, quotedCurrencyPair=None, fixingDate=None, fxSpotRateSource=None):
        self.original_tagname_ = None
        self.quotedCurrencyPair = quotedCurrencyPair
        if isinstance(fixingDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(fixingDate, '%Y-%m-%d').date()
        else:
            initvalue_ = fixingDate
        self.fixingDate = initvalue_
        self.fxSpotRateSource = fxSpotRateSource
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FxFixing)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FxFixing.subclass:
            return FxFixing.subclass(*args_, **kwargs_)
        else:
            return FxFixing(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_quotedCurrencyPair(self): return self.quotedCurrencyPair
    def set_quotedCurrencyPair(self, quotedCurrencyPair): self.quotedCurrencyPair = quotedCurrencyPair
    def get_fixingDate(self): return self.fixingDate
    def set_fixingDate(self, fixingDate): self.fixingDate = fixingDate
    def get_fxSpotRateSource(self): return self.fxSpotRateSource
    def set_fxSpotRateSource(self, fxSpotRateSource): self.fxSpotRateSource = fxSpotRateSource
    def hasContent_(self):
        if (
            self.quotedCurrencyPair is not None or
            self.fixingDate is not None or
            self.fxSpotRateSource is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FxFixing', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FxFixing')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FxFixing', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FxFixing'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FxFixing', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.quotedCurrencyPair is not None:
            self.quotedCurrencyPair.export(outfile, level, namespace_, name_='quotedCurrencyPair', pretty_print=pretty_print)
        if self.fixingDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfixingDate>%s</%sfixingDate>%s' % (namespace_, self.gds_format_date(self.fixingDate, input_name='fixingDate'), namespace_, eol_))
        if self.fxSpotRateSource is not None:
            self.fxSpotRateSource.export(outfile, level, namespace_, name_='fxSpotRateSource', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'quotedCurrencyPair':
            obj_ = QuotedCurrencyPair.factory()
            obj_.build(child_)
            self.quotedCurrencyPair = obj_
            obj_.original_tagname_ = 'quotedCurrencyPair'
        elif nodeName_ == 'fixingDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.fixingDate = dval_
        elif nodeName_ == 'fxSpotRateSource':
            obj_ = FxSpotRateSource.factory()
            obj_.build(child_)
            self.fxSpotRateSource = obj_
            obj_.original_tagname_ = 'fxSpotRateSource'
# end class FxFixing


class FxRate(GeneratedsSuper):
    """A type describing the rate of a currency conversion: pair of
    currency, quotation mode and exchange rate."""
    member_data_items_ = {
        'quotedCurrencyPair': MemberSpec_('quotedCurrencyPair', 'QuotedCurrencyPair', 0),
        'rate': MemberSpec_('rate', 'xsd:decimal', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, quotedCurrencyPair=None, rate=None):
        self.original_tagname_ = None
        self.quotedCurrencyPair = quotedCurrencyPair
        self.rate = rate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FxRate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FxRate.subclass:
            return FxRate.subclass(*args_, **kwargs_)
        else:
            return FxRate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_quotedCurrencyPair(self): return self.quotedCurrencyPair
    def set_quotedCurrencyPair(self, quotedCurrencyPair): self.quotedCurrencyPair = quotedCurrencyPair
    def get_rate(self): return self.rate
    def set_rate(self, rate): self.rate = rate
    def hasContent_(self):
        if (
            self.quotedCurrencyPair is not None or
            self.rate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FxRate', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FxRate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FxRate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FxRate'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FxRate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.quotedCurrencyPair is not None:
            self.quotedCurrencyPair.export(outfile, level, namespace_, name_='quotedCurrencyPair', pretty_print=pretty_print)
        if self.rate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srate>%s</%srate>%s' % (namespace_, self.gds_format_float(self.rate, input_name='rate'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'quotedCurrencyPair':
            obj_ = QuotedCurrencyPair.factory()
            obj_.build(child_)
            self.quotedCurrencyPair = obj_
            obj_.original_tagname_ = 'quotedCurrencyPair'
        elif nodeName_ == 'rate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'rate')
            self.rate = fval_
# end class FxRate


class FxRateSourceFixing(GeneratedsSuper):
    """Describes a rate source to be fixed and the date the fixing occurs"""
    member_data_items_ = {
        'settlementRateSource': MemberSpec_('settlementRateSource', 'FxSettlementRateSource', 0),
        'fixingDate': MemberSpec_('fixingDate', 'AdjustableDate', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, settlementRateSource=None, fixingDate=None):
        self.original_tagname_ = None
        self.settlementRateSource = settlementRateSource
        self.fixingDate = fixingDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FxRateSourceFixing)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FxRateSourceFixing.subclass:
            return FxRateSourceFixing.subclass(*args_, **kwargs_)
        else:
            return FxRateSourceFixing(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_settlementRateSource(self): return self.settlementRateSource
    def set_settlementRateSource(self, settlementRateSource): self.settlementRateSource = settlementRateSource
    def get_fixingDate(self): return self.fixingDate
    def set_fixingDate(self, fixingDate): self.fixingDate = fixingDate
    def hasContent_(self):
        if (
            self.settlementRateSource is not None or
            self.fixingDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FxRateSourceFixing', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FxRateSourceFixing')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FxRateSourceFixing', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FxRateSourceFixing'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FxRateSourceFixing', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.settlementRateSource is not None:
            self.settlementRateSource.export(outfile, level, namespace_, name_='settlementRateSource', pretty_print=pretty_print)
        if self.fixingDate is not None:
            self.fixingDate.export(outfile, level, namespace_, name_='fixingDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'settlementRateSource':
            obj_ = FxSettlementRateSource.factory()
            obj_.build(child_)
            self.settlementRateSource = obj_
            obj_.original_tagname_ = 'settlementRateSource'
        elif nodeName_ == 'fixingDate':
            obj_ = AdjustableDate.factory()
            obj_.build(child_)
            self.fixingDate = obj_
            obj_.original_tagname_ = 'fixingDate'
# end class FxRateSourceFixing


class FxSettlementRateSource(GeneratedsSuper):
    member_data_items_ = {
        'settlementRateOption': MemberSpec_('settlementRateOption', 'SettlementRateOption', 0),
        'nonstandardSettlementRate': MemberSpec_('nonstandardSettlementRate', 'FxInformationSource', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, settlementRateOption=None, nonstandardSettlementRate=None):
        self.original_tagname_ = None
        self.settlementRateOption = settlementRateOption
        self.nonstandardSettlementRate = nonstandardSettlementRate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FxSettlementRateSource)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FxSettlementRateSource.subclass:
            return FxSettlementRateSource.subclass(*args_, **kwargs_)
        else:
            return FxSettlementRateSource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_settlementRateOption(self): return self.settlementRateOption
    def set_settlementRateOption(self, settlementRateOption): self.settlementRateOption = settlementRateOption
    def get_nonstandardSettlementRate(self): return self.nonstandardSettlementRate
    def set_nonstandardSettlementRate(self, nonstandardSettlementRate): self.nonstandardSettlementRate = nonstandardSettlementRate
    def hasContent_(self):
        if (
            self.settlementRateOption is not None or
            self.nonstandardSettlementRate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FxSettlementRateSource', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FxSettlementRateSource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FxSettlementRateSource', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FxSettlementRateSource'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FxSettlementRateSource', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.settlementRateOption is not None:
            self.settlementRateOption.export(outfile, level, namespace_, name_='settlementRateOption', pretty_print=pretty_print)
        if self.nonstandardSettlementRate is not None:
            self.nonstandardSettlementRate.export(outfile, level, namespace_, name_='nonstandardSettlementRate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'settlementRateOption':
            obj_ = SettlementRateOption.factory()
            obj_.build(child_)
            self.settlementRateOption = obj_
            obj_.original_tagname_ = 'settlementRateOption'
        elif nodeName_ == 'nonstandardSettlementRate':
            obj_ = FxInformationSource.factory()
            obj_.build(child_)
            self.nonstandardSettlementRate = obj_
            obj_.original_tagname_ = 'nonstandardSettlementRate'
# end class FxSettlementRateSource


class FxSpotRateSource(GeneratedsSuper):
    """A type defining the rate source and fixing time for an fx rate."""
    member_data_items_ = {
        'primaryRateSource': MemberSpec_('primaryRateSource', 'InformationSource', 0),
        'secondaryRateSource': MemberSpec_('secondaryRateSource', 'InformationSource', 0),
        'fixingTime': MemberSpec_('fixingTime', 'BusinessCenterTime', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, primaryRateSource=None, secondaryRateSource=None, fixingTime=None):
        self.original_tagname_ = None
        self.primaryRateSource = primaryRateSource
        self.secondaryRateSource = secondaryRateSource
        self.fixingTime = fixingTime
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FxSpotRateSource)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FxSpotRateSource.subclass:
            return FxSpotRateSource.subclass(*args_, **kwargs_)
        else:
            return FxSpotRateSource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_primaryRateSource(self): return self.primaryRateSource
    def set_primaryRateSource(self, primaryRateSource): self.primaryRateSource = primaryRateSource
    def get_secondaryRateSource(self): return self.secondaryRateSource
    def set_secondaryRateSource(self, secondaryRateSource): self.secondaryRateSource = secondaryRateSource
    def get_fixingTime(self): return self.fixingTime
    def set_fixingTime(self, fixingTime): self.fixingTime = fixingTime
    def hasContent_(self):
        if (
            self.primaryRateSource is not None or
            self.secondaryRateSource is not None or
            self.fixingTime is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FxSpotRateSource', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FxSpotRateSource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FxSpotRateSource', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FxSpotRateSource'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FxSpotRateSource', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.primaryRateSource is not None:
            self.primaryRateSource.export(outfile, level, namespace_, name_='primaryRateSource', pretty_print=pretty_print)
        if self.secondaryRateSource is not None:
            self.secondaryRateSource.export(outfile, level, namespace_, name_='secondaryRateSource', pretty_print=pretty_print)
        if self.fixingTime is not None:
            self.fixingTime.export(outfile, level, namespace_, name_='fixingTime', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'primaryRateSource':
            class_obj_ = self.get_class_obj_(child_, InformationSource)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.primaryRateSource = obj_
            obj_.original_tagname_ = 'primaryRateSource'
        elif nodeName_ == 'secondaryRateSource':
            class_obj_ = self.get_class_obj_(child_, InformationSource)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.secondaryRateSource = obj_
            obj_.original_tagname_ = 'secondaryRateSource'
        elif nodeName_ == 'fixingTime':
            obj_ = BusinessCenterTime.factory()
            obj_.build(child_)
            self.fixingTime = obj_
            obj_.original_tagname_ = 'fixingTime'
# end class FxSpotRateSource


class GenericAgreement(GeneratedsSuper):
    """An entity for defining a generic agreement executed between two
    parties for any purpose."""
    member_data_items_ = {
        'type_': MemberSpec_('type_', 'AgreementType', 0),
        'version': MemberSpec_('version', 'AgreementVersion', 0),
        'date': MemberSpec_('date', 'xsd:date', 0),
        'amendmentDate': MemberSpec_('amendmentDate', 'xsd:date', 1),
        'governingLaw': MemberSpec_('governingLaw', 'GoverningLaw', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, type_=None, version=None, date=None, amendmentDate=None, governingLaw=None):
        self.original_tagname_ = None
        self.type_ = type_
        self.version = version
        if isinstance(date, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(date, '%Y-%m-%d').date()
        else:
            initvalue_ = date
        self.date = initvalue_
        if amendmentDate is None:
            self.amendmentDate = []
        else:
            self.amendmentDate = amendmentDate
        self.governingLaw = governingLaw
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GenericAgreement)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GenericAgreement.subclass:
            return GenericAgreement.subclass(*args_, **kwargs_)
        else:
            return GenericAgreement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_date(self): return self.date
    def set_date(self, date): self.date = date
    def get_amendmentDate(self): return self.amendmentDate
    def set_amendmentDate(self, amendmentDate): self.amendmentDate = amendmentDate
    def add_amendmentDate(self, value): self.amendmentDate.append(value)
    def insert_amendmentDate_at(self, index, value): self.amendmentDate.insert(index, value)
    def replace_amendmentDate_at(self, index, value): self.amendmentDate[index] = value
    def get_governingLaw(self): return self.governingLaw
    def set_governingLaw(self, governingLaw): self.governingLaw = governingLaw
    def hasContent_(self):
        if (
            self.type_ is not None or
            self.version is not None or
            self.date is not None or
            self.amendmentDate or
            self.governingLaw is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GenericAgreement', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GenericAgreement')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GenericAgreement', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GenericAgreement'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GenericAgreement', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            self.type_.export(outfile, level, namespace_, name_='type', pretty_print=pretty_print)
        if self.version is not None:
            self.version.export(outfile, level, namespace_, name_='version', pretty_print=pretty_print)
        if self.date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdate>%s</%sdate>%s' % (namespace_, self.gds_format_date(self.date, input_name='date'), namespace_, eol_))
        for amendmentDate_ in self.amendmentDate:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%samendmentDate>%s</%samendmentDate>%s' % (namespace_, self.gds_format_date(amendmentDate_, input_name='amendmentDate'), namespace_, eol_))
        if self.governingLaw is not None:
            self.governingLaw.export(outfile, level, namespace_, name_='governingLaw', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            obj_ = AgreementType.factory()
            obj_.build(child_)
            self.type_ = obj_
            obj_.original_tagname_ = 'type'
        elif nodeName_ == 'version':
            obj_ = AgreementVersion.factory()
            obj_.build(child_)
            self.version = obj_
            obj_.original_tagname_ = 'version'
        elif nodeName_ == 'date':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.date = dval_
        elif nodeName_ == 'amendmentDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.amendmentDate.append(dval_)
        elif nodeName_ == 'governingLaw':
            obj_ = GoverningLaw.factory()
            obj_.build(child_)
            self.governingLaw = obj_
            obj_.original_tagname_ = 'governingLaw'
# end class GenericAgreement


class GoverningLaw(GeneratedsSuper):
    """Identification of the law governing the transaction."""
    member_data_items_ = {
        'governingLawScheme': MemberSpec_('governingLawScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, governingLawScheme='http://www.fpml.org/coding-scheme/governing-law', valueOf_=None):
        self.original_tagname_ = None
        self.governingLawScheme = _cast(None, governingLawScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GoverningLaw)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GoverningLaw.subclass:
            return GoverningLaw.subclass(*args_, **kwargs_)
        else:
            return GoverningLaw(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_governingLawScheme(self): return self.governingLawScheme
    def set_governingLawScheme(self, governingLawScheme): self.governingLawScheme = governingLawScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GoverningLaw', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GoverningLaw')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GoverningLaw', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GoverningLaw'):
        if self.governingLawScheme != "http://www.fpml.org/coding-scheme/governing-law" and 'governingLawScheme' not in already_processed:
            already_processed.add('governingLawScheme')
            outfile.write(' governingLawScheme=%s' % (quote_attrib(self.governingLawScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='GoverningLaw', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('governingLawScheme', node)
        if value is not None and 'governingLawScheme' not in already_processed:
            already_processed.add('governingLawScheme')
            self.governingLawScheme = value
            self.validate_NonEmptyURI(self.governingLawScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class GoverningLaw


class GrossCashflow(GeneratedsSuper):
    """A payment component owed from one party to the other for the cash
    flow date. This payment component should by of only a single
    type, e.g. a fee or a cashflow from a cashflow stream."""
    member_data_items_ = {
        'cashflowId': MemberSpec_('cashflowId', 'CashflowId', 0),
        'partyTradeIdentifierReference': MemberSpec_('partyTradeIdentifierReference', 'PartyTradeIdentifierReference', 0),
        'payerPartyReference': MemberSpec_('payerPartyReference', 'PartyReference', 0),
        'payerAccountReference': MemberSpec_('payerAccountReference', 'AccountReference', 0),
        'receiverPartyReference': MemberSpec_('receiverPartyReference', 'PartyReference', 0),
        'receiverAccountReference': MemberSpec_('receiverAccountReference', 'AccountReference', 0),
        'cashflowAmount': MemberSpec_('cashflowAmount', 'Money', 0),
        'cashflowType': MemberSpec_('cashflowType', 'CashflowType', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, cashflowId=None, partyTradeIdentifierReference=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, cashflowAmount=None, cashflowType=None):
        self.original_tagname_ = None
        self.cashflowId = cashflowId
        self.partyTradeIdentifierReference = partyTradeIdentifierReference
        self.payerPartyReference = payerPartyReference
        self.payerAccountReference = payerAccountReference
        self.receiverPartyReference = receiverPartyReference
        self.receiverAccountReference = receiverAccountReference
        self.cashflowAmount = cashflowAmount
        self.cashflowType = cashflowType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GrossCashflow)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GrossCashflow.subclass:
            return GrossCashflow.subclass(*args_, **kwargs_)
        else:
            return GrossCashflow(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cashflowId(self): return self.cashflowId
    def set_cashflowId(self, cashflowId): self.cashflowId = cashflowId
    def get_partyTradeIdentifierReference(self): return self.partyTradeIdentifierReference
    def set_partyTradeIdentifierReference(self, partyTradeIdentifierReference): self.partyTradeIdentifierReference = partyTradeIdentifierReference
    def get_payerPartyReference(self): return self.payerPartyReference
    def set_payerPartyReference(self, payerPartyReference): self.payerPartyReference = payerPartyReference
    def get_payerAccountReference(self): return self.payerAccountReference
    def set_payerAccountReference(self, payerAccountReference): self.payerAccountReference = payerAccountReference
    def get_receiverPartyReference(self): return self.receiverPartyReference
    def set_receiverPartyReference(self, receiverPartyReference): self.receiverPartyReference = receiverPartyReference
    def get_receiverAccountReference(self): return self.receiverAccountReference
    def set_receiverAccountReference(self, receiverAccountReference): self.receiverAccountReference = receiverAccountReference
    def get_cashflowAmount(self): return self.cashflowAmount
    def set_cashflowAmount(self, cashflowAmount): self.cashflowAmount = cashflowAmount
    def get_cashflowType(self): return self.cashflowType
    def set_cashflowType(self, cashflowType): self.cashflowType = cashflowType
    def hasContent_(self):
        if (
            self.cashflowId is not None or
            self.partyTradeIdentifierReference is not None or
            self.payerPartyReference is not None or
            self.payerAccountReference is not None or
            self.receiverPartyReference is not None or
            self.receiverAccountReference is not None or
            self.cashflowAmount is not None or
            self.cashflowType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GrossCashflow', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GrossCashflow')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GrossCashflow', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GrossCashflow'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GrossCashflow', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cashflowId is not None:
            self.cashflowId.export(outfile, level, namespace_, name_='cashflowId', pretty_print=pretty_print)
        if self.partyTradeIdentifierReference is not None:
            self.partyTradeIdentifierReference.export(outfile, level, namespace_, name_='partyTradeIdentifierReference', pretty_print=pretty_print)
        if self.payerPartyReference is not None:
            self.payerPartyReference.export(outfile, level, namespace_, name_='payerPartyReference', pretty_print=pretty_print)
        if self.payerAccountReference is not None:
            self.payerAccountReference.export(outfile, level, namespace_, name_='payerAccountReference', pretty_print=pretty_print)
        if self.receiverPartyReference is not None:
            self.receiverPartyReference.export(outfile, level, namespace_, name_='receiverPartyReference', pretty_print=pretty_print)
        if self.receiverAccountReference is not None:
            self.receiverAccountReference.export(outfile, level, namespace_, name_='receiverAccountReference', pretty_print=pretty_print)
        if self.cashflowAmount is not None:
            self.cashflowAmount.export(outfile, level, namespace_, name_='cashflowAmount', pretty_print=pretty_print)
        if self.cashflowType is not None:
            self.cashflowType.export(outfile, level, namespace_, name_='cashflowType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cashflowId':
            obj_ = CashflowId.factory()
            obj_.build(child_)
            self.cashflowId = obj_
            obj_.original_tagname_ = 'cashflowId'
        elif nodeName_ == 'partyTradeIdentifierReference':
            obj_ = PartyTradeIdentifierReference.factory()
            obj_.build(child_)
            self.partyTradeIdentifierReference = obj_
            obj_.original_tagname_ = 'partyTradeIdentifierReference'
        elif nodeName_ == 'payerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.payerPartyReference = obj_
            obj_.original_tagname_ = 'payerPartyReference'
        elif nodeName_ == 'payerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.payerAccountReference = obj_
            obj_.original_tagname_ = 'payerAccountReference'
        elif nodeName_ == 'receiverPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.receiverPartyReference = obj_
            obj_.original_tagname_ = 'receiverPartyReference'
        elif nodeName_ == 'receiverAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.receiverAccountReference = obj_
            obj_.original_tagname_ = 'receiverAccountReference'
        elif nodeName_ == 'cashflowAmount':
            obj_ = Money.factory()
            obj_.build(child_)
            self.cashflowAmount = obj_
            obj_.original_tagname_ = 'cashflowAmount'
        elif nodeName_ == 'cashflowType':
            obj_ = CashflowType.factory()
            obj_.build(child_)
            self.cashflowType = obj_
            obj_.original_tagname_ = 'cashflowType'
# end class GrossCashflow


class IdentifiedCurrency(Currency):
    """Specifies Currency with ID attribute."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'valueOf_': MemberSpec_('valueOf_', 'Currency', 0),
    }
    subclass = None
    superclass = Currency
    def __init__(self, currencyScheme='http://www.fpml.org/coding-scheme/external/iso4217-2001-08-15', id=None, valueOf_=None):
        self.original_tagname_ = None
        super(IdentifiedCurrency, self).__init__(currencyScheme, valueOf_, )
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IdentifiedCurrency)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IdentifiedCurrency.subclass:
            return IdentifiedCurrency.subclass(*args_, **kwargs_)
        else:
            return IdentifiedCurrency(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_ or
            super(IdentifiedCurrency, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IdentifiedCurrency', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifiedCurrency')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IdentifiedCurrency', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IdentifiedCurrency'):
        super(IdentifiedCurrency, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifiedCurrency')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IdentifiedCurrency', fromsubclass_=False, pretty_print=True):
        super(IdentifiedCurrency, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        super(IdentifiedCurrency, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IdentifiedCurrency


class IdentifiedDate(GeneratedsSuper):
    """A date which can be referenced elsewhere."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'valueOf_': MemberSpec_('valueOf_', 'xsd:date', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IdentifiedDate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IdentifiedDate.subclass:
            return IdentifiedDate.subclass(*args_, **kwargs_)
        else:
            return IdentifiedDate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IdentifiedDate', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifiedDate')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IdentifiedDate', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IdentifiedDate'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IdentifiedDate', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IdentifiedDate


class IdentifiedPayerReceiver(GeneratedsSuper):
    """A type extending the PayerReceiverEnum type wih an id attribute."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'valueOf_': MemberSpec_('valueOf_', ['PayerReceiverEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IdentifiedPayerReceiver)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IdentifiedPayerReceiver.subclass:
            return IdentifiedPayerReceiver.subclass(*args_, **kwargs_)
        else:
            return IdentifiedPayerReceiver(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IdentifiedPayerReceiver', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifiedPayerReceiver')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IdentifiedPayerReceiver', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IdentifiedPayerReceiver'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IdentifiedPayerReceiver', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IdentifiedPayerReceiver


class IdentifiedRate(GeneratedsSuper):
    """A rate which can be referenced elsewhere."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'valueOf_': MemberSpec_('valueOf_', 'xsd:decimal', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IdentifiedRate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IdentifiedRate.subclass:
            return IdentifiedRate.subclass(*args_, **kwargs_)
        else:
            return IdentifiedRate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IdentifiedRate', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifiedRate')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IdentifiedRate', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IdentifiedRate'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IdentifiedRate', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IdentifiedRate


class IndependentAmount(GeneratedsSuper):
    member_data_items_ = {
        'payerPartyReference': MemberSpec_('payerPartyReference', 'PartyReference', 0),
        'payerAccountReference': MemberSpec_('payerAccountReference', 'AccountReference', 0),
        'receiverPartyReference': MemberSpec_('receiverPartyReference', 'PartyReference', 0),
        'receiverAccountReference': MemberSpec_('receiverAccountReference', 'AccountReference', 0),
        'paymentDetail': MemberSpec_('paymentDetail', 'PaymentDetail', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, paymentDetail=None):
        self.original_tagname_ = None
        self.payerPartyReference = payerPartyReference
        self.payerAccountReference = payerAccountReference
        self.receiverPartyReference = receiverPartyReference
        self.receiverAccountReference = receiverAccountReference
        if paymentDetail is None:
            self.paymentDetail = []
        else:
            self.paymentDetail = paymentDetail
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IndependentAmount)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IndependentAmount.subclass:
            return IndependentAmount.subclass(*args_, **kwargs_)
        else:
            return IndependentAmount(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_payerPartyReference(self): return self.payerPartyReference
    def set_payerPartyReference(self, payerPartyReference): self.payerPartyReference = payerPartyReference
    def get_payerAccountReference(self): return self.payerAccountReference
    def set_payerAccountReference(self, payerAccountReference): self.payerAccountReference = payerAccountReference
    def get_receiverPartyReference(self): return self.receiverPartyReference
    def set_receiverPartyReference(self, receiverPartyReference): self.receiverPartyReference = receiverPartyReference
    def get_receiverAccountReference(self): return self.receiverAccountReference
    def set_receiverAccountReference(self, receiverAccountReference): self.receiverAccountReference = receiverAccountReference
    def get_paymentDetail(self): return self.paymentDetail
    def set_paymentDetail(self, paymentDetail): self.paymentDetail = paymentDetail
    def add_paymentDetail(self, value): self.paymentDetail.append(value)
    def insert_paymentDetail_at(self, index, value): self.paymentDetail.insert(index, value)
    def replace_paymentDetail_at(self, index, value): self.paymentDetail[index] = value
    def hasContent_(self):
        if (
            self.payerPartyReference is not None or
            self.payerAccountReference is not None or
            self.receiverPartyReference is not None or
            self.receiverAccountReference is not None or
            self.paymentDetail
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IndependentAmount', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IndependentAmount')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IndependentAmount', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IndependentAmount'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IndependentAmount', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.payerPartyReference is not None:
            self.payerPartyReference.export(outfile, level, namespace_, name_='payerPartyReference', pretty_print=pretty_print)
        if self.payerAccountReference is not None:
            self.payerAccountReference.export(outfile, level, namespace_, name_='payerAccountReference', pretty_print=pretty_print)
        if self.receiverPartyReference is not None:
            self.receiverPartyReference.export(outfile, level, namespace_, name_='receiverPartyReference', pretty_print=pretty_print)
        if self.receiverAccountReference is not None:
            self.receiverAccountReference.export(outfile, level, namespace_, name_='receiverAccountReference', pretty_print=pretty_print)
        for paymentDetail_ in self.paymentDetail:
            paymentDetail_.export(outfile, level, namespace_, name_='paymentDetail', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'payerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.payerPartyReference = obj_
            obj_.original_tagname_ = 'payerPartyReference'
        elif nodeName_ == 'payerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.payerAccountReference = obj_
            obj_.original_tagname_ = 'payerAccountReference'
        elif nodeName_ == 'receiverPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.receiverPartyReference = obj_
            obj_.original_tagname_ = 'receiverPartyReference'
        elif nodeName_ == 'receiverAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.receiverAccountReference = obj_
            obj_.original_tagname_ = 'receiverAccountReference'
        elif nodeName_ == 'paymentDetail':
            obj_ = PaymentDetail.factory()
            obj_.build(child_)
            self.paymentDetail.append(obj_)
            obj_.original_tagname_ = 'paymentDetail'
# end class IndependentAmount


class IndustryClassification(GeneratedsSuper):
    """A party's industry sector classification."""
    member_data_items_ = {
        'industryClassificationScheme': MemberSpec_('industryClassificationScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, industryClassificationScheme='http://www.fpml.org/coding-scheme/regulatory-corporate-sector', valueOf_=None):
        self.original_tagname_ = None
        self.industryClassificationScheme = _cast(None, industryClassificationScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IndustryClassification)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IndustryClassification.subclass:
            return IndustryClassification.subclass(*args_, **kwargs_)
        else:
            return IndustryClassification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_industryClassificationScheme(self): return self.industryClassificationScheme
    def set_industryClassificationScheme(self, industryClassificationScheme): self.industryClassificationScheme = industryClassificationScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IndustryClassification', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IndustryClassification')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IndustryClassification', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IndustryClassification'):
        if self.industryClassificationScheme != "http://www.fpml.org/coding-scheme/regulatory-corporate-sector" and 'industryClassificationScheme' not in already_processed:
            already_processed.add('industryClassificationScheme')
            outfile.write(' industryClassificationScheme=%s' % (quote_attrib(self.industryClassificationScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IndustryClassification', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('industryClassificationScheme', node)
        if value is not None and 'industryClassificationScheme' not in already_processed:
            already_processed.add('industryClassificationScheme')
            self.industryClassificationScheme = value
            self.validate_NonEmptyURI(self.industryClassificationScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IndustryClassification


class InformationProvider(GeneratedsSuper):
    member_data_items_ = {
        'informationProviderScheme': MemberSpec_('informationProviderScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, informationProviderScheme='http://www.fpml.org/coding-scheme/information-provider', valueOf_=None):
        self.original_tagname_ = None
        self.informationProviderScheme = _cast(None, informationProviderScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InformationProvider)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InformationProvider.subclass:
            return InformationProvider.subclass(*args_, **kwargs_)
        else:
            return InformationProvider(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_informationProviderScheme(self): return self.informationProviderScheme
    def set_informationProviderScheme(self, informationProviderScheme): self.informationProviderScheme = informationProviderScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InformationProvider', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InformationProvider')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InformationProvider', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InformationProvider'):
        if self.informationProviderScheme != "http://www.fpml.org/coding-scheme/information-provider" and 'informationProviderScheme' not in already_processed:
            already_processed.add('informationProviderScheme')
            outfile.write(' informationProviderScheme=%s' % (quote_attrib(self.informationProviderScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='InformationProvider', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('informationProviderScheme', node)
        if value is not None and 'informationProviderScheme' not in already_processed:
            already_processed.add('informationProviderScheme')
            self.informationProviderScheme = value
            self.validate_NonEmptyURI(self.informationProviderScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class InformationProvider


class InformationSource(GeneratedsSuper):
    """A type defining the source for a piece of information (e.g. a rate
    refix or an fx fixing)."""
    member_data_items_ = {
        'rateSource': MemberSpec_('rateSource', 'InformationProvider', 0),
        'rateSourcePage': MemberSpec_('rateSourcePage', 'RateSourcePage', 0),
        'rateSourcePageHeading': MemberSpec_('rateSourcePageHeading', ['String', 'xsd:string'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, rateSource=None, rateSourcePage=None, rateSourcePageHeading=None, extensiontype_=None):
        self.original_tagname_ = None
        self.rateSource = rateSource
        self.rateSourcePage = rateSourcePage
        self.rateSourcePageHeading = rateSourcePageHeading
        self.validate_String(self.rateSourcePageHeading)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InformationSource)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InformationSource.subclass:
            return InformationSource.subclass(*args_, **kwargs_)
        else:
            return InformationSource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rateSource(self): return self.rateSource
    def set_rateSource(self, rateSource): self.rateSource = rateSource
    def get_rateSourcePage(self): return self.rateSourcePage
    def set_rateSourcePage(self, rateSourcePage): self.rateSourcePage = rateSourcePage
    def get_rateSourcePageHeading(self): return self.rateSourcePageHeading
    def set_rateSourcePageHeading(self, rateSourcePageHeading): self.rateSourcePageHeading = rateSourcePageHeading
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.rateSource is not None or
            self.rateSourcePage is not None or
            self.rateSourcePageHeading is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InformationSource', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InformationSource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InformationSource', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InformationSource'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='InformationSource', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.rateSource is not None:
            self.rateSource.export(outfile, level, namespace_, name_='rateSource', pretty_print=pretty_print)
        if self.rateSourcePage is not None:
            self.rateSourcePage.export(outfile, level, namespace_, name_='rateSourcePage', pretty_print=pretty_print)
        if self.rateSourcePageHeading is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srateSourcePageHeading>%s</%srateSourcePageHeading>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.rateSourcePageHeading), input_name='rateSourcePageHeading')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'rateSource':
            obj_ = InformationProvider.factory()
            obj_.build(child_)
            self.rateSource = obj_
            obj_.original_tagname_ = 'rateSource'
        elif nodeName_ == 'rateSourcePage':
            obj_ = RateSourcePage.factory()
            obj_.build(child_)
            self.rateSourcePage = obj_
            obj_.original_tagname_ = 'rateSourcePage'
        elif nodeName_ == 'rateSourcePageHeading':
            rateSourcePageHeading_ = child_.text
            rateSourcePageHeading_ = self.gds_validate_string(rateSourcePageHeading_, node, 'rateSourcePageHeading')
            self.rateSourcePageHeading = rateSourcePageHeading_
            # validate type String
            self.validate_String(self.rateSourcePageHeading)
# end class InformationSource


class InstrumentId(GeneratedsSuper):
    """A short form unique identifier for a security."""
    member_data_items_ = {
        'instrumentIdScheme': MemberSpec_('instrumentIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, instrumentIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.instrumentIdScheme = _cast(None, instrumentIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InstrumentId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InstrumentId.subclass:
            return InstrumentId.subclass(*args_, **kwargs_)
        else:
            return InstrumentId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_instrumentIdScheme(self): return self.instrumentIdScheme
    def set_instrumentIdScheme(self, instrumentIdScheme): self.instrumentIdScheme = instrumentIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InstrumentId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InstrumentId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InstrumentId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InstrumentId'):
        if self.instrumentIdScheme is not None and 'instrumentIdScheme' not in already_processed:
            already_processed.add('instrumentIdScheme')
            outfile.write(' instrumentIdScheme=%s' % (quote_attrib(self.instrumentIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='InstrumentId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('instrumentIdScheme', node)
        if value is not None and 'instrumentIdScheme' not in already_processed:
            already_processed.add('instrumentIdScheme')
            self.instrumentIdScheme = value
            self.validate_NonEmptyURI(self.instrumentIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class InstrumentId


class InterestAccrualsMethod(GeneratedsSuper):
    """A type describing the method for accruing interests on dividends.
    Can be either a fixed rate reference or a floating rate
    reference."""
    member_data_items_ = {
        'floatingRateCalculation': MemberSpec_('floatingRateCalculation', 'FloatingRateCalculation', 0),
        'fixedRate': MemberSpec_('fixedRate', 'xsd:decimal', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, floatingRateCalculation=None, fixedRate=None, extensiontype_=None):
        self.original_tagname_ = None
        self.floatingRateCalculation = floatingRateCalculation
        self.fixedRate = fixedRate
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InterestAccrualsMethod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InterestAccrualsMethod.subclass:
            return InterestAccrualsMethod.subclass(*args_, **kwargs_)
        else:
            return InterestAccrualsMethod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_floatingRateCalculation(self): return self.floatingRateCalculation
    def set_floatingRateCalculation(self, floatingRateCalculation): self.floatingRateCalculation = floatingRateCalculation
    def get_fixedRate(self): return self.fixedRate
    def set_fixedRate(self, fixedRate): self.fixedRate = fixedRate
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.floatingRateCalculation is not None or
            self.fixedRate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InterestAccrualsMethod', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InterestAccrualsMethod')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InterestAccrualsMethod', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InterestAccrualsMethod'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='InterestAccrualsMethod', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.floatingRateCalculation is not None:
            self.floatingRateCalculation.export(outfile, level, namespace_, name_='floatingRateCalculation', pretty_print=pretty_print)
        if self.fixedRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfixedRate>%s</%sfixedRate>%s' % (namespace_, self.gds_format_float(self.fixedRate, input_name='fixedRate'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'floatingRateCalculation':
            obj_ = FloatingRateCalculation.factory()
            obj_.build(child_)
            self.floatingRateCalculation = obj_
            obj_.original_tagname_ = 'floatingRateCalculation'
        elif nodeName_ == 'fixedRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'fixedRate')
            self.fixedRate = fval_
# end class InterestAccrualsMethod


class IntermediaryInformation(GeneratedsSuper):
    """A type that describes the information to identify an intermediary
    through which payment will be made by the correspondent bank to
    the ultimate beneficiary of the funds."""
    member_data_items_ = {
        'routingIds': MemberSpec_('routingIds', 'RoutingIds', 0),
        'routingExplicitDetails': MemberSpec_('routingExplicitDetails', 'RoutingExplicitDetails', 0),
        'routingIdsAndExplicitDetails': MemberSpec_('routingIdsAndExplicitDetails', 'RoutingIdsAndExplicitDetails', 0),
        'intermediarySequenceNumber': MemberSpec_('intermediarySequenceNumber', 'xsd:positiveInteger', 0),
        'intermediaryPartyReference': MemberSpec_('intermediaryPartyReference', 'PartyReference', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, routingIds=None, routingExplicitDetails=None, routingIdsAndExplicitDetails=None, intermediarySequenceNumber=None, intermediaryPartyReference=None):
        self.original_tagname_ = None
        self.routingIds = routingIds
        self.routingExplicitDetails = routingExplicitDetails
        self.routingIdsAndExplicitDetails = routingIdsAndExplicitDetails
        self.intermediarySequenceNumber = intermediarySequenceNumber
        self.intermediaryPartyReference = intermediaryPartyReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IntermediaryInformation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IntermediaryInformation.subclass:
            return IntermediaryInformation.subclass(*args_, **kwargs_)
        else:
            return IntermediaryInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_routingIds(self): return self.routingIds
    def set_routingIds(self, routingIds): self.routingIds = routingIds
    def get_routingExplicitDetails(self): return self.routingExplicitDetails
    def set_routingExplicitDetails(self, routingExplicitDetails): self.routingExplicitDetails = routingExplicitDetails
    def get_routingIdsAndExplicitDetails(self): return self.routingIdsAndExplicitDetails
    def set_routingIdsAndExplicitDetails(self, routingIdsAndExplicitDetails): self.routingIdsAndExplicitDetails = routingIdsAndExplicitDetails
    def get_intermediarySequenceNumber(self): return self.intermediarySequenceNumber
    def set_intermediarySequenceNumber(self, intermediarySequenceNumber): self.intermediarySequenceNumber = intermediarySequenceNumber
    def get_intermediaryPartyReference(self): return self.intermediaryPartyReference
    def set_intermediaryPartyReference(self, intermediaryPartyReference): self.intermediaryPartyReference = intermediaryPartyReference
    def hasContent_(self):
        if (
            self.routingIds is not None or
            self.routingExplicitDetails is not None or
            self.routingIdsAndExplicitDetails is not None or
            self.intermediarySequenceNumber is not None or
            self.intermediaryPartyReference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IntermediaryInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IntermediaryInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IntermediaryInformation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IntermediaryInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IntermediaryInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.routingIds is not None:
            self.routingIds.export(outfile, level, namespace_, name_='routingIds', pretty_print=pretty_print)
        if self.routingExplicitDetails is not None:
            self.routingExplicitDetails.export(outfile, level, namespace_, name_='routingExplicitDetails', pretty_print=pretty_print)
        if self.routingIdsAndExplicitDetails is not None:
            self.routingIdsAndExplicitDetails.export(outfile, level, namespace_, name_='routingIdsAndExplicitDetails', pretty_print=pretty_print)
        if self.intermediarySequenceNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sintermediarySequenceNumber>%s</%sintermediarySequenceNumber>%s' % (namespace_, self.gds_format_integer(self.intermediarySequenceNumber, input_name='intermediarySequenceNumber'), namespace_, eol_))
        if self.intermediaryPartyReference is not None:
            self.intermediaryPartyReference.export(outfile, level, namespace_, name_='intermediaryPartyReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'routingIds':
            obj_ = RoutingIds.factory()
            obj_.build(child_)
            self.routingIds = obj_
            obj_.original_tagname_ = 'routingIds'
        elif nodeName_ == 'routingExplicitDetails':
            obj_ = RoutingExplicitDetails.factory()
            obj_.build(child_)
            self.routingExplicitDetails = obj_
            obj_.original_tagname_ = 'routingExplicitDetails'
        elif nodeName_ == 'routingIdsAndExplicitDetails':
            obj_ = RoutingIdsAndExplicitDetails.factory()
            obj_.build(child_)
            self.routingIdsAndExplicitDetails = obj_
            obj_.original_tagname_ = 'routingIdsAndExplicitDetails'
        elif nodeName_ == 'intermediarySequenceNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'intermediarySequenceNumber')
            self.intermediarySequenceNumber = ival_
        elif nodeName_ == 'intermediaryPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.intermediaryPartyReference = obj_
            obj_.original_tagname_ = 'intermediaryPartyReference'
# end class IntermediaryInformation


class InterpolationMethod(GeneratedsSuper):
    """The type of interpolation used."""
    member_data_items_ = {
        'interpolationMethodScheme': MemberSpec_('interpolationMethodScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, interpolationMethodScheme='http://www.fpml.org/coding-scheme/interpolation-method', valueOf_=None):
        self.original_tagname_ = None
        self.interpolationMethodScheme = _cast(None, interpolationMethodScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InterpolationMethod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InterpolationMethod.subclass:
            return InterpolationMethod.subclass(*args_, **kwargs_)
        else:
            return InterpolationMethod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_interpolationMethodScheme(self): return self.interpolationMethodScheme
    def set_interpolationMethodScheme(self, interpolationMethodScheme): self.interpolationMethodScheme = interpolationMethodScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InterpolationMethod', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InterpolationMethod')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InterpolationMethod', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InterpolationMethod'):
        if self.interpolationMethodScheme != "http://www.fpml.org/coding-scheme/interpolation-method" and 'interpolationMethodScheme' not in already_processed:
            already_processed.add('interpolationMethodScheme')
            outfile.write(' interpolationMethodScheme=%s' % (quote_attrib(self.interpolationMethodScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='InterpolationMethod', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('interpolationMethodScheme', node)
        if value is not None and 'interpolationMethodScheme' not in already_processed:
            already_processed.add('interpolationMethodScheme')
            self.interpolationMethodScheme = value
            self.validate_NonEmptyURI(self.interpolationMethodScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class InterpolationMethod


class Language(GeneratedsSuper):
    """The data type used for indicating the language of the resource,
    described using the ISO 639-2/T Code."""
    member_data_items_ = {
        'languageScheme': MemberSpec_('languageScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, languageScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.languageScheme = _cast(None, languageScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Language)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Language.subclass:
            return Language.subclass(*args_, **kwargs_)
        else:
            return Language(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_languageScheme(self): return self.languageScheme
    def set_languageScheme(self, languageScheme): self.languageScheme = languageScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Language', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Language')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Language', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Language'):
        if self.languageScheme is not None and 'languageScheme' not in already_processed:
            already_processed.add('languageScheme')
            outfile.write(' languageScheme=%s' % (quote_attrib(self.languageScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Language', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('languageScheme', node)
        if value is not None and 'languageScheme' not in already_processed:
            already_processed.add('languageScheme')
            self.languageScheme = value
            self.validate_NonEmptyURI(self.languageScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Language


class Leg(GeneratedsSuper):
    """A supertype of leg. All swap legs extend this type."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Leg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Leg.subclass:
            return Leg.subclass(*args_, **kwargs_)
        else:
            return Leg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Leg', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Leg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Leg', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Leg'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Leg', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Leg


class LegId(GeneratedsSuper):
    """Leg identity."""
    member_data_items_ = {
        'legIdScheme': MemberSpec_('legIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Token60', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, legIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.legIdScheme = _cast(None, legIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LegId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LegId.subclass:
            return LegId.subclass(*args_, **kwargs_)
        else:
            return LegId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_legIdScheme(self): return self.legIdScheme
    def set_legIdScheme(self, legIdScheme): self.legIdScheme = legIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LegId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LegId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LegId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LegId'):
        if self.legIdScheme is not None and 'legIdScheme' not in already_processed:
            already_processed.add('legIdScheme')
            outfile.write(' legIdScheme=%s' % (quote_attrib(self.legIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LegId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('legIdScheme', node)
        if value is not None and 'legIdScheme' not in already_processed:
            already_processed.add('legIdScheme')
            self.legIdScheme = value
            self.validate_NonEmptyURI(self.legIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LegId


class LegIdentifier(GeneratedsSuper):
    """Version aware identification of a leg."""
    member_data_items_ = {
        'legId': MemberSpec_('legId', 'LegId', 0),
        'version': MemberSpec_('version', 'xsd:nonNegativeInteger', 0),
        'effectiveDate': MemberSpec_('effectiveDate', 'IdentifiedDate', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, legId=None, version=None, effectiveDate=None):
        self.original_tagname_ = None
        self.legId = legId
        self.version = version
        self.effectiveDate = effectiveDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LegIdentifier)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LegIdentifier.subclass:
            return LegIdentifier.subclass(*args_, **kwargs_)
        else:
            return LegIdentifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_legId(self): return self.legId
    def set_legId(self, legId): self.legId = legId
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_effectiveDate(self): return self.effectiveDate
    def set_effectiveDate(self, effectiveDate): self.effectiveDate = effectiveDate
    def hasContent_(self):
        if (
            self.legId is not None or
            self.version is not None or
            self.effectiveDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LegIdentifier', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LegIdentifier')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LegIdentifier', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LegIdentifier'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LegIdentifier', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.legId is not None:
            self.legId.export(outfile, level, namespace_, name_='legId', pretty_print=pretty_print)
        if self.version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sversion>%s</%sversion>%s' % (namespace_, self.gds_format_integer(self.version, input_name='version'), namespace_, eol_))
        if self.effectiveDate is not None:
            self.effectiveDate.export(outfile, level, namespace_, name_='effectiveDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'legId':
            obj_ = LegId.factory()
            obj_.build(child_)
            self.legId = obj_
            obj_.original_tagname_ = 'legId'
        elif nodeName_ == 'version':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'version')
            self.version = ival_
        elif nodeName_ == 'effectiveDate':
            obj_ = IdentifiedDate.factory()
            obj_.build(child_)
            self.effectiveDate = obj_
            obj_.original_tagname_ = 'effectiveDate'
# end class LegIdentifier


class LegalEntity(GeneratedsSuper):
    """A type defining a legal entity."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'entityName': MemberSpec_('entityName', 'EntityName', 0),
        'entityId': MemberSpec_('entityId', 'EntityId', 1),
        'entityId': MemberSpec_('entityId', 'EntityId', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, entityName=None, entityId=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.entityName = entityName
        if entityId is None:
            self.entityId = []
        else:
            self.entityId = entityId
        if entityId is None:
            self.entityId = []
        else:
            self.entityId = entityId
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LegalEntity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LegalEntity.subclass:
            return LegalEntity.subclass(*args_, **kwargs_)
        else:
            return LegalEntity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_entityName(self): return self.entityName
    def set_entityName(self, entityName): self.entityName = entityName
    def get_entityId(self): return self.entityId
    def set_entityId(self, entityId): self.entityId = entityId
    def add_entityId(self, value): self.entityId.append(value)
    def insert_entityId_at(self, index, value): self.entityId.insert(index, value)
    def replace_entityId_at(self, index, value): self.entityId[index] = value
    def get_entityId(self): return self.entityId
    def set_entityId(self, entityId): self.entityId = entityId
    def add_entityId(self, value): self.entityId.append(value)
    def insert_entityId_at(self, index, value): self.entityId.insert(index, value)
    def replace_entityId_at(self, index, value): self.entityId[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.entityName is not None or
            self.entityId or
            self.entityId
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LegalEntity', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LegalEntity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LegalEntity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LegalEntity'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LegalEntity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.entityName is not None:
            self.entityName.export(outfile, level, namespace_, name_='entityName', pretty_print=pretty_print)
        for entityId_ in self.entityId:
            entityId_.export(outfile, level, namespace_, name_='entityId', pretty_print=pretty_print)
        for entityId_ in self.entityId:
            entityId_.export(outfile, level, namespace_, name_='entityId', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'entityName':
            obj_ = EntityName.factory()
            obj_.build(child_)
            self.entityName = obj_
            obj_.original_tagname_ = 'entityName'
        elif nodeName_ == 'entityId':
            obj_ = EntityId.factory()
            obj_.build(child_)
            self.entityId.append(obj_)
            obj_.original_tagname_ = 'entityId'
        elif nodeName_ == 'entityId':
            obj_ = EntityId.factory()
            obj_.build(child_)
            self.entityId.append(obj_)
            obj_.original_tagname_ = 'entityId'
# end class LegalEntity


class MainPublication(GeneratedsSuper):
    """A type to define the main publication source."""
    member_data_items_ = {
        'mainPublicationScheme': MemberSpec_('mainPublicationScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, mainPublicationScheme='http://www.fpml.org/coding-scheme/inflation-main-publication', valueOf_=None):
        self.original_tagname_ = None
        self.mainPublicationScheme = _cast(None, mainPublicationScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MainPublication)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MainPublication.subclass:
            return MainPublication.subclass(*args_, **kwargs_)
        else:
            return MainPublication(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mainPublicationScheme(self): return self.mainPublicationScheme
    def set_mainPublicationScheme(self, mainPublicationScheme): self.mainPublicationScheme = mainPublicationScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MainPublication', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MainPublication')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MainPublication', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MainPublication'):
        if self.mainPublicationScheme != "http://www.fpml.org/coding-scheme/inflation-main-publication" and 'mainPublicationScheme' not in already_processed:
            already_processed.add('mainPublicationScheme')
            outfile.write(' mainPublicationScheme=%s' % (quote_attrib(self.mainPublicationScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MainPublication', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mainPublicationScheme', node)
        if value is not None and 'mainPublicationScheme' not in already_processed:
            already_processed.add('mainPublicationScheme')
            self.mainPublicationScheme = value
            self.validate_NonEmptyURI(self.mainPublicationScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MainPublication


class ManualExercise(GeneratedsSuper):
    """A type defining manual exercise, i.e. that the option buyer
    counterparty must give notice to the option seller of exercise."""
    member_data_items_ = {
        'exerciseNotice': MemberSpec_('exerciseNotice', 'ExerciseNotice', 0),
        'fallbackExercise': MemberSpec_('fallbackExercise', 'xsd:boolean', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, exerciseNotice=None, fallbackExercise=None):
        self.original_tagname_ = None
        self.exerciseNotice = exerciseNotice
        self.fallbackExercise = fallbackExercise
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ManualExercise)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ManualExercise.subclass:
            return ManualExercise.subclass(*args_, **kwargs_)
        else:
            return ManualExercise(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_exerciseNotice(self): return self.exerciseNotice
    def set_exerciseNotice(self, exerciseNotice): self.exerciseNotice = exerciseNotice
    def get_fallbackExercise(self): return self.fallbackExercise
    def set_fallbackExercise(self, fallbackExercise): self.fallbackExercise = fallbackExercise
    def hasContent_(self):
        if (
            self.exerciseNotice is not None or
            self.fallbackExercise is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ManualExercise', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ManualExercise')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ManualExercise', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ManualExercise'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ManualExercise', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.exerciseNotice is not None:
            self.exerciseNotice.export(outfile, level, namespace_, name_='exerciseNotice', pretty_print=pretty_print)
        if self.fallbackExercise is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfallbackExercise>%s</%sfallbackExercise>%s' % (namespace_, self.gds_format_boolean(self.fallbackExercise, input_name='fallbackExercise'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'exerciseNotice':
            obj_ = ExerciseNotice.factory()
            obj_.build(child_)
            self.exerciseNotice = obj_
            obj_.original_tagname_ = 'exerciseNotice'
        elif nodeName_ == 'fallbackExercise':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'fallbackExercise')
            self.fallbackExercise = ival_
# end class ManualExercise


class MasterAgreement(GeneratedsSuper):
    """An entity for defining the agreement executed between the parties
    and intended to govern all OTC derivatives transactions between
    those parties."""
    member_data_items_ = {
        'masterAgreementId': MemberSpec_('masterAgreementId', 'MasterAgreementId', 1),
        'masterAgreementType': MemberSpec_('masterAgreementType', 'MasterAgreementType', 0),
        'masterAgreementVersion': MemberSpec_('masterAgreementVersion', 'MasterAgreementVersion', 0),
        'masterAgreementDate': MemberSpec_('masterAgreementDate', 'xsd:date', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, masterAgreementId=None, masterAgreementType=None, masterAgreementVersion=None, masterAgreementDate=None):
        self.original_tagname_ = None
        if masterAgreementId is None:
            self.masterAgreementId = []
        else:
            self.masterAgreementId = masterAgreementId
        self.masterAgreementType = masterAgreementType
        self.masterAgreementVersion = masterAgreementVersion
        if isinstance(masterAgreementDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(masterAgreementDate, '%Y-%m-%d').date()
        else:
            initvalue_ = masterAgreementDate
        self.masterAgreementDate = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MasterAgreement)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MasterAgreement.subclass:
            return MasterAgreement.subclass(*args_, **kwargs_)
        else:
            return MasterAgreement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_masterAgreementId(self): return self.masterAgreementId
    def set_masterAgreementId(self, masterAgreementId): self.masterAgreementId = masterAgreementId
    def add_masterAgreementId(self, value): self.masterAgreementId.append(value)
    def insert_masterAgreementId_at(self, index, value): self.masterAgreementId.insert(index, value)
    def replace_masterAgreementId_at(self, index, value): self.masterAgreementId[index] = value
    def get_masterAgreementType(self): return self.masterAgreementType
    def set_masterAgreementType(self, masterAgreementType): self.masterAgreementType = masterAgreementType
    def get_masterAgreementVersion(self): return self.masterAgreementVersion
    def set_masterAgreementVersion(self, masterAgreementVersion): self.masterAgreementVersion = masterAgreementVersion
    def get_masterAgreementDate(self): return self.masterAgreementDate
    def set_masterAgreementDate(self, masterAgreementDate): self.masterAgreementDate = masterAgreementDate
    def hasContent_(self):
        if (
            self.masterAgreementId or
            self.masterAgreementType is not None or
            self.masterAgreementVersion is not None or
            self.masterAgreementDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MasterAgreement', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MasterAgreement')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MasterAgreement', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MasterAgreement'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MasterAgreement', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for masterAgreementId_ in self.masterAgreementId:
            masterAgreementId_.export(outfile, level, namespace_, name_='masterAgreementId', pretty_print=pretty_print)
        if self.masterAgreementType is not None:
            self.masterAgreementType.export(outfile, level, namespace_, name_='masterAgreementType', pretty_print=pretty_print)
        if self.masterAgreementVersion is not None:
            self.masterAgreementVersion.export(outfile, level, namespace_, name_='masterAgreementVersion', pretty_print=pretty_print)
        if self.masterAgreementDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smasterAgreementDate>%s</%smasterAgreementDate>%s' % (namespace_, self.gds_format_date(self.masterAgreementDate, input_name='masterAgreementDate'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'masterAgreementId':
            obj_ = MasterAgreementId.factory()
            obj_.build(child_)
            self.masterAgreementId.append(obj_)
            obj_.original_tagname_ = 'masterAgreementId'
        elif nodeName_ == 'masterAgreementType':
            obj_ = MasterAgreementType.factory()
            obj_.build(child_)
            self.masterAgreementType = obj_
            obj_.original_tagname_ = 'masterAgreementType'
        elif nodeName_ == 'masterAgreementVersion':
            obj_ = MasterAgreementVersion.factory()
            obj_.build(child_)
            self.masterAgreementVersion = obj_
            obj_.original_tagname_ = 'masterAgreementVersion'
        elif nodeName_ == 'masterAgreementDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.masterAgreementDate = dval_
# end class MasterAgreement


class MasterAgreementId(GeneratedsSuper):
    """A master agreement identifier allocated by a party. FpML does not
    define the domain values associated with this element. Note that
    the domain values for this element are not strictly an
    enumerated list."""
    member_data_items_ = {
        'masterAgreementIdScheme': MemberSpec_('masterAgreementIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, masterAgreementIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.masterAgreementIdScheme = _cast(None, masterAgreementIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MasterAgreementId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MasterAgreementId.subclass:
            return MasterAgreementId.subclass(*args_, **kwargs_)
        else:
            return MasterAgreementId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_masterAgreementIdScheme(self): return self.masterAgreementIdScheme
    def set_masterAgreementIdScheme(self, masterAgreementIdScheme): self.masterAgreementIdScheme = masterAgreementIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MasterAgreementId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MasterAgreementId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MasterAgreementId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MasterAgreementId'):
        if self.masterAgreementIdScheme is not None and 'masterAgreementIdScheme' not in already_processed:
            already_processed.add('masterAgreementIdScheme')
            outfile.write(' masterAgreementIdScheme=%s' % (quote_attrib(self.masterAgreementIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MasterAgreementId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('masterAgreementIdScheme', node)
        if value is not None and 'masterAgreementIdScheme' not in already_processed:
            already_processed.add('masterAgreementIdScheme')
            self.masterAgreementIdScheme = value
            self.validate_NonEmptyURI(self.masterAgreementIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MasterAgreementId


class MasterAgreementType(GeneratedsSuper):
    member_data_items_ = {
        'masterAgreementTypeScheme': MemberSpec_('masterAgreementTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, masterAgreementTypeScheme='http://www.fpml.org/coding-scheme/master-agreement-type', valueOf_=None):
        self.original_tagname_ = None
        self.masterAgreementTypeScheme = _cast(None, masterAgreementTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MasterAgreementType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MasterAgreementType.subclass:
            return MasterAgreementType.subclass(*args_, **kwargs_)
        else:
            return MasterAgreementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_masterAgreementTypeScheme(self): return self.masterAgreementTypeScheme
    def set_masterAgreementTypeScheme(self, masterAgreementTypeScheme): self.masterAgreementTypeScheme = masterAgreementTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MasterAgreementType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MasterAgreementType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MasterAgreementType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MasterAgreementType'):
        if self.masterAgreementTypeScheme != "http://www.fpml.org/coding-scheme/master-agreement-type" and 'masterAgreementTypeScheme' not in already_processed:
            already_processed.add('masterAgreementTypeScheme')
            outfile.write(' masterAgreementTypeScheme=%s' % (quote_attrib(self.masterAgreementTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MasterAgreementType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('masterAgreementTypeScheme', node)
        if value is not None and 'masterAgreementTypeScheme' not in already_processed:
            already_processed.add('masterAgreementTypeScheme')
            self.masterAgreementTypeScheme = value
            self.validate_NonEmptyURI(self.masterAgreementTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MasterAgreementType


class MasterAgreementVersion(GeneratedsSuper):
    member_data_items_ = {
        'masterAgreementVersionScheme': MemberSpec_('masterAgreementVersionScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, masterAgreementVersionScheme='http://www.fpml.org/coding-scheme/master-agreement-version', valueOf_=None):
        self.original_tagname_ = None
        self.masterAgreementVersionScheme = _cast(None, masterAgreementVersionScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MasterAgreementVersion)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MasterAgreementVersion.subclass:
            return MasterAgreementVersion.subclass(*args_, **kwargs_)
        else:
            return MasterAgreementVersion(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_masterAgreementVersionScheme(self): return self.masterAgreementVersionScheme
    def set_masterAgreementVersionScheme(self, masterAgreementVersionScheme): self.masterAgreementVersionScheme = masterAgreementVersionScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MasterAgreementVersion', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MasterAgreementVersion')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MasterAgreementVersion', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MasterAgreementVersion'):
        if self.masterAgreementVersionScheme != "http://www.fpml.org/coding-scheme/master-agreement-version" and 'masterAgreementVersionScheme' not in already_processed:
            already_processed.add('masterAgreementVersionScheme')
            outfile.write(' masterAgreementVersionScheme=%s' % (quote_attrib(self.masterAgreementVersionScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MasterAgreementVersion', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('masterAgreementVersionScheme', node)
        if value is not None and 'masterAgreementVersionScheme' not in already_processed:
            already_processed.add('masterAgreementVersionScheme')
            self.masterAgreementVersionScheme = value
            self.validate_NonEmptyURI(self.masterAgreementVersionScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MasterAgreementVersion


class MasterConfirmation(GeneratedsSuper):
    """An entity for defining the master confirmation agreement executed
    between the parties."""
    member_data_items_ = {
        'masterConfirmationType': MemberSpec_('masterConfirmationType', 'MasterConfirmationType', 0),
        'masterConfirmationDate': MemberSpec_('masterConfirmationDate', 'xsd:date', 0),
        'masterConfirmationAnnexDate': MemberSpec_('masterConfirmationAnnexDate', 'xsd:date', 0),
        'masterConfirmationAnnexType': MemberSpec_('masterConfirmationAnnexType', 'MasterConfirmationAnnexType', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, masterConfirmationType=None, masterConfirmationDate=None, masterConfirmationAnnexDate=None, masterConfirmationAnnexType=None):
        self.original_tagname_ = None
        self.masterConfirmationType = masterConfirmationType
        if isinstance(masterConfirmationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(masterConfirmationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = masterConfirmationDate
        self.masterConfirmationDate = initvalue_
        if isinstance(masterConfirmationAnnexDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(masterConfirmationAnnexDate, '%Y-%m-%d').date()
        else:
            initvalue_ = masterConfirmationAnnexDate
        self.masterConfirmationAnnexDate = initvalue_
        self.masterConfirmationAnnexType = masterConfirmationAnnexType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MasterConfirmation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MasterConfirmation.subclass:
            return MasterConfirmation.subclass(*args_, **kwargs_)
        else:
            return MasterConfirmation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_masterConfirmationType(self): return self.masterConfirmationType
    def set_masterConfirmationType(self, masterConfirmationType): self.masterConfirmationType = masterConfirmationType
    def get_masterConfirmationDate(self): return self.masterConfirmationDate
    def set_masterConfirmationDate(self, masterConfirmationDate): self.masterConfirmationDate = masterConfirmationDate
    def get_masterConfirmationAnnexDate(self): return self.masterConfirmationAnnexDate
    def set_masterConfirmationAnnexDate(self, masterConfirmationAnnexDate): self.masterConfirmationAnnexDate = masterConfirmationAnnexDate
    def get_masterConfirmationAnnexType(self): return self.masterConfirmationAnnexType
    def set_masterConfirmationAnnexType(self, masterConfirmationAnnexType): self.masterConfirmationAnnexType = masterConfirmationAnnexType
    def hasContent_(self):
        if (
            self.masterConfirmationType is not None or
            self.masterConfirmationDate is not None or
            self.masterConfirmationAnnexDate is not None or
            self.masterConfirmationAnnexType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MasterConfirmation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MasterConfirmation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MasterConfirmation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MasterConfirmation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MasterConfirmation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.masterConfirmationType is not None:
            self.masterConfirmationType.export(outfile, level, namespace_, name_='masterConfirmationType', pretty_print=pretty_print)
        if self.masterConfirmationDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smasterConfirmationDate>%s</%smasterConfirmationDate>%s' % (namespace_, self.gds_format_date(self.masterConfirmationDate, input_name='masterConfirmationDate'), namespace_, eol_))
        if self.masterConfirmationAnnexDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smasterConfirmationAnnexDate>%s</%smasterConfirmationAnnexDate>%s' % (namespace_, self.gds_format_date(self.masterConfirmationAnnexDate, input_name='masterConfirmationAnnexDate'), namespace_, eol_))
        if self.masterConfirmationAnnexType is not None:
            self.masterConfirmationAnnexType.export(outfile, level, namespace_, name_='masterConfirmationAnnexType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'masterConfirmationType':
            obj_ = MasterConfirmationType.factory()
            obj_.build(child_)
            self.masterConfirmationType = obj_
            obj_.original_tagname_ = 'masterConfirmationType'
        elif nodeName_ == 'masterConfirmationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.masterConfirmationDate = dval_
        elif nodeName_ == 'masterConfirmationAnnexDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.masterConfirmationAnnexDate = dval_
        elif nodeName_ == 'masterConfirmationAnnexType':
            obj_ = MasterConfirmationAnnexType.factory()
            obj_.build(child_)
            self.masterConfirmationAnnexType = obj_
            obj_.original_tagname_ = 'masterConfirmationAnnexType'
# end class MasterConfirmation


class MasterConfirmationAnnexType(GeneratedsSuper):
    member_data_items_ = {
        'masterConfirmationAnnexTypeScheme': MemberSpec_('masterConfirmationAnnexTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, masterConfirmationAnnexTypeScheme='http://www.fpml.org/coding-scheme/master-confirmation-annex-type', valueOf_=None):
        self.original_tagname_ = None
        self.masterConfirmationAnnexTypeScheme = _cast(None, masterConfirmationAnnexTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MasterConfirmationAnnexType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MasterConfirmationAnnexType.subclass:
            return MasterConfirmationAnnexType.subclass(*args_, **kwargs_)
        else:
            return MasterConfirmationAnnexType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_masterConfirmationAnnexTypeScheme(self): return self.masterConfirmationAnnexTypeScheme
    def set_masterConfirmationAnnexTypeScheme(self, masterConfirmationAnnexTypeScheme): self.masterConfirmationAnnexTypeScheme = masterConfirmationAnnexTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MasterConfirmationAnnexType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MasterConfirmationAnnexType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MasterConfirmationAnnexType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MasterConfirmationAnnexType'):
        if self.masterConfirmationAnnexTypeScheme != "http://www.fpml.org/coding-scheme/master-confirmation-annex-type" and 'masterConfirmationAnnexTypeScheme' not in already_processed:
            already_processed.add('masterConfirmationAnnexTypeScheme')
            outfile.write(' masterConfirmationAnnexTypeScheme=%s' % (quote_attrib(self.masterConfirmationAnnexTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MasterConfirmationAnnexType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('masterConfirmationAnnexTypeScheme', node)
        if value is not None and 'masterConfirmationAnnexTypeScheme' not in already_processed:
            already_processed.add('masterConfirmationAnnexTypeScheme')
            self.masterConfirmationAnnexTypeScheme = value
            self.validate_NonEmptyURI(self.masterConfirmationAnnexTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MasterConfirmationAnnexType


class MasterConfirmationType(GeneratedsSuper):
    member_data_items_ = {
        'masterConfirmationTypeScheme': MemberSpec_('masterConfirmationTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, masterConfirmationTypeScheme='http://www.fpml.org/coding-scheme/master-confirmation-type', valueOf_=None):
        self.original_tagname_ = None
        self.masterConfirmationTypeScheme = _cast(None, masterConfirmationTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MasterConfirmationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MasterConfirmationType.subclass:
            return MasterConfirmationType.subclass(*args_, **kwargs_)
        else:
            return MasterConfirmationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_masterConfirmationTypeScheme(self): return self.masterConfirmationTypeScheme
    def set_masterConfirmationTypeScheme(self, masterConfirmationTypeScheme): self.masterConfirmationTypeScheme = masterConfirmationTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MasterConfirmationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MasterConfirmationType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MasterConfirmationType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MasterConfirmationType'):
        if self.masterConfirmationTypeScheme != "http://www.fpml.org/coding-scheme/master-confirmation-type" and 'masterConfirmationTypeScheme' not in already_processed:
            already_processed.add('masterConfirmationTypeScheme')
            outfile.write(' masterConfirmationTypeScheme=%s' % (quote_attrib(self.masterConfirmationTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MasterConfirmationType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('masterConfirmationTypeScheme', node)
        if value is not None and 'masterConfirmationTypeScheme' not in already_processed:
            already_processed.add('masterConfirmationTypeScheme')
            self.masterConfirmationTypeScheme = value
            self.validate_NonEmptyURI(self.masterConfirmationTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MasterConfirmationType


class MatchId(GeneratedsSuper):
    """An identifier used to identify matched cashflows."""
    member_data_items_ = {
        'matchIdScheme': MemberSpec_('matchIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, matchIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.matchIdScheme = _cast(None, matchIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MatchId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MatchId.subclass:
            return MatchId.subclass(*args_, **kwargs_)
        else:
            return MatchId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_matchIdScheme(self): return self.matchIdScheme
    def set_matchIdScheme(self, matchIdScheme): self.matchIdScheme = matchIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MatchId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MatchId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MatchId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MatchId'):
        if self.matchIdScheme is not None and 'matchIdScheme' not in already_processed:
            already_processed.add('matchIdScheme')
            outfile.write(' matchIdScheme=%s' % (quote_attrib(self.matchIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MatchId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('matchIdScheme', node)
        if value is not None and 'matchIdScheme' not in already_processed:
            already_processed.add('matchIdScheme')
            self.matchIdScheme = value
            self.validate_NonEmptyURI(self.matchIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MatchId


class Math(GeneratedsSuper):
    """A type defining a mathematical expression."""
    member_data_items_ = {
        '': MemberSpec_('', 'xsd:string', 1),
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Math)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Math.subclass:
            return Math.subclass(*args_, **kwargs_)
        else:
            return Math(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Math', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Math')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Math', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Math'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Math', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class Math


class MatrixType(GeneratedsSuper):
    member_data_items_ = {
        'matrixTypeScheme': MemberSpec_('matrixTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, matrixTypeScheme='http://www.fpml.org/coding-scheme/matrix-type', valueOf_=None):
        self.original_tagname_ = None
        self.matrixTypeScheme = _cast(None, matrixTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MatrixType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MatrixType.subclass:
            return MatrixType.subclass(*args_, **kwargs_)
        else:
            return MatrixType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_matrixTypeScheme(self): return self.matrixTypeScheme
    def set_matrixTypeScheme(self, matrixTypeScheme): self.matrixTypeScheme = matrixTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MatrixType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MatrixType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MatrixType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MatrixType'):
        if self.matrixTypeScheme != "http://www.fpml.org/coding-scheme/matrix-type" and 'matrixTypeScheme' not in already_processed:
            already_processed.add('matrixTypeScheme')
            outfile.write(' matrixTypeScheme=%s' % (quote_attrib(self.matrixTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MatrixType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('matrixTypeScheme', node)
        if value is not None and 'matrixTypeScheme' not in already_processed:
            already_processed.add('matrixTypeScheme')
            self.matrixTypeScheme = value
            self.validate_NonEmptyURI(self.matrixTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MatrixType


class MatrixTerm(GeneratedsSuper):
    member_data_items_ = {
        'matrixTermScheme': MemberSpec_('matrixTermScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, matrixTermScheme='http://www.fpml.org/coding-scheme/credit-matrix-transaction-type', valueOf_=None):
        self.original_tagname_ = None
        self.matrixTermScheme = _cast(None, matrixTermScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MatrixTerm)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MatrixTerm.subclass:
            return MatrixTerm.subclass(*args_, **kwargs_)
        else:
            return MatrixTerm(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_matrixTermScheme(self): return self.matrixTermScheme
    def set_matrixTermScheme(self, matrixTermScheme): self.matrixTermScheme = matrixTermScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MatrixTerm', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MatrixTerm')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MatrixTerm', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MatrixTerm'):
        if self.matrixTermScheme != "http://www.fpml.org/coding-scheme/credit-matrix-transaction-type" and 'matrixTermScheme' not in already_processed:
            already_processed.add('matrixTermScheme')
            outfile.write(' matrixTermScheme=%s' % (quote_attrib(self.matrixTermScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MatrixTerm', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('matrixTermScheme', node)
        if value is not None and 'matrixTermScheme' not in already_processed:
            already_processed.add('matrixTermScheme')
            self.matrixTermScheme = value
            self.validate_NonEmptyURI(self.matrixTermScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MatrixTerm


class MimeType(GeneratedsSuper):
    """The type that indicates the type of media used to store the content.
    MimeType is used to determine the software product(s) that can
    read the content. MIME types are described in RFC 2046."""
    member_data_items_ = {
        'mimeTypeScheme': MemberSpec_('mimeTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, mimeTypeScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.mimeTypeScheme = _cast(None, mimeTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MimeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MimeType.subclass:
            return MimeType.subclass(*args_, **kwargs_)
        else:
            return MimeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mimeTypeScheme(self): return self.mimeTypeScheme
    def set_mimeTypeScheme(self, mimeTypeScheme): self.mimeTypeScheme = mimeTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MimeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MimeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MimeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MimeType'):
        if self.mimeTypeScheme is not None and 'mimeTypeScheme' not in already_processed:
            already_processed.add('mimeTypeScheme')
            outfile.write(' mimeTypeScheme=%s' % (quote_attrib(self.mimeTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MimeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mimeTypeScheme', node)
        if value is not None and 'mimeTypeScheme' not in already_processed:
            already_processed.add('mimeTypeScheme')
            self.mimeTypeScheme = value
            self.validate_NonEmptyURI(self.mimeTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MimeType


class MoneyBase(GeneratedsSuper):
    """Abstract base class for all money types."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'currency': MemberSpec_('currency', 'Currency', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, currency=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.currency = currency
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MoneyBase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MoneyBase.subclass:
            return MoneyBase.subclass(*args_, **kwargs_)
        else:
            return MoneyBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.currency is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MoneyBase', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MoneyBase')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MoneyBase', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MoneyBase'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='MoneyBase', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.currency is not None:
            self.currency.export(outfile, level, namespace_, name_='currency', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'currency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
# end class MoneyBase


class MultipleExercise(GeneratedsSuper):
    """A type defining multiple exercises. As defining in the 2000 ISDA
    Definitions, Section 12.4. Multiple Exercise, the buyer of the
    option has the right to exercise all or less than all the
    unexercised notional amount of the underlying swap on one or
    more days in the exercise period, but on any such day may not
    exercise less than the minimum notional amount or more than the
    maximum notional amount, and if an integral multiple amount is
    specified, the notional exercised must be equal to or, be an
    integral multiple of, the integral multiple amount."""
    member_data_items_ = {
        'notionalReference': MemberSpec_('notionalReference', 'NotionalReference', 1),
        'integralMultipleAmount': MemberSpec_('integralMultipleAmount', 'xsd:decimal', 0),
        'minimumNotionalAmount': MemberSpec_('minimumNotionalAmount', 'xsd:decimal', 0),
        'minimumNumberOfOptions': MemberSpec_('minimumNumberOfOptions', 'xsd:nonNegativeInteger', 0),
        'maximumNotionalAmount': MemberSpec_('maximumNotionalAmount', 'xsd:decimal', 0),
        'maximumNumberOfOptions': MemberSpec_('maximumNumberOfOptions', ['NonNegativeDecimal', 'xsd:decimal'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, notionalReference=None, integralMultipleAmount=None, minimumNotionalAmount=None, minimumNumberOfOptions=None, maximumNotionalAmount=None, maximumNumberOfOptions=None):
        self.original_tagname_ = None
        if notionalReference is None:
            self.notionalReference = []
        else:
            self.notionalReference = notionalReference
        self.integralMultipleAmount = integralMultipleAmount
        self.minimumNotionalAmount = minimumNotionalAmount
        self.minimumNumberOfOptions = minimumNumberOfOptions
        self.maximumNotionalAmount = maximumNotionalAmount
        self.maximumNumberOfOptions = maximumNumberOfOptions
        self.validate_NonNegativeDecimal(self.maximumNumberOfOptions)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MultipleExercise)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MultipleExercise.subclass:
            return MultipleExercise.subclass(*args_, **kwargs_)
        else:
            return MultipleExercise(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_notionalReference(self): return self.notionalReference
    def set_notionalReference(self, notionalReference): self.notionalReference = notionalReference
    def add_notionalReference(self, value): self.notionalReference.append(value)
    def insert_notionalReference_at(self, index, value): self.notionalReference.insert(index, value)
    def replace_notionalReference_at(self, index, value): self.notionalReference[index] = value
    def get_integralMultipleAmount(self): return self.integralMultipleAmount
    def set_integralMultipleAmount(self, integralMultipleAmount): self.integralMultipleAmount = integralMultipleAmount
    def get_minimumNotionalAmount(self): return self.minimumNotionalAmount
    def set_minimumNotionalAmount(self, minimumNotionalAmount): self.minimumNotionalAmount = minimumNotionalAmount
    def get_minimumNumberOfOptions(self): return self.minimumNumberOfOptions
    def set_minimumNumberOfOptions(self, minimumNumberOfOptions): self.minimumNumberOfOptions = minimumNumberOfOptions
    def get_maximumNotionalAmount(self): return self.maximumNotionalAmount
    def set_maximumNotionalAmount(self, maximumNotionalAmount): self.maximumNotionalAmount = maximumNotionalAmount
    def get_maximumNumberOfOptions(self): return self.maximumNumberOfOptions
    def set_maximumNumberOfOptions(self, maximumNumberOfOptions): self.maximumNumberOfOptions = maximumNumberOfOptions
    def validate_NonNegativeDecimal(self, value):
        # Validate type NonNegativeDecimal, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on NonNegativeDecimal' % {"value" : value} )
    def hasContent_(self):
        if (
            self.notionalReference or
            self.integralMultipleAmount is not None or
            self.minimumNotionalAmount is not None or
            self.minimumNumberOfOptions is not None or
            self.maximumNotionalAmount is not None or
            self.maximumNumberOfOptions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MultipleExercise', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MultipleExercise')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MultipleExercise', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MultipleExercise'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MultipleExercise', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for notionalReference_ in self.notionalReference:
            notionalReference_.export(outfile, level, namespace_, name_='notionalReference', pretty_print=pretty_print)
        if self.integralMultipleAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sintegralMultipleAmount>%s</%sintegralMultipleAmount>%s' % (namespace_, self.gds_format_float(self.integralMultipleAmount, input_name='integralMultipleAmount'), namespace_, eol_))
        if self.minimumNotionalAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sminimumNotionalAmount>%s</%sminimumNotionalAmount>%s' % (namespace_, self.gds_format_float(self.minimumNotionalAmount, input_name='minimumNotionalAmount'), namespace_, eol_))
        if self.minimumNumberOfOptions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sminimumNumberOfOptions>%s</%sminimumNumberOfOptions>%s' % (namespace_, self.gds_format_integer(self.minimumNumberOfOptions, input_name='minimumNumberOfOptions'), namespace_, eol_))
        if self.maximumNotionalAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaximumNotionalAmount>%s</%smaximumNotionalAmount>%s' % (namespace_, self.gds_format_float(self.maximumNotionalAmount, input_name='maximumNotionalAmount'), namespace_, eol_))
        if self.maximumNumberOfOptions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaximumNumberOfOptions>%s</%smaximumNumberOfOptions>%s' % (namespace_, self.gds_format_float(self.maximumNumberOfOptions, input_name='maximumNumberOfOptions'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'notionalReference':
            obj_ = NotionalReference.factory()
            obj_.build(child_)
            self.notionalReference.append(obj_)
            obj_.original_tagname_ = 'notionalReference'
        elif nodeName_ == 'integralMultipleAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'integralMultipleAmount')
            self.integralMultipleAmount = fval_
        elif nodeName_ == 'minimumNotionalAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'minimumNotionalAmount')
            self.minimumNotionalAmount = fval_
        elif nodeName_ == 'minimumNumberOfOptions':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'minimumNumberOfOptions')
            self.minimumNumberOfOptions = ival_
        elif nodeName_ == 'maximumNotionalAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'maximumNotionalAmount')
            self.maximumNotionalAmount = fval_
        elif nodeName_ == 'maximumNumberOfOptions':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'maximumNumberOfOptions')
            self.maximumNumberOfOptions = fval_
            # validate type NonNegativeDecimal
            self.validate_NonNegativeDecimal(self.maximumNumberOfOptions)
# end class MultipleExercise


class NonNegativeMoney(MoneyBase):
    """A type defining a non negative money amount."""
    member_data_items_ = {
        'amount': MemberSpec_('amount', ['NonNegativeDecimal', 'xsd:decimal'], 0),
    }
    subclass = None
    superclass = MoneyBase
    def __init__(self, id=None, currency=None, amount=None, extensiontype_=None):
        self.original_tagname_ = None
        super(NonNegativeMoney, self).__init__(id, currency, extensiontype_, )
        self.amount = amount
        self.validate_NonNegativeDecimal(self.amount)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NonNegativeMoney)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NonNegativeMoney.subclass:
            return NonNegativeMoney.subclass(*args_, **kwargs_)
        else:
            return NonNegativeMoney(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_amount(self): return self.amount
    def set_amount(self, amount): self.amount = amount
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_NonNegativeDecimal(self, value):
        # Validate type NonNegativeDecimal, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on NonNegativeDecimal' % {"value" : value} )
    def hasContent_(self):
        if (
            self.amount is not None or
            super(NonNegativeMoney, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NonNegativeMoney', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NonNegativeMoney')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NonNegativeMoney', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NonNegativeMoney'):
        super(NonNegativeMoney, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NonNegativeMoney')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='NonNegativeMoney', fromsubclass_=False, pretty_print=True):
        super(NonNegativeMoney, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.amount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%samount>%s</%samount>%s' % (namespace_, self.gds_format_float(self.amount, input_name='amount'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(NonNegativeMoney, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'amount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'amount')
            self.amount = fval_
            # validate type NonNegativeDecimal
            self.validate_NonNegativeDecimal(self.amount)
        super(NonNegativeMoney, self).buildChildren(child_, node, nodeName_, True)
# end class NonNegativeMoney


class NonNegativeSchedule(GeneratedsSuper):
    """A type defining a schedule of non-negative rates or amounts in terms
    of an initial value and then a series of step date and value
    pairs. On each step date the rate or amount changes to the new
    step value. The series of step date and value pairs are
    optional. If not specified, this implies that the initial value
    remains unchanged over time."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'initialValue': MemberSpec_('initialValue', ['NonNegativeDecimal', 'xsd:decimal'], 0),
        'step': MemberSpec_('step', 'NonNegativeStep', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, initialValue=None, step=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.initialValue = initialValue
        self.validate_NonNegativeDecimal(self.initialValue)
        if step is None:
            self.step = []
        else:
            self.step = step
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NonNegativeSchedule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NonNegativeSchedule.subclass:
            return NonNegativeSchedule.subclass(*args_, **kwargs_)
        else:
            return NonNegativeSchedule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_initialValue(self): return self.initialValue
    def set_initialValue(self, initialValue): self.initialValue = initialValue
    def get_step(self): return self.step
    def set_step(self, step): self.step = step
    def add_step(self, value): self.step.append(value)
    def insert_step_at(self, index, value): self.step.insert(index, value)
    def replace_step_at(self, index, value): self.step[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_NonNegativeDecimal(self, value):
        # Validate type NonNegativeDecimal, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on NonNegativeDecimal' % {"value" : value} )
    def hasContent_(self):
        if (
            self.initialValue is not None or
            self.step
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NonNegativeSchedule', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NonNegativeSchedule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NonNegativeSchedule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NonNegativeSchedule'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='NonNegativeSchedule', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.initialValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinitialValue>%s</%sinitialValue>%s' % (namespace_, self.gds_format_float(self.initialValue, input_name='initialValue'), namespace_, eol_))
        for step_ in self.step:
            step_.export(outfile, level, namespace_, name_='step', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'initialValue':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'initialValue')
            self.initialValue = fval_
            # validate type NonNegativeDecimal
            self.validate_NonNegativeDecimal(self.initialValue)
        elif nodeName_ == 'step':
            obj_ = NonNegativeStep.factory()
            obj_.build(child_)
            self.step.append(obj_)
            obj_.original_tagname_ = 'step'
# end class NonNegativeSchedule


class NotionalAmount(NonNegativeMoney):
    """A complex type to specify the notional amount."""
    member_data_items_ = {
    }
    subclass = None
    superclass = NonNegativeMoney
    def __init__(self, id=None, currency=None, amount=None):
        self.original_tagname_ = None
        super(NotionalAmount, self).__init__(id, currency, amount, )
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NotionalAmount)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NotionalAmount.subclass:
            return NotionalAmount.subclass(*args_, **kwargs_)
        else:
            return NotionalAmount(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(NotionalAmount, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NotionalAmount', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NotionalAmount')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NotionalAmount', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NotionalAmount'):
        super(NotionalAmount, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NotionalAmount')
    def exportChildren(self, outfile, level, namespace_='', name_='NotionalAmount', fromsubclass_=False, pretty_print=True):
        super(NotionalAmount, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NotionalAmount, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(NotionalAmount, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class NotionalAmount


class OffsetPrevailingTime(GeneratedsSuper):
    """Allows the specification of a time that may be on a day prior or
    subsequent to the day in question. This type is intended for use
    with a day of the week (i.e. where no actual date is specified)
    as part of, for example, a period that runs from 23:00-07:00 on
    a series of days and where holidays on the actual days would
    affect the entire time period."""
    member_data_items_ = {
        'time': MemberSpec_('time', 'PrevailingTime', 0),
        'offset': MemberSpec_('offset', 'Offset', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, time=None, offset=None):
        self.original_tagname_ = None
        self.time = time
        self.offset = offset
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OffsetPrevailingTime)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OffsetPrevailingTime.subclass:
            return OffsetPrevailingTime.subclass(*args_, **kwargs_)
        else:
            return OffsetPrevailingTime(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_time(self): return self.time
    def set_time(self, time): self.time = time
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def hasContent_(self):
        if (
            self.time is not None or
            self.offset is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OffsetPrevailingTime', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OffsetPrevailingTime')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OffsetPrevailingTime', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OffsetPrevailingTime'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OffsetPrevailingTime', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.time is not None:
            self.time.export(outfile, level, namespace_, name_='time', pretty_print=pretty_print)
        if self.offset is not None:
            self.offset.export(outfile, level, namespace_, name_='offset', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'time':
            obj_ = PrevailingTime.factory()
            obj_.build(child_)
            self.time = obj_
            obj_.original_tagname_ = 'time'
        elif nodeName_ == 'offset':
            class_obj_ = self.get_class_obj_(child_, Offset)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.offset = obj_
            obj_.original_tagname_ = 'offset'
# end class OffsetPrevailingTime


class OnBehalfOf(GeneratedsSuper):
    member_data_items_ = {
        'partyReference': MemberSpec_('partyReference', 'PartyReference', 0),
        'accountReference': MemberSpec_('accountReference', 'AccountReference', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, partyReference=None, accountReference=None):
        self.original_tagname_ = None
        self.partyReference = partyReference
        if accountReference is None:
            self.accountReference = []
        else:
            self.accountReference = accountReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OnBehalfOf)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OnBehalfOf.subclass:
            return OnBehalfOf.subclass(*args_, **kwargs_)
        else:
            return OnBehalfOf(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyReference(self): return self.partyReference
    def set_partyReference(self, partyReference): self.partyReference = partyReference
    def get_accountReference(self): return self.accountReference
    def set_accountReference(self, accountReference): self.accountReference = accountReference
    def add_accountReference(self, value): self.accountReference.append(value)
    def insert_accountReference_at(self, index, value): self.accountReference.insert(index, value)
    def replace_accountReference_at(self, index, value): self.accountReference[index] = value
    def hasContent_(self):
        if (
            self.partyReference is not None or
            self.accountReference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OnBehalfOf', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OnBehalfOf')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OnBehalfOf', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OnBehalfOf'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OnBehalfOf', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.partyReference is not None:
            self.partyReference.export(outfile, level, namespace_, name_='partyReference', pretty_print=pretty_print)
        for accountReference_ in self.accountReference:
            accountReference_.export(outfile, level, namespace_, name_='accountReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'partyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.partyReference = obj_
            obj_.original_tagname_ = 'partyReference'
        elif nodeName_ == 'accountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.accountReference.append(obj_)
            obj_.original_tagname_ = 'accountReference'
# end class OnBehalfOf


class OrganizationType(GeneratedsSuper):
    """A code that describes what type of role an organization plays, for
    example a SwapsDealer, a Major Swaps Participant, or Other"""
    member_data_items_ = {
        'organizationTypeScheme': MemberSpec_('organizationTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, organizationTypeScheme='http://www.fpml.org/coding-scheme/organization-type', valueOf_=None):
        self.original_tagname_ = None
        self.organizationTypeScheme = _cast(None, organizationTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OrganizationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OrganizationType.subclass:
            return OrganizationType.subclass(*args_, **kwargs_)
        else:
            return OrganizationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_organizationTypeScheme(self): return self.organizationTypeScheme
    def set_organizationTypeScheme(self, organizationTypeScheme): self.organizationTypeScheme = organizationTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OrganizationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OrganizationType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OrganizationType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OrganizationType'):
        if self.organizationTypeScheme != "http://www.fpml.org/coding-scheme/organization-type" and 'organizationTypeScheme' not in already_processed:
            already_processed.add('organizationTypeScheme')
            outfile.write(' organizationTypeScheme=%s' % (quote_attrib(self.organizationTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OrganizationType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('organizationTypeScheme', node)
        if value is not None and 'organizationTypeScheme' not in already_processed:
            already_processed.add('organizationTypeScheme')
            self.organizationTypeScheme = value
            self.validate_NonEmptyURI(self.organizationTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OrganizationType


class OriginatingEvent(GeneratedsSuper):
    member_data_items_ = {
        'originatingEventScheme': MemberSpec_('originatingEventScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, originatingEventScheme='http://www.fpml.org/coding-scheme/originating-event', valueOf_=None):
        self.original_tagname_ = None
        self.originatingEventScheme = _cast(None, originatingEventScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OriginatingEvent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OriginatingEvent.subclass:
            return OriginatingEvent.subclass(*args_, **kwargs_)
        else:
            return OriginatingEvent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_originatingEventScheme(self): return self.originatingEventScheme
    def set_originatingEventScheme(self, originatingEventScheme): self.originatingEventScheme = originatingEventScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OriginatingEvent', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OriginatingEvent')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OriginatingEvent', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OriginatingEvent'):
        if self.originatingEventScheme != "http://www.fpml.org/coding-scheme/originating-event" and 'originatingEventScheme' not in already_processed:
            already_processed.add('originatingEventScheme')
            outfile.write(' originatingEventScheme=%s' % (quote_attrib(self.originatingEventScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OriginatingEvent', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('originatingEventScheme', node)
        if value is not None and 'originatingEventScheme' not in already_processed:
            already_processed.add('originatingEventScheme')
            self.originatingEventScheme = value
            self.validate_NonEmptyURI(self.originatingEventScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OriginatingEvent


class PartialExercise(GeneratedsSuper):
    """A type defining partial exercise. As defined in the 2000 ISDA
    Definitions, Section 12.3 Partial Exercise, the buyer of the
    option may exercise all or less than all the notional amount of
    the underlying swap but may not be less than the minimum
    notional amount (if specified) and must be an integral multiple
    of the integral multiple amount if specified."""
    member_data_items_ = {
        'notionalReference': MemberSpec_('notionalReference', 'NotionalReference', 1),
        'integralMultipleAmount': MemberSpec_('integralMultipleAmount', 'xsd:decimal', 0),
        'minimumNotionalAmount': MemberSpec_('minimumNotionalAmount', 'xsd:decimal', 0),
        'minimumNumberOfOptions': MemberSpec_('minimumNumberOfOptions', 'xsd:nonNegativeInteger', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, notionalReference=None, integralMultipleAmount=None, minimumNotionalAmount=None, minimumNumberOfOptions=None):
        self.original_tagname_ = None
        if notionalReference is None:
            self.notionalReference = []
        else:
            self.notionalReference = notionalReference
        self.integralMultipleAmount = integralMultipleAmount
        self.minimumNotionalAmount = minimumNotionalAmount
        self.minimumNumberOfOptions = minimumNumberOfOptions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartialExercise)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartialExercise.subclass:
            return PartialExercise.subclass(*args_, **kwargs_)
        else:
            return PartialExercise(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_notionalReference(self): return self.notionalReference
    def set_notionalReference(self, notionalReference): self.notionalReference = notionalReference
    def add_notionalReference(self, value): self.notionalReference.append(value)
    def insert_notionalReference_at(self, index, value): self.notionalReference.insert(index, value)
    def replace_notionalReference_at(self, index, value): self.notionalReference[index] = value
    def get_integralMultipleAmount(self): return self.integralMultipleAmount
    def set_integralMultipleAmount(self, integralMultipleAmount): self.integralMultipleAmount = integralMultipleAmount
    def get_minimumNotionalAmount(self): return self.minimumNotionalAmount
    def set_minimumNotionalAmount(self, minimumNotionalAmount): self.minimumNotionalAmount = minimumNotionalAmount
    def get_minimumNumberOfOptions(self): return self.minimumNumberOfOptions
    def set_minimumNumberOfOptions(self, minimumNumberOfOptions): self.minimumNumberOfOptions = minimumNumberOfOptions
    def hasContent_(self):
        if (
            self.notionalReference or
            self.integralMultipleAmount is not None or
            self.minimumNotionalAmount is not None or
            self.minimumNumberOfOptions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartialExercise', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartialExercise')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartialExercise', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartialExercise'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PartialExercise', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for notionalReference_ in self.notionalReference:
            notionalReference_.export(outfile, level, namespace_, name_='notionalReference', pretty_print=pretty_print)
        if self.integralMultipleAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sintegralMultipleAmount>%s</%sintegralMultipleAmount>%s' % (namespace_, self.gds_format_float(self.integralMultipleAmount, input_name='integralMultipleAmount'), namespace_, eol_))
        if self.minimumNotionalAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sminimumNotionalAmount>%s</%sminimumNotionalAmount>%s' % (namespace_, self.gds_format_float(self.minimumNotionalAmount, input_name='minimumNotionalAmount'), namespace_, eol_))
        if self.minimumNumberOfOptions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sminimumNumberOfOptions>%s</%sminimumNumberOfOptions>%s' % (namespace_, self.gds_format_integer(self.minimumNumberOfOptions, input_name='minimumNumberOfOptions'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'notionalReference':
            obj_ = NotionalReference.factory()
            obj_.build(child_)
            self.notionalReference.append(obj_)
            obj_.original_tagname_ = 'notionalReference'
        elif nodeName_ == 'integralMultipleAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'integralMultipleAmount')
            self.integralMultipleAmount = fval_
        elif nodeName_ == 'minimumNotionalAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'minimumNotionalAmount')
            self.minimumNotionalAmount = fval_
        elif nodeName_ == 'minimumNumberOfOptions':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'minimumNumberOfOptions')
            self.minimumNumberOfOptions = ival_
# end class PartialExercise


class Party(GeneratedsSuper):
    """A type defining a legal entity or a subdivision of a legal
    entity.Parties can perform multiple roles in a trade lifecycle.
    For example, the principal parties obligated to make payments
    from time to time during the term of the trade, but may include
    other parties involved in, or incidental to, the trade, such as
    parties acting in the role of novation transferor/transferee,
    broker, calculation agent, etc. In FpML roles are defined in
    multiple places within a document.A group of parties acting as a
    single party (e.g. joint and several).The id uniquely
    identifying the Party within the document."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'partyId': MemberSpec_('partyId', 'PartyId', 1),
        'partyName': MemberSpec_('partyName', 'PartyName', 0),
        'classification': MemberSpec_('classification', 'IndustryClassification', 1),
        'creditRating': MemberSpec_('creditRating', 'CreditRating', 1),
        'country': MemberSpec_('country', 'CountryCode', 0),
        'region': MemberSpec_('region', 'Region', 1),
        'jurisdiction': MemberSpec_('jurisdiction', 'GoverningLaw', 1),
        'organizationType': MemberSpec_('organizationType', 'OrganizationType', 0),
        'relatedParty': MemberSpec_('relatedParty', 'PartyRelationship', 1),
        'contactInfo': MemberSpec_('contactInfo', 'ContactInformation', 0),
        'businessUnit': MemberSpec_('businessUnit', 'BusinessUnit', 1),
        'person': MemberSpec_('person', 'Person', 1),
        'groupType': MemberSpec_('groupType', 'PartyGroupType', 0),
        'partyReference': MemberSpec_('partyReference', 'PartyReference', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, partyId=None, partyName=None, classification=None, creditRating=None, country=None, region=None, jurisdiction=None, organizationType=None, relatedParty=None, contactInfo=None, businessUnit=None, person=None, groupType=None, partyReference=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if partyId is None:
            self.partyId = []
        else:
            self.partyId = partyId
        self.partyName = partyName
        if classification is None:
            self.classification = []
        else:
            self.classification = classification
        if creditRating is None:
            self.creditRating = []
        else:
            self.creditRating = creditRating
        self.country = country
        if region is None:
            self.region = []
        else:
            self.region = region
        if jurisdiction is None:
            self.jurisdiction = []
        else:
            self.jurisdiction = jurisdiction
        self.organizationType = organizationType
        if relatedParty is None:
            self.relatedParty = []
        else:
            self.relatedParty = relatedParty
        self.contactInfo = contactInfo
        if businessUnit is None:
            self.businessUnit = []
        else:
            self.businessUnit = businessUnit
        if person is None:
            self.person = []
        else:
            self.person = person
        self.groupType = groupType
        if partyReference is None:
            self.partyReference = []
        else:
            self.partyReference = partyReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Party)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Party.subclass:
            return Party.subclass(*args_, **kwargs_)
        else:
            return Party(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyId(self): return self.partyId
    def set_partyId(self, partyId): self.partyId = partyId
    def add_partyId(self, value): self.partyId.append(value)
    def insert_partyId_at(self, index, value): self.partyId.insert(index, value)
    def replace_partyId_at(self, index, value): self.partyId[index] = value
    def get_partyName(self): return self.partyName
    def set_partyName(self, partyName): self.partyName = partyName
    def get_classification(self): return self.classification
    def set_classification(self, classification): self.classification = classification
    def add_classification(self, value): self.classification.append(value)
    def insert_classification_at(self, index, value): self.classification.insert(index, value)
    def replace_classification_at(self, index, value): self.classification[index] = value
    def get_creditRating(self): return self.creditRating
    def set_creditRating(self, creditRating): self.creditRating = creditRating
    def add_creditRating(self, value): self.creditRating.append(value)
    def insert_creditRating_at(self, index, value): self.creditRating.insert(index, value)
    def replace_creditRating_at(self, index, value): self.creditRating[index] = value
    def get_country(self): return self.country
    def set_country(self, country): self.country = country
    def get_region(self): return self.region
    def set_region(self, region): self.region = region
    def add_region(self, value): self.region.append(value)
    def insert_region_at(self, index, value): self.region.insert(index, value)
    def replace_region_at(self, index, value): self.region[index] = value
    def get_jurisdiction(self): return self.jurisdiction
    def set_jurisdiction(self, jurisdiction): self.jurisdiction = jurisdiction
    def add_jurisdiction(self, value): self.jurisdiction.append(value)
    def insert_jurisdiction_at(self, index, value): self.jurisdiction.insert(index, value)
    def replace_jurisdiction_at(self, index, value): self.jurisdiction[index] = value
    def get_organizationType(self): return self.organizationType
    def set_organizationType(self, organizationType): self.organizationType = organizationType
    def get_relatedParty(self): return self.relatedParty
    def set_relatedParty(self, relatedParty): self.relatedParty = relatedParty
    def add_relatedParty(self, value): self.relatedParty.append(value)
    def insert_relatedParty_at(self, index, value): self.relatedParty.insert(index, value)
    def replace_relatedParty_at(self, index, value): self.relatedParty[index] = value
    def get_contactInfo(self): return self.contactInfo
    def set_contactInfo(self, contactInfo): self.contactInfo = contactInfo
    def get_businessUnit(self): return self.businessUnit
    def set_businessUnit(self, businessUnit): self.businessUnit = businessUnit
    def add_businessUnit(self, value): self.businessUnit.append(value)
    def insert_businessUnit_at(self, index, value): self.businessUnit.insert(index, value)
    def replace_businessUnit_at(self, index, value): self.businessUnit[index] = value
    def get_person(self): return self.person
    def set_person(self, person): self.person = person
    def add_person(self, value): self.person.append(value)
    def insert_person_at(self, index, value): self.person.insert(index, value)
    def replace_person_at(self, index, value): self.person[index] = value
    def get_groupType(self): return self.groupType
    def set_groupType(self, groupType): self.groupType = groupType
    def get_partyReference(self): return self.partyReference
    def set_partyReference(self, partyReference): self.partyReference = partyReference
    def add_partyReference(self, value): self.partyReference.append(value)
    def insert_partyReference_at(self, index, value): self.partyReference.insert(index, value)
    def replace_partyReference_at(self, index, value): self.partyReference[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.partyId or
            self.partyName is not None or
            self.classification or
            self.creditRating or
            self.country is not None or
            self.region or
            self.jurisdiction or
            self.organizationType is not None or
            self.relatedParty or
            self.contactInfo is not None or
            self.businessUnit or
            self.person or
            self.groupType is not None or
            self.partyReference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Party', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Party')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Party', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Party'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Party', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for partyId_ in self.partyId:
            partyId_.export(outfile, level, namespace_, name_='partyId', pretty_print=pretty_print)
        if self.partyName is not None:
            self.partyName.export(outfile, level, namespace_, name_='partyName', pretty_print=pretty_print)
        for classification_ in self.classification:
            classification_.export(outfile, level, namespace_, name_='classification', pretty_print=pretty_print)
        for creditRating_ in self.creditRating:
            creditRating_.export(outfile, level, namespace_, name_='creditRating', pretty_print=pretty_print)
        if self.country is not None:
            self.country.export(outfile, level, namespace_, name_='country', pretty_print=pretty_print)
        for region_ in self.region:
            region_.export(outfile, level, namespace_, name_='region', pretty_print=pretty_print)
        for jurisdiction_ in self.jurisdiction:
            jurisdiction_.export(outfile, level, namespace_, name_='jurisdiction', pretty_print=pretty_print)
        if self.organizationType is not None:
            self.organizationType.export(outfile, level, namespace_, name_='organizationType', pretty_print=pretty_print)
        for relatedParty_ in self.relatedParty:
            relatedParty_.export(outfile, level, namespace_, name_='relatedParty', pretty_print=pretty_print)
        if self.contactInfo is not None:
            self.contactInfo.export(outfile, level, namespace_, name_='contactInfo', pretty_print=pretty_print)
        for businessUnit_ in self.businessUnit:
            businessUnit_.export(outfile, level, namespace_, name_='businessUnit', pretty_print=pretty_print)
        for person_ in self.person:
            person_.export(outfile, level, namespace_, name_='person', pretty_print=pretty_print)
        if self.groupType is not None:
            self.groupType.export(outfile, level, namespace_, name_='groupType', pretty_print=pretty_print)
        for partyReference_ in self.partyReference:
            partyReference_.export(outfile, level, namespace_, name_='partyReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'partyId':
            obj_ = PartyId.factory()
            obj_.build(child_)
            self.partyId.append(obj_)
            obj_.original_tagname_ = 'partyId'
        elif nodeName_ == 'partyName':
            obj_ = PartyName.factory()
            obj_.build(child_)
            self.partyName = obj_
            obj_.original_tagname_ = 'partyName'
        elif nodeName_ == 'classification':
            obj_ = IndustryClassification.factory()
            obj_.build(child_)
            self.classification.append(obj_)
            obj_.original_tagname_ = 'classification'
        elif nodeName_ == 'creditRating':
            obj_ = CreditRating.factory()
            obj_.build(child_)
            self.creditRating.append(obj_)
            obj_.original_tagname_ = 'creditRating'
        elif nodeName_ == 'country':
            obj_ = CountryCode.factory()
            obj_.build(child_)
            self.country = obj_
            obj_.original_tagname_ = 'country'
        elif nodeName_ == 'region':
            obj_ = Region.factory()
            obj_.build(child_)
            self.region.append(obj_)
            obj_.original_tagname_ = 'region'
        elif nodeName_ == 'jurisdiction':
            obj_ = GoverningLaw.factory()
            obj_.build(child_)
            self.jurisdiction.append(obj_)
            obj_.original_tagname_ = 'jurisdiction'
        elif nodeName_ == 'organizationType':
            obj_ = OrganizationType.factory()
            obj_.build(child_)
            self.organizationType = obj_
            obj_.original_tagname_ = 'organizationType'
        elif nodeName_ == 'relatedParty':
            obj_ = PartyRelationship.factory()
            obj_.build(child_)
            self.relatedParty.append(obj_)
            obj_.original_tagname_ = 'relatedParty'
        elif nodeName_ == 'contactInfo':
            obj_ = ContactInformation.factory()
            obj_.build(child_)
            self.contactInfo = obj_
            obj_.original_tagname_ = 'contactInfo'
        elif nodeName_ == 'businessUnit':
            obj_ = BusinessUnit.factory()
            obj_.build(child_)
            self.businessUnit.append(obj_)
            obj_.original_tagname_ = 'businessUnit'
        elif nodeName_ == 'person':
            obj_ = Person.factory()
            obj_.build(child_)
            self.person.append(obj_)
            obj_.original_tagname_ = 'person'
        elif nodeName_ == 'groupType':
            obj_ = PartyGroupType.factory()
            obj_.build(child_)
            self.groupType = obj_
            obj_.original_tagname_ = 'groupType'
        elif nodeName_ == 'partyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.partyReference.append(obj_)
            obj_.original_tagname_ = 'partyReference'
# end class Party


class PartyContactInformation(GeneratedsSuper):
    member_data_items_ = {
        'partyReference': MemberSpec_('partyReference', 'PartyReference', 0),
        'contactInfo': MemberSpec_('contactInfo', 'ContactInformation', 0),
        'businessUnit': MemberSpec_('businessUnit', 'BusinessUnit', 1),
        'person': MemberSpec_('person', 'Person', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, partyReference=None, contactInfo=None, businessUnit=None, person=None):
        self.original_tagname_ = None
        self.partyReference = partyReference
        self.contactInfo = contactInfo
        if businessUnit is None:
            self.businessUnit = []
        else:
            self.businessUnit = businessUnit
        if person is None:
            self.person = []
        else:
            self.person = person
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyContactInformation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyContactInformation.subclass:
            return PartyContactInformation.subclass(*args_, **kwargs_)
        else:
            return PartyContactInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyReference(self): return self.partyReference
    def set_partyReference(self, partyReference): self.partyReference = partyReference
    def get_contactInfo(self): return self.contactInfo
    def set_contactInfo(self, contactInfo): self.contactInfo = contactInfo
    def get_businessUnit(self): return self.businessUnit
    def set_businessUnit(self, businessUnit): self.businessUnit = businessUnit
    def add_businessUnit(self, value): self.businessUnit.append(value)
    def insert_businessUnit_at(self, index, value): self.businessUnit.insert(index, value)
    def replace_businessUnit_at(self, index, value): self.businessUnit[index] = value
    def get_person(self): return self.person
    def set_person(self, person): self.person = person
    def add_person(self, value): self.person.append(value)
    def insert_person_at(self, index, value): self.person.insert(index, value)
    def replace_person_at(self, index, value): self.person[index] = value
    def hasContent_(self):
        if (
            self.partyReference is not None or
            self.contactInfo is not None or
            self.businessUnit or
            self.person
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartyContactInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyContactInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartyContactInformation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyContactInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PartyContactInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.partyReference is not None:
            self.partyReference.export(outfile, level, namespace_, name_='partyReference', pretty_print=pretty_print)
        if self.contactInfo is not None:
            self.contactInfo.export(outfile, level, namespace_, name_='contactInfo', pretty_print=pretty_print)
        for businessUnit_ in self.businessUnit:
            businessUnit_.export(outfile, level, namespace_, name_='businessUnit', pretty_print=pretty_print)
        for person_ in self.person:
            person_.export(outfile, level, namespace_, name_='person', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'partyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.partyReference = obj_
            obj_.original_tagname_ = 'partyReference'
        elif nodeName_ == 'contactInfo':
            obj_ = ContactInformation.factory()
            obj_.build(child_)
            self.contactInfo = obj_
            obj_.original_tagname_ = 'contactInfo'
        elif nodeName_ == 'businessUnit':
            obj_ = BusinessUnit.factory()
            obj_.build(child_)
            self.businessUnit.append(obj_)
            obj_.original_tagname_ = 'businessUnit'
        elif nodeName_ == 'person':
            obj_ = Person.factory()
            obj_.build(child_)
            self.person.append(obj_)
            obj_.original_tagname_ = 'person'
# end class PartyContactInformation


class PartyGroupType(GeneratedsSuper):
    """The data type used for party group classification."""
    member_data_items_ = {
        'partyGroupTypeScheme': MemberSpec_('partyGroupTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, partyGroupTypeScheme='http://www.fpml.org/coding-scheme/party-group-type', valueOf_=None):
        self.original_tagname_ = None
        self.partyGroupTypeScheme = _cast(None, partyGroupTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyGroupType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyGroupType.subclass:
            return PartyGroupType.subclass(*args_, **kwargs_)
        else:
            return PartyGroupType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyGroupTypeScheme(self): return self.partyGroupTypeScheme
    def set_partyGroupTypeScheme(self, partyGroupTypeScheme): self.partyGroupTypeScheme = partyGroupTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartyGroupType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyGroupType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartyGroupType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyGroupType'):
        if self.partyGroupTypeScheme != "http://www.fpml.org/coding-scheme/party-group-type" and 'partyGroupTypeScheme' not in already_processed:
            already_processed.add('partyGroupTypeScheme')
            outfile.write(' partyGroupTypeScheme=%s' % (quote_attrib(self.partyGroupTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PartyGroupType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partyGroupTypeScheme', node)
        if value is not None and 'partyGroupTypeScheme' not in already_processed:
            already_processed.add('partyGroupTypeScheme')
            self.partyGroupTypeScheme = value
            self.validate_NonEmptyURI(self.partyGroupTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PartyGroupType


class PartyId(GeneratedsSuper):
    """The data type used for party identifiers."""
    member_data_items_ = {
        'partyIdScheme': MemberSpec_('partyIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, partyIdScheme='http://www.fpml.org/coding-scheme/external/iso9362', valueOf_=None):
        self.original_tagname_ = None
        self.partyIdScheme = _cast(None, partyIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyId.subclass:
            return PartyId.subclass(*args_, **kwargs_)
        else:
            return PartyId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyIdScheme(self): return self.partyIdScheme
    def set_partyIdScheme(self, partyIdScheme): self.partyIdScheme = partyIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartyId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartyId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyId'):
        if self.partyIdScheme != "http://www.fpml.org/coding-scheme/external/iso9362" and 'partyIdScheme' not in already_processed:
            already_processed.add('partyIdScheme')
            outfile.write(' partyIdScheme=%s' % (quote_attrib(self.partyIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PartyId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partyIdScheme', node)
        if value is not None and 'partyIdScheme' not in already_processed:
            already_processed.add('partyIdScheme')
            self.partyIdScheme = value
            self.validate_NonEmptyURI(self.partyIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PartyId


class PartyName(GeneratedsSuper):
    """The data type used for the legal name of an organization."""
    member_data_items_ = {
        'partyNameScheme': MemberSpec_('partyNameScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, partyNameScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.partyNameScheme = _cast(None, partyNameScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyName)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyName.subclass:
            return PartyName.subclass(*args_, **kwargs_)
        else:
            return PartyName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyNameScheme(self): return self.partyNameScheme
    def set_partyNameScheme(self, partyNameScheme): self.partyNameScheme = partyNameScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartyName', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyName')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartyName', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyName'):
        if self.partyNameScheme is not None and 'partyNameScheme' not in already_processed:
            already_processed.add('partyNameScheme')
            outfile.write(' partyNameScheme=%s' % (quote_attrib(self.partyNameScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PartyName', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partyNameScheme', node)
        if value is not None and 'partyNameScheme' not in already_processed:
            already_processed.add('partyNameScheme')
            self.partyNameScheme = value
            self.validate_NonEmptyURI(self.partyNameScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PartyName


class PartyRelationship(GeneratedsSuper):
    member_data_items_ = {
        'partyReference': MemberSpec_('partyReference', 'PartyReference', 0),
        'accountReference': MemberSpec_('accountReference', 'AccountReference', 0),
        'role': MemberSpec_('role', 'PartyRole', 0),
        'type_': MemberSpec_('type_', 'PartyRoleType', 0),
        'effectiveDate': MemberSpec_('effectiveDate', 'xsd:date', 0),
        'terminationDate': MemberSpec_('terminationDate', 'xsd:date', 0),
        'documentation': MemberSpec_('documentation', 'PartyRelationshipDocumentation', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, partyReference=None, accountReference=None, role=None, type_=None, effectiveDate=None, terminationDate=None, documentation=None):
        self.original_tagname_ = None
        self.partyReference = partyReference
        self.accountReference = accountReference
        self.role = role
        self.type_ = type_
        if isinstance(effectiveDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(effectiveDate, '%Y-%m-%d').date()
        else:
            initvalue_ = effectiveDate
        self.effectiveDate = initvalue_
        if isinstance(terminationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(terminationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = terminationDate
        self.terminationDate = initvalue_
        self.documentation = documentation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyRelationship)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyRelationship.subclass:
            return PartyRelationship.subclass(*args_, **kwargs_)
        else:
            return PartyRelationship(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyReference(self): return self.partyReference
    def set_partyReference(self, partyReference): self.partyReference = partyReference
    def get_accountReference(self): return self.accountReference
    def set_accountReference(self, accountReference): self.accountReference = accountReference
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_effectiveDate(self): return self.effectiveDate
    def set_effectiveDate(self, effectiveDate): self.effectiveDate = effectiveDate
    def get_terminationDate(self): return self.terminationDate
    def set_terminationDate(self, terminationDate): self.terminationDate = terminationDate
    def get_documentation(self): return self.documentation
    def set_documentation(self, documentation): self.documentation = documentation
    def hasContent_(self):
        if (
            self.partyReference is not None or
            self.accountReference is not None or
            self.role is not None or
            self.type_ is not None or
            self.effectiveDate is not None or
            self.terminationDate is not None or
            self.documentation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartyRelationship', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyRelationship')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartyRelationship', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyRelationship'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PartyRelationship', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.partyReference is not None:
            self.partyReference.export(outfile, level, namespace_, name_='partyReference', pretty_print=pretty_print)
        if self.accountReference is not None:
            self.accountReference.export(outfile, level, namespace_, name_='accountReference', pretty_print=pretty_print)
        if self.role is not None:
            self.role.export(outfile, level, namespace_, name_='role', pretty_print=pretty_print)
        if self.type_ is not None:
            self.type_.export(outfile, level, namespace_, name_='type', pretty_print=pretty_print)
        if self.effectiveDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%seffectiveDate>%s</%seffectiveDate>%s' % (namespace_, self.gds_format_date(self.effectiveDate, input_name='effectiveDate'), namespace_, eol_))
        if self.terminationDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sterminationDate>%s</%sterminationDate>%s' % (namespace_, self.gds_format_date(self.terminationDate, input_name='terminationDate'), namespace_, eol_))
        if self.documentation is not None:
            self.documentation.export(outfile, level, namespace_, name_='documentation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'partyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.partyReference = obj_
            obj_.original_tagname_ = 'partyReference'
        elif nodeName_ == 'accountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.accountReference = obj_
            obj_.original_tagname_ = 'accountReference'
        elif nodeName_ == 'role':
            obj_ = PartyRole.factory()
            obj_.build(child_)
            self.role = obj_
            obj_.original_tagname_ = 'role'
        elif nodeName_ == 'type':
            obj_ = PartyRoleType.factory()
            obj_.build(child_)
            self.type_ = obj_
            obj_.original_tagname_ = 'type'
        elif nodeName_ == 'effectiveDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.effectiveDate = dval_
        elif nodeName_ == 'terminationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.terminationDate = dval_
        elif nodeName_ == 'documentation':
            obj_ = PartyRelationshipDocumentation.factory()
            obj_.build(child_)
            self.documentation = obj_
            obj_.original_tagname_ = 'documentation'
# end class PartyRelationship


class PartyRelationshipDocumentation(GeneratedsSuper):
    """A description of the legal agreement(s) and definitions that
    document a party's relationships with other parties"""
    member_data_items_ = {
        'masterAgreement': MemberSpec_('masterAgreement', 'MasterAgreement', 1),
        'creditSupportAgreement': MemberSpec_('creditSupportAgreement', 'CreditSupportAgreement', 1),
        'agreement': MemberSpec_('agreement', 'GenericAgreement', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, masterAgreement=None, creditSupportAgreement=None, agreement=None):
        self.original_tagname_ = None
        if masterAgreement is None:
            self.masterAgreement = []
        else:
            self.masterAgreement = masterAgreement
        if creditSupportAgreement is None:
            self.creditSupportAgreement = []
        else:
            self.creditSupportAgreement = creditSupportAgreement
        if agreement is None:
            self.agreement = []
        else:
            self.agreement = agreement
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyRelationshipDocumentation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyRelationshipDocumentation.subclass:
            return PartyRelationshipDocumentation.subclass(*args_, **kwargs_)
        else:
            return PartyRelationshipDocumentation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_masterAgreement(self): return self.masterAgreement
    def set_masterAgreement(self, masterAgreement): self.masterAgreement = masterAgreement
    def add_masterAgreement(self, value): self.masterAgreement.append(value)
    def insert_masterAgreement_at(self, index, value): self.masterAgreement.insert(index, value)
    def replace_masterAgreement_at(self, index, value): self.masterAgreement[index] = value
    def get_creditSupportAgreement(self): return self.creditSupportAgreement
    def set_creditSupportAgreement(self, creditSupportAgreement): self.creditSupportAgreement = creditSupportAgreement
    def add_creditSupportAgreement(self, value): self.creditSupportAgreement.append(value)
    def insert_creditSupportAgreement_at(self, index, value): self.creditSupportAgreement.insert(index, value)
    def replace_creditSupportAgreement_at(self, index, value): self.creditSupportAgreement[index] = value
    def get_agreement(self): return self.agreement
    def set_agreement(self, agreement): self.agreement = agreement
    def add_agreement(self, value): self.agreement.append(value)
    def insert_agreement_at(self, index, value): self.agreement.insert(index, value)
    def replace_agreement_at(self, index, value): self.agreement[index] = value
    def hasContent_(self):
        if (
            self.masterAgreement or
            self.creditSupportAgreement or
            self.agreement
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartyRelationshipDocumentation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyRelationshipDocumentation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartyRelationshipDocumentation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyRelationshipDocumentation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PartyRelationshipDocumentation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for masterAgreement_ in self.masterAgreement:
            masterAgreement_.export(outfile, level, namespace_, name_='masterAgreement', pretty_print=pretty_print)
        for creditSupportAgreement_ in self.creditSupportAgreement:
            creditSupportAgreement_.export(outfile, level, namespace_, name_='creditSupportAgreement', pretty_print=pretty_print)
        for agreement_ in self.agreement:
            agreement_.export(outfile, level, namespace_, name_='agreement', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'masterAgreement':
            obj_ = MasterAgreement.factory()
            obj_.build(child_)
            self.masterAgreement.append(obj_)
            obj_.original_tagname_ = 'masterAgreement'
        elif nodeName_ == 'creditSupportAgreement':
            obj_ = CreditSupportAgreement.factory()
            obj_.build(child_)
            self.creditSupportAgreement.append(obj_)
            obj_.original_tagname_ = 'creditSupportAgreement'
        elif nodeName_ == 'agreement':
            obj_ = GenericAgreement.factory()
            obj_.build(child_)
            self.agreement.append(obj_)
            obj_.original_tagname_ = 'agreement'
# end class PartyRelationshipDocumentation


class PartyRole(GeneratedsSuper):
    """A type describing a role played by a party in one or more
    transactions. Examples include roles such as guarantor,
    custodian, confirmation service provider, etc. This can be
    extended to provide custom roles."""
    member_data_items_ = {
        'partyRoleScheme': MemberSpec_('partyRoleScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, partyRoleScheme='http://www.fpml.org/coding-scheme/party-role', valueOf_=None):
        self.original_tagname_ = None
        self.partyRoleScheme = _cast(None, partyRoleScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyRole)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyRole.subclass:
            return PartyRole.subclass(*args_, **kwargs_)
        else:
            return PartyRole(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyRoleScheme(self): return self.partyRoleScheme
    def set_partyRoleScheme(self, partyRoleScheme): self.partyRoleScheme = partyRoleScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartyRole', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyRole')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartyRole', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyRole'):
        if self.partyRoleScheme != "http://www.fpml.org/coding-scheme/party-role" and 'partyRoleScheme' not in already_processed:
            already_processed.add('partyRoleScheme')
            outfile.write(' partyRoleScheme=%s' % (quote_attrib(self.partyRoleScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PartyRole', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partyRoleScheme', node)
        if value is not None and 'partyRoleScheme' not in already_processed:
            already_processed.add('partyRoleScheme')
            self.partyRoleScheme = value
            self.validate_NonEmptyURI(self.partyRoleScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PartyRole


class PartyRoleType(GeneratedsSuper):
    """A type refining the role a role played by a party in one or more
    transactions. Examples include "AllPositions" and
    "SomePositions" for Guarantor. This can be extended to provide
    custom types."""
    member_data_items_ = {
        'partyRoleTypeScheme': MemberSpec_('partyRoleTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, partyRoleTypeScheme='http://www.fpml.org/coding-scheme/party-role-type', valueOf_=None):
        self.original_tagname_ = None
        self.partyRoleTypeScheme = _cast(None, partyRoleTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyRoleType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyRoleType.subclass:
            return PartyRoleType.subclass(*args_, **kwargs_)
        else:
            return PartyRoleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyRoleTypeScheme(self): return self.partyRoleTypeScheme
    def set_partyRoleTypeScheme(self, partyRoleTypeScheme): self.partyRoleTypeScheme = partyRoleTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartyRoleType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyRoleType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartyRoleType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyRoleType'):
        if self.partyRoleTypeScheme != "http://www.fpml.org/coding-scheme/party-role-type" and 'partyRoleTypeScheme' not in already_processed:
            already_processed.add('partyRoleTypeScheme')
            outfile.write(' partyRoleTypeScheme=%s' % (quote_attrib(self.partyRoleTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PartyRoleType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partyRoleTypeScheme', node)
        if value is not None and 'partyRoleTypeScheme' not in already_processed:
            already_processed.add('partyRoleTypeScheme')
            self.partyRoleTypeScheme = value
            self.validate_NonEmptyURI(self.partyRoleTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PartyRoleType


class PaymentBase(GeneratedsSuper):
    """An abstract base class for payment types."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PaymentBase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PaymentBase.subclass:
            return PaymentBase.subclass(*args_, **kwargs_)
        else:
            return PaymentBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PaymentBase', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentBase')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PaymentBase', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PaymentBase'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='PaymentBase', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PaymentBase


class PaymentBaseExtended(PaymentBase):
    """Base type for payments."""
    member_data_items_ = {
        'payerPartyReference': MemberSpec_('payerPartyReference', 'PartyReference', 0),
        'payerAccountReference': MemberSpec_('payerAccountReference', 'AccountReference', 0),
        'receiverPartyReference': MemberSpec_('receiverPartyReference', 'PartyReference', 0),
        'receiverAccountReference': MemberSpec_('receiverAccountReference', 'AccountReference', 0),
        'paymentDate': MemberSpec_('paymentDate', 'AdjustableOrRelativeDate', 0),
    }
    subclass = None
    superclass = PaymentBase
    def __init__(self, id=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, paymentDate=None, extensiontype_=None):
        self.original_tagname_ = None
        super(PaymentBaseExtended, self).__init__(id, extensiontype_, )
        self.payerPartyReference = payerPartyReference
        self.payerAccountReference = payerAccountReference
        self.receiverPartyReference = receiverPartyReference
        self.receiverAccountReference = receiverAccountReference
        self.paymentDate = paymentDate
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PaymentBaseExtended)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PaymentBaseExtended.subclass:
            return PaymentBaseExtended.subclass(*args_, **kwargs_)
        else:
            return PaymentBaseExtended(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_payerPartyReference(self): return self.payerPartyReference
    def set_payerPartyReference(self, payerPartyReference): self.payerPartyReference = payerPartyReference
    def get_payerAccountReference(self): return self.payerAccountReference
    def set_payerAccountReference(self, payerAccountReference): self.payerAccountReference = payerAccountReference
    def get_receiverPartyReference(self): return self.receiverPartyReference
    def set_receiverPartyReference(self, receiverPartyReference): self.receiverPartyReference = receiverPartyReference
    def get_receiverAccountReference(self): return self.receiverAccountReference
    def set_receiverAccountReference(self, receiverAccountReference): self.receiverAccountReference = receiverAccountReference
    def get_paymentDate(self): return self.paymentDate
    def set_paymentDate(self, paymentDate): self.paymentDate = paymentDate
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.payerPartyReference is not None or
            self.payerAccountReference is not None or
            self.receiverPartyReference is not None or
            self.receiverAccountReference is not None or
            self.paymentDate is not None or
            super(PaymentBaseExtended, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PaymentBaseExtended', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentBaseExtended')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PaymentBaseExtended', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PaymentBaseExtended'):
        super(PaymentBaseExtended, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentBaseExtended')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='PaymentBaseExtended', fromsubclass_=False, pretty_print=True):
        super(PaymentBaseExtended, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.payerPartyReference is not None:
            self.payerPartyReference.export(outfile, level, namespace_, name_='payerPartyReference', pretty_print=pretty_print)
        if self.payerAccountReference is not None:
            self.payerAccountReference.export(outfile, level, namespace_, name_='payerAccountReference', pretty_print=pretty_print)
        if self.receiverPartyReference is not None:
            self.receiverPartyReference.export(outfile, level, namespace_, name_='receiverPartyReference', pretty_print=pretty_print)
        if self.receiverAccountReference is not None:
            self.receiverAccountReference.export(outfile, level, namespace_, name_='receiverAccountReference', pretty_print=pretty_print)
        if self.paymentDate is not None:
            self.paymentDate.export(outfile, level, namespace_, name_='paymentDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(PaymentBaseExtended, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'payerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.payerPartyReference = obj_
            obj_.original_tagname_ = 'payerPartyReference'
        elif nodeName_ == 'payerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.payerAccountReference = obj_
            obj_.original_tagname_ = 'payerAccountReference'
        elif nodeName_ == 'receiverPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.receiverPartyReference = obj_
            obj_.original_tagname_ = 'receiverPartyReference'
        elif nodeName_ == 'receiverAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.receiverAccountReference = obj_
            obj_.original_tagname_ = 'receiverAccountReference'
        elif nodeName_ == 'paymentDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.paymentDate = obj_
            obj_.original_tagname_ = 'paymentDate'
        super(PaymentBaseExtended, self).buildChildren(child_, node, nodeName_, True)
# end class PaymentBaseExtended


class PaymentDetail(PaymentBase):
    member_data_items_ = {
        'paymentDate': MemberSpec_('paymentDate', 'AdjustableOrRelativeDate', 0),
        'paymentAmount': MemberSpec_('paymentAmount', 'Money', 0),
        'paymentRule': MemberSpec_('paymentRule', 'PaymentRule', 0),
        'paymentAmount': MemberSpec_('paymentAmount', 'Money', 0),
    }
    subclass = None
    superclass = PaymentBase
    def __init__(self, id=None, paymentDate=None, paymentAmount=None, paymentRule=None):
        self.original_tagname_ = None
        super(PaymentDetail, self).__init__(id, )
        self.paymentDate = paymentDate
        self.paymentAmount = paymentAmount
        self.paymentRule = paymentRule
        self.paymentAmount = paymentAmount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PaymentDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PaymentDetail.subclass:
            return PaymentDetail.subclass(*args_, **kwargs_)
        else:
            return PaymentDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_paymentDate(self): return self.paymentDate
    def set_paymentDate(self, paymentDate): self.paymentDate = paymentDate
    def get_paymentAmount(self): return self.paymentAmount
    def set_paymentAmount(self, paymentAmount): self.paymentAmount = paymentAmount
    def get_paymentRule(self): return self.paymentRule
    def set_paymentRule(self, paymentRule): self.paymentRule = paymentRule
    def get_paymentAmount(self): return self.paymentAmount
    def set_paymentAmount(self, paymentAmount): self.paymentAmount = paymentAmount
    def hasContent_(self):
        if (
            self.paymentDate is not None or
            self.paymentAmount is not None or
            self.paymentRule is not None or
            self.paymentAmount is not None or
            super(PaymentDetail, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PaymentDetail', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PaymentDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PaymentDetail'):
        super(PaymentDetail, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentDetail')
    def exportChildren(self, outfile, level, namespace_='', name_='PaymentDetail', fromsubclass_=False, pretty_print=True):
        super(PaymentDetail, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.paymentDate is not None:
            self.paymentDate.export(outfile, level, namespace_, name_='paymentDate', pretty_print=pretty_print)
        if self.paymentAmount is not None:
            self.paymentAmount.export(outfile, level, namespace_, name_='paymentAmount', pretty_print=pretty_print)
        if self.paymentRule is not None:
            self.paymentRule.export(outfile, level, namespace_, name_='paymentRule', pretty_print=pretty_print)
        if self.paymentAmount is not None:
            self.paymentAmount.export(outfile, level, namespace_, name_='paymentAmount', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PaymentDetail, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'paymentDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.paymentDate = obj_
            obj_.original_tagname_ = 'paymentDate'
        elif nodeName_ == 'paymentAmount':
            obj_ = Money.factory()
            obj_.build(child_)
            self.paymentAmount = obj_
            obj_.original_tagname_ = 'paymentAmount'
        elif nodeName_ == 'paymentRule':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <paymentRule> element')
            self.paymentRule = obj_
            obj_.original_tagname_ = 'paymentRule'
        elif nodeName_ == 'paymentAmount':
            obj_ = Money.factory()
            obj_.build(child_)
            self.paymentAmount = obj_
            obj_.original_tagname_ = 'paymentAmount'
        super(PaymentDetail, self).buildChildren(child_, node, nodeName_, True)
# end class PaymentDetail


class PaymentDetails(GeneratedsSuper):
    """Details on the referenced payment. e.g. Its cashflow components,
    settlement details."""
    member_data_items_ = {
        'paymentReference': MemberSpec_('paymentReference', 'PaymentReference', 0),
        'grossCashflow': MemberSpec_('grossCashflow', 'GrossCashflow', 1),
        'settlementInformation': MemberSpec_('settlementInformation', 'SettlementInformation', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, paymentReference=None, grossCashflow=None, settlementInformation=None):
        self.original_tagname_ = None
        self.paymentReference = paymentReference
        if grossCashflow is None:
            self.grossCashflow = []
        else:
            self.grossCashflow = grossCashflow
        self.settlementInformation = settlementInformation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PaymentDetails)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PaymentDetails.subclass:
            return PaymentDetails.subclass(*args_, **kwargs_)
        else:
            return PaymentDetails(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_paymentReference(self): return self.paymentReference
    def set_paymentReference(self, paymentReference): self.paymentReference = paymentReference
    def get_grossCashflow(self): return self.grossCashflow
    def set_grossCashflow(self, grossCashflow): self.grossCashflow = grossCashflow
    def add_grossCashflow(self, value): self.grossCashflow.append(value)
    def insert_grossCashflow_at(self, index, value): self.grossCashflow.insert(index, value)
    def replace_grossCashflow_at(self, index, value): self.grossCashflow[index] = value
    def get_settlementInformation(self): return self.settlementInformation
    def set_settlementInformation(self, settlementInformation): self.settlementInformation = settlementInformation
    def hasContent_(self):
        if (
            self.paymentReference is not None or
            self.grossCashflow or
            self.settlementInformation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PaymentDetails', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentDetails')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PaymentDetails', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PaymentDetails'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PaymentDetails', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.paymentReference is not None:
            self.paymentReference.export(outfile, level, namespace_, name_='paymentReference', pretty_print=pretty_print)
        for grossCashflow_ in self.grossCashflow:
            grossCashflow_.export(outfile, level, namespace_, name_='grossCashflow', pretty_print=pretty_print)
        if self.settlementInformation is not None:
            self.settlementInformation.export(outfile, level, namespace_, name_='settlementInformation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'paymentReference':
            obj_ = PaymentReference.factory()
            obj_.build(child_)
            self.paymentReference = obj_
            obj_.original_tagname_ = 'paymentReference'
        elif nodeName_ == 'grossCashflow':
            obj_ = GrossCashflow.factory()
            obj_.build(child_)
            self.grossCashflow.append(obj_)
            obj_.original_tagname_ = 'grossCashflow'
        elif nodeName_ == 'settlementInformation':
            obj_ = SettlementInformation.factory()
            obj_.build(child_)
            self.settlementInformation = obj_
            obj_.original_tagname_ = 'settlementInformation'
# end class PaymentDetails


class PaymentId(GeneratedsSuper):
    """An identifier used to identify a matchable payment."""
    member_data_items_ = {
        'paymentIdScheme': MemberSpec_('paymentIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, paymentIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.paymentIdScheme = _cast(None, paymentIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PaymentId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PaymentId.subclass:
            return PaymentId.subclass(*args_, **kwargs_)
        else:
            return PaymentId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_paymentIdScheme(self): return self.paymentIdScheme
    def set_paymentIdScheme(self, paymentIdScheme): self.paymentIdScheme = paymentIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PaymentId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PaymentId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PaymentId'):
        if self.paymentIdScheme is not None and 'paymentIdScheme' not in already_processed:
            already_processed.add('paymentIdScheme')
            outfile.write(' paymentIdScheme=%s' % (quote_attrib(self.paymentIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PaymentId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('paymentIdScheme', node)
        if value is not None and 'paymentIdScheme' not in already_processed:
            already_processed.add('paymentIdScheme')
            self.paymentIdScheme = value
            self.validate_NonEmptyURI(self.paymentIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PaymentId


class PaymentRule(GeneratedsSuper):
    """The abstract base type from which all calculation rules of the
    independent amount must be derived."""
    member_data_items_ = {
    }
    subclass = None
    superclass = None
    def __init__(self, extensiontype_=None):
        self.original_tagname_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PaymentRule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PaymentRule.subclass:
            return PaymentRule.subclass(*args_, **kwargs_)
        else:
            return PaymentRule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PaymentRule', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentRule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PaymentRule', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PaymentRule'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PaymentRule', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PaymentRule


class PaymentType(GeneratedsSuper):
    member_data_items_ = {
        'paymentTypeScheme': MemberSpec_('paymentTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, paymentTypeScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.paymentTypeScheme = _cast(None, paymentTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PaymentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PaymentType.subclass:
            return PaymentType.subclass(*args_, **kwargs_)
        else:
            return PaymentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_paymentTypeScheme(self): return self.paymentTypeScheme
    def set_paymentTypeScheme(self, paymentTypeScheme): self.paymentTypeScheme = paymentTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PaymentType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PaymentType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PaymentType'):
        if self.paymentTypeScheme is not None and 'paymentTypeScheme' not in already_processed:
            already_processed.add('paymentTypeScheme')
            outfile.write(' paymentTypeScheme=%s' % (quote_attrib(self.paymentTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PaymentType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('paymentTypeScheme', node)
        if value is not None and 'paymentTypeScheme' not in already_processed:
            already_processed.add('paymentTypeScheme')
            self.paymentTypeScheme = value
            self.validate_NonEmptyURI(self.paymentTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PaymentType


class Period(GeneratedsSuper):
    """A type to define recurring periods or time offsets."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'periodMultiplier': MemberSpec_('periodMultiplier', 'xsd:integer', 0),
        'period': MemberSpec_('period', ['PeriodEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, periodMultiplier=None, period=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.periodMultiplier = periodMultiplier
        self.period = period
        self.validate_PeriodEnum(self.period)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Period)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Period.subclass:
            return Period.subclass(*args_, **kwargs_)
        else:
            return Period(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_periodMultiplier(self): return self.periodMultiplier
    def set_periodMultiplier(self, periodMultiplier): self.periodMultiplier = periodMultiplier
    def get_period(self): return self.period
    def set_period(self, period): self.period = period
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_PeriodEnum(self, value):
        # Validate type PeriodEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['D', 'W', 'M', 'Y']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PeriodEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on PeriodEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.periodMultiplier is not None or
            self.period is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Period', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Period')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Period', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Period'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Period', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.periodMultiplier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%speriodMultiplier>%s</%speriodMultiplier>%s' % (namespace_, self.gds_format_integer(self.periodMultiplier, input_name='periodMultiplier'), namespace_, eol_))
        if self.period is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%speriod>%s</%speriod>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.period), input_name='period')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'periodMultiplier':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'periodMultiplier')
            self.periodMultiplier = ival_
        elif nodeName_ == 'period':
            period_ = child_.text
            period_ = re_.sub(String_cleanup_pat_, " ", period_).strip()
            period_ = self.gds_validate_string(period_, node, 'period')
            self.period = period_
            # validate type PeriodEnum
            self.validate_PeriodEnum(self.period)
# end class Period


class PeriodicDates(GeneratedsSuper):
    member_data_items_ = {
        'calculationStartDate': MemberSpec_('calculationStartDate', 'AdjustableOrRelativeDate', 0),
        'calculationEndDate': MemberSpec_('calculationEndDate', 'AdjustableOrRelativeDate', 0),
        'calculationPeriodFrequency': MemberSpec_('calculationPeriodFrequency', 'CalculationPeriodFrequency', 0),
        'calculationPeriodDatesAdjustments': MemberSpec_('calculationPeriodDatesAdjustments', 'BusinessDayAdjustments', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, calculationStartDate=None, calculationEndDate=None, calculationPeriodFrequency=None, calculationPeriodDatesAdjustments=None):
        self.original_tagname_ = None
        self.calculationStartDate = calculationStartDate
        self.calculationEndDate = calculationEndDate
        self.calculationPeriodFrequency = calculationPeriodFrequency
        self.calculationPeriodDatesAdjustments = calculationPeriodDatesAdjustments
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PeriodicDates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PeriodicDates.subclass:
            return PeriodicDates.subclass(*args_, **kwargs_)
        else:
            return PeriodicDates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_calculationStartDate(self): return self.calculationStartDate
    def set_calculationStartDate(self, calculationStartDate): self.calculationStartDate = calculationStartDate
    def get_calculationEndDate(self): return self.calculationEndDate
    def set_calculationEndDate(self, calculationEndDate): self.calculationEndDate = calculationEndDate
    def get_calculationPeriodFrequency(self): return self.calculationPeriodFrequency
    def set_calculationPeriodFrequency(self, calculationPeriodFrequency): self.calculationPeriodFrequency = calculationPeriodFrequency
    def get_calculationPeriodDatesAdjustments(self): return self.calculationPeriodDatesAdjustments
    def set_calculationPeriodDatesAdjustments(self, calculationPeriodDatesAdjustments): self.calculationPeriodDatesAdjustments = calculationPeriodDatesAdjustments
    def hasContent_(self):
        if (
            self.calculationStartDate is not None or
            self.calculationEndDate is not None or
            self.calculationPeriodFrequency is not None or
            self.calculationPeriodDatesAdjustments is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PeriodicDates', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PeriodicDates')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PeriodicDates', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PeriodicDates'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PeriodicDates', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.calculationStartDate is not None:
            self.calculationStartDate.export(outfile, level, namespace_, name_='calculationStartDate', pretty_print=pretty_print)
        if self.calculationEndDate is not None:
            self.calculationEndDate.export(outfile, level, namespace_, name_='calculationEndDate', pretty_print=pretty_print)
        if self.calculationPeriodFrequency is not None:
            self.calculationPeriodFrequency.export(outfile, level, namespace_, name_='calculationPeriodFrequency', pretty_print=pretty_print)
        if self.calculationPeriodDatesAdjustments is not None:
            self.calculationPeriodDatesAdjustments.export(outfile, level, namespace_, name_='calculationPeriodDatesAdjustments', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'calculationStartDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.calculationStartDate = obj_
            obj_.original_tagname_ = 'calculationStartDate'
        elif nodeName_ == 'calculationEndDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.calculationEndDate = obj_
            obj_.original_tagname_ = 'calculationEndDate'
        elif nodeName_ == 'calculationPeriodFrequency':
            obj_ = CalculationPeriodFrequency.factory()
            obj_.build(child_)
            self.calculationPeriodFrequency = obj_
            obj_.original_tagname_ = 'calculationPeriodFrequency'
        elif nodeName_ == 'calculationPeriodDatesAdjustments':
            obj_ = BusinessDayAdjustments.factory()
            obj_.build(child_)
            self.calculationPeriodDatesAdjustments = obj_
            obj_.original_tagname_ = 'calculationPeriodDatesAdjustments'
# end class PeriodicDates


class Person(GeneratedsSuper):
    """A type that represents information about a person connected with a
    trade or business process."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'honorific': MemberSpec_('honorific', ['NormalizedString', 'xsd:normalizedString'], 0),
        'firstName': MemberSpec_('firstName', ['NormalizedString', 'xsd:normalizedString'], 0),
        'middleName': MemberSpec_('middleName', ['NormalizedString', 'xsd:normalizedString'], 1),
        'initial': MemberSpec_('initial', ['Initial', 'xsd:normalizedString'], 1),
        'surname': MemberSpec_('surname', ['NormalizedString', 'xsd:normalizedString'], 0),
        'suffix': MemberSpec_('suffix', ['NormalizedString', 'xsd:normalizedString'], 0),
        'personId': MemberSpec_('personId', 'PersonId', 1),
        'businessUnitReference': MemberSpec_('businessUnitReference', 'BusinessUnitReference', 0),
        'contactInfo': MemberSpec_('contactInfo', 'ContactInformation', 0),
        'dateOfBirth': MemberSpec_('dateOfBirth', 'xsd:date', 0),
        'country': MemberSpec_('country', 'CountryCode', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, honorific=None, firstName=None, middleName=None, initial=None, surname=None, suffix=None, personId=None, businessUnitReference=None, contactInfo=None, dateOfBirth=None, country=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.honorific = honorific
        self.validate_NormalizedString(self.honorific)
        self.firstName = firstName
        self.validate_NormalizedString(self.firstName)
        if middleName is None:
            self.middleName = []
        else:
            self.middleName = middleName
        if initial is None:
            self.initial = []
        else:
            self.initial = initial
        self.surname = surname
        self.validate_NormalizedString(self.surname)
        self.suffix = suffix
        self.validate_NormalizedString(self.suffix)
        if personId is None:
            self.personId = []
        else:
            self.personId = personId
        self.businessUnitReference = businessUnitReference
        self.contactInfo = contactInfo
        if isinstance(dateOfBirth, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(dateOfBirth, '%Y-%m-%d').date()
        else:
            initvalue_ = dateOfBirth
        self.dateOfBirth = initvalue_
        self.country = country
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Person)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Person.subclass:
            return Person.subclass(*args_, **kwargs_)
        else:
            return Person(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_honorific(self): return self.honorific
    def set_honorific(self, honorific): self.honorific = honorific
    def get_firstName(self): return self.firstName
    def set_firstName(self, firstName): self.firstName = firstName
    def get_middleName(self): return self.middleName
    def set_middleName(self, middleName): self.middleName = middleName
    def add_middleName(self, value): self.middleName.append(value)
    def insert_middleName_at(self, index, value): self.middleName.insert(index, value)
    def replace_middleName_at(self, index, value): self.middleName[index] = value
    def get_initial(self): return self.initial
    def set_initial(self, initial): self.initial = initial
    def add_initial(self, value): self.initial.append(value)
    def insert_initial_at(self, index, value): self.initial.insert(index, value)
    def replace_initial_at(self, index, value): self.initial[index] = value
    def get_surname(self): return self.surname
    def set_surname(self, surname): self.surname = surname
    def get_suffix(self): return self.suffix
    def set_suffix(self, suffix): self.suffix = suffix
    def get_personId(self): return self.personId
    def set_personId(self, personId): self.personId = personId
    def add_personId(self, value): self.personId.append(value)
    def insert_personId_at(self, index, value): self.personId.insert(index, value)
    def replace_personId_at(self, index, value): self.personId[index] = value
    def get_businessUnitReference(self): return self.businessUnitReference
    def set_businessUnitReference(self, businessUnitReference): self.businessUnitReference = businessUnitReference
    def get_contactInfo(self): return self.contactInfo
    def set_contactInfo(self, contactInfo): self.contactInfo = contactInfo
    def get_dateOfBirth(self): return self.dateOfBirth
    def set_dateOfBirth(self, dateOfBirth): self.dateOfBirth = dateOfBirth
    def get_country(self): return self.country
    def set_country(self, country): self.country = country
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_NormalizedString(self, value):
        # Validate type NormalizedString, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NormalizedString' % {"value" : value} )
    def validate_Initial(self, value):
        # Validate type Initial, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on Initial' % {"value" : value} )
    def hasContent_(self):
        if (
            self.honorific is not None or
            self.firstName is not None or
            self.middleName or
            self.initial or
            self.surname is not None or
            self.suffix is not None or
            self.personId or
            self.businessUnitReference is not None or
            self.contactInfo is not None or
            self.dateOfBirth is not None or
            self.country is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Person', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Person')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Person', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Person'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Person', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.honorific is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shonorific>%s</%shonorific>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.honorific), input_name='honorific')), namespace_, eol_))
        if self.firstName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfirstName>%s</%sfirstName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.firstName), input_name='firstName')), namespace_, eol_))
        for middleName_ in self.middleName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smiddleName>%s</%smiddleName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(middleName_), input_name='middleName')), namespace_, eol_))
        for initial_ in self.initial:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinitial>%s</%sinitial>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(initial_), input_name='initial')), namespace_, eol_))
        if self.surname is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssurname>%s</%ssurname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.surname), input_name='surname')), namespace_, eol_))
        if self.suffix is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssuffix>%s</%ssuffix>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.suffix), input_name='suffix')), namespace_, eol_))
        for personId_ in self.personId:
            personId_.export(outfile, level, namespace_, name_='personId', pretty_print=pretty_print)
        if self.businessUnitReference is not None:
            self.businessUnitReference.export(outfile, level, namespace_, name_='businessUnitReference', pretty_print=pretty_print)
        if self.contactInfo is not None:
            self.contactInfo.export(outfile, level, namespace_, name_='contactInfo', pretty_print=pretty_print)
        if self.dateOfBirth is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdateOfBirth>%s</%sdateOfBirth>%s' % (namespace_, self.gds_format_date(self.dateOfBirth, input_name='dateOfBirth'), namespace_, eol_))
        if self.country is not None:
            self.country.export(outfile, level, namespace_, name_='country', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'honorific':
            honorific_ = child_.text
            honorific_ = self.gds_validate_string(honorific_, node, 'honorific')
            self.honorific = honorific_
            # validate type NormalizedString
            self.validate_NormalizedString(self.honorific)
        elif nodeName_ == 'firstName':
            firstName_ = child_.text
            firstName_ = self.gds_validate_string(firstName_, node, 'firstName')
            self.firstName = firstName_
            # validate type NormalizedString
            self.validate_NormalizedString(self.firstName)
        elif nodeName_ == 'middleName':
            middleName_ = child_.text
            middleName_ = self.gds_validate_string(middleName_, node, 'middleName')
            self.middleName.append(middleName_)
            # validate type NormalizedString
            self.validate_NormalizedString(self.middleName[-1])
        elif nodeName_ == 'initial':
            initial_ = child_.text
            initial_ = self.gds_validate_string(initial_, node, 'initial')
            self.initial.append(initial_)
            # validate type Initial
            self.validate_Initial(self.initial[-1])
        elif nodeName_ == 'surname':
            surname_ = child_.text
            surname_ = self.gds_validate_string(surname_, node, 'surname')
            self.surname = surname_
            # validate type NormalizedString
            self.validate_NormalizedString(self.surname)
        elif nodeName_ == 'suffix':
            suffix_ = child_.text
            suffix_ = self.gds_validate_string(suffix_, node, 'suffix')
            self.suffix = suffix_
            # validate type NormalizedString
            self.validate_NormalizedString(self.suffix)
        elif nodeName_ == 'personId':
            obj_ = PersonId.factory()
            obj_.build(child_)
            self.personId.append(obj_)
            obj_.original_tagname_ = 'personId'
        elif nodeName_ == 'businessUnitReference':
            obj_ = BusinessUnitReference.factory()
            obj_.build(child_)
            self.businessUnitReference = obj_
            obj_.original_tagname_ = 'businessUnitReference'
        elif nodeName_ == 'contactInfo':
            obj_ = ContactInformation.factory()
            obj_.build(child_)
            self.contactInfo = obj_
            obj_.original_tagname_ = 'contactInfo'
        elif nodeName_ == 'dateOfBirth':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.dateOfBirth = dval_
        elif nodeName_ == 'country':
            obj_ = CountryCode.factory()
            obj_.build(child_)
            self.country = obj_
            obj_.original_tagname_ = 'country'
# end class Person


class PersonId(GeneratedsSuper):
    """An identifier used to identify an individual person."""
    member_data_items_ = {
        'personIdScheme': MemberSpec_('personIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, personIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.personIdScheme = _cast(None, personIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PersonId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PersonId.subclass:
            return PersonId.subclass(*args_, **kwargs_)
        else:
            return PersonId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_personIdScheme(self): return self.personIdScheme
    def set_personIdScheme(self, personIdScheme): self.personIdScheme = personIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PersonId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PersonId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PersonId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PersonId'):
        if self.personIdScheme is not None and 'personIdScheme' not in already_processed:
            already_processed.add('personIdScheme')
            outfile.write(' personIdScheme=%s' % (quote_attrib(self.personIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PersonId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('personIdScheme', node)
        if value is not None and 'personIdScheme' not in already_processed:
            already_processed.add('personIdScheme')
            self.personIdScheme = value
            self.validate_NonEmptyURI(self.personIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PersonId


class PersonRole(GeneratedsSuper):
    """A type describing a role played by a person in one or more
    transactions. Examples include roles such as Trader, Broker,
    MiddleOffice, Legal, etc. This can be extended to provide custom
    roles."""
    member_data_items_ = {
        'personRoleScheme': MemberSpec_('personRoleScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, personRoleScheme='http://www.fpml.org/coding-scheme/person-role', valueOf_=None):
        self.original_tagname_ = None
        self.personRoleScheme = _cast(None, personRoleScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PersonRole)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PersonRole.subclass:
            return PersonRole.subclass(*args_, **kwargs_)
        else:
            return PersonRole(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_personRoleScheme(self): return self.personRoleScheme
    def set_personRoleScheme(self, personRoleScheme): self.personRoleScheme = personRoleScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PersonRole', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PersonRole')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PersonRole', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PersonRole'):
        if self.personRoleScheme != "http://www.fpml.org/coding-scheme/person-role" and 'personRoleScheme' not in already_processed:
            already_processed.add('personRoleScheme')
            outfile.write(' personRoleScheme=%s' % (quote_attrib(self.personRoleScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PersonRole', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('personRoleScheme', node)
        if value is not None and 'personRoleScheme' not in already_processed:
            already_processed.add('personRoleScheme')
            self.personRoleScheme = value
            self.validate_NonEmptyURI(self.personRoleScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PersonRole


class PositiveMoney(MoneyBase):
    """A type defining a positive money amount"""
    member_data_items_ = {
        'amount': MemberSpec_('amount', ['PositiveDecimal', 'xsd:decimal'], 0),
    }
    subclass = None
    superclass = MoneyBase
    def __init__(self, id=None, currency=None, amount=None):
        self.original_tagname_ = None
        super(PositiveMoney, self).__init__(id, currency, )
        self.amount = amount
        self.validate_PositiveDecimal(self.amount)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PositiveMoney)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PositiveMoney.subclass:
            return PositiveMoney.subclass(*args_, **kwargs_)
        else:
            return PositiveMoney(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_amount(self): return self.amount
    def set_amount(self, amount): self.amount = amount
    def validate_PositiveDecimal(self, value):
        # Validate type PositiveDecimal, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value <= 0:
                warnings_.warn('Value "%(value)s" does not match xsd minExclusive restriction on PositiveDecimal' % {"value" : value} )
    def hasContent_(self):
        if (
            self.amount is not None or
            super(PositiveMoney, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PositiveMoney', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PositiveMoney')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PositiveMoney', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PositiveMoney'):
        super(PositiveMoney, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PositiveMoney')
    def exportChildren(self, outfile, level, namespace_='', name_='PositiveMoney', fromsubclass_=False, pretty_print=True):
        super(PositiveMoney, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.amount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%samount>%s</%samount>%s' % (namespace_, self.gds_format_float(self.amount, input_name='amount'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PositiveMoney, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'amount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'amount')
            self.amount = fval_
            # validate type PositiveDecimal
            self.validate_PositiveDecimal(self.amount)
        super(PositiveMoney, self).buildChildren(child_, node, nodeName_, True)
# end class PositiveMoney


class PrevailingTime(GeneratedsSuper):
    """A type for defining a time with respect to a geographic location,
    for example 11:00 Phoenix, USA. This type should be used where a
    wider range of locations than those available as business
    centres is required."""
    member_data_items_ = {
        'hourMinuteTime': MemberSpec_('hourMinuteTime', ['HourMinuteTime', 'xsd:time'], 0),
        'location': MemberSpec_('location', 'TimezoneLocation', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, hourMinuteTime=None, location=None):
        self.original_tagname_ = None
        if isinstance(hourMinuteTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(hourMinuteTime, '%H:%M:%S').time()
        else:
            initvalue_ = hourMinuteTime
        self.hourMinuteTime = initvalue_
        self.location = location
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PrevailingTime)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PrevailingTime.subclass:
            return PrevailingTime.subclass(*args_, **kwargs_)
        else:
            return PrevailingTime(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_hourMinuteTime(self): return self.hourMinuteTime
    def set_hourMinuteTime(self, hourMinuteTime): self.hourMinuteTime = hourMinuteTime
    def get_location(self): return self.location
    def set_location(self, location): self.location = location
    def validate_HourMinuteTime(self, value):
        # Validate type HourMinuteTime, a restriction on xsd:time.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_HourMinuteTime_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_HourMinuteTime_patterns_, ))
    validate_HourMinuteTime_patterns_ = [['^[0-2][0-9]:[0-5][0-9]:00$']]
    def hasContent_(self):
        if (
            self.hourMinuteTime is not None or
            self.location is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PrevailingTime', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PrevailingTime')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PrevailingTime', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PrevailingTime'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PrevailingTime', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.hourMinuteTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shourMinuteTime>%s</%shourMinuteTime>%s' % (namespace_, self.gds_format_time(self.hourMinuteTime, input_name='hourMinuteTime'), namespace_, eol_))
        if self.location is not None:
            self.location.export(outfile, level, namespace_, name_='location', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'hourMinuteTime':
            sval_ = child_.text
            dval_ = self.gds_parse_time(sval_)
            self.hourMinuteTime = dval_
            # validate type HourMinuteTime
            self.validate_HourMinuteTime(self.hourMinuteTime)
        elif nodeName_ == 'location':
            obj_ = TimezoneLocation.factory()
            obj_.build(child_)
            self.location = obj_
            obj_.original_tagname_ = 'location'
# end class PrevailingTime


class PricingStructure(GeneratedsSuper):
    """An abstract pricing structure base type. Used as a base for
    structures such as yield curves and volatility matrices."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'name': MemberSpec_('name', ['NormalizedString', 'xsd:normalizedString'], 0),
        'currency': MemberSpec_('currency', 'Currency', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, currency=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.name = name
        self.validate_NormalizedString(self.name)
        self.currency = currency
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PricingStructure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PricingStructure.subclass:
            return PricingStructure.subclass(*args_, **kwargs_)
        else:
            return PricingStructure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_NormalizedString(self, value):
        # Validate type NormalizedString, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NormalizedString' % {"value" : value} )
    def hasContent_(self):
        if (
            self.name is not None or
            self.currency is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PricingStructure', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PricingStructure')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PricingStructure', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PricingStructure'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PricingStructure', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespace_, eol_))
        if self.currency is not None:
            self.currency.export(outfile, level, namespace_, name_='currency', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
            # validate type NormalizedString
            self.validate_NormalizedString(self.name)
        elif nodeName_ == 'currency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
# end class PricingStructure


class PrincipalExchanges(GeneratedsSuper):
    """A type defining which principal exchanges occur for the stream."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'initialExchange': MemberSpec_('initialExchange', 'xsd:boolean', 0),
        'finalExchange': MemberSpec_('finalExchange', 'xsd:boolean', 0),
        'intermediateExchange': MemberSpec_('intermediateExchange', 'xsd:boolean', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, initialExchange=None, finalExchange=None, intermediateExchange=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.initialExchange = initialExchange
        self.finalExchange = finalExchange
        self.intermediateExchange = intermediateExchange
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PrincipalExchanges)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PrincipalExchanges.subclass:
            return PrincipalExchanges.subclass(*args_, **kwargs_)
        else:
            return PrincipalExchanges(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_initialExchange(self): return self.initialExchange
    def set_initialExchange(self, initialExchange): self.initialExchange = initialExchange
    def get_finalExchange(self): return self.finalExchange
    def set_finalExchange(self, finalExchange): self.finalExchange = finalExchange
    def get_intermediateExchange(self): return self.intermediateExchange
    def set_intermediateExchange(self, intermediateExchange): self.intermediateExchange = intermediateExchange
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.initialExchange is not None or
            self.finalExchange is not None or
            self.intermediateExchange is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PrincipalExchanges', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PrincipalExchanges')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PrincipalExchanges', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PrincipalExchanges'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PrincipalExchanges', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.initialExchange is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinitialExchange>%s</%sinitialExchange>%s' % (namespace_, self.gds_format_boolean(self.initialExchange, input_name='initialExchange'), namespace_, eol_))
        if self.finalExchange is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfinalExchange>%s</%sfinalExchange>%s' % (namespace_, self.gds_format_boolean(self.finalExchange, input_name='finalExchange'), namespace_, eol_))
        if self.intermediateExchange is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sintermediateExchange>%s</%sintermediateExchange>%s' % (namespace_, self.gds_format_boolean(self.intermediateExchange, input_name='intermediateExchange'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'initialExchange':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'initialExchange')
            self.initialExchange = ival_
        elif nodeName_ == 'finalExchange':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'finalExchange')
            self.finalExchange = ival_
        elif nodeName_ == 'intermediateExchange':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'intermediateExchange')
            self.intermediateExchange = ival_
# end class PrincipalExchanges


class Product(GeneratedsSuper):
    """The base type which all FpML products extend."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'primaryAssetClass': MemberSpec_('primaryAssetClass', 'AssetClass', 0),
        'secondaryAssetClass': MemberSpec_('secondaryAssetClass', 'AssetClass', 1),
        'productType': MemberSpec_('productType', 'ProductType', 1),
        'productId': MemberSpec_('productId', 'ProductId', 1),
        'productId': MemberSpec_('productId', 'ProductId', 1),
        'assetClass': MemberSpec_('assetClass', 'AssetClass', 1),
        'embeddedOptionType': MemberSpec_('embeddedOptionType', 'EmbeddedOptionType', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, primaryAssetClass=None, secondaryAssetClass=None, productType=None, productId=None, assetClass=None, embeddedOptionType=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.primaryAssetClass = primaryAssetClass
        if secondaryAssetClass is None:
            self.secondaryAssetClass = []
        else:
            self.secondaryAssetClass = secondaryAssetClass
        if productType is None:
            self.productType = []
        else:
            self.productType = productType
        if productId is None:
            self.productId = []
        else:
            self.productId = productId
        if productId is None:
            self.productId = []
        else:
            self.productId = productId
        if assetClass is None:
            self.assetClass = []
        else:
            self.assetClass = assetClass
        if embeddedOptionType is None:
            self.embeddedOptionType = []
        else:
            self.embeddedOptionType = embeddedOptionType
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Product)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Product.subclass:
            return Product.subclass(*args_, **kwargs_)
        else:
            return Product(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_primaryAssetClass(self): return self.primaryAssetClass
    def set_primaryAssetClass(self, primaryAssetClass): self.primaryAssetClass = primaryAssetClass
    def get_secondaryAssetClass(self): return self.secondaryAssetClass
    def set_secondaryAssetClass(self, secondaryAssetClass): self.secondaryAssetClass = secondaryAssetClass
    def add_secondaryAssetClass(self, value): self.secondaryAssetClass.append(value)
    def insert_secondaryAssetClass_at(self, index, value): self.secondaryAssetClass.insert(index, value)
    def replace_secondaryAssetClass_at(self, index, value): self.secondaryAssetClass[index] = value
    def get_productType(self): return self.productType
    def set_productType(self, productType): self.productType = productType
    def add_productType(self, value): self.productType.append(value)
    def insert_productType_at(self, index, value): self.productType.insert(index, value)
    def replace_productType_at(self, index, value): self.productType[index] = value
    def get_productId(self): return self.productId
    def set_productId(self, productId): self.productId = productId
    def add_productId(self, value): self.productId.append(value)
    def insert_productId_at(self, index, value): self.productId.insert(index, value)
    def replace_productId_at(self, index, value): self.productId[index] = value
    def get_productId(self): return self.productId
    def set_productId(self, productId): self.productId = productId
    def add_productId(self, value): self.productId.append(value)
    def insert_productId_at(self, index, value): self.productId.insert(index, value)
    def replace_productId_at(self, index, value): self.productId[index] = value
    def get_assetClass(self): return self.assetClass
    def set_assetClass(self, assetClass): self.assetClass = assetClass
    def add_assetClass(self, value): self.assetClass.append(value)
    def insert_assetClass_at(self, index, value): self.assetClass.insert(index, value)
    def replace_assetClass_at(self, index, value): self.assetClass[index] = value
    def get_embeddedOptionType(self): return self.embeddedOptionType
    def set_embeddedOptionType(self, embeddedOptionType): self.embeddedOptionType = embeddedOptionType
    def add_embeddedOptionType(self, value): self.embeddedOptionType.append(value)
    def insert_embeddedOptionType_at(self, index, value): self.embeddedOptionType.insert(index, value)
    def replace_embeddedOptionType_at(self, index, value): self.embeddedOptionType[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.primaryAssetClass is not None or
            self.secondaryAssetClass or
            self.productType or
            self.productId or
            self.productId or
            self.assetClass or
            self.embeddedOptionType
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Product', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Product')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Product', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Product'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Product', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.primaryAssetClass is not None:
            self.primaryAssetClass.export(outfile, level, namespace_, name_='primaryAssetClass', pretty_print=pretty_print)
        for secondaryAssetClass_ in self.secondaryAssetClass:
            secondaryAssetClass_.export(outfile, level, namespace_, name_='secondaryAssetClass', pretty_print=pretty_print)
        for productType_ in self.productType:
            productType_.export(outfile, level, namespace_, name_='productType', pretty_print=pretty_print)
        for productId_ in self.productId:
            productId_.export(outfile, level, namespace_, name_='productId', pretty_print=pretty_print)
        for productId_ in self.productId:
            productId_.export(outfile, level, namespace_, name_='productId', pretty_print=pretty_print)
        for assetClass_ in self.assetClass:
            assetClass_.export(outfile, level, namespace_, name_='assetClass', pretty_print=pretty_print)
        for embeddedOptionType_ in self.embeddedOptionType:
            embeddedOptionType_.export(outfile, level, namespace_, name_='embeddedOptionType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'primaryAssetClass':
            obj_ = AssetClass.factory()
            obj_.build(child_)
            self.primaryAssetClass = obj_
            obj_.original_tagname_ = 'primaryAssetClass'
        elif nodeName_ == 'secondaryAssetClass':
            obj_ = AssetClass.factory()
            obj_.build(child_)
            self.secondaryAssetClass.append(obj_)
            obj_.original_tagname_ = 'secondaryAssetClass'
        elif nodeName_ == 'productType':
            obj_ = ProductType.factory()
            obj_.build(child_)
            self.productType.append(obj_)
            obj_.original_tagname_ = 'productType'
        elif nodeName_ == 'productId':
            obj_ = ProductId.factory()
            obj_.build(child_)
            self.productId.append(obj_)
            obj_.original_tagname_ = 'productId'
        elif nodeName_ == 'productId':
            obj_ = ProductId.factory()
            obj_.build(child_)
            self.productId.append(obj_)
            obj_.original_tagname_ = 'productId'
        elif nodeName_ == 'assetClass':
            obj_ = AssetClass.factory()
            obj_.build(child_)
            self.assetClass.append(obj_)
            obj_.original_tagname_ = 'assetClass'
        elif nodeName_ == 'embeddedOptionType':
            obj_ = EmbeddedOptionType.factory()
            obj_.build(child_)
            self.embeddedOptionType.append(obj_)
            obj_.original_tagname_ = 'embeddedOptionType'
# end class Product


class ProductId(GeneratedsSuper):
    member_data_items_ = {
        'productIdScheme': MemberSpec_('productIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyLongScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, productIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.productIdScheme = _cast(None, productIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductId.subclass:
            return ProductId.subclass(*args_, **kwargs_)
        else:
            return ProductId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_productIdScheme(self): return self.productIdScheme
    def set_productIdScheme(self, productIdScheme): self.productIdScheme = productIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ProductId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ProductId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProductId'):
        if self.productIdScheme is not None and 'productIdScheme' not in already_processed:
            already_processed.add('productIdScheme')
            outfile.write(' productIdScheme=%s' % (quote_attrib(self.productIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ProductId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('productIdScheme', node)
        if value is not None and 'productIdScheme' not in already_processed:
            already_processed.add('productIdScheme')
            self.productIdScheme = value
            self.validate_NonEmptyURI(self.productIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ProductId


class ProductType(GeneratedsSuper):
    member_data_items_ = {
        'productTypeScheme': MemberSpec_('productTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyLongScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, productTypeScheme='http://www.fpml.org/coding-scheme/product-taxonomy', valueOf_=None):
        self.original_tagname_ = None
        self.productTypeScheme = _cast(None, productTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductType.subclass:
            return ProductType.subclass(*args_, **kwargs_)
        else:
            return ProductType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_productTypeScheme(self): return self.productTypeScheme
    def set_productTypeScheme(self, productTypeScheme): self.productTypeScheme = productTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ProductType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ProductType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProductType'):
        if self.productTypeScheme != "http://www.fpml.org/coding-scheme/product-taxonomy" and 'productTypeScheme' not in already_processed:
            already_processed.add('productTypeScheme')
            outfile.write(' productTypeScheme=%s' % (quote_attrib(self.productTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ProductType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('productTypeScheme', node)
        if value is not None and 'productTypeScheme' not in already_processed:
            already_processed.add('productTypeScheme')
            self.productTypeScheme = value
            self.validate_NonEmptyURI(self.productTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ProductType


class ProposedCollateralAllocation(GeneratedsSuper):
    """The proposed collateral allocation."""
    member_data_items_ = {
        'allocationPartyReference': MemberSpec_('allocationPartyReference', 'PartyReference', 0),
        'allocationAccountReference': MemberSpec_('allocationAccountReference', 'AccountReference', 0),
        'collateralValueAllocation': MemberSpec_('collateralValueAllocation', 'CollateralValueAllocation', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, allocationPartyReference=None, allocationAccountReference=None, collateralValueAllocation=None):
        self.original_tagname_ = None
        self.allocationPartyReference = allocationPartyReference
        self.allocationAccountReference = allocationAccountReference
        if collateralValueAllocation is None:
            self.collateralValueAllocation = []
        else:
            self.collateralValueAllocation = collateralValueAllocation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProposedCollateralAllocation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProposedCollateralAllocation.subclass:
            return ProposedCollateralAllocation.subclass(*args_, **kwargs_)
        else:
            return ProposedCollateralAllocation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_allocationPartyReference(self): return self.allocationPartyReference
    def set_allocationPartyReference(self, allocationPartyReference): self.allocationPartyReference = allocationPartyReference
    def get_allocationAccountReference(self): return self.allocationAccountReference
    def set_allocationAccountReference(self, allocationAccountReference): self.allocationAccountReference = allocationAccountReference
    def get_collateralValueAllocation(self): return self.collateralValueAllocation
    def set_collateralValueAllocation(self, collateralValueAllocation): self.collateralValueAllocation = collateralValueAllocation
    def add_collateralValueAllocation(self, value): self.collateralValueAllocation.append(value)
    def insert_collateralValueAllocation_at(self, index, value): self.collateralValueAllocation.insert(index, value)
    def replace_collateralValueAllocation_at(self, index, value): self.collateralValueAllocation[index] = value
    def hasContent_(self):
        if (
            self.allocationPartyReference is not None or
            self.allocationAccountReference is not None or
            self.collateralValueAllocation
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ProposedCollateralAllocation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProposedCollateralAllocation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ProposedCollateralAllocation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProposedCollateralAllocation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ProposedCollateralAllocation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.allocationPartyReference is not None:
            self.allocationPartyReference.export(outfile, level, namespace_, name_='allocationPartyReference', pretty_print=pretty_print)
        if self.allocationAccountReference is not None:
            self.allocationAccountReference.export(outfile, level, namespace_, name_='allocationAccountReference', pretty_print=pretty_print)
        for collateralValueAllocation_ in self.collateralValueAllocation:
            collateralValueAllocation_.export(outfile, level, namespace_, name_='collateralValueAllocation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'allocationPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.allocationPartyReference = obj_
            obj_.original_tagname_ = 'allocationPartyReference'
        elif nodeName_ == 'allocationAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.allocationAccountReference = obj_
            obj_.original_tagname_ = 'allocationAccountReference'
        elif nodeName_ == 'collateralValueAllocation':
            obj_ = CollateralValueAllocation.factory()
            obj_.build(child_)
            self.collateralValueAllocation.append(obj_)
            obj_.original_tagname_ = 'collateralValueAllocation'
# end class ProposedCollateralAllocation


class QuotedCurrencyPair(GeneratedsSuper):
    """A type that describes the composition of a rate that has been quoted
    or is to be quoted. This includes the two currencies and the
    quotation relationship between the two currencies and is used as
    a building block throughout the FX specification."""
    member_data_items_ = {
        'currency1': MemberSpec_('currency1', 'Currency', 0),
        'currency2': MemberSpec_('currency2', 'Currency', 0),
        'quoteBasis': MemberSpec_('quoteBasis', ['QuoteBasisEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, currency1=None, currency2=None, quoteBasis=None):
        self.original_tagname_ = None
        self.currency1 = currency1
        self.currency2 = currency2
        self.quoteBasis = quoteBasis
        self.validate_QuoteBasisEnum(self.quoteBasis)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QuotedCurrencyPair)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QuotedCurrencyPair.subclass:
            return QuotedCurrencyPair.subclass(*args_, **kwargs_)
        else:
            return QuotedCurrencyPair(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_currency1(self): return self.currency1
    def set_currency1(self, currency1): self.currency1 = currency1
    def get_currency2(self): return self.currency2
    def set_currency2(self, currency2): self.currency2 = currency2
    def get_quoteBasis(self): return self.quoteBasis
    def set_quoteBasis(self, quoteBasis): self.quoteBasis = quoteBasis
    def validate_QuoteBasisEnum(self, value):
        # Validate type QuoteBasisEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Currency1PerCurrency2', 'Currency2PerCurrency1']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on QuoteBasisEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on QuoteBasisEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.currency1 is not None or
            self.currency2 is not None or
            self.quoteBasis is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QuotedCurrencyPair', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QuotedCurrencyPair')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QuotedCurrencyPair', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QuotedCurrencyPair'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='QuotedCurrencyPair', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.currency1 is not None:
            self.currency1.export(outfile, level, namespace_, name_='currency1', pretty_print=pretty_print)
        if self.currency2 is not None:
            self.currency2.export(outfile, level, namespace_, name_='currency2', pretty_print=pretty_print)
        if self.quoteBasis is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%squoteBasis>%s</%squoteBasis>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.quoteBasis), input_name='quoteBasis')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'currency1':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency1 = obj_
            obj_.original_tagname_ = 'currency1'
        elif nodeName_ == 'currency2':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency2 = obj_
            obj_.original_tagname_ = 'currency2'
        elif nodeName_ == 'quoteBasis':
            quoteBasis_ = child_.text
            quoteBasis_ = re_.sub(String_cleanup_pat_, " ", quoteBasis_).strip()
            quoteBasis_ = self.gds_validate_string(quoteBasis_, node, 'quoteBasis')
            self.quoteBasis = quoteBasis_
            # validate type QuoteBasisEnum
            self.validate_QuoteBasisEnum(self.quoteBasis)
# end class QuotedCurrencyPair


class Rate(GeneratedsSuper):
    """The abstract base class for all types which define interest rate
    streams."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Rate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Rate.subclass:
            return Rate.subclass(*args_, **kwargs_)
        else:
            return Rate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Rate', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Rate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Rate', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Rate'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Rate', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Rate


class RateObservation(GeneratedsSuper):
    """A type defining parameters associated with an individual observation
    or fixing. This type forms part of the cashflow representation
    of a stream."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'resetDate': MemberSpec_('resetDate', 'xsd:date', 0),
        'adjustedFixingDate': MemberSpec_('adjustedFixingDate', 'xsd:date', 0),
        'observedRate': MemberSpec_('observedRate', 'xsd:decimal', 0),
        'treatedRate': MemberSpec_('treatedRate', 'xsd:decimal', 0),
        'observationWeight': MemberSpec_('observationWeight', 'xsd:positiveInteger', 0),
        'rateReference': MemberSpec_('rateReference', 'RateReference', 0),
        'forecastRate': MemberSpec_('forecastRate', 'xsd:decimal', 0),
        'treatedForecastRate': MemberSpec_('treatedForecastRate', 'xsd:decimal', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, resetDate=None, adjustedFixingDate=None, observedRate=None, treatedRate=None, observationWeight=None, rateReference=None, forecastRate=None, treatedForecastRate=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if isinstance(resetDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(resetDate, '%Y-%m-%d').date()
        else:
            initvalue_ = resetDate
        self.resetDate = initvalue_
        if isinstance(adjustedFixingDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(adjustedFixingDate, '%Y-%m-%d').date()
        else:
            initvalue_ = adjustedFixingDate
        self.adjustedFixingDate = initvalue_
        self.observedRate = observedRate
        self.treatedRate = treatedRate
        self.observationWeight = observationWeight
        self.rateReference = rateReference
        self.forecastRate = forecastRate
        self.treatedForecastRate = treatedForecastRate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RateObservation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RateObservation.subclass:
            return RateObservation.subclass(*args_, **kwargs_)
        else:
            return RateObservation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_resetDate(self): return self.resetDate
    def set_resetDate(self, resetDate): self.resetDate = resetDate
    def get_adjustedFixingDate(self): return self.adjustedFixingDate
    def set_adjustedFixingDate(self, adjustedFixingDate): self.adjustedFixingDate = adjustedFixingDate
    def get_observedRate(self): return self.observedRate
    def set_observedRate(self, observedRate): self.observedRate = observedRate
    def get_treatedRate(self): return self.treatedRate
    def set_treatedRate(self, treatedRate): self.treatedRate = treatedRate
    def get_observationWeight(self): return self.observationWeight
    def set_observationWeight(self, observationWeight): self.observationWeight = observationWeight
    def get_rateReference(self): return self.rateReference
    def set_rateReference(self, rateReference): self.rateReference = rateReference
    def get_forecastRate(self): return self.forecastRate
    def set_forecastRate(self, forecastRate): self.forecastRate = forecastRate
    def get_treatedForecastRate(self): return self.treatedForecastRate
    def set_treatedForecastRate(self, treatedForecastRate): self.treatedForecastRate = treatedForecastRate
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.resetDate is not None or
            self.adjustedFixingDate is not None or
            self.observedRate is not None or
            self.treatedRate is not None or
            self.observationWeight is not None or
            self.rateReference is not None or
            self.forecastRate is not None or
            self.treatedForecastRate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RateObservation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RateObservation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RateObservation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RateObservation'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RateObservation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.resetDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sresetDate>%s</%sresetDate>%s' % (namespace_, self.gds_format_date(self.resetDate, input_name='resetDate'), namespace_, eol_))
        if self.adjustedFixingDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sadjustedFixingDate>%s</%sadjustedFixingDate>%s' % (namespace_, self.gds_format_date(self.adjustedFixingDate, input_name='adjustedFixingDate'), namespace_, eol_))
        if self.observedRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sobservedRate>%s</%sobservedRate>%s' % (namespace_, self.gds_format_float(self.observedRate, input_name='observedRate'), namespace_, eol_))
        if self.treatedRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%streatedRate>%s</%streatedRate>%s' % (namespace_, self.gds_format_float(self.treatedRate, input_name='treatedRate'), namespace_, eol_))
        if self.observationWeight is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sobservationWeight>%s</%sobservationWeight>%s' % (namespace_, self.gds_format_integer(self.observationWeight, input_name='observationWeight'), namespace_, eol_))
        if self.rateReference is not None:
            self.rateReference.export(outfile, level, namespace_, name_='rateReference', pretty_print=pretty_print)
        if self.forecastRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sforecastRate>%s</%sforecastRate>%s' % (namespace_, self.gds_format_float(self.forecastRate, input_name='forecastRate'), namespace_, eol_))
        if self.treatedForecastRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%streatedForecastRate>%s</%streatedForecastRate>%s' % (namespace_, self.gds_format_float(self.treatedForecastRate, input_name='treatedForecastRate'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'resetDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.resetDate = dval_
        elif nodeName_ == 'adjustedFixingDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.adjustedFixingDate = dval_
        elif nodeName_ == 'observedRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'observedRate')
            self.observedRate = fval_
        elif nodeName_ == 'treatedRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'treatedRate')
            self.treatedRate = fval_
        elif nodeName_ == 'observationWeight':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'observationWeight')
            self.observationWeight = ival_
        elif nodeName_ == 'rateReference':
            obj_ = RateReference.factory()
            obj_.build(child_)
            self.rateReference = obj_
            obj_.original_tagname_ = 'rateReference'
        elif nodeName_ == 'forecastRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'forecastRate')
            self.forecastRate = fval_
        elif nodeName_ == 'treatedForecastRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'treatedForecastRate')
            self.treatedForecastRate = fval_
# end class RateObservation


class RateReference(GeneratedsSuper):
    """Reference to any rate (floating, inflation) derived from the
    abstract Rate component."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, href=None):
        self.original_tagname_ = None
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RateReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RateReference.subclass:
            return RateReference.subclass(*args_, **kwargs_)
        else:
            return RateReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RateReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RateReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RateReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RateReference'):
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RateReference', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RateReference


class RateSourcePage(GeneratedsSuper):
    member_data_items_ = {
        'rateSourcePageScheme': MemberSpec_('rateSourcePageScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, rateSourcePageScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.rateSourcePageScheme = _cast(None, rateSourcePageScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RateSourcePage)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RateSourcePage.subclass:
            return RateSourcePage.subclass(*args_, **kwargs_)
        else:
            return RateSourcePage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rateSourcePageScheme(self): return self.rateSourcePageScheme
    def set_rateSourcePageScheme(self, rateSourcePageScheme): self.rateSourcePageScheme = rateSourcePageScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RateSourcePage', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RateSourcePage')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RateSourcePage', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RateSourcePage'):
        if self.rateSourcePageScheme is not None and 'rateSourcePageScheme' not in already_processed:
            already_processed.add('rateSourcePageScheme')
            outfile.write(' rateSourcePageScheme=%s' % (quote_attrib(self.rateSourcePageScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RateSourcePage', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('rateSourcePageScheme', node)
        if value is not None and 'rateSourcePageScheme' not in already_processed:
            already_processed.add('rateSourcePageScheme')
            self.rateSourcePageScheme = value
            self.validate_NonEmptyURI(self.rateSourcePageScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RateSourcePage


class Reference(GeneratedsSuper):
    """The abstract base class for all types which define intra-document
    pointers."""
    member_data_items_ = {
    }
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Reference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Reference.subclass:
            return Reference.subclass(*args_, **kwargs_)
        else:
            return Reference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Reference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Reference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Reference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Reference'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Reference', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Reference


class ReferenceAmount(GeneratedsSuper):
    """Specifies the reference amount using a scheme."""
    member_data_items_ = {
        'referenceAmountScheme': MemberSpec_('referenceAmountScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, referenceAmountScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.referenceAmountScheme = _cast(None, referenceAmountScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferenceAmount)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferenceAmount.subclass:
            return ReferenceAmount.subclass(*args_, **kwargs_)
        else:
            return ReferenceAmount(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_referenceAmountScheme(self): return self.referenceAmountScheme
    def set_referenceAmountScheme(self, referenceAmountScheme): self.referenceAmountScheme = referenceAmountScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReferenceAmount', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceAmount')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReferenceAmount', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReferenceAmount'):
        if self.referenceAmountScheme is not None and 'referenceAmountScheme' not in already_processed:
            already_processed.add('referenceAmountScheme')
            outfile.write(' referenceAmountScheme=%s' % (quote_attrib(self.referenceAmountScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ReferenceAmount', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('referenceAmountScheme', node)
        if value is not None and 'referenceAmountScheme' not in already_processed:
            already_processed.add('referenceAmountScheme')
            self.referenceAmountScheme = value
            self.validate_NonEmptyURI(self.referenceAmountScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReferenceAmount


class ReferenceBank(GeneratedsSuper):
    """A type to describe an institution (party) identified by means of a
    coding scheme and an optional name."""
    member_data_items_ = {
        'referenceBankId': MemberSpec_('referenceBankId', 'ReferenceBankId', 0),
        'referenceBankName': MemberSpec_('referenceBankName', ['String', 'xsd:string'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, referenceBankId=None, referenceBankName=None):
        self.original_tagname_ = None
        self.referenceBankId = referenceBankId
        self.referenceBankName = referenceBankName
        self.validate_String(self.referenceBankName)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferenceBank)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferenceBank.subclass:
            return ReferenceBank.subclass(*args_, **kwargs_)
        else:
            return ReferenceBank(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_referenceBankId(self): return self.referenceBankId
    def set_referenceBankId(self, referenceBankId): self.referenceBankId = referenceBankId
    def get_referenceBankName(self): return self.referenceBankName
    def set_referenceBankName(self, referenceBankName): self.referenceBankName = referenceBankName
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.referenceBankId is not None or
            self.referenceBankName is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReferenceBank', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceBank')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReferenceBank', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReferenceBank'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ReferenceBank', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.referenceBankId is not None:
            self.referenceBankId.export(outfile, level, namespace_, name_='referenceBankId', pretty_print=pretty_print)
        if self.referenceBankName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreferenceBankName>%s</%sreferenceBankName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.referenceBankName), input_name='referenceBankName')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'referenceBankId':
            obj_ = ReferenceBankId.factory()
            obj_.build(child_)
            self.referenceBankId = obj_
            obj_.original_tagname_ = 'referenceBankId'
        elif nodeName_ == 'referenceBankName':
            referenceBankName_ = child_.text
            referenceBankName_ = self.gds_validate_string(referenceBankName_, node, 'referenceBankName')
            self.referenceBankName = referenceBankName_
            # validate type String
            self.validate_String(self.referenceBankName)
# end class ReferenceBank


class ReferenceBankId(GeneratedsSuper):
    member_data_items_ = {
        'referenceBankIdScheme': MemberSpec_('referenceBankIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, referenceBankIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.referenceBankIdScheme = _cast(None, referenceBankIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferenceBankId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferenceBankId.subclass:
            return ReferenceBankId.subclass(*args_, **kwargs_)
        else:
            return ReferenceBankId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_referenceBankIdScheme(self): return self.referenceBankIdScheme
    def set_referenceBankIdScheme(self, referenceBankIdScheme): self.referenceBankIdScheme = referenceBankIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReferenceBankId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceBankId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReferenceBankId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReferenceBankId'):
        if self.referenceBankIdScheme is not None and 'referenceBankIdScheme' not in already_processed:
            already_processed.add('referenceBankIdScheme')
            outfile.write(' referenceBankIdScheme=%s' % (quote_attrib(self.referenceBankIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ReferenceBankId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('referenceBankIdScheme', node)
        if value is not None and 'referenceBankIdScheme' not in already_processed:
            already_processed.add('referenceBankIdScheme')
            self.referenceBankIdScheme = value
            self.validate_NonEmptyURI(self.referenceBankIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReferenceBankId


class Region(GeneratedsSuper):
    """A code that describes the world region of a counterparty. For
    example, NorthAmerica, Europe, Asia."""
    member_data_items_ = {
        'regionScheme': MemberSpec_('regionScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, regionScheme='http://www.fpml.org/coding-scheme/region', valueOf_=None):
        self.original_tagname_ = None
        self.regionScheme = _cast(None, regionScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Region)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Region.subclass:
            return Region.subclass(*args_, **kwargs_)
        else:
            return Region(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_regionScheme(self): return self.regionScheme
    def set_regionScheme(self, regionScheme): self.regionScheme = regionScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Region', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Region')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Region', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Region'):
        if self.regionScheme != "http://www.fpml.org/coding-scheme/region" and 'regionScheme' not in already_processed:
            already_processed.add('regionScheme')
            outfile.write(' regionScheme=%s' % (quote_attrib(self.regionScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Region', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('regionScheme', node)
        if value is not None and 'regionScheme' not in already_processed:
            already_processed.add('regionScheme')
            self.regionScheme = value
            self.validate_NonEmptyURI(self.regionScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Region


class RelatedBusinessUnit(GeneratedsSuper):
    member_data_items_ = {
        'businessUnitReference': MemberSpec_('businessUnitReference', 'BusinessUnitReference', 0),
        'role': MemberSpec_('role', 'BusinessUnitRole', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, businessUnitReference=None, role=None):
        self.original_tagname_ = None
        self.businessUnitReference = businessUnitReference
        self.role = role
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RelatedBusinessUnit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RelatedBusinessUnit.subclass:
            return RelatedBusinessUnit.subclass(*args_, **kwargs_)
        else:
            return RelatedBusinessUnit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_businessUnitReference(self): return self.businessUnitReference
    def set_businessUnitReference(self, businessUnitReference): self.businessUnitReference = businessUnitReference
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def hasContent_(self):
        if (
            self.businessUnitReference is not None or
            self.role is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RelatedBusinessUnit', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RelatedBusinessUnit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RelatedBusinessUnit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RelatedBusinessUnit'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RelatedBusinessUnit', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.businessUnitReference is not None:
            self.businessUnitReference.export(outfile, level, namespace_, name_='businessUnitReference', pretty_print=pretty_print)
        if self.role is not None:
            self.role.export(outfile, level, namespace_, name_='role', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'businessUnitReference':
            obj_ = BusinessUnitReference.factory()
            obj_.build(child_)
            self.businessUnitReference = obj_
            obj_.original_tagname_ = 'businessUnitReference'
        elif nodeName_ == 'role':
            obj_ = BusinessUnitRole.factory()
            obj_.build(child_)
            self.role = obj_
            obj_.original_tagname_ = 'role'
# end class RelatedBusinessUnit


class RelatedParty(GeneratedsSuper):
    member_data_items_ = {
        'partyReference': MemberSpec_('partyReference', 'PartyReference', 0),
        'accountReference': MemberSpec_('accountReference', 'AccountReference', 0),
        'role': MemberSpec_('role', 'PartyRole', 0),
        'type_': MemberSpec_('type_', 'PartyRoleType', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, partyReference=None, accountReference=None, role=None, type_=None):
        self.original_tagname_ = None
        self.partyReference = partyReference
        self.accountReference = accountReference
        self.role = role
        self.type_ = type_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RelatedParty)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RelatedParty.subclass:
            return RelatedParty.subclass(*args_, **kwargs_)
        else:
            return RelatedParty(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyReference(self): return self.partyReference
    def set_partyReference(self, partyReference): self.partyReference = partyReference
    def get_accountReference(self): return self.accountReference
    def set_accountReference(self, accountReference): self.accountReference = accountReference
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (
            self.partyReference is not None or
            self.accountReference is not None or
            self.role is not None or
            self.type_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RelatedParty', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RelatedParty')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RelatedParty', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RelatedParty'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RelatedParty', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.partyReference is not None:
            self.partyReference.export(outfile, level, namespace_, name_='partyReference', pretty_print=pretty_print)
        if self.accountReference is not None:
            self.accountReference.export(outfile, level, namespace_, name_='accountReference', pretty_print=pretty_print)
        if self.role is not None:
            self.role.export(outfile, level, namespace_, name_='role', pretty_print=pretty_print)
        if self.type_ is not None:
            self.type_.export(outfile, level, namespace_, name_='type', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'partyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.partyReference = obj_
            obj_.original_tagname_ = 'partyReference'
        elif nodeName_ == 'accountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.accountReference = obj_
            obj_.original_tagname_ = 'accountReference'
        elif nodeName_ == 'role':
            obj_ = PartyRole.factory()
            obj_.build(child_)
            self.role = obj_
            obj_.original_tagname_ = 'role'
        elif nodeName_ == 'type':
            obj_ = PartyRoleType.factory()
            obj_.build(child_)
            self.type_ = obj_
            obj_.original_tagname_ = 'type'
# end class RelatedParty


class RelatedPerson(GeneratedsSuper):
    member_data_items_ = {
        'personReference': MemberSpec_('personReference', 'PersonReference', 0),
        'role': MemberSpec_('role', 'PersonRole', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, personReference=None, role=None):
        self.original_tagname_ = None
        self.personReference = personReference
        self.role = role
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RelatedPerson)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RelatedPerson.subclass:
            return RelatedPerson.subclass(*args_, **kwargs_)
        else:
            return RelatedPerson(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_personReference(self): return self.personReference
    def set_personReference(self, personReference): self.personReference = personReference
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def hasContent_(self):
        if (
            self.personReference is not None or
            self.role is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RelatedPerson', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RelatedPerson')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RelatedPerson', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RelatedPerson'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RelatedPerson', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.personReference is not None:
            self.personReference.export(outfile, level, namespace_, name_='personReference', pretty_print=pretty_print)
        if self.role is not None:
            self.role.export(outfile, level, namespace_, name_='role', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'personReference':
            obj_ = PersonReference.factory()
            obj_.build(child_)
            self.personReference = obj_
            obj_.original_tagname_ = 'personReference'
        elif nodeName_ == 'role':
            obj_ = PersonRole.factory()
            obj_.build(child_)
            self.role = obj_
            obj_.original_tagname_ = 'role'
# end class RelatedPerson


class RelativeDateSequence(GeneratedsSuper):
    """A type describing a date when this date is defined in reference to
    another date through one or several date offsets."""
    member_data_items_ = {
        'dateRelativeTo': MemberSpec_('dateRelativeTo', 'DateReference', 0),
        'dateOffset': MemberSpec_('dateOffset', 'DateOffset', 1),
        'businessCentersReference': MemberSpec_('businessCentersReference', 'BusinessCentersReference', 0),
        'businessCenters': MemberSpec_('businessCenters', 'BusinessCenters', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, dateRelativeTo=None, dateOffset=None, businessCentersReference=None, businessCenters=None):
        self.original_tagname_ = None
        self.dateRelativeTo = dateRelativeTo
        if dateOffset is None:
            self.dateOffset = []
        else:
            self.dateOffset = dateOffset
        self.businessCentersReference = businessCentersReference
        self.businessCenters = businessCenters
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RelativeDateSequence)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RelativeDateSequence.subclass:
            return RelativeDateSequence.subclass(*args_, **kwargs_)
        else:
            return RelativeDateSequence(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dateRelativeTo(self): return self.dateRelativeTo
    def set_dateRelativeTo(self, dateRelativeTo): self.dateRelativeTo = dateRelativeTo
    def get_dateOffset(self): return self.dateOffset
    def set_dateOffset(self, dateOffset): self.dateOffset = dateOffset
    def add_dateOffset(self, value): self.dateOffset.append(value)
    def insert_dateOffset_at(self, index, value): self.dateOffset.insert(index, value)
    def replace_dateOffset_at(self, index, value): self.dateOffset[index] = value
    def get_businessCentersReference(self): return self.businessCentersReference
    def set_businessCentersReference(self, businessCentersReference): self.businessCentersReference = businessCentersReference
    def get_businessCenters(self): return self.businessCenters
    def set_businessCenters(self, businessCenters): self.businessCenters = businessCenters
    def hasContent_(self):
        if (
            self.dateRelativeTo is not None or
            self.dateOffset or
            self.businessCentersReference is not None or
            self.businessCenters is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RelativeDateSequence', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RelativeDateSequence')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RelativeDateSequence', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RelativeDateSequence'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RelativeDateSequence', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dateRelativeTo is not None:
            self.dateRelativeTo.export(outfile, level, namespace_, name_='dateRelativeTo', pretty_print=pretty_print)
        for dateOffset_ in self.dateOffset:
            dateOffset_.export(outfile, level, namespace_, name_='dateOffset', pretty_print=pretty_print)
        if self.businessCentersReference is not None:
            self.businessCentersReference.export(outfile, level, namespace_, name_='businessCentersReference', pretty_print=pretty_print)
        if self.businessCenters is not None:
            self.businessCenters.export(outfile, level, namespace_, name_='businessCenters', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dateRelativeTo':
            obj_ = DateReference.factory()
            obj_.build(child_)
            self.dateRelativeTo = obj_
            obj_.original_tagname_ = 'dateRelativeTo'
        elif nodeName_ == 'dateOffset':
            obj_ = DateOffset.factory()
            obj_.build(child_)
            self.dateOffset.append(obj_)
            obj_.original_tagname_ = 'dateOffset'
        elif nodeName_ == 'businessCentersReference':
            obj_ = BusinessCentersReference.factory()
            obj_.build(child_)
            self.businessCentersReference = obj_
            obj_.original_tagname_ = 'businessCentersReference'
        elif nodeName_ == 'businessCenters':
            obj_ = BusinessCenters.factory()
            obj_.build(child_)
            self.businessCenters = obj_
            obj_.original_tagname_ = 'businessCenters'
# end class RelativeDateSequence


class ReportingRegimeName(GeneratedsSuper):
    """An identifier of an reporting regime or format used for regulatory
    reporting, for example DoddFrankAct, MiFID,
    HongKongOTCDRepository, etc."""
    member_data_items_ = {
        'reportingRegimeNameScheme': MemberSpec_('reportingRegimeNameScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, reportingRegimeNameScheme='http://www.fpml.org/coding-scheme/reporting-regime', valueOf_=None):
        self.original_tagname_ = None
        self.reportingRegimeNameScheme = _cast(None, reportingRegimeNameScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReportingRegimeName)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReportingRegimeName.subclass:
            return ReportingRegimeName.subclass(*args_, **kwargs_)
        else:
            return ReportingRegimeName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_reportingRegimeNameScheme(self): return self.reportingRegimeNameScheme
    def set_reportingRegimeNameScheme(self, reportingRegimeNameScheme): self.reportingRegimeNameScheme = reportingRegimeNameScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReportingRegimeName', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReportingRegimeName')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReportingRegimeName', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReportingRegimeName'):
        if self.reportingRegimeNameScheme != "http://www.fpml.org/coding-scheme/reporting-regime" and 'reportingRegimeNameScheme' not in already_processed:
            already_processed.add('reportingRegimeNameScheme')
            outfile.write(' reportingRegimeNameScheme=%s' % (quote_attrib(self.reportingRegimeNameScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ReportingRegimeName', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('reportingRegimeNameScheme', node)
        if value is not None and 'reportingRegimeNameScheme' not in already_processed:
            already_processed.add('reportingRegimeNameScheme')
            self.reportingRegimeNameScheme = value
            self.validate_NonEmptyURI(self.reportingRegimeNameScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReportingRegimeName


class RequestedAction(GeneratedsSuper):
    member_data_items_ = {
        'requestedActionScheme': MemberSpec_('requestedActionScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, requestedActionScheme='http://www.fpml.org/coding-scheme/requested-action', valueOf_=None):
        self.original_tagname_ = None
        self.requestedActionScheme = _cast(None, requestedActionScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RequestedAction)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RequestedAction.subclass:
            return RequestedAction.subclass(*args_, **kwargs_)
        else:
            return RequestedAction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_requestedActionScheme(self): return self.requestedActionScheme
    def set_requestedActionScheme(self, requestedActionScheme): self.requestedActionScheme = requestedActionScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RequestedAction', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RequestedAction')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RequestedAction', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RequestedAction'):
        if self.requestedActionScheme != "http://www.fpml.org/coding-scheme/requested-action" and 'requestedActionScheme' not in already_processed:
            already_processed.add('requestedActionScheme')
            outfile.write(' requestedActionScheme=%s' % (quote_attrib(self.requestedActionScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RequestedAction', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('requestedActionScheme', node)
        if value is not None and 'requestedActionScheme' not in already_processed:
            already_processed.add('requestedActionScheme')
            self.requestedActionScheme = value
            self.validate_NonEmptyURI(self.requestedActionScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RequestedAction


class RequiredIdentifierDate(GeneratedsSuper):
    """A date with a required identifier which can be referenced elsewhere."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'valueOf_': MemberSpec_('valueOf_', 'xsd:date', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RequiredIdentifierDate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RequiredIdentifierDate.subclass:
            return RequiredIdentifierDate.subclass(*args_, **kwargs_)
        else:
            return RequiredIdentifierDate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RequiredIdentifierDate', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RequiredIdentifierDate')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RequiredIdentifierDate', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RequiredIdentifierDate'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RequiredIdentifierDate', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RequiredIdentifierDate


class ResetFrequency(Frequency):
    """A type defining the reset frequency. In the case of a weekly reset,
    also specifies the day of the week that the reset occurs. If the
    reset frequency is greater than the calculation period frequency
    the this implies that more or more reset dates is established
    for each calculation period and some form of rate averaginhg is
    applicable. The specific averaging method of calculation is
    specified in FloatingRateCalculation. In case the reset
    frequency is of value T (term), the period is defined by the
    swap\swapStream\calculationPerioDates\effectiveDate and the
    swap\swapStream\calculationPerioDates\terminationDate."""
    member_data_items_ = {
        'weeklyRollConvention': MemberSpec_('weeklyRollConvention', ['WeeklyRollConventionEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = Frequency
    def __init__(self, id=None, periodMultiplier=None, period=None, weeklyRollConvention=None):
        self.original_tagname_ = None
        super(ResetFrequency, self).__init__(id, periodMultiplier, period, )
        self.weeklyRollConvention = weeklyRollConvention
        self.validate_WeeklyRollConventionEnum(self.weeklyRollConvention)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResetFrequency)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResetFrequency.subclass:
            return ResetFrequency.subclass(*args_, **kwargs_)
        else:
            return ResetFrequency(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_weeklyRollConvention(self): return self.weeklyRollConvention
    def set_weeklyRollConvention(self, weeklyRollConvention): self.weeklyRollConvention = weeklyRollConvention
    def validate_WeeklyRollConventionEnum(self, value):
        # Validate type WeeklyRollConventionEnum, a restriction on Token.
        pass
    def hasContent_(self):
        if (
            self.weeklyRollConvention is not None or
            super(ResetFrequency, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ResetFrequency', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResetFrequency')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ResetFrequency', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ResetFrequency'):
        super(ResetFrequency, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ResetFrequency')
    def exportChildren(self, outfile, level, namespace_='', name_='ResetFrequency', fromsubclass_=False, pretty_print=True):
        super(ResetFrequency, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.weeklyRollConvention is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sweeklyRollConvention>%s</%sweeklyRollConvention>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.weeklyRollConvention), input_name='weeklyRollConvention')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ResetFrequency, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'weeklyRollConvention':
            weeklyRollConvention_ = child_.text
            weeklyRollConvention_ = re_.sub(String_cleanup_pat_, " ", weeklyRollConvention_).strip()
            weeklyRollConvention_ = self.gds_validate_string(weeklyRollConvention_, node, 'weeklyRollConvention')
            self.weeklyRollConvention = weeklyRollConvention_
            # validate type WeeklyRollConventionEnum
            self.validate_WeeklyRollConventionEnum(self.weeklyRollConvention)
        super(ResetFrequency, self).buildChildren(child_, node, nodeName_, True)
# end class ResetFrequency


class Resource(GeneratedsSuper):
    """Describes the resource that contains the media representation of a
    business event (i.e used for stating the Publicly Available
    Information). For example, can describe a file or a URL that
    represents the event. This type is an extended version of a type
    defined by RIXML (www.rixml.org)."""
    member_data_items_ = {
        'resourceId': MemberSpec_('resourceId', 'ResourceId', 0),
        'resourceType': MemberSpec_('resourceType', 'ResourceType', 0),
        'language': MemberSpec_('language', 'Language', 0),
        'sizeInBytes': MemberSpec_('sizeInBytes', 'xsd:decimal', 0),
        'length': MemberSpec_('length', 'ResourceLength', 0),
        'mimeType': MemberSpec_('mimeType', 'MimeType', 0),
        'name': MemberSpec_('name', ['NormalizedString', 'xsd:normalizedString'], 0),
        'comments': MemberSpec_('comments', ['String', 'xsd:string'], 0),
        'string': MemberSpec_('string', ['String', 'xsd:string'], 0),
        'hexadecimalBinary': MemberSpec_('hexadecimalBinary', 'xsd:hexBinary', 0),
        'base64Binary': MemberSpec_('base64Binary', 'xsd:base64Binary', 0),
        'url': MemberSpec_('url', ['NonEmptyURI', 'xsd:anyURI'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, resourceId=None, resourceType=None, language=None, sizeInBytes=None, length=None, mimeType=None, name=None, comments=None, string=None, hexadecimalBinary=None, base64Binary=None, url=None):
        self.original_tagname_ = None
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.language = language
        self.sizeInBytes = sizeInBytes
        self.length = length
        self.mimeType = mimeType
        self.name = name
        self.validate_NormalizedString(self.name)
        self.comments = comments
        self.validate_String(self.comments)
        self.string = string
        self.validate_String(self.string)
        self.hexadecimalBinary = hexadecimalBinary
        self.base64Binary = base64Binary
        self.url = url
        self.validate_NonEmptyURI(self.url)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Resource)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Resource.subclass:
            return Resource.subclass(*args_, **kwargs_)
        else:
            return Resource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_resourceId(self): return self.resourceId
    def set_resourceId(self, resourceId): self.resourceId = resourceId
    def get_resourceType(self): return self.resourceType
    def set_resourceType(self, resourceType): self.resourceType = resourceType
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def get_sizeInBytes(self): return self.sizeInBytes
    def set_sizeInBytes(self, sizeInBytes): self.sizeInBytes = sizeInBytes
    def get_length(self): return self.length
    def set_length(self, length): self.length = length
    def get_mimeType(self): return self.mimeType
    def set_mimeType(self, mimeType): self.mimeType = mimeType
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_comments(self): return self.comments
    def set_comments(self, comments): self.comments = comments
    def get_string(self): return self.string
    def set_string(self, string): self.string = string
    def get_hexadecimalBinary(self): return self.hexadecimalBinary
    def set_hexadecimalBinary(self, hexadecimalBinary): self.hexadecimalBinary = hexadecimalBinary
    def get_base64Binary(self): return self.base64Binary
    def set_base64Binary(self, base64Binary): self.base64Binary = base64Binary
    def get_url(self): return self.url
    def set_url(self, url): self.url = url
    def validate_NormalizedString(self, value):
        # Validate type NormalizedString, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NormalizedString' % {"value" : value} )
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            self.resourceId is not None or
            self.resourceType is not None or
            self.language is not None or
            self.sizeInBytes is not None or
            self.length is not None or
            self.mimeType is not None or
            self.name is not None or
            self.comments is not None or
            self.string is not None or
            self.hexadecimalBinary is not None or
            self.base64Binary is not None or
            self.url is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Resource', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Resource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Resource', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Resource'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Resource', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.resourceId is not None:
            self.resourceId.export(outfile, level, namespace_, name_='resourceId', pretty_print=pretty_print)
        if self.resourceType is not None:
            self.resourceType.export(outfile, level, namespace_, name_='resourceType', pretty_print=pretty_print)
        if self.language is not None:
            self.language.export(outfile, level, namespace_, name_='language', pretty_print=pretty_print)
        if self.sizeInBytes is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssizeInBytes>%s</%ssizeInBytes>%s' % (namespace_, self.gds_format_float(self.sizeInBytes, input_name='sizeInBytes'), namespace_, eol_))
        if self.length is not None:
            self.length.export(outfile, level, namespace_, name_='length', pretty_print=pretty_print)
        if self.mimeType is not None:
            self.mimeType.export(outfile, level, namespace_, name_='mimeType', pretty_print=pretty_print)
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespace_, eol_))
        if self.comments is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomments>%s</%scomments>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.comments), input_name='comments')), namespace_, eol_))
        if self.string is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstring>%s</%sstring>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.string), input_name='string')), namespace_, eol_))
        if self.hexadecimalBinary is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shexadecimalBinary>%s</%shexadecimalBinary>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.hexadecimalBinary), input_name='hexadecimalBinary')), namespace_, eol_))
        if self.base64Binary is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbase64Binary>%s</%sbase64Binary>%s' % (namespace_, self.gds_format_base64(self.base64Binary, input_name='base64Binary'), namespace_, eol_))
        if self.url is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%surl>%s</%surl>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.url), input_name='url')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'resourceId':
            obj_ = ResourceId.factory()
            obj_.build(child_)
            self.resourceId = obj_
            obj_.original_tagname_ = 'resourceId'
        elif nodeName_ == 'resourceType':
            obj_ = ResourceType.factory()
            obj_.build(child_)
            self.resourceType = obj_
            obj_.original_tagname_ = 'resourceType'
        elif nodeName_ == 'language':
            obj_ = Language.factory()
            obj_.build(child_)
            self.language = obj_
            obj_.original_tagname_ = 'language'
        elif nodeName_ == 'sizeInBytes':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'sizeInBytes')
            self.sizeInBytes = fval_
        elif nodeName_ == 'length':
            obj_ = ResourceLength.factory()
            obj_.build(child_)
            self.length = obj_
            obj_.original_tagname_ = 'length'
        elif nodeName_ == 'mimeType':
            obj_ = MimeType.factory()
            obj_.build(child_)
            self.mimeType = obj_
            obj_.original_tagname_ = 'mimeType'
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
            # validate type NormalizedString
            self.validate_NormalizedString(self.name)
        elif nodeName_ == 'comments':
            comments_ = child_.text
            comments_ = self.gds_validate_string(comments_, node, 'comments')
            self.comments = comments_
            # validate type String
            self.validate_String(self.comments)
        elif nodeName_ == 'string':
            string_ = child_.text
            string_ = self.gds_validate_string(string_, node, 'string')
            self.string = string_
            # validate type String
            self.validate_String(self.string)
        elif nodeName_ == 'hexadecimalBinary':
            hexadecimalBinary_ = child_.text
            hexadecimalBinary_ = self.gds_validate_string(hexadecimalBinary_, node, 'hexadecimalBinary')
            self.hexadecimalBinary = hexadecimalBinary_
        elif nodeName_ == 'base64Binary':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'base64Binary')
            else:
                bval_ = None
            self.base64Binary = bval_
        elif nodeName_ == 'url':
            url_ = child_.text
            url_ = self.gds_validate_string(url_, node, 'url')
            self.url = url_
            # validate type NonEmptyURI
            self.validate_NonEmptyURI(self.url)
# end class Resource


class ResourceId(GeneratedsSuper):
    """The data type used for resource identifiers."""
    member_data_items_ = {
        'resourceIdScheme': MemberSpec_('resourceIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, resourceIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.resourceIdScheme = _cast(None, resourceIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResourceId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResourceId.subclass:
            return ResourceId.subclass(*args_, **kwargs_)
        else:
            return ResourceId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_resourceIdScheme(self): return self.resourceIdScheme
    def set_resourceIdScheme(self, resourceIdScheme): self.resourceIdScheme = resourceIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ResourceId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResourceId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ResourceId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ResourceId'):
        if self.resourceIdScheme is not None and 'resourceIdScheme' not in already_processed:
            already_processed.add('resourceIdScheme')
            outfile.write(' resourceIdScheme=%s' % (quote_attrib(self.resourceIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ResourceId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('resourceIdScheme', node)
        if value is not None and 'resourceIdScheme' not in already_processed:
            already_processed.add('resourceIdScheme')
            self.resourceIdScheme = value
            self.validate_NonEmptyURI(self.resourceIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ResourceId


class ResourceLength(GeneratedsSuper):
    """The type that indicates the length of the resource."""
    member_data_items_ = {
        'lengthUnit': MemberSpec_('lengthUnit', ['LengthUnitEnum', 'Token', 'xsd:token'], 0),
        'lengthValue': MemberSpec_('lengthValue', 'xsd:decimal', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, lengthUnit=None, lengthValue=None):
        self.original_tagname_ = None
        self.lengthUnit = lengthUnit
        self.validate_LengthUnitEnum(self.lengthUnit)
        self.lengthValue = lengthValue
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResourceLength)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResourceLength.subclass:
            return ResourceLength.subclass(*args_, **kwargs_)
        else:
            return ResourceLength(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lengthUnit(self): return self.lengthUnit
    def set_lengthUnit(self, lengthUnit): self.lengthUnit = lengthUnit
    def get_lengthValue(self): return self.lengthValue
    def set_lengthValue(self, lengthValue): self.lengthValue = lengthValue
    def validate_LengthUnitEnum(self, value):
        # Validate type LengthUnitEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Pages', 'TimeUnit']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on LengthUnitEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on LengthUnitEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.lengthUnit is not None or
            self.lengthValue is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ResourceLength', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResourceLength')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ResourceLength', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ResourceLength'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ResourceLength', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.lengthUnit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slengthUnit>%s</%slengthUnit>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.lengthUnit), input_name='lengthUnit')), namespace_, eol_))
        if self.lengthValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slengthValue>%s</%slengthValue>%s' % (namespace_, self.gds_format_float(self.lengthValue, input_name='lengthValue'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'lengthUnit':
            lengthUnit_ = child_.text
            lengthUnit_ = re_.sub(String_cleanup_pat_, " ", lengthUnit_).strip()
            lengthUnit_ = self.gds_validate_string(lengthUnit_, node, 'lengthUnit')
            self.lengthUnit = lengthUnit_
            # validate type LengthUnitEnum
            self.validate_LengthUnitEnum(self.lengthUnit)
        elif nodeName_ == 'lengthValue':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'lengthValue')
            self.lengthValue = fval_
# end class ResourceLength


class ResourceType(GeneratedsSuper):
    """The data type used for describing the type or purpose of a resource,
    e.g. "Confirmation"."""
    member_data_items_ = {
        'resourceTypeScheme': MemberSpec_('resourceTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, resourceTypeScheme='http://www.fpml.org/coding-scheme/resource-type', valueOf_=None):
        self.original_tagname_ = None
        self.resourceTypeScheme = _cast(None, resourceTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResourceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResourceType.subclass:
            return ResourceType.subclass(*args_, **kwargs_)
        else:
            return ResourceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_resourceTypeScheme(self): return self.resourceTypeScheme
    def set_resourceTypeScheme(self, resourceTypeScheme): self.resourceTypeScheme = resourceTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ResourceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResourceType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ResourceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ResourceType'):
        if self.resourceTypeScheme != "http://www.fpml.org/coding-scheme/resource-type" and 'resourceTypeScheme' not in already_processed:
            already_processed.add('resourceTypeScheme')
            outfile.write(' resourceTypeScheme=%s' % (quote_attrib(self.resourceTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ResourceType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('resourceTypeScheme', node)
        if value is not None and 'resourceTypeScheme' not in already_processed:
            already_processed.add('resourceTypeScheme')
            self.resourceTypeScheme = value
            self.validate_NonEmptyURI(self.resourceTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ResourceType


class ReturnSwapNotionalAmountReference(Reference):
    """A reference to the return swap notional amount."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(ReturnSwapNotionalAmountReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReturnSwapNotionalAmountReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReturnSwapNotionalAmountReference.subclass:
            return ReturnSwapNotionalAmountReference.subclass(*args_, **kwargs_)
        else:
            return ReturnSwapNotionalAmountReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(ReturnSwapNotionalAmountReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReturnSwapNotionalAmountReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReturnSwapNotionalAmountReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReturnSwapNotionalAmountReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReturnSwapNotionalAmountReference'):
        super(ReturnSwapNotionalAmountReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ReturnSwapNotionalAmountReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ReturnSwapNotionalAmountReference', fromsubclass_=False, pretty_print=True):
        super(ReturnSwapNotionalAmountReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(ReturnSwapNotionalAmountReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ReturnSwapNotionalAmountReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ReturnSwapNotionalAmountReference


class Rounding(GeneratedsSuper):
    """A type defining a rounding direction and precision to be used in the
    rounding of a rate."""
    member_data_items_ = {
        'roundingDirection': MemberSpec_('roundingDirection', ['RoundingDirectionEnum', 'Token', 'xsd:token'], 0),
        'precision': MemberSpec_('precision', 'xsd:nonNegativeInteger', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, roundingDirection=None, precision=None):
        self.original_tagname_ = None
        self.roundingDirection = roundingDirection
        self.validate_RoundingDirectionEnum(self.roundingDirection)
        self.precision = precision
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Rounding)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Rounding.subclass:
            return Rounding.subclass(*args_, **kwargs_)
        else:
            return Rounding(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_roundingDirection(self): return self.roundingDirection
    def set_roundingDirection(self, roundingDirection): self.roundingDirection = roundingDirection
    def get_precision(self): return self.precision
    def set_precision(self, precision): self.precision = precision
    def validate_RoundingDirectionEnum(self, value):
        # Validate type RoundingDirectionEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Up', 'Down', 'Nearest']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RoundingDirectionEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on RoundingDirectionEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.roundingDirection is not None or
            self.precision is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Rounding', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Rounding')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Rounding', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Rounding'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Rounding', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.roundingDirection is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sroundingDirection>%s</%sroundingDirection>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.roundingDirection), input_name='roundingDirection')), namespace_, eol_))
        if self.precision is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprecision>%s</%sprecision>%s' % (namespace_, self.gds_format_integer(self.precision, input_name='precision'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'roundingDirection':
            roundingDirection_ = child_.text
            roundingDirection_ = re_.sub(String_cleanup_pat_, " ", roundingDirection_).strip()
            roundingDirection_ = self.gds_validate_string(roundingDirection_, node, 'roundingDirection')
            self.roundingDirection = roundingDirection_
            # validate type RoundingDirectionEnum
            self.validate_RoundingDirectionEnum(self.roundingDirection)
        elif nodeName_ == 'precision':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'precision')
            self.precision = ival_
# end class Rounding


class Routing(GeneratedsSuper):
    """A type that provides three alternative ways of identifying a party
    involved in the routing of a payment. The identification may use
    payment system identifiers only; actual name, address and other
    reference information; or a combination of both."""
    member_data_items_ = {
        'routingIds': MemberSpec_('routingIds', 'RoutingIds', 0),
        'routingExplicitDetails': MemberSpec_('routingExplicitDetails', 'RoutingExplicitDetails', 0),
        'routingIdsAndExplicitDetails': MemberSpec_('routingIdsAndExplicitDetails', 'RoutingIdsAndExplicitDetails', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, routingIds=None, routingExplicitDetails=None, routingIdsAndExplicitDetails=None):
        self.original_tagname_ = None
        self.routingIds = routingIds
        self.routingExplicitDetails = routingExplicitDetails
        self.routingIdsAndExplicitDetails = routingIdsAndExplicitDetails
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Routing)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Routing.subclass:
            return Routing.subclass(*args_, **kwargs_)
        else:
            return Routing(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_routingIds(self): return self.routingIds
    def set_routingIds(self, routingIds): self.routingIds = routingIds
    def get_routingExplicitDetails(self): return self.routingExplicitDetails
    def set_routingExplicitDetails(self, routingExplicitDetails): self.routingExplicitDetails = routingExplicitDetails
    def get_routingIdsAndExplicitDetails(self): return self.routingIdsAndExplicitDetails
    def set_routingIdsAndExplicitDetails(self, routingIdsAndExplicitDetails): self.routingIdsAndExplicitDetails = routingIdsAndExplicitDetails
    def hasContent_(self):
        if (
            self.routingIds is not None or
            self.routingExplicitDetails is not None or
            self.routingIdsAndExplicitDetails is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Routing', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Routing')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Routing', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Routing'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Routing', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.routingIds is not None:
            self.routingIds.export(outfile, level, namespace_, name_='routingIds', pretty_print=pretty_print)
        if self.routingExplicitDetails is not None:
            self.routingExplicitDetails.export(outfile, level, namespace_, name_='routingExplicitDetails', pretty_print=pretty_print)
        if self.routingIdsAndExplicitDetails is not None:
            self.routingIdsAndExplicitDetails.export(outfile, level, namespace_, name_='routingIdsAndExplicitDetails', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'routingIds':
            obj_ = RoutingIds.factory()
            obj_.build(child_)
            self.routingIds = obj_
            obj_.original_tagname_ = 'routingIds'
        elif nodeName_ == 'routingExplicitDetails':
            obj_ = RoutingExplicitDetails.factory()
            obj_.build(child_)
            self.routingExplicitDetails = obj_
            obj_.original_tagname_ = 'routingExplicitDetails'
        elif nodeName_ == 'routingIdsAndExplicitDetails':
            obj_ = RoutingIdsAndExplicitDetails.factory()
            obj_.build(child_)
            self.routingIdsAndExplicitDetails = obj_
            obj_.original_tagname_ = 'routingIdsAndExplicitDetails'
# end class Routing


class RoutingExplicitDetails(GeneratedsSuper):
    """A type that models name, address and supplementary textual
    information for the purposes of identifying a party involved in
    the routing of a payment."""
    member_data_items_ = {
        'routingName': MemberSpec_('routingName', ['String', 'xsd:string'], 0),
        'routingAddress': MemberSpec_('routingAddress', 'Address', 0),
        'routingAccountNumber': MemberSpec_('routingAccountNumber', ['String', 'xsd:string'], 0),
        'routingReferenceText': MemberSpec_('routingReferenceText', ['String', 'xsd:string'], 1),
    }
    subclass = None
    superclass = None
    def __init__(self, routingName=None, routingAddress=None, routingAccountNumber=None, routingReferenceText=None):
        self.original_tagname_ = None
        self.routingName = routingName
        self.validate_String(self.routingName)
        self.routingAddress = routingAddress
        self.routingAccountNumber = routingAccountNumber
        self.validate_String(self.routingAccountNumber)
        if routingReferenceText is None:
            self.routingReferenceText = []
        else:
            self.routingReferenceText = routingReferenceText
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RoutingExplicitDetails)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RoutingExplicitDetails.subclass:
            return RoutingExplicitDetails.subclass(*args_, **kwargs_)
        else:
            return RoutingExplicitDetails(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_routingName(self): return self.routingName
    def set_routingName(self, routingName): self.routingName = routingName
    def get_routingAddress(self): return self.routingAddress
    def set_routingAddress(self, routingAddress): self.routingAddress = routingAddress
    def get_routingAccountNumber(self): return self.routingAccountNumber
    def set_routingAccountNumber(self, routingAccountNumber): self.routingAccountNumber = routingAccountNumber
    def get_routingReferenceText(self): return self.routingReferenceText
    def set_routingReferenceText(self, routingReferenceText): self.routingReferenceText = routingReferenceText
    def add_routingReferenceText(self, value): self.routingReferenceText.append(value)
    def insert_routingReferenceText_at(self, index, value): self.routingReferenceText.insert(index, value)
    def replace_routingReferenceText_at(self, index, value): self.routingReferenceText[index] = value
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.routingName is not None or
            self.routingAddress is not None or
            self.routingAccountNumber is not None or
            self.routingReferenceText
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RoutingExplicitDetails', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RoutingExplicitDetails')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RoutingExplicitDetails', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RoutingExplicitDetails'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RoutingExplicitDetails', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.routingName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sroutingName>%s</%sroutingName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.routingName), input_name='routingName')), namespace_, eol_))
        if self.routingAddress is not None:
            self.routingAddress.export(outfile, level, namespace_, name_='routingAddress', pretty_print=pretty_print)
        if self.routingAccountNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sroutingAccountNumber>%s</%sroutingAccountNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.routingAccountNumber), input_name='routingAccountNumber')), namespace_, eol_))
        for routingReferenceText_ in self.routingReferenceText:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sroutingReferenceText>%s</%sroutingReferenceText>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(routingReferenceText_), input_name='routingReferenceText')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'routingName':
            routingName_ = child_.text
            routingName_ = self.gds_validate_string(routingName_, node, 'routingName')
            self.routingName = routingName_
            # validate type String
            self.validate_String(self.routingName)
        elif nodeName_ == 'routingAddress':
            obj_ = Address.factory()
            obj_.build(child_)
            self.routingAddress = obj_
            obj_.original_tagname_ = 'routingAddress'
        elif nodeName_ == 'routingAccountNumber':
            routingAccountNumber_ = child_.text
            routingAccountNumber_ = self.gds_validate_string(routingAccountNumber_, node, 'routingAccountNumber')
            self.routingAccountNumber = routingAccountNumber_
            # validate type String
            self.validate_String(self.routingAccountNumber)
        elif nodeName_ == 'routingReferenceText':
            routingReferenceText_ = child_.text
            routingReferenceText_ = self.gds_validate_string(routingReferenceText_, node, 'routingReferenceText')
            self.routingReferenceText.append(routingReferenceText_)
            # validate type String
            self.validate_String(self.routingReferenceText[-1])
# end class RoutingExplicitDetails


class RoutingId(GeneratedsSuper):
    member_data_items_ = {
        'routingIdCodeScheme': MemberSpec_('routingIdCodeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, routingIdCodeScheme='http://www.fpml.org/coding-scheme/external/iso9362', valueOf_=None):
        self.original_tagname_ = None
        self.routingIdCodeScheme = _cast(None, routingIdCodeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RoutingId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RoutingId.subclass:
            return RoutingId.subclass(*args_, **kwargs_)
        else:
            return RoutingId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_routingIdCodeScheme(self): return self.routingIdCodeScheme
    def set_routingIdCodeScheme(self, routingIdCodeScheme): self.routingIdCodeScheme = routingIdCodeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RoutingId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RoutingId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RoutingId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RoutingId'):
        if self.routingIdCodeScheme != "http://www.fpml.org/coding-scheme/external/iso9362" and 'routingIdCodeScheme' not in already_processed:
            already_processed.add('routingIdCodeScheme')
            outfile.write(' routingIdCodeScheme=%s' % (quote_attrib(self.routingIdCodeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RoutingId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('routingIdCodeScheme', node)
        if value is not None and 'routingIdCodeScheme' not in already_processed:
            already_processed.add('routingIdCodeScheme')
            self.routingIdCodeScheme = value
            self.validate_NonEmptyURI(self.routingIdCodeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RoutingId


class RoutingIds(GeneratedsSuper):
    """A type that provides for identifying a party involved in the routing
    of a payment by means of one or more standard identification
    codes. For example, both a SWIFT BIC code and a national bank
    identifier may be required."""
    member_data_items_ = {
        'routingId': MemberSpec_('routingId', 'RoutingId', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, routingId=None):
        self.original_tagname_ = None
        if routingId is None:
            self.routingId = []
        else:
            self.routingId = routingId
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RoutingIds)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RoutingIds.subclass:
            return RoutingIds.subclass(*args_, **kwargs_)
        else:
            return RoutingIds(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_routingId(self): return self.routingId
    def set_routingId(self, routingId): self.routingId = routingId
    def add_routingId(self, value): self.routingId.append(value)
    def insert_routingId_at(self, index, value): self.routingId.insert(index, value)
    def replace_routingId_at(self, index, value): self.routingId[index] = value
    def hasContent_(self):
        if (
            self.routingId
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RoutingIds', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RoutingIds')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RoutingIds', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RoutingIds'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RoutingIds', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for routingId_ in self.routingId:
            routingId_.export(outfile, level, namespace_, name_='routingId', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'routingId':
            obj_ = RoutingId.factory()
            obj_.build(child_)
            self.routingId.append(obj_)
            obj_.original_tagname_ = 'routingId'
# end class RoutingIds


class RoutingIdsAndExplicitDetails(GeneratedsSuper):
    """A type that provides a combination of payment system identification
    codes with physical postal address details, for the purposes of
    identifying a party involved in the routing of a payment."""
    member_data_items_ = {
        'routingIds': MemberSpec_('routingIds', 'RoutingIds', 1),
        'routingName': MemberSpec_('routingName', ['String', 'xsd:string'], 0),
        'routingAddress': MemberSpec_('routingAddress', 'Address', 0),
        'routingAccountNumber': MemberSpec_('routingAccountNumber', ['String', 'xsd:string'], 0),
        'routingReferenceText': MemberSpec_('routingReferenceText', ['String', 'xsd:string'], 1),
    }
    subclass = None
    superclass = None
    def __init__(self, routingIds=None, routingName=None, routingAddress=None, routingAccountNumber=None, routingReferenceText=None):
        self.original_tagname_ = None
        if routingIds is None:
            self.routingIds = []
        else:
            self.routingIds = routingIds
        self.routingName = routingName
        self.validate_String(self.routingName)
        self.routingAddress = routingAddress
        self.routingAccountNumber = routingAccountNumber
        self.validate_String(self.routingAccountNumber)
        if routingReferenceText is None:
            self.routingReferenceText = []
        else:
            self.routingReferenceText = routingReferenceText
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RoutingIdsAndExplicitDetails)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RoutingIdsAndExplicitDetails.subclass:
            return RoutingIdsAndExplicitDetails.subclass(*args_, **kwargs_)
        else:
            return RoutingIdsAndExplicitDetails(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_routingIds(self): return self.routingIds
    def set_routingIds(self, routingIds): self.routingIds = routingIds
    def add_routingIds(self, value): self.routingIds.append(value)
    def insert_routingIds_at(self, index, value): self.routingIds.insert(index, value)
    def replace_routingIds_at(self, index, value): self.routingIds[index] = value
    def get_routingName(self): return self.routingName
    def set_routingName(self, routingName): self.routingName = routingName
    def get_routingAddress(self): return self.routingAddress
    def set_routingAddress(self, routingAddress): self.routingAddress = routingAddress
    def get_routingAccountNumber(self): return self.routingAccountNumber
    def set_routingAccountNumber(self, routingAccountNumber): self.routingAccountNumber = routingAccountNumber
    def get_routingReferenceText(self): return self.routingReferenceText
    def set_routingReferenceText(self, routingReferenceText): self.routingReferenceText = routingReferenceText
    def add_routingReferenceText(self, value): self.routingReferenceText.append(value)
    def insert_routingReferenceText_at(self, index, value): self.routingReferenceText.insert(index, value)
    def replace_routingReferenceText_at(self, index, value): self.routingReferenceText[index] = value
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.routingIds or
            self.routingName is not None or
            self.routingAddress is not None or
            self.routingAccountNumber is not None or
            self.routingReferenceText
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RoutingIdsAndExplicitDetails', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RoutingIdsAndExplicitDetails')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RoutingIdsAndExplicitDetails', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RoutingIdsAndExplicitDetails'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RoutingIdsAndExplicitDetails', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for routingIds_ in self.routingIds:
            routingIds_.export(outfile, level, namespace_, name_='routingIds', pretty_print=pretty_print)
        if self.routingName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sroutingName>%s</%sroutingName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.routingName), input_name='routingName')), namespace_, eol_))
        if self.routingAddress is not None:
            self.routingAddress.export(outfile, level, namespace_, name_='routingAddress', pretty_print=pretty_print)
        if self.routingAccountNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sroutingAccountNumber>%s</%sroutingAccountNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.routingAccountNumber), input_name='routingAccountNumber')), namespace_, eol_))
        for routingReferenceText_ in self.routingReferenceText:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sroutingReferenceText>%s</%sroutingReferenceText>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(routingReferenceText_), input_name='routingReferenceText')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'routingIds':
            obj_ = RoutingIds.factory()
            obj_.build(child_)
            self.routingIds.append(obj_)
            obj_.original_tagname_ = 'routingIds'
        elif nodeName_ == 'routingName':
            routingName_ = child_.text
            routingName_ = self.gds_validate_string(routingName_, node, 'routingName')
            self.routingName = routingName_
            # validate type String
            self.validate_String(self.routingName)
        elif nodeName_ == 'routingAddress':
            obj_ = Address.factory()
            obj_.build(child_)
            self.routingAddress = obj_
            obj_.original_tagname_ = 'routingAddress'
        elif nodeName_ == 'routingAccountNumber':
            routingAccountNumber_ = child_.text
            routingAccountNumber_ = self.gds_validate_string(routingAccountNumber_, node, 'routingAccountNumber')
            self.routingAccountNumber = routingAccountNumber_
            # validate type String
            self.validate_String(self.routingAccountNumber)
        elif nodeName_ == 'routingReferenceText':
            routingReferenceText_ = child_.text
            routingReferenceText_ = self.gds_validate_string(routingReferenceText_, node, 'routingReferenceText')
            self.routingReferenceText.append(routingReferenceText_)
            # validate type String
            self.validate_String(self.routingReferenceText[-1])
# end class RoutingIdsAndExplicitDetails


class Schedule(GeneratedsSuper):
    """A type defining a schedule of rates or amounts in terms of an
    initial value and then a series of step date and value pairs. On
    each step date the rate or amount changes to the new step value.
    The series of step date and value pairs are optional. If not
    specified, this implies that the initial value remains unchanged
    over time."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'initialValue': MemberSpec_('initialValue', 'xsd:decimal', 0),
        'step': MemberSpec_('step', 'Step', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, initialValue=None, step=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.initialValue = initialValue
        if step is None:
            self.step = []
        else:
            self.step = step
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Schedule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Schedule.subclass:
            return Schedule.subclass(*args_, **kwargs_)
        else:
            return Schedule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_initialValue(self): return self.initialValue
    def set_initialValue(self, initialValue): self.initialValue = initialValue
    def get_step(self): return self.step
    def set_step(self, step): self.step = step
    def add_step(self, value): self.step.append(value)
    def insert_step_at(self, index, value): self.step.insert(index, value)
    def replace_step_at(self, index, value): self.step[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.initialValue is not None or
            self.step
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Schedule', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Schedule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Schedule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Schedule'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Schedule', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.initialValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinitialValue>%s</%sinitialValue>%s' % (namespace_, self.gds_format_float(self.initialValue, input_name='initialValue'), namespace_, eol_))
        for step_ in self.step:
            step_.export(outfile, level, namespace_, name_='step', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'initialValue':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'initialValue')
            self.initialValue = fval_
        elif nodeName_ == 'step':
            obj_ = Step.factory()
            obj_.build(child_)
            self.step.append(obj_)
            obj_.original_tagname_ = 'step'
# end class Schedule


class ScheduleReference(Reference):
    """Reference to a schedule of rates or amounts."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(ScheduleReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ScheduleReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ScheduleReference.subclass:
            return ScheduleReference.subclass(*args_, **kwargs_)
        else:
            return ScheduleReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(ScheduleReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ScheduleReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ScheduleReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ScheduleReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ScheduleReference'):
        super(ScheduleReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ScheduleReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ScheduleReference', fromsubclass_=False, pretty_print=True):
        super(ScheduleReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(ScheduleReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ScheduleReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ScheduleReference


class SettlementInformation(GeneratedsSuper):
    """A type that represents the choice of methods for settling a
    potential currency payment resulting from a trade: by means of a
    standard settlement instruction, by netting it out with other
    payments, or with an explicit settlement instruction."""
    member_data_items_ = {
        'standardSettlementStyle': MemberSpec_('standardSettlementStyle', ['StandardSettlementStyleEnum', 'Token', 'xsd:token'], 0),
        'settlementInstruction': MemberSpec_('settlementInstruction', 'SettlementInstruction', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, standardSettlementStyle=None, settlementInstruction=None):
        self.original_tagname_ = None
        self.standardSettlementStyle = standardSettlementStyle
        self.validate_StandardSettlementStyleEnum(self.standardSettlementStyle)
        self.settlementInstruction = settlementInstruction
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SettlementInformation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SettlementInformation.subclass:
            return SettlementInformation.subclass(*args_, **kwargs_)
        else:
            return SettlementInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_standardSettlementStyle(self): return self.standardSettlementStyle
    def set_standardSettlementStyle(self, standardSettlementStyle): self.standardSettlementStyle = standardSettlementStyle
    def get_settlementInstruction(self): return self.settlementInstruction
    def set_settlementInstruction(self, settlementInstruction): self.settlementInstruction = settlementInstruction
    def validate_StandardSettlementStyleEnum(self, value):
        # Validate type StandardSettlementStyleEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Standard', 'Net', 'StandardAndNet']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on StandardSettlementStyleEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on StandardSettlementStyleEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.standardSettlementStyle is not None or
            self.settlementInstruction is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SettlementInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SettlementInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SettlementInformation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SettlementInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SettlementInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.standardSettlementStyle is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstandardSettlementStyle>%s</%sstandardSettlementStyle>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.standardSettlementStyle), input_name='standardSettlementStyle')), namespace_, eol_))
        if self.settlementInstruction is not None:
            self.settlementInstruction.export(outfile, level, namespace_, name_='settlementInstruction', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'standardSettlementStyle':
            standardSettlementStyle_ = child_.text
            standardSettlementStyle_ = re_.sub(String_cleanup_pat_, " ", standardSettlementStyle_).strip()
            standardSettlementStyle_ = self.gds_validate_string(standardSettlementStyle_, node, 'standardSettlementStyle')
            self.standardSettlementStyle = standardSettlementStyle_
            # validate type StandardSettlementStyleEnum
            self.validate_StandardSettlementStyleEnum(self.standardSettlementStyle)
        elif nodeName_ == 'settlementInstruction':
            obj_ = SettlementInstruction.factory()
            obj_.build(child_)
            self.settlementInstruction = obj_
            obj_.original_tagname_ = 'settlementInstruction'
# end class SettlementInformation


class SettlementInstruction(GeneratedsSuper):
    """A type that models a complete instruction for settling a currency
    payment, including the settlement method to be used, the
    correspondent bank, any intermediary banks and the ultimate
    beneficary."""
    member_data_items_ = {
        'settlementMethod': MemberSpec_('settlementMethod', 'SettlementMethod', 0),
        'correspondentInformation': MemberSpec_('correspondentInformation', 'CorrespondentInformation', 0),
        'intermediaryInformation': MemberSpec_('intermediaryInformation', 'IntermediaryInformation', 1),
        'beneficiaryBank': MemberSpec_('beneficiaryBank', 'Beneficiary', 0),
        'beneficiary': MemberSpec_('beneficiary', 'Beneficiary', 0),
        'depositoryPartyReference': MemberSpec_('depositoryPartyReference', 'PartyReference', 0),
        'splitSettlement': MemberSpec_('splitSettlement', 'SplitSettlement', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, settlementMethod=None, correspondentInformation=None, intermediaryInformation=None, beneficiaryBank=None, beneficiary=None, depositoryPartyReference=None, splitSettlement=None):
        self.original_tagname_ = None
        self.settlementMethod = settlementMethod
        self.correspondentInformation = correspondentInformation
        if intermediaryInformation is None:
            self.intermediaryInformation = []
        else:
            self.intermediaryInformation = intermediaryInformation
        self.beneficiaryBank = beneficiaryBank
        self.beneficiary = beneficiary
        self.depositoryPartyReference = depositoryPartyReference
        if splitSettlement is None:
            self.splitSettlement = []
        else:
            self.splitSettlement = splitSettlement
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SettlementInstruction)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SettlementInstruction.subclass:
            return SettlementInstruction.subclass(*args_, **kwargs_)
        else:
            return SettlementInstruction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_settlementMethod(self): return self.settlementMethod
    def set_settlementMethod(self, settlementMethod): self.settlementMethod = settlementMethod
    def get_correspondentInformation(self): return self.correspondentInformation
    def set_correspondentInformation(self, correspondentInformation): self.correspondentInformation = correspondentInformation
    def get_intermediaryInformation(self): return self.intermediaryInformation
    def set_intermediaryInformation(self, intermediaryInformation): self.intermediaryInformation = intermediaryInformation
    def add_intermediaryInformation(self, value): self.intermediaryInformation.append(value)
    def insert_intermediaryInformation_at(self, index, value): self.intermediaryInformation.insert(index, value)
    def replace_intermediaryInformation_at(self, index, value): self.intermediaryInformation[index] = value
    def get_beneficiaryBank(self): return self.beneficiaryBank
    def set_beneficiaryBank(self, beneficiaryBank): self.beneficiaryBank = beneficiaryBank
    def get_beneficiary(self): return self.beneficiary
    def set_beneficiary(self, beneficiary): self.beneficiary = beneficiary
    def get_depositoryPartyReference(self): return self.depositoryPartyReference
    def set_depositoryPartyReference(self, depositoryPartyReference): self.depositoryPartyReference = depositoryPartyReference
    def get_splitSettlement(self): return self.splitSettlement
    def set_splitSettlement(self, splitSettlement): self.splitSettlement = splitSettlement
    def add_splitSettlement(self, value): self.splitSettlement.append(value)
    def insert_splitSettlement_at(self, index, value): self.splitSettlement.insert(index, value)
    def replace_splitSettlement_at(self, index, value): self.splitSettlement[index] = value
    def hasContent_(self):
        if (
            self.settlementMethod is not None or
            self.correspondentInformation is not None or
            self.intermediaryInformation or
            self.beneficiaryBank is not None or
            self.beneficiary is not None or
            self.depositoryPartyReference is not None or
            self.splitSettlement
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SettlementInstruction', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SettlementInstruction')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SettlementInstruction', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SettlementInstruction'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SettlementInstruction', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.settlementMethod is not None:
            self.settlementMethod.export(outfile, level, namespace_, name_='settlementMethod', pretty_print=pretty_print)
        if self.correspondentInformation is not None:
            self.correspondentInformation.export(outfile, level, namespace_, name_='correspondentInformation', pretty_print=pretty_print)
        for intermediaryInformation_ in self.intermediaryInformation:
            intermediaryInformation_.export(outfile, level, namespace_, name_='intermediaryInformation', pretty_print=pretty_print)
        if self.beneficiaryBank is not None:
            self.beneficiaryBank.export(outfile, level, namespace_, name_='beneficiaryBank', pretty_print=pretty_print)
        if self.beneficiary is not None:
            self.beneficiary.export(outfile, level, namespace_, name_='beneficiary', pretty_print=pretty_print)
        if self.depositoryPartyReference is not None:
            self.depositoryPartyReference.export(outfile, level, namespace_, name_='depositoryPartyReference', pretty_print=pretty_print)
        for splitSettlement_ in self.splitSettlement:
            splitSettlement_.export(outfile, level, namespace_, name_='splitSettlement', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'settlementMethod':
            obj_ = SettlementMethod.factory()
            obj_.build(child_)
            self.settlementMethod = obj_
            obj_.original_tagname_ = 'settlementMethod'
        elif nodeName_ == 'correspondentInformation':
            obj_ = CorrespondentInformation.factory()
            obj_.build(child_)
            self.correspondentInformation = obj_
            obj_.original_tagname_ = 'correspondentInformation'
        elif nodeName_ == 'intermediaryInformation':
            obj_ = IntermediaryInformation.factory()
            obj_.build(child_)
            self.intermediaryInformation.append(obj_)
            obj_.original_tagname_ = 'intermediaryInformation'
        elif nodeName_ == 'beneficiaryBank':
            obj_ = Beneficiary.factory()
            obj_.build(child_)
            self.beneficiaryBank = obj_
            obj_.original_tagname_ = 'beneficiaryBank'
        elif nodeName_ == 'beneficiary':
            obj_ = Beneficiary.factory()
            obj_.build(child_)
            self.beneficiary = obj_
            obj_.original_tagname_ = 'beneficiary'
        elif nodeName_ == 'depositoryPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.depositoryPartyReference = obj_
            obj_.original_tagname_ = 'depositoryPartyReference'
        elif nodeName_ == 'splitSettlement':
            obj_ = SplitSettlement.factory()
            obj_.build(child_)
            self.splitSettlement.append(obj_)
            obj_.original_tagname_ = 'splitSettlement'
# end class SettlementInstruction


class SettlementMethod(GeneratedsSuper):
    member_data_items_ = {
        'settlementMethodScheme': MemberSpec_('settlementMethodScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, settlementMethodScheme='http://www.fpml.org/coding-scheme/settlement-method', valueOf_=None):
        self.original_tagname_ = None
        self.settlementMethodScheme = _cast(None, settlementMethodScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SettlementMethod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SettlementMethod.subclass:
            return SettlementMethod.subclass(*args_, **kwargs_)
        else:
            return SettlementMethod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_settlementMethodScheme(self): return self.settlementMethodScheme
    def set_settlementMethodScheme(self, settlementMethodScheme): self.settlementMethodScheme = settlementMethodScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SettlementMethod', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SettlementMethod')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SettlementMethod', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SettlementMethod'):
        if self.settlementMethodScheme != "http://www.fpml.org/coding-scheme/settlement-method" and 'settlementMethodScheme' not in already_processed:
            already_processed.add('settlementMethodScheme')
            outfile.write(' settlementMethodScheme=%s' % (quote_attrib(self.settlementMethodScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SettlementMethod', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('settlementMethodScheme', node)
        if value is not None and 'settlementMethodScheme' not in already_processed:
            already_processed.add('settlementMethodScheme')
            self.settlementMethodScheme = value
            self.validate_NonEmptyURI(self.settlementMethodScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SettlementMethod


class SettlementPriceDefaultElection(GeneratedsSuper):
    """Coding scheme that specifies the settlement price default election."""
    member_data_items_ = {
        'settlementPriceDefaultElectionScheme': MemberSpec_('settlementPriceDefaultElectionScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, settlementPriceDefaultElectionScheme='http://www.fpml.org/coding-scheme/settlement-price-default-election', valueOf_=None):
        self.original_tagname_ = None
        self.settlementPriceDefaultElectionScheme = _cast(None, settlementPriceDefaultElectionScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SettlementPriceDefaultElection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SettlementPriceDefaultElection.subclass:
            return SettlementPriceDefaultElection.subclass(*args_, **kwargs_)
        else:
            return SettlementPriceDefaultElection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_settlementPriceDefaultElectionScheme(self): return self.settlementPriceDefaultElectionScheme
    def set_settlementPriceDefaultElectionScheme(self, settlementPriceDefaultElectionScheme): self.settlementPriceDefaultElectionScheme = settlementPriceDefaultElectionScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SettlementPriceDefaultElection', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SettlementPriceDefaultElection')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SettlementPriceDefaultElection', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SettlementPriceDefaultElection'):
        if self.settlementPriceDefaultElectionScheme != "http://www.fpml.org/coding-scheme/settlement-price-default-election" and 'settlementPriceDefaultElectionScheme' not in already_processed:
            already_processed.add('settlementPriceDefaultElectionScheme')
            outfile.write(' settlementPriceDefaultElectionScheme=%s' % (quote_attrib(self.settlementPriceDefaultElectionScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SettlementPriceDefaultElection', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('settlementPriceDefaultElectionScheme', node)
        if value is not None and 'settlementPriceDefaultElectionScheme' not in already_processed:
            already_processed.add('settlementPriceDefaultElectionScheme')
            self.settlementPriceDefaultElectionScheme = value
            self.validate_NonEmptyURI(self.settlementPriceDefaultElectionScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SettlementPriceDefaultElection


class SettlementPriceSource(GeneratedsSuper):
    """The source from which the settlement price is to be obtained, e.g. a
    Reuters page, Prezzo di Riferimento, etc."""
    member_data_items_ = {
        'settlementPriceSourceScheme': MemberSpec_('settlementPriceSourceScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, settlementPriceSourceScheme='http://www.fpml.org/coding-scheme/settlement-price-source', valueOf_=None):
        self.original_tagname_ = None
        self.settlementPriceSourceScheme = _cast(None, settlementPriceSourceScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SettlementPriceSource)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SettlementPriceSource.subclass:
            return SettlementPriceSource.subclass(*args_, **kwargs_)
        else:
            return SettlementPriceSource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_settlementPriceSourceScheme(self): return self.settlementPriceSourceScheme
    def set_settlementPriceSourceScheme(self, settlementPriceSourceScheme): self.settlementPriceSourceScheme = settlementPriceSourceScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SettlementPriceSource', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SettlementPriceSource')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SettlementPriceSource', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SettlementPriceSource'):
        if self.settlementPriceSourceScheme != "http://www.fpml.org/coding-scheme/settlement-price-source" and 'settlementPriceSourceScheme' not in already_processed:
            already_processed.add('settlementPriceSourceScheme')
            outfile.write(' settlementPriceSourceScheme=%s' % (quote_attrib(self.settlementPriceSourceScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SettlementPriceSource', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('settlementPriceSourceScheme', node)
        if value is not None and 'settlementPriceSourceScheme' not in already_processed:
            already_processed.add('settlementPriceSourceScheme')
            self.settlementPriceSourceScheme = value
            self.validate_NonEmptyURI(self.settlementPriceSourceScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SettlementPriceSource


class SettlementRateOption(GeneratedsSuper):
    """A type defining the settlement rate options through a scheme
    reflecting the terms of the Annex A to the 1998 FX and Currency
    Option Definitions."""
    member_data_items_ = {
        'settlementRateOptionScheme': MemberSpec_('settlementRateOptionScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, settlementRateOptionScheme='http://www.fpml.org/coding-scheme/settlement-rate-option', valueOf_=None):
        self.original_tagname_ = None
        self.settlementRateOptionScheme = _cast(None, settlementRateOptionScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SettlementRateOption)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SettlementRateOption.subclass:
            return SettlementRateOption.subclass(*args_, **kwargs_)
        else:
            return SettlementRateOption(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_settlementRateOptionScheme(self): return self.settlementRateOptionScheme
    def set_settlementRateOptionScheme(self, settlementRateOptionScheme): self.settlementRateOptionScheme = settlementRateOptionScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SettlementRateOption', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SettlementRateOption')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SettlementRateOption', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SettlementRateOption'):
        if self.settlementRateOptionScheme != "http://www.fpml.org/coding-scheme/settlement-rate-option" and 'settlementRateOptionScheme' not in already_processed:
            already_processed.add('settlementRateOptionScheme')
            outfile.write(' settlementRateOptionScheme=%s' % (quote_attrib(self.settlementRateOptionScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SettlementRateOption', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('settlementRateOptionScheme', node)
        if value is not None and 'settlementRateOptionScheme' not in already_processed:
            already_processed.add('settlementRateOptionScheme')
            self.settlementRateOptionScheme = value
            self.validate_NonEmptyURI(self.settlementRateOptionScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SettlementRateOption


class SettlementRateSource(GeneratedsSuper):
    """A type describing the method for obtaining a settlement rate."""
    member_data_items_ = {
        'informationSource': MemberSpec_('informationSource', 'InformationSource', 0),
        'cashSettlementReferenceBanks': MemberSpec_('cashSettlementReferenceBanks', 'CashSettlementReferenceBanks', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, informationSource=None, cashSettlementReferenceBanks=None):
        self.original_tagname_ = None
        self.informationSource = informationSource
        self.cashSettlementReferenceBanks = cashSettlementReferenceBanks
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SettlementRateSource)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SettlementRateSource.subclass:
            return SettlementRateSource.subclass(*args_, **kwargs_)
        else:
            return SettlementRateSource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_informationSource(self): return self.informationSource
    def set_informationSource(self, informationSource): self.informationSource = informationSource
    def get_cashSettlementReferenceBanks(self): return self.cashSettlementReferenceBanks
    def set_cashSettlementReferenceBanks(self, cashSettlementReferenceBanks): self.cashSettlementReferenceBanks = cashSettlementReferenceBanks
    def hasContent_(self):
        if (
            self.informationSource is not None or
            self.cashSettlementReferenceBanks is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SettlementRateSource', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SettlementRateSource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SettlementRateSource', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SettlementRateSource'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SettlementRateSource', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.informationSource is not None:
            self.informationSource.export(outfile, level, namespace_, name_='informationSource', pretty_print=pretty_print)
        if self.cashSettlementReferenceBanks is not None:
            self.cashSettlementReferenceBanks.export(outfile, level, namespace_, name_='cashSettlementReferenceBanks', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'informationSource':
            class_obj_ = self.get_class_obj_(child_, InformationSource)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.informationSource = obj_
            obj_.original_tagname_ = 'informationSource'
        elif nodeName_ == 'cashSettlementReferenceBanks':
            obj_ = CashSettlementReferenceBanks.factory()
            obj_.build(child_)
            self.cashSettlementReferenceBanks = obj_
            obj_.original_tagname_ = 'cashSettlementReferenceBanks'
# end class SettlementRateSource


class SharedAmericanExercise(Exercise):
    """TBAChoice between latest exercise time expressed as literal time, or
    using a determination method."""
    member_data_items_ = {
        'commencementDate': MemberSpec_('commencementDate', 'AdjustableOrRelativeDate', 0),
        'expirationDate': MemberSpec_('expirationDate', 'AdjustableOrRelativeDate', 0),
        'latestExerciseTime': MemberSpec_('latestExerciseTime', 'BusinessCenterTime', 0),
        'latestExerciseTimeDetermination': MemberSpec_('latestExerciseTimeDetermination', 'DeterminationMethod', 0),
    }
    subclass = None
    superclass = Exercise
    def __init__(self, id=None, commencementDate=None, expirationDate=None, latestExerciseTime=None, latestExerciseTimeDetermination=None):
        self.original_tagname_ = None
        super(SharedAmericanExercise, self).__init__(id, )
        self.commencementDate = commencementDate
        self.expirationDate = expirationDate
        self.latestExerciseTime = latestExerciseTime
        self.latestExerciseTimeDetermination = latestExerciseTimeDetermination
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SharedAmericanExercise)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SharedAmericanExercise.subclass:
            return SharedAmericanExercise.subclass(*args_, **kwargs_)
        else:
            return SharedAmericanExercise(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commencementDate(self): return self.commencementDate
    def set_commencementDate(self, commencementDate): self.commencementDate = commencementDate
    def get_expirationDate(self): return self.expirationDate
    def set_expirationDate(self, expirationDate): self.expirationDate = expirationDate
    def get_latestExerciseTime(self): return self.latestExerciseTime
    def set_latestExerciseTime(self, latestExerciseTime): self.latestExerciseTime = latestExerciseTime
    def get_latestExerciseTimeDetermination(self): return self.latestExerciseTimeDetermination
    def set_latestExerciseTimeDetermination(self, latestExerciseTimeDetermination): self.latestExerciseTimeDetermination = latestExerciseTimeDetermination
    def hasContent_(self):
        if (
            self.commencementDate is not None or
            self.expirationDate is not None or
            self.latestExerciseTime is not None or
            self.latestExerciseTimeDetermination is not None or
            super(SharedAmericanExercise, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SharedAmericanExercise', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SharedAmericanExercise')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SharedAmericanExercise', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SharedAmericanExercise'):
        super(SharedAmericanExercise, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SharedAmericanExercise')
    def exportChildren(self, outfile, level, namespace_='', name_='SharedAmericanExercise', fromsubclass_=False, pretty_print=True):
        super(SharedAmericanExercise, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.commencementDate is not None:
            self.commencementDate.export(outfile, level, namespace_, name_='commencementDate', pretty_print=pretty_print)
        if self.expirationDate is not None:
            self.expirationDate.export(outfile, level, namespace_, name_='expirationDate', pretty_print=pretty_print)
        if self.latestExerciseTime is not None:
            self.latestExerciseTime.export(outfile, level, namespace_, name_='latestExerciseTime', pretty_print=pretty_print)
        if self.latestExerciseTimeDetermination is not None:
            self.latestExerciseTimeDetermination.export(outfile, level, namespace_, name_='latestExerciseTimeDetermination', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SharedAmericanExercise, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'commencementDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.commencementDate = obj_
            obj_.original_tagname_ = 'commencementDate'
        elif nodeName_ == 'expirationDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.expirationDate = obj_
            obj_.original_tagname_ = 'expirationDate'
        elif nodeName_ == 'latestExerciseTime':
            obj_ = BusinessCenterTime.factory()
            obj_.build(child_)
            self.latestExerciseTime = obj_
            obj_.original_tagname_ = 'latestExerciseTime'
        elif nodeName_ == 'latestExerciseTimeDetermination':
            obj_ = DeterminationMethod.factory()
            obj_.build(child_)
            self.latestExerciseTimeDetermination = obj_
            obj_.original_tagname_ = 'latestExerciseTimeDetermination'
        super(SharedAmericanExercise, self).buildChildren(child_, node, nodeName_, True)
# end class SharedAmericanExercise


class SimplePayment(PaymentBase):
    """A complex type to specified payments in a simpler fashion than the
    Payment type. This construct should be used from the version 4.3
    onwards."""
    member_data_items_ = {
        'payerPartyReference': MemberSpec_('payerPartyReference', 'PartyReference', 0),
        'payerAccountReference': MemberSpec_('payerAccountReference', 'AccountReference', 0),
        'receiverPartyReference': MemberSpec_('receiverPartyReference', 'PartyReference', 0),
        'receiverAccountReference': MemberSpec_('receiverAccountReference', 'AccountReference', 0),
        'paymentAmount': MemberSpec_('paymentAmount', 'NonNegativeMoney', 0),
        'paymentDate': MemberSpec_('paymentDate', 'AdjustableOrRelativeDate', 0),
    }
    subclass = None
    superclass = PaymentBase
    def __init__(self, id=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, paymentAmount=None, paymentDate=None):
        self.original_tagname_ = None
        super(SimplePayment, self).__init__(id, )
        self.payerPartyReference = payerPartyReference
        self.payerAccountReference = payerAccountReference
        self.receiverPartyReference = receiverPartyReference
        self.receiverAccountReference = receiverAccountReference
        self.paymentAmount = paymentAmount
        self.paymentDate = paymentDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SimplePayment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SimplePayment.subclass:
            return SimplePayment.subclass(*args_, **kwargs_)
        else:
            return SimplePayment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_payerPartyReference(self): return self.payerPartyReference
    def set_payerPartyReference(self, payerPartyReference): self.payerPartyReference = payerPartyReference
    def get_payerAccountReference(self): return self.payerAccountReference
    def set_payerAccountReference(self, payerAccountReference): self.payerAccountReference = payerAccountReference
    def get_receiverPartyReference(self): return self.receiverPartyReference
    def set_receiverPartyReference(self, receiverPartyReference): self.receiverPartyReference = receiverPartyReference
    def get_receiverAccountReference(self): return self.receiverAccountReference
    def set_receiverAccountReference(self, receiverAccountReference): self.receiverAccountReference = receiverAccountReference
    def get_paymentAmount(self): return self.paymentAmount
    def set_paymentAmount(self, paymentAmount): self.paymentAmount = paymentAmount
    def get_paymentDate(self): return self.paymentDate
    def set_paymentDate(self, paymentDate): self.paymentDate = paymentDate
    def hasContent_(self):
        if (
            self.payerPartyReference is not None or
            self.payerAccountReference is not None or
            self.receiverPartyReference is not None or
            self.receiverAccountReference is not None or
            self.paymentAmount is not None or
            self.paymentDate is not None or
            super(SimplePayment, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SimplePayment', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SimplePayment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SimplePayment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SimplePayment'):
        super(SimplePayment, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SimplePayment')
    def exportChildren(self, outfile, level, namespace_='', name_='SimplePayment', fromsubclass_=False, pretty_print=True):
        super(SimplePayment, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.payerPartyReference is not None:
            self.payerPartyReference.export(outfile, level, namespace_, name_='payerPartyReference', pretty_print=pretty_print)
        if self.payerAccountReference is not None:
            self.payerAccountReference.export(outfile, level, namespace_, name_='payerAccountReference', pretty_print=pretty_print)
        if self.receiverPartyReference is not None:
            self.receiverPartyReference.export(outfile, level, namespace_, name_='receiverPartyReference', pretty_print=pretty_print)
        if self.receiverAccountReference is not None:
            self.receiverAccountReference.export(outfile, level, namespace_, name_='receiverAccountReference', pretty_print=pretty_print)
        if self.paymentAmount is not None:
            self.paymentAmount.export(outfile, level, namespace_, name_='paymentAmount', pretty_print=pretty_print)
        if self.paymentDate is not None:
            self.paymentDate.export(outfile, level, namespace_, name_='paymentDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SimplePayment, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'payerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.payerPartyReference = obj_
            obj_.original_tagname_ = 'payerPartyReference'
        elif nodeName_ == 'payerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.payerAccountReference = obj_
            obj_.original_tagname_ = 'payerAccountReference'
        elif nodeName_ == 'receiverPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.receiverPartyReference = obj_
            obj_.original_tagname_ = 'receiverPartyReference'
        elif nodeName_ == 'receiverAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.receiverAccountReference = obj_
            obj_.original_tagname_ = 'receiverAccountReference'
        elif nodeName_ == 'paymentAmount':
            class_obj_ = self.get_class_obj_(child_, NonNegativeMoney)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.paymentAmount = obj_
            obj_.original_tagname_ = 'paymentAmount'
        elif nodeName_ == 'paymentDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.paymentDate = obj_
            obj_.original_tagname_ = 'paymentDate'
        super(SimplePayment, self).buildChildren(child_, node, nodeName_, True)
# end class SimplePayment


class SplitSettlement(GeneratedsSuper):
    """A type that supports the division of a gross settlement amount into
    a number of split settlements, each requiring its own settlement
    instruction."""
    member_data_items_ = {
        'splitSettlementAmount': MemberSpec_('splitSettlementAmount', 'Money', 0),
        'beneficiaryBank': MemberSpec_('beneficiaryBank', 'Routing', 0),
        'beneficiary': MemberSpec_('beneficiary', 'Routing', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, splitSettlementAmount=None, beneficiaryBank=None, beneficiary=None):
        self.original_tagname_ = None
        self.splitSettlementAmount = splitSettlementAmount
        self.beneficiaryBank = beneficiaryBank
        self.beneficiary = beneficiary
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SplitSettlement)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SplitSettlement.subclass:
            return SplitSettlement.subclass(*args_, **kwargs_)
        else:
            return SplitSettlement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_splitSettlementAmount(self): return self.splitSettlementAmount
    def set_splitSettlementAmount(self, splitSettlementAmount): self.splitSettlementAmount = splitSettlementAmount
    def get_beneficiaryBank(self): return self.beneficiaryBank
    def set_beneficiaryBank(self, beneficiaryBank): self.beneficiaryBank = beneficiaryBank
    def get_beneficiary(self): return self.beneficiary
    def set_beneficiary(self, beneficiary): self.beneficiary = beneficiary
    def hasContent_(self):
        if (
            self.splitSettlementAmount is not None or
            self.beneficiaryBank is not None or
            self.beneficiary is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SplitSettlement', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SplitSettlement')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SplitSettlement', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SplitSettlement'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SplitSettlement', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.splitSettlementAmount is not None:
            self.splitSettlementAmount.export(outfile, level, namespace_, name_='splitSettlementAmount', pretty_print=pretty_print)
        if self.beneficiaryBank is not None:
            self.beneficiaryBank.export(outfile, level, namespace_, name_='beneficiaryBank', pretty_print=pretty_print)
        if self.beneficiary is not None:
            self.beneficiary.export(outfile, level, namespace_, name_='beneficiary', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'splitSettlementAmount':
            obj_ = Money.factory()
            obj_.build(child_)
            self.splitSettlementAmount = obj_
            obj_.original_tagname_ = 'splitSettlementAmount'
        elif nodeName_ == 'beneficiaryBank':
            obj_ = Routing.factory()
            obj_.build(child_)
            self.beneficiaryBank = obj_
            obj_.original_tagname_ = 'beneficiaryBank'
        elif nodeName_ == 'beneficiary':
            obj_ = Routing.factory()
            obj_.build(child_)
            self.beneficiary = obj_
            obj_.original_tagname_ = 'beneficiary'
# end class SplitSettlement


class SpreadSchedule(Schedule):
    """Adds an optional spread type element to the Schedule to identify a
    long or short spread value."""
    member_data_items_ = {
        'type_': MemberSpec_('type_', 'SpreadScheduleType', 0),
    }
    subclass = None
    superclass = Schedule
    def __init__(self, id=None, initialValue=None, step=None, type_=None):
        self.original_tagname_ = None
        super(SpreadSchedule, self).__init__(id, initialValue, step, )
        self.type_ = type_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpreadSchedule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpreadSchedule.subclass:
            return SpreadSchedule.subclass(*args_, **kwargs_)
        else:
            return SpreadSchedule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (
            self.type_ is not None or
            super(SpreadSchedule, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SpreadSchedule', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SpreadSchedule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SpreadSchedule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SpreadSchedule'):
        super(SpreadSchedule, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SpreadSchedule')
    def exportChildren(self, outfile, level, namespace_='', name_='SpreadSchedule', fromsubclass_=False, pretty_print=True):
        super(SpreadSchedule, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            self.type_.export(outfile, level, namespace_, name_='type', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SpreadSchedule, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            obj_ = SpreadScheduleType.factory()
            obj_.build(child_)
            self.type_ = obj_
            obj_.original_tagname_ = 'type'
        super(SpreadSchedule, self).buildChildren(child_, node, nodeName_, True)
# end class SpreadSchedule


class SpreadScheduleReference(Reference):
    """Provides a reference to a spread schedule."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(SpreadScheduleReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpreadScheduleReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpreadScheduleReference.subclass:
            return SpreadScheduleReference.subclass(*args_, **kwargs_)
        else:
            return SpreadScheduleReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(SpreadScheduleReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SpreadScheduleReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SpreadScheduleReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SpreadScheduleReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SpreadScheduleReference'):
        super(SpreadScheduleReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SpreadScheduleReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SpreadScheduleReference', fromsubclass_=False, pretty_print=True):
        super(SpreadScheduleReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(SpreadScheduleReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SpreadScheduleReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SpreadScheduleReference


class SpreadScheduleType(GeneratedsSuper):
    """Defines a Spread Type Scheme to identify a long or short spread
    value."""
    member_data_items_ = {
        'spreadScheduleTypeScheme': MemberSpec_('spreadScheduleTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, spreadScheduleTypeScheme='http://www.fpml.org/coding-scheme/spread-schedule-type', valueOf_=None):
        self.original_tagname_ = None
        self.spreadScheduleTypeScheme = _cast(None, spreadScheduleTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpreadScheduleType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpreadScheduleType.subclass:
            return SpreadScheduleType.subclass(*args_, **kwargs_)
        else:
            return SpreadScheduleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_spreadScheduleTypeScheme(self): return self.spreadScheduleTypeScheme
    def set_spreadScheduleTypeScheme(self, spreadScheduleTypeScheme): self.spreadScheduleTypeScheme = spreadScheduleTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SpreadScheduleType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SpreadScheduleType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SpreadScheduleType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SpreadScheduleType'):
        if self.spreadScheduleTypeScheme != "http://www.fpml.org/coding-scheme/spread-schedule-type" and 'spreadScheduleTypeScheme' not in already_processed:
            already_processed.add('spreadScheduleTypeScheme')
            outfile.write(' spreadScheduleTypeScheme=%s' % (quote_attrib(self.spreadScheduleTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SpreadScheduleType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('spreadScheduleTypeScheme', node)
        if value is not None and 'spreadScheduleTypeScheme' not in already_processed:
            already_processed.add('spreadScheduleTypeScheme')
            self.spreadScheduleTypeScheme = value
            self.validate_NonEmptyURI(self.spreadScheduleTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SpreadScheduleType


class StepBase(GeneratedsSuper):
    """A type defining a step date and step value pair. This step
    definitions are used to define varying rate or amount schedules,
    e.g. a notional amortization or a step-up coupon schedule."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'stepDate': MemberSpec_('stepDate', 'xsd:date', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, stepDate=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if isinstance(stepDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(stepDate, '%Y-%m-%d').date()
        else:
            initvalue_ = stepDate
        self.stepDate = initvalue_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StepBase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StepBase.subclass:
            return StepBase.subclass(*args_, **kwargs_)
        else:
            return StepBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_stepDate(self): return self.stepDate
    def set_stepDate(self, stepDate): self.stepDate = stepDate
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.stepDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StepBase', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StepBase')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StepBase', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StepBase'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='StepBase', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.stepDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstepDate>%s</%sstepDate>%s' % (namespace_, self.gds_format_date(self.stepDate, input_name='stepDate'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'stepDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.stepDate = dval_
# end class StepBase


class StreetAddress(GeneratedsSuper):
    """A type that describes the set of street and building number
    information that identifies a postal address within a city."""
    member_data_items_ = {
        'streetLine': MemberSpec_('streetLine', ['String', 'xsd:string'], 1),
    }
    subclass = None
    superclass = None
    def __init__(self, streetLine=None):
        self.original_tagname_ = None
        if streetLine is None:
            self.streetLine = []
        else:
            self.streetLine = streetLine
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StreetAddress)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StreetAddress.subclass:
            return StreetAddress.subclass(*args_, **kwargs_)
        else:
            return StreetAddress(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_streetLine(self): return self.streetLine
    def set_streetLine(self, streetLine): self.streetLine = streetLine
    def add_streetLine(self, value): self.streetLine.append(value)
    def insert_streetLine_at(self, index, value): self.streetLine.insert(index, value)
    def replace_streetLine_at(self, index, value): self.streetLine[index] = value
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.streetLine
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StreetAddress', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StreetAddress')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StreetAddress', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StreetAddress'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StreetAddress', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for streetLine_ in self.streetLine:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstreetLine>%s</%sstreetLine>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(streetLine_), input_name='streetLine')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'streetLine':
            streetLine_ = child_.text
            streetLine_ = self.gds_validate_string(streetLine_, node, 'streetLine')
            self.streetLine.append(streetLine_)
            # validate type String
            self.validate_String(self.streetLine[-1])
# end class StreetAddress


class Strike(GeneratedsSuper):
    """A type describing a single cap or floor rate."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'strikeRate': MemberSpec_('strikeRate', 'xsd:decimal', 0),
        'buyer': MemberSpec_('buyer', 'IdentifiedPayerReceiver', 0),
        'seller': MemberSpec_('seller', 'IdentifiedPayerReceiver', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, strikeRate=None, buyer=None, seller=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.strikeRate = strikeRate
        self.buyer = buyer
        self.seller = seller
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Strike)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Strike.subclass:
            return Strike.subclass(*args_, **kwargs_)
        else:
            return Strike(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_strikeRate(self): return self.strikeRate
    def set_strikeRate(self, strikeRate): self.strikeRate = strikeRate
    def get_buyer(self): return self.buyer
    def set_buyer(self, buyer): self.buyer = buyer
    def get_seller(self): return self.seller
    def set_seller(self, seller): self.seller = seller
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.strikeRate is not None or
            self.buyer is not None or
            self.seller is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Strike', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Strike')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Strike', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Strike'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Strike', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.strikeRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstrikeRate>%s</%sstrikeRate>%s' % (namespace_, self.gds_format_float(self.strikeRate, input_name='strikeRate'), namespace_, eol_))
        if self.buyer is not None:
            self.buyer.export(outfile, level, namespace_, name_='buyer', pretty_print=pretty_print)
        if self.seller is not None:
            self.seller.export(outfile, level, namespace_, name_='seller', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'strikeRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'strikeRate')
            self.strikeRate = fval_
        elif nodeName_ == 'buyer':
            obj_ = IdentifiedPayerReceiver.factory()
            obj_.build(child_)
            self.buyer = obj_
            obj_.original_tagname_ = 'buyer'
        elif nodeName_ == 'seller':
            obj_ = IdentifiedPayerReceiver.factory()
            obj_.build(child_)
            self.seller = obj_
            obj_.original_tagname_ = 'seller'
# end class Strike


class StrikeSchedule(Schedule):
    """A type describing a schedule of cap or floor rates."""
    member_data_items_ = {
        'buyer': MemberSpec_('buyer', 'IdentifiedPayerReceiver', 0),
        'seller': MemberSpec_('seller', 'IdentifiedPayerReceiver', 0),
    }
    subclass = None
    superclass = Schedule
    def __init__(self, id=None, initialValue=None, step=None, buyer=None, seller=None):
        self.original_tagname_ = None
        super(StrikeSchedule, self).__init__(id, initialValue, step, )
        self.buyer = buyer
        self.seller = seller
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrikeSchedule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrikeSchedule.subclass:
            return StrikeSchedule.subclass(*args_, **kwargs_)
        else:
            return StrikeSchedule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_buyer(self): return self.buyer
    def set_buyer(self, buyer): self.buyer = buyer
    def get_seller(self): return self.seller
    def set_seller(self, seller): self.seller = seller
    def hasContent_(self):
        if (
            self.buyer is not None or
            self.seller is not None or
            super(StrikeSchedule, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StrikeSchedule', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StrikeSchedule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StrikeSchedule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StrikeSchedule'):
        super(StrikeSchedule, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StrikeSchedule')
    def exportChildren(self, outfile, level, namespace_='', name_='StrikeSchedule', fromsubclass_=False, pretty_print=True):
        super(StrikeSchedule, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.buyer is not None:
            self.buyer.export(outfile, level, namespace_, name_='buyer', pretty_print=pretty_print)
        if self.seller is not None:
            self.seller.export(outfile, level, namespace_, name_='seller', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(StrikeSchedule, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'buyer':
            obj_ = IdentifiedPayerReceiver.factory()
            obj_.build(child_)
            self.buyer = obj_
            obj_.original_tagname_ = 'buyer'
        elif nodeName_ == 'seller':
            obj_ = IdentifiedPayerReceiver.factory()
            obj_.build(child_)
            self.seller = obj_
            obj_.original_tagname_ = 'seller'
        super(StrikeSchedule, self).buildChildren(child_, node, nodeName_, True)
# end class StrikeSchedule


class StubValue(GeneratedsSuper):
    """A type defining how a stub calculation period amount is calculated.
    A single floating rate tenor different to that used for the
    regular part of the calculation periods schedule may be
    specified, or two floating rate tenors many be specified. If two
    floating rate tenors are specified then Linear Interpolation (in
    accordance with the 2000 ISDA Definitions, Section 8.3
    Interpolation) is assumed to apply. Alternatively, an actual
    known stub rate or stub amount may be specified."""
    member_data_items_ = {
        'floatingRate': MemberSpec_('floatingRate', 'StubFloatingRate', 1),
        'stubRate': MemberSpec_('stubRate', 'xsd:decimal', 0),
        'stubAmount': MemberSpec_('stubAmount', 'Money', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, floatingRate=None, stubRate=None, stubAmount=None, extensiontype_=None):
        self.original_tagname_ = None
        if floatingRate is None:
            self.floatingRate = []
        else:
            self.floatingRate = floatingRate
        self.stubRate = stubRate
        self.stubAmount = stubAmount
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StubValue)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StubValue.subclass:
            return StubValue.subclass(*args_, **kwargs_)
        else:
            return StubValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_floatingRate(self): return self.floatingRate
    def set_floatingRate(self, floatingRate): self.floatingRate = floatingRate
    def add_floatingRate(self, value): self.floatingRate.append(value)
    def insert_floatingRate_at(self, index, value): self.floatingRate.insert(index, value)
    def replace_floatingRate_at(self, index, value): self.floatingRate[index] = value
    def get_stubRate(self): return self.stubRate
    def set_stubRate(self, stubRate): self.stubRate = stubRate
    def get_stubAmount(self): return self.stubAmount
    def set_stubAmount(self, stubAmount): self.stubAmount = stubAmount
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.floatingRate or
            self.stubRate is not None or
            self.stubAmount is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StubValue', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StubValue')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StubValue', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StubValue'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StubValue', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for floatingRate_ in self.floatingRate:
            floatingRate_.export(outfile, level, namespace_, name_='floatingRate', pretty_print=pretty_print)
        if self.stubRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstubRate>%s</%sstubRate>%s' % (namespace_, self.gds_format_float(self.stubRate, input_name='stubRate'), namespace_, eol_))
        if self.stubAmount is not None:
            self.stubAmount.export(outfile, level, namespace_, name_='stubAmount', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'floatingRate':
            obj_ = StubFloatingRate.factory()
            obj_.build(child_)
            self.floatingRate.append(obj_)
            obj_.original_tagname_ = 'floatingRate'
        elif nodeName_ == 'stubRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'stubRate')
            self.stubRate = fval_
        elif nodeName_ == 'stubAmount':
            obj_ = Money.factory()
            obj_.build(child_)
            self.stubAmount = obj_
            obj_.original_tagname_ = 'stubAmount'
# end class StubValue


class StubFloatingRate(Rate):
    """A type defining a floating rate."""
    member_data_items_ = {
        'floatingRateIndex': MemberSpec_('floatingRateIndex', 'FloatingRateIndex', 0),
        'indexTenor': MemberSpec_('indexTenor', 'Period', 0),
        'floatingRateMultiplierSchedule': MemberSpec_('floatingRateMultiplierSchedule', 'Schedule', 0),
        'spreadSchedule': MemberSpec_('spreadSchedule', 'SpreadSchedule', 1),
        'rateTreatment': MemberSpec_('rateTreatment', ['RateTreatmentEnum', 'Token', 'xsd:token'], 0),
        'capRateSchedule': MemberSpec_('capRateSchedule', 'StrikeSchedule', 1),
        'floorRateSchedule': MemberSpec_('floorRateSchedule', 'StrikeSchedule', 1),
        'capFloorStraddle': MemberSpec_('capFloorStraddle', 'xsd:boolean', 0),
    }
    subclass = None
    superclass = Rate
    def __init__(self, id=None, floatingRateIndex=None, indexTenor=None, floatingRateMultiplierSchedule=None, spreadSchedule=None, rateTreatment=None, capRateSchedule=None, floorRateSchedule=None, capFloorStraddle=None):
        self.original_tagname_ = None
        super(StubFloatingRate, self).__init__(id, )
        self.floatingRateIndex = floatingRateIndex
        self.indexTenor = indexTenor
        self.floatingRateMultiplierSchedule = floatingRateMultiplierSchedule
        if spreadSchedule is None:
            self.spreadSchedule = []
        else:
            self.spreadSchedule = spreadSchedule
        self.rateTreatment = rateTreatment
        self.validate_RateTreatmentEnum(self.rateTreatment)
        if capRateSchedule is None:
            self.capRateSchedule = []
        else:
            self.capRateSchedule = capRateSchedule
        if floorRateSchedule is None:
            self.floorRateSchedule = []
        else:
            self.floorRateSchedule = floorRateSchedule
        self.capFloorStraddle = capFloorStraddle
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StubFloatingRate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StubFloatingRate.subclass:
            return StubFloatingRate.subclass(*args_, **kwargs_)
        else:
            return StubFloatingRate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_floatingRateIndex(self): return self.floatingRateIndex
    def set_floatingRateIndex(self, floatingRateIndex): self.floatingRateIndex = floatingRateIndex
    def get_indexTenor(self): return self.indexTenor
    def set_indexTenor(self, indexTenor): self.indexTenor = indexTenor
    def get_floatingRateMultiplierSchedule(self): return self.floatingRateMultiplierSchedule
    def set_floatingRateMultiplierSchedule(self, floatingRateMultiplierSchedule): self.floatingRateMultiplierSchedule = floatingRateMultiplierSchedule
    def get_spreadSchedule(self): return self.spreadSchedule
    def set_spreadSchedule(self, spreadSchedule): self.spreadSchedule = spreadSchedule
    def add_spreadSchedule(self, value): self.spreadSchedule.append(value)
    def insert_spreadSchedule_at(self, index, value): self.spreadSchedule.insert(index, value)
    def replace_spreadSchedule_at(self, index, value): self.spreadSchedule[index] = value
    def get_rateTreatment(self): return self.rateTreatment
    def set_rateTreatment(self, rateTreatment): self.rateTreatment = rateTreatment
    def get_capRateSchedule(self): return self.capRateSchedule
    def set_capRateSchedule(self, capRateSchedule): self.capRateSchedule = capRateSchedule
    def add_capRateSchedule(self, value): self.capRateSchedule.append(value)
    def insert_capRateSchedule_at(self, index, value): self.capRateSchedule.insert(index, value)
    def replace_capRateSchedule_at(self, index, value): self.capRateSchedule[index] = value
    def get_floorRateSchedule(self): return self.floorRateSchedule
    def set_floorRateSchedule(self, floorRateSchedule): self.floorRateSchedule = floorRateSchedule
    def add_floorRateSchedule(self, value): self.floorRateSchedule.append(value)
    def insert_floorRateSchedule_at(self, index, value): self.floorRateSchedule.insert(index, value)
    def replace_floorRateSchedule_at(self, index, value): self.floorRateSchedule[index] = value
    def get_capFloorStraddle(self): return self.capFloorStraddle
    def set_capFloorStraddle(self, capFloorStraddle): self.capFloorStraddle = capFloorStraddle
    def validate_RateTreatmentEnum(self, value):
        # Validate type RateTreatmentEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['BondEquivalentYield', 'MoneyMarketYield']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RateTreatmentEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on RateTreatmentEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.floatingRateIndex is not None or
            self.indexTenor is not None or
            self.floatingRateMultiplierSchedule is not None or
            self.spreadSchedule or
            self.rateTreatment is not None or
            self.capRateSchedule or
            self.floorRateSchedule or
            self.capFloorStraddle is not None or
            super(StubFloatingRate, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StubFloatingRate', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StubFloatingRate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StubFloatingRate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StubFloatingRate'):
        super(StubFloatingRate, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StubFloatingRate')
    def exportChildren(self, outfile, level, namespace_='', name_='StubFloatingRate', fromsubclass_=False, pretty_print=True):
        super(StubFloatingRate, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.floatingRateIndex is not None:
            self.floatingRateIndex.export(outfile, level, namespace_, name_='floatingRateIndex', pretty_print=pretty_print)
        if self.indexTenor is not None:
            self.indexTenor.export(outfile, level, namespace_, name_='indexTenor', pretty_print=pretty_print)
        if self.floatingRateMultiplierSchedule is not None:
            self.floatingRateMultiplierSchedule.export(outfile, level, namespace_, name_='floatingRateMultiplierSchedule', pretty_print=pretty_print)
        for spreadSchedule_ in self.spreadSchedule:
            spreadSchedule_.export(outfile, level, namespace_, name_='spreadSchedule', pretty_print=pretty_print)
        if self.rateTreatment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srateTreatment>%s</%srateTreatment>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.rateTreatment), input_name='rateTreatment')), namespace_, eol_))
        for capRateSchedule_ in self.capRateSchedule:
            capRateSchedule_.export(outfile, level, namespace_, name_='capRateSchedule', pretty_print=pretty_print)
        for floorRateSchedule_ in self.floorRateSchedule:
            floorRateSchedule_.export(outfile, level, namespace_, name_='floorRateSchedule', pretty_print=pretty_print)
        if self.capFloorStraddle is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scapFloorStraddle>%s</%scapFloorStraddle>%s' % (namespace_, self.gds_format_boolean(self.capFloorStraddle, input_name='capFloorStraddle'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(StubFloatingRate, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'floatingRateIndex':
            obj_ = FloatingRateIndex.factory()
            obj_.build(child_)
            self.floatingRateIndex = obj_
            obj_.original_tagname_ = 'floatingRateIndex'
        elif nodeName_ == 'indexTenor':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.indexTenor = obj_
            obj_.original_tagname_ = 'indexTenor'
        elif nodeName_ == 'floatingRateMultiplierSchedule':
            class_obj_ = self.get_class_obj_(child_, Schedule)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.floatingRateMultiplierSchedule = obj_
            obj_.original_tagname_ = 'floatingRateMultiplierSchedule'
        elif nodeName_ == 'spreadSchedule':
            obj_ = SpreadSchedule.factory()
            obj_.build(child_)
            self.spreadSchedule.append(obj_)
            obj_.original_tagname_ = 'spreadSchedule'
        elif nodeName_ == 'rateTreatment':
            rateTreatment_ = child_.text
            rateTreatment_ = re_.sub(String_cleanup_pat_, " ", rateTreatment_).strip()
            rateTreatment_ = self.gds_validate_string(rateTreatment_, node, 'rateTreatment')
            self.rateTreatment = rateTreatment_
            # validate type RateTreatmentEnum
            self.validate_RateTreatmentEnum(self.rateTreatment)
        elif nodeName_ == 'capRateSchedule':
            obj_ = StrikeSchedule.factory()
            obj_.build(child_)
            self.capRateSchedule.append(obj_)
            obj_.original_tagname_ = 'capRateSchedule'
        elif nodeName_ == 'floorRateSchedule':
            obj_ = StrikeSchedule.factory()
            obj_.build(child_)
            self.floorRateSchedule.append(obj_)
            obj_.original_tagname_ = 'floorRateSchedule'
        elif nodeName_ == 'capFloorStraddle':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'capFloorStraddle')
            self.capFloorStraddle = ival_
        super(StubFloatingRate, self).buildChildren(child_, node, nodeName_, True)
# end class StubFloatingRate


class SupervisoryBody(GeneratedsSuper):
    """An identifier of an organization that supervises or regulates
    trading activity, e.g. CFTC, SEC, FSA, ODRF, etc."""
    member_data_items_ = {
        'supervisoryBodyScheme': MemberSpec_('supervisoryBodyScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, supervisoryBodyScheme='http://www.fpml.org/coding-scheme/supervisory-body', valueOf_=None):
        self.original_tagname_ = None
        self.supervisoryBodyScheme = _cast(None, supervisoryBodyScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SupervisoryBody)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SupervisoryBody.subclass:
            return SupervisoryBody.subclass(*args_, **kwargs_)
        else:
            return SupervisoryBody(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_supervisoryBodyScheme(self): return self.supervisoryBodyScheme
    def set_supervisoryBodyScheme(self, supervisoryBodyScheme): self.supervisoryBodyScheme = supervisoryBodyScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SupervisoryBody', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SupervisoryBody')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SupervisoryBody', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SupervisoryBody'):
        if self.supervisoryBodyScheme != "http://www.fpml.org/coding-scheme/supervisory-body" and 'supervisoryBodyScheme' not in already_processed:
            already_processed.add('supervisoryBodyScheme')
            outfile.write(' supervisoryBodyScheme=%s' % (quote_attrib(self.supervisoryBodyScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SupervisoryBody', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('supervisoryBodyScheme', node)
        if value is not None and 'supervisoryBodyScheme' not in already_processed:
            already_processed.add('supervisoryBodyScheme')
            self.supervisoryBodyScheme = value
            self.validate_NonEmptyURI(self.supervisoryBodyScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SupervisoryBody


class TelephoneNumber(GeneratedsSuper):
    """A type that represents a telephonic contact."""
    member_data_items_ = {
        'type_': MemberSpec_('type_', ['TelephoneTypeEnum', 'Token', 'xsd:token'], 0),
        'number': MemberSpec_('number', ['String', 'xsd:string'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, type_=None, number=None):
        self.original_tagname_ = None
        self.type_ = type_
        self.validate_TelephoneTypeEnum(self.type_)
        self.number = number
        self.validate_String(self.number)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TelephoneNumber)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TelephoneNumber.subclass:
            return TelephoneNumber.subclass(*args_, **kwargs_)
        else:
            return TelephoneNumber(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_number(self): return self.number
    def set_number(self, number): self.number = number
    def validate_TelephoneTypeEnum(self, value):
        # Validate type TelephoneTypeEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Work', 'Mobile', 'Fax', 'Personal']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TelephoneTypeEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on TelephoneTypeEnum' % {"value" : value} )
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.type_ is not None or
            self.number is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TelephoneNumber', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TelephoneNumber')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TelephoneNumber', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TelephoneNumber'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TelephoneNumber', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stype>%s</%stype>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.type_), input_name='type')), namespace_, eol_))
        if self.number is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumber>%s</%snumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.number), input_name='number')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            type_ = child_.text
            type_ = re_.sub(String_cleanup_pat_, " ", type_).strip()
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
            # validate type TelephoneTypeEnum
            self.validate_TelephoneTypeEnum(self.type_)
        elif nodeName_ == 'number':
            number_ = child_.text
            number_ = self.gds_validate_string(number_, node, 'number')
            self.number = number_
            # validate type String
            self.validate_String(self.number)
# end class TelephoneNumber


class TimezoneLocation(GeneratedsSuper):
    """A geophraphic location for the purposes of defining a prevailing
    time according to the tz database."""
    member_data_items_ = {
        'timezoneLocationScheme': MemberSpec_('timezoneLocationScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, timezoneLocationScheme='http://www.fpml.org/coding-scheme/external/tzdatabase', valueOf_=None):
        self.original_tagname_ = None
        self.timezoneLocationScheme = _cast(None, timezoneLocationScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimezoneLocation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimezoneLocation.subclass:
            return TimezoneLocation.subclass(*args_, **kwargs_)
        else:
            return TimezoneLocation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_timezoneLocationScheme(self): return self.timezoneLocationScheme
    def set_timezoneLocationScheme(self, timezoneLocationScheme): self.timezoneLocationScheme = timezoneLocationScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TimezoneLocation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimezoneLocation')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TimezoneLocation', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimezoneLocation'):
        if self.timezoneLocationScheme != "http://www.fpml.org/coding-scheme/external/tzdatabase" and 'timezoneLocationScheme' not in already_processed:
            already_processed.add('timezoneLocationScheme')
            outfile.write(' timezoneLocationScheme=%s' % (quote_attrib(self.timezoneLocationScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TimezoneLocation', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('timezoneLocationScheme', node)
        if value is not None and 'timezoneLocationScheme' not in already_processed:
            already_processed.add('timezoneLocationScheme')
            self.timezoneLocationScheme = value
            self.validate_NonEmptyURI(self.timezoneLocationScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TimezoneLocation


class TradeId(GeneratedsSuper):
    """A trade reference identifier allocated by a party. FpML does not
    define the domain values associated with this element. Note that
    the domain values for this element are not strictly an
    enumerated list."""
    member_data_items_ = {
        'tradeIdScheme': MemberSpec_('tradeIdScheme', 'NonEmptyURI', 0),
        'id': MemberSpec_('id', 'xsd:string', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, tradeIdScheme=None, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.tradeIdScheme = _cast(None, tradeIdScheme)
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TradeId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TradeId.subclass:
            return TradeId.subclass(*args_, **kwargs_)
        else:
            return TradeId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tradeIdScheme(self): return self.tradeIdScheme
    def set_tradeIdScheme(self, tradeIdScheme): self.tradeIdScheme = tradeIdScheme
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TradeId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TradeId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TradeId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TradeId'):
        if self.tradeIdScheme is not None and 'tradeIdScheme' not in already_processed:
            already_processed.add('tradeIdScheme')
            outfile.write(' tradeIdScheme=%s' % (quote_attrib(self.tradeIdScheme), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TradeId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('tradeIdScheme', node)
        if value is not None and 'tradeIdScheme' not in already_processed:
            already_processed.add('tradeIdScheme')
            self.tradeIdScheme = value
            self.validate_NonEmptyURI(self.tradeIdScheme)    # validate type NonEmptyURI
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TradeId


class Unit(GeneratedsSuper):
    """A type used to record information about a unit, subdivision, desk,
    or other similar business entity."""
    member_data_items_ = {
        'unitScheme': MemberSpec_('unitScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, unitScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.unitScheme = _cast(None, unitScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Unit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Unit.subclass:
            return Unit.subclass(*args_, **kwargs_)
        else:
            return Unit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unitScheme(self): return self.unitScheme
    def set_unitScheme(self, unitScheme): self.unitScheme = unitScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Unit', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Unit')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Unit', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Unit'):
        if self.unitScheme is not None and 'unitScheme' not in already_processed:
            already_processed.add('unitScheme')
            outfile.write(' unitScheme=%s' % (quote_attrib(self.unitScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Unit', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unitScheme', node)
        if value is not None and 'unitScheme' not in already_processed:
            already_processed.add('unitScheme')
            self.unitScheme = value
            self.validate_NonEmptyURI(self.unitScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Unit


class IssuerId(GeneratedsSuper):
    """The data type used for issuer identifiers."""
    member_data_items_ = {
        'issuerIdScheme': MemberSpec_('issuerIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, issuerIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.issuerIdScheme = _cast(None, issuerIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IssuerId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IssuerId.subclass:
            return IssuerId.subclass(*args_, **kwargs_)
        else:
            return IssuerId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_issuerIdScheme(self): return self.issuerIdScheme
    def set_issuerIdScheme(self, issuerIdScheme): self.issuerIdScheme = issuerIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IssuerId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IssuerId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IssuerId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IssuerId'):
        if self.issuerIdScheme is not None and 'issuerIdScheme' not in already_processed:
            already_processed.add('issuerIdScheme')
            outfile.write(' issuerIdScheme=%s' % (quote_attrib(self.issuerIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IssuerId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('issuerIdScheme', node)
        if value is not None and 'issuerIdScheme' not in already_processed:
            already_processed.add('issuerIdScheme')
            self.issuerIdScheme = value
            self.validate_NonEmptyURI(self.issuerIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IssuerId


class IssuerTradeId(GeneratedsSuper):
    """A complex type for a two part identifier such as a USI."""
    member_data_items_ = {
        'issuer': MemberSpec_('issuer', 'IssuerId', 0),
        'tradeId': MemberSpec_('tradeId', 'TradeId', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, issuer=None, tradeId=None):
        self.original_tagname_ = None
        self.issuer = issuer
        self.tradeId = tradeId
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IssuerTradeId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IssuerTradeId.subclass:
            return IssuerTradeId.subclass(*args_, **kwargs_)
        else:
            return IssuerTradeId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_issuer(self): return self.issuer
    def set_issuer(self, issuer): self.issuer = issuer
    def get_tradeId(self): return self.tradeId
    def set_tradeId(self, tradeId): self.tradeId = tradeId
    def hasContent_(self):
        if (
            self.issuer is not None or
            self.tradeId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IssuerTradeId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IssuerTradeId')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IssuerTradeId', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IssuerTradeId'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IssuerTradeId', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.issuer is not None:
            self.issuer.export(outfile, level, namespace_, name_='issuer', pretty_print=pretty_print)
        if self.tradeId is not None:
            self.tradeId.export(outfile, level, namespace_, name_='tradeId', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'issuer':
            obj_ = IssuerId.factory()
            obj_.build(child_)
            self.issuer = obj_
            obj_.original_tagname_ = 'issuer'
        elif nodeName_ == 'tradeId':
            obj_ = TradeId.factory()
            obj_.build(child_)
            self.tradeId = obj_
            obj_.original_tagname_ = 'tradeId'
# end class IssuerTradeId


class ContractualDocument(GeneratedsSuper):
    """The base type for a legal document."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'documentType': MemberSpec_('documentType', 'LegalDocumentType', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, documentType=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.documentType = documentType
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContractualDocument)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContractualDocument.subclass:
            return ContractualDocument.subclass(*args_, **kwargs_)
        else:
            return ContractualDocument(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_documentType(self): return self.documentType
    def set_documentType(self, documentType): self.documentType = documentType
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.documentType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ContractualDocument', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContractualDocument')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ContractualDocument', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContractualDocument'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='ContractualDocument', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.documentType is not None:
            self.documentType.export(outfile, level, namespace_, name_='documentType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'documentType':
            obj_ = LegalDocumentType.factory()
            obj_.build(child_)
            self.documentType = obj_
            obj_.original_tagname_ = 'documentType'
# end class ContractualDocument


class Country(GeneratedsSuper):
    """A type to hold the country scheme. By default, it is a valid country
    code as defined by the ISO standard 3166."""
    member_data_items_ = {
        'countryScheme': MemberSpec_('countryScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, countryScheme='http://www.fpml.org/coding-scheme/external/iso3166', valueOf_=None):
        self.original_tagname_ = None
        self.countryScheme = _cast(None, countryScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Country)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Country.subclass:
            return Country.subclass(*args_, **kwargs_)
        else:
            return Country(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_countryScheme(self): return self.countryScheme
    def set_countryScheme(self, countryScheme): self.countryScheme = countryScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Country', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Country')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Country', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Country'):
        if self.countryScheme != "http://www.fpml.org/coding-scheme/external/iso3166" and 'countryScheme' not in already_processed:
            already_processed.add('countryScheme')
            outfile.write(' countryScheme=%s' % (quote_attrib(self.countryScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Country', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('countryScheme', node)
        if value is not None and 'countryScheme' not in already_processed:
            already_processed.add('countryScheme')
            self.countryScheme = value
            self.validate_NonEmptyURI(self.countryScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Country


class CreditNotation(GeneratedsSuper):
    """The credit rating notation base construct, which includes agency,
    notation, scale and debt type qualifications."""
    member_data_items_ = {
        'agency': MemberSpec_('agency', 'CreditRatingAgency', 0),
        'notation': MemberSpec_('notation', 'CreditRatingNotation', 0),
        'scale': MemberSpec_('scale', 'CreditRatingScale', 0),
        'debt': MemberSpec_('debt', 'CreditRatingDebt', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, agency=None, notation=None, scale=None, debt=None):
        self.original_tagname_ = None
        self.agency = agency
        self.notation = notation
        self.scale = scale
        self.debt = debt
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditNotation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditNotation.subclass:
            return CreditNotation.subclass(*args_, **kwargs_)
        else:
            return CreditNotation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_agency(self): return self.agency
    def set_agency(self, agency): self.agency = agency
    def get_notation(self): return self.notation
    def set_notation(self, notation): self.notation = notation
    def get_scale(self): return self.scale
    def set_scale(self, scale): self.scale = scale
    def get_debt(self): return self.debt
    def set_debt(self, debt): self.debt = debt
    def hasContent_(self):
        if (
            self.agency is not None or
            self.notation is not None or
            self.scale is not None or
            self.debt is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditNotation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditNotation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditNotation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditNotation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CreditNotation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.agency is not None:
            self.agency.export(outfile, level, namespace_, name_='agency', pretty_print=pretty_print)
        if self.notation is not None:
            self.notation.export(outfile, level, namespace_, name_='notation', pretty_print=pretty_print)
        if self.scale is not None:
            self.scale.export(outfile, level, namespace_, name_='scale', pretty_print=pretty_print)
        if self.debt is not None:
            self.debt.export(outfile, level, namespace_, name_='debt', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'agency':
            obj_ = CreditRatingAgency.factory()
            obj_.build(child_)
            self.agency = obj_
            obj_.original_tagname_ = 'agency'
        elif nodeName_ == 'notation':
            obj_ = CreditRatingNotation.factory()
            obj_.build(child_)
            self.notation = obj_
            obj_.original_tagname_ = 'notation'
        elif nodeName_ == 'scale':
            obj_ = CreditRatingScale.factory()
            obj_.build(child_)
            self.scale = obj_
            obj_.original_tagname_ = 'scale'
        elif nodeName_ == 'debt':
            obj_ = CreditRatingDebt.factory()
            obj_.build(child_)
            self.debt = obj_
            obj_.original_tagname_ = 'debt'
# end class CreditNotation


class CreditNotations(GeneratedsSuper):
    """The credit rating notation higher level construct, which provides
    the ability to specify multiple rating notations."""
    member_data_items_ = {
        'creditNotation': MemberSpec_('creditNotation', 'CreditNotation', 0),
        'condition': MemberSpec_('condition', ['QuantifierEnum', 'Token', 'xsd:token'], 0),
        'creditNotation': MemberSpec_('creditNotation', 'CreditNotation', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, creditNotation=None, condition=None):
        self.original_tagname_ = None
        self.creditNotation = creditNotation
        self.condition = condition
        self.validate_QuantifierEnum(self.condition)
        if creditNotation is None:
            self.creditNotation = []
        else:
            self.creditNotation = creditNotation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditNotations)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditNotations.subclass:
            return CreditNotations.subclass(*args_, **kwargs_)
        else:
            return CreditNotations(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_creditNotation(self): return self.creditNotation
    def set_creditNotation(self, creditNotation): self.creditNotation = creditNotation
    def get_condition(self): return self.condition
    def set_condition(self, condition): self.condition = condition
    def get_creditNotation(self): return self.creditNotation
    def set_creditNotation(self, creditNotation): self.creditNotation = creditNotation
    def add_creditNotation(self, value): self.creditNotation.append(value)
    def insert_creditNotation_at(self, index, value): self.creditNotation.insert(index, value)
    def replace_creditNotation_at(self, index, value): self.creditNotation[index] = value
    def validate_QuantifierEnum(self, value):
        # Validate type QuantifierEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['All', 'Any']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on QuantifierEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on QuantifierEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.creditNotation is not None or
            self.condition is not None or
            self.creditNotation
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditNotations', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditNotations')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditNotations', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditNotations'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CreditNotations', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.creditNotation is not None:
            self.creditNotation.export(outfile, level, namespace_, name_='creditNotation', pretty_print=pretty_print)
        if self.condition is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scondition>%s</%scondition>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.condition), input_name='condition')), namespace_, eol_))
        for creditNotation_ in self.creditNotation:
            creditNotation_.export(outfile, level, namespace_, name_='creditNotation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'creditNotation':
            obj_ = CreditNotation.factory()
            obj_.build(child_)
            self.creditNotation = obj_
            obj_.original_tagname_ = 'creditNotation'
        elif nodeName_ == 'condition':
            condition_ = child_.text
            condition_ = re_.sub(String_cleanup_pat_, " ", condition_).strip()
            condition_ = self.gds_validate_string(condition_, node, 'condition')
            self.condition = condition_
            # validate type QuantifierEnum
            self.validate_QuantifierEnum(self.condition)
        elif nodeName_ == 'creditNotation':
            obj_ = CreditNotation.factory()
            obj_.build(child_)
            self.creditNotation.append(obj_)
            obj_.original_tagname_ = 'creditNotation'
# end class CreditNotations


class CreditRatingAgency(GeneratedsSuper):
    """A type to hold the scheme that specifies the various credit rating
    agencies."""
    member_data_items_ = {
        'creditRatingAgencyScheme': MemberSpec_('creditRatingAgencyScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, creditRatingAgencyScheme='http://www.fpml.org/coding-scheme/credit-rating-agency', valueOf_=None):
        self.original_tagname_ = None
        self.creditRatingAgencyScheme = _cast(None, creditRatingAgencyScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditRatingAgency)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditRatingAgency.subclass:
            return CreditRatingAgency.subclass(*args_, **kwargs_)
        else:
            return CreditRatingAgency(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_creditRatingAgencyScheme(self): return self.creditRatingAgencyScheme
    def set_creditRatingAgencyScheme(self, creditRatingAgencyScheme): self.creditRatingAgencyScheme = creditRatingAgencyScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditRatingAgency', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditRatingAgency')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditRatingAgency', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditRatingAgency'):
        if self.creditRatingAgencyScheme != "http://www.fpml.org/coding-scheme/credit-rating-agency" and 'creditRatingAgencyScheme' not in already_processed:
            already_processed.add('creditRatingAgencyScheme')
            outfile.write(' creditRatingAgencyScheme=%s' % (quote_attrib(self.creditRatingAgencyScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CreditRatingAgency', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('creditRatingAgencyScheme', node)
        if value is not None and 'creditRatingAgencyScheme' not in already_processed:
            already_processed.add('creditRatingAgencyScheme')
            self.creditRatingAgencyScheme = value
            self.validate_NonEmptyURI(self.creditRatingAgencyScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CreditRatingAgency


class CreditRatingDebt(GeneratedsSuper):
    """The credit rating debt type(s) associated with the credit rating
    notation and scale. When several debt types are specified, 'any'
    or 'all' may be applicable."""
    member_data_items_ = {
        'debtType': MemberSpec_('debtType', 'DebtType', 0),
        'condition': MemberSpec_('condition', ['QuantifierEnum', 'Token', 'xsd:token'], 0),
        'debtType': MemberSpec_('debtType', 'DebtType', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, debtType=None, condition=None):
        self.original_tagname_ = None
        self.debtType = debtType
        self.condition = condition
        self.validate_QuantifierEnum(self.condition)
        if debtType is None:
            self.debtType = []
        else:
            self.debtType = debtType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditRatingDebt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditRatingDebt.subclass:
            return CreditRatingDebt.subclass(*args_, **kwargs_)
        else:
            return CreditRatingDebt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_debtType(self): return self.debtType
    def set_debtType(self, debtType): self.debtType = debtType
    def get_condition(self): return self.condition
    def set_condition(self, condition): self.condition = condition
    def get_debtType(self): return self.debtType
    def set_debtType(self, debtType): self.debtType = debtType
    def add_debtType(self, value): self.debtType.append(value)
    def insert_debtType_at(self, index, value): self.debtType.insert(index, value)
    def replace_debtType_at(self, index, value): self.debtType[index] = value
    def validate_QuantifierEnum(self, value):
        # Validate type QuantifierEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['All', 'Any']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on QuantifierEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on QuantifierEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.debtType is not None or
            self.condition is not None or
            self.debtType
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditRatingDebt', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditRatingDebt')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditRatingDebt', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditRatingDebt'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CreditRatingDebt', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.debtType is not None:
            self.debtType.export(outfile, level, namespace_, name_='debtType', pretty_print=pretty_print)
        if self.condition is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scondition>%s</%scondition>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.condition), input_name='condition')), namespace_, eol_))
        for debtType_ in self.debtType:
            debtType_.export(outfile, level, namespace_, name_='debtType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'debtType':
            obj_ = DebtType.factory()
            obj_.build(child_)
            self.debtType = obj_
            obj_.original_tagname_ = 'debtType'
        elif nodeName_ == 'condition':
            condition_ = child_.text
            condition_ = re_.sub(String_cleanup_pat_, " ", condition_).strip()
            condition_ = self.gds_validate_string(condition_, node, 'condition')
            self.condition = condition_
            # validate type QuantifierEnum
            self.validate_QuantifierEnum(self.condition)
        elif nodeName_ == 'debtType':
            obj_ = DebtType.factory()
            obj_.build(child_)
            self.debtType.append(obj_)
            obj_.original_tagname_ = 'debtType'
# end class CreditRatingDebt


class CreditRatingNotation(GeneratedsSuper):
    """A type to hold the credit rating notation scheme. FpML doesn't
    specify that scheme."""
    member_data_items_ = {
        'creditRatingNotationScheme': MemberSpec_('creditRatingNotationScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, creditRatingNotationScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.creditRatingNotationScheme = _cast(None, creditRatingNotationScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditRatingNotation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditRatingNotation.subclass:
            return CreditRatingNotation.subclass(*args_, **kwargs_)
        else:
            return CreditRatingNotation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_creditRatingNotationScheme(self): return self.creditRatingNotationScheme
    def set_creditRatingNotationScheme(self, creditRatingNotationScheme): self.creditRatingNotationScheme = creditRatingNotationScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditRatingNotation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditRatingNotation')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditRatingNotation', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditRatingNotation'):
        if self.creditRatingNotationScheme is not None and 'creditRatingNotationScheme' not in already_processed:
            already_processed.add('creditRatingNotationScheme')
            outfile.write(' creditRatingNotationScheme=%s' % (quote_attrib(self.creditRatingNotationScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CreditRatingNotation', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('creditRatingNotationScheme', node)
        if value is not None and 'creditRatingNotationScheme' not in already_processed:
            already_processed.add('creditRatingNotationScheme')
            self.creditRatingNotationScheme = value
            self.validate_NonEmptyURI(self.creditRatingNotationScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CreditRatingNotation


class CreditRatingScale(GeneratedsSuper):
    """A type to hold the credit rating scale scheme. FpML doesn't specify
    that scheme."""
    member_data_items_ = {
        'creditRatingScaleScheme': MemberSpec_('creditRatingScaleScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, creditRatingScaleScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.creditRatingScaleScheme = _cast(None, creditRatingScaleScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditRatingScale)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditRatingScale.subclass:
            return CreditRatingScale.subclass(*args_, **kwargs_)
        else:
            return CreditRatingScale(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_creditRatingScaleScheme(self): return self.creditRatingScaleScheme
    def set_creditRatingScaleScheme(self, creditRatingScaleScheme): self.creditRatingScaleScheme = creditRatingScaleScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditRatingScale', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditRatingScale')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditRatingScale', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditRatingScale'):
        if self.creditRatingScaleScheme is not None and 'creditRatingScaleScheme' not in already_processed:
            already_processed.add('creditRatingScaleScheme')
            outfile.write(' creditRatingScaleScheme=%s' % (quote_attrib(self.creditRatingScaleScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CreditRatingScale', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('creditRatingScaleScheme', node)
        if value is not None and 'creditRatingScaleScheme' not in already_processed:
            already_processed.add('creditRatingScaleScheme')
            self.creditRatingScaleScheme = value
            self.validate_NonEmptyURI(self.creditRatingScaleScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CreditRatingScale


class CustodianTerms(GeneratedsSuper):
    """The stipulation of the terms under which a custody agent will be
    deemed acceptable by the parties. This construct has been
    initially developed for the purpose of the Standard CSA."""
    member_data_items_ = {
        'minimumAssets': MemberSpec_('minimumAssets', 'Money', 0),
        'minimumRating': MemberSpec_('minimumRating', 'CreditNotations', 0),
        'initialDesignation': MemberSpec_('initialDesignation', ['Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, minimumAssets=None, minimumRating=None, initialDesignation=None):
        self.original_tagname_ = None
        self.minimumAssets = minimumAssets
        self.minimumRating = minimumRating
        self.initialDesignation = initialDesignation
        self.validate_Token(self.initialDesignation)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustodianTerms)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustodianTerms.subclass:
            return CustodianTerms.subclass(*args_, **kwargs_)
        else:
            return CustodianTerms(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_minimumAssets(self): return self.minimumAssets
    def set_minimumAssets(self, minimumAssets): self.minimumAssets = minimumAssets
    def get_minimumRating(self): return self.minimumRating
    def set_minimumRating(self, minimumRating): self.minimumRating = minimumRating
    def get_initialDesignation(self): return self.initialDesignation
    def set_initialDesignation(self, initialDesignation): self.initialDesignation = initialDesignation
    def validate_Token(self, value):
        # Validate type Token, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Token' % {"value" : value} )
    def hasContent_(self):
        if (
            self.minimumAssets is not None or
            self.minimumRating is not None or
            self.initialDesignation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CustodianTerms', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustodianTerms')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CustodianTerms', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CustodianTerms'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CustodianTerms', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.minimumAssets is not None:
            self.minimumAssets.export(outfile, level, namespace_, name_='minimumAssets', pretty_print=pretty_print)
        if self.minimumRating is not None:
            self.minimumRating.export(outfile, level, namespace_, name_='minimumRating', pretty_print=pretty_print)
        if self.initialDesignation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinitialDesignation>%s</%sinitialDesignation>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.initialDesignation), input_name='initialDesignation')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'minimumAssets':
            obj_ = Money.factory()
            obj_.build(child_)
            self.minimumAssets = obj_
            obj_.original_tagname_ = 'minimumAssets'
        elif nodeName_ == 'minimumRating':
            obj_ = CreditNotations.factory()
            obj_.build(child_)
            self.minimumRating = obj_
            obj_.original_tagname_ = 'minimumRating'
        elif nodeName_ == 'initialDesignation':
            initialDesignation_ = child_.text
            initialDesignation_ = re_.sub(String_cleanup_pat_, " ", initialDesignation_).strip()
            initialDesignation_ = self.gds_validate_string(initialDesignation_, node, 'initialDesignation')
            self.initialDesignation = initialDesignation_
            # validate type Token
            self.validate_Token(self.initialDesignation)
# end class CustodianTerms


class DayCount(GeneratedsSuper):
    """The day count used as the denominator for interest accrual
    calculation as specififed in the ISDA Standard CSA. The day
    count applies to all currencies, unless specified."""
    member_data_items_ = {
        'defaultDayCount': MemberSpec_('defaultDayCount', 'DayCountDenominator', 0),
        'currencySpecificDayCount': MemberSpec_('currencySpecificDayCount', 'currencySpecificDayCountType', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, defaultDayCount=None, currencySpecificDayCount=None):
        self.original_tagname_ = None
        self.defaultDayCount = defaultDayCount
        if currencySpecificDayCount is None:
            self.currencySpecificDayCount = []
        else:
            self.currencySpecificDayCount = currencySpecificDayCount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DayCount)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DayCount.subclass:
            return DayCount.subclass(*args_, **kwargs_)
        else:
            return DayCount(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_defaultDayCount(self): return self.defaultDayCount
    def set_defaultDayCount(self, defaultDayCount): self.defaultDayCount = defaultDayCount
    def get_currencySpecificDayCount(self): return self.currencySpecificDayCount
    def set_currencySpecificDayCount(self, currencySpecificDayCount): self.currencySpecificDayCount = currencySpecificDayCount
    def add_currencySpecificDayCount(self, value): self.currencySpecificDayCount.append(value)
    def insert_currencySpecificDayCount_at(self, index, value): self.currencySpecificDayCount.insert(index, value)
    def replace_currencySpecificDayCount_at(self, index, value): self.currencySpecificDayCount[index] = value
    def hasContent_(self):
        if (
            self.defaultDayCount is not None or
            self.currencySpecificDayCount
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DayCount', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DayCount')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DayCount', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DayCount'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DayCount', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.defaultDayCount is not None:
            self.defaultDayCount.export(outfile, level, namespace_, name_='defaultDayCount', pretty_print=pretty_print)
        for currencySpecificDayCount_ in self.currencySpecificDayCount:
            currencySpecificDayCount_.export(outfile, level, namespace_, name_='currencySpecificDayCount', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'defaultDayCount':
            obj_ = DayCountDenominator.factory()
            obj_.build(child_)
            self.defaultDayCount = obj_
            obj_.original_tagname_ = 'defaultDayCount'
        elif nodeName_ == 'currencySpecificDayCount':
            obj_ = currencySpecificDayCountType.factory()
            obj_.build(child_)
            self.currencySpecificDayCount.append(obj_)
            obj_.original_tagname_ = 'currencySpecificDayCount'
# end class DayCount


class DayCountDenominator(GeneratedsSuper):
    """A type to hold the day count scheme, used to specify the denominator
    for accrual calculation to be used as part of the ISDA Standard
    CSA."""
    member_data_items_ = {
        'dayCountScheme': MemberSpec_('dayCountScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, dayCountScheme='http://www.fpml.org/coding-scheme/day-count', valueOf_=None):
        self.original_tagname_ = None
        self.dayCountScheme = _cast(None, dayCountScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DayCountDenominator)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DayCountDenominator.subclass:
            return DayCountDenominator.subclass(*args_, **kwargs_)
        else:
            return DayCountDenominator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dayCountScheme(self): return self.dayCountScheme
    def set_dayCountScheme(self, dayCountScheme): self.dayCountScheme = dayCountScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DayCountDenominator', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DayCountDenominator')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DayCountDenominator', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DayCountDenominator'):
        if self.dayCountScheme != "http://www.fpml.org/coding-scheme/day-count" and 'dayCountScheme' not in already_processed:
            already_processed.add('dayCountScheme')
            outfile.write(' dayCountScheme=%s' % (quote_attrib(self.dayCountScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DayCountDenominator', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dayCountScheme', node)
        if value is not None and 'dayCountScheme' not in already_processed:
            already_processed.add('dayCountScheme')
            self.dayCountScheme = value
            self.validate_NonEmptyURI(self.dayCountScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DayCountDenominator


class DebtType(GeneratedsSuper):
    """A type to hold the debt type scheme. FpML doesn't specify that
    scheme."""
    member_data_items_ = {
        'debtTypeScheme': MemberSpec_('debtTypeScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, debtTypeScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.debtTypeScheme = _cast(None, debtTypeScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DebtType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DebtType.subclass:
            return DebtType.subclass(*args_, **kwargs_)
        else:
            return DebtType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_debtTypeScheme(self): return self.debtTypeScheme
    def set_debtTypeScheme(self, debtTypeScheme): self.debtTypeScheme = debtTypeScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DebtType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DebtType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DebtType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DebtType'):
        if self.debtTypeScheme is not None and 'debtTypeScheme' not in already_processed:
            already_processed.add('debtTypeScheme')
            outfile.write(' debtTypeScheme=%s' % (quote_attrib(self.debtTypeScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DebtType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('debtTypeScheme', node)
        if value is not None and 'debtTypeScheme' not in already_processed:
            already_processed.add('debtTypeScheme')
            self.debtTypeScheme = value
            self.validate_NonEmptyURI(self.debtTypeScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DebtType


class DisputeResolution(GeneratedsSuper):
    """The time by which a dispute needs to be resolved. Initially
    developed for the Standard CSA, in reference to margin call
    disputes."""
    member_data_items_ = {
        'resolutionTime': MemberSpec_('resolutionTime', 'BusinessCenterTime', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, resolutionTime=None):
        self.original_tagname_ = None
        self.resolutionTime = resolutionTime
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DisputeResolution)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DisputeResolution.subclass:
            return DisputeResolution.subclass(*args_, **kwargs_)
        else:
            return DisputeResolution(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_resolutionTime(self): return self.resolutionTime
    def set_resolutionTime(self, resolutionTime): self.resolutionTime = resolutionTime
    def hasContent_(self):
        if (
            self.resolutionTime is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DisputeResolution', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DisputeResolution')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DisputeResolution', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DisputeResolution'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DisputeResolution', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.resolutionTime is not None:
            self.resolutionTime.export(outfile, level, namespace_, name_='resolutionTime', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'resolutionTime':
            obj_ = BusinessCenterTime.factory()
            obj_.build(child_)
            self.resolutionTime = obj_
            obj_.original_tagname_ = 'resolutionTime'
# end class DisputeResolution


class DocumentReference(Reference):
    """A type to hold a reference to a legal document."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(DocumentReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DocumentReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DocumentReference.subclass:
            return DocumentReference.subclass(*args_, **kwargs_)
        else:
            return DocumentReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(DocumentReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DocumentReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DocumentReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DocumentReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DocumentReference'):
        super(DocumentReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DocumentReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DocumentReference', fromsubclass_=False, pretty_print=True):
        super(DocumentReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(DocumentReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DocumentReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DocumentReference


class ElectedTransportCurrency(GeneratedsSuper):
    """A type to hold the transport currency scheme."""
    member_data_items_ = {
        'transportCurrencyScheme': MemberSpec_('transportCurrencyScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, transportCurrencyScheme='http://www.fpml.org/coding-scheme/transport-currency', valueOf_=None):
        self.original_tagname_ = None
        self.transportCurrencyScheme = _cast(None, transportCurrencyScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectedTransportCurrency)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectedTransportCurrency.subclass:
            return ElectedTransportCurrency.subclass(*args_, **kwargs_)
        else:
            return ElectedTransportCurrency(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_transportCurrencyScheme(self): return self.transportCurrencyScheme
    def set_transportCurrencyScheme(self, transportCurrencyScheme): self.transportCurrencyScheme = transportCurrencyScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ElectedTransportCurrency', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectedTransportCurrency')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ElectedTransportCurrency', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ElectedTransportCurrency'):
        if self.transportCurrencyScheme != "http://www.fpml.org/coding-scheme/transport-currency" and 'transportCurrencyScheme' not in already_processed:
            already_processed.add('transportCurrencyScheme')
            outfile.write(' transportCurrencyScheme=%s' % (quote_attrib(self.transportCurrencyScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ElectedTransportCurrency', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('transportCurrencyScheme', node)
        if value is not None and 'transportCurrencyScheme' not in already_processed:
            already_processed.add('transportCurrencyScheme')
            self.transportCurrencyScheme = value
            self.validate_NonEmptyURI(self.transportCurrencyScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ElectedTransportCurrency


class EligibleAsset(GeneratedsSuper):
    """A type to hold the collateral asset definitions scheme."""
    member_data_items_ = {
        'collateralAssetDefinitionsScheme': MemberSpec_('collateralAssetDefinitionsScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, collateralAssetDefinitionsScheme='http://www.fpml.org/coding-scheme/collateral-asset-definitions-scheme', valueOf_=None):
        self.original_tagname_ = None
        self.collateralAssetDefinitionsScheme = _cast(None, collateralAssetDefinitionsScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EligibleAsset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EligibleAsset.subclass:
            return EligibleAsset.subclass(*args_, **kwargs_)
        else:
            return EligibleAsset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_collateralAssetDefinitionsScheme(self): return self.collateralAssetDefinitionsScheme
    def set_collateralAssetDefinitionsScheme(self, collateralAssetDefinitionsScheme): self.collateralAssetDefinitionsScheme = collateralAssetDefinitionsScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EligibleAsset', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EligibleAsset')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EligibleAsset', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EligibleAsset'):
        if self.collateralAssetDefinitionsScheme != "http://www.fpml.org/coding-scheme/collateral-asset-definitions-scheme" and 'collateralAssetDefinitionsScheme' not in already_processed:
            already_processed.add('collateralAssetDefinitionsScheme')
            outfile.write(' collateralAssetDefinitionsScheme=%s' % (quote_attrib(self.collateralAssetDefinitionsScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EligibleAsset', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('collateralAssetDefinitionsScheme', node)
        if value is not None and 'collateralAssetDefinitionsScheme' not in already_processed:
            already_processed.add('collateralAssetDefinitionsScheme')
            self.collateralAssetDefinitionsScheme = value
            self.validate_NonEmptyURI(self.collateralAssetDefinitionsScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EligibleAsset


class EligibleCollateral(GeneratedsSuper):
    """The collateral eligibility as a function of the types of asset, the
    maturity and rating terms."""
    member_data_items_ = {
        'eligibleAsset': MemberSpec_('eligibleAsset', 'EligibleAsset', 0),
        'lowerMaturity': MemberSpec_('lowerMaturity', 'Period', 0),
        'higherMaturity': MemberSpec_('higherMaturity', 'Period', 0),
        'minimumRating': MemberSpec_('minimumRating', 'CreditNotations', 0),
        'valuationPercentage': MemberSpec_('valuationPercentage', ['RestrictedPercentage', 'xsd:decimal'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, eligibleAsset=None, lowerMaturity=None, higherMaturity=None, minimumRating=None, valuationPercentage=None):
        self.original_tagname_ = None
        self.eligibleAsset = eligibleAsset
        self.lowerMaturity = lowerMaturity
        self.higherMaturity = higherMaturity
        self.minimumRating = minimumRating
        self.valuationPercentage = valuationPercentage
        self.validate_RestrictedPercentage(self.valuationPercentage)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EligibleCollateral)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EligibleCollateral.subclass:
            return EligibleCollateral.subclass(*args_, **kwargs_)
        else:
            return EligibleCollateral(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_eligibleAsset(self): return self.eligibleAsset
    def set_eligibleAsset(self, eligibleAsset): self.eligibleAsset = eligibleAsset
    def get_lowerMaturity(self): return self.lowerMaturity
    def set_lowerMaturity(self, lowerMaturity): self.lowerMaturity = lowerMaturity
    def get_higherMaturity(self): return self.higherMaturity
    def set_higherMaturity(self, higherMaturity): self.higherMaturity = higherMaturity
    def get_minimumRating(self): return self.minimumRating
    def set_minimumRating(self, minimumRating): self.minimumRating = minimumRating
    def get_valuationPercentage(self): return self.valuationPercentage
    def set_valuationPercentage(self, valuationPercentage): self.valuationPercentage = valuationPercentage
    def validate_RestrictedPercentage(self, value):
        # Validate type RestrictedPercentage, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on RestrictedPercentage' % {"value" : value} )
            if value > 1:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on RestrictedPercentage' % {"value" : value} )
    def hasContent_(self):
        if (
            self.eligibleAsset is not None or
            self.lowerMaturity is not None or
            self.higherMaturity is not None or
            self.minimumRating is not None or
            self.valuationPercentage is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EligibleCollateral', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EligibleCollateral')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EligibleCollateral', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EligibleCollateral'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EligibleCollateral', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.eligibleAsset is not None:
            self.eligibleAsset.export(outfile, level, namespace_, name_='eligibleAsset', pretty_print=pretty_print)
        if self.lowerMaturity is not None:
            self.lowerMaturity.export(outfile, level, namespace_, name_='lowerMaturity', pretty_print=pretty_print)
        if self.higherMaturity is not None:
            self.higherMaturity.export(outfile, level, namespace_, name_='higherMaturity', pretty_print=pretty_print)
        if self.minimumRating is not None:
            self.minimumRating.export(outfile, level, namespace_, name_='minimumRating', pretty_print=pretty_print)
        if self.valuationPercentage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svaluationPercentage>%s</%svaluationPercentage>%s' % (namespace_, self.gds_format_float(self.valuationPercentage, input_name='valuationPercentage'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'eligibleAsset':
            obj_ = EligibleAsset.factory()
            obj_.build(child_)
            self.eligibleAsset = obj_
            obj_.original_tagname_ = 'eligibleAsset'
        elif nodeName_ == 'lowerMaturity':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.lowerMaturity = obj_
            obj_.original_tagname_ = 'lowerMaturity'
        elif nodeName_ == 'higherMaturity':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.higherMaturity = obj_
            obj_.original_tagname_ = 'higherMaturity'
        elif nodeName_ == 'minimumRating':
            obj_ = CreditNotations.factory()
            obj_.build(child_)
            self.minimumRating = obj_
            obj_.original_tagname_ = 'minimumRating'
        elif nodeName_ == 'valuationPercentage':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'valuationPercentage')
            self.valuationPercentage = fval_
            # validate type RestrictedPercentage
            self.validate_RestrictedPercentage(self.valuationPercentage)
# end class EligibleCollateral


class EligibilityToHoldCollateral(GeneratedsSuper):
    """The conditions under which a party and its custodians are entitled
    to hold collateral."""
    member_data_items_ = {
        'holdingPostedCollateral': MemberSpec_('holdingPostedCollateral', 'HoldingPostedCollateral', 1),
        'custodianTerms': MemberSpec_('custodianTerms', 'CustodianTerms', 0),
        'eligibleCountry': MemberSpec_('eligibleCountry', 'Country', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, holdingPostedCollateral=None, custodianTerms=None, eligibleCountry=None):
        self.original_tagname_ = None
        if holdingPostedCollateral is None:
            self.holdingPostedCollateral = []
        else:
            self.holdingPostedCollateral = holdingPostedCollateral
        self.custodianTerms = custodianTerms
        if eligibleCountry is None:
            self.eligibleCountry = []
        else:
            self.eligibleCountry = eligibleCountry
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EligibilityToHoldCollateral)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EligibilityToHoldCollateral.subclass:
            return EligibilityToHoldCollateral.subclass(*args_, **kwargs_)
        else:
            return EligibilityToHoldCollateral(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_holdingPostedCollateral(self): return self.holdingPostedCollateral
    def set_holdingPostedCollateral(self, holdingPostedCollateral): self.holdingPostedCollateral = holdingPostedCollateral
    def add_holdingPostedCollateral(self, value): self.holdingPostedCollateral.append(value)
    def insert_holdingPostedCollateral_at(self, index, value): self.holdingPostedCollateral.insert(index, value)
    def replace_holdingPostedCollateral_at(self, index, value): self.holdingPostedCollateral[index] = value
    def get_custodianTerms(self): return self.custodianTerms
    def set_custodianTerms(self, custodianTerms): self.custodianTerms = custodianTerms
    def get_eligibleCountry(self): return self.eligibleCountry
    def set_eligibleCountry(self, eligibleCountry): self.eligibleCountry = eligibleCountry
    def add_eligibleCountry(self, value): self.eligibleCountry.append(value)
    def insert_eligibleCountry_at(self, index, value): self.eligibleCountry.insert(index, value)
    def replace_eligibleCountry_at(self, index, value): self.eligibleCountry[index] = value
    def hasContent_(self):
        if (
            self.holdingPostedCollateral or
            self.custodianTerms is not None or
            self.eligibleCountry
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EligibilityToHoldCollateral', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EligibilityToHoldCollateral')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EligibilityToHoldCollateral', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EligibilityToHoldCollateral'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EligibilityToHoldCollateral', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for holdingPostedCollateral_ in self.holdingPostedCollateral:
            holdingPostedCollateral_.export(outfile, level, namespace_, name_='holdingPostedCollateral', pretty_print=pretty_print)
        if self.custodianTerms is not None:
            self.custodianTerms.export(outfile, level, namespace_, name_='custodianTerms', pretty_print=pretty_print)
        for eligibleCountry_ in self.eligibleCountry:
            eligibleCountry_.export(outfile, level, namespace_, name_='eligibleCountry', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'holdingPostedCollateral':
            obj_ = HoldingPostedCollateral.factory()
            obj_.build(child_)
            self.holdingPostedCollateral.append(obj_)
            obj_.original_tagname_ = 'holdingPostedCollateral'
        elif nodeName_ == 'custodianTerms':
            obj_ = CustodianTerms.factory()
            obj_.build(child_)
            self.custodianTerms = obj_
            obj_.original_tagname_ = 'custodianTerms'
        elif nodeName_ == 'eligibleCountry':
            obj_ = Country.factory()
            obj_.build(child_)
            self.eligibleCountry.append(obj_)
            obj_.original_tagname_ = 'eligibleCountry'
# end class EligibilityToHoldCollateral


class ExchangeDate(GeneratedsSuper):
    """A type to hold the exchange date scheme."""
    member_data_items_ = {
        'exchangeDateScheme': MemberSpec_('exchangeDateScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, exchangeDateScheme='http://www.fpml.org/coding-scheme/exchange-date', valueOf_=None):
        self.original_tagname_ = None
        self.exchangeDateScheme = _cast(None, exchangeDateScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExchangeDate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExchangeDate.subclass:
            return ExchangeDate.subclass(*args_, **kwargs_)
        else:
            return ExchangeDate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_exchangeDateScheme(self): return self.exchangeDateScheme
    def set_exchangeDateScheme(self, exchangeDateScheme): self.exchangeDateScheme = exchangeDateScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExchangeDate', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExchangeDate')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExchangeDate', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExchangeDate'):
        if self.exchangeDateScheme != "http://www.fpml.org/coding-scheme/exchange-date" and 'exchangeDateScheme' not in already_processed:
            already_processed.add('exchangeDateScheme')
            outfile.write(' exchangeDateScheme=%s' % (quote_attrib(self.exchangeDateScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ExchangeDate', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('exchangeDateScheme', node)
        if value is not None and 'exchangeDateScheme' not in already_processed:
            already_processed.add('exchangeDateScheme')
            self.exchangeDateScheme = value
            self.validate_NonEmptyURI(self.exchangeDateScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ExchangeDate


class ExistingCreditSupportAnnex(GeneratedsSuper):
    """The reference to the existing Credit Support Annex (CSA). Used as
    part of the Standard CSA document."""
    member_data_items_ = {
        'agreementDate': MemberSpec_('agreementDate', 'xsd:date', 0),
        'documentType': MemberSpec_('documentType', 'LegalDocumentType', 0),
        'partyDocumentIdentifier': MemberSpec_('partyDocumentIdentifier', 'PartyDocumentIdentifier', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, agreementDate=None, documentType=None, partyDocumentIdentifier=None):
        self.original_tagname_ = None
        if isinstance(agreementDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(agreementDate, '%Y-%m-%d').date()
        else:
            initvalue_ = agreementDate
        self.agreementDate = initvalue_
        self.documentType = documentType
        if partyDocumentIdentifier is None:
            self.partyDocumentIdentifier = []
        else:
            self.partyDocumentIdentifier = partyDocumentIdentifier
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExistingCreditSupportAnnex)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExistingCreditSupportAnnex.subclass:
            return ExistingCreditSupportAnnex.subclass(*args_, **kwargs_)
        else:
            return ExistingCreditSupportAnnex(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_agreementDate(self): return self.agreementDate
    def set_agreementDate(self, agreementDate): self.agreementDate = agreementDate
    def get_documentType(self): return self.documentType
    def set_documentType(self, documentType): self.documentType = documentType
    def get_partyDocumentIdentifier(self): return self.partyDocumentIdentifier
    def set_partyDocumentIdentifier(self, partyDocumentIdentifier): self.partyDocumentIdentifier = partyDocumentIdentifier
    def add_partyDocumentIdentifier(self, value): self.partyDocumentIdentifier.append(value)
    def insert_partyDocumentIdentifier_at(self, index, value): self.partyDocumentIdentifier.insert(index, value)
    def replace_partyDocumentIdentifier_at(self, index, value): self.partyDocumentIdentifier[index] = value
    def hasContent_(self):
        if (
            self.agreementDate is not None or
            self.documentType is not None or
            self.partyDocumentIdentifier
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExistingCreditSupportAnnex', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExistingCreditSupportAnnex')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExistingCreditSupportAnnex', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExistingCreditSupportAnnex'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ExistingCreditSupportAnnex', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.agreementDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sagreementDate>%s</%sagreementDate>%s' % (namespace_, self.gds_format_date(self.agreementDate, input_name='agreementDate'), namespace_, eol_))
        if self.documentType is not None:
            self.documentType.export(outfile, level, namespace_, name_='documentType', pretty_print=pretty_print)
        for partyDocumentIdentifier_ in self.partyDocumentIdentifier:
            partyDocumentIdentifier_.export(outfile, level, namespace_, name_='partyDocumentIdentifier', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'agreementDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.agreementDate = dval_
        elif nodeName_ == 'documentType':
            obj_ = LegalDocumentType.factory()
            obj_.build(child_)
            self.documentType = obj_
            obj_.original_tagname_ = 'documentType'
        elif nodeName_ == 'partyDocumentIdentifier':
            obj_ = PartyDocumentIdentifier.factory()
            obj_.build(child_)
            self.partyDocumentIdentifier.append(obj_)
            obj_.original_tagname_ = 'partyDocumentIdentifier'
# end class ExistingCreditSupportAnnex


class HoldingAndUsingPostedCollateral(GeneratedsSuper):
    """The provisions related to the holding and usage of posted
    collateral."""
    member_data_items_ = {
        'partyReference': MemberSpec_('partyReference', 'PartyReference', 0),
        'eligibilityToHoldCollateral': MemberSpec_('eligibilityToHoldCollateral', 'EligibilityToHoldCollateral', 0),
        'useOfPostedCollateral': MemberSpec_('useOfPostedCollateral', 'xsd:boolean', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, partyReference=None, eligibilityToHoldCollateral=None, useOfPostedCollateral=None):
        self.original_tagname_ = None
        self.partyReference = partyReference
        self.eligibilityToHoldCollateral = eligibilityToHoldCollateral
        self.useOfPostedCollateral = useOfPostedCollateral
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HoldingAndUsingPostedCollateral)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HoldingAndUsingPostedCollateral.subclass:
            return HoldingAndUsingPostedCollateral.subclass(*args_, **kwargs_)
        else:
            return HoldingAndUsingPostedCollateral(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyReference(self): return self.partyReference
    def set_partyReference(self, partyReference): self.partyReference = partyReference
    def get_eligibilityToHoldCollateral(self): return self.eligibilityToHoldCollateral
    def set_eligibilityToHoldCollateral(self, eligibilityToHoldCollateral): self.eligibilityToHoldCollateral = eligibilityToHoldCollateral
    def get_useOfPostedCollateral(self): return self.useOfPostedCollateral
    def set_useOfPostedCollateral(self, useOfPostedCollateral): self.useOfPostedCollateral = useOfPostedCollateral
    def hasContent_(self):
        if (
            self.partyReference is not None or
            self.eligibilityToHoldCollateral is not None or
            self.useOfPostedCollateral is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='HoldingAndUsingPostedCollateral', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HoldingAndUsingPostedCollateral')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='HoldingAndUsingPostedCollateral', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='HoldingAndUsingPostedCollateral'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='HoldingAndUsingPostedCollateral', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.partyReference is not None:
            self.partyReference.export(outfile, level, namespace_, name_='partyReference', pretty_print=pretty_print)
        if self.eligibilityToHoldCollateral is not None:
            self.eligibilityToHoldCollateral.export(outfile, level, namespace_, name_='eligibilityToHoldCollateral', pretty_print=pretty_print)
        if self.useOfPostedCollateral is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suseOfPostedCollateral>%s</%suseOfPostedCollateral>%s' % (namespace_, self.gds_format_boolean(self.useOfPostedCollateral, input_name='useOfPostedCollateral'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'partyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.partyReference = obj_
            obj_.original_tagname_ = 'partyReference'
        elif nodeName_ == 'eligibilityToHoldCollateral':
            obj_ = EligibilityToHoldCollateral.factory()
            obj_.build(child_)
            self.eligibilityToHoldCollateral = obj_
            obj_.original_tagname_ = 'eligibilityToHoldCollateral'
        elif nodeName_ == 'useOfPostedCollateral':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'useOfPostedCollateral')
            self.useOfPostedCollateral = ival_
# end class HoldingAndUsingPostedCollateral


class HoldingPostedCollateral(GeneratedsSuper):
    """A type to hold the holding posted collateral scheme."""
    member_data_items_ = {
        'holdingPostedCollateralScheme': MemberSpec_('holdingPostedCollateralScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, holdingPostedCollateralScheme='http://www.fpml.org/coding-scheme/holding-posted-collateral', valueOf_=None):
        self.original_tagname_ = None
        self.holdingPostedCollateralScheme = _cast(None, holdingPostedCollateralScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HoldingPostedCollateral)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HoldingPostedCollateral.subclass:
            return HoldingPostedCollateral.subclass(*args_, **kwargs_)
        else:
            return HoldingPostedCollateral(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_holdingPostedCollateralScheme(self): return self.holdingPostedCollateralScheme
    def set_holdingPostedCollateralScheme(self, holdingPostedCollateralScheme): self.holdingPostedCollateralScheme = holdingPostedCollateralScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='HoldingPostedCollateral', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HoldingPostedCollateral')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='HoldingPostedCollateral', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='HoldingPostedCollateral'):
        if self.holdingPostedCollateralScheme != "http://www.fpml.org/coding-scheme/holding-posted-collateral" and 'holdingPostedCollateralScheme' not in already_processed:
            already_processed.add('holdingPostedCollateralScheme')
            outfile.write(' holdingPostedCollateralScheme=%s' % (quote_attrib(self.holdingPostedCollateralScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='HoldingPostedCollateral', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('holdingPostedCollateralScheme', node)
        if value is not None and 'holdingPostedCollateralScheme' not in already_processed:
            already_processed.add('holdingPostedCollateralScheme')
            self.holdingPostedCollateralScheme = value
            self.validate_NonEmptyURI(self.holdingPostedCollateralScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HoldingPostedCollateral


class IndependentAmountDetermination(GeneratedsSuper):
    """A type to hold the independent amount determination scheme."""
    member_data_items_ = {
        'independentAmountDeterminationScheme': MemberSpec_('independentAmountDeterminationScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, independentAmountDeterminationScheme='http://www.fpml.org/coding-scheme/independent-amount-determination', valueOf_=None):
        self.original_tagname_ = None
        self.independentAmountDeterminationScheme = _cast(None, independentAmountDeterminationScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IndependentAmountDetermination)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IndependentAmountDetermination.subclass:
            return IndependentAmountDetermination.subclass(*args_, **kwargs_)
        else:
            return IndependentAmountDetermination(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_independentAmountDeterminationScheme(self): return self.independentAmountDeterminationScheme
    def set_independentAmountDeterminationScheme(self, independentAmountDeterminationScheme): self.independentAmountDeterminationScheme = independentAmountDeterminationScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IndependentAmountDetermination', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IndependentAmountDetermination')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IndependentAmountDetermination', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IndependentAmountDetermination'):
        if self.independentAmountDeterminationScheme != "http://www.fpml.org/coding-scheme/independent-amount-determination" and 'independentAmountDeterminationScheme' not in already_processed:
            already_processed.add('independentAmountDeterminationScheme')
            outfile.write(' independentAmountDeterminationScheme=%s' % (quote_attrib(self.independentAmountDeterminationScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IndependentAmountDetermination', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('independentAmountDeterminationScheme', node)
        if value is not None and 'independentAmountDeterminationScheme' not in already_processed:
            already_processed.add('independentAmountDeterminationScheme')
            self.independentAmountDeterminationScheme = value
            self.validate_NonEmptyURI(self.independentAmountDeterminationScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IndependentAmountDetermination


class IndependentAmountEligibility(GeneratedsSuper):
    """A type to hold the independent amount eligibility scheme."""
    member_data_items_ = {
        'independentAmountEligibilityScheme': MemberSpec_('independentAmountEligibilityScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, independentAmountEligibilityScheme='http://www.fpml.org/coding-scheme/independent-amount-eligibility', valueOf_=None):
        self.original_tagname_ = None
        self.independentAmountEligibilityScheme = _cast(None, independentAmountEligibilityScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IndependentAmountEligibility)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IndependentAmountEligibility.subclass:
            return IndependentAmountEligibility.subclass(*args_, **kwargs_)
        else:
            return IndependentAmountEligibility(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_independentAmountEligibilityScheme(self): return self.independentAmountEligibilityScheme
    def set_independentAmountEligibilityScheme(self, independentAmountEligibilityScheme): self.independentAmountEligibilityScheme = independentAmountEligibilityScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IndependentAmountEligibility', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IndependentAmountEligibility')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IndependentAmountEligibility', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IndependentAmountEligibility'):
        if self.independentAmountEligibilityScheme != "http://www.fpml.org/coding-scheme/independent-amount-eligibility" and 'independentAmountEligibilityScheme' not in already_processed:
            already_processed.add('independentAmountEligibilityScheme')
            outfile.write(' independentAmountEligibilityScheme=%s' % (quote_attrib(self.independentAmountEligibilityScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IndependentAmountEligibility', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('independentAmountEligibilityScheme', node)
        if value is not None and 'independentAmountEligibilityScheme' not in already_processed:
            already_processed.add('independentAmountEligibilityScheme')
            self.independentAmountEligibilityScheme = value
            self.validate_NonEmptyURI(self.independentAmountEligibilityScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IndependentAmountEligibility


class IndependentAmountEligibleCollateral(GeneratedsSuper):
    """A type to specify the eligible collateral."""
    member_data_items_ = {
        'partyReference': MemberSpec_('partyReference', 'PartyReference', 0),
        'eligibleCollateral': MemberSpec_('eligibleCollateral', 'EligibleCollateral', 1),
        'independentAmountEligibility': MemberSpec_('independentAmountEligibility', 'IndependentAmountEligibility', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, partyReference=None, eligibleCollateral=None, independentAmountEligibility=None):
        self.original_tagname_ = None
        self.partyReference = partyReference
        if eligibleCollateral is None:
            self.eligibleCollateral = []
        else:
            self.eligibleCollateral = eligibleCollateral
        self.independentAmountEligibility = independentAmountEligibility
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IndependentAmountEligibleCollateral)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IndependentAmountEligibleCollateral.subclass:
            return IndependentAmountEligibleCollateral.subclass(*args_, **kwargs_)
        else:
            return IndependentAmountEligibleCollateral(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyReference(self): return self.partyReference
    def set_partyReference(self, partyReference): self.partyReference = partyReference
    def get_eligibleCollateral(self): return self.eligibleCollateral
    def set_eligibleCollateral(self, eligibleCollateral): self.eligibleCollateral = eligibleCollateral
    def add_eligibleCollateral(self, value): self.eligibleCollateral.append(value)
    def insert_eligibleCollateral_at(self, index, value): self.eligibleCollateral.insert(index, value)
    def replace_eligibleCollateral_at(self, index, value): self.eligibleCollateral[index] = value
    def get_independentAmountEligibility(self): return self.independentAmountEligibility
    def set_independentAmountEligibility(self, independentAmountEligibility): self.independentAmountEligibility = independentAmountEligibility
    def hasContent_(self):
        if (
            self.partyReference is not None or
            self.eligibleCollateral or
            self.independentAmountEligibility is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IndependentAmountEligibleCollateral', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IndependentAmountEligibleCollateral')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IndependentAmountEligibleCollateral', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IndependentAmountEligibleCollateral'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IndependentAmountEligibleCollateral', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.partyReference is not None:
            self.partyReference.export(outfile, level, namespace_, name_='partyReference', pretty_print=pretty_print)
        for eligibleCollateral_ in self.eligibleCollateral:
            eligibleCollateral_.export(outfile, level, namespace_, name_='eligibleCollateral', pretty_print=pretty_print)
        if self.independentAmountEligibility is not None:
            self.independentAmountEligibility.export(outfile, level, namespace_, name_='independentAmountEligibility', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'partyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.partyReference = obj_
            obj_.original_tagname_ = 'partyReference'
        elif nodeName_ == 'eligibleCollateral':
            obj_ = EligibleCollateral.factory()
            obj_.build(child_)
            self.eligibleCollateral.append(obj_)
            obj_.original_tagname_ = 'eligibleCollateral'
        elif nodeName_ == 'independentAmountEligibility':
            obj_ = IndependentAmountEligibility.factory()
            obj_.build(child_)
            self.independentAmountEligibility = obj_
            obj_.original_tagname_ = 'independentAmountEligibility'
# end class IndependentAmountEligibleCollateral


class IndependentAmountInterestRate(GeneratedsSuper):
    """A type to specify the interest terms applicable to a margin terms
    agreement. Initially developed for the Standard CSA, but
    applicable in concept to other agreements."""
    member_data_items_ = {
        'initialMarginInterestRateTerms': MemberSpec_('initialMarginInterestRateTerms', 'InitialMarginInterestRateTerms', 0),
        'specifiedRate': MemberSpec_('specifiedRate', 'SpecifiedRate', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, initialMarginInterestRateTerms=None, specifiedRate=None):
        self.original_tagname_ = None
        self.initialMarginInterestRateTerms = initialMarginInterestRateTerms
        if specifiedRate is None:
            self.specifiedRate = []
        else:
            self.specifiedRate = specifiedRate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IndependentAmountInterestRate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IndependentAmountInterestRate.subclass:
            return IndependentAmountInterestRate.subclass(*args_, **kwargs_)
        else:
            return IndependentAmountInterestRate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_initialMarginInterestRateTerms(self): return self.initialMarginInterestRateTerms
    def set_initialMarginInterestRateTerms(self, initialMarginInterestRateTerms): self.initialMarginInterestRateTerms = initialMarginInterestRateTerms
    def get_specifiedRate(self): return self.specifiedRate
    def set_specifiedRate(self, specifiedRate): self.specifiedRate = specifiedRate
    def add_specifiedRate(self, value): self.specifiedRate.append(value)
    def insert_specifiedRate_at(self, index, value): self.specifiedRate.insert(index, value)
    def replace_specifiedRate_at(self, index, value): self.specifiedRate[index] = value
    def hasContent_(self):
        if (
            self.initialMarginInterestRateTerms is not None or
            self.specifiedRate
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IndependentAmountInterestRate', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IndependentAmountInterestRate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IndependentAmountInterestRate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IndependentAmountInterestRate'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IndependentAmountInterestRate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.initialMarginInterestRateTerms is not None:
            self.initialMarginInterestRateTerms.export(outfile, level, namespace_, name_='initialMarginInterestRateTerms', pretty_print=pretty_print)
        for specifiedRate_ in self.specifiedRate:
            specifiedRate_.export(outfile, level, namespace_, name_='specifiedRate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'initialMarginInterestRateTerms':
            obj_ = InitialMarginInterestRateTerms.factory()
            obj_.build(child_)
            self.initialMarginInterestRateTerms = obj_
            obj_.original_tagname_ = 'initialMarginInterestRateTerms'
        elif nodeName_ == 'specifiedRate':
            obj_ = SpecifiedRate.factory()
            obj_.build(child_)
            self.specifiedRate.append(obj_)
            obj_.original_tagname_ = 'specifiedRate'
# end class IndependentAmountInterestRate


class IndependentAmounts(GeneratedsSuper):
    """A type to specify how the independent amount (a.k.a. initial margin
    collateral) is determined."""
    member_data_items_ = {
        'partyReference': MemberSpec_('partyReference', 'PartyReference', 0),
        'independentAmountDetermination': MemberSpec_('independentAmountDetermination', 'IndependentAmountDetermination', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, partyReference=None, independentAmountDetermination=None):
        self.original_tagname_ = None
        self.partyReference = partyReference
        self.independentAmountDetermination = independentAmountDetermination
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IndependentAmounts)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IndependentAmounts.subclass:
            return IndependentAmounts.subclass(*args_, **kwargs_)
        else:
            return IndependentAmounts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyReference(self): return self.partyReference
    def set_partyReference(self, partyReference): self.partyReference = partyReference
    def get_independentAmountDetermination(self): return self.independentAmountDetermination
    def set_independentAmountDetermination(self, independentAmountDetermination): self.independentAmountDetermination = independentAmountDetermination
    def hasContent_(self):
        if (
            self.partyReference is not None or
            self.independentAmountDetermination is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IndependentAmounts', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IndependentAmounts')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IndependentAmounts', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IndependentAmounts'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IndependentAmounts', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.partyReference is not None:
            self.partyReference.export(outfile, level, namespace_, name_='partyReference', pretty_print=pretty_print)
        if self.independentAmountDetermination is not None:
            self.independentAmountDetermination.export(outfile, level, namespace_, name_='independentAmountDetermination', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'partyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.partyReference = obj_
            obj_.original_tagname_ = 'partyReference'
        elif nodeName_ == 'independentAmountDetermination':
            obj_ = IndependentAmountDetermination.factory()
            obj_.build(child_)
            self.independentAmountDetermination = obj_
            obj_.original_tagname_ = 'independentAmountDetermination'
# end class IndependentAmounts


class InitialMarginInterestRateTerms(GeneratedsSuper):
    """A type to hold the initial margin interest rate terms scheme."""
    member_data_items_ = {
        'initialMarginInterestRateTermsScheme': MemberSpec_('initialMarginInterestRateTermsScheme', 'xsd:string', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, initialMarginInterestRateTermsScheme='http://www.fpml.org/coding-scheme/initial-margin-interest-rate-terms', valueOf_=None):
        self.original_tagname_ = None
        self.initialMarginInterestRateTermsScheme = _cast(None, initialMarginInterestRateTermsScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InitialMarginInterestRateTerms)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InitialMarginInterestRateTerms.subclass:
            return InitialMarginInterestRateTerms.subclass(*args_, **kwargs_)
        else:
            return InitialMarginInterestRateTerms(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_initialMarginInterestRateTermsScheme(self): return self.initialMarginInterestRateTermsScheme
    def set_initialMarginInterestRateTermsScheme(self, initialMarginInterestRateTermsScheme): self.initialMarginInterestRateTermsScheme = initialMarginInterestRateTermsScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InitialMarginInterestRateTerms', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InitialMarginInterestRateTerms')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InitialMarginInterestRateTerms', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InitialMarginInterestRateTerms'):
        if self.initialMarginInterestRateTermsScheme != "http://www.fpml.org/coding-scheme/initial-margin-interest-rate-terms" and 'initialMarginInterestRateTermsScheme' not in already_processed:
            already_processed.add('initialMarginInterestRateTermsScheme')
            outfile.write(' initialMarginInterestRateTermsScheme=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.initialMarginInterestRateTermsScheme), input_name='initialMarginInterestRateTermsScheme')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='InitialMarginInterestRateTerms', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('initialMarginInterestRateTermsScheme', node)
        if value is not None and 'initialMarginInterestRateTermsScheme' not in already_processed:
            already_processed.add('initialMarginInterestRateTermsScheme')
            self.initialMarginInterestRateTermsScheme = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class InitialMarginInterestRateTerms


class LegalDocumentAdmendment(GeneratedsSuper):
    """A legal document admendment, which can be specified by either
    referencing a legal document that is described elsewhere in the
    XML file, or by specifying the identity of that amended
    document."""
    member_data_items_ = {
        'agreementDate': MemberSpec_('agreementDate', 'xsd:date', 0),
        'partyDocumentIdentifier': MemberSpec_('partyDocumentIdentifier', 'PartyDocumentIdentifier', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, agreementDate=None, partyDocumentIdentifier=None):
        self.original_tagname_ = None
        if isinstance(agreementDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(agreementDate, '%Y-%m-%d').date()
        else:
            initvalue_ = agreementDate
        self.agreementDate = initvalue_
        if partyDocumentIdentifier is None:
            self.partyDocumentIdentifier = []
        else:
            self.partyDocumentIdentifier = partyDocumentIdentifier
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LegalDocumentAdmendment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LegalDocumentAdmendment.subclass:
            return LegalDocumentAdmendment.subclass(*args_, **kwargs_)
        else:
            return LegalDocumentAdmendment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_agreementDate(self): return self.agreementDate
    def set_agreementDate(self, agreementDate): self.agreementDate = agreementDate
    def get_partyDocumentIdentifier(self): return self.partyDocumentIdentifier
    def set_partyDocumentIdentifier(self, partyDocumentIdentifier): self.partyDocumentIdentifier = partyDocumentIdentifier
    def add_partyDocumentIdentifier(self, value): self.partyDocumentIdentifier.append(value)
    def insert_partyDocumentIdentifier_at(self, index, value): self.partyDocumentIdentifier.insert(index, value)
    def replace_partyDocumentIdentifier_at(self, index, value): self.partyDocumentIdentifier[index] = value
    def hasContent_(self):
        if (
            self.agreementDate is not None or
            self.partyDocumentIdentifier
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LegalDocumentAdmendment', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LegalDocumentAdmendment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LegalDocumentAdmendment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LegalDocumentAdmendment'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LegalDocumentAdmendment', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.agreementDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sagreementDate>%s</%sagreementDate>%s' % (namespace_, self.gds_format_date(self.agreementDate, input_name='agreementDate'), namespace_, eol_))
        for partyDocumentIdentifier_ in self.partyDocumentIdentifier:
            partyDocumentIdentifier_.export(outfile, level, namespace_, name_='partyDocumentIdentifier', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'agreementDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.agreementDate = dval_
        elif nodeName_ == 'partyDocumentIdentifier':
            obj_ = PartyDocumentIdentifier.factory()
            obj_.build(child_)
            self.partyDocumentIdentifier.append(obj_)
            obj_.original_tagname_ = 'partyDocumentIdentifier'
# end class LegalDocumentAdmendment


class LegalDocumentHeader(GeneratedsSuper):
    """The legal document header."""
    member_data_items_ = {
        'partyRoles': MemberSpec_('partyRoles', 'PartyRoles', 0),
        'agreementDate': MemberSpec_('agreementDate', 'xsd:date', 0),
        'effectiveDate': MemberSpec_('effectiveDate', 'xsd:date', 0),
        'partyDocumentIdentifier': MemberSpec_('partyDocumentIdentifier', 'PartyDocumentIdentifier', 1),
        'amendedDocument': MemberSpec_('amendedDocument', 'DocumentReference', 0),
        'documentHistory': MemberSpec_('documentHistory', 'LegalDocumentHistory', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, partyRoles=None, agreementDate=None, effectiveDate=None, partyDocumentIdentifier=None, amendedDocument=None, documentHistory=None):
        self.original_tagname_ = None
        self.partyRoles = partyRoles
        if isinstance(agreementDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(agreementDate, '%Y-%m-%d').date()
        else:
            initvalue_ = agreementDate
        self.agreementDate = initvalue_
        if isinstance(effectiveDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(effectiveDate, '%Y-%m-%d').date()
        else:
            initvalue_ = effectiveDate
        self.effectiveDate = initvalue_
        if partyDocumentIdentifier is None:
            self.partyDocumentIdentifier = []
        else:
            self.partyDocumentIdentifier = partyDocumentIdentifier
        self.amendedDocument = amendedDocument
        self.documentHistory = documentHistory
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LegalDocumentHeader)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LegalDocumentHeader.subclass:
            return LegalDocumentHeader.subclass(*args_, **kwargs_)
        else:
            return LegalDocumentHeader(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyRoles(self): return self.partyRoles
    def set_partyRoles(self, partyRoles): self.partyRoles = partyRoles
    def get_agreementDate(self): return self.agreementDate
    def set_agreementDate(self, agreementDate): self.agreementDate = agreementDate
    def get_effectiveDate(self): return self.effectiveDate
    def set_effectiveDate(self, effectiveDate): self.effectiveDate = effectiveDate
    def get_partyDocumentIdentifier(self): return self.partyDocumentIdentifier
    def set_partyDocumentIdentifier(self, partyDocumentIdentifier): self.partyDocumentIdentifier = partyDocumentIdentifier
    def add_partyDocumentIdentifier(self, value): self.partyDocumentIdentifier.append(value)
    def insert_partyDocumentIdentifier_at(self, index, value): self.partyDocumentIdentifier.insert(index, value)
    def replace_partyDocumentIdentifier_at(self, index, value): self.partyDocumentIdentifier[index] = value
    def get_amendedDocument(self): return self.amendedDocument
    def set_amendedDocument(self, amendedDocument): self.amendedDocument = amendedDocument
    def get_documentHistory(self): return self.documentHistory
    def set_documentHistory(self, documentHistory): self.documentHistory = documentHistory
    def hasContent_(self):
        if (
            self.partyRoles is not None or
            self.agreementDate is not None or
            self.effectiveDate is not None or
            self.partyDocumentIdentifier or
            self.amendedDocument is not None or
            self.documentHistory is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LegalDocumentHeader', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LegalDocumentHeader')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LegalDocumentHeader', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LegalDocumentHeader'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LegalDocumentHeader', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.partyRoles is not None:
            self.partyRoles.export(outfile, level, namespace_, name_='partyRoles', pretty_print=pretty_print)
        if self.agreementDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sagreementDate>%s</%sagreementDate>%s' % (namespace_, self.gds_format_date(self.agreementDate, input_name='agreementDate'), namespace_, eol_))
        if self.effectiveDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%seffectiveDate>%s</%seffectiveDate>%s' % (namespace_, self.gds_format_date(self.effectiveDate, input_name='effectiveDate'), namespace_, eol_))
        for partyDocumentIdentifier_ in self.partyDocumentIdentifier:
            partyDocumentIdentifier_.export(outfile, level, namespace_, name_='partyDocumentIdentifier', pretty_print=pretty_print)
        if self.amendedDocument is not None:
            self.amendedDocument.export(outfile, level, namespace_, name_='amendedDocument', pretty_print=pretty_print)
        if self.documentHistory is not None:
            self.documentHistory.export(outfile, level, namespace_, name_='documentHistory', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'partyRoles':
            obj_ = PartyRoles.factory()
            obj_.build(child_)
            self.partyRoles = obj_
            obj_.original_tagname_ = 'partyRoles'
        elif nodeName_ == 'agreementDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.agreementDate = dval_
        elif nodeName_ == 'effectiveDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.effectiveDate = dval_
        elif nodeName_ == 'partyDocumentIdentifier':
            obj_ = PartyDocumentIdentifier.factory()
            obj_.build(child_)
            self.partyDocumentIdentifier.append(obj_)
            obj_.original_tagname_ = 'partyDocumentIdentifier'
        elif nodeName_ == 'amendedDocument':
            obj_ = DocumentReference.factory()
            obj_.build(child_)
            self.amendedDocument = obj_
            obj_.original_tagname_ = 'amendedDocument'
        elif nodeName_ == 'documentHistory':
            obj_ = LegalDocumentHistory.factory()
            obj_.build(child_)
            self.documentHistory = obj_
            obj_.original_tagname_ = 'documentHistory'
# end class LegalDocumentHeader


class LegalDocumentHistory(GeneratedsSuper):
    """The legal document history."""
    member_data_items_ = {
        'documentIdentity': MemberSpec_('documentIdentity', 'DocumentIdentity', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, documentIdentity=None):
        self.original_tagname_ = None
        if documentIdentity is None:
            self.documentIdentity = []
        else:
            self.documentIdentity = documentIdentity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LegalDocumentHistory)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LegalDocumentHistory.subclass:
            return LegalDocumentHistory.subclass(*args_, **kwargs_)
        else:
            return LegalDocumentHistory(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_documentIdentity(self): return self.documentIdentity
    def set_documentIdentity(self, documentIdentity): self.documentIdentity = documentIdentity
    def add_documentIdentity(self, value): self.documentIdentity.append(value)
    def insert_documentIdentity_at(self, index, value): self.documentIdentity.insert(index, value)
    def replace_documentIdentity_at(self, index, value): self.documentIdentity[index] = value
    def hasContent_(self):
        if (
            self.documentIdentity
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LegalDocumentHistory', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LegalDocumentHistory')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LegalDocumentHistory', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LegalDocumentHistory'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LegalDocumentHistory', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for documentIdentity_ in self.documentIdentity:
            documentIdentity_.export(outfile, level, namespace_, name_='documentIdentity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'documentIdentity':
            obj_ = DocumentIdentity.factory()
            obj_.build(child_)
            self.documentIdentity.append(obj_)
            obj_.original_tagname_ = 'documentIdentity'
# end class LegalDocumentHistory


class LegalDocumentId(GeneratedsSuper):
    """A legal document reference identifier allocated by a party. FpML
    does not define the domain values associated with this element.
    Note that the domain values for this element are not strictly an
    enumerated list."""
    member_data_items_ = {
        'legalDocumentIdScheme': MemberSpec_('legalDocumentIdScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['NonEmptyScheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, legalDocumentIdScheme=None, valueOf_=None):
        self.original_tagname_ = None
        self.legalDocumentIdScheme = _cast(None, legalDocumentIdScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LegalDocumentId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LegalDocumentId.subclass:
            return LegalDocumentId.subclass(*args_, **kwargs_)
        else:
            return LegalDocumentId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_legalDocumentIdScheme(self): return self.legalDocumentIdScheme
    def set_legalDocumentIdScheme(self, legalDocumentIdScheme): self.legalDocumentIdScheme = legalDocumentIdScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LegalDocumentId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LegalDocumentId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LegalDocumentId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LegalDocumentId'):
        if self.legalDocumentIdScheme is not None and 'legalDocumentIdScheme' not in already_processed:
            already_processed.add('legalDocumentIdScheme')
            outfile.write(' legalDocumentIdScheme=%s' % (quote_attrib(self.legalDocumentIdScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LegalDocumentId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('legalDocumentIdScheme', node)
        if value is not None and 'legalDocumentIdScheme' not in already_processed:
            already_processed.add('legalDocumentIdScheme')
            self.legalDocumentIdScheme = value
            self.validate_NonEmptyURI(self.legalDocumentIdScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LegalDocumentId


class LegalDocumentIdentity(GeneratedsSuper):
    """A type to specify the legal document identity."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'partyReference': MemberSpec_('partyReference', 'PartyReference', 1),
        'documentType': MemberSpec_('documentType', 'LegalDocumentType', 0),
        'agreementDate': MemberSpec_('agreementDate', 'xsd:date', 0),
        'partyDocumentIdentifier': MemberSpec_('partyDocumentIdentifier', 'PartyDocumentIdentifier', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, partyReference=None, documentType=None, agreementDate=None, partyDocumentIdentifier=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if partyReference is None:
            self.partyReference = []
        else:
            self.partyReference = partyReference
        self.documentType = documentType
        if isinstance(agreementDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(agreementDate, '%Y-%m-%d').date()
        else:
            initvalue_ = agreementDate
        self.agreementDate = initvalue_
        if partyDocumentIdentifier is None:
            self.partyDocumentIdentifier = []
        else:
            self.partyDocumentIdentifier = partyDocumentIdentifier
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LegalDocumentIdentity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LegalDocumentIdentity.subclass:
            return LegalDocumentIdentity.subclass(*args_, **kwargs_)
        else:
            return LegalDocumentIdentity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyReference(self): return self.partyReference
    def set_partyReference(self, partyReference): self.partyReference = partyReference
    def add_partyReference(self, value): self.partyReference.append(value)
    def insert_partyReference_at(self, index, value): self.partyReference.insert(index, value)
    def replace_partyReference_at(self, index, value): self.partyReference[index] = value
    def get_documentType(self): return self.documentType
    def set_documentType(self, documentType): self.documentType = documentType
    def get_agreementDate(self): return self.agreementDate
    def set_agreementDate(self, agreementDate): self.agreementDate = agreementDate
    def get_partyDocumentIdentifier(self): return self.partyDocumentIdentifier
    def set_partyDocumentIdentifier(self, partyDocumentIdentifier): self.partyDocumentIdentifier = partyDocumentIdentifier
    def add_partyDocumentIdentifier(self, value): self.partyDocumentIdentifier.append(value)
    def insert_partyDocumentIdentifier_at(self, index, value): self.partyDocumentIdentifier.insert(index, value)
    def replace_partyDocumentIdentifier_at(self, index, value): self.partyDocumentIdentifier[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.partyReference or
            self.documentType is not None or
            self.agreementDate is not None or
            self.partyDocumentIdentifier
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LegalDocumentIdentity', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LegalDocumentIdentity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LegalDocumentIdentity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LegalDocumentIdentity'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='LegalDocumentIdentity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for partyReference_ in self.partyReference:
            partyReference_.export(outfile, level, namespace_, name_='partyReference', pretty_print=pretty_print)
        if self.documentType is not None:
            self.documentType.export(outfile, level, namespace_, name_='documentType', pretty_print=pretty_print)
        if self.agreementDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sagreementDate>%s</%sagreementDate>%s' % (namespace_, self.gds_format_date(self.agreementDate, input_name='agreementDate'), namespace_, eol_))
        for partyDocumentIdentifier_ in self.partyDocumentIdentifier:
            partyDocumentIdentifier_.export(outfile, level, namespace_, name_='partyDocumentIdentifier', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'partyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.partyReference.append(obj_)
            obj_.original_tagname_ = 'partyReference'
        elif nodeName_ == 'documentType':
            obj_ = LegalDocumentType.factory()
            obj_.build(child_)
            self.documentType = obj_
            obj_.original_tagname_ = 'documentType'
        elif nodeName_ == 'agreementDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.agreementDate = dval_
        elif nodeName_ == 'partyDocumentIdentifier':
            obj_ = PartyDocumentIdentifier.factory()
            obj_.build(child_)
            self.partyDocumentIdentifier.append(obj_)
            obj_.original_tagname_ = 'partyDocumentIdentifier'
# end class LegalDocumentIdentity


class LegalDocumentName(GeneratedsSuper):
    """A type to hold the legal document name scheme."""
    member_data_items_ = {
        'legalDocumentNameScheme': MemberSpec_('legalDocumentNameScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, legalDocumentNameScheme='http://www.fpml.org/coding-scheme/legal-document-name', valueOf_=None):
        self.original_tagname_ = None
        self.legalDocumentNameScheme = _cast(None, legalDocumentNameScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LegalDocumentName)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LegalDocumentName.subclass:
            return LegalDocumentName.subclass(*args_, **kwargs_)
        else:
            return LegalDocumentName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_legalDocumentNameScheme(self): return self.legalDocumentNameScheme
    def set_legalDocumentNameScheme(self, legalDocumentNameScheme): self.legalDocumentNameScheme = legalDocumentNameScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LegalDocumentName', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LegalDocumentName')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LegalDocumentName', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LegalDocumentName'):
        if self.legalDocumentNameScheme != "http://www.fpml.org/coding-scheme/legal-document-name" and 'legalDocumentNameScheme' not in already_processed:
            already_processed.add('legalDocumentNameScheme')
            outfile.write(' legalDocumentNameScheme=%s' % (quote_attrib(self.legalDocumentNameScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LegalDocumentName', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('legalDocumentNameScheme', node)
        if value is not None and 'legalDocumentNameScheme' not in already_processed:
            already_processed.add('legalDocumentNameScheme')
            self.legalDocumentNameScheme = value
            self.validate_NonEmptyURI(self.legalDocumentNameScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LegalDocumentName


class LegalDocumentPublisher(GeneratedsSuper):
    """A type to hold the legal document publisher scheme."""
    member_data_items_ = {
        'legalDocumentPublisherScheme': MemberSpec_('legalDocumentPublisherScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, legalDocumentPublisherScheme='http://www.fpml.org/coding-scheme/legal-document-publisher', valueOf_=None):
        self.original_tagname_ = None
        self.legalDocumentPublisherScheme = _cast(None, legalDocumentPublisherScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LegalDocumentPublisher)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LegalDocumentPublisher.subclass:
            return LegalDocumentPublisher.subclass(*args_, **kwargs_)
        else:
            return LegalDocumentPublisher(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_legalDocumentPublisherScheme(self): return self.legalDocumentPublisherScheme
    def set_legalDocumentPublisherScheme(self, legalDocumentPublisherScheme): self.legalDocumentPublisherScheme = legalDocumentPublisherScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LegalDocumentPublisher', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LegalDocumentPublisher')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LegalDocumentPublisher', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LegalDocumentPublisher'):
        if self.legalDocumentPublisherScheme != "http://www.fpml.org/coding-scheme/legal-document-publisher" and 'legalDocumentPublisherScheme' not in already_processed:
            already_processed.add('legalDocumentPublisherScheme')
            outfile.write(' legalDocumentPublisherScheme=%s' % (quote_attrib(self.legalDocumentPublisherScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LegalDocumentPublisher', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('legalDocumentPublisherScheme', node)
        if value is not None and 'legalDocumentPublisherScheme' not in already_processed:
            already_processed.add('legalDocumentPublisherScheme')
            self.legalDocumentPublisherScheme = value
            self.validate_NonEmptyURI(self.legalDocumentPublisherScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LegalDocumentPublisher


class LegalDocumentStyle(GeneratedsSuper):
    """A type to hold the legal document style scheme."""
    member_data_items_ = {
        'legalDocumentStyleScheme': MemberSpec_('legalDocumentStyleScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, legalDocumentStyleScheme='http://www.fpml.org/coding-scheme/legal-document-style', valueOf_=None):
        self.original_tagname_ = None
        self.legalDocumentStyleScheme = _cast(None, legalDocumentStyleScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LegalDocumentStyle)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LegalDocumentStyle.subclass:
            return LegalDocumentStyle.subclass(*args_, **kwargs_)
        else:
            return LegalDocumentStyle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_legalDocumentStyleScheme(self): return self.legalDocumentStyleScheme
    def set_legalDocumentStyleScheme(self, legalDocumentStyleScheme): self.legalDocumentStyleScheme = legalDocumentStyleScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LegalDocumentStyle', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LegalDocumentStyle')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LegalDocumentStyle', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LegalDocumentStyle'):
        if self.legalDocumentStyleScheme != "http://www.fpml.org/coding-scheme/legal-document-style" and 'legalDocumentStyleScheme' not in already_processed:
            already_processed.add('legalDocumentStyleScheme')
            outfile.write(' legalDocumentStyleScheme=%s' % (quote_attrib(self.legalDocumentStyleScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LegalDocumentStyle', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('legalDocumentStyleScheme', node)
        if value is not None and 'legalDocumentStyleScheme' not in already_processed:
            already_processed.add('legalDocumentStyleScheme')
            self.legalDocumentStyleScheme = value
            self.validate_NonEmptyURI(self.legalDocumentStyleScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LegalDocumentStyle


class LegalDocumentType(GeneratedsSuper):
    """The type of legal document."""
    member_data_items_ = {
        'name': MemberSpec_('name', 'LegalDocumentName', 0),
        'publisher': MemberSpec_('publisher', 'LegalDocumentPublisher', 0),
        'style': MemberSpec_('style', 'LegalDocumentStyle', 0),
        'version': MemberSpec_('version', ['Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, name=None, publisher=None, style=None, version=None):
        self.original_tagname_ = None
        self.name = name
        self.publisher = publisher
        self.style = style
        self.version = version
        self.validate_Token(self.version)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LegalDocumentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LegalDocumentType.subclass:
            return LegalDocumentType.subclass(*args_, **kwargs_)
        else:
            return LegalDocumentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_publisher(self): return self.publisher
    def set_publisher(self, publisher): self.publisher = publisher
    def get_style(self): return self.style
    def set_style(self, style): self.style = style
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def validate_Token(self, value):
        # Validate type Token, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Token' % {"value" : value} )
    def hasContent_(self):
        if (
            self.name is not None or
            self.publisher is not None or
            self.style is not None or
            self.version is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LegalDocumentType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LegalDocumentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LegalDocumentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LegalDocumentType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LegalDocumentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            self.name.export(outfile, level, namespace_, name_='name', pretty_print=pretty_print)
        if self.publisher is not None:
            self.publisher.export(outfile, level, namespace_, name_='publisher', pretty_print=pretty_print)
        if self.style is not None:
            self.style.export(outfile, level, namespace_, name_='style', pretty_print=pretty_print)
        if self.version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sversion>%s</%sversion>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.version), input_name='version')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            obj_ = LegalDocumentName.factory()
            obj_.build(child_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'publisher':
            obj_ = LegalDocumentPublisher.factory()
            obj_.build(child_)
            self.publisher = obj_
            obj_.original_tagname_ = 'publisher'
        elif nodeName_ == 'style':
            obj_ = LegalDocumentStyle.factory()
            obj_.build(child_)
            self.style = obj_
            obj_.original_tagname_ = 'style'
        elif nodeName_ == 'version':
            version_ = child_.text
            version_ = re_.sub(String_cleanup_pat_, " ", version_).strip()
            version_ = self.gds_validate_string(version_, node, 'version')
            self.version = version_
            # validate type Token
            self.validate_Token(self.version)
# end class LegalDocumentType


class OtherProvisions(GeneratedsSuper):
    """A type to hold the other provisions schemes."""
    member_data_items_ = {
        'otherProvisionsEnglishLawScheme': MemberSpec_('otherProvisionsEnglishLawScheme', 'NonEmptyURI', 0),
        'otherProvisionsNewYorkLawScheme': MemberSpec_('otherProvisionsNewYorkLawScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, otherProvisionsEnglishLawScheme='http://www.fpml.org/coding-scheme/other-provisions-english-law', otherProvisionsNewYorkLawScheme='http://www.fpml.org/coding-scheme/other-provisions-new-york-law', valueOf_=None):
        self.original_tagname_ = None
        self.otherProvisionsEnglishLawScheme = _cast(None, otherProvisionsEnglishLawScheme)
        self.otherProvisionsNewYorkLawScheme = _cast(None, otherProvisionsNewYorkLawScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OtherProvisions)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OtherProvisions.subclass:
            return OtherProvisions.subclass(*args_, **kwargs_)
        else:
            return OtherProvisions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_otherProvisionsEnglishLawScheme(self): return self.otherProvisionsEnglishLawScheme
    def set_otherProvisionsEnglishLawScheme(self, otherProvisionsEnglishLawScheme): self.otherProvisionsEnglishLawScheme = otherProvisionsEnglishLawScheme
    def get_otherProvisionsNewYorkLawScheme(self): return self.otherProvisionsNewYorkLawScheme
    def set_otherProvisionsNewYorkLawScheme(self, otherProvisionsNewYorkLawScheme): self.otherProvisionsNewYorkLawScheme = otherProvisionsNewYorkLawScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OtherProvisions', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OtherProvisions')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OtherProvisions', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OtherProvisions'):
        if self.otherProvisionsEnglishLawScheme != "http://www.fpml.org/coding-scheme/other-provisions-english-law" and 'otherProvisionsEnglishLawScheme' not in already_processed:
            already_processed.add('otherProvisionsEnglishLawScheme')
            outfile.write(' otherProvisionsEnglishLawScheme=%s' % (quote_attrib(self.otherProvisionsEnglishLawScheme), ))
        if self.otherProvisionsNewYorkLawScheme != "http://www.fpml.org/coding-scheme/other-provisions-new-york-law" and 'otherProvisionsNewYorkLawScheme' not in already_processed:
            already_processed.add('otherProvisionsNewYorkLawScheme')
            outfile.write(' otherProvisionsNewYorkLawScheme=%s' % (quote_attrib(self.otherProvisionsNewYorkLawScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OtherProvisions', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('otherProvisionsEnglishLawScheme', node)
        if value is not None and 'otherProvisionsEnglishLawScheme' not in already_processed:
            already_processed.add('otherProvisionsEnglishLawScheme')
            self.otherProvisionsEnglishLawScheme = value
            self.validate_NonEmptyURI(self.otherProvisionsEnglishLawScheme)    # validate type NonEmptyURI
        value = find_attr_value_('otherProvisionsNewYorkLawScheme', node)
        if value is not None and 'otherProvisionsNewYorkLawScheme' not in already_processed:
            already_processed.add('otherProvisionsNewYorkLawScheme')
            self.otherProvisionsNewYorkLawScheme = value
            self.validate_NonEmptyURI(self.otherProvisionsNewYorkLawScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OtherProvisions


class PartyDocumentIdentifier(GeneratedsSuper):
    """A type defining a legal document identifier issued by the indicated
    party."""
    member_data_items_ = {
        'id': MemberSpec_('id', 'xsd:string', 0),
        'partyReference': MemberSpec_('partyReference', 'PartyReference', 0),
        'documentId': MemberSpec_('documentId', 'LegalDocumentId', 1),
        'documentVersion': MemberSpec_('documentVersion', ['Token', 'xsd:token'], 1),
    }
    subclass = None
    superclass = None
    def __init__(self, id=None, partyReference=None, documentId=None, documentVersion=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.partyReference = partyReference
        if documentId is None:
            self.documentId = []
        else:
            self.documentId = documentId
        if documentVersion is None:
            self.documentVersion = []
        else:
            self.documentVersion = documentVersion
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyDocumentIdentifier)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyDocumentIdentifier.subclass:
            return PartyDocumentIdentifier.subclass(*args_, **kwargs_)
        else:
            return PartyDocumentIdentifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyReference(self): return self.partyReference
    def set_partyReference(self, partyReference): self.partyReference = partyReference
    def get_documentId(self): return self.documentId
    def set_documentId(self, documentId): self.documentId = documentId
    def add_documentId(self, value): self.documentId.append(value)
    def insert_documentId_at(self, index, value): self.documentId.insert(index, value)
    def replace_documentId_at(self, index, value): self.documentId[index] = value
    def get_documentVersion(self): return self.documentVersion
    def set_documentVersion(self, documentVersion): self.documentVersion = documentVersion
    def add_documentVersion(self, value): self.documentVersion.append(value)
    def insert_documentVersion_at(self, index, value): self.documentVersion.insert(index, value)
    def replace_documentVersion_at(self, index, value): self.documentVersion[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_Token(self, value):
        # Validate type Token, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Token' % {"value" : value} )
    def hasContent_(self):
        if (
            self.partyReference is not None or
            self.documentId or
            self.documentVersion
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartyDocumentIdentifier', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyDocumentIdentifier')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartyDocumentIdentifier', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyDocumentIdentifier'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PartyDocumentIdentifier', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.partyReference is not None:
            self.partyReference.export(outfile, level, namespace_, name_='partyReference', pretty_print=pretty_print)
        for documentId_ in self.documentId:
            documentId_.export(outfile, level, namespace_, name_='documentId', pretty_print=pretty_print)
        for documentVersion_ in self.documentVersion:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdocumentVersion>%s</%sdocumentVersion>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(documentVersion_), input_name='documentVersion')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'partyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.partyReference = obj_
            obj_.original_tagname_ = 'partyReference'
        elif nodeName_ == 'documentId':
            obj_ = LegalDocumentId.factory()
            obj_.build(child_)
            self.documentId.append(obj_)
            obj_.original_tagname_ = 'documentId'
        elif nodeName_ == 'documentVersion':
            documentVersion_ = child_.text
            documentVersion_ = re_.sub(String_cleanup_pat_, " ", documentVersion_).strip()
            documentVersion_ = self.gds_validate_string(documentVersion_, node, 'documentVersion')
            self.documentVersion.append(documentVersion_)
            # validate type Token
            self.validate_Token(self.documentVersion[-1])
# end class PartyDocumentIdentifier


class PartyRoles(GeneratedsSuper):
    """A type to specify the roles of the parties to the document."""
    member_data_items_ = {
        'relatedParty': MemberSpec_('relatedParty', 'RelatedParty', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, relatedParty=None):
        self.original_tagname_ = None
        if relatedParty is None:
            self.relatedParty = []
        else:
            self.relatedParty = relatedParty
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyRoles)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyRoles.subclass:
            return PartyRoles.subclass(*args_, **kwargs_)
        else:
            return PartyRoles(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_relatedParty(self): return self.relatedParty
    def set_relatedParty(self, relatedParty): self.relatedParty = relatedParty
    def add_relatedParty(self, value): self.relatedParty.append(value)
    def insert_relatedParty_at(self, index, value): self.relatedParty.insert(index, value)
    def replace_relatedParty_at(self, index, value): self.relatedParty[index] = value
    def hasContent_(self):
        if (
            self.relatedParty
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartyRoles', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyRoles')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartyRoles', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyRoles'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PartyRoles', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for relatedParty_ in self.relatedParty:
            relatedParty_.export(outfile, level, namespace_, name_='relatedParty', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'relatedParty':
            obj_ = RelatedParty.factory()
            obj_.build(child_)
            self.relatedParty.append(obj_)
            obj_.original_tagname_ = 'relatedParty'
# end class PartyRoles


class SettlementDay(GeneratedsSuper):
    """A type to hold the settlement day scheme."""
    member_data_items_ = {
        'settlementDayScheme': MemberSpec_('settlementDayScheme', 'NonEmptyURI', 0),
        'valueOf_': MemberSpec_('valueOf_', ['Scheme', 'NormalizedString', 'xsd:normalizedString'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, settlementDayScheme='http://www.fpml.org/coding-scheme/settlement-day', valueOf_=None):
        self.original_tagname_ = None
        self.settlementDayScheme = _cast(None, settlementDayScheme)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SettlementDay)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SettlementDay.subclass:
            return SettlementDay.subclass(*args_, **kwargs_)
        else:
            return SettlementDay(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_settlementDayScheme(self): return self.settlementDayScheme
    def set_settlementDayScheme(self, settlementDayScheme): self.settlementDayScheme = settlementDayScheme
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NonEmptyURI(self, value):
        # Validate type NonEmptyURI, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NonEmptyURI' % {"value" : value} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SettlementDay', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SettlementDay')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SettlementDay', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SettlementDay'):
        if self.settlementDayScheme != "http://www.fpml.org/coding-scheme/settlement-day" and 'settlementDayScheme' not in already_processed:
            already_processed.add('settlementDayScheme')
            outfile.write(' settlementDayScheme=%s' % (quote_attrib(self.settlementDayScheme), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SettlementDay', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('settlementDayScheme', node)
        if value is not None and 'settlementDayScheme' not in already_processed:
            already_processed.add('settlementDayScheme')
            self.settlementDayScheme = value
            self.validate_NonEmptyURI(self.settlementDayScheme)    # validate type NonEmptyURI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SettlementDay


class SpecifiedRate(GeneratedsSuper):
    """A type to specify an interest rate."""
    member_data_items_ = {
        'currency': MemberSpec_('currency', 'Currency', 0),
        'fixedRate': MemberSpec_('fixedRate', 'xsd:decimal', 0),
        'floatingRate': MemberSpec_('floatingRate', 'FloatingRateIndex', 0),
        'spread': MemberSpec_('spread', 'xsd:decimal', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, currency=None, fixedRate=None, floatingRate=None, spread=None):
        self.original_tagname_ = None
        self.currency = currency
        self.fixedRate = fixedRate
        self.floatingRate = floatingRate
        self.spread = spread
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpecifiedRate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpecifiedRate.subclass:
            return SpecifiedRate.subclass(*args_, **kwargs_)
        else:
            return SpecifiedRate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_fixedRate(self): return self.fixedRate
    def set_fixedRate(self, fixedRate): self.fixedRate = fixedRate
    def get_floatingRate(self): return self.floatingRate
    def set_floatingRate(self, floatingRate): self.floatingRate = floatingRate
    def get_spread(self): return self.spread
    def set_spread(self, spread): self.spread = spread
    def hasContent_(self):
        if (
            self.currency is not None or
            self.fixedRate is not None or
            self.floatingRate is not None or
            self.spread is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SpecifiedRate', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SpecifiedRate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SpecifiedRate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SpecifiedRate'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SpecifiedRate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.currency is not None:
            self.currency.export(outfile, level, namespace_, name_='currency', pretty_print=pretty_print)
        if self.fixedRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfixedRate>%s</%sfixedRate>%s' % (namespace_, self.gds_format_float(self.fixedRate, input_name='fixedRate'), namespace_, eol_))
        if self.floatingRate is not None:
            self.floatingRate.export(outfile, level, namespace_, name_='floatingRate', pretty_print=pretty_print)
        if self.spread is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sspread>%s</%sspread>%s' % (namespace_, self.gds_format_float(self.spread, input_name='spread'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'currency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'fixedRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'fixedRate')
            self.fixedRate = fval_
        elif nodeName_ == 'floatingRate':
            obj_ = FloatingRateIndex.factory()
            obj_.build(child_)
            self.floatingRate = obj_
            obj_.original_tagname_ = 'floatingRate'
        elif nodeName_ == 'spread':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'spread')
            self.spread = fval_
# end class SpecifiedRate


class StandardCreditSupportAnnexBase(ContractualDocument):
    """The base SCSA implementation."""
    member_data_items_ = {
        'independentAmounts': MemberSpec_('independentAmounts', 'IndependentAmounts', 1),
        'baseCurrency': MemberSpec_('baseCurrency', 'Currency', 0),
        'existingCreditSupportAnnex': MemberSpec_('existingCreditSupportAnnex', 'ExistingCreditSupportAnnex', 0),
        'settlementDay': MemberSpec_('settlementDay', 'SettlementDay', 0),
    }
    subclass = None
    superclass = ContractualDocument
    def __init__(self, id=None, documentType=None, independentAmounts=None, baseCurrency=None, existingCreditSupportAnnex=None, settlementDay=None, extensiontype_=None):
        self.original_tagname_ = None
        super(StandardCreditSupportAnnexBase, self).__init__(id, documentType, extensiontype_, )
        if independentAmounts is None:
            self.independentAmounts = []
        else:
            self.independentAmounts = independentAmounts
        self.baseCurrency = baseCurrency
        self.existingCreditSupportAnnex = existingCreditSupportAnnex
        self.settlementDay = settlementDay
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StandardCreditSupportAnnexBase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StandardCreditSupportAnnexBase.subclass:
            return StandardCreditSupportAnnexBase.subclass(*args_, **kwargs_)
        else:
            return StandardCreditSupportAnnexBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_independentAmounts(self): return self.independentAmounts
    def set_independentAmounts(self, independentAmounts): self.independentAmounts = independentAmounts
    def add_independentAmounts(self, value): self.independentAmounts.append(value)
    def insert_independentAmounts_at(self, index, value): self.independentAmounts.insert(index, value)
    def replace_independentAmounts_at(self, index, value): self.independentAmounts[index] = value
    def get_baseCurrency(self): return self.baseCurrency
    def set_baseCurrency(self, baseCurrency): self.baseCurrency = baseCurrency
    def get_existingCreditSupportAnnex(self): return self.existingCreditSupportAnnex
    def set_existingCreditSupportAnnex(self, existingCreditSupportAnnex): self.existingCreditSupportAnnex = existingCreditSupportAnnex
    def get_settlementDay(self): return self.settlementDay
    def set_settlementDay(self, settlementDay): self.settlementDay = settlementDay
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.independentAmounts or
            self.baseCurrency is not None or
            self.existingCreditSupportAnnex is not None or
            self.settlementDay is not None or
            super(StandardCreditSupportAnnexBase, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StandardCreditSupportAnnexBase', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StandardCreditSupportAnnexBase')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StandardCreditSupportAnnexBase', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StandardCreditSupportAnnexBase'):
        super(StandardCreditSupportAnnexBase, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StandardCreditSupportAnnexBase')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='StandardCreditSupportAnnexBase', fromsubclass_=False, pretty_print=True):
        super(StandardCreditSupportAnnexBase, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for independentAmounts_ in self.independentAmounts:
            independentAmounts_.export(outfile, level, namespace_, name_='independentAmounts', pretty_print=pretty_print)
        if self.baseCurrency is not None:
            self.baseCurrency.export(outfile, level, namespace_, name_='baseCurrency', pretty_print=pretty_print)
        if self.existingCreditSupportAnnex is not None:
            self.existingCreditSupportAnnex.export(outfile, level, namespace_, name_='existingCreditSupportAnnex', pretty_print=pretty_print)
        if self.settlementDay is not None:
            self.settlementDay.export(outfile, level, namespace_, name_='settlementDay', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(StandardCreditSupportAnnexBase, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'independentAmounts':
            obj_ = IndependentAmounts.factory()
            obj_.build(child_)
            self.independentAmounts.append(obj_)
            obj_.original_tagname_ = 'independentAmounts'
        elif nodeName_ == 'baseCurrency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.baseCurrency = obj_
            obj_.original_tagname_ = 'baseCurrency'
        elif nodeName_ == 'existingCreditSupportAnnex':
            obj_ = ExistingCreditSupportAnnex.factory()
            obj_.build(child_)
            self.existingCreditSupportAnnex = obj_
            obj_.original_tagname_ = 'existingCreditSupportAnnex'
        elif nodeName_ == 'settlementDay':
            obj_ = SettlementDay.factory()
            obj_.build(child_)
            self.settlementDay = obj_
            obj_.original_tagname_ = 'settlementDay'
        super(StandardCreditSupportAnnexBase, self).buildChildren(child_, node, nodeName_, True)
# end class StandardCreditSupportAnnexBase


class TransportCurrency(GeneratedsSuper):
    """A type to specify the transport currency for each of the parties to
    the agreement. This Transport Currency concept is specific to
    the 2013 version of the Standard CSA."""
    member_data_items_ = {
        'partyReference': MemberSpec_('partyReference', 'PartyReference', 0),
        'electedTransportCurrency': MemberSpec_('electedTransportCurrency', 'ElectedTransportCurrency', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, partyReference=None, electedTransportCurrency=None):
        self.original_tagname_ = None
        self.partyReference = partyReference
        self.electedTransportCurrency = electedTransportCurrency
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransportCurrency)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransportCurrency.subclass:
            return TransportCurrency.subclass(*args_, **kwargs_)
        else:
            return TransportCurrency(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyReference(self): return self.partyReference
    def set_partyReference(self, partyReference): self.partyReference = partyReference
    def get_electedTransportCurrency(self): return self.electedTransportCurrency
    def set_electedTransportCurrency(self, electedTransportCurrency): self.electedTransportCurrency = electedTransportCurrency
    def hasContent_(self):
        if (
            self.partyReference is not None or
            self.electedTransportCurrency is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TransportCurrency', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TransportCurrency')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TransportCurrency', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TransportCurrency'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TransportCurrency', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.partyReference is not None:
            self.partyReference.export(outfile, level, namespace_, name_='partyReference', pretty_print=pretty_print)
        if self.electedTransportCurrency is not None:
            self.electedTransportCurrency.export(outfile, level, namespace_, name_='electedTransportCurrency', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'partyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.partyReference = obj_
            obj_.original_tagname_ = 'partyReference'
        elif nodeName_ == 'electedTransportCurrency':
            obj_ = ElectedTransportCurrency.factory()
            obj_.build(child_)
            self.electedTransportCurrency = obj_
            obj_.original_tagname_ = 'electedTransportCurrency'
# end class TransportCurrency


class UseOfPostedCreditSupport(GeneratedsSuper):
    member_data_items_ = {
        'partyReference': MemberSpec_('partyReference', 'PartyReference', 0),
        'useOfPostedCollateral': MemberSpec_('useOfPostedCollateral', 'xsd:boolean', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, partyReference=None, useOfPostedCollateral=None):
        self.original_tagname_ = None
        self.partyReference = partyReference
        self.useOfPostedCollateral = useOfPostedCollateral
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UseOfPostedCreditSupport)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UseOfPostedCreditSupport.subclass:
            return UseOfPostedCreditSupport.subclass(*args_, **kwargs_)
        else:
            return UseOfPostedCreditSupport(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partyReference(self): return self.partyReference
    def set_partyReference(self, partyReference): self.partyReference = partyReference
    def get_useOfPostedCollateral(self): return self.useOfPostedCollateral
    def set_useOfPostedCollateral(self, useOfPostedCollateral): self.useOfPostedCollateral = useOfPostedCollateral
    def hasContent_(self):
        if (
            self.partyReference is not None or
            self.useOfPostedCollateral is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='UseOfPostedCreditSupport', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UseOfPostedCreditSupport')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='UseOfPostedCreditSupport', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UseOfPostedCreditSupport'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='UseOfPostedCreditSupport', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.partyReference is not None:
            self.partyReference.export(outfile, level, namespace_, name_='partyReference', pretty_print=pretty_print)
        if self.useOfPostedCollateral is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suseOfPostedCollateral>%s</%suseOfPostedCollateral>%s' % (namespace_, self.gds_format_boolean(self.useOfPostedCollateral, input_name='useOfPostedCollateral'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'partyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.partyReference = obj_
            obj_.original_tagname_ = 'partyReference'
        elif nodeName_ == 'useOfPostedCollateral':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'useOfPostedCollateral')
            self.useOfPostedCollateral = ival_
# end class UseOfPostedCreditSupport


class SignatureType(GeneratedsSuper):
    member_data_items_ = {
        'Id': MemberSpec_('Id', 'ID', 0),
        'SignedInfo': MemberSpec_('SignedInfo', 'SignedInfoType', 0),
        'SignatureValue': MemberSpec_('SignatureValue', 'SignatureValueType', 0),
        'KeyInfo': MemberSpec_('KeyInfo', 'KeyInfoType', 0),
        'Object': MemberSpec_('Object', 'ObjectType', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, Id=None, SignedInfo=None, SignatureValue=None, KeyInfo=None, Object=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        self.SignedInfo = SignedInfo
        self.SignatureValue = SignatureValue
        self.KeyInfo = KeyInfo
        if Object is None:
            self.Object = []
        else:
            self.Object = Object
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignatureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignatureType.subclass:
            return SignatureType.subclass(*args_, **kwargs_)
        else:
            return SignatureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SignedInfo(self): return self.SignedInfo
    def set_SignedInfo(self, SignedInfo): self.SignedInfo = SignedInfo
    def get_SignatureValue(self): return self.SignatureValue
    def set_SignatureValue(self, SignatureValue): self.SignatureValue = SignatureValue
    def get_KeyInfo(self): return self.KeyInfo
    def set_KeyInfo(self, KeyInfo): self.KeyInfo = KeyInfo
    def get_Object(self): return self.Object
    def set_Object(self, Object): self.Object = Object
    def add_Object(self, value): self.Object.append(value)
    def insert_Object_at(self, index, value): self.Object.insert(index, value)
    def replace_Object_at(self, index, value): self.Object[index] = value
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def hasContent_(self):
        if (
            self.SignedInfo is not None or
            self.SignatureValue is not None or
            self.KeyInfo is not None or
            self.Object
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SignatureType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SignatureType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SignatureType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SignatureType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SignatureType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SignedInfo is not None:
            self.SignedInfo.export(outfile, level, namespace_='ds:', name_='SignedInfo', pretty_print=pretty_print)
        if self.SignatureValue is not None:
            self.SignatureValue.export(outfile, level, namespace_='ds:', name_='SignatureValue', pretty_print=pretty_print)
        if self.KeyInfo is not None:
            self.KeyInfo.export(outfile, level, namespace_='ds:', name_='KeyInfo', pretty_print=pretty_print)
        for Object_ in self.Object:
            Object_.export(outfile, level, namespace_='ds:', name_='Object', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SignedInfo':
            obj_ = SignedInfoType.factory()
            obj_.build(child_)
            self.SignedInfo = obj_
            obj_.original_tagname_ = 'SignedInfo'
        elif nodeName_ == 'SignatureValue':
            obj_ = SignatureValueType.factory()
            obj_.build(child_)
            self.SignatureValue = obj_
            obj_.original_tagname_ = 'SignatureValue'
        elif nodeName_ == 'KeyInfo':
            obj_ = KeyInfoType.factory()
            obj_.build(child_)
            self.KeyInfo = obj_
            obj_.original_tagname_ = 'KeyInfo'
        elif nodeName_ == 'Object':
            obj_ = ObjectType.factory()
            obj_.build(child_)
            self.Object.append(obj_)
            obj_.original_tagname_ = 'Object'
# end class SignatureType


class SignatureValueType(GeneratedsSuper):
    member_data_items_ = {
        'Id': MemberSpec_('Id', 'ID', 0),
        'valueOf_': MemberSpec_('valueOf_', 'base64Binary', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, Id=None, valueOf_=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignatureValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignatureValueType.subclass:
            return SignatureValueType.subclass(*args_, **kwargs_)
        else:
            return SignatureValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SignatureValueType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SignatureValueType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SignatureValueType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SignatureValueType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SignatureValueType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SignatureValueType


class SignedInfoType(GeneratedsSuper):
    member_data_items_ = {
        'Id': MemberSpec_('Id', 'ID', 0),
        'CanonicalizationMethod': MemberSpec_('CanonicalizationMethod', 'CanonicalizationMethodType', 0),
        'SignatureMethod': MemberSpec_('SignatureMethod', 'SignatureMethodType', 0),
        'Reference': MemberSpec_('Reference', 'ReferenceType', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, Id=None, CanonicalizationMethod=None, SignatureMethod=None, Reference=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        self.CanonicalizationMethod = CanonicalizationMethod
        self.SignatureMethod = SignatureMethod
        if Reference is None:
            self.Reference = []
        else:
            self.Reference = Reference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignedInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignedInfoType.subclass:
            return SignedInfoType.subclass(*args_, **kwargs_)
        else:
            return SignedInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CanonicalizationMethod(self): return self.CanonicalizationMethod
    def set_CanonicalizationMethod(self, CanonicalizationMethod): self.CanonicalizationMethod = CanonicalizationMethod
    def get_SignatureMethod(self): return self.SignatureMethod
    def set_SignatureMethod(self, SignatureMethod): self.SignatureMethod = SignatureMethod
    def get_Reference(self): return self.Reference
    def set_Reference(self, Reference): self.Reference = Reference
    def add_Reference(self, value): self.Reference.append(value)
    def insert_Reference_at(self, index, value): self.Reference.insert(index, value)
    def replace_Reference_at(self, index, value): self.Reference[index] = value
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def hasContent_(self):
        if (
            self.CanonicalizationMethod is not None or
            self.SignatureMethod is not None or
            self.Reference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SignedInfoType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SignedInfoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SignedInfoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SignedInfoType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SignedInfoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CanonicalizationMethod is not None:
            self.CanonicalizationMethod.export(outfile, level, namespace_='ds:', name_='CanonicalizationMethod', pretty_print=pretty_print)
        if self.SignatureMethod is not None:
            self.SignatureMethod.export(outfile, level, namespace_='ds:', name_='SignatureMethod', pretty_print=pretty_print)
        for Reference_ in self.Reference:
            Reference_.export(outfile, level, namespace_='ds:', name_='Reference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CanonicalizationMethod':
            obj_ = CanonicalizationMethodType.factory()
            obj_.build(child_)
            self.CanonicalizationMethod = obj_
            obj_.original_tagname_ = 'CanonicalizationMethod'
        elif nodeName_ == 'SignatureMethod':
            obj_ = SignatureMethodType.factory()
            obj_.build(child_)
            self.SignatureMethod = obj_
            obj_.original_tagname_ = 'SignatureMethod'
        elif nodeName_ == 'Reference':
            obj_ = ReferenceType.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'Reference'
# end class SignedInfoType


class CanonicalizationMethodType(GeneratedsSuper):
    member_data_items_ = {
        'Algorithm': MemberSpec_('Algorithm', 'anyURI', 0),
        '': MemberSpec_('', 'xsd:string', 1),
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, Algorithm=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.Algorithm = _cast(None, Algorithm)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CanonicalizationMethodType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CanonicalizationMethodType.subclass:
            return CanonicalizationMethodType.subclass(*args_, **kwargs_)
        else:
            return CanonicalizationMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_Algorithm(self): return self.Algorithm
    def set_Algorithm(self, Algorithm): self.Algorithm = Algorithm
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CanonicalizationMethodType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CanonicalizationMethodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CanonicalizationMethodType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CanonicalizationMethodType'):
        if self.Algorithm is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CanonicalizationMethodType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Algorithm', node)
        if value is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            self.Algorithm = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class CanonicalizationMethodType


class SignatureMethodType(GeneratedsSuper):
    member_data_items_ = {
        'Algorithm': MemberSpec_('Algorithm', 'anyURI', 0),
        'HMACOutputLength': MemberSpec_('HMACOutputLength', ['HMACOutputLengthType', 'integer'], 0),
        '': MemberSpec_('', 'xsd:string', 1),
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, Algorithm=None, HMACOutputLength=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.Algorithm = _cast(None, Algorithm)
        self.HMACOutputLength = HMACOutputLength
        self.validate_HMACOutputLengthType(self.HMACOutputLength)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignatureMethodType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignatureMethodType.subclass:
            return SignatureMethodType.subclass(*args_, **kwargs_)
        else:
            return SignatureMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_HMACOutputLength(self): return self.HMACOutputLength
    def set_HMACOutputLength(self, HMACOutputLength): self.HMACOutputLength = HMACOutputLength
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_Algorithm(self): return self.Algorithm
    def set_Algorithm(self, Algorithm): self.Algorithm = Algorithm
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_HMACOutputLengthType(self, value):
        # Validate type HMACOutputLengthType, a restriction on integer.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.HMACOutputLength is not None or
            self.anytypeobjs_ or
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SignatureMethodType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SignatureMethodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SignatureMethodType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SignatureMethodType'):
        if self.Algorithm is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SignatureMethodType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Algorithm', node)
        if value is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            self.Algorithm = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'HMACOutputLength' and child_.text is not None:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeInteger, 'HMACOutputLength', ival_)
            self.content_.append(obj_)
        elif nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class SignatureMethodType


class ReferenceType(GeneratedsSuper):
    member_data_items_ = {
        'Id': MemberSpec_('Id', 'ID', 0),
        'URI': MemberSpec_('URI', 'anyURI', 0),
        'Type': MemberSpec_('Type', 'anyURI', 0),
        'Transforms': MemberSpec_('Transforms', 'TransformsType', 0),
        'DigestMethod': MemberSpec_('DigestMethod', 'DigestMethodType', 0),
        'DigestValue': MemberSpec_('DigestValue', 'xsd:base64Binary', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, Id=None, URI=None, Type=None, Transforms=None, DigestMethod=None, DigestValue=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        self.URI = _cast(None, URI)
        self.Type = _cast(None, Type)
        self.Transforms = Transforms
        self.DigestMethod = DigestMethod
        self.DigestValue = DigestValue
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferenceType.subclass:
            return ReferenceType.subclass(*args_, **kwargs_)
        else:
            return ReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Transforms(self): return self.Transforms
    def set_Transforms(self, Transforms): self.Transforms = Transforms
    def get_DigestMethod(self): return self.DigestMethod
    def set_DigestMethod(self, DigestMethod): self.DigestMethod = DigestMethod
    def get_DigestValue(self): return self.DigestValue
    def set_DigestValue(self, DigestValue): self.DigestValue = DigestValue
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_URI(self): return self.URI
    def set_URI(self, URI): self.URI = URI
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def hasContent_(self):
        if (
            self.Transforms is not None or
            self.DigestMethod is not None or
            self.DigestValue is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReferenceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReferenceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReferenceType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
        if self.URI is not None and 'URI' not in already_processed:
            already_processed.add('URI')
            outfile.write(' URI=%s' % (quote_attrib(self.URI), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ReferenceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Transforms is not None:
            self.Transforms.export(outfile, level, namespace_='ds:', name_='Transforms', pretty_print=pretty_print)
        if self.DigestMethod is not None:
            self.DigestMethod.export(outfile, level, namespace_='ds:', name_='DigestMethod', pretty_print=pretty_print)
        if self.DigestValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDigestValue>%s</%sDigestValue>%s' % (namespace_, self.gds_format_base64(self.DigestValue, input_name='DigestValue'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
        value = find_attr_value_('URI', node)
        if value is not None and 'URI' not in already_processed:
            already_processed.add('URI')
            self.URI = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Transforms':
            obj_ = TransformsType.factory()
            obj_.build(child_)
            self.Transforms = obj_
            obj_.original_tagname_ = 'Transforms'
        elif nodeName_ == 'DigestMethod':
            obj_ = DigestMethodType.factory()
            obj_.build(child_)
            self.DigestMethod = obj_
            obj_.original_tagname_ = 'DigestMethod'
        elif nodeName_ == 'DigestValue':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'DigestValue')
            else:
                bval_ = None
            self.DigestValue = bval_
# end class ReferenceType


class TransformsType(GeneratedsSuper):
    member_data_items_ = {
        'Transform': MemberSpec_('Transform', 'TransformType', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, Transform=None):
        self.original_tagname_ = None
        if Transform is None:
            self.Transform = []
        else:
            self.Transform = Transform
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransformsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransformsType.subclass:
            return TransformsType.subclass(*args_, **kwargs_)
        else:
            return TransformsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Transform(self): return self.Transform
    def set_Transform(self, Transform): self.Transform = Transform
    def add_Transform(self, value): self.Transform.append(value)
    def insert_Transform_at(self, index, value): self.Transform.insert(index, value)
    def replace_Transform_at(self, index, value): self.Transform[index] = value
    def hasContent_(self):
        if (
            self.Transform
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TransformsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TransformsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TransformsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TransformsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TransformsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Transform_ in self.Transform:
            Transform_.export(outfile, level, namespace_='ds:', name_='Transform', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Transform':
            obj_ = TransformType.factory()
            obj_.build(child_)
            self.Transform.append(obj_)
            obj_.original_tagname_ = 'Transform'
# end class TransformsType


class TransformType(GeneratedsSuper):
    member_data_items_ = {
        'Algorithm': MemberSpec_('Algorithm', 'anyURI', 0),
        '': MemberSpec_('', 'xsd:string', 0),
        'XPath': MemberSpec_('XPath', 'xsd:string', 1),
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, Algorithm=None, anytypeobjs_=None, XPath=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.Algorithm = _cast(None, Algorithm)
        self.anytypeobjs_ = anytypeobjs_
        if XPath is None:
            self.XPath = []
        else:
            self.XPath = XPath
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransformType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransformType.subclass:
            return TransformType.subclass(*args_, **kwargs_)
        else:
            return TransformType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_XPath(self): return self.XPath
    def set_XPath(self, XPath): self.XPath = XPath
    def add_XPath(self, value): self.XPath.append(value)
    def insert_XPath_at(self, index, value): self.XPath.insert(index, value)
    def replace_XPath_at(self, index, value): self.XPath[index] = value
    def get_Algorithm(self): return self.Algorithm
    def set_Algorithm(self, Algorithm): self.Algorithm = Algorithm
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.anytypeobjs_ is not None or
            self.XPath or
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TransformType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TransformType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TransformType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TransformType'):
        if self.Algorithm is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TransformType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Algorithm', node)
        if value is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            self.Algorithm = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        elif nodeName_ == 'XPath' and child_.text is not None:
            valuestr_ = child_.text
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'XPath', valuestr_)
            self.content_.append(obj_)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class TransformType


class DigestMethodType(GeneratedsSuper):
    member_data_items_ = {
        'Algorithm': MemberSpec_('Algorithm', 'anyURI', 0),
        '': MemberSpec_('', 'xsd:string', 1),
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, Algorithm=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.Algorithm = _cast(None, Algorithm)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DigestMethodType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DigestMethodType.subclass:
            return DigestMethodType.subclass(*args_, **kwargs_)
        else:
            return DigestMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_Algorithm(self): return self.Algorithm
    def set_Algorithm(self, Algorithm): self.Algorithm = Algorithm
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DigestMethodType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DigestMethodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DigestMethodType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DigestMethodType'):
        if self.Algorithm is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DigestMethodType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Algorithm', node)
        if value is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            self.Algorithm = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class DigestMethodType


class KeyInfoType(GeneratedsSuper):
    member_data_items_ = {
        'Id': MemberSpec_('Id', 'ID', 0),
        'KeyName': MemberSpec_('KeyName', 'xsd:string', 1),
        'KeyValue': MemberSpec_('KeyValue', 'KeyValueType', 1),
        'RetrievalMethod': MemberSpec_('RetrievalMethod', 'RetrievalMethodType', 1),
        'X509Data': MemberSpec_('X509Data', 'X509DataType', 1),
        'PGPData': MemberSpec_('PGPData', 'PGPDataType', 1),
        'SPKIData': MemberSpec_('SPKIData', 'SPKIDataType', 1),
        'MgmtData': MemberSpec_('MgmtData', 'xsd:string', 1),
        '': MemberSpec_('', 'xsd:string', 0),
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, Id=None, KeyName=None, KeyValue=None, RetrievalMethod=None, X509Data=None, PGPData=None, SPKIData=None, MgmtData=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        if KeyName is None:
            self.KeyName = []
        else:
            self.KeyName = KeyName
        if KeyValue is None:
            self.KeyValue = []
        else:
            self.KeyValue = KeyValue
        if RetrievalMethod is None:
            self.RetrievalMethod = []
        else:
            self.RetrievalMethod = RetrievalMethod
        if X509Data is None:
            self.X509Data = []
        else:
            self.X509Data = X509Data
        if PGPData is None:
            self.PGPData = []
        else:
            self.PGPData = PGPData
        if SPKIData is None:
            self.SPKIData = []
        else:
            self.SPKIData = SPKIData
        if MgmtData is None:
            self.MgmtData = []
        else:
            self.MgmtData = MgmtData
        self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KeyInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KeyInfoType.subclass:
            return KeyInfoType.subclass(*args_, **kwargs_)
        else:
            return KeyInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_KeyName(self): return self.KeyName
    def set_KeyName(self, KeyName): self.KeyName = KeyName
    def add_KeyName(self, value): self.KeyName.append(value)
    def insert_KeyName_at(self, index, value): self.KeyName.insert(index, value)
    def replace_KeyName_at(self, index, value): self.KeyName[index] = value
    def get_KeyValue(self): return self.KeyValue
    def set_KeyValue(self, KeyValue): self.KeyValue = KeyValue
    def add_KeyValue(self, value): self.KeyValue.append(value)
    def insert_KeyValue_at(self, index, value): self.KeyValue.insert(index, value)
    def replace_KeyValue_at(self, index, value): self.KeyValue[index] = value
    def get_RetrievalMethod(self): return self.RetrievalMethod
    def set_RetrievalMethod(self, RetrievalMethod): self.RetrievalMethod = RetrievalMethod
    def add_RetrievalMethod(self, value): self.RetrievalMethod.append(value)
    def insert_RetrievalMethod_at(self, index, value): self.RetrievalMethod.insert(index, value)
    def replace_RetrievalMethod_at(self, index, value): self.RetrievalMethod[index] = value
    def get_X509Data(self): return self.X509Data
    def set_X509Data(self, X509Data): self.X509Data = X509Data
    def add_X509Data(self, value): self.X509Data.append(value)
    def insert_X509Data_at(self, index, value): self.X509Data.insert(index, value)
    def replace_X509Data_at(self, index, value): self.X509Data[index] = value
    def get_PGPData(self): return self.PGPData
    def set_PGPData(self, PGPData): self.PGPData = PGPData
    def add_PGPData(self, value): self.PGPData.append(value)
    def insert_PGPData_at(self, index, value): self.PGPData.insert(index, value)
    def replace_PGPData_at(self, index, value): self.PGPData[index] = value
    def get_SPKIData(self): return self.SPKIData
    def set_SPKIData(self, SPKIData): self.SPKIData = SPKIData
    def add_SPKIData(self, value): self.SPKIData.append(value)
    def insert_SPKIData_at(self, index, value): self.SPKIData.insert(index, value)
    def replace_SPKIData_at(self, index, value): self.SPKIData[index] = value
    def get_MgmtData(self): return self.MgmtData
    def set_MgmtData(self, MgmtData): self.MgmtData = MgmtData
    def add_MgmtData(self, value): self.MgmtData.append(value)
    def insert_MgmtData_at(self, index, value): self.MgmtData.insert(index, value)
    def replace_MgmtData_at(self, index, value): self.MgmtData[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.KeyName or
            self.KeyValue or
            self.RetrievalMethod or
            self.X509Data or
            self.PGPData or
            self.SPKIData or
            self.MgmtData or
            self.anytypeobjs_ is not None or
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='KeyInfoType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KeyInfoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='KeyInfoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='KeyInfoType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def exportChildren(self, outfile, level, namespace_='', name_='KeyInfoType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'KeyName' and child_.text is not None:
            valuestr_ = child_.text
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'KeyName', valuestr_)
            self.content_.append(obj_)
        elif nodeName_ == 'KeyValue':
            obj_ = KeyValue.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'KeyValue', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_KeyValue'):
              self.add_KeyValue(obj_.value)
            elif hasattr(self, 'set_KeyValue'):
              self.set_KeyValue(obj_.value)
        elif nodeName_ == 'RetrievalMethod':
            obj_ = RetrievalMethod.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'RetrievalMethod', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_RetrievalMethod'):
              self.add_RetrievalMethod(obj_.value)
            elif hasattr(self, 'set_RetrievalMethod'):
              self.set_RetrievalMethod(obj_.value)
        elif nodeName_ == 'X509Data':
            obj_ = X509Data.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'X509Data', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_X509Data'):
              self.add_X509Data(obj_.value)
            elif hasattr(self, 'set_X509Data'):
              self.set_X509Data(obj_.value)
        elif nodeName_ == 'PGPData':
            obj_ = PGPData.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'PGPData', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_PGPData'):
              self.add_PGPData(obj_.value)
            elif hasattr(self, 'set_PGPData'):
              self.set_PGPData(obj_.value)
        elif nodeName_ == 'SPKIData':
            obj_ = SPKIData.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'SPKIData', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_SPKIData'):
              self.add_SPKIData(obj_.value)
            elif hasattr(self, 'set_SPKIData'):
              self.set_SPKIData(obj_.value)
        elif nodeName_ == 'MgmtData' and child_.text is not None:
            valuestr_ = child_.text
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'MgmtData', valuestr_)
            self.content_.append(obj_)
        elif nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class KeyInfoType


class KeyValueType(GeneratedsSuper):
    member_data_items_ = {
        'DSAKeyValue': MemberSpec_('DSAKeyValue', 'DSAKeyValueType', 0),
        'RSAKeyValue': MemberSpec_('RSAKeyValue', 'RSAKeyValueType', 0),
        '': MemberSpec_('', 'xsd:string', 0),
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, DSAKeyValue=None, RSAKeyValue=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.DSAKeyValue = DSAKeyValue
        self.RSAKeyValue = RSAKeyValue
        self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KeyValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KeyValueType.subclass:
            return KeyValueType.subclass(*args_, **kwargs_)
        else:
            return KeyValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DSAKeyValue(self): return self.DSAKeyValue
    def set_DSAKeyValue(self, DSAKeyValue): self.DSAKeyValue = DSAKeyValue
    def get_RSAKeyValue(self): return self.RSAKeyValue
    def set_RSAKeyValue(self, RSAKeyValue): self.RSAKeyValue = RSAKeyValue
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.DSAKeyValue is not None or
            self.RSAKeyValue is not None or
            self.anytypeobjs_ is not None or
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='KeyValueType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KeyValueType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='KeyValueType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='KeyValueType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='KeyValueType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DSAKeyValue':
            obj_ = DSAKeyValue.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'DSAKeyValue', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_DSAKeyValue'):
              self.add_DSAKeyValue(obj_.value)
            elif hasattr(self, 'set_DSAKeyValue'):
              self.set_DSAKeyValue(obj_.value)
        elif nodeName_ == 'RSAKeyValue':
            obj_ = RSAKeyValue.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'RSAKeyValue', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_RSAKeyValue'):
              self.add_RSAKeyValue(obj_.value)
            elif hasattr(self, 'set_RSAKeyValue'):
              self.set_RSAKeyValue(obj_.value)
        elif nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class KeyValueType


class RetrievalMethodType(GeneratedsSuper):
    member_data_items_ = {
        'URI': MemberSpec_('URI', 'anyURI', 0),
        'Type': MemberSpec_('Type', 'anyURI', 0),
        'Transforms': MemberSpec_('Transforms', 'TransformsType', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, URI=None, Type=None, Transforms=None):
        self.original_tagname_ = None
        self.URI = _cast(None, URI)
        self.Type = _cast(None, Type)
        self.Transforms = Transforms
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RetrievalMethodType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RetrievalMethodType.subclass:
            return RetrievalMethodType.subclass(*args_, **kwargs_)
        else:
            return RetrievalMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Transforms(self): return self.Transforms
    def set_Transforms(self, Transforms): self.Transforms = Transforms
    def get_URI(self): return self.URI
    def set_URI(self, URI): self.URI = URI
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def hasContent_(self):
        if (
            self.Transforms is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RetrievalMethodType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RetrievalMethodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RetrievalMethodType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RetrievalMethodType'):
        if self.URI is not None and 'URI' not in already_processed:
            already_processed.add('URI')
            outfile.write(' URI=%s' % (quote_attrib(self.URI), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RetrievalMethodType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Transforms is not None:
            self.Transforms.export(outfile, level, namespace_='ds:', name_='Transforms', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('URI', node)
        if value is not None and 'URI' not in already_processed:
            already_processed.add('URI')
            self.URI = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Transforms':
            obj_ = TransformsType.factory()
            obj_.build(child_)
            self.Transforms = obj_
            obj_.original_tagname_ = 'Transforms'
# end class RetrievalMethodType


class X509DataType(GeneratedsSuper):
    member_data_items_ = {
        'X509IssuerSerial': MemberSpec_('X509IssuerSerial', 'X509IssuerSerialType', 1),
        'X509SKI': MemberSpec_('X509SKI', 'xsd:string', 1),
        'X509SubjectName': MemberSpec_('X509SubjectName', 'xsd:string', 1),
        'X509Certificate': MemberSpec_('X509Certificate', 'xsd:string', 1),
        'X509CRL': MemberSpec_('X509CRL', 'xsd:string', 1),
        '': MemberSpec_('', 'xsd:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, X509IssuerSerial=None, X509SKI=None, X509SubjectName=None, X509Certificate=None, X509CRL=None, anytypeobjs_=None):
        self.original_tagname_ = None
        if X509IssuerSerial is None:
            self.X509IssuerSerial = []
        else:
            self.X509IssuerSerial = X509IssuerSerial
        if X509SKI is None:
            self.X509SKI = []
        else:
            self.X509SKI = X509SKI
        if X509SubjectName is None:
            self.X509SubjectName = []
        else:
            self.X509SubjectName = X509SubjectName
        if X509Certificate is None:
            self.X509Certificate = []
        else:
            self.X509Certificate = X509Certificate
        if X509CRL is None:
            self.X509CRL = []
        else:
            self.X509CRL = X509CRL
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, X509DataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if X509DataType.subclass:
            return X509DataType.subclass(*args_, **kwargs_)
        else:
            return X509DataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_X509IssuerSerial(self): return self.X509IssuerSerial
    def set_X509IssuerSerial(self, X509IssuerSerial): self.X509IssuerSerial = X509IssuerSerial
    def add_X509IssuerSerial(self, value): self.X509IssuerSerial.append(value)
    def insert_X509IssuerSerial_at(self, index, value): self.X509IssuerSerial.insert(index, value)
    def replace_X509IssuerSerial_at(self, index, value): self.X509IssuerSerial[index] = value
    def get_X509SKI(self): return self.X509SKI
    def set_X509SKI(self, X509SKI): self.X509SKI = X509SKI
    def add_X509SKI(self, value): self.X509SKI.append(value)
    def insert_X509SKI_at(self, index, value): self.X509SKI.insert(index, value)
    def replace_X509SKI_at(self, index, value): self.X509SKI[index] = value
    def get_X509SubjectName(self): return self.X509SubjectName
    def set_X509SubjectName(self, X509SubjectName): self.X509SubjectName = X509SubjectName
    def add_X509SubjectName(self, value): self.X509SubjectName.append(value)
    def insert_X509SubjectName_at(self, index, value): self.X509SubjectName.insert(index, value)
    def replace_X509SubjectName_at(self, index, value): self.X509SubjectName[index] = value
    def get_X509Certificate(self): return self.X509Certificate
    def set_X509Certificate(self, X509Certificate): self.X509Certificate = X509Certificate
    def add_X509Certificate(self, value): self.X509Certificate.append(value)
    def insert_X509Certificate_at(self, index, value): self.X509Certificate.insert(index, value)
    def replace_X509Certificate_at(self, index, value): self.X509Certificate[index] = value
    def get_X509CRL(self): return self.X509CRL
    def set_X509CRL(self, X509CRL): self.X509CRL = X509CRL
    def add_X509CRL(self, value): self.X509CRL.append(value)
    def insert_X509CRL_at(self, index, value): self.X509CRL.insert(index, value)
    def replace_X509CRL_at(self, index, value): self.X509CRL[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def hasContent_(self):
        if (
            self.X509IssuerSerial or
            self.X509SKI or
            self.X509SubjectName or
            self.X509Certificate or
            self.X509CRL or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='X509DataType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='X509DataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='X509DataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='X509DataType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='X509DataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for X509IssuerSerial_ in self.X509IssuerSerial:
            X509IssuerSerial_.export(outfile, level, namespace_, name_='X509IssuerSerial', pretty_print=pretty_print)
        for X509SKI_ in self.X509SKI:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sX509SKI>%s</%sX509SKI>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(X509SKI_), input_name='X509SKI')), namespace_, eol_))
        for X509SubjectName_ in self.X509SubjectName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sX509SubjectName>%s</%sX509SubjectName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(X509SubjectName_), input_name='X509SubjectName')), namespace_, eol_))
        for X509Certificate_ in self.X509Certificate:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sX509Certificate>%s</%sX509Certificate>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(X509Certificate_), input_name='X509Certificate')), namespace_, eol_))
        for X509CRL_ in self.X509CRL:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sX509CRL>%s</%sX509CRL>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(X509CRL_), input_name='X509CRL')), namespace_, eol_))
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'X509IssuerSerial':
            obj_ = X509IssuerSerialType.factory()
            obj_.build(child_)
            self.X509IssuerSerial.append(obj_)
            obj_.original_tagname_ = 'X509IssuerSerial'
        elif nodeName_ == 'X509SKI':
            X509SKI_ = child_.text
            X509SKI_ = self.gds_validate_string(X509SKI_, node, 'X509SKI')
            self.X509SKI.append(X509SKI_)
        elif nodeName_ == 'X509SubjectName':
            X509SubjectName_ = child_.text
            X509SubjectName_ = self.gds_validate_string(X509SubjectName_, node, 'X509SubjectName')
            self.X509SubjectName.append(X509SubjectName_)
        elif nodeName_ == 'X509Certificate':
            X509Certificate_ = child_.text
            X509Certificate_ = self.gds_validate_string(X509Certificate_, node, 'X509Certificate')
            self.X509Certificate.append(X509Certificate_)
        elif nodeName_ == 'X509CRL':
            X509CRL_ = child_.text
            X509CRL_ = self.gds_validate_string(X509CRL_, node, 'X509CRL')
            self.X509CRL.append(X509CRL_)
        else:
            obj_ = self.gds_build_any(child_, 'X509DataType')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class X509DataType


class X509IssuerSerialType(GeneratedsSuper):
    member_data_items_ = {
        'X509IssuerName': MemberSpec_('X509IssuerName', 'xsd:string', 0),
        'X509SerialNumber': MemberSpec_('X509SerialNumber', 'xsd:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, X509IssuerName=None, X509SerialNumber=None):
        self.original_tagname_ = None
        self.X509IssuerName = X509IssuerName
        self.X509SerialNumber = X509SerialNumber
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, X509IssuerSerialType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if X509IssuerSerialType.subclass:
            return X509IssuerSerialType.subclass(*args_, **kwargs_)
        else:
            return X509IssuerSerialType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_X509IssuerName(self): return self.X509IssuerName
    def set_X509IssuerName(self, X509IssuerName): self.X509IssuerName = X509IssuerName
    def get_X509SerialNumber(self): return self.X509SerialNumber
    def set_X509SerialNumber(self, X509SerialNumber): self.X509SerialNumber = X509SerialNumber
    def hasContent_(self):
        if (
            self.X509IssuerName is not None or
            self.X509SerialNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='X509IssuerSerialType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='X509IssuerSerialType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='X509IssuerSerialType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='X509IssuerSerialType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='X509IssuerSerialType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.X509IssuerName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sX509IssuerName>%s</%sX509IssuerName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.X509IssuerName), input_name='X509IssuerName')), namespace_, eol_))
        if self.X509SerialNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sX509SerialNumber>%s</%sX509SerialNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.X509SerialNumber), input_name='X509SerialNumber')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'X509IssuerName':
            X509IssuerName_ = child_.text
            X509IssuerName_ = self.gds_validate_string(X509IssuerName_, node, 'X509IssuerName')
            self.X509IssuerName = X509IssuerName_
        elif nodeName_ == 'X509SerialNumber':
            X509SerialNumber_ = child_.text
            X509SerialNumber_ = self.gds_validate_string(X509SerialNumber_, node, 'X509SerialNumber')
            self.X509SerialNumber = X509SerialNumber_
# end class X509IssuerSerialType


class PGPDataType(GeneratedsSuper):
    member_data_items_ = {
        'PGPKeyID': MemberSpec_('PGPKeyID', 'xsd:string', 0),
        'PGPKeyPacket': MemberSpec_('PGPKeyPacket', 'xsd:string', 0),
        '': MemberSpec_('', 'xsd:string', 1),
        'PGPKeyPacket': MemberSpec_('PGPKeyPacket', 'xsd:string', 0),
        '': MemberSpec_('', 'xsd:string', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, PGPKeyID=None, PGPKeyPacket=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.PGPKeyID = PGPKeyID
        self.PGPKeyPacket = PGPKeyPacket
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.PGPKeyPacket = PGPKeyPacket
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PGPDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PGPDataType.subclass:
            return PGPDataType.subclass(*args_, **kwargs_)
        else:
            return PGPDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PGPKeyID(self): return self.PGPKeyID
    def set_PGPKeyID(self, PGPKeyID): self.PGPKeyID = PGPKeyID
    def get_PGPKeyPacket(self): return self.PGPKeyPacket
    def set_PGPKeyPacket(self, PGPKeyPacket): self.PGPKeyPacket = PGPKeyPacket
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_PGPKeyPacket(self): return self.PGPKeyPacket
    def set_PGPKeyPacket(self, PGPKeyPacket): self.PGPKeyPacket = PGPKeyPacket
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.PGPKeyID is not None or
            self.PGPKeyPacket is not None or
            self.anytypeobjs_ or
            self.PGPKeyPacket is not None or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PGPDataType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PGPDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PGPDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PGPDataType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PGPDataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PGPKeyID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPGPKeyID>%s</%sPGPKeyID>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PGPKeyID), input_name='PGPKeyID')), namespace_, eol_))
        if self.PGPKeyPacket is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPGPKeyPacket>%s</%sPGPKeyPacket>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PGPKeyPacket), input_name='PGPKeyPacket')), namespace_, eol_))
        if self.PGPKeyPacket is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPGPKeyPacket>%s</%sPGPKeyPacket>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PGPKeyPacket), input_name='PGPKeyPacket')), namespace_, eol_))
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PGPKeyID':
            PGPKeyID_ = child_.text
            PGPKeyID_ = self.gds_validate_string(PGPKeyID_, node, 'PGPKeyID')
            self.PGPKeyID = PGPKeyID_
        elif nodeName_ == 'PGPKeyPacket':
            PGPKeyPacket_ = child_.text
            PGPKeyPacket_ = self.gds_validate_string(PGPKeyPacket_, node, 'PGPKeyPacket')
            self.PGPKeyPacket = PGPKeyPacket_
        elif nodeName_ == 'PGPKeyPacket':
            PGPKeyPacket_ = child_.text
            PGPKeyPacket_ = self.gds_validate_string(PGPKeyPacket_, node, 'PGPKeyPacket')
            self.PGPKeyPacket = PGPKeyPacket_
        else:
            obj_ = self.gds_build_any(child_, 'PGPDataType')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class PGPDataType


class SPKIDataType(GeneratedsSuper):
    member_data_items_ = {
        'SPKISexp': MemberSpec_('SPKISexp', 'xsd:string', 1),
        '': MemberSpec_('', 'xsd:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, SPKISexp=None, anytypeobjs_=None):
        self.original_tagname_ = None
        if SPKISexp is None:
            self.SPKISexp = []
        else:
            self.SPKISexp = SPKISexp
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SPKIDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SPKIDataType.subclass:
            return SPKIDataType.subclass(*args_, **kwargs_)
        else:
            return SPKIDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SPKISexp(self): return self.SPKISexp
    def set_SPKISexp(self, SPKISexp): self.SPKISexp = SPKISexp
    def add_SPKISexp(self, value): self.SPKISexp.append(value)
    def insert_SPKISexp_at(self, index, value): self.SPKISexp.insert(index, value)
    def replace_SPKISexp_at(self, index, value): self.SPKISexp[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def hasContent_(self):
        if (
            self.SPKISexp or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SPKIDataType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SPKIDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SPKIDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SPKIDataType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SPKIDataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SPKISexp_ in self.SPKISexp:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSPKISexp>%s</%sSPKISexp>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(SPKISexp_), input_name='SPKISexp')), namespace_, eol_))
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SPKISexp':
            SPKISexp_ = child_.text
            SPKISexp_ = self.gds_validate_string(SPKISexp_, node, 'SPKISexp')
            self.SPKISexp.append(SPKISexp_)
        else:
            obj_ = self.gds_build_any(child_, 'SPKIDataType')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class SPKIDataType


class ObjectType(GeneratedsSuper):
    member_data_items_ = {
        'Id': MemberSpec_('Id', 'ID', 0),
        'MimeType': MemberSpec_('MimeType', 'xsd:string', 0),
        'Encoding': MemberSpec_('Encoding', 'anyURI', 0),
        '': MemberSpec_('', 'xsd:string', 0),
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, Id=None, MimeType=None, Encoding=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        self.MimeType = _cast(None, MimeType)
        self.Encoding = _cast(None, Encoding)
        self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ObjectType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ObjectType.subclass:
            return ObjectType.subclass(*args_, **kwargs_)
        else:
            return ObjectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_MimeType(self): return self.MimeType
    def set_MimeType(self, MimeType): self.MimeType = MimeType
    def get_Encoding(self): return self.Encoding
    def set_Encoding(self, Encoding): self.Encoding = Encoding
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.anytypeobjs_ is not None or
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ObjectType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObjectType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ObjectType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ObjectType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
        if self.MimeType is not None and 'MimeType' not in already_processed:
            already_processed.add('MimeType')
            outfile.write(' MimeType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.MimeType), input_name='MimeType')), ))
        if self.Encoding is not None and 'Encoding' not in already_processed:
            already_processed.add('Encoding')
            outfile.write(' Encoding=%s' % (quote_attrib(self.Encoding), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ObjectType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
        value = find_attr_value_('MimeType', node)
        if value is not None and 'MimeType' not in already_processed:
            already_processed.add('MimeType')
            self.MimeType = value
        value = find_attr_value_('Encoding', node)
        if value is not None and 'Encoding' not in already_processed:
            already_processed.add('Encoding')
            self.Encoding = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class ObjectType


class ManifestType(GeneratedsSuper):
    member_data_items_ = {
        'Id': MemberSpec_('Id', 'ID', 0),
        'Reference': MemberSpec_('Reference', 'ReferenceType', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, Id=None, Reference=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        if Reference is None:
            self.Reference = []
        else:
            self.Reference = Reference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ManifestType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ManifestType.subclass:
            return ManifestType.subclass(*args_, **kwargs_)
        else:
            return ManifestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Reference(self): return self.Reference
    def set_Reference(self, Reference): self.Reference = Reference
    def add_Reference(self, value): self.Reference.append(value)
    def insert_Reference_at(self, index, value): self.Reference.insert(index, value)
    def replace_Reference_at(self, index, value): self.Reference[index] = value
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def hasContent_(self):
        if (
            self.Reference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ManifestType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ManifestType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ManifestType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ManifestType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ManifestType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Reference_ in self.Reference:
            Reference_.export(outfile, level, namespace_='ds:', name_='Reference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Reference':
            obj_ = ReferenceType.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'Reference'
# end class ManifestType


class SignaturePropertiesType(GeneratedsSuper):
    member_data_items_ = {
        'Id': MemberSpec_('Id', 'ID', 0),
        'SignatureProperty': MemberSpec_('SignatureProperty', 'SignaturePropertyType', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, Id=None, SignatureProperty=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        if SignatureProperty is None:
            self.SignatureProperty = []
        else:
            self.SignatureProperty = SignatureProperty
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignaturePropertiesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignaturePropertiesType.subclass:
            return SignaturePropertiesType.subclass(*args_, **kwargs_)
        else:
            return SignaturePropertiesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SignatureProperty(self): return self.SignatureProperty
    def set_SignatureProperty(self, SignatureProperty): self.SignatureProperty = SignatureProperty
    def add_SignatureProperty(self, value): self.SignatureProperty.append(value)
    def insert_SignatureProperty_at(self, index, value): self.SignatureProperty.insert(index, value)
    def replace_SignatureProperty_at(self, index, value): self.SignatureProperty[index] = value
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def hasContent_(self):
        if (
            self.SignatureProperty
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SignaturePropertiesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SignaturePropertiesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SignaturePropertiesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SignaturePropertiesType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SignaturePropertiesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SignatureProperty_ in self.SignatureProperty:
            SignatureProperty_.export(outfile, level, namespace_='ds:', name_='SignatureProperty', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SignatureProperty':
            obj_ = SignaturePropertyType.factory()
            obj_.build(child_)
            self.SignatureProperty.append(obj_)
            obj_.original_tagname_ = 'SignatureProperty'
# end class SignaturePropertiesType


class SignaturePropertyType(GeneratedsSuper):
    member_data_items_ = {
        'Target': MemberSpec_('Target', 'anyURI', 0),
        'Id': MemberSpec_('Id', 'ID', 0),
        '': MemberSpec_('', 'xsd:string', 0),
        'valueOf_': MemberSpec_('valueOf_', [], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, Target=None, Id=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.Target = _cast(None, Target)
        self.Id = _cast(None, Id)
        self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignaturePropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignaturePropertyType.subclass:
            return SignaturePropertyType.subclass(*args_, **kwargs_)
        else:
            return SignaturePropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_Target(self): return self.Target
    def set_Target(self, Target): self.Target = Target
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.anytypeobjs_ is not None or
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SignaturePropertyType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SignaturePropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SignaturePropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SignaturePropertyType'):
        if self.Target is not None and 'Target' not in already_processed:
            already_processed.add('Target')
            outfile.write(' Target=%s' % (quote_attrib(self.Target), ))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SignaturePropertyType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Target', node)
        if value is not None and 'Target' not in already_processed:
            already_processed.add('Target')
            self.Target = value
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class SignaturePropertyType


class DSAKeyValueType(GeneratedsSuper):
    member_data_items_ = {
        'P': MemberSpec_('P', ['CryptoBinary', 'base64Binary'], 0),
        'Q': MemberSpec_('Q', ['CryptoBinary', 'base64Binary'], 0),
        'G': MemberSpec_('G', ['CryptoBinary', 'base64Binary'], 0),
        'Y': MemberSpec_('Y', ['CryptoBinary', 'base64Binary'], 0),
        'J': MemberSpec_('J', ['CryptoBinary', 'base64Binary'], 0),
        'Seed': MemberSpec_('Seed', ['CryptoBinary', 'base64Binary'], 0),
        'PgenCounter': MemberSpec_('PgenCounter', ['CryptoBinary', 'base64Binary'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, P=None, Q=None, G=None, Y=None, J=None, Seed=None, PgenCounter=None):
        self.original_tagname_ = None
        self.P = P
        self.validate_CryptoBinary(self.P)
        self.Q = Q
        self.validate_CryptoBinary(self.Q)
        self.G = G
        self.validate_CryptoBinary(self.G)
        self.Y = Y
        self.validate_CryptoBinary(self.Y)
        self.J = J
        self.validate_CryptoBinary(self.J)
        self.Seed = Seed
        self.validate_CryptoBinary(self.Seed)
        self.PgenCounter = PgenCounter
        self.validate_CryptoBinary(self.PgenCounter)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DSAKeyValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DSAKeyValueType.subclass:
            return DSAKeyValueType.subclass(*args_, **kwargs_)
        else:
            return DSAKeyValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_P(self): return self.P
    def set_P(self, P): self.P = P
    def get_Q(self): return self.Q
    def set_Q(self, Q): self.Q = Q
    def get_G(self): return self.G
    def set_G(self, G): self.G = G
    def get_Y(self): return self.Y
    def set_Y(self, Y): self.Y = Y
    def get_J(self): return self.J
    def set_J(self, J): self.J = J
    def get_Seed(self): return self.Seed
    def set_Seed(self, Seed): self.Seed = Seed
    def get_PgenCounter(self): return self.PgenCounter
    def set_PgenCounter(self, PgenCounter): self.PgenCounter = PgenCounter
    def validate_CryptoBinary(self, value):
        # Validate type CryptoBinary, a restriction on base64Binary.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.P is not None or
            self.Q is not None or
            self.G is not None or
            self.Y is not None or
            self.J is not None or
            self.Seed is not None or
            self.PgenCounter is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DSAKeyValueType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DSAKeyValueType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DSAKeyValueType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DSAKeyValueType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DSAKeyValueType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.P is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sP>%s</%sP>%s' % (namespace_, self.gds_format_base64(self.P, input_name='P'), namespace_, eol_))
        if self.Q is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sQ>%s</%sQ>%s' % (namespace_, self.gds_format_base64(self.Q, input_name='Q'), namespace_, eol_))
        if self.G is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sG>%s</%sG>%s' % (namespace_, self.gds_format_base64(self.G, input_name='G'), namespace_, eol_))
        if self.Y is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sY>%s</%sY>%s' % (namespace_, self.gds_format_base64(self.Y, input_name='Y'), namespace_, eol_))
        if self.J is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sJ>%s</%sJ>%s' % (namespace_, self.gds_format_base64(self.J, input_name='J'), namespace_, eol_))
        if self.Seed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSeed>%s</%sSeed>%s' % (namespace_, self.gds_format_base64(self.Seed, input_name='Seed'), namespace_, eol_))
        if self.PgenCounter is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPgenCounter>%s</%sPgenCounter>%s' % (namespace_, self.gds_format_base64(self.PgenCounter, input_name='PgenCounter'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'P':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'P')
            else:
                bval_ = None
            self.P = bval_
            # validate type CryptoBinary
            self.validate_CryptoBinary(self.P)
        elif nodeName_ == 'Q':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'Q')
            else:
                bval_ = None
            self.Q = bval_
            # validate type CryptoBinary
            self.validate_CryptoBinary(self.Q)
        elif nodeName_ == 'G':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'G')
            else:
                bval_ = None
            self.G = bval_
            # validate type CryptoBinary
            self.validate_CryptoBinary(self.G)
        elif nodeName_ == 'Y':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'Y')
            else:
                bval_ = None
            self.Y = bval_
            # validate type CryptoBinary
            self.validate_CryptoBinary(self.Y)
        elif nodeName_ == 'J':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'J')
            else:
                bval_ = None
            self.J = bval_
            # validate type CryptoBinary
            self.validate_CryptoBinary(self.J)
        elif nodeName_ == 'Seed':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'Seed')
            else:
                bval_ = None
            self.Seed = bval_
            # validate type CryptoBinary
            self.validate_CryptoBinary(self.Seed)
        elif nodeName_ == 'PgenCounter':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'PgenCounter')
            else:
                bval_ = None
            self.PgenCounter = bval_
            # validate type CryptoBinary
            self.validate_CryptoBinary(self.PgenCounter)
# end class DSAKeyValueType


class RSAKeyValueType(GeneratedsSuper):
    member_data_items_ = {
        'Modulus': MemberSpec_('Modulus', ['CryptoBinary', 'base64Binary'], 0),
        'Exponent': MemberSpec_('Exponent', ['CryptoBinary', 'base64Binary'], 0),
    }
    subclass = None
    superclass = None
    def __init__(self, Modulus=None, Exponent=None):
        self.original_tagname_ = None
        self.Modulus = Modulus
        self.validate_CryptoBinary(self.Modulus)
        self.Exponent = Exponent
        self.validate_CryptoBinary(self.Exponent)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RSAKeyValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RSAKeyValueType.subclass:
            return RSAKeyValueType.subclass(*args_, **kwargs_)
        else:
            return RSAKeyValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Modulus(self): return self.Modulus
    def set_Modulus(self, Modulus): self.Modulus = Modulus
    def get_Exponent(self): return self.Exponent
    def set_Exponent(self, Exponent): self.Exponent = Exponent
    def validate_CryptoBinary(self, value):
        # Validate type CryptoBinary, a restriction on base64Binary.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Modulus is not None or
            self.Exponent is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RSAKeyValueType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RSAKeyValueType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RSAKeyValueType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RSAKeyValueType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RSAKeyValueType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Modulus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sModulus>%s</%sModulus>%s' % (namespace_, self.gds_format_base64(self.Modulus, input_name='Modulus'), namespace_, eol_))
        if self.Exponent is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExponent>%s</%sExponent>%s' % (namespace_, self.gds_format_base64(self.Exponent, input_name='Exponent'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Modulus':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'Modulus')
            else:
                bval_ = None
            self.Modulus = bval_
            # validate type CryptoBinary
            self.validate_CryptoBinary(self.Modulus)
        elif nodeName_ == 'Exponent':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'Exponent')
            else:
                bval_ = None
            self.Exponent = bval_
            # validate type CryptoBinary
            self.validate_CryptoBinary(self.Exponent)
# end class RSAKeyValueType


class originalMessageType(GeneratedsSuper):
    member_data_items_ = {
        '': MemberSpec_('', 'xsd:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None):
        self.original_tagname_ = None
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, originalMessageType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if originalMessageType.subclass:
            return originalMessageType.subclass(*args_, **kwargs_)
        else:
            return originalMessageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def hasContent_(self):
        if (
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='originalMessageType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='originalMessageType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='originalMessageType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='originalMessageType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='originalMessageType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'originalMessageType')
        if obj_ is not None:
            self.set_anytypeobjs_(obj_)
# end class originalMessageType


class currencySpecificDayCountType(GeneratedsSuper):
    member_data_items_ = {
        'dayCountValue': MemberSpec_('dayCountValue', 'DayCountDenominator', 0),
        'currency': MemberSpec_('currency', 'Currency', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, dayCountValue=None, currency=None):
        self.original_tagname_ = None
        self.dayCountValue = dayCountValue
        self.currency = currency
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, currencySpecificDayCountType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if currencySpecificDayCountType.subclass:
            return currencySpecificDayCountType.subclass(*args_, **kwargs_)
        else:
            return currencySpecificDayCountType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dayCountValue(self): return self.dayCountValue
    def set_dayCountValue(self, dayCountValue): self.dayCountValue = dayCountValue
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def hasContent_(self):
        if (
            self.dayCountValue is not None or
            self.currency is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='currencySpecificDayCountType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='currencySpecificDayCountType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='currencySpecificDayCountType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='currencySpecificDayCountType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='currencySpecificDayCountType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dayCountValue is not None:
            self.dayCountValue.export(outfile, level, namespace_, name_='dayCountValue', pretty_print=pretty_print)
        if self.currency is not None:
            self.currency.export(outfile, level, namespace_, name_='currency', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dayCountValue':
            obj_ = DayCountDenominator.factory()
            obj_.build(child_)
            self.dayCountValue = obj_
            obj_.original_tagname_ = 'dayCountValue'
        elif nodeName_ == 'currency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
# end class currencySpecificDayCountType


class StandardCreditSupportAnnex2014NewYorkLaw(StandardCreditSupportAnnexBase):
    """The New York Law 2014 SCSA implementation, which extends
    StandardCreditSupportAnnexBase.Provisions that are specific to
    the New York Law document."""
    member_data_items_ = {
        'demandsAndNotices': MemberSpec_('demandsAndNotices', 'PartyContactInformation', 1),
        'independentAmountEligibleCreditSupport': MemberSpec_('independentAmountEligibleCreditSupport', 'IndependentAmountEligibleCollateral', 1),
        'useOfPostedCreditSupport': MemberSpec_('useOfPostedCreditSupport', 'UseOfPostedCreditSupport', 1),
        'valuationDateCity': MemberSpec_('valuationDateCity', 'BusinessCenters', 0),
        'notificationTimeCity': MemberSpec_('notificationTimeCity', 'BusinessCenter', 0),
    }
    subclass = None
    superclass = StandardCreditSupportAnnexBase
    def __init__(self, id=None, documentType=None, independentAmounts=None, baseCurrency=None, existingCreditSupportAnnex=None, settlementDay=None, demandsAndNotices=None, independentAmountEligibleCreditSupport=None, useOfPostedCreditSupport=None, valuationDateCity=None, notificationTimeCity=None):
        self.original_tagname_ = None
        super(StandardCreditSupportAnnex2014NewYorkLaw, self).__init__(id, documentType, independentAmounts, baseCurrency, existingCreditSupportAnnex, settlementDay, )
        if demandsAndNotices is None:
            self.demandsAndNotices = []
        else:
            self.demandsAndNotices = demandsAndNotices
        if independentAmountEligibleCreditSupport is None:
            self.independentAmountEligibleCreditSupport = []
        else:
            self.independentAmountEligibleCreditSupport = independentAmountEligibleCreditSupport
        if useOfPostedCreditSupport is None:
            self.useOfPostedCreditSupport = []
        else:
            self.useOfPostedCreditSupport = useOfPostedCreditSupport
        self.valuationDateCity = valuationDateCity
        self.notificationTimeCity = notificationTimeCity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StandardCreditSupportAnnex2014NewYorkLaw)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StandardCreditSupportAnnex2014NewYorkLaw.subclass:
            return StandardCreditSupportAnnex2014NewYorkLaw.subclass(*args_, **kwargs_)
        else:
            return StandardCreditSupportAnnex2014NewYorkLaw(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_demandsAndNotices(self): return self.demandsAndNotices
    def set_demandsAndNotices(self, demandsAndNotices): self.demandsAndNotices = demandsAndNotices
    def add_demandsAndNotices(self, value): self.demandsAndNotices.append(value)
    def insert_demandsAndNotices_at(self, index, value): self.demandsAndNotices.insert(index, value)
    def replace_demandsAndNotices_at(self, index, value): self.demandsAndNotices[index] = value
    def get_independentAmountEligibleCreditSupport(self): return self.independentAmountEligibleCreditSupport
    def set_independentAmountEligibleCreditSupport(self, independentAmountEligibleCreditSupport): self.independentAmountEligibleCreditSupport = independentAmountEligibleCreditSupport
    def add_independentAmountEligibleCreditSupport(self, value): self.independentAmountEligibleCreditSupport.append(value)
    def insert_independentAmountEligibleCreditSupport_at(self, index, value): self.independentAmountEligibleCreditSupport.insert(index, value)
    def replace_independentAmountEligibleCreditSupport_at(self, index, value): self.independentAmountEligibleCreditSupport[index] = value
    def get_useOfPostedCreditSupport(self): return self.useOfPostedCreditSupport
    def set_useOfPostedCreditSupport(self, useOfPostedCreditSupport): self.useOfPostedCreditSupport = useOfPostedCreditSupport
    def add_useOfPostedCreditSupport(self, value): self.useOfPostedCreditSupport.append(value)
    def insert_useOfPostedCreditSupport_at(self, index, value): self.useOfPostedCreditSupport.insert(index, value)
    def replace_useOfPostedCreditSupport_at(self, index, value): self.useOfPostedCreditSupport[index] = value
    def get_valuationDateCity(self): return self.valuationDateCity
    def set_valuationDateCity(self, valuationDateCity): self.valuationDateCity = valuationDateCity
    def get_notificationTimeCity(self): return self.notificationTimeCity
    def set_notificationTimeCity(self, notificationTimeCity): self.notificationTimeCity = notificationTimeCity
    def hasContent_(self):
        if (
            self.demandsAndNotices or
            self.independentAmountEligibleCreditSupport or
            self.useOfPostedCreditSupport or
            self.valuationDateCity is not None or
            self.notificationTimeCity is not None or
            super(StandardCreditSupportAnnex2014NewYorkLaw, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StandardCreditSupportAnnex2014NewYorkLaw', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StandardCreditSupportAnnex2014NewYorkLaw')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StandardCreditSupportAnnex2014NewYorkLaw', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StandardCreditSupportAnnex2014NewYorkLaw'):
        super(StandardCreditSupportAnnex2014NewYorkLaw, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StandardCreditSupportAnnex2014NewYorkLaw')
    def exportChildren(self, outfile, level, namespace_='', name_='StandardCreditSupportAnnex2014NewYorkLaw', fromsubclass_=False, pretty_print=True):
        super(StandardCreditSupportAnnex2014NewYorkLaw, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for demandsAndNotices_ in self.demandsAndNotices:
            demandsAndNotices_.export(outfile, level, namespace_, name_='demandsAndNotices', pretty_print=pretty_print)
        for independentAmountEligibleCreditSupport_ in self.independentAmountEligibleCreditSupport:
            independentAmountEligibleCreditSupport_.export(outfile, level, namespace_, name_='independentAmountEligibleCreditSupport', pretty_print=pretty_print)
        for useOfPostedCreditSupport_ in self.useOfPostedCreditSupport:
            useOfPostedCreditSupport_.export(outfile, level, namespace_, name_='useOfPostedCreditSupport', pretty_print=pretty_print)
        if self.valuationDateCity is not None:
            self.valuationDateCity.export(outfile, level, namespace_, name_='valuationDateCity', pretty_print=pretty_print)
        if self.notificationTimeCity is not None:
            self.notificationTimeCity.export(outfile, level, namespace_, name_='notificationTimeCity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(StandardCreditSupportAnnex2014NewYorkLaw, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'demandsAndNotices':
            obj_ = PartyContactInformation.factory()
            obj_.build(child_)
            self.demandsAndNotices.append(obj_)
            obj_.original_tagname_ = 'demandsAndNotices'
        elif nodeName_ == 'independentAmountEligibleCreditSupport':
            obj_ = IndependentAmountEligibleCollateral.factory()
            obj_.build(child_)
            self.independentAmountEligibleCreditSupport.append(obj_)
            obj_.original_tagname_ = 'independentAmountEligibleCreditSupport'
        elif nodeName_ == 'useOfPostedCreditSupport':
            obj_ = UseOfPostedCreditSupport.factory()
            obj_.build(child_)
            self.useOfPostedCreditSupport.append(obj_)
            obj_.original_tagname_ = 'useOfPostedCreditSupport'
        elif nodeName_ == 'valuationDateCity':
            obj_ = BusinessCenters.factory()
            obj_.build(child_)
            self.valuationDateCity = obj_
            obj_.original_tagname_ = 'valuationDateCity'
        elif nodeName_ == 'notificationTimeCity':
            obj_ = BusinessCenter.factory()
            obj_.build(child_)
            self.notificationTimeCity = obj_
            obj_.original_tagname_ = 'notificationTimeCity'
        super(StandardCreditSupportAnnex2014NewYorkLaw, self).buildChildren(child_, node, nodeName_, True)
# end class StandardCreditSupportAnnex2014NewYorkLaw


class StandardCreditSupportAnnex2013NewYorkLaw(StandardCreditSupportAnnexBase):
    """The New York Law 2013 SCSA implementation, which extends
    StandardCreditSupportAnnexBase.Provisions that are specific to
    the New York Law document."""
    member_data_items_ = {
        'disputeResolution': MemberSpec_('disputeResolution', 'DisputeResolution', 0),
        'demandsAndNotices': MemberSpec_('demandsAndNotices', 'PartyContactInformation', 1),
        'otherProvisions': MemberSpec_('otherProvisions', 'OtherProvisions', 0),
        'transportCurrency': MemberSpec_('transportCurrency', 'TransportCurrency', 1),
        'dayCount': MemberSpec_('dayCount', 'DayCount', 0),
        'independentAmountInterestRate': MemberSpec_('independentAmountInterestRate', 'IndependentAmountInterestRate', 0),
        'independentAmountEligibleCollateral': MemberSpec_('independentAmountEligibleCollateral', 'IndependentAmountEligibleCollateral', 1),
        'holdingAndUsingPostedCollateral': MemberSpec_('holdingAndUsingPostedCollateral', 'HoldingAndUsingPostedCollateral', 1),
    }
    subclass = None
    superclass = StandardCreditSupportAnnexBase
    def __init__(self, id=None, documentType=None, independentAmounts=None, baseCurrency=None, existingCreditSupportAnnex=None, settlementDay=None, disputeResolution=None, demandsAndNotices=None, otherProvisions=None, transportCurrency=None, dayCount=None, independentAmountInterestRate=None, independentAmountEligibleCollateral=None, holdingAndUsingPostedCollateral=None):
        self.original_tagname_ = None
        super(StandardCreditSupportAnnex2013NewYorkLaw, self).__init__(id, documentType, independentAmounts, baseCurrency, existingCreditSupportAnnex, settlementDay, )
        self.disputeResolution = disputeResolution
        if demandsAndNotices is None:
            self.demandsAndNotices = []
        else:
            self.demandsAndNotices = demandsAndNotices
        self.otherProvisions = otherProvisions
        if transportCurrency is None:
            self.transportCurrency = []
        else:
            self.transportCurrency = transportCurrency
        self.dayCount = dayCount
        self.independentAmountInterestRate = independentAmountInterestRate
        if independentAmountEligibleCollateral is None:
            self.independentAmountEligibleCollateral = []
        else:
            self.independentAmountEligibleCollateral = independentAmountEligibleCollateral
        if holdingAndUsingPostedCollateral is None:
            self.holdingAndUsingPostedCollateral = []
        else:
            self.holdingAndUsingPostedCollateral = holdingAndUsingPostedCollateral
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StandardCreditSupportAnnex2013NewYorkLaw)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StandardCreditSupportAnnex2013NewYorkLaw.subclass:
            return StandardCreditSupportAnnex2013NewYorkLaw.subclass(*args_, **kwargs_)
        else:
            return StandardCreditSupportAnnex2013NewYorkLaw(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_disputeResolution(self): return self.disputeResolution
    def set_disputeResolution(self, disputeResolution): self.disputeResolution = disputeResolution
    def get_demandsAndNotices(self): return self.demandsAndNotices
    def set_demandsAndNotices(self, demandsAndNotices): self.demandsAndNotices = demandsAndNotices
    def add_demandsAndNotices(self, value): self.demandsAndNotices.append(value)
    def insert_demandsAndNotices_at(self, index, value): self.demandsAndNotices.insert(index, value)
    def replace_demandsAndNotices_at(self, index, value): self.demandsAndNotices[index] = value
    def get_otherProvisions(self): return self.otherProvisions
    def set_otherProvisions(self, otherProvisions): self.otherProvisions = otherProvisions
    def get_transportCurrency(self): return self.transportCurrency
    def set_transportCurrency(self, transportCurrency): self.transportCurrency = transportCurrency
    def add_transportCurrency(self, value): self.transportCurrency.append(value)
    def insert_transportCurrency_at(self, index, value): self.transportCurrency.insert(index, value)
    def replace_transportCurrency_at(self, index, value): self.transportCurrency[index] = value
    def get_dayCount(self): return self.dayCount
    def set_dayCount(self, dayCount): self.dayCount = dayCount
    def get_independentAmountInterestRate(self): return self.independentAmountInterestRate
    def set_independentAmountInterestRate(self, independentAmountInterestRate): self.independentAmountInterestRate = independentAmountInterestRate
    def get_independentAmountEligibleCollateral(self): return self.independentAmountEligibleCollateral
    def set_independentAmountEligibleCollateral(self, independentAmountEligibleCollateral): self.independentAmountEligibleCollateral = independentAmountEligibleCollateral
    def add_independentAmountEligibleCollateral(self, value): self.independentAmountEligibleCollateral.append(value)
    def insert_independentAmountEligibleCollateral_at(self, index, value): self.independentAmountEligibleCollateral.insert(index, value)
    def replace_independentAmountEligibleCollateral_at(self, index, value): self.independentAmountEligibleCollateral[index] = value
    def get_holdingAndUsingPostedCollateral(self): return self.holdingAndUsingPostedCollateral
    def set_holdingAndUsingPostedCollateral(self, holdingAndUsingPostedCollateral): self.holdingAndUsingPostedCollateral = holdingAndUsingPostedCollateral
    def add_holdingAndUsingPostedCollateral(self, value): self.holdingAndUsingPostedCollateral.append(value)
    def insert_holdingAndUsingPostedCollateral_at(self, index, value): self.holdingAndUsingPostedCollateral.insert(index, value)
    def replace_holdingAndUsingPostedCollateral_at(self, index, value): self.holdingAndUsingPostedCollateral[index] = value
    def hasContent_(self):
        if (
            self.disputeResolution is not None or
            self.demandsAndNotices or
            self.otherProvisions is not None or
            self.transportCurrency or
            self.dayCount is not None or
            self.independentAmountInterestRate is not None or
            self.independentAmountEligibleCollateral or
            self.holdingAndUsingPostedCollateral or
            super(StandardCreditSupportAnnex2013NewYorkLaw, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StandardCreditSupportAnnex2013NewYorkLaw', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StandardCreditSupportAnnex2013NewYorkLaw')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StandardCreditSupportAnnex2013NewYorkLaw', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StandardCreditSupportAnnex2013NewYorkLaw'):
        super(StandardCreditSupportAnnex2013NewYorkLaw, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StandardCreditSupportAnnex2013NewYorkLaw')
    def exportChildren(self, outfile, level, namespace_='', name_='StandardCreditSupportAnnex2013NewYorkLaw', fromsubclass_=False, pretty_print=True):
        super(StandardCreditSupportAnnex2013NewYorkLaw, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.disputeResolution is not None:
            self.disputeResolution.export(outfile, level, namespace_, name_='disputeResolution', pretty_print=pretty_print)
        for demandsAndNotices_ in self.demandsAndNotices:
            demandsAndNotices_.export(outfile, level, namespace_, name_='demandsAndNotices', pretty_print=pretty_print)
        if self.otherProvisions is not None:
            self.otherProvisions.export(outfile, level, namespace_, name_='otherProvisions', pretty_print=pretty_print)
        for transportCurrency_ in self.transportCurrency:
            transportCurrency_.export(outfile, level, namespace_, name_='transportCurrency', pretty_print=pretty_print)
        if self.dayCount is not None:
            self.dayCount.export(outfile, level, namespace_, name_='dayCount', pretty_print=pretty_print)
        if self.independentAmountInterestRate is not None:
            self.independentAmountInterestRate.export(outfile, level, namespace_, name_='independentAmountInterestRate', pretty_print=pretty_print)
        for independentAmountEligibleCollateral_ in self.independentAmountEligibleCollateral:
            independentAmountEligibleCollateral_.export(outfile, level, namespace_, name_='independentAmountEligibleCollateral', pretty_print=pretty_print)
        for holdingAndUsingPostedCollateral_ in self.holdingAndUsingPostedCollateral:
            holdingAndUsingPostedCollateral_.export(outfile, level, namespace_, name_='holdingAndUsingPostedCollateral', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(StandardCreditSupportAnnex2013NewYorkLaw, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'disputeResolution':
            obj_ = DisputeResolution.factory()
            obj_.build(child_)
            self.disputeResolution = obj_
            obj_.original_tagname_ = 'disputeResolution'
        elif nodeName_ == 'demandsAndNotices':
            obj_ = PartyContactInformation.factory()
            obj_.build(child_)
            self.demandsAndNotices.append(obj_)
            obj_.original_tagname_ = 'demandsAndNotices'
        elif nodeName_ == 'otherProvisions':
            obj_ = OtherProvisions.factory()
            obj_.build(child_)
            self.otherProvisions = obj_
            obj_.original_tagname_ = 'otherProvisions'
        elif nodeName_ == 'transportCurrency':
            obj_ = TransportCurrency.factory()
            obj_.build(child_)
            self.transportCurrency.append(obj_)
            obj_.original_tagname_ = 'transportCurrency'
        elif nodeName_ == 'dayCount':
            obj_ = DayCount.factory()
            obj_.build(child_)
            self.dayCount = obj_
            obj_.original_tagname_ = 'dayCount'
        elif nodeName_ == 'independentAmountInterestRate':
            obj_ = IndependentAmountInterestRate.factory()
            obj_.build(child_)
            self.independentAmountInterestRate = obj_
            obj_.original_tagname_ = 'independentAmountInterestRate'
        elif nodeName_ == 'independentAmountEligibleCollateral':
            obj_ = IndependentAmountEligibleCollateral.factory()
            obj_.build(child_)
            self.independentAmountEligibleCollateral.append(obj_)
            obj_.original_tagname_ = 'independentAmountEligibleCollateral'
        elif nodeName_ == 'holdingAndUsingPostedCollateral':
            obj_ = HoldingAndUsingPostedCollateral.factory()
            obj_.build(child_)
            self.holdingAndUsingPostedCollateral.append(obj_)
            obj_.original_tagname_ = 'holdingAndUsingPostedCollateral'
        super(StandardCreditSupportAnnex2013NewYorkLaw, self).buildChildren(child_, node, nodeName_, True)
# end class StandardCreditSupportAnnex2013NewYorkLaw


class StandardCreditSupportAnnex2014EnglishLaw(StandardCreditSupportAnnexBase):
    """The English Law 2014 SCSA implementation, which extends
    StandardCreditSupportAnnexBase.Provisions that are specific to
    the English Law document."""
    member_data_items_ = {
        'demandsAndNotices': MemberSpec_('demandsAndNotices', 'PartyContactInformation', 1),
        'independentAmountEligibleCreditSupport': MemberSpec_('independentAmountEligibleCreditSupport', 'IndependentAmountEligibleCollateral', 1),
        'valuationDateCity': MemberSpec_('valuationDateCity', 'BusinessCenters', 0),
        'notificationTimeCity': MemberSpec_('notificationTimeCity', 'BusinessCenter', 0),
    }
    subclass = None
    superclass = StandardCreditSupportAnnexBase
    def __init__(self, id=None, documentType=None, independentAmounts=None, baseCurrency=None, existingCreditSupportAnnex=None, settlementDay=None, demandsAndNotices=None, independentAmountEligibleCreditSupport=None, valuationDateCity=None, notificationTimeCity=None):
        self.original_tagname_ = None
        super(StandardCreditSupportAnnex2014EnglishLaw, self).__init__(id, documentType, independentAmounts, baseCurrency, existingCreditSupportAnnex, settlementDay, )
        if demandsAndNotices is None:
            self.demandsAndNotices = []
        else:
            self.demandsAndNotices = demandsAndNotices
        if independentAmountEligibleCreditSupport is None:
            self.independentAmountEligibleCreditSupport = []
        else:
            self.independentAmountEligibleCreditSupport = independentAmountEligibleCreditSupport
        self.valuationDateCity = valuationDateCity
        self.notificationTimeCity = notificationTimeCity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StandardCreditSupportAnnex2014EnglishLaw)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StandardCreditSupportAnnex2014EnglishLaw.subclass:
            return StandardCreditSupportAnnex2014EnglishLaw.subclass(*args_, **kwargs_)
        else:
            return StandardCreditSupportAnnex2014EnglishLaw(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_demandsAndNotices(self): return self.demandsAndNotices
    def set_demandsAndNotices(self, demandsAndNotices): self.demandsAndNotices = demandsAndNotices
    def add_demandsAndNotices(self, value): self.demandsAndNotices.append(value)
    def insert_demandsAndNotices_at(self, index, value): self.demandsAndNotices.insert(index, value)
    def replace_demandsAndNotices_at(self, index, value): self.demandsAndNotices[index] = value
    def get_independentAmountEligibleCreditSupport(self): return self.independentAmountEligibleCreditSupport
    def set_independentAmountEligibleCreditSupport(self, independentAmountEligibleCreditSupport): self.independentAmountEligibleCreditSupport = independentAmountEligibleCreditSupport
    def add_independentAmountEligibleCreditSupport(self, value): self.independentAmountEligibleCreditSupport.append(value)
    def insert_independentAmountEligibleCreditSupport_at(self, index, value): self.independentAmountEligibleCreditSupport.insert(index, value)
    def replace_independentAmountEligibleCreditSupport_at(self, index, value): self.independentAmountEligibleCreditSupport[index] = value
    def get_valuationDateCity(self): return self.valuationDateCity
    def set_valuationDateCity(self, valuationDateCity): self.valuationDateCity = valuationDateCity
    def get_notificationTimeCity(self): return self.notificationTimeCity
    def set_notificationTimeCity(self, notificationTimeCity): self.notificationTimeCity = notificationTimeCity
    def hasContent_(self):
        if (
            self.demandsAndNotices or
            self.independentAmountEligibleCreditSupport or
            self.valuationDateCity is not None or
            self.notificationTimeCity is not None or
            super(StandardCreditSupportAnnex2014EnglishLaw, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StandardCreditSupportAnnex2014EnglishLaw', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StandardCreditSupportAnnex2014EnglishLaw')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StandardCreditSupportAnnex2014EnglishLaw', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StandardCreditSupportAnnex2014EnglishLaw'):
        super(StandardCreditSupportAnnex2014EnglishLaw, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StandardCreditSupportAnnex2014EnglishLaw')
    def exportChildren(self, outfile, level, namespace_='', name_='StandardCreditSupportAnnex2014EnglishLaw', fromsubclass_=False, pretty_print=True):
        super(StandardCreditSupportAnnex2014EnglishLaw, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for demandsAndNotices_ in self.demandsAndNotices:
            demandsAndNotices_.export(outfile, level, namespace_, name_='demandsAndNotices', pretty_print=pretty_print)
        for independentAmountEligibleCreditSupport_ in self.independentAmountEligibleCreditSupport:
            independentAmountEligibleCreditSupport_.export(outfile, level, namespace_, name_='independentAmountEligibleCreditSupport', pretty_print=pretty_print)
        if self.valuationDateCity is not None:
            self.valuationDateCity.export(outfile, level, namespace_, name_='valuationDateCity', pretty_print=pretty_print)
        if self.notificationTimeCity is not None:
            self.notificationTimeCity.export(outfile, level, namespace_, name_='notificationTimeCity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(StandardCreditSupportAnnex2014EnglishLaw, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'demandsAndNotices':
            obj_ = PartyContactInformation.factory()
            obj_.build(child_)
            self.demandsAndNotices.append(obj_)
            obj_.original_tagname_ = 'demandsAndNotices'
        elif nodeName_ == 'independentAmountEligibleCreditSupport':
            obj_ = IndependentAmountEligibleCollateral.factory()
            obj_.build(child_)
            self.independentAmountEligibleCreditSupport.append(obj_)
            obj_.original_tagname_ = 'independentAmountEligibleCreditSupport'
        elif nodeName_ == 'valuationDateCity':
            obj_ = BusinessCenters.factory()
            obj_.build(child_)
            self.valuationDateCity = obj_
            obj_.original_tagname_ = 'valuationDateCity'
        elif nodeName_ == 'notificationTimeCity':
            obj_ = BusinessCenter.factory()
            obj_.build(child_)
            self.notificationTimeCity = obj_
            obj_.original_tagname_ = 'notificationTimeCity'
        super(StandardCreditSupportAnnex2014EnglishLaw, self).buildChildren(child_, node, nodeName_, True)
# end class StandardCreditSupportAnnex2014EnglishLaw


class StandardCreditSupportAnnex2013EnglishLaw(StandardCreditSupportAnnexBase):
    """The English Law 2013 SCSA implementation, which extends
    StandardCreditSupportAnnexBase.Provisions that are specific to
    the English Law document."""
    member_data_items_ = {
        'disputeResolution': MemberSpec_('disputeResolution', 'DisputeResolution', 0),
        'demandsAndNotices': MemberSpec_('demandsAndNotices', 'PartyContactInformation', 1),
        'otherProvisions': MemberSpec_('otherProvisions', 'OtherProvisions', 0),
        'transportCurrency': MemberSpec_('transportCurrency', 'TransportCurrency', 1),
        'dayCount': MemberSpec_('dayCount', 'DayCount', 0),
        'independentAmountInterestRate': MemberSpec_('independentAmountInterestRate', 'IndependentAmountInterestRate', 0),
        'independentAmountEligibleCreditSupport': MemberSpec_('independentAmountEligibleCreditSupport', 'IndependentAmountEligibleCollateral', 1),
        'exchangeDate': MemberSpec_('exchangeDate', 'ExchangeDate', 0),
    }
    subclass = None
    superclass = StandardCreditSupportAnnexBase
    def __init__(self, id=None, documentType=None, independentAmounts=None, baseCurrency=None, existingCreditSupportAnnex=None, settlementDay=None, disputeResolution=None, demandsAndNotices=None, otherProvisions=None, transportCurrency=None, dayCount=None, independentAmountInterestRate=None, independentAmountEligibleCreditSupport=None, exchangeDate=None):
        self.original_tagname_ = None
        super(StandardCreditSupportAnnex2013EnglishLaw, self).__init__(id, documentType, independentAmounts, baseCurrency, existingCreditSupportAnnex, settlementDay, )
        self.disputeResolution = disputeResolution
        if demandsAndNotices is None:
            self.demandsAndNotices = []
        else:
            self.demandsAndNotices = demandsAndNotices
        self.otherProvisions = otherProvisions
        if transportCurrency is None:
            self.transportCurrency = []
        else:
            self.transportCurrency = transportCurrency
        self.dayCount = dayCount
        self.independentAmountInterestRate = independentAmountInterestRate
        if independentAmountEligibleCreditSupport is None:
            self.independentAmountEligibleCreditSupport = []
        else:
            self.independentAmountEligibleCreditSupport = independentAmountEligibleCreditSupport
        self.exchangeDate = exchangeDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StandardCreditSupportAnnex2013EnglishLaw)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StandardCreditSupportAnnex2013EnglishLaw.subclass:
            return StandardCreditSupportAnnex2013EnglishLaw.subclass(*args_, **kwargs_)
        else:
            return StandardCreditSupportAnnex2013EnglishLaw(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_disputeResolution(self): return self.disputeResolution
    def set_disputeResolution(self, disputeResolution): self.disputeResolution = disputeResolution
    def get_demandsAndNotices(self): return self.demandsAndNotices
    def set_demandsAndNotices(self, demandsAndNotices): self.demandsAndNotices = demandsAndNotices
    def add_demandsAndNotices(self, value): self.demandsAndNotices.append(value)
    def insert_demandsAndNotices_at(self, index, value): self.demandsAndNotices.insert(index, value)
    def replace_demandsAndNotices_at(self, index, value): self.demandsAndNotices[index] = value
    def get_otherProvisions(self): return self.otherProvisions
    def set_otherProvisions(self, otherProvisions): self.otherProvisions = otherProvisions
    def get_transportCurrency(self): return self.transportCurrency
    def set_transportCurrency(self, transportCurrency): self.transportCurrency = transportCurrency
    def add_transportCurrency(self, value): self.transportCurrency.append(value)
    def insert_transportCurrency_at(self, index, value): self.transportCurrency.insert(index, value)
    def replace_transportCurrency_at(self, index, value): self.transportCurrency[index] = value
    def get_dayCount(self): return self.dayCount
    def set_dayCount(self, dayCount): self.dayCount = dayCount
    def get_independentAmountInterestRate(self): return self.independentAmountInterestRate
    def set_independentAmountInterestRate(self, independentAmountInterestRate): self.independentAmountInterestRate = independentAmountInterestRate
    def get_independentAmountEligibleCreditSupport(self): return self.independentAmountEligibleCreditSupport
    def set_independentAmountEligibleCreditSupport(self, independentAmountEligibleCreditSupport): self.independentAmountEligibleCreditSupport = independentAmountEligibleCreditSupport
    def add_independentAmountEligibleCreditSupport(self, value): self.independentAmountEligibleCreditSupport.append(value)
    def insert_independentAmountEligibleCreditSupport_at(self, index, value): self.independentAmountEligibleCreditSupport.insert(index, value)
    def replace_independentAmountEligibleCreditSupport_at(self, index, value): self.independentAmountEligibleCreditSupport[index] = value
    def get_exchangeDate(self): return self.exchangeDate
    def set_exchangeDate(self, exchangeDate): self.exchangeDate = exchangeDate
    def hasContent_(self):
        if (
            self.disputeResolution is not None or
            self.demandsAndNotices or
            self.otherProvisions is not None or
            self.transportCurrency or
            self.dayCount is not None or
            self.independentAmountInterestRate is not None or
            self.independentAmountEligibleCreditSupport or
            self.exchangeDate is not None or
            super(StandardCreditSupportAnnex2013EnglishLaw, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StandardCreditSupportAnnex2013EnglishLaw', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StandardCreditSupportAnnex2013EnglishLaw')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StandardCreditSupportAnnex2013EnglishLaw', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StandardCreditSupportAnnex2013EnglishLaw'):
        super(StandardCreditSupportAnnex2013EnglishLaw, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StandardCreditSupportAnnex2013EnglishLaw')
    def exportChildren(self, outfile, level, namespace_='', name_='StandardCreditSupportAnnex2013EnglishLaw', fromsubclass_=False, pretty_print=True):
        super(StandardCreditSupportAnnex2013EnglishLaw, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.disputeResolution is not None:
            self.disputeResolution.export(outfile, level, namespace_, name_='disputeResolution', pretty_print=pretty_print)
        for demandsAndNotices_ in self.demandsAndNotices:
            demandsAndNotices_.export(outfile, level, namespace_, name_='demandsAndNotices', pretty_print=pretty_print)
        if self.otherProvisions is not None:
            self.otherProvisions.export(outfile, level, namespace_, name_='otherProvisions', pretty_print=pretty_print)
        for transportCurrency_ in self.transportCurrency:
            transportCurrency_.export(outfile, level, namespace_, name_='transportCurrency', pretty_print=pretty_print)
        if self.dayCount is not None:
            self.dayCount.export(outfile, level, namespace_, name_='dayCount', pretty_print=pretty_print)
        if self.independentAmountInterestRate is not None:
            self.independentAmountInterestRate.export(outfile, level, namespace_, name_='independentAmountInterestRate', pretty_print=pretty_print)
        for independentAmountEligibleCreditSupport_ in self.independentAmountEligibleCreditSupport:
            independentAmountEligibleCreditSupport_.export(outfile, level, namespace_, name_='independentAmountEligibleCreditSupport', pretty_print=pretty_print)
        if self.exchangeDate is not None:
            self.exchangeDate.export(outfile, level, namespace_, name_='exchangeDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(StandardCreditSupportAnnex2013EnglishLaw, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'disputeResolution':
            obj_ = DisputeResolution.factory()
            obj_.build(child_)
            self.disputeResolution = obj_
            obj_.original_tagname_ = 'disputeResolution'
        elif nodeName_ == 'demandsAndNotices':
            obj_ = PartyContactInformation.factory()
            obj_.build(child_)
            self.demandsAndNotices.append(obj_)
            obj_.original_tagname_ = 'demandsAndNotices'
        elif nodeName_ == 'otherProvisions':
            obj_ = OtherProvisions.factory()
            obj_.build(child_)
            self.otherProvisions = obj_
            obj_.original_tagname_ = 'otherProvisions'
        elif nodeName_ == 'transportCurrency':
            obj_ = TransportCurrency.factory()
            obj_.build(child_)
            self.transportCurrency.append(obj_)
            obj_.original_tagname_ = 'transportCurrency'
        elif nodeName_ == 'dayCount':
            obj_ = DayCount.factory()
            obj_.build(child_)
            self.dayCount = obj_
            obj_.original_tagname_ = 'dayCount'
        elif nodeName_ == 'independentAmountInterestRate':
            obj_ = IndependentAmountInterestRate.factory()
            obj_.build(child_)
            self.independentAmountInterestRate = obj_
            obj_.original_tagname_ = 'independentAmountInterestRate'
        elif nodeName_ == 'independentAmountEligibleCreditSupport':
            obj_ = IndependentAmountEligibleCollateral.factory()
            obj_.build(child_)
            self.independentAmountEligibleCreditSupport.append(obj_)
            obj_.original_tagname_ = 'independentAmountEligibleCreditSupport'
        elif nodeName_ == 'exchangeDate':
            obj_ = ExchangeDate.factory()
            obj_.build(child_)
            self.exchangeDate = obj_
            obj_.original_tagname_ = 'exchangeDate'
        super(StandardCreditSupportAnnex2013EnglishLaw, self).buildChildren(child_, node, nodeName_, True)
# end class StandardCreditSupportAnnex2013EnglishLaw


class DocumentIdentity(LegalDocumentIdentity):
    """A type to specifty the document identity."""
    member_data_items_ = {
        'documentAmendment': MemberSpec_('documentAmendment', 'LegalDocumentAdmendment', 1),
    }
    subclass = None
    superclass = LegalDocumentIdentity
    def __init__(self, id=None, partyReference=None, documentType=None, agreementDate=None, partyDocumentIdentifier=None, documentAmendment=None):
        self.original_tagname_ = None
        super(DocumentIdentity, self).__init__(id, partyReference, documentType, agreementDate, partyDocumentIdentifier, )
        if documentAmendment is None:
            self.documentAmendment = []
        else:
            self.documentAmendment = documentAmendment
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DocumentIdentity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DocumentIdentity.subclass:
            return DocumentIdentity.subclass(*args_, **kwargs_)
        else:
            return DocumentIdentity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_documentAmendment(self): return self.documentAmendment
    def set_documentAmendment(self, documentAmendment): self.documentAmendment = documentAmendment
    def add_documentAmendment(self, value): self.documentAmendment.append(value)
    def insert_documentAmendment_at(self, index, value): self.documentAmendment.insert(index, value)
    def replace_documentAmendment_at(self, index, value): self.documentAmendment[index] = value
    def hasContent_(self):
        if (
            self.documentAmendment or
            super(DocumentIdentity, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DocumentIdentity', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DocumentIdentity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DocumentIdentity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DocumentIdentity'):
        super(DocumentIdentity, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DocumentIdentity')
    def exportChildren(self, outfile, level, namespace_='', name_='DocumentIdentity', fromsubclass_=False, pretty_print=True):
        super(DocumentIdentity, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for documentAmendment_ in self.documentAmendment:
            documentAmendment_.export(outfile, level, namespace_, name_='documentAmendment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DocumentIdentity, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'documentAmendment':
            obj_ = LegalDocumentAdmendment.factory()
            obj_.build(child_)
            self.documentAmendment.append(obj_)
            obj_.original_tagname_ = 'documentAmendment'
        super(DocumentIdentity, self).buildChildren(child_, node, nodeName_, True)
# end class DocumentIdentity


class Stub(StubValue):
    """A type defining how a stub calculation period amount is calculated
    and the start and end date of the stub. A single floating rate
    tenor different to that used for the regular part of the
    calculation periods schedule may be specified, or two floating
    rate tenors many be specified. If two floating rate tenors are
    specified then Linear Interpolation (in accordance with the 2000
    ISDA Definitions, Section 8.3 Interpolation) is assumed to
    apply. Alternatively, an actual known stub rate or stub amount
    may be specified."""
    member_data_items_ = {
        'stubStartDate': MemberSpec_('stubStartDate', 'AdjustableOrRelativeDate', 0),
        'stubEndDate': MemberSpec_('stubEndDate', 'AdjustableOrRelativeDate', 0),
    }
    subclass = None
    superclass = StubValue
    def __init__(self, floatingRate=None, stubRate=None, stubAmount=None, stubStartDate=None, stubEndDate=None):
        self.original_tagname_ = None
        super(Stub, self).__init__(floatingRate, stubRate, stubAmount, )
        self.stubStartDate = stubStartDate
        self.stubEndDate = stubEndDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Stub)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Stub.subclass:
            return Stub.subclass(*args_, **kwargs_)
        else:
            return Stub(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_stubStartDate(self): return self.stubStartDate
    def set_stubStartDate(self, stubStartDate): self.stubStartDate = stubStartDate
    def get_stubEndDate(self): return self.stubEndDate
    def set_stubEndDate(self, stubEndDate): self.stubEndDate = stubEndDate
    def hasContent_(self):
        if (
            self.stubStartDate is not None or
            self.stubEndDate is not None or
            super(Stub, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Stub', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Stub')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Stub', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Stub'):
        super(Stub, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Stub')
    def exportChildren(self, outfile, level, namespace_='', name_='Stub', fromsubclass_=False, pretty_print=True):
        super(Stub, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.stubStartDate is not None:
            self.stubStartDate.export(outfile, level, namespace_, name_='stubStartDate', pretty_print=pretty_print)
        if self.stubEndDate is not None:
            self.stubEndDate.export(outfile, level, namespace_, name_='stubEndDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Stub, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'stubStartDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.stubStartDate = obj_
            obj_.original_tagname_ = 'stubStartDate'
        elif nodeName_ == 'stubEndDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.stubEndDate = obj_
            obj_.original_tagname_ = 'stubEndDate'
        super(Stub, self).buildChildren(child_, node, nodeName_, True)
# end class Stub


class Step(StepBase):
    """A type defining a step date and step value pair. This step
    definitions are used to define varying rate or amount schedules,
    e.g. a notional amortization or a step-up coupon schedule."""
    member_data_items_ = {
        'stepValue': MemberSpec_('stepValue', 'xsd:decimal', 0),
    }
    subclass = None
    superclass = StepBase
    def __init__(self, id=None, stepDate=None, stepValue=None):
        self.original_tagname_ = None
        super(Step, self).__init__(id, stepDate, )
        self.stepValue = stepValue
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Step)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Step.subclass:
            return Step.subclass(*args_, **kwargs_)
        else:
            return Step(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_stepValue(self): return self.stepValue
    def set_stepValue(self, stepValue): self.stepValue = stepValue
    def hasContent_(self):
        if (
            self.stepValue is not None or
            super(Step, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Step', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Step')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Step', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Step'):
        super(Step, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Step')
    def exportChildren(self, outfile, level, namespace_='', name_='Step', fromsubclass_=False, pretty_print=True):
        super(Step, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.stepValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstepValue>%s</%sstepValue>%s' % (namespace_, self.gds_format_float(self.stepValue, input_name='stepValue'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Step, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'stepValue':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'stepValue')
            self.stepValue = fval_
        super(Step, self).buildChildren(child_, node, nodeName_, True)
# end class Step


class ProductReference(Reference):
    """Reference to a full FpML product."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(ProductReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductReference.subclass:
            return ProductReference.subclass(*args_, **kwargs_)
        else:
            return ProductReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(ProductReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ProductReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ProductReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProductReference'):
        super(ProductReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ProductReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ProductReference', fromsubclass_=False, pretty_print=True):
        super(ProductReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(ProductReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ProductReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ProductReference


class PricingStructureReference(Reference):
    """Reference to a pricing structure or any derived components (i.e.
    yield curve)."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(PricingStructureReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PricingStructureReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PricingStructureReference.subclass:
            return PricingStructureReference.subclass(*args_, **kwargs_)
        else:
            return PricingStructureReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(PricingStructureReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PricingStructureReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PricingStructureReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PricingStructureReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PricingStructureReference'):
        super(PricingStructureReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PricingStructureReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PricingStructureReference', fromsubclass_=False, pretty_print=True):
        super(PricingStructureReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(PricingStructureReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(PricingStructureReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PricingStructureReference


class PaymentReference(Reference):
    """Reference to a payment."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(PaymentReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PaymentReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PaymentReference.subclass:
            return PaymentReference.subclass(*args_, **kwargs_)
        else:
            return PaymentReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(PaymentReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PaymentReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PaymentReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PaymentReference'):
        super(PaymentReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PaymentReference', fromsubclass_=False, pretty_print=True):
        super(PaymentReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(PaymentReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(PaymentReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PaymentReference


class Payment(PaymentBase):
    """A type for defining payments. In Transparency view, normally the
    payer and receiver party references are not used; however they
    may be provided if necessary for administrative activities such
    as Reporting Party Determination in FX.Can be used to reference
    the yield curve used to estimate the discount factor."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
        'payerPartyReference': MemberSpec_('payerPartyReference', 'PartyReference', 0),
        'payerAccountReference': MemberSpec_('payerAccountReference', 'AccountReference', 0),
        'receiverPartyReference': MemberSpec_('receiverPartyReference', 'PartyReference', 0),
        'receiverAccountReference': MemberSpec_('receiverAccountReference', 'AccountReference', 0),
        'paymentAmount': MemberSpec_('paymentAmount', 'NonNegativeMoney', 0),
        'paymentDate': MemberSpec_('paymentDate', 'AdjustableOrAdjustedDate', 0),
        'paymentType': MemberSpec_('paymentType', 'PaymentType', 0),
        'settlementInformation': MemberSpec_('settlementInformation', 'SettlementInformation', 0),
        'discountFactor': MemberSpec_('discountFactor', 'xsd:decimal', 0),
        'presentValueAmount': MemberSpec_('presentValueAmount', 'Money', 0),
    }
    subclass = None
    superclass = PaymentBase
    def __init__(self, id=None, href=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, paymentAmount=None, paymentDate=None, paymentType=None, settlementInformation=None, discountFactor=None, presentValueAmount=None):
        self.original_tagname_ = None
        super(Payment, self).__init__(id, )
        self.href = _cast(None, href)
        self.payerPartyReference = payerPartyReference
        self.payerAccountReference = payerAccountReference
        self.receiverPartyReference = receiverPartyReference
        self.receiverAccountReference = receiverAccountReference
        self.paymentAmount = paymentAmount
        self.paymentDate = paymentDate
        self.paymentType = paymentType
        self.settlementInformation = settlementInformation
        self.discountFactor = discountFactor
        self.presentValueAmount = presentValueAmount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Payment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Payment.subclass:
            return Payment.subclass(*args_, **kwargs_)
        else:
            return Payment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_payerPartyReference(self): return self.payerPartyReference
    def set_payerPartyReference(self, payerPartyReference): self.payerPartyReference = payerPartyReference
    def get_payerAccountReference(self): return self.payerAccountReference
    def set_payerAccountReference(self, payerAccountReference): self.payerAccountReference = payerAccountReference
    def get_receiverPartyReference(self): return self.receiverPartyReference
    def set_receiverPartyReference(self, receiverPartyReference): self.receiverPartyReference = receiverPartyReference
    def get_receiverAccountReference(self): return self.receiverAccountReference
    def set_receiverAccountReference(self, receiverAccountReference): self.receiverAccountReference = receiverAccountReference
    def get_paymentAmount(self): return self.paymentAmount
    def set_paymentAmount(self, paymentAmount): self.paymentAmount = paymentAmount
    def get_paymentDate(self): return self.paymentDate
    def set_paymentDate(self, paymentDate): self.paymentDate = paymentDate
    def get_paymentType(self): return self.paymentType
    def set_paymentType(self, paymentType): self.paymentType = paymentType
    def get_settlementInformation(self): return self.settlementInformation
    def set_settlementInformation(self, settlementInformation): self.settlementInformation = settlementInformation
    def get_discountFactor(self): return self.discountFactor
    def set_discountFactor(self, discountFactor): self.discountFactor = discountFactor
    def get_presentValueAmount(self): return self.presentValueAmount
    def set_presentValueAmount(self, presentValueAmount): self.presentValueAmount = presentValueAmount
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            self.payerPartyReference is not None or
            self.payerAccountReference is not None or
            self.receiverPartyReference is not None or
            self.receiverAccountReference is not None or
            self.paymentAmount is not None or
            self.paymentDate is not None or
            self.paymentType is not None or
            self.settlementInformation is not None or
            self.discountFactor is not None or
            self.presentValueAmount is not None or
            super(Payment, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Payment', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Payment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Payment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Payment'):
        super(Payment, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Payment')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Payment', fromsubclass_=False, pretty_print=True):
        super(Payment, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.payerPartyReference is not None:
            self.payerPartyReference.export(outfile, level, namespace_, name_='payerPartyReference', pretty_print=pretty_print)
        if self.payerAccountReference is not None:
            self.payerAccountReference.export(outfile, level, namespace_, name_='payerAccountReference', pretty_print=pretty_print)
        if self.receiverPartyReference is not None:
            self.receiverPartyReference.export(outfile, level, namespace_, name_='receiverPartyReference', pretty_print=pretty_print)
        if self.receiverAccountReference is not None:
            self.receiverAccountReference.export(outfile, level, namespace_, name_='receiverAccountReference', pretty_print=pretty_print)
        if self.paymentAmount is not None:
            self.paymentAmount.export(outfile, level, namespace_, name_='paymentAmount', pretty_print=pretty_print)
        if self.paymentDate is not None:
            self.paymentDate.export(outfile, level, namespace_, name_='paymentDate', pretty_print=pretty_print)
        if self.paymentType is not None:
            self.paymentType.export(outfile, level, namespace_, name_='paymentType', pretty_print=pretty_print)
        if self.settlementInformation is not None:
            self.settlementInformation.export(outfile, level, namespace_, name_='settlementInformation', pretty_print=pretty_print)
        if self.discountFactor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdiscountFactor>%s</%sdiscountFactor>%s' % (namespace_, self.gds_format_float(self.discountFactor, input_name='discountFactor'), namespace_, eol_))
        if self.presentValueAmount is not None:
            self.presentValueAmount.export(outfile, level, namespace_, name_='presentValueAmount', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(Payment, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'payerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.payerPartyReference = obj_
            obj_.original_tagname_ = 'payerPartyReference'
        elif nodeName_ == 'payerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.payerAccountReference = obj_
            obj_.original_tagname_ = 'payerAccountReference'
        elif nodeName_ == 'receiverPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.receiverPartyReference = obj_
            obj_.original_tagname_ = 'receiverPartyReference'
        elif nodeName_ == 'receiverAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.receiverAccountReference = obj_
            obj_.original_tagname_ = 'receiverAccountReference'
        elif nodeName_ == 'paymentAmount':
            class_obj_ = self.get_class_obj_(child_, NonNegativeMoney)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.paymentAmount = obj_
            obj_.original_tagname_ = 'paymentAmount'
        elif nodeName_ == 'paymentDate':
            obj_ = AdjustableOrAdjustedDate.factory()
            obj_.build(child_)
            self.paymentDate = obj_
            obj_.original_tagname_ = 'paymentDate'
        elif nodeName_ == 'paymentType':
            obj_ = PaymentType.factory()
            obj_.build(child_)
            self.paymentType = obj_
            obj_.original_tagname_ = 'paymentType'
        elif nodeName_ == 'settlementInformation':
            obj_ = SettlementInformation.factory()
            obj_.build(child_)
            self.settlementInformation = obj_
            obj_.original_tagname_ = 'settlementInformation'
        elif nodeName_ == 'discountFactor':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'discountFactor')
            self.discountFactor = fval_
        elif nodeName_ == 'presentValueAmount':
            obj_ = Money.factory()
            obj_.build(child_)
            self.presentValueAmount = obj_
            obj_.original_tagname_ = 'presentValueAmount'
        super(Payment, self).buildChildren(child_, node, nodeName_, True)
# end class Payment


class PartyTradeIdentifierReference(Reference):
    """A reference to a partyTradeIdentifier object."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(PartyTradeIdentifierReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyTradeIdentifierReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyTradeIdentifierReference.subclass:
            return PartyTradeIdentifierReference.subclass(*args_, **kwargs_)
        else:
            return PartyTradeIdentifierReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(PartyTradeIdentifierReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartyTradeIdentifierReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyTradeIdentifierReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartyTradeIdentifierReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyTradeIdentifierReference'):
        super(PartyTradeIdentifierReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PartyTradeIdentifierReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PartyTradeIdentifierReference', fromsubclass_=False, pretty_print=True):
        super(PartyTradeIdentifierReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(PartyTradeIdentifierReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(PartyTradeIdentifierReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PartyTradeIdentifierReference


class PersonReference(Reference):
    """Reference to an individual."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(PersonReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PersonReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PersonReference.subclass:
            return PersonReference.subclass(*args_, **kwargs_)
        else:
            return PersonReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(PersonReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PersonReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PersonReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PersonReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PersonReference'):
        super(PersonReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PersonReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PersonReference', fromsubclass_=False, pretty_print=True):
        super(PersonReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(PersonReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(PersonReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PersonReference


class PartyReference(Reference):
    """Reference to a party."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(PartyReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyReference.subclass:
            return PartyReference.subclass(*args_, **kwargs_)
        else:
            return PartyReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(PartyReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartyReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartyReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyReference'):
        super(PartyReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PartyReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PartyReference', fromsubclass_=False, pretty_print=True):
        super(PartyReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(PartyReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(PartyReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PartyReference


class Offset(Period):
    """A type defining an offset used in calculating a new date relative to
    a reference date. E.g. calendar days, business days, Commodity
    Business days, etc.."""
    member_data_items_ = {
        'dayType': MemberSpec_('dayType', ['DayTypeEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = Period
    def __init__(self, id=None, periodMultiplier=None, period=None, dayType=None, extensiontype_=None):
        self.original_tagname_ = None
        super(Offset, self).__init__(id, periodMultiplier, period, extensiontype_, )
        self.dayType = dayType
        self.validate_DayTypeEnum(self.dayType)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Offset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Offset.subclass:
            return Offset.subclass(*args_, **kwargs_)
        else:
            return Offset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dayType(self): return self.dayType
    def set_dayType(self, dayType): self.dayType = dayType
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_DayTypeEnum(self, value):
        # Validate type DayTypeEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Business', 'Calendar', 'CommodityBusiness', 'CurrencyBusiness', 'ExchangeBusiness', 'ScheduledTradingDay']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DayTypeEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on DayTypeEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.dayType is not None or
            super(Offset, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Offset', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Offset')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Offset', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Offset'):
        super(Offset, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Offset')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Offset', fromsubclass_=False, pretty_print=True):
        super(Offset, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dayType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdayType>%s</%sdayType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.dayType), input_name='dayType')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(Offset, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dayType':
            dayType_ = child_.text
            dayType_ = re_.sub(String_cleanup_pat_, " ", dayType_).strip()
            dayType_ = self.gds_validate_string(dayType_, node, 'dayType')
            self.dayType = dayType_
            # validate type DayTypeEnum
            self.validate_DayTypeEnum(self.dayType)
        super(Offset, self).buildChildren(child_, node, nodeName_, True)
# end class Offset


class ObservationFrequency(Period):
    """A type defining the frequency at which calculation period end dates
    occur within the regular part of the calculation period schedule
    and thier roll date convention. In case the calculation
    frequency is of value T (term), the period is defined by the
    swap\swapStream\calculationPerioDates\effectiveDate and the
    swap\swapStream\calculationPerioDates\terminationDate."""
    member_data_items_ = {
        'periodConvention': MemberSpec_('periodConvention', ['RollConventionEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = Period
    def __init__(self, id=None, periodMultiplier=None, period=None, periodConvention=None):
        self.original_tagname_ = None
        super(ObservationFrequency, self).__init__(id, periodMultiplier, period, )
        self.periodConvention = periodConvention
        self.validate_RollConventionEnum(self.periodConvention)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ObservationFrequency)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ObservationFrequency.subclass:
            return ObservationFrequency.subclass(*args_, **kwargs_)
        else:
            return ObservationFrequency(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_periodConvention(self): return self.periodConvention
    def set_periodConvention(self, periodConvention): self.periodConvention = periodConvention
    def validate_RollConventionEnum(self, value):
        # Validate type RollConventionEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['EOM', 'FRN', 'IMM', 'IMMCAD', 'IMMAUD', 'IMMNZD', 'SFE', 'NONE', 'TBILL', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '30', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT', 'SUN']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RollConventionEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on RollConventionEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.periodConvention is not None or
            super(ObservationFrequency, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ObservationFrequency', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObservationFrequency')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ObservationFrequency', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ObservationFrequency'):
        super(ObservationFrequency, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ObservationFrequency')
    def exportChildren(self, outfile, level, namespace_='', name_='ObservationFrequency', fromsubclass_=False, pretty_print=True):
        super(ObservationFrequency, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.periodConvention is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%speriodConvention>%s</%speriodConvention>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.periodConvention), input_name='periodConvention')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ObservationFrequency, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'periodConvention':
            periodConvention_ = child_.text
            periodConvention_ = re_.sub(String_cleanup_pat_, " ", periodConvention_).strip()
            periodConvention_ = self.gds_validate_string(periodConvention_, node, 'periodConvention')
            self.periodConvention = periodConvention_
            # validate type RollConventionEnum
            self.validate_RollConventionEnum(self.periodConvention)
        super(ObservationFrequency, self).buildChildren(child_, node, nodeName_, True)
# end class ObservationFrequency


class NumberOfUnitsReference(Reference):
    """A reference to the number of units."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(NumberOfUnitsReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NumberOfUnitsReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NumberOfUnitsReference.subclass:
            return NumberOfUnitsReference.subclass(*args_, **kwargs_)
        else:
            return NumberOfUnitsReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(NumberOfUnitsReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NumberOfUnitsReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NumberOfUnitsReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NumberOfUnitsReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NumberOfUnitsReference'):
        super(NumberOfUnitsReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NumberOfUnitsReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NumberOfUnitsReference', fromsubclass_=False, pretty_print=True):
        super(NumberOfUnitsReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(NumberOfUnitsReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(NumberOfUnitsReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class NumberOfUnitsReference


class NumberOfOptionsReference(Reference):
    """A reference to the number of options."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(NumberOfOptionsReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NumberOfOptionsReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NumberOfOptionsReference.subclass:
            return NumberOfOptionsReference.subclass(*args_, **kwargs_)
        else:
            return NumberOfOptionsReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(NumberOfOptionsReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NumberOfOptionsReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NumberOfOptionsReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NumberOfOptionsReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NumberOfOptionsReference'):
        super(NumberOfOptionsReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NumberOfOptionsReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NumberOfOptionsReference', fromsubclass_=False, pretty_print=True):
        super(NumberOfOptionsReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(NumberOfOptionsReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(NumberOfOptionsReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class NumberOfOptionsReference


class NotionalReference(Reference):
    """A reference to the notional amount."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(NotionalReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NotionalReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NotionalReference.subclass:
            return NotionalReference.subclass(*args_, **kwargs_)
        else:
            return NotionalReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(NotionalReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NotionalReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NotionalReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NotionalReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NotionalReference'):
        super(NotionalReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NotionalReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NotionalReference', fromsubclass_=False, pretty_print=True):
        super(NotionalReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(NotionalReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(NotionalReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class NotionalReference


class NotionalAmountReference(Reference):
    """A reference to the notional amount."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(NotionalAmountReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NotionalAmountReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NotionalAmountReference.subclass:
            return NotionalAmountReference.subclass(*args_, **kwargs_)
        else:
            return NotionalAmountReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(NotionalAmountReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NotionalAmountReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NotionalAmountReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NotionalAmountReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NotionalAmountReference'):
        super(NotionalAmountReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NotionalAmountReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NotionalAmountReference', fromsubclass_=False, pretty_print=True):
        super(NotionalAmountReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(NotionalAmountReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(NotionalAmountReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class NotionalAmountReference


class NonNegativeStep(StepBase):
    """A type defining a step date and non-negative step value pair. This
    step definitions are used to define varying rate or amount
    schedules, e.g. a notional amortization or a step-up coupon
    schedule."""
    member_data_items_ = {
        'stepValue': MemberSpec_('stepValue', ['NonNegativeDecimal', 'xsd:decimal'], 0),
    }
    subclass = None
    superclass = StepBase
    def __init__(self, id=None, stepDate=None, stepValue=None):
        self.original_tagname_ = None
        super(NonNegativeStep, self).__init__(id, stepDate, )
        self.stepValue = stepValue
        self.validate_NonNegativeDecimal(self.stepValue)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NonNegativeStep)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NonNegativeStep.subclass:
            return NonNegativeStep.subclass(*args_, **kwargs_)
        else:
            return NonNegativeStep(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_stepValue(self): return self.stepValue
    def set_stepValue(self, stepValue): self.stepValue = stepValue
    def validate_NonNegativeDecimal(self, value):
        # Validate type NonNegativeDecimal, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on NonNegativeDecimal' % {"value" : value} )
    def hasContent_(self):
        if (
            self.stepValue is not None or
            super(NonNegativeStep, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NonNegativeStep', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NonNegativeStep')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NonNegativeStep', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NonNegativeStep'):
        super(NonNegativeStep, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NonNegativeStep')
    def exportChildren(self, outfile, level, namespace_='', name_='NonNegativeStep', fromsubclass_=False, pretty_print=True):
        super(NonNegativeStep, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.stepValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstepValue>%s</%sstepValue>%s' % (namespace_, self.gds_format_float(self.stepValue, input_name='stepValue'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NonNegativeStep, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'stepValue':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'stepValue')
            self.stepValue = fval_
            # validate type NonNegativeDecimal
            self.validate_NonNegativeDecimal(self.stepValue)
        super(NonNegativeStep, self).buildChildren(child_, node, nodeName_, True)
# end class NonNegativeStep


class NonNegativePayment(PaymentBaseExtended):
    """A complex type to specify non negative payments."""
    member_data_items_ = {
        'paymentAmount': MemberSpec_('paymentAmount', 'NonNegativeMoney', 0),
    }
    subclass = None
    superclass = PaymentBaseExtended
    def __init__(self, id=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, paymentDate=None, paymentAmount=None):
        self.original_tagname_ = None
        super(NonNegativePayment, self).__init__(id, payerPartyReference, payerAccountReference, receiverPartyReference, receiverAccountReference, paymentDate, )
        self.paymentAmount = paymentAmount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NonNegativePayment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NonNegativePayment.subclass:
            return NonNegativePayment.subclass(*args_, **kwargs_)
        else:
            return NonNegativePayment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_paymentAmount(self): return self.paymentAmount
    def set_paymentAmount(self, paymentAmount): self.paymentAmount = paymentAmount
    def hasContent_(self):
        if (
            self.paymentAmount is not None or
            super(NonNegativePayment, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NonNegativePayment', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NonNegativePayment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NonNegativePayment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NonNegativePayment'):
        super(NonNegativePayment, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NonNegativePayment')
    def exportChildren(self, outfile, level, namespace_='', name_='NonNegativePayment', fromsubclass_=False, pretty_print=True):
        super(NonNegativePayment, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.paymentAmount is not None:
            self.paymentAmount.export(outfile, level, namespace_, name_='paymentAmount', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NonNegativePayment, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'paymentAmount':
            class_obj_ = self.get_class_obj_(child_, NonNegativeMoney)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.paymentAmount = obj_
            obj_.original_tagname_ = 'paymentAmount'
        super(NonNegativePayment, self).buildChildren(child_, node, nodeName_, True)
# end class NonNegativePayment


class NonNegativeAmountSchedule(NonNegativeSchedule):
    """A type defining a currency amount or a currency amount schedule."""
    member_data_items_ = {
        'currency': MemberSpec_('currency', 'Currency', 0),
    }
    subclass = None
    superclass = NonNegativeSchedule
    def __init__(self, id=None, initialValue=None, step=None, currency=None):
        self.original_tagname_ = None
        super(NonNegativeAmountSchedule, self).__init__(id, initialValue, step, )
        self.currency = currency
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NonNegativeAmountSchedule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NonNegativeAmountSchedule.subclass:
            return NonNegativeAmountSchedule.subclass(*args_, **kwargs_)
        else:
            return NonNegativeAmountSchedule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def hasContent_(self):
        if (
            self.currency is not None or
            super(NonNegativeAmountSchedule, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NonNegativeAmountSchedule', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NonNegativeAmountSchedule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NonNegativeAmountSchedule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NonNegativeAmountSchedule'):
        super(NonNegativeAmountSchedule, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NonNegativeAmountSchedule')
    def exportChildren(self, outfile, level, namespace_='', name_='NonNegativeAmountSchedule', fromsubclass_=False, pretty_print=True):
        super(NonNegativeAmountSchedule, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.currency is not None:
            self.currency.export(outfile, level, namespace_, name_='currency', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NonNegativeAmountSchedule, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'currency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        super(NonNegativeAmountSchedule, self).buildChildren(child_, node, nodeName_, True)
# end class NonNegativeAmountSchedule


class Money(MoneyBase):
    """A type defining a currency amount."""
    member_data_items_ = {
        'amount': MemberSpec_('amount', 'xsd:decimal', 0),
    }
    subclass = None
    superclass = MoneyBase
    def __init__(self, id=None, currency=None, amount=None):
        self.original_tagname_ = None
        super(Money, self).__init__(id, currency, )
        self.amount = amount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Money)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Money.subclass:
            return Money.subclass(*args_, **kwargs_)
        else:
            return Money(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_amount(self): return self.amount
    def set_amount(self, amount): self.amount = amount
    def hasContent_(self):
        if (
            self.amount is not None or
            super(Money, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Money', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Money')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Money', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Money'):
        super(Money, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Money')
    def exportChildren(self, outfile, level, namespace_='', name_='Money', fromsubclass_=False, pretty_print=True):
        super(Money, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.amount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%samount>%s</%samount>%s' % (namespace_, self.gds_format_float(self.amount, input_name='amount'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Money, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'amount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'amount')
            self.amount = fval_
        super(Money, self).buildChildren(child_, node, nodeName_, True)
# end class Money


class LegalEntityReference(Reference):
    """References a credit entity defined elsewhere in the document."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(LegalEntityReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LegalEntityReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LegalEntityReference.subclass:
            return LegalEntityReference.subclass(*args_, **kwargs_)
        else:
            return LegalEntityReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(LegalEntityReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LegalEntityReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LegalEntityReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LegalEntityReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LegalEntityReference'):
        super(LegalEntityReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LegalEntityReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LegalEntityReference', fromsubclass_=False, pretty_print=True):
        super(LegalEntityReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(LegalEntityReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(LegalEntityReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class LegalEntityReference


class InterestAccrualsCompoundingMethod(InterestAccrualsMethod):
    """A type defining the way in which interests are accrued: the
    applicable rate (fixed or floating reference) and the
    compounding method."""
    member_data_items_ = {
        'compoundingMethod': MemberSpec_('compoundingMethod', ['CompoundingMethodEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = InterestAccrualsMethod
    def __init__(self, floatingRateCalculation=None, fixedRate=None, compoundingMethod=None):
        self.original_tagname_ = None
        super(InterestAccrualsCompoundingMethod, self).__init__(floatingRateCalculation, fixedRate, )
        self.compoundingMethod = compoundingMethod
        self.validate_CompoundingMethodEnum(self.compoundingMethod)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InterestAccrualsCompoundingMethod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InterestAccrualsCompoundingMethod.subclass:
            return InterestAccrualsCompoundingMethod.subclass(*args_, **kwargs_)
        else:
            return InterestAccrualsCompoundingMethod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_compoundingMethod(self): return self.compoundingMethod
    def set_compoundingMethod(self, compoundingMethod): self.compoundingMethod = compoundingMethod
    def validate_CompoundingMethodEnum(self, value):
        # Validate type CompoundingMethodEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Flat', 'None', 'Straight', 'SpreadExclusive']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CompoundingMethodEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on CompoundingMethodEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.compoundingMethod is not None or
            super(InterestAccrualsCompoundingMethod, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InterestAccrualsCompoundingMethod', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InterestAccrualsCompoundingMethod')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InterestAccrualsCompoundingMethod', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InterestAccrualsCompoundingMethod'):
        super(InterestAccrualsCompoundingMethod, self).exportAttributes(outfile, level, already_processed, namespace_, name_='InterestAccrualsCompoundingMethod')
    def exportChildren(self, outfile, level, namespace_='', name_='InterestAccrualsCompoundingMethod', fromsubclass_=False, pretty_print=True):
        super(InterestAccrualsCompoundingMethod, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.compoundingMethod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scompoundingMethod>%s</%scompoundingMethod>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.compoundingMethod), input_name='compoundingMethod')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(InterestAccrualsCompoundingMethod, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'compoundingMethod':
            compoundingMethod_ = child_.text
            compoundingMethod_ = re_.sub(String_cleanup_pat_, " ", compoundingMethod_).strip()
            compoundingMethod_ = self.gds_validate_string(compoundingMethod_, node, 'compoundingMethod')
            self.compoundingMethod = compoundingMethod_
            # validate type CompoundingMethodEnum
            self.validate_CompoundingMethodEnum(self.compoundingMethod)
        super(InterestAccrualsCompoundingMethod, self).buildChildren(child_, node, nodeName_, True)
# end class InterestAccrualsCompoundingMethod


class IdentifiedCurrencyReference(Reference):
    """Reference to a currency with ID attribute"""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(IdentifiedCurrencyReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IdentifiedCurrencyReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IdentifiedCurrencyReference.subclass:
            return IdentifiedCurrencyReference.subclass(*args_, **kwargs_)
        else:
            return IdentifiedCurrencyReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(IdentifiedCurrencyReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IdentifiedCurrencyReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifiedCurrencyReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IdentifiedCurrencyReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IdentifiedCurrencyReference'):
        super(IdentifiedCurrencyReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifiedCurrencyReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IdentifiedCurrencyReference', fromsubclass_=False, pretty_print=True):
        super(IdentifiedCurrencyReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(IdentifiedCurrencyReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(IdentifiedCurrencyReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IdentifiedCurrencyReference


class FxInformationSource(InformationSource):
    member_data_items_ = {
        'fixingTime': MemberSpec_('fixingTime', 'BusinessCenterTime', 0),
    }
    subclass = None
    superclass = InformationSource
    def __init__(self, rateSource=None, rateSourcePage=None, rateSourcePageHeading=None, fixingTime=None):
        self.original_tagname_ = None
        super(FxInformationSource, self).__init__(rateSource, rateSourcePage, rateSourcePageHeading, )
        self.fixingTime = fixingTime
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FxInformationSource)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FxInformationSource.subclass:
            return FxInformationSource.subclass(*args_, **kwargs_)
        else:
            return FxInformationSource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fixingTime(self): return self.fixingTime
    def set_fixingTime(self, fixingTime): self.fixingTime = fixingTime
    def hasContent_(self):
        if (
            self.fixingTime is not None or
            super(FxInformationSource, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FxInformationSource', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FxInformationSource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FxInformationSource', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FxInformationSource'):
        super(FxInformationSource, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FxInformationSource')
    def exportChildren(self, outfile, level, namespace_='', name_='FxInformationSource', fromsubclass_=False, pretty_print=True):
        super(FxInformationSource, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.fixingTime is not None:
            self.fixingTime.export(outfile, level, namespace_, name_='fixingTime', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FxInformationSource, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fixingTime':
            obj_ = BusinessCenterTime.factory()
            obj_.build(child_)
            self.fixingTime = obj_
            obj_.original_tagname_ = 'fixingTime'
        super(FxInformationSource, self).buildChildren(child_, node, nodeName_, True)
# end class FxInformationSource


class FutureValueAmount(NonNegativeMoney):
    """A type defining a currency amount as at a future value date.A type
    defining a currency amount as at a future value date. - For use
    with pre-trade Credit Limit Check messages."""
    member_data_items_ = {
        'calculationPeriodNumberOfDays': MemberSpec_('calculationPeriodNumberOfDays', 'xsd:positiveInteger', 0),
        'valueDate': MemberSpec_('valueDate', 'xsd:date', 0),
    }
    subclass = None
    superclass = NonNegativeMoney
    def __init__(self, id=None, currency=None, amount=None, calculationPeriodNumberOfDays=None, valueDate=None):
        self.original_tagname_ = None
        super(FutureValueAmount, self).__init__(id, currency, amount, )
        self.calculationPeriodNumberOfDays = calculationPeriodNumberOfDays
        if isinstance(valueDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(valueDate, '%Y-%m-%d').date()
        else:
            initvalue_ = valueDate
        self.valueDate = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FutureValueAmount)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FutureValueAmount.subclass:
            return FutureValueAmount.subclass(*args_, **kwargs_)
        else:
            return FutureValueAmount(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_calculationPeriodNumberOfDays(self): return self.calculationPeriodNumberOfDays
    def set_calculationPeriodNumberOfDays(self, calculationPeriodNumberOfDays): self.calculationPeriodNumberOfDays = calculationPeriodNumberOfDays
    def get_valueDate(self): return self.valueDate
    def set_valueDate(self, valueDate): self.valueDate = valueDate
    def hasContent_(self):
        if (
            self.calculationPeriodNumberOfDays is not None or
            self.valueDate is not None or
            super(FutureValueAmount, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FutureValueAmount', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FutureValueAmount')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FutureValueAmount', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FutureValueAmount'):
        super(FutureValueAmount, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FutureValueAmount')
    def exportChildren(self, outfile, level, namespace_='', name_='FutureValueAmount', fromsubclass_=False, pretty_print=True):
        super(FutureValueAmount, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.calculationPeriodNumberOfDays is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scalculationPeriodNumberOfDays>%s</%scalculationPeriodNumberOfDays>%s' % (namespace_, self.gds_format_integer(self.calculationPeriodNumberOfDays, input_name='calculationPeriodNumberOfDays'), namespace_, eol_))
        if self.valueDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalueDate>%s</%svalueDate>%s' % (namespace_, self.gds_format_date(self.valueDate, input_name='valueDate'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FutureValueAmount, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'calculationPeriodNumberOfDays':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'calculationPeriodNumberOfDays')
            self.calculationPeriodNumberOfDays = ival_
        elif nodeName_ == 'valueDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.valueDate = dval_
        super(FutureValueAmount, self).buildChildren(child_, node, nodeName_, True)
# end class FutureValueAmount


class FloatingRate(Rate):
    """A type defining a floating rate."""
    member_data_items_ = {
        'floatingRateIndex': MemberSpec_('floatingRateIndex', 'FloatingRateIndex', 0),
        'indexTenor': MemberSpec_('indexTenor', 'Period', 0),
        'floatingRateMultiplierSchedule': MemberSpec_('floatingRateMultiplierSchedule', 'Schedule', 0),
        'spreadSchedule': MemberSpec_('spreadSchedule', 'SpreadSchedule', 1),
        'rateTreatment': MemberSpec_('rateTreatment', ['RateTreatmentEnum', 'Token', 'xsd:token'], 0),
        'capRateSchedule': MemberSpec_('capRateSchedule', 'StrikeSchedule', 1),
        'floorRateSchedule': MemberSpec_('floorRateSchedule', 'StrikeSchedule', 1),
        'capFloorStraddle': MemberSpec_('capFloorStraddle', 'xsd:boolean', 0),
    }
    subclass = None
    superclass = Rate
    def __init__(self, id=None, floatingRateIndex=None, indexTenor=None, floatingRateMultiplierSchedule=None, spreadSchedule=None, rateTreatment=None, capRateSchedule=None, floorRateSchedule=None, capFloorStraddle=None, extensiontype_=None):
        self.original_tagname_ = None
        super(FloatingRate, self).__init__(id, extensiontype_, )
        self.floatingRateIndex = floatingRateIndex
        self.indexTenor = indexTenor
        self.floatingRateMultiplierSchedule = floatingRateMultiplierSchedule
        if spreadSchedule is None:
            self.spreadSchedule = []
        else:
            self.spreadSchedule = spreadSchedule
        self.rateTreatment = rateTreatment
        self.validate_RateTreatmentEnum(self.rateTreatment)
        if capRateSchedule is None:
            self.capRateSchedule = []
        else:
            self.capRateSchedule = capRateSchedule
        if floorRateSchedule is None:
            self.floorRateSchedule = []
        else:
            self.floorRateSchedule = floorRateSchedule
        self.capFloorStraddle = capFloorStraddle
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FloatingRate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FloatingRate.subclass:
            return FloatingRate.subclass(*args_, **kwargs_)
        else:
            return FloatingRate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_floatingRateIndex(self): return self.floatingRateIndex
    def set_floatingRateIndex(self, floatingRateIndex): self.floatingRateIndex = floatingRateIndex
    def get_indexTenor(self): return self.indexTenor
    def set_indexTenor(self, indexTenor): self.indexTenor = indexTenor
    def get_floatingRateMultiplierSchedule(self): return self.floatingRateMultiplierSchedule
    def set_floatingRateMultiplierSchedule(self, floatingRateMultiplierSchedule): self.floatingRateMultiplierSchedule = floatingRateMultiplierSchedule
    def get_spreadSchedule(self): return self.spreadSchedule
    def set_spreadSchedule(self, spreadSchedule): self.spreadSchedule = spreadSchedule
    def add_spreadSchedule(self, value): self.spreadSchedule.append(value)
    def insert_spreadSchedule_at(self, index, value): self.spreadSchedule.insert(index, value)
    def replace_spreadSchedule_at(self, index, value): self.spreadSchedule[index] = value
    def get_rateTreatment(self): return self.rateTreatment
    def set_rateTreatment(self, rateTreatment): self.rateTreatment = rateTreatment
    def get_capRateSchedule(self): return self.capRateSchedule
    def set_capRateSchedule(self, capRateSchedule): self.capRateSchedule = capRateSchedule
    def add_capRateSchedule(self, value): self.capRateSchedule.append(value)
    def insert_capRateSchedule_at(self, index, value): self.capRateSchedule.insert(index, value)
    def replace_capRateSchedule_at(self, index, value): self.capRateSchedule[index] = value
    def get_floorRateSchedule(self): return self.floorRateSchedule
    def set_floorRateSchedule(self, floorRateSchedule): self.floorRateSchedule = floorRateSchedule
    def add_floorRateSchedule(self, value): self.floorRateSchedule.append(value)
    def insert_floorRateSchedule_at(self, index, value): self.floorRateSchedule.insert(index, value)
    def replace_floorRateSchedule_at(self, index, value): self.floorRateSchedule[index] = value
    def get_capFloorStraddle(self): return self.capFloorStraddle
    def set_capFloorStraddle(self, capFloorStraddle): self.capFloorStraddle = capFloorStraddle
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_RateTreatmentEnum(self, value):
        # Validate type RateTreatmentEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['BondEquivalentYield', 'MoneyMarketYield']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RateTreatmentEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on RateTreatmentEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.floatingRateIndex is not None or
            self.indexTenor is not None or
            self.floatingRateMultiplierSchedule is not None or
            self.spreadSchedule or
            self.rateTreatment is not None or
            self.capRateSchedule or
            self.floorRateSchedule or
            self.capFloorStraddle is not None or
            super(FloatingRate, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FloatingRate', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FloatingRate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FloatingRate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FloatingRate'):
        super(FloatingRate, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FloatingRate')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='FloatingRate', fromsubclass_=False, pretty_print=True):
        super(FloatingRate, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.floatingRateIndex is not None:
            self.floatingRateIndex.export(outfile, level, namespace_, name_='floatingRateIndex', pretty_print=pretty_print)
        if self.indexTenor is not None:
            self.indexTenor.export(outfile, level, namespace_, name_='indexTenor', pretty_print=pretty_print)
        if self.floatingRateMultiplierSchedule is not None:
            self.floatingRateMultiplierSchedule.export(outfile, level, namespace_, name_='floatingRateMultiplierSchedule', pretty_print=pretty_print)
        for spreadSchedule_ in self.spreadSchedule:
            spreadSchedule_.export(outfile, level, namespace_, name_='spreadSchedule', pretty_print=pretty_print)
        if self.rateTreatment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srateTreatment>%s</%srateTreatment>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.rateTreatment), input_name='rateTreatment')), namespace_, eol_))
        for capRateSchedule_ in self.capRateSchedule:
            capRateSchedule_.export(outfile, level, namespace_, name_='capRateSchedule', pretty_print=pretty_print)
        for floorRateSchedule_ in self.floorRateSchedule:
            floorRateSchedule_.export(outfile, level, namespace_, name_='floorRateSchedule', pretty_print=pretty_print)
        if self.capFloorStraddle is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scapFloorStraddle>%s</%scapFloorStraddle>%s' % (namespace_, self.gds_format_boolean(self.capFloorStraddle, input_name='capFloorStraddle'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(FloatingRate, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'floatingRateIndex':
            obj_ = FloatingRateIndex.factory()
            obj_.build(child_)
            self.floatingRateIndex = obj_
            obj_.original_tagname_ = 'floatingRateIndex'
        elif nodeName_ == 'indexTenor':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.indexTenor = obj_
            obj_.original_tagname_ = 'indexTenor'
        elif nodeName_ == 'floatingRateMultiplierSchedule':
            class_obj_ = self.get_class_obj_(child_, Schedule)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.floatingRateMultiplierSchedule = obj_
            obj_.original_tagname_ = 'floatingRateMultiplierSchedule'
        elif nodeName_ == 'spreadSchedule':
            obj_ = SpreadSchedule.factory()
            obj_.build(child_)
            self.spreadSchedule.append(obj_)
            obj_.original_tagname_ = 'spreadSchedule'
        elif nodeName_ == 'rateTreatment':
            rateTreatment_ = child_.text
            rateTreatment_ = re_.sub(String_cleanup_pat_, " ", rateTreatment_).strip()
            rateTreatment_ = self.gds_validate_string(rateTreatment_, node, 'rateTreatment')
            self.rateTreatment = rateTreatment_
            # validate type RateTreatmentEnum
            self.validate_RateTreatmentEnum(self.rateTreatment)
        elif nodeName_ == 'capRateSchedule':
            obj_ = StrikeSchedule.factory()
            obj_.build(child_)
            self.capRateSchedule.append(obj_)
            obj_.original_tagname_ = 'capRateSchedule'
        elif nodeName_ == 'floorRateSchedule':
            obj_ = StrikeSchedule.factory()
            obj_.build(child_)
            self.floorRateSchedule.append(obj_)
            obj_.original_tagname_ = 'floorRateSchedule'
        elif nodeName_ == 'capFloorStraddle':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'capFloorStraddle')
            self.capFloorStraddle = ival_
        super(FloatingRate, self).buildChildren(child_, node, nodeName_, True)
# end class FloatingRate


class EuropeanExercise(Exercise):
    """A type defining the exercise period for a European style option
    together with any rules governing the notional amount of the
    underlying which can be exercised on any given exercise date and
    any associated exercise fees."""
    member_data_items_ = {
        'expirationDate': MemberSpec_('expirationDate', 'AdjustableOrRelativeDate', 0),
        'relevantUnderlyingDate': MemberSpec_('relevantUnderlyingDate', 'AdjustableOrRelativeDates', 0),
        'earliestExerciseTime': MemberSpec_('earliestExerciseTime', 'BusinessCenterTime', 0),
        'expirationTime': MemberSpec_('expirationTime', 'BusinessCenterTime', 0),
        'partialExercise': MemberSpec_('partialExercise', 'PartialExercise', 0),
        'exerciseFee': MemberSpec_('exerciseFee', 'ExerciseFee', 0),
    }
    subclass = None
    superclass = Exercise
    def __init__(self, id=None, expirationDate=None, relevantUnderlyingDate=None, earliestExerciseTime=None, expirationTime=None, partialExercise=None, exerciseFee=None):
        self.original_tagname_ = None
        super(EuropeanExercise, self).__init__(id, )
        self.expirationDate = expirationDate
        self.relevantUnderlyingDate = relevantUnderlyingDate
        self.earliestExerciseTime = earliestExerciseTime
        self.expirationTime = expirationTime
        self.partialExercise = partialExercise
        self.exerciseFee = exerciseFee
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EuropeanExercise)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EuropeanExercise.subclass:
            return EuropeanExercise.subclass(*args_, **kwargs_)
        else:
            return EuropeanExercise(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_expirationDate(self): return self.expirationDate
    def set_expirationDate(self, expirationDate): self.expirationDate = expirationDate
    def get_relevantUnderlyingDate(self): return self.relevantUnderlyingDate
    def set_relevantUnderlyingDate(self, relevantUnderlyingDate): self.relevantUnderlyingDate = relevantUnderlyingDate
    def get_earliestExerciseTime(self): return self.earliestExerciseTime
    def set_earliestExerciseTime(self, earliestExerciseTime): self.earliestExerciseTime = earliestExerciseTime
    def get_expirationTime(self): return self.expirationTime
    def set_expirationTime(self, expirationTime): self.expirationTime = expirationTime
    def get_partialExercise(self): return self.partialExercise
    def set_partialExercise(self, partialExercise): self.partialExercise = partialExercise
    def get_exerciseFee(self): return self.exerciseFee
    def set_exerciseFee(self, exerciseFee): self.exerciseFee = exerciseFee
    def hasContent_(self):
        if (
            self.expirationDate is not None or
            self.relevantUnderlyingDate is not None or
            self.earliestExerciseTime is not None or
            self.expirationTime is not None or
            self.partialExercise is not None or
            self.exerciseFee is not None or
            super(EuropeanExercise, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EuropeanExercise', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EuropeanExercise')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EuropeanExercise', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EuropeanExercise'):
        super(EuropeanExercise, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EuropeanExercise')
    def exportChildren(self, outfile, level, namespace_='', name_='EuropeanExercise', fromsubclass_=False, pretty_print=True):
        super(EuropeanExercise, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.expirationDate is not None:
            self.expirationDate.export(outfile, level, namespace_, name_='expirationDate', pretty_print=pretty_print)
        if self.relevantUnderlyingDate is not None:
            self.relevantUnderlyingDate.export(outfile, level, namespace_, name_='relevantUnderlyingDate', pretty_print=pretty_print)
        if self.earliestExerciseTime is not None:
            self.earliestExerciseTime.export(outfile, level, namespace_, name_='earliestExerciseTime', pretty_print=pretty_print)
        if self.expirationTime is not None:
            self.expirationTime.export(outfile, level, namespace_, name_='expirationTime', pretty_print=pretty_print)
        if self.partialExercise is not None:
            self.partialExercise.export(outfile, level, namespace_, name_='partialExercise', pretty_print=pretty_print)
        if self.exerciseFee is not None:
            self.exerciseFee.export(outfile, level, namespace_, name_='exerciseFee', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EuropeanExercise, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'expirationDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.expirationDate = obj_
            obj_.original_tagname_ = 'expirationDate'
        elif nodeName_ == 'relevantUnderlyingDate':
            obj_ = AdjustableOrRelativeDates.factory()
            obj_.build(child_)
            self.relevantUnderlyingDate = obj_
            obj_.original_tagname_ = 'relevantUnderlyingDate'
        elif nodeName_ == 'earliestExerciseTime':
            obj_ = BusinessCenterTime.factory()
            obj_.build(child_)
            self.earliestExerciseTime = obj_
            obj_.original_tagname_ = 'earliestExerciseTime'
        elif nodeName_ == 'expirationTime':
            obj_ = BusinessCenterTime.factory()
            obj_.build(child_)
            self.expirationTime = obj_
            obj_.original_tagname_ = 'expirationTime'
        elif nodeName_ == 'partialExercise':
            obj_ = PartialExercise.factory()
            obj_.build(child_)
            self.partialExercise = obj_
            obj_.original_tagname_ = 'partialExercise'
        elif nodeName_ == 'exerciseFee':
            obj_ = ExerciseFee.factory()
            obj_.build(child_)
            self.exerciseFee = obj_
            obj_.original_tagname_ = 'exerciseFee'
        super(EuropeanExercise, self).buildChildren(child_, node, nodeName_, True)
# end class EuropeanExercise


class DirectionalLeg(Leg):
    """An abstract base class for all directional leg types with effective
    date, termination date, where a payer makes a stream of payments
    of greater than zero value to a receiver."""
    member_data_items_ = {
        'legIdentifier': MemberSpec_('legIdentifier', 'LegIdentifier', 1),
        'payerPartyReference': MemberSpec_('payerPartyReference', 'PartyReference', 0),
        'payerAccountReference': MemberSpec_('payerAccountReference', 'AccountReference', 0),
        'receiverPartyReference': MemberSpec_('receiverPartyReference', 'PartyReference', 0),
        'receiverAccountReference': MemberSpec_('receiverAccountReference', 'AccountReference', 0),
        'effectiveDate': MemberSpec_('effectiveDate', 'AdjustableOrRelativeDate', 0),
        'terminationDate': MemberSpec_('terminationDate', 'AdjustableOrRelativeDate', 0),
    }
    subclass = None
    superclass = Leg
    def __init__(self, id=None, legIdentifier=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, effectiveDate=None, terminationDate=None, extensiontype_=None):
        self.original_tagname_ = None
        super(DirectionalLeg, self).__init__(id, extensiontype_, )
        if legIdentifier is None:
            self.legIdentifier = []
        else:
            self.legIdentifier = legIdentifier
        self.payerPartyReference = payerPartyReference
        self.payerAccountReference = payerAccountReference
        self.receiverPartyReference = receiverPartyReference
        self.receiverAccountReference = receiverAccountReference
        self.effectiveDate = effectiveDate
        self.terminationDate = terminationDate
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DirectionalLeg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DirectionalLeg.subclass:
            return DirectionalLeg.subclass(*args_, **kwargs_)
        else:
            return DirectionalLeg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_legIdentifier(self): return self.legIdentifier
    def set_legIdentifier(self, legIdentifier): self.legIdentifier = legIdentifier
    def add_legIdentifier(self, value): self.legIdentifier.append(value)
    def insert_legIdentifier_at(self, index, value): self.legIdentifier.insert(index, value)
    def replace_legIdentifier_at(self, index, value): self.legIdentifier[index] = value
    def get_payerPartyReference(self): return self.payerPartyReference
    def set_payerPartyReference(self, payerPartyReference): self.payerPartyReference = payerPartyReference
    def get_payerAccountReference(self): return self.payerAccountReference
    def set_payerAccountReference(self, payerAccountReference): self.payerAccountReference = payerAccountReference
    def get_receiverPartyReference(self): return self.receiverPartyReference
    def set_receiverPartyReference(self, receiverPartyReference): self.receiverPartyReference = receiverPartyReference
    def get_receiverAccountReference(self): return self.receiverAccountReference
    def set_receiverAccountReference(self, receiverAccountReference): self.receiverAccountReference = receiverAccountReference
    def get_effectiveDate(self): return self.effectiveDate
    def set_effectiveDate(self, effectiveDate): self.effectiveDate = effectiveDate
    def get_terminationDate(self): return self.terminationDate
    def set_terminationDate(self, terminationDate): self.terminationDate = terminationDate
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.legIdentifier or
            self.payerPartyReference is not None or
            self.payerAccountReference is not None or
            self.receiverPartyReference is not None or
            self.receiverAccountReference is not None or
            self.effectiveDate is not None or
            self.terminationDate is not None or
            super(DirectionalLeg, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DirectionalLeg', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DirectionalLeg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DirectionalLeg', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DirectionalLeg'):
        super(DirectionalLeg, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DirectionalLeg')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='DirectionalLeg', fromsubclass_=False, pretty_print=True):
        super(DirectionalLeg, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for legIdentifier_ in self.legIdentifier:
            legIdentifier_.export(outfile, level, namespace_, name_='legIdentifier', pretty_print=pretty_print)
        if self.payerPartyReference is not None:
            self.payerPartyReference.export(outfile, level, namespace_, name_='payerPartyReference', pretty_print=pretty_print)
        if self.payerAccountReference is not None:
            self.payerAccountReference.export(outfile, level, namespace_, name_='payerAccountReference', pretty_print=pretty_print)
        if self.receiverPartyReference is not None:
            self.receiverPartyReference.export(outfile, level, namespace_, name_='receiverPartyReference', pretty_print=pretty_print)
        if self.receiverAccountReference is not None:
            self.receiverAccountReference.export(outfile, level, namespace_, name_='receiverAccountReference', pretty_print=pretty_print)
        if self.effectiveDate is not None:
            self.effectiveDate.export(outfile, level, namespace_, name_='effectiveDate', pretty_print=pretty_print)
        if self.terminationDate is not None:
            self.terminationDate.export(outfile, level, namespace_, name_='terminationDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(DirectionalLeg, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'legIdentifier':
            obj_ = LegIdentifier.factory()
            obj_.build(child_)
            self.legIdentifier.append(obj_)
            obj_.original_tagname_ = 'legIdentifier'
        elif nodeName_ == 'payerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.payerPartyReference = obj_
            obj_.original_tagname_ = 'payerPartyReference'
        elif nodeName_ == 'payerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.payerAccountReference = obj_
            obj_.original_tagname_ = 'payerAccountReference'
        elif nodeName_ == 'receiverPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.receiverPartyReference = obj_
            obj_.original_tagname_ = 'receiverPartyReference'
        elif nodeName_ == 'receiverAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.receiverAccountReference = obj_
            obj_.original_tagname_ = 'receiverAccountReference'
        elif nodeName_ == 'effectiveDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.effectiveDate = obj_
            obj_.original_tagname_ = 'effectiveDate'
        elif nodeName_ == 'terminationDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.terminationDate = obj_
            obj_.original_tagname_ = 'terminationDate'
        super(DirectionalLeg, self).buildChildren(child_, node, nodeName_, True)
# end class DirectionalLeg


class DeterminationMethodReference(Reference):
    """A reference to the return swap notional determination method."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(DeterminationMethodReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DeterminationMethodReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DeterminationMethodReference.subclass:
            return DeterminationMethodReference.subclass(*args_, **kwargs_)
        else:
            return DeterminationMethodReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(DeterminationMethodReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DeterminationMethodReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeterminationMethodReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DeterminationMethodReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DeterminationMethodReference'):
        super(DeterminationMethodReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DeterminationMethodReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DeterminationMethodReference', fromsubclass_=False, pretty_print=True):
        super(DeterminationMethodReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(DeterminationMethodReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DeterminationMethodReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DeterminationMethodReference


class DateReference(Reference):
    """Reference to an identified date or a complex date structure."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(DateReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DateReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DateReference.subclass:
            return DateReference.subclass(*args_, **kwargs_)
        else:
            return DateReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(DateReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DateReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DateReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DateReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DateReference'):
        super(DateReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DateReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DateReference', fromsubclass_=False, pretty_print=True):
        super(DateReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(DateReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DateReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DateReference


class DateOffset(Offset):
    """A type defining an offset used in calculating a date when this date
    is defined in reference to another date through a date offset.
    The type includes the convention for adjusting the date and an
    optional sequence element to indicate the order in a sequence of
    multiple date offsets."""
    member_data_items_ = {
        'businessDayConvention': MemberSpec_('businessDayConvention', ['BusinessDayConventionEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = Offset
    def __init__(self, id=None, periodMultiplier=None, period=None, dayType=None, businessDayConvention=None):
        self.original_tagname_ = None
        super(DateOffset, self).__init__(id, periodMultiplier, period, dayType, )
        self.businessDayConvention = businessDayConvention
        self.validate_BusinessDayConventionEnum(self.businessDayConvention)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DateOffset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DateOffset.subclass:
            return DateOffset.subclass(*args_, **kwargs_)
        else:
            return DateOffset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_businessDayConvention(self): return self.businessDayConvention
    def set_businessDayConvention(self, businessDayConvention): self.businessDayConvention = businessDayConvention
    def validate_BusinessDayConventionEnum(self, value):
        # Validate type BusinessDayConventionEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FOLLOWING', 'FRN', 'MODFOLLOWING', 'PRECEDING', 'MODPRECEDING', 'NEAREST', 'NONE', 'NotApplicable']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on BusinessDayConventionEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on BusinessDayConventionEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.businessDayConvention is not None or
            super(DateOffset, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DateOffset', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DateOffset')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DateOffset', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DateOffset'):
        super(DateOffset, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DateOffset')
    def exportChildren(self, outfile, level, namespace_='', name_='DateOffset', fromsubclass_=False, pretty_print=True):
        super(DateOffset, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.businessDayConvention is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbusinessDayConvention>%s</%sbusinessDayConvention>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.businessDayConvention), input_name='businessDayConvention')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DateOffset, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'businessDayConvention':
            businessDayConvention_ = child_.text
            businessDayConvention_ = re_.sub(String_cleanup_pat_, " ", businessDayConvention_).strip()
            businessDayConvention_ = self.gds_validate_string(businessDayConvention_, node, 'businessDayConvention')
            self.businessDayConvention = businessDayConvention_
            # validate type BusinessDayConventionEnum
            self.validate_BusinessDayConventionEnum(self.businessDayConvention)
        super(DateOffset, self).buildChildren(child_, node, nodeName_, True)
# end class DateOffset


class CalculationPeriodFrequency(Frequency):
    """A type defining the frequency at which calculation period end dates
    occur within the regular part of the calculation period schedule
    and thier roll date convention. In case the calculation
    frequency is of value T (term), the period is defined by the
    swap\swapStream\calculationPerioDates\effectiveDate and the
    swap\swapStream\calculationPerioDates\terminationDate."""
    member_data_items_ = {
        'rollConvention': MemberSpec_('rollConvention', ['RollConventionEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = Frequency
    def __init__(self, id=None, periodMultiplier=None, period=None, rollConvention=None):
        self.original_tagname_ = None
        super(CalculationPeriodFrequency, self).__init__(id, periodMultiplier, period, )
        self.rollConvention = rollConvention
        self.validate_RollConventionEnum(self.rollConvention)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CalculationPeriodFrequency)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CalculationPeriodFrequency.subclass:
            return CalculationPeriodFrequency.subclass(*args_, **kwargs_)
        else:
            return CalculationPeriodFrequency(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rollConvention(self): return self.rollConvention
    def set_rollConvention(self, rollConvention): self.rollConvention = rollConvention
    def validate_RollConventionEnum(self, value):
        # Validate type RollConventionEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['EOM', 'FRN', 'IMM', 'IMMCAD', 'IMMAUD', 'IMMNZD', 'SFE', 'NONE', 'TBILL', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '30', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT', 'SUN']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RollConventionEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on RollConventionEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.rollConvention is not None or
            super(CalculationPeriodFrequency, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CalculationPeriodFrequency', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CalculationPeriodFrequency')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CalculationPeriodFrequency', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CalculationPeriodFrequency'):
        super(CalculationPeriodFrequency, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CalculationPeriodFrequency')
    def exportChildren(self, outfile, level, namespace_='', name_='CalculationPeriodFrequency', fromsubclass_=False, pretty_print=True):
        super(CalculationPeriodFrequency, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.rollConvention is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srollConvention>%s</%srollConvention>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.rollConvention), input_name='rollConvention')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CalculationPeriodFrequency, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'rollConvention':
            rollConvention_ = child_.text
            rollConvention_ = re_.sub(String_cleanup_pat_, " ", rollConvention_).strip()
            rollConvention_ = self.gds_validate_string(rollConvention_, node, 'rollConvention')
            self.rollConvention = rollConvention_
            # validate type RollConventionEnum
            self.validate_RollConventionEnum(self.rollConvention)
        super(CalculationPeriodFrequency, self).buildChildren(child_, node, nodeName_, True)
# end class CalculationPeriodFrequency


class BusinessUnitReference(Reference):
    """Reference to an organizational unit."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(BusinessUnitReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BusinessUnitReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BusinessUnitReference.subclass:
            return BusinessUnitReference.subclass(*args_, **kwargs_)
        else:
            return BusinessUnitReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(BusinessUnitReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BusinessUnitReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BusinessUnitReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BusinessUnitReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BusinessUnitReference'):
        super(BusinessUnitReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BusinessUnitReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BusinessUnitReference', fromsubclass_=False, pretty_print=True):
        super(BusinessUnitReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(BusinessUnitReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(BusinessUnitReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BusinessUnitReference


class BusinessDayAdjustmentsReference(Reference):
    """Reference to a business day adjustments structure."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(BusinessDayAdjustmentsReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BusinessDayAdjustmentsReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BusinessDayAdjustmentsReference.subclass:
            return BusinessDayAdjustmentsReference.subclass(*args_, **kwargs_)
        else:
            return BusinessDayAdjustmentsReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(BusinessDayAdjustmentsReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BusinessDayAdjustmentsReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BusinessDayAdjustmentsReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BusinessDayAdjustmentsReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BusinessDayAdjustmentsReference'):
        super(BusinessDayAdjustmentsReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BusinessDayAdjustmentsReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BusinessDayAdjustmentsReference', fromsubclass_=False, pretty_print=True):
        super(BusinessDayAdjustmentsReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(BusinessDayAdjustmentsReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(BusinessDayAdjustmentsReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BusinessDayAdjustmentsReference


class BusinessDateRange(DateRange):
    """A type defining a range of contiguous business days by defining an
    unadjusted first date, an unadjusted last date and a business
    day convention and business centers for adjusting the first and
    last dates if they would otherwise fall on a non business day in
    the specified business centers. The days between the first and
    last date must also be good business days in the specified
    centers to be counted in the range."""
    member_data_items_ = {
        'businessDayConvention': MemberSpec_('businessDayConvention', ['BusinessDayConventionEnum', 'Token', 'xsd:token'], 0),
        'businessCentersReference': MemberSpec_('businessCentersReference', 'BusinessCentersReference', 0),
        'businessCenters': MemberSpec_('businessCenters', 'BusinessCenters', 0),
    }
    subclass = None
    superclass = DateRange
    def __init__(self, unadjustedFirstDate=None, unadjustedLastDate=None, businessDayConvention=None, businessCentersReference=None, businessCenters=None):
        self.original_tagname_ = None
        super(BusinessDateRange, self).__init__(unadjustedFirstDate, unadjustedLastDate, )
        self.businessDayConvention = businessDayConvention
        self.validate_BusinessDayConventionEnum(self.businessDayConvention)
        self.businessCentersReference = businessCentersReference
        self.businessCenters = businessCenters
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BusinessDateRange)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BusinessDateRange.subclass:
            return BusinessDateRange.subclass(*args_, **kwargs_)
        else:
            return BusinessDateRange(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_businessDayConvention(self): return self.businessDayConvention
    def set_businessDayConvention(self, businessDayConvention): self.businessDayConvention = businessDayConvention
    def get_businessCentersReference(self): return self.businessCentersReference
    def set_businessCentersReference(self, businessCentersReference): self.businessCentersReference = businessCentersReference
    def get_businessCenters(self): return self.businessCenters
    def set_businessCenters(self, businessCenters): self.businessCenters = businessCenters
    def validate_BusinessDayConventionEnum(self, value):
        # Validate type BusinessDayConventionEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FOLLOWING', 'FRN', 'MODFOLLOWING', 'PRECEDING', 'MODPRECEDING', 'NEAREST', 'NONE', 'NotApplicable']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on BusinessDayConventionEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on BusinessDayConventionEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.businessDayConvention is not None or
            self.businessCentersReference is not None or
            self.businessCenters is not None or
            super(BusinessDateRange, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BusinessDateRange', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BusinessDateRange')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BusinessDateRange', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BusinessDateRange'):
        super(BusinessDateRange, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BusinessDateRange')
    def exportChildren(self, outfile, level, namespace_='', name_='BusinessDateRange', fromsubclass_=False, pretty_print=True):
        super(BusinessDateRange, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.businessDayConvention is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbusinessDayConvention>%s</%sbusinessDayConvention>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.businessDayConvention), input_name='businessDayConvention')), namespace_, eol_))
        if self.businessCentersReference is not None:
            self.businessCentersReference.export(outfile, level, namespace_, name_='businessCentersReference', pretty_print=pretty_print)
        if self.businessCenters is not None:
            self.businessCenters.export(outfile, level, namespace_, name_='businessCenters', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(BusinessDateRange, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'businessDayConvention':
            businessDayConvention_ = child_.text
            businessDayConvention_ = re_.sub(String_cleanup_pat_, " ", businessDayConvention_).strip()
            businessDayConvention_ = self.gds_validate_string(businessDayConvention_, node, 'businessDayConvention')
            self.businessDayConvention = businessDayConvention_
            # validate type BusinessDayConventionEnum
            self.validate_BusinessDayConventionEnum(self.businessDayConvention)
        elif nodeName_ == 'businessCentersReference':
            obj_ = BusinessCentersReference.factory()
            obj_.build(child_)
            self.businessCentersReference = obj_
            obj_.original_tagname_ = 'businessCentersReference'
        elif nodeName_ == 'businessCenters':
            obj_ = BusinessCenters.factory()
            obj_.build(child_)
            self.businessCenters = obj_
            obj_.original_tagname_ = 'businessCenters'
        super(BusinessDateRange, self).buildChildren(child_, node, nodeName_, True)
# end class BusinessDateRange


class BusinessCentersReference(Reference):
    """A pointer style reference to a set of business day calendar defined
    elsewhere in the document."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(BusinessCentersReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BusinessCentersReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BusinessCentersReference.subclass:
            return BusinessCentersReference.subclass(*args_, **kwargs_)
        else:
            return BusinessCentersReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(BusinessCentersReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BusinessCentersReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BusinessCentersReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BusinessCentersReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BusinessCentersReference'):
        super(BusinessCentersReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BusinessCentersReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BusinessCentersReference', fromsubclass_=False, pretty_print=True):
        super(BusinessCentersReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(BusinessCentersReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(BusinessCentersReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BusinessCentersReference


class BermudaExercise(Exercise):
    """A type defining the Bermuda option exercise dates and the expiration
    date together with any rules govenerning the notional amount of
    the underlying which can be exercised on any given exercise date
    and any associated exercise fee."""
    member_data_items_ = {
        'bermudaExerciseDates': MemberSpec_('bermudaExerciseDates', 'AdjustableOrRelativeDates', 0),
        'relevantUnderlyingDate': MemberSpec_('relevantUnderlyingDate', 'AdjustableOrRelativeDates', 0),
        'earliestExerciseTime': MemberSpec_('earliestExerciseTime', 'BusinessCenterTime', 0),
        'latestExerciseTime': MemberSpec_('latestExerciseTime', 'BusinessCenterTime', 0),
        'expirationTime': MemberSpec_('expirationTime', 'BusinessCenterTime', 0),
        'multipleExercise': MemberSpec_('multipleExercise', 'MultipleExercise', 0),
        'exerciseFeeSchedule': MemberSpec_('exerciseFeeSchedule', 'ExerciseFeeSchedule', 0),
    }
    subclass = None
    superclass = Exercise
    def __init__(self, id=None, bermudaExerciseDates=None, relevantUnderlyingDate=None, earliestExerciseTime=None, latestExerciseTime=None, expirationTime=None, multipleExercise=None, exerciseFeeSchedule=None):
        self.original_tagname_ = None
        super(BermudaExercise, self).__init__(id, )
        self.bermudaExerciseDates = bermudaExerciseDates
        self.relevantUnderlyingDate = relevantUnderlyingDate
        self.earliestExerciseTime = earliestExerciseTime
        self.latestExerciseTime = latestExerciseTime
        self.expirationTime = expirationTime
        self.multipleExercise = multipleExercise
        self.exerciseFeeSchedule = exerciseFeeSchedule
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BermudaExercise)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BermudaExercise.subclass:
            return BermudaExercise.subclass(*args_, **kwargs_)
        else:
            return BermudaExercise(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_bermudaExerciseDates(self): return self.bermudaExerciseDates
    def set_bermudaExerciseDates(self, bermudaExerciseDates): self.bermudaExerciseDates = bermudaExerciseDates
    def get_relevantUnderlyingDate(self): return self.relevantUnderlyingDate
    def set_relevantUnderlyingDate(self, relevantUnderlyingDate): self.relevantUnderlyingDate = relevantUnderlyingDate
    def get_earliestExerciseTime(self): return self.earliestExerciseTime
    def set_earliestExerciseTime(self, earliestExerciseTime): self.earliestExerciseTime = earliestExerciseTime
    def get_latestExerciseTime(self): return self.latestExerciseTime
    def set_latestExerciseTime(self, latestExerciseTime): self.latestExerciseTime = latestExerciseTime
    def get_expirationTime(self): return self.expirationTime
    def set_expirationTime(self, expirationTime): self.expirationTime = expirationTime
    def get_multipleExercise(self): return self.multipleExercise
    def set_multipleExercise(self, multipleExercise): self.multipleExercise = multipleExercise
    def get_exerciseFeeSchedule(self): return self.exerciseFeeSchedule
    def set_exerciseFeeSchedule(self, exerciseFeeSchedule): self.exerciseFeeSchedule = exerciseFeeSchedule
    def hasContent_(self):
        if (
            self.bermudaExerciseDates is not None or
            self.relevantUnderlyingDate is not None or
            self.earliestExerciseTime is not None or
            self.latestExerciseTime is not None or
            self.expirationTime is not None or
            self.multipleExercise is not None or
            self.exerciseFeeSchedule is not None or
            super(BermudaExercise, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BermudaExercise', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BermudaExercise')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BermudaExercise', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BermudaExercise'):
        super(BermudaExercise, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BermudaExercise')
    def exportChildren(self, outfile, level, namespace_='', name_='BermudaExercise', fromsubclass_=False, pretty_print=True):
        super(BermudaExercise, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.bermudaExerciseDates is not None:
            self.bermudaExerciseDates.export(outfile, level, namespace_, name_='bermudaExerciseDates', pretty_print=pretty_print)
        if self.relevantUnderlyingDate is not None:
            self.relevantUnderlyingDate.export(outfile, level, namespace_, name_='relevantUnderlyingDate', pretty_print=pretty_print)
        if self.earliestExerciseTime is not None:
            self.earliestExerciseTime.export(outfile, level, namespace_, name_='earliestExerciseTime', pretty_print=pretty_print)
        if self.latestExerciseTime is not None:
            self.latestExerciseTime.export(outfile, level, namespace_, name_='latestExerciseTime', pretty_print=pretty_print)
        if self.expirationTime is not None:
            self.expirationTime.export(outfile, level, namespace_, name_='expirationTime', pretty_print=pretty_print)
        if self.multipleExercise is not None:
            self.multipleExercise.export(outfile, level, namespace_, name_='multipleExercise', pretty_print=pretty_print)
        if self.exerciseFeeSchedule is not None:
            self.exerciseFeeSchedule.export(outfile, level, namespace_, name_='exerciseFeeSchedule', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(BermudaExercise, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'bermudaExerciseDates':
            obj_ = AdjustableOrRelativeDates.factory()
            obj_.build(child_)
            self.bermudaExerciseDates = obj_
            obj_.original_tagname_ = 'bermudaExerciseDates'
        elif nodeName_ == 'relevantUnderlyingDate':
            obj_ = AdjustableOrRelativeDates.factory()
            obj_.build(child_)
            self.relevantUnderlyingDate = obj_
            obj_.original_tagname_ = 'relevantUnderlyingDate'
        elif nodeName_ == 'earliestExerciseTime':
            obj_ = BusinessCenterTime.factory()
            obj_.build(child_)
            self.earliestExerciseTime = obj_
            obj_.original_tagname_ = 'earliestExerciseTime'
        elif nodeName_ == 'latestExerciseTime':
            obj_ = BusinessCenterTime.factory()
            obj_.build(child_)
            self.latestExerciseTime = obj_
            obj_.original_tagname_ = 'latestExerciseTime'
        elif nodeName_ == 'expirationTime':
            obj_ = BusinessCenterTime.factory()
            obj_.build(child_)
            self.expirationTime = obj_
            obj_.original_tagname_ = 'expirationTime'
        elif nodeName_ == 'multipleExercise':
            obj_ = MultipleExercise.factory()
            obj_.build(child_)
            self.multipleExercise = obj_
            obj_.original_tagname_ = 'multipleExercise'
        elif nodeName_ == 'exerciseFeeSchedule':
            obj_ = ExerciseFeeSchedule.factory()
            obj_.build(child_)
            self.exerciseFeeSchedule = obj_
            obj_.original_tagname_ = 'exerciseFeeSchedule'
        super(BermudaExercise, self).buildChildren(child_, node, nodeName_, True)
# end class BermudaExercise


class AmountSchedule(Schedule):
    """A type defining a currency amount or a currency amount schedule."""
    member_data_items_ = {
        'currency': MemberSpec_('currency', 'Currency', 0),
    }
    subclass = None
    superclass = Schedule
    def __init__(self, id=None, initialValue=None, step=None, currency=None):
        self.original_tagname_ = None
        super(AmountSchedule, self).__init__(id, initialValue, step, )
        self.currency = currency
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AmountSchedule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AmountSchedule.subclass:
            return AmountSchedule.subclass(*args_, **kwargs_)
        else:
            return AmountSchedule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def hasContent_(self):
        if (
            self.currency is not None or
            super(AmountSchedule, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AmountSchedule', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AmountSchedule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AmountSchedule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AmountSchedule'):
        super(AmountSchedule, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AmountSchedule')
    def exportChildren(self, outfile, level, namespace_='', name_='AmountSchedule', fromsubclass_=False, pretty_print=True):
        super(AmountSchedule, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.currency is not None:
            self.currency.export(outfile, level, namespace_, name_='currency', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AmountSchedule, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'currency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        super(AmountSchedule, self).buildChildren(child_, node, nodeName_, True)
# end class AmountSchedule


class AmountReference(Reference):
    """Specifies a reference to a monetary amount."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(AmountReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AmountReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AmountReference.subclass:
            return AmountReference.subclass(*args_, **kwargs_)
        else:
            return AmountReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(AmountReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AmountReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AmountReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AmountReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AmountReference'):
        super(AmountReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AmountReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AmountReference', fromsubclass_=False, pretty_print=True):
        super(AmountReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(AmountReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AmountReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AmountReference


class AmericanExercise(Exercise):
    """A type defining the exercise period for an American style option
    together with any rules governing the notional amount of the
    underlying which can be exercised on any given exercise date and
    any associated exercise fees."""
    member_data_items_ = {
        'commencementDate': MemberSpec_('commencementDate', 'AdjustableOrRelativeDate', 0),
        'expirationDate': MemberSpec_('expirationDate', 'AdjustableOrRelativeDate', 0),
        'relevantUnderlyingDate': MemberSpec_('relevantUnderlyingDate', 'AdjustableOrRelativeDates', 0),
        'earliestExerciseTime': MemberSpec_('earliestExerciseTime', 'BusinessCenterTime', 0),
        'latestExerciseTime': MemberSpec_('latestExerciseTime', 'BusinessCenterTime', 0),
        'expirationTime': MemberSpec_('expirationTime', 'BusinessCenterTime', 0),
        'multipleExercise': MemberSpec_('multipleExercise', 'MultipleExercise', 0),
        'exerciseFeeSchedule': MemberSpec_('exerciseFeeSchedule', 'ExerciseFeeSchedule', 0),
    }
    subclass = None
    superclass = Exercise
    def __init__(self, id=None, commencementDate=None, expirationDate=None, relevantUnderlyingDate=None, earliestExerciseTime=None, latestExerciseTime=None, expirationTime=None, multipleExercise=None, exerciseFeeSchedule=None):
        self.original_tagname_ = None
        super(AmericanExercise, self).__init__(id, )
        self.commencementDate = commencementDate
        self.expirationDate = expirationDate
        self.relevantUnderlyingDate = relevantUnderlyingDate
        self.earliestExerciseTime = earliestExerciseTime
        self.latestExerciseTime = latestExerciseTime
        self.expirationTime = expirationTime
        self.multipleExercise = multipleExercise
        self.exerciseFeeSchedule = exerciseFeeSchedule
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AmericanExercise)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AmericanExercise.subclass:
            return AmericanExercise.subclass(*args_, **kwargs_)
        else:
            return AmericanExercise(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commencementDate(self): return self.commencementDate
    def set_commencementDate(self, commencementDate): self.commencementDate = commencementDate
    def get_expirationDate(self): return self.expirationDate
    def set_expirationDate(self, expirationDate): self.expirationDate = expirationDate
    def get_relevantUnderlyingDate(self): return self.relevantUnderlyingDate
    def set_relevantUnderlyingDate(self, relevantUnderlyingDate): self.relevantUnderlyingDate = relevantUnderlyingDate
    def get_earliestExerciseTime(self): return self.earliestExerciseTime
    def set_earliestExerciseTime(self, earliestExerciseTime): self.earliestExerciseTime = earliestExerciseTime
    def get_latestExerciseTime(self): return self.latestExerciseTime
    def set_latestExerciseTime(self, latestExerciseTime): self.latestExerciseTime = latestExerciseTime
    def get_expirationTime(self): return self.expirationTime
    def set_expirationTime(self, expirationTime): self.expirationTime = expirationTime
    def get_multipleExercise(self): return self.multipleExercise
    def set_multipleExercise(self, multipleExercise): self.multipleExercise = multipleExercise
    def get_exerciseFeeSchedule(self): return self.exerciseFeeSchedule
    def set_exerciseFeeSchedule(self, exerciseFeeSchedule): self.exerciseFeeSchedule = exerciseFeeSchedule
    def hasContent_(self):
        if (
            self.commencementDate is not None or
            self.expirationDate is not None or
            self.relevantUnderlyingDate is not None or
            self.earliestExerciseTime is not None or
            self.latestExerciseTime is not None or
            self.expirationTime is not None or
            self.multipleExercise is not None or
            self.exerciseFeeSchedule is not None or
            super(AmericanExercise, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AmericanExercise', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AmericanExercise')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AmericanExercise', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AmericanExercise'):
        super(AmericanExercise, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AmericanExercise')
    def exportChildren(self, outfile, level, namespace_='', name_='AmericanExercise', fromsubclass_=False, pretty_print=True):
        super(AmericanExercise, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.commencementDate is not None:
            self.commencementDate.export(outfile, level, namespace_, name_='commencementDate', pretty_print=pretty_print)
        if self.expirationDate is not None:
            self.expirationDate.export(outfile, level, namespace_, name_='expirationDate', pretty_print=pretty_print)
        if self.relevantUnderlyingDate is not None:
            self.relevantUnderlyingDate.export(outfile, level, namespace_, name_='relevantUnderlyingDate', pretty_print=pretty_print)
        if self.earliestExerciseTime is not None:
            self.earliestExerciseTime.export(outfile, level, namespace_, name_='earliestExerciseTime', pretty_print=pretty_print)
        if self.latestExerciseTime is not None:
            self.latestExerciseTime.export(outfile, level, namespace_, name_='latestExerciseTime', pretty_print=pretty_print)
        if self.expirationTime is not None:
            self.expirationTime.export(outfile, level, namespace_, name_='expirationTime', pretty_print=pretty_print)
        if self.multipleExercise is not None:
            self.multipleExercise.export(outfile, level, namespace_, name_='multipleExercise', pretty_print=pretty_print)
        if self.exerciseFeeSchedule is not None:
            self.exerciseFeeSchedule.export(outfile, level, namespace_, name_='exerciseFeeSchedule', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AmericanExercise, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'commencementDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.commencementDate = obj_
            obj_.original_tagname_ = 'commencementDate'
        elif nodeName_ == 'expirationDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.expirationDate = obj_
            obj_.original_tagname_ = 'expirationDate'
        elif nodeName_ == 'relevantUnderlyingDate':
            obj_ = AdjustableOrRelativeDates.factory()
            obj_.build(child_)
            self.relevantUnderlyingDate = obj_
            obj_.original_tagname_ = 'relevantUnderlyingDate'
        elif nodeName_ == 'earliestExerciseTime':
            obj_ = BusinessCenterTime.factory()
            obj_.build(child_)
            self.earliestExerciseTime = obj_
            obj_.original_tagname_ = 'earliestExerciseTime'
        elif nodeName_ == 'latestExerciseTime':
            obj_ = BusinessCenterTime.factory()
            obj_.build(child_)
            self.latestExerciseTime = obj_
            obj_.original_tagname_ = 'latestExerciseTime'
        elif nodeName_ == 'expirationTime':
            obj_ = BusinessCenterTime.factory()
            obj_.build(child_)
            self.expirationTime = obj_
            obj_.original_tagname_ = 'expirationTime'
        elif nodeName_ == 'multipleExercise':
            obj_ = MultipleExercise.factory()
            obj_.build(child_)
            self.multipleExercise = obj_
            obj_.original_tagname_ = 'multipleExercise'
        elif nodeName_ == 'exerciseFeeSchedule':
            obj_ = ExerciseFeeSchedule.factory()
            obj_.build(child_)
            self.exerciseFeeSchedule = obj_
            obj_.original_tagname_ = 'exerciseFeeSchedule'
        super(AmericanExercise, self).buildChildren(child_, node, nodeName_, True)
# end class AmericanExercise


class AccountReference(Reference):
    """Reference to an account."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(AccountReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AccountReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AccountReference.subclass:
            return AccountReference.subclass(*args_, **kwargs_)
        else:
            return AccountReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(AccountReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AccountReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AccountReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AccountReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AccountReference'):
        super(AccountReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AccountReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AccountReference', fromsubclass_=False, pretty_print=True):
        super(AccountReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(AccountReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AccountReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AccountReference


class SimpleIRSwap(UnderlyingAsset):
    member_data_items_ = {
        'term': MemberSpec_('term', 'Period', 0),
        'paymentFrequency': MemberSpec_('paymentFrequency', 'Period', 0),
        'dayCountFraction': MemberSpec_('dayCountFraction', 'DayCountFraction', 0),
    }
    subclass = None
    superclass = UnderlyingAsset
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, term=None, paymentFrequency=None, dayCountFraction=None):
        self.original_tagname_ = None
        super(SimpleIRSwap, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, )
        self.term = term
        self.paymentFrequency = paymentFrequency
        self.dayCountFraction = dayCountFraction
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SimpleIRSwap)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SimpleIRSwap.subclass:
            return SimpleIRSwap.subclass(*args_, **kwargs_)
        else:
            return SimpleIRSwap(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_term(self): return self.term
    def set_term(self, term): self.term = term
    def get_paymentFrequency(self): return self.paymentFrequency
    def set_paymentFrequency(self, paymentFrequency): self.paymentFrequency = paymentFrequency
    def get_dayCountFraction(self): return self.dayCountFraction
    def set_dayCountFraction(self, dayCountFraction): self.dayCountFraction = dayCountFraction
    def hasContent_(self):
        if (
            self.term is not None or
            self.paymentFrequency is not None or
            self.dayCountFraction is not None or
            super(SimpleIRSwap, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SimpleIRSwap', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SimpleIRSwap')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SimpleIRSwap', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SimpleIRSwap'):
        super(SimpleIRSwap, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SimpleIRSwap')
    def exportChildren(self, outfile, level, namespace_='', name_='SimpleIRSwap', fromsubclass_=False, pretty_print=True):
        super(SimpleIRSwap, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.term is not None:
            self.term.export(outfile, level, namespace_, name_='term', pretty_print=pretty_print)
        if self.paymentFrequency is not None:
            self.paymentFrequency.export(outfile, level, namespace_, name_='paymentFrequency', pretty_print=pretty_print)
        if self.dayCountFraction is not None:
            self.dayCountFraction.export(outfile, level, namespace_, name_='dayCountFraction', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SimpleIRSwap, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'term':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.term = obj_
            obj_.original_tagname_ = 'term'
        elif nodeName_ == 'paymentFrequency':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.paymentFrequency = obj_
            obj_.original_tagname_ = 'paymentFrequency'
        elif nodeName_ == 'dayCountFraction':
            obj_ = DayCountFraction.factory()
            obj_.build(child_)
            self.dayCountFraction = obj_
            obj_.original_tagname_ = 'dayCountFraction'
        super(SimpleIRSwap, self).buildChildren(child_, node, nodeName_, True)
# end class SimpleIRSwap


class SimpleFra(UnderlyingAsset):
    member_data_items_ = {
        'startTerm': MemberSpec_('startTerm', 'Period', 0),
        'endTerm': MemberSpec_('endTerm', 'Period', 0),
        'dayCountFraction': MemberSpec_('dayCountFraction', 'DayCountFraction', 0),
    }
    subclass = None
    superclass = UnderlyingAsset
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, startTerm=None, endTerm=None, dayCountFraction=None):
        self.original_tagname_ = None
        super(SimpleFra, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, )
        self.startTerm = startTerm
        self.endTerm = endTerm
        self.dayCountFraction = dayCountFraction
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SimpleFra)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SimpleFra.subclass:
            return SimpleFra.subclass(*args_, **kwargs_)
        else:
            return SimpleFra(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_startTerm(self): return self.startTerm
    def set_startTerm(self, startTerm): self.startTerm = startTerm
    def get_endTerm(self): return self.endTerm
    def set_endTerm(self, endTerm): self.endTerm = endTerm
    def get_dayCountFraction(self): return self.dayCountFraction
    def set_dayCountFraction(self, dayCountFraction): self.dayCountFraction = dayCountFraction
    def hasContent_(self):
        if (
            self.startTerm is not None or
            self.endTerm is not None or
            self.dayCountFraction is not None or
            super(SimpleFra, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SimpleFra', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SimpleFra')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SimpleFra', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SimpleFra'):
        super(SimpleFra, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SimpleFra')
    def exportChildren(self, outfile, level, namespace_='', name_='SimpleFra', fromsubclass_=False, pretty_print=True):
        super(SimpleFra, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.startTerm is not None:
            self.startTerm.export(outfile, level, namespace_, name_='startTerm', pretty_print=pretty_print)
        if self.endTerm is not None:
            self.endTerm.export(outfile, level, namespace_, name_='endTerm', pretty_print=pretty_print)
        if self.dayCountFraction is not None:
            self.dayCountFraction.export(outfile, level, namespace_, name_='dayCountFraction', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SimpleFra, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'startTerm':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.startTerm = obj_
            obj_.original_tagname_ = 'startTerm'
        elif nodeName_ == 'endTerm':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.endTerm = obj_
            obj_.original_tagname_ = 'endTerm'
        elif nodeName_ == 'dayCountFraction':
            obj_ = DayCountFraction.factory()
            obj_.build(child_)
            self.dayCountFraction = obj_
            obj_.original_tagname_ = 'dayCountFraction'
        super(SimpleFra, self).buildChildren(child_, node, nodeName_, True)
# end class SimpleFra


class SimpleCreditDefaultSwap(UnderlyingAsset):
    member_data_items_ = {
        'referenceEntity': MemberSpec_('referenceEntity', 'LegalEntity', 0),
        'creditEntityReference': MemberSpec_('creditEntityReference', 'LegalEntityReference', 0),
        'term': MemberSpec_('term', 'Period', 0),
        'paymentFrequency': MemberSpec_('paymentFrequency', 'Period', 0),
    }
    subclass = None
    superclass = UnderlyingAsset
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, referenceEntity=None, creditEntityReference=None, term=None, paymentFrequency=None):
        self.original_tagname_ = None
        super(SimpleCreditDefaultSwap, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, )
        self.referenceEntity = referenceEntity
        self.creditEntityReference = creditEntityReference
        self.term = term
        self.paymentFrequency = paymentFrequency
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SimpleCreditDefaultSwap)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SimpleCreditDefaultSwap.subclass:
            return SimpleCreditDefaultSwap.subclass(*args_, **kwargs_)
        else:
            return SimpleCreditDefaultSwap(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_referenceEntity(self): return self.referenceEntity
    def set_referenceEntity(self, referenceEntity): self.referenceEntity = referenceEntity
    def get_creditEntityReference(self): return self.creditEntityReference
    def set_creditEntityReference(self, creditEntityReference): self.creditEntityReference = creditEntityReference
    def get_term(self): return self.term
    def set_term(self, term): self.term = term
    def get_paymentFrequency(self): return self.paymentFrequency
    def set_paymentFrequency(self, paymentFrequency): self.paymentFrequency = paymentFrequency
    def hasContent_(self):
        if (
            self.referenceEntity is not None or
            self.creditEntityReference is not None or
            self.term is not None or
            self.paymentFrequency is not None or
            super(SimpleCreditDefaultSwap, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SimpleCreditDefaultSwap', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SimpleCreditDefaultSwap')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SimpleCreditDefaultSwap', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SimpleCreditDefaultSwap'):
        super(SimpleCreditDefaultSwap, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SimpleCreditDefaultSwap')
    def exportChildren(self, outfile, level, namespace_='', name_='SimpleCreditDefaultSwap', fromsubclass_=False, pretty_print=True):
        super(SimpleCreditDefaultSwap, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.referenceEntity is not None:
            self.referenceEntity.export(outfile, level, namespace_, name_='referenceEntity', pretty_print=pretty_print)
        if self.creditEntityReference is not None:
            self.creditEntityReference.export(outfile, level, namespace_, name_='creditEntityReference', pretty_print=pretty_print)
        if self.term is not None:
            self.term.export(outfile, level, namespace_, name_='term', pretty_print=pretty_print)
        if self.paymentFrequency is not None:
            self.paymentFrequency.export(outfile, level, namespace_, name_='paymentFrequency', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SimpleCreditDefaultSwap, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'referenceEntity':
            obj_ = LegalEntity.factory()
            obj_.build(child_)
            self.referenceEntity = obj_
            obj_.original_tagname_ = 'referenceEntity'
        elif nodeName_ == 'creditEntityReference':
            obj_ = LegalEntityReference.factory()
            obj_.build(child_)
            self.creditEntityReference = obj_
            obj_.original_tagname_ = 'creditEntityReference'
        elif nodeName_ == 'term':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.term = obj_
            obj_.original_tagname_ = 'term'
        elif nodeName_ == 'paymentFrequency':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.paymentFrequency = obj_
            obj_.original_tagname_ = 'paymentFrequency'
        super(SimpleCreditDefaultSwap, self).buildChildren(child_, node, nodeName_, True)
# end class SimpleCreditDefaultSwap


class RateIndex(UnderlyingAsset):
    member_data_items_ = {
        'floatingRateIndex': MemberSpec_('floatingRateIndex', 'FloatingRateIndex', 0),
        'term': MemberSpec_('term', 'Period', 0),
        'paymentFrequency': MemberSpec_('paymentFrequency', 'Period', 0),
        'dayCountFraction': MemberSpec_('dayCountFraction', 'DayCountFraction', 0),
    }
    subclass = None
    superclass = UnderlyingAsset
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, floatingRateIndex=None, term=None, paymentFrequency=None, dayCountFraction=None):
        self.original_tagname_ = None
        super(RateIndex, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, )
        self.floatingRateIndex = floatingRateIndex
        self.term = term
        self.paymentFrequency = paymentFrequency
        self.dayCountFraction = dayCountFraction
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RateIndex)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RateIndex.subclass:
            return RateIndex.subclass(*args_, **kwargs_)
        else:
            return RateIndex(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_floatingRateIndex(self): return self.floatingRateIndex
    def set_floatingRateIndex(self, floatingRateIndex): self.floatingRateIndex = floatingRateIndex
    def get_term(self): return self.term
    def set_term(self, term): self.term = term
    def get_paymentFrequency(self): return self.paymentFrequency
    def set_paymentFrequency(self, paymentFrequency): self.paymentFrequency = paymentFrequency
    def get_dayCountFraction(self): return self.dayCountFraction
    def set_dayCountFraction(self, dayCountFraction): self.dayCountFraction = dayCountFraction
    def hasContent_(self):
        if (
            self.floatingRateIndex is not None or
            self.term is not None or
            self.paymentFrequency is not None or
            self.dayCountFraction is not None or
            super(RateIndex, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RateIndex', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RateIndex')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RateIndex', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RateIndex'):
        super(RateIndex, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RateIndex')
    def exportChildren(self, outfile, level, namespace_='', name_='RateIndex', fromsubclass_=False, pretty_print=True):
        super(RateIndex, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.floatingRateIndex is not None:
            self.floatingRateIndex.export(outfile, level, namespace_, name_='floatingRateIndex', pretty_print=pretty_print)
        if self.term is not None:
            self.term.export(outfile, level, namespace_, name_='term', pretty_print=pretty_print)
        if self.paymentFrequency is not None:
            self.paymentFrequency.export(outfile, level, namespace_, name_='paymentFrequency', pretty_print=pretty_print)
        if self.dayCountFraction is not None:
            self.dayCountFraction.export(outfile, level, namespace_, name_='dayCountFraction', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RateIndex, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'floatingRateIndex':
            obj_ = FloatingRateIndex.factory()
            obj_.build(child_)
            self.floatingRateIndex = obj_
            obj_.original_tagname_ = 'floatingRateIndex'
        elif nodeName_ == 'term':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.term = obj_
            obj_.original_tagname_ = 'term'
        elif nodeName_ == 'paymentFrequency':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.paymentFrequency = obj_
            obj_.original_tagname_ = 'paymentFrequency'
        elif nodeName_ == 'dayCountFraction':
            obj_ = DayCountFraction.factory()
            obj_.build(child_)
            self.dayCountFraction = obj_
            obj_.original_tagname_ = 'dayCountFraction'
        super(RateIndex, self).buildChildren(child_, node, nodeName_, True)
# end class RateIndex


class PendingPayment(PaymentBase):
    """A structure representing a pending dividend or coupon payment."""
    member_data_items_ = {
        'paymentDate': MemberSpec_('paymentDate', 'xsd:date', 0),
        'amount': MemberSpec_('amount', 'Money', 0),
        'accruedInterest': MemberSpec_('accruedInterest', 'Money', 0),
    }
    subclass = None
    superclass = PaymentBase
    def __init__(self, id=None, paymentDate=None, amount=None, accruedInterest=None):
        self.original_tagname_ = None
        super(PendingPayment, self).__init__(id, )
        if isinstance(paymentDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(paymentDate, '%Y-%m-%d').date()
        else:
            initvalue_ = paymentDate
        self.paymentDate = initvalue_
        self.amount = amount
        self.accruedInterest = accruedInterest
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PendingPayment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PendingPayment.subclass:
            return PendingPayment.subclass(*args_, **kwargs_)
        else:
            return PendingPayment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_paymentDate(self): return self.paymentDate
    def set_paymentDate(self, paymentDate): self.paymentDate = paymentDate
    def get_amount(self): return self.amount
    def set_amount(self, amount): self.amount = amount
    def get_accruedInterest(self): return self.accruedInterest
    def set_accruedInterest(self, accruedInterest): self.accruedInterest = accruedInterest
    def hasContent_(self):
        if (
            self.paymentDate is not None or
            self.amount is not None or
            self.accruedInterest is not None or
            super(PendingPayment, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PendingPayment', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PendingPayment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PendingPayment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PendingPayment'):
        super(PendingPayment, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PendingPayment')
    def exportChildren(self, outfile, level, namespace_='', name_='PendingPayment', fromsubclass_=False, pretty_print=True):
        super(PendingPayment, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.paymentDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spaymentDate>%s</%spaymentDate>%s' % (namespace_, self.gds_format_date(self.paymentDate, input_name='paymentDate'), namespace_, eol_))
        if self.amount is not None:
            self.amount.export(outfile, level, namespace_, name_='amount', pretty_print=pretty_print)
        if self.accruedInterest is not None:
            self.accruedInterest.export(outfile, level, namespace_, name_='accruedInterest', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PendingPayment, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'paymentDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.paymentDate = dval_
        elif nodeName_ == 'amount':
            obj_ = Money.factory()
            obj_.build(child_)
            self.amount = obj_
            obj_.original_tagname_ = 'amount'
        elif nodeName_ == 'accruedInterest':
            obj_ = Money.factory()
            obj_.build(child_)
            self.accruedInterest = obj_
            obj_.original_tagname_ = 'accruedInterest'
        super(PendingPayment, self).buildChildren(child_, node, nodeName_, True)
# end class PendingPayment


class MutualFund(UnderlyingAsset):
    member_data_items_ = {
        'openEndedFund': MemberSpec_('openEndedFund', 'xsd:boolean', 0),
        'fundManager': MemberSpec_('fundManager', ['String', 'xsd:string'], 0),
    }
    subclass = None
    superclass = UnderlyingAsset
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, openEndedFund=None, fundManager=None):
        self.original_tagname_ = None
        super(MutualFund, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, )
        self.openEndedFund = openEndedFund
        self.fundManager = fundManager
        self.validate_String(self.fundManager)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MutualFund)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MutualFund.subclass:
            return MutualFund.subclass(*args_, **kwargs_)
        else:
            return MutualFund(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_openEndedFund(self): return self.openEndedFund
    def set_openEndedFund(self, openEndedFund): self.openEndedFund = openEndedFund
    def get_fundManager(self): return self.fundManager
    def set_fundManager(self, fundManager): self.fundManager = fundManager
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.openEndedFund is not None or
            self.fundManager is not None or
            super(MutualFund, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MutualFund', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MutualFund')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MutualFund', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MutualFund'):
        super(MutualFund, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MutualFund')
    def exportChildren(self, outfile, level, namespace_='', name_='MutualFund', fromsubclass_=False, pretty_print=True):
        super(MutualFund, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.openEndedFund is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sopenEndedFund>%s</%sopenEndedFund>%s' % (namespace_, self.gds_format_boolean(self.openEndedFund, input_name='openEndedFund'), namespace_, eol_))
        if self.fundManager is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfundManager>%s</%sfundManager>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.fundManager), input_name='fundManager')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MutualFund, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'openEndedFund':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'openEndedFund')
            self.openEndedFund = ival_
        elif nodeName_ == 'fundManager':
            fundManager_ = child_.text
            fundManager_ = self.gds_validate_string(fundManager_, node, 'fundManager')
            self.fundManager = fundManager_
            # validate type String
            self.validate_String(self.fundManager)
        super(MutualFund, self).buildChildren(child_, node, nodeName_, True)
# end class MutualFund


class Mortgage(UnderlyingAsset):
    """A type describing a mortgage asset.Applicable to the case of default
    swaps on MBS terms. For specifying the insurer name, when
    applicable (when the element is not present, it signifies that
    the insurer is Not Applicable)Specifies the issuer name of a
    fixed income security or convertible bond. This name can either
    be explicitly stated, or specified as an href into another
    element of the document, such as the obligor."""
    member_data_items_ = {
        'insurer': MemberSpec_('insurer', 'LegalEntity', 0),
        'insurerReference': MemberSpec_('insurerReference', 'LegalEntityReference', 0),
        'issuerName': MemberSpec_('issuerName', ['String', 'xsd:string'], 0),
        'issuerPartyReference': MemberSpec_('issuerPartyReference', 'PartyReference', 0),
        'seniority': MemberSpec_('seniority', 'CreditSeniority', 0),
        'couponType': MemberSpec_('couponType', 'CouponType', 0),
        'couponRate': MemberSpec_('couponRate', 'xsd:decimal', 0),
        'maturity': MemberSpec_('maturity', 'xsd:date', 0),
        'paymentFrequency': MemberSpec_('paymentFrequency', 'Period', 0),
        'dayCountFraction': MemberSpec_('dayCountFraction', 'DayCountFraction', 0),
        'originalPrincipalAmount': MemberSpec_('originalPrincipalAmount', 'xsd:decimal', 0),
        'pool': MemberSpec_('pool', 'AssetPool', 0),
        'sector': MemberSpec_('sector', 'MortgageSector', 0),
        'tranche': MemberSpec_('tranche', ['Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = UnderlyingAsset
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, insurer=None, insurerReference=None, issuerName=None, issuerPartyReference=None, seniority=None, couponType=None, couponRate=None, maturity=None, paymentFrequency=None, dayCountFraction=None, originalPrincipalAmount=None, pool=None, sector=None, tranche=None):
        self.original_tagname_ = None
        super(Mortgage, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, )
        self.insurer = insurer
        self.insurerReference = insurerReference
        self.issuerName = issuerName
        self.validate_String(self.issuerName)
        self.issuerPartyReference = issuerPartyReference
        self.seniority = seniority
        self.couponType = couponType
        self.couponRate = couponRate
        if isinstance(maturity, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(maturity, '%Y-%m-%d').date()
        else:
            initvalue_ = maturity
        self.maturity = initvalue_
        self.paymentFrequency = paymentFrequency
        self.dayCountFraction = dayCountFraction
        self.originalPrincipalAmount = originalPrincipalAmount
        self.pool = pool
        self.sector = sector
        self.tranche = tranche
        self.validate_Token(self.tranche)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Mortgage)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Mortgage.subclass:
            return Mortgage.subclass(*args_, **kwargs_)
        else:
            return Mortgage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_insurer(self): return self.insurer
    def set_insurer(self, insurer): self.insurer = insurer
    def get_insurerReference(self): return self.insurerReference
    def set_insurerReference(self, insurerReference): self.insurerReference = insurerReference
    def get_issuerName(self): return self.issuerName
    def set_issuerName(self, issuerName): self.issuerName = issuerName
    def get_issuerPartyReference(self): return self.issuerPartyReference
    def set_issuerPartyReference(self, issuerPartyReference): self.issuerPartyReference = issuerPartyReference
    def get_seniority(self): return self.seniority
    def set_seniority(self, seniority): self.seniority = seniority
    def get_couponType(self): return self.couponType
    def set_couponType(self, couponType): self.couponType = couponType
    def get_couponRate(self): return self.couponRate
    def set_couponRate(self, couponRate): self.couponRate = couponRate
    def get_maturity(self): return self.maturity
    def set_maturity(self, maturity): self.maturity = maturity
    def get_paymentFrequency(self): return self.paymentFrequency
    def set_paymentFrequency(self, paymentFrequency): self.paymentFrequency = paymentFrequency
    def get_dayCountFraction(self): return self.dayCountFraction
    def set_dayCountFraction(self, dayCountFraction): self.dayCountFraction = dayCountFraction
    def get_originalPrincipalAmount(self): return self.originalPrincipalAmount
    def set_originalPrincipalAmount(self, originalPrincipalAmount): self.originalPrincipalAmount = originalPrincipalAmount
    def get_pool(self): return self.pool
    def set_pool(self, pool): self.pool = pool
    def get_sector(self): return self.sector
    def set_sector(self, sector): self.sector = sector
    def get_tranche(self): return self.tranche
    def set_tranche(self, tranche): self.tranche = tranche
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def validate_Token(self, value):
        # Validate type Token, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on Token' % {"value" : value} )
    def hasContent_(self):
        if (
            self.insurer is not None or
            self.insurerReference is not None or
            self.issuerName is not None or
            self.issuerPartyReference is not None or
            self.seniority is not None or
            self.couponType is not None or
            self.couponRate is not None or
            self.maturity is not None or
            self.paymentFrequency is not None or
            self.dayCountFraction is not None or
            self.originalPrincipalAmount is not None or
            self.pool is not None or
            self.sector is not None or
            self.tranche is not None or
            super(Mortgage, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Mortgage', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Mortgage')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Mortgage', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Mortgage'):
        super(Mortgage, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Mortgage')
    def exportChildren(self, outfile, level, namespace_='', name_='Mortgage', fromsubclass_=False, pretty_print=True):
        super(Mortgage, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.insurer is not None:
            self.insurer.export(outfile, level, namespace_, name_='insurer', pretty_print=pretty_print)
        if self.insurerReference is not None:
            self.insurerReference.export(outfile, level, namespace_, name_='insurerReference', pretty_print=pretty_print)
        if self.issuerName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sissuerName>%s</%sissuerName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.issuerName), input_name='issuerName')), namespace_, eol_))
        if self.issuerPartyReference is not None:
            self.issuerPartyReference.export(outfile, level, namespace_, name_='issuerPartyReference', pretty_print=pretty_print)
        if self.seniority is not None:
            self.seniority.export(outfile, level, namespace_, name_='seniority', pretty_print=pretty_print)
        if self.couponType is not None:
            self.couponType.export(outfile, level, namespace_, name_='couponType', pretty_print=pretty_print)
        if self.couponRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scouponRate>%s</%scouponRate>%s' % (namespace_, self.gds_format_float(self.couponRate, input_name='couponRate'), namespace_, eol_))
        if self.maturity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaturity>%s</%smaturity>%s' % (namespace_, self.gds_format_date(self.maturity, input_name='maturity'), namespace_, eol_))
        if self.paymentFrequency is not None:
            self.paymentFrequency.export(outfile, level, namespace_, name_='paymentFrequency', pretty_print=pretty_print)
        if self.dayCountFraction is not None:
            self.dayCountFraction.export(outfile, level, namespace_, name_='dayCountFraction', pretty_print=pretty_print)
        if self.originalPrincipalAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soriginalPrincipalAmount>%s</%soriginalPrincipalAmount>%s' % (namespace_, self.gds_format_float(self.originalPrincipalAmount, input_name='originalPrincipalAmount'), namespace_, eol_))
        if self.pool is not None:
            self.pool.export(outfile, level, namespace_, name_='pool', pretty_print=pretty_print)
        if self.sector is not None:
            self.sector.export(outfile, level, namespace_, name_='sector', pretty_print=pretty_print)
        if self.tranche is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stranche>%s</%stranche>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.tranche), input_name='tranche')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Mortgage, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'insurer':
            obj_ = LegalEntity.factory()
            obj_.build(child_)
            self.insurer = obj_
            obj_.original_tagname_ = 'insurer'
        elif nodeName_ == 'insurerReference':
            obj_ = LegalEntityReference.factory()
            obj_.build(child_)
            self.insurerReference = obj_
            obj_.original_tagname_ = 'insurerReference'
        elif nodeName_ == 'issuerName':
            issuerName_ = child_.text
            issuerName_ = self.gds_validate_string(issuerName_, node, 'issuerName')
            self.issuerName = issuerName_
            # validate type String
            self.validate_String(self.issuerName)
        elif nodeName_ == 'issuerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.issuerPartyReference = obj_
            obj_.original_tagname_ = 'issuerPartyReference'
        elif nodeName_ == 'seniority':
            obj_ = CreditSeniority.factory()
            obj_.build(child_)
            self.seniority = obj_
            obj_.original_tagname_ = 'seniority'
        elif nodeName_ == 'couponType':
            obj_ = CouponType.factory()
            obj_.build(child_)
            self.couponType = obj_
            obj_.original_tagname_ = 'couponType'
        elif nodeName_ == 'couponRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'couponRate')
            self.couponRate = fval_
        elif nodeName_ == 'maturity':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.maturity = dval_
        elif nodeName_ == 'paymentFrequency':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.paymentFrequency = obj_
            obj_.original_tagname_ = 'paymentFrequency'
        elif nodeName_ == 'dayCountFraction':
            obj_ = DayCountFraction.factory()
            obj_.build(child_)
            self.dayCountFraction = obj_
            obj_.original_tagname_ = 'dayCountFraction'
        elif nodeName_ == 'originalPrincipalAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'originalPrincipalAmount')
            self.originalPrincipalAmount = fval_
        elif nodeName_ == 'pool':
            obj_ = AssetPool.factory()
            obj_.build(child_)
            self.pool = obj_
            obj_.original_tagname_ = 'pool'
        elif nodeName_ == 'sector':
            obj_ = MortgageSector.factory()
            obj_.build(child_)
            self.sector = obj_
            obj_.original_tagname_ = 'sector'
        elif nodeName_ == 'tranche':
            tranche_ = child_.text
            tranche_ = re_.sub(String_cleanup_pat_, " ", tranche_).strip()
            tranche_ = self.gds_validate_string(tranche_, node, 'tranche')
            self.tranche = tranche_
            # validate type Token
            self.validate_Token(self.tranche)
        super(Mortgage, self).buildChildren(child_, node, nodeName_, True)
# end class Mortgage


class Loan(UnderlyingAsset):
    """A type describing a loan underlying asset.Specifies the borrower.
    There can be more than one borrower. It is meant to be used in
    the event that there is no Bloomberg Id or the Secured List
    isn't applicable."""
    member_data_items_ = {
        'borrower': MemberSpec_('borrower', 'LegalEntity', 1),
        'borrowerReference': MemberSpec_('borrowerReference', 'LegalEntityReference', 1),
        'lien': MemberSpec_('lien', 'Lien', 0),
        'facilityType': MemberSpec_('facilityType', 'FacilityType', 0),
        'maturity': MemberSpec_('maturity', 'xsd:date', 0),
        'creditAgreementDate': MemberSpec_('creditAgreementDate', 'xsd:date', 0),
        'tranche': MemberSpec_('tranche', 'UnderlyingAssetTranche', 0),
    }
    subclass = None
    superclass = UnderlyingAsset
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, borrower=None, borrowerReference=None, lien=None, facilityType=None, maturity=None, creditAgreementDate=None, tranche=None):
        self.original_tagname_ = None
        super(Loan, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, )
        if borrower is None:
            self.borrower = []
        else:
            self.borrower = borrower
        if borrowerReference is None:
            self.borrowerReference = []
        else:
            self.borrowerReference = borrowerReference
        self.lien = lien
        self.facilityType = facilityType
        if isinstance(maturity, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(maturity, '%Y-%m-%d').date()
        else:
            initvalue_ = maturity
        self.maturity = initvalue_
        if isinstance(creditAgreementDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(creditAgreementDate, '%Y-%m-%d').date()
        else:
            initvalue_ = creditAgreementDate
        self.creditAgreementDate = initvalue_
        self.tranche = tranche
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Loan)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Loan.subclass:
            return Loan.subclass(*args_, **kwargs_)
        else:
            return Loan(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_borrower(self): return self.borrower
    def set_borrower(self, borrower): self.borrower = borrower
    def add_borrower(self, value): self.borrower.append(value)
    def insert_borrower_at(self, index, value): self.borrower.insert(index, value)
    def replace_borrower_at(self, index, value): self.borrower[index] = value
    def get_borrowerReference(self): return self.borrowerReference
    def set_borrowerReference(self, borrowerReference): self.borrowerReference = borrowerReference
    def add_borrowerReference(self, value): self.borrowerReference.append(value)
    def insert_borrowerReference_at(self, index, value): self.borrowerReference.insert(index, value)
    def replace_borrowerReference_at(self, index, value): self.borrowerReference[index] = value
    def get_lien(self): return self.lien
    def set_lien(self, lien): self.lien = lien
    def get_facilityType(self): return self.facilityType
    def set_facilityType(self, facilityType): self.facilityType = facilityType
    def get_maturity(self): return self.maturity
    def set_maturity(self, maturity): self.maturity = maturity
    def get_creditAgreementDate(self): return self.creditAgreementDate
    def set_creditAgreementDate(self, creditAgreementDate): self.creditAgreementDate = creditAgreementDate
    def get_tranche(self): return self.tranche
    def set_tranche(self, tranche): self.tranche = tranche
    def hasContent_(self):
        if (
            self.borrower or
            self.borrowerReference or
            self.lien is not None or
            self.facilityType is not None or
            self.maturity is not None or
            self.creditAgreementDate is not None or
            self.tranche is not None or
            super(Loan, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Loan', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Loan')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Loan', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Loan'):
        super(Loan, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Loan')
    def exportChildren(self, outfile, level, namespace_='', name_='Loan', fromsubclass_=False, pretty_print=True):
        super(Loan, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for borrower_ in self.borrower:
            borrower_.export(outfile, level, namespace_, name_='borrower', pretty_print=pretty_print)
        for borrowerReference_ in self.borrowerReference:
            borrowerReference_.export(outfile, level, namespace_, name_='borrowerReference', pretty_print=pretty_print)
        if self.lien is not None:
            self.lien.export(outfile, level, namespace_, name_='lien', pretty_print=pretty_print)
        if self.facilityType is not None:
            self.facilityType.export(outfile, level, namespace_, name_='facilityType', pretty_print=pretty_print)
        if self.maturity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaturity>%s</%smaturity>%s' % (namespace_, self.gds_format_date(self.maturity, input_name='maturity'), namespace_, eol_))
        if self.creditAgreementDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%screditAgreementDate>%s</%screditAgreementDate>%s' % (namespace_, self.gds_format_date(self.creditAgreementDate, input_name='creditAgreementDate'), namespace_, eol_))
        if self.tranche is not None:
            self.tranche.export(outfile, level, namespace_, name_='tranche', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Loan, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'borrower':
            obj_ = LegalEntity.factory()
            obj_.build(child_)
            self.borrower.append(obj_)
            obj_.original_tagname_ = 'borrower'
        elif nodeName_ == 'borrowerReference':
            obj_ = LegalEntityReference.factory()
            obj_.build(child_)
            self.borrowerReference.append(obj_)
            obj_.original_tagname_ = 'borrowerReference'
        elif nodeName_ == 'lien':
            obj_ = Lien.factory()
            obj_.build(child_)
            self.lien = obj_
            obj_.original_tagname_ = 'lien'
        elif nodeName_ == 'facilityType':
            obj_ = FacilityType.factory()
            obj_.build(child_)
            self.facilityType = obj_
            obj_.original_tagname_ = 'facilityType'
        elif nodeName_ == 'maturity':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.maturity = dval_
        elif nodeName_ == 'creditAgreementDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.creditAgreementDate = dval_
        elif nodeName_ == 'tranche':
            obj_ = UnderlyingAssetTranche.factory()
            obj_.build(child_)
            self.tranche = obj_
            obj_.original_tagname_ = 'tranche'
        super(Loan, self).buildChildren(child_, node, nodeName_, True)
# end class Loan


class FxRateAsset(UnderlyingAsset):
    member_data_items_ = {
        'quotedCurrencyPair': MemberSpec_('quotedCurrencyPair', 'QuotedCurrencyPair', 0),
        'rateSource': MemberSpec_('rateSource', 'FxSpotRateSource', 0),
    }
    subclass = None
    superclass = UnderlyingAsset
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, quotedCurrencyPair=None, rateSource=None):
        self.original_tagname_ = None
        super(FxRateAsset, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, )
        self.quotedCurrencyPair = quotedCurrencyPair
        self.rateSource = rateSource
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FxRateAsset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FxRateAsset.subclass:
            return FxRateAsset.subclass(*args_, **kwargs_)
        else:
            return FxRateAsset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_quotedCurrencyPair(self): return self.quotedCurrencyPair
    def set_quotedCurrencyPair(self, quotedCurrencyPair): self.quotedCurrencyPair = quotedCurrencyPair
    def get_rateSource(self): return self.rateSource
    def set_rateSource(self, rateSource): self.rateSource = rateSource
    def hasContent_(self):
        if (
            self.quotedCurrencyPair is not None or
            self.rateSource is not None or
            super(FxRateAsset, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FxRateAsset', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FxRateAsset')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FxRateAsset', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FxRateAsset'):
        super(FxRateAsset, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FxRateAsset')
    def exportChildren(self, outfile, level, namespace_='', name_='FxRateAsset', fromsubclass_=False, pretty_print=True):
        super(FxRateAsset, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.quotedCurrencyPair is not None:
            self.quotedCurrencyPair.export(outfile, level, namespace_, name_='quotedCurrencyPair', pretty_print=pretty_print)
        if self.rateSource is not None:
            self.rateSource.export(outfile, level, namespace_, name_='rateSource', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FxRateAsset, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'quotedCurrencyPair':
            obj_ = QuotedCurrencyPair.factory()
            obj_.build(child_)
            self.quotedCurrencyPair = obj_
            obj_.original_tagname_ = 'quotedCurrencyPair'
        elif nodeName_ == 'rateSource':
            obj_ = FxSpotRateSource.factory()
            obj_.build(child_)
            self.rateSource = obj_
            obj_.original_tagname_ = 'rateSource'
        super(FxRateAsset, self).buildChildren(child_, node, nodeName_, True)
# end class FxRateAsset


class ExchangeTraded(UnderlyingAsset):
    """An abstract base class for all exchange traded financial products."""
    member_data_items_ = {
        'relatedExchangeId': MemberSpec_('relatedExchangeId', 'ExchangeId', 1),
        'optionsExchangeId': MemberSpec_('optionsExchangeId', 'ExchangeId', 1),
        'specifiedExchangeId': MemberSpec_('specifiedExchangeId', 'ExchangeId', 1),
    }
    subclass = None
    superclass = UnderlyingAsset
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, relatedExchangeId=None, optionsExchangeId=None, specifiedExchangeId=None, extensiontype_=None):
        self.original_tagname_ = None
        super(ExchangeTraded, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, extensiontype_, )
        if relatedExchangeId is None:
            self.relatedExchangeId = []
        else:
            self.relatedExchangeId = relatedExchangeId
        if optionsExchangeId is None:
            self.optionsExchangeId = []
        else:
            self.optionsExchangeId = optionsExchangeId
        if specifiedExchangeId is None:
            self.specifiedExchangeId = []
        else:
            self.specifiedExchangeId = specifiedExchangeId
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExchangeTraded)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExchangeTraded.subclass:
            return ExchangeTraded.subclass(*args_, **kwargs_)
        else:
            return ExchangeTraded(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_relatedExchangeId(self): return self.relatedExchangeId
    def set_relatedExchangeId(self, relatedExchangeId): self.relatedExchangeId = relatedExchangeId
    def add_relatedExchangeId(self, value): self.relatedExchangeId.append(value)
    def insert_relatedExchangeId_at(self, index, value): self.relatedExchangeId.insert(index, value)
    def replace_relatedExchangeId_at(self, index, value): self.relatedExchangeId[index] = value
    def get_optionsExchangeId(self): return self.optionsExchangeId
    def set_optionsExchangeId(self, optionsExchangeId): self.optionsExchangeId = optionsExchangeId
    def add_optionsExchangeId(self, value): self.optionsExchangeId.append(value)
    def insert_optionsExchangeId_at(self, index, value): self.optionsExchangeId.insert(index, value)
    def replace_optionsExchangeId_at(self, index, value): self.optionsExchangeId[index] = value
    def get_specifiedExchangeId(self): return self.specifiedExchangeId
    def set_specifiedExchangeId(self, specifiedExchangeId): self.specifiedExchangeId = specifiedExchangeId
    def add_specifiedExchangeId(self, value): self.specifiedExchangeId.append(value)
    def insert_specifiedExchangeId_at(self, index, value): self.specifiedExchangeId.insert(index, value)
    def replace_specifiedExchangeId_at(self, index, value): self.specifiedExchangeId[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.relatedExchangeId or
            self.optionsExchangeId or
            self.specifiedExchangeId or
            super(ExchangeTraded, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExchangeTraded', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExchangeTraded')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExchangeTraded', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExchangeTraded'):
        super(ExchangeTraded, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ExchangeTraded')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='ExchangeTraded', fromsubclass_=False, pretty_print=True):
        super(ExchangeTraded, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for relatedExchangeId_ in self.relatedExchangeId:
            relatedExchangeId_.export(outfile, level, namespace_, name_='relatedExchangeId', pretty_print=pretty_print)
        for optionsExchangeId_ in self.optionsExchangeId:
            optionsExchangeId_.export(outfile, level, namespace_, name_='optionsExchangeId', pretty_print=pretty_print)
        for specifiedExchangeId_ in self.specifiedExchangeId:
            specifiedExchangeId_.export(outfile, level, namespace_, name_='specifiedExchangeId', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ExchangeTraded, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'relatedExchangeId':
            obj_ = ExchangeId.factory()
            obj_.build(child_)
            self.relatedExchangeId.append(obj_)
            obj_.original_tagname_ = 'relatedExchangeId'
        elif nodeName_ == 'optionsExchangeId':
            obj_ = ExchangeId.factory()
            obj_.build(child_)
            self.optionsExchangeId.append(obj_)
            obj_.original_tagname_ = 'optionsExchangeId'
        elif nodeName_ == 'specifiedExchangeId':
            obj_ = ExchangeId.factory()
            obj_.build(child_)
            self.specifiedExchangeId.append(obj_)
            obj_.original_tagname_ = 'specifiedExchangeId'
        super(ExchangeTraded, self).buildChildren(child_, node, nodeName_, True)
# end class ExchangeTraded


class EquityAsset(ExchangeTraded):
    """An exchange traded equity asset."""
    member_data_items_ = {
    }
    subclass = None
    superclass = ExchangeTraded
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, relatedExchangeId=None, optionsExchangeId=None, specifiedExchangeId=None):
        self.original_tagname_ = None
        super(EquityAsset, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, relatedExchangeId, optionsExchangeId, specifiedExchangeId, )
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EquityAsset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EquityAsset.subclass:
            return EquityAsset.subclass(*args_, **kwargs_)
        else:
            return EquityAsset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(EquityAsset, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EquityAsset', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EquityAsset')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EquityAsset', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EquityAsset'):
        super(EquityAsset, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EquityAsset')
    def exportChildren(self, outfile, level, namespace_='', name_='EquityAsset', fromsubclass_=False, pretty_print=True):
        super(EquityAsset, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EquityAsset, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(EquityAsset, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class EquityAsset


class Deposit(UnderlyingAsset):
    member_data_items_ = {
        'term': MemberSpec_('term', 'Period', 0),
        'paymentFrequency': MemberSpec_('paymentFrequency', 'Period', 0),
        'dayCountFraction': MemberSpec_('dayCountFraction', 'DayCountFraction', 0),
    }
    subclass = None
    superclass = UnderlyingAsset
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, term=None, paymentFrequency=None, dayCountFraction=None):
        self.original_tagname_ = None
        super(Deposit, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, )
        self.term = term
        self.paymentFrequency = paymentFrequency
        self.dayCountFraction = dayCountFraction
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Deposit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Deposit.subclass:
            return Deposit.subclass(*args_, **kwargs_)
        else:
            return Deposit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_term(self): return self.term
    def set_term(self, term): self.term = term
    def get_paymentFrequency(self): return self.paymentFrequency
    def set_paymentFrequency(self, paymentFrequency): self.paymentFrequency = paymentFrequency
    def get_dayCountFraction(self): return self.dayCountFraction
    def set_dayCountFraction(self, dayCountFraction): self.dayCountFraction = dayCountFraction
    def hasContent_(self):
        if (
            self.term is not None or
            self.paymentFrequency is not None or
            self.dayCountFraction is not None or
            super(Deposit, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Deposit', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Deposit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Deposit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Deposit'):
        super(Deposit, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Deposit')
    def exportChildren(self, outfile, level, namespace_='', name_='Deposit', fromsubclass_=False, pretty_print=True):
        super(Deposit, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.term is not None:
            self.term.export(outfile, level, namespace_, name_='term', pretty_print=pretty_print)
        if self.paymentFrequency is not None:
            self.paymentFrequency.export(outfile, level, namespace_, name_='paymentFrequency', pretty_print=pretty_print)
        if self.dayCountFraction is not None:
            self.dayCountFraction.export(outfile, level, namespace_, name_='dayCountFraction', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Deposit, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'term':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.term = obj_
            obj_.original_tagname_ = 'term'
        elif nodeName_ == 'paymentFrequency':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.paymentFrequency = obj_
            obj_.original_tagname_ = 'paymentFrequency'
        elif nodeName_ == 'dayCountFraction':
            obj_ = DayCountFraction.factory()
            obj_.build(child_)
            self.dayCountFraction = obj_
            obj_.original_tagname_ = 'dayCountFraction'
        super(Deposit, self).buildChildren(child_, node, nodeName_, True)
# end class Deposit


class Commodity(IdentifiedAsset):
    """A type describing a commodity underlying asset."""
    member_data_items_ = {
        'commodityBase': MemberSpec_('commodityBase', 'CommodityBase', 0),
        'commodityDetails': MemberSpec_('commodityDetails', 'CommodityDetails', 0),
        'unit': MemberSpec_('unit', 'QuantityUnit', 0),
        'currency': MemberSpec_('currency', 'Currency', 0),
        'exchangeId': MemberSpec_('exchangeId', 'ExchangeId', 0),
        'publication': MemberSpec_('publication', 'CommodityInformationSource', 0),
        'specifiedPrice': MemberSpec_('specifiedPrice', ['SpecifiedPriceEnum', 'Token', 'xsd:token'], 0),
        'deliveryDates': MemberSpec_('deliveryDates', ['DeliveryDatesEnum', 'Token', 'xsd:token'], 0),
        'deliveryNearby': MemberSpec_('deliveryNearby', 'DeliveryNearby', 0),
        'deliveryDate': MemberSpec_('deliveryDate', 'AdjustableDate', 0),
        'deliveryDateYearMonth': MemberSpec_('deliveryDateYearMonth', 'xsd:gYearMonth', 0),
        'deliveryDateRollConvention': MemberSpec_('deliveryDateRollConvention', 'Offset', 0),
        'deliveryDateExpirationConvention': MemberSpec_('deliveryDateExpirationConvention', 'Offset', 0),
        'multiplier': MemberSpec_('multiplier', ['PositiveDecimal', 'xsd:decimal'], 0),
    }
    subclass = None
    superclass = IdentifiedAsset
    def __init__(self, id=None, instrumentId=None, description=None, commodityBase=None, commodityDetails=None, unit=None, currency=None, exchangeId=None, publication=None, specifiedPrice=None, deliveryDates=None, deliveryNearby=None, deliveryDate=None, deliveryDateYearMonth=None, deliveryDateRollConvention=None, deliveryDateExpirationConvention=None, multiplier=None):
        self.original_tagname_ = None
        super(Commodity, self).__init__(id, instrumentId, description, )
        self.commodityBase = commodityBase
        self.commodityDetails = commodityDetails
        self.unit = unit
        self.currency = currency
        self.exchangeId = exchangeId
        self.publication = publication
        self.specifiedPrice = specifiedPrice
        self.validate_SpecifiedPriceEnum(self.specifiedPrice)
        self.deliveryDates = deliveryDates
        self.validate_DeliveryDatesEnum(self.deliveryDates)
        self.deliveryNearby = deliveryNearby
        self.deliveryDate = deliveryDate
        self.deliveryDateYearMonth = deliveryDateYearMonth
        self.deliveryDateRollConvention = deliveryDateRollConvention
        self.deliveryDateExpirationConvention = deliveryDateExpirationConvention
        self.multiplier = multiplier
        self.validate_PositiveDecimal(self.multiplier)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Commodity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Commodity.subclass:
            return Commodity.subclass(*args_, **kwargs_)
        else:
            return Commodity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commodityBase(self): return self.commodityBase
    def set_commodityBase(self, commodityBase): self.commodityBase = commodityBase
    def get_commodityDetails(self): return self.commodityDetails
    def set_commodityDetails(self, commodityDetails): self.commodityDetails = commodityDetails
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_exchangeId(self): return self.exchangeId
    def set_exchangeId(self, exchangeId): self.exchangeId = exchangeId
    def get_publication(self): return self.publication
    def set_publication(self, publication): self.publication = publication
    def get_specifiedPrice(self): return self.specifiedPrice
    def set_specifiedPrice(self, specifiedPrice): self.specifiedPrice = specifiedPrice
    def get_deliveryDates(self): return self.deliveryDates
    def set_deliveryDates(self, deliveryDates): self.deliveryDates = deliveryDates
    def get_deliveryNearby(self): return self.deliveryNearby
    def set_deliveryNearby(self, deliveryNearby): self.deliveryNearby = deliveryNearby
    def get_deliveryDate(self): return self.deliveryDate
    def set_deliveryDate(self, deliveryDate): self.deliveryDate = deliveryDate
    def get_deliveryDateYearMonth(self): return self.deliveryDateYearMonth
    def set_deliveryDateYearMonth(self, deliveryDateYearMonth): self.deliveryDateYearMonth = deliveryDateYearMonth
    def get_deliveryDateRollConvention(self): return self.deliveryDateRollConvention
    def set_deliveryDateRollConvention(self, deliveryDateRollConvention): self.deliveryDateRollConvention = deliveryDateRollConvention
    def get_deliveryDateExpirationConvention(self): return self.deliveryDateExpirationConvention
    def set_deliveryDateExpirationConvention(self, deliveryDateExpirationConvention): self.deliveryDateExpirationConvention = deliveryDateExpirationConvention
    def get_multiplier(self): return self.multiplier
    def set_multiplier(self, multiplier): self.multiplier = multiplier
    def validate_SpecifiedPriceEnum(self, value):
        # Validate type SpecifiedPriceEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Afternoon', 'Ask', 'Bid', 'Closing', 'High', 'Index', 'MeanOfBidAndAsk', 'LocationalMarginal', 'Low', 'MarginalHourly', 'MarketClearing', 'MeanOfHighAndLow', 'Morning', 'Official', 'Opening', 'OSP', 'Settlement', 'Spot', 'Midpoint', 'NationalSingle', 'WeightedAverage', 'UnWeightedAverage']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SpecifiedPriceEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on SpecifiedPriceEnum' % {"value" : value} )
    def validate_DeliveryDatesEnum(self, value):
        # Validate type DeliveryDatesEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CalculationPeriod', 'FirstNearby', 'SecondNearby', 'ThirdNearby', 'FourthNearby', 'FifthNearby', 'SixthNearby', 'SeventhNearby', 'EighthNearby', 'NinthNearby', 'TenthNearby', 'EleventhNearby', 'TwelfthNearby', 'ThirteenthNearby', 'FourteenthNearby', 'FifteenthNearby', 'SixteenthNearby', 'SeventeenthNearby', 'EighteenthNearby', 'NineteenthNearby', 'TwentiethNearby', 'TwentyFirstNearby', 'TwentySecondNearby', 'TwentyThirdNearby', 'TwentyFourthNearby', 'TwentyFifthNearby', 'TwentySixthNearby', 'TwentySeventhNearby', 'TwentyEighthNearby', 'TwentyNinthNearby', 'ThirtiethNearby', 'ThirtyFirstNearby', 'ThirtySecondNearby', 'ThirtyThirdNearby', 'ThirtyFourthNearby', 'ThirtyFifthNearby', 'ThirtySixthNearby', 'ThirtySeventhNearby', 'ThirtyEighthNearby', 'ThirtyNinthNearby', 'FortiethNearby', 'FortyFirstNearby', 'FortySecondNearby', 'FortyThirdNearby', 'FortyFourthNearby', 'FortyFifthNearby', 'FortySixthNearby', 'FortySeventhNearby', 'FortyEighthNearby', 'FortyNinthNearby', 'FiftiethNearby', 'FiftyFirstNearby', 'FiftySecondNearby', 'FiftyThirdNearby', 'FiftyFourthNearby', 'FiftyFifthNearby', 'FiftySixthNearby', 'FiftySeventhNearby', 'FiftyEighthNearby', 'FiftyNinthNearby', 'Spot', 'FirstNearbyWeek', 'SecondNearbyWeek', 'ThirdNearbyWeek', 'FourthNearbyWeek', 'FifthNearbyWeek', 'SixthNearbyWeek', 'SeventhNearbyWeek', 'EighthNearbyWeek', 'NinthNearbyWeek', 'TenthNearbyWeek', 'EleventhNearbyWeek', 'TwelfthNearbyWeek', 'ThirteenthNearbyWeek', 'FourteenthNearbyWeek', 'FifteenthNearbyWeek', 'SixteenthNearbyWeek', 'SeventeenthNearbyWeek', 'EighteenthNearbyWeek', 'NineteenthNearbyWeek', 'TwentiethNearbyWeek', 'TwentyFirstNearbyWeek', 'TwentySecondNearbyWeek', 'TwentyThirdNearbyWeek', 'TwentyFourthearbyWeek', 'TwentyFifthNearbyWeek', 'TwentySixthNearbyWeek', 'TwentySeventhNearbyWeek', 'TwentyEighthNearbyWeek', 'TwentyNinthNearbyWeek', 'ThirtiethNearbyWeek', 'ThirtyFirstNearbyWeek', 'ThirtySecondNearbyWeek', 'ThirtyThirdNearbyWeek', 'ThirtyFourthNearbyWeek', 'ThirtyFifthNearbyWeek', 'ThirtySixthNearbyWeek', 'ThirtySeventhNearbyWeek', 'ThirtyEighthNearbyWeek', 'ThirtyNinthNearbyWeek', 'FortiethNearbyWeek', 'FortyFirstNearbyWeek', 'FortySecondNearbyWeek', 'FortyThirdNearbyWeek', 'FortyFourthNearbyWeek', 'FortyFifthNearbyWeek', 'FortySixthNearbyWeek', 'FortySeventhNearbyWeek', 'FortyEighthNearbyWeek', 'FortyNinthNearbyWeek', 'FiftiethNearbyWeek', 'FiftyFirstNearbyWeek', 'FiftySecondNearbyWeek']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeliveryDatesEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on DeliveryDatesEnum' % {"value" : value} )
    def validate_PositiveDecimal(self, value):
        # Validate type PositiveDecimal, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value <= 0:
                warnings_.warn('Value "%(value)s" does not match xsd minExclusive restriction on PositiveDecimal' % {"value" : value} )
    def hasContent_(self):
        if (
            self.commodityBase is not None or
            self.commodityDetails is not None or
            self.unit is not None or
            self.currency is not None or
            self.exchangeId is not None or
            self.publication is not None or
            self.specifiedPrice is not None or
            self.deliveryDates is not None or
            self.deliveryNearby is not None or
            self.deliveryDate is not None or
            self.deliveryDateYearMonth is not None or
            self.deliveryDateRollConvention is not None or
            self.deliveryDateExpirationConvention is not None or
            self.multiplier is not None or
            super(Commodity, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Commodity', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Commodity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Commodity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Commodity'):
        super(Commodity, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Commodity')
    def exportChildren(self, outfile, level, namespace_='', name_='Commodity', fromsubclass_=False, pretty_print=True):
        super(Commodity, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.commodityBase is not None:
            self.commodityBase.export(outfile, level, namespace_, name_='commodityBase', pretty_print=pretty_print)
        if self.commodityDetails is not None:
            self.commodityDetails.export(outfile, level, namespace_, name_='commodityDetails', pretty_print=pretty_print)
        if self.unit is not None:
            self.unit.export(outfile, level, namespace_, name_='unit', pretty_print=pretty_print)
        if self.currency is not None:
            self.currency.export(outfile, level, namespace_, name_='currency', pretty_print=pretty_print)
        if self.exchangeId is not None:
            self.exchangeId.export(outfile, level, namespace_, name_='exchangeId', pretty_print=pretty_print)
        if self.publication is not None:
            self.publication.export(outfile, level, namespace_, name_='publication', pretty_print=pretty_print)
        if self.specifiedPrice is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sspecifiedPrice>%s</%sspecifiedPrice>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.specifiedPrice), input_name='specifiedPrice')), namespace_, eol_))
        if self.deliveryDates is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdeliveryDates>%s</%sdeliveryDates>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.deliveryDates), input_name='deliveryDates')), namespace_, eol_))
        if self.deliveryNearby is not None:
            self.deliveryNearby.export(outfile, level, namespace_, name_='deliveryNearby', pretty_print=pretty_print)
        if self.deliveryDate is not None:
            self.deliveryDate.export(outfile, level, namespace_, name_='deliveryDate', pretty_print=pretty_print)
        if self.deliveryDateYearMonth is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdeliveryDateYearMonth>%s</%sdeliveryDateYearMonth>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.deliveryDateYearMonth), input_name='deliveryDateYearMonth')), namespace_, eol_))
        if self.deliveryDateRollConvention is not None:
            self.deliveryDateRollConvention.export(outfile, level, namespace_, name_='deliveryDateRollConvention', pretty_print=pretty_print)
        if self.deliveryDateExpirationConvention is not None:
            self.deliveryDateExpirationConvention.export(outfile, level, namespace_, name_='deliveryDateExpirationConvention', pretty_print=pretty_print)
        if self.multiplier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smultiplier>%s</%smultiplier>%s' % (namespace_, self.gds_format_float(self.multiplier, input_name='multiplier'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Commodity, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'commodityBase':
            obj_ = CommodityBase.factory()
            obj_.build(child_)
            self.commodityBase = obj_
            obj_.original_tagname_ = 'commodityBase'
        elif nodeName_ == 'commodityDetails':
            obj_ = CommodityDetails.factory()
            obj_.build(child_)
            self.commodityDetails = obj_
            obj_.original_tagname_ = 'commodityDetails'
        elif nodeName_ == 'unit':
            obj_ = QuantityUnit.factory()
            obj_.build(child_)
            self.unit = obj_
            obj_.original_tagname_ = 'unit'
        elif nodeName_ == 'currency':
            class_obj_ = self.get_class_obj_(child_, Currency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'exchangeId':
            obj_ = ExchangeId.factory()
            obj_.build(child_)
            self.exchangeId = obj_
            obj_.original_tagname_ = 'exchangeId'
        elif nodeName_ == 'publication':
            obj_ = CommodityInformationSource.factory()
            obj_.build(child_)
            self.publication = obj_
            obj_.original_tagname_ = 'publication'
        elif nodeName_ == 'specifiedPrice':
            specifiedPrice_ = child_.text
            specifiedPrice_ = re_.sub(String_cleanup_pat_, " ", specifiedPrice_).strip()
            specifiedPrice_ = self.gds_validate_string(specifiedPrice_, node, 'specifiedPrice')
            self.specifiedPrice = specifiedPrice_
            # validate type SpecifiedPriceEnum
            self.validate_SpecifiedPriceEnum(self.specifiedPrice)
        elif nodeName_ == 'deliveryDates':
            deliveryDates_ = child_.text
            deliveryDates_ = re_.sub(String_cleanup_pat_, " ", deliveryDates_).strip()
            deliveryDates_ = self.gds_validate_string(deliveryDates_, node, 'deliveryDates')
            self.deliveryDates = deliveryDates_
            # validate type DeliveryDatesEnum
            self.validate_DeliveryDatesEnum(self.deliveryDates)
        elif nodeName_ == 'deliveryNearby':
            obj_ = DeliveryNearby.factory()
            obj_.build(child_)
            self.deliveryNearby = obj_
            obj_.original_tagname_ = 'deliveryNearby'
        elif nodeName_ == 'deliveryDate':
            obj_ = AdjustableDate.factory()
            obj_.build(child_)
            self.deliveryDate = obj_
            obj_.original_tagname_ = 'deliveryDate'
        elif nodeName_ == 'deliveryDateYearMonth':
            deliveryDateYearMonth_ = child_.text
            deliveryDateYearMonth_ = self.gds_validate_string(deliveryDateYearMonth_, node, 'deliveryDateYearMonth')
            self.deliveryDateYearMonth = deliveryDateYearMonth_
        elif nodeName_ == 'deliveryDateRollConvention':
            class_obj_ = self.get_class_obj_(child_, Offset)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.deliveryDateRollConvention = obj_
            obj_.original_tagname_ = 'deliveryDateRollConvention'
        elif nodeName_ == 'deliveryDateExpirationConvention':
            class_obj_ = self.get_class_obj_(child_, Offset)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.deliveryDateExpirationConvention = obj_
            obj_.original_tagname_ = 'deliveryDateExpirationConvention'
        elif nodeName_ == 'multiplier':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'multiplier')
            self.multiplier = fval_
            # validate type PositiveDecimal
            self.validate_PositiveDecimal(self.multiplier)
        super(Commodity, self).buildChildren(child_, node, nodeName_, True)
# end class Commodity


class Bond(UnderlyingAsset):
    """An exchange traded bond.Specifies the issuer name of a fixed income
    security or convertible bond. This name can either be explicitly
    stated, or specified as an href into another element of the
    document, such as the obligor."""
    member_data_items_ = {
        'issuerName': MemberSpec_('issuerName', ['String', 'xsd:string'], 0),
        'issuerPartyReference': MemberSpec_('issuerPartyReference', 'PartyReference', 0),
        'seniority': MemberSpec_('seniority', 'CreditSeniority', 0),
        'couponType': MemberSpec_('couponType', 'CouponType', 0),
        'couponRate': MemberSpec_('couponRate', 'xsd:decimal', 0),
        'maturity': MemberSpec_('maturity', 'xsd:date', 0),
        'parValue': MemberSpec_('parValue', 'xsd:decimal', 0),
        'faceAmount': MemberSpec_('faceAmount', 'xsd:decimal', 0),
        'paymentFrequency': MemberSpec_('paymentFrequency', 'Period', 0),
        'dayCountFraction': MemberSpec_('dayCountFraction', 'DayCountFraction', 0),
    }
    subclass = None
    superclass = UnderlyingAsset
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, issuerName=None, issuerPartyReference=None, seniority=None, couponType=None, couponRate=None, maturity=None, parValue=None, faceAmount=None, paymentFrequency=None, dayCountFraction=None, extensiontype_=None):
        self.original_tagname_ = None
        super(Bond, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, extensiontype_, )
        self.issuerName = issuerName
        self.validate_String(self.issuerName)
        self.issuerPartyReference = issuerPartyReference
        self.seniority = seniority
        self.couponType = couponType
        self.couponRate = couponRate
        if isinstance(maturity, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(maturity, '%Y-%m-%d').date()
        else:
            initvalue_ = maturity
        self.maturity = initvalue_
        self.parValue = parValue
        self.faceAmount = faceAmount
        self.paymentFrequency = paymentFrequency
        self.dayCountFraction = dayCountFraction
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Bond)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Bond.subclass:
            return Bond.subclass(*args_, **kwargs_)
        else:
            return Bond(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_issuerName(self): return self.issuerName
    def set_issuerName(self, issuerName): self.issuerName = issuerName
    def get_issuerPartyReference(self): return self.issuerPartyReference
    def set_issuerPartyReference(self, issuerPartyReference): self.issuerPartyReference = issuerPartyReference
    def get_seniority(self): return self.seniority
    def set_seniority(self, seniority): self.seniority = seniority
    def get_couponType(self): return self.couponType
    def set_couponType(self, couponType): self.couponType = couponType
    def get_couponRate(self): return self.couponRate
    def set_couponRate(self, couponRate): self.couponRate = couponRate
    def get_maturity(self): return self.maturity
    def set_maturity(self, maturity): self.maturity = maturity
    def get_parValue(self): return self.parValue
    def set_parValue(self, parValue): self.parValue = parValue
    def get_faceAmount(self): return self.faceAmount
    def set_faceAmount(self, faceAmount): self.faceAmount = faceAmount
    def get_paymentFrequency(self): return self.paymentFrequency
    def set_paymentFrequency(self, paymentFrequency): self.paymentFrequency = paymentFrequency
    def get_dayCountFraction(self): return self.dayCountFraction
    def set_dayCountFraction(self, dayCountFraction): self.dayCountFraction = dayCountFraction
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.issuerName is not None or
            self.issuerPartyReference is not None or
            self.seniority is not None or
            self.couponType is not None or
            self.couponRate is not None or
            self.maturity is not None or
            self.parValue is not None or
            self.faceAmount is not None or
            self.paymentFrequency is not None or
            self.dayCountFraction is not None or
            super(Bond, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Bond', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Bond')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Bond', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Bond'):
        super(Bond, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Bond')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Bond', fromsubclass_=False, pretty_print=True):
        super(Bond, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.issuerName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sissuerName>%s</%sissuerName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.issuerName), input_name='issuerName')), namespace_, eol_))
        if self.issuerPartyReference is not None:
            self.issuerPartyReference.export(outfile, level, namespace_, name_='issuerPartyReference', pretty_print=pretty_print)
        if self.seniority is not None:
            self.seniority.export(outfile, level, namespace_, name_='seniority', pretty_print=pretty_print)
        if self.couponType is not None:
            self.couponType.export(outfile, level, namespace_, name_='couponType', pretty_print=pretty_print)
        if self.couponRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scouponRate>%s</%scouponRate>%s' % (namespace_, self.gds_format_float(self.couponRate, input_name='couponRate'), namespace_, eol_))
        if self.maturity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaturity>%s</%smaturity>%s' % (namespace_, self.gds_format_date(self.maturity, input_name='maturity'), namespace_, eol_))
        if self.parValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sparValue>%s</%sparValue>%s' % (namespace_, self.gds_format_float(self.parValue, input_name='parValue'), namespace_, eol_))
        if self.faceAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfaceAmount>%s</%sfaceAmount>%s' % (namespace_, self.gds_format_float(self.faceAmount, input_name='faceAmount'), namespace_, eol_))
        if self.paymentFrequency is not None:
            self.paymentFrequency.export(outfile, level, namespace_, name_='paymentFrequency', pretty_print=pretty_print)
        if self.dayCountFraction is not None:
            self.dayCountFraction.export(outfile, level, namespace_, name_='dayCountFraction', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(Bond, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'issuerName':
            issuerName_ = child_.text
            issuerName_ = self.gds_validate_string(issuerName_, node, 'issuerName')
            self.issuerName = issuerName_
            # validate type String
            self.validate_String(self.issuerName)
        elif nodeName_ == 'issuerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.issuerPartyReference = obj_
            obj_.original_tagname_ = 'issuerPartyReference'
        elif nodeName_ == 'seniority':
            obj_ = CreditSeniority.factory()
            obj_.build(child_)
            self.seniority = obj_
            obj_.original_tagname_ = 'seniority'
        elif nodeName_ == 'couponType':
            obj_ = CouponType.factory()
            obj_.build(child_)
            self.couponType = obj_
            obj_.original_tagname_ = 'couponType'
        elif nodeName_ == 'couponRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'couponRate')
            self.couponRate = fval_
        elif nodeName_ == 'maturity':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.maturity = dval_
        elif nodeName_ == 'parValue':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'parValue')
            self.parValue = fval_
        elif nodeName_ == 'faceAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'faceAmount')
            self.faceAmount = fval_
        elif nodeName_ == 'paymentFrequency':
            class_obj_ = self.get_class_obj_(child_, Period)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.paymentFrequency = obj_
            obj_.original_tagname_ = 'paymentFrequency'
        elif nodeName_ == 'dayCountFraction':
            obj_ = DayCountFraction.factory()
            obj_.build(child_)
            self.dayCountFraction = obj_
            obj_.original_tagname_ = 'dayCountFraction'
        super(Bond, self).buildChildren(child_, node, nodeName_, True)
# end class Bond


class AssetReference(Reference):
    """Reference to an underlying asset."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(AssetReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AssetReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AssetReference.subclass:
            return AssetReference.subclass(*args_, **kwargs_)
        else:
            return AssetReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(AssetReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AssetReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AssetReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AssetReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AssetReference'):
        super(AssetReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AssetReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AssetReference', fromsubclass_=False, pretty_print=True):
        super(AssetReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(AssetReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AssetReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AssetReference


class AnyAssetReference(Reference):
    """A reference to an asset, e.g. a portfolio, trade, or reference
    instrument.."""
    member_data_items_ = {
        'href': MemberSpec_('href', 'xsd:string', 0),
    }
    subclass = None
    superclass = Reference
    def __init__(self, href=None):
        self.original_tagname_ = None
        super(AnyAssetReference, self).__init__()
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnyAssetReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnyAssetReference.subclass:
            return AnyAssetReference.subclass(*args_, **kwargs_)
        else:
            return AnyAssetReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(AnyAssetReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AnyAssetReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnyAssetReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AnyAssetReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AnyAssetReference'):
        super(AnyAssetReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AnyAssetReference')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AnyAssetReference', fromsubclass_=False, pretty_print=True):
        super(AnyAssetReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(AnyAssetReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AnyAssetReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AnyAssetReference


class Strategy(Product):
    """A type defining a group of products making up a single trade."""
    member_data_items_ = {
        'strategyComponentIdentifier': MemberSpec_('strategyComponentIdentifier', 'StrategyComponentIdentification', 1),
        'premiumProductReference': MemberSpec_('premiumProductReference', 'ProductReference', 0),
        'product': MemberSpec_('product', 'Product', 1),
    }
    subclass = None
    superclass = Product
    def __init__(self, id=None, primaryAssetClass=None, secondaryAssetClass=None, productType=None, productId=None, assetClass=None, embeddedOptionType=None, strategyComponentIdentifier=None, premiumProductReference=None, product=None):
        self.original_tagname_ = None
        super(Strategy, self).__init__(id, primaryAssetClass, secondaryAssetClass, productType, productId, assetClass, embeddedOptionType, )
        if strategyComponentIdentifier is None:
            self.strategyComponentIdentifier = []
        else:
            self.strategyComponentIdentifier = strategyComponentIdentifier
        self.premiumProductReference = premiumProductReference
        if product is None:
            self.product = []
        else:
            self.product = product
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Strategy)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Strategy.subclass:
            return Strategy.subclass(*args_, **kwargs_)
        else:
            return Strategy(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_strategyComponentIdentifier(self): return self.strategyComponentIdentifier
    def set_strategyComponentIdentifier(self, strategyComponentIdentifier): self.strategyComponentIdentifier = strategyComponentIdentifier
    def add_strategyComponentIdentifier(self, value): self.strategyComponentIdentifier.append(value)
    def insert_strategyComponentIdentifier_at(self, index, value): self.strategyComponentIdentifier.insert(index, value)
    def replace_strategyComponentIdentifier_at(self, index, value): self.strategyComponentIdentifier[index] = value
    def get_premiumProductReference(self): return self.premiumProductReference
    def set_premiumProductReference(self, premiumProductReference): self.premiumProductReference = premiumProductReference
    def get_product(self): return self.product
    def set_product(self, product): self.product = product
    def add_product(self, value): self.product.append(value)
    def insert_product_at(self, index, value): self.product.insert(index, value)
    def replace_product_at(self, index, value): self.product[index] = value
    def hasContent_(self):
        if (
            self.strategyComponentIdentifier or
            self.premiumProductReference is not None or
            self.product or
            super(Strategy, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Strategy', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Strategy')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Strategy', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Strategy'):
        super(Strategy, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Strategy')
    def exportChildren(self, outfile, level, namespace_='', name_='Strategy', fromsubclass_=False, pretty_print=True):
        super(Strategy, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for strategyComponentIdentifier_ in self.strategyComponentIdentifier:
            strategyComponentIdentifier_.export(outfile, level, namespace_, name_='strategyComponentIdentifier', pretty_print=pretty_print)
        if self.premiumProductReference is not None:
            self.premiumProductReference.export(outfile, level, namespace_, name_='premiumProductReference', pretty_print=pretty_print)
        for product_ in self.product:
            product_.export(outfile, level, namespace_, name_='product', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Strategy, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'strategyComponentIdentifier':
            obj_ = StrategyComponentIdentification.factory()
            obj_.build(child_)
            self.strategyComponentIdentifier.append(obj_)
            obj_.original_tagname_ = 'strategyComponentIdentifier'
        elif nodeName_ == 'premiumProductReference':
            obj_ = ProductReference.factory()
            obj_.build(child_)
            self.premiumProductReference = obj_
            obj_.original_tagname_ = 'premiumProductReference'
        elif nodeName_ == 'product':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <product> element')
            self.product.append(obj_)
            obj_.original_tagname_ = 'product'
        elif nodeName_ == 'instrumentTradeDetails':
            obj_ = InstrumentTradeDetails.factory()
            obj_.build(child_)
            self.product.append(obj_)
            obj_.original_tagname_ = 'instrumentTradeDetails'
        elif nodeName_ == 'strategy':
            obj_ = Strategy.factory()
            obj_.build(child_)
            self.product.append(obj_)
            obj_.original_tagname_ = 'strategy'
        super(Strategy, self).buildChildren(child_, node, nodeName_, True)
# end class Strategy


class PercentageRule(PaymentRule):
    """A type defining a content model for a calculation rule defined as
    percentage of the notional amount."""
    member_data_items_ = {
        'paymentPercent': MemberSpec_('paymentPercent', 'xsd:decimal', 0),
        'notionalAmountReference': MemberSpec_('notionalAmountReference', 'NotionalAmountReference', 0),
    }
    subclass = None
    superclass = PaymentRule
    def __init__(self, paymentPercent=None, notionalAmountReference=None):
        self.original_tagname_ = None
        super(PercentageRule, self).__init__()
        self.paymentPercent = paymentPercent
        self.notionalAmountReference = notionalAmountReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PercentageRule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PercentageRule.subclass:
            return PercentageRule.subclass(*args_, **kwargs_)
        else:
            return PercentageRule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_paymentPercent(self): return self.paymentPercent
    def set_paymentPercent(self, paymentPercent): self.paymentPercent = paymentPercent
    def get_notionalAmountReference(self): return self.notionalAmountReference
    def set_notionalAmountReference(self, notionalAmountReference): self.notionalAmountReference = notionalAmountReference
    def hasContent_(self):
        if (
            self.paymentPercent is not None or
            self.notionalAmountReference is not None or
            super(PercentageRule, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PercentageRule', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PercentageRule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PercentageRule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PercentageRule'):
        super(PercentageRule, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PercentageRule')
    def exportChildren(self, outfile, level, namespace_='', name_='PercentageRule', fromsubclass_=False, pretty_print=True):
        super(PercentageRule, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.paymentPercent is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spaymentPercent>%s</%spaymentPercent>%s' % (namespace_, self.gds_format_float(self.paymentPercent, input_name='paymentPercent'), namespace_, eol_))
        if self.notionalAmountReference is not None:
            self.notionalAmountReference.export(outfile, level, namespace_, name_='notionalAmountReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PercentageRule, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'paymentPercent':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'paymentPercent')
            self.paymentPercent = fval_
        elif nodeName_ == 'notionalAmountReference':
            obj_ = NotionalAmountReference.factory()
            obj_.build(child_)
            self.notionalAmountReference = obj_
            obj_.original_tagname_ = 'notionalAmountReference'
        super(PercentageRule, self).buildChildren(child_, node, nodeName_, True)
# end class PercentageRule


class PartyTradeIdentifier(TradeIdentifier):
    """A type defining one or more trade identifiers allocated to the trade
    by a party. A link identifier allows the trade to be associated
    with other related trades, e.g. trades forming part of a larger
    structured transaction. It is expected that for external
    communication of trade there will be only one tradeId sent in
    the document per party."""
    member_data_items_ = {
        'linkId': MemberSpec_('linkId', 'LinkId', 1),
        'allocationTradeId': MemberSpec_('allocationTradeId', 'TradeIdentifier', 1),
        'blockTradeId': MemberSpec_('blockTradeId', 'TradeIdentifier', 0),
        'originatingTradeId': MemberSpec_('originatingTradeId', 'TradeIdentifier', 1),
        'productComponentIdentifier': MemberSpec_('productComponentIdentifier', 'ProductComponentIdentifier', 1),
    }
    subclass = None
    superclass = TradeIdentifier
    def __init__(self, id=None, issuer=None, tradeId=None, partyReference=None, accountReference=None, reportingRole=None, versionedTradeId=None, linkId=None, allocationTradeId=None, blockTradeId=None, originatingTradeId=None, productComponentIdentifier=None):
        self.original_tagname_ = None
        super(PartyTradeIdentifier, self).__init__(id, issuer, tradeId, partyReference, accountReference, reportingRole, versionedTradeId, )
        if linkId is None:
            self.linkId = []
        else:
            self.linkId = linkId
        if allocationTradeId is None:
            self.allocationTradeId = []
        else:
            self.allocationTradeId = allocationTradeId
        self.blockTradeId = blockTradeId
        if originatingTradeId is None:
            self.originatingTradeId = []
        else:
            self.originatingTradeId = originatingTradeId
        if productComponentIdentifier is None:
            self.productComponentIdentifier = []
        else:
            self.productComponentIdentifier = productComponentIdentifier
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyTradeIdentifier)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyTradeIdentifier.subclass:
            return PartyTradeIdentifier.subclass(*args_, **kwargs_)
        else:
            return PartyTradeIdentifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_linkId(self): return self.linkId
    def set_linkId(self, linkId): self.linkId = linkId
    def add_linkId(self, value): self.linkId.append(value)
    def insert_linkId_at(self, index, value): self.linkId.insert(index, value)
    def replace_linkId_at(self, index, value): self.linkId[index] = value
    def get_allocationTradeId(self): return self.allocationTradeId
    def set_allocationTradeId(self, allocationTradeId): self.allocationTradeId = allocationTradeId
    def add_allocationTradeId(self, value): self.allocationTradeId.append(value)
    def insert_allocationTradeId_at(self, index, value): self.allocationTradeId.insert(index, value)
    def replace_allocationTradeId_at(self, index, value): self.allocationTradeId[index] = value
    def get_blockTradeId(self): return self.blockTradeId
    def set_blockTradeId(self, blockTradeId): self.blockTradeId = blockTradeId
    def get_originatingTradeId(self): return self.originatingTradeId
    def set_originatingTradeId(self, originatingTradeId): self.originatingTradeId = originatingTradeId
    def add_originatingTradeId(self, value): self.originatingTradeId.append(value)
    def insert_originatingTradeId_at(self, index, value): self.originatingTradeId.insert(index, value)
    def replace_originatingTradeId_at(self, index, value): self.originatingTradeId[index] = value
    def get_productComponentIdentifier(self): return self.productComponentIdentifier
    def set_productComponentIdentifier(self, productComponentIdentifier): self.productComponentIdentifier = productComponentIdentifier
    def add_productComponentIdentifier(self, value): self.productComponentIdentifier.append(value)
    def insert_productComponentIdentifier_at(self, index, value): self.productComponentIdentifier.insert(index, value)
    def replace_productComponentIdentifier_at(self, index, value): self.productComponentIdentifier[index] = value
    def hasContent_(self):
        if (
            self.linkId or
            self.allocationTradeId or
            self.blockTradeId is not None or
            self.originatingTradeId or
            self.productComponentIdentifier or
            super(PartyTradeIdentifier, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartyTradeIdentifier', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyTradeIdentifier')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartyTradeIdentifier', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyTradeIdentifier'):
        super(PartyTradeIdentifier, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PartyTradeIdentifier')
    def exportChildren(self, outfile, level, namespace_='', name_='PartyTradeIdentifier', fromsubclass_=False, pretty_print=True):
        super(PartyTradeIdentifier, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for linkId_ in self.linkId:
            linkId_.export(outfile, level, namespace_, name_='linkId', pretty_print=pretty_print)
        for allocationTradeId_ in self.allocationTradeId:
            allocationTradeId_.export(outfile, level, namespace_, name_='allocationTradeId', pretty_print=pretty_print)
        if self.blockTradeId is not None:
            self.blockTradeId.export(outfile, level, namespace_, name_='blockTradeId', pretty_print=pretty_print)
        for originatingTradeId_ in self.originatingTradeId:
            originatingTradeId_.export(outfile, level, namespace_, name_='originatingTradeId', pretty_print=pretty_print)
        for productComponentIdentifier_ in self.productComponentIdentifier:
            productComponentIdentifier_.export(outfile, level, namespace_, name_='productComponentIdentifier', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PartyTradeIdentifier, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'linkId':
            obj_ = LinkId.factory()
            obj_.build(child_)
            self.linkId.append(obj_)
            obj_.original_tagname_ = 'linkId'
        elif nodeName_ == 'allocationTradeId':
            class_obj_ = self.get_class_obj_(child_, TradeIdentifier)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.allocationTradeId.append(obj_)
            obj_.original_tagname_ = 'allocationTradeId'
        elif nodeName_ == 'blockTradeId':
            class_obj_ = self.get_class_obj_(child_, TradeIdentifier)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.blockTradeId = obj_
            obj_.original_tagname_ = 'blockTradeId'
        elif nodeName_ == 'originatingTradeId':
            class_obj_ = self.get_class_obj_(child_, TradeIdentifier)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.originatingTradeId.append(obj_)
            obj_.original_tagname_ = 'originatingTradeId'
        elif nodeName_ == 'productComponentIdentifier':
            obj_ = ProductComponentIdentifier.factory()
            obj_.build(child_)
            self.productComponentIdentifier.append(obj_)
            obj_.original_tagname_ = 'productComponentIdentifier'
        super(PartyTradeIdentifier, self).buildChildren(child_, node, nodeName_, True)
# end class PartyTradeIdentifier


class InstrumentTradeDetails(Product):
    """The economics of a trade of a multiply traded instrument."""
    member_data_items_ = {
        'buyerPartyReference': MemberSpec_('buyerPartyReference', 'PartyReference', 0),
        'buyerAccountReference': MemberSpec_('buyerAccountReference', 'AccountReference', 0),
        'sellerPartyReference': MemberSpec_('sellerPartyReference', 'PartyReference', 0),
        'sellerAccountReference': MemberSpec_('sellerAccountReference', 'AccountReference', 0),
        'underlyingAsset': MemberSpec_('underlyingAsset', 'Asset', 0),
        'quantity': MemberSpec_('quantity', 'InstrumentTradeQuantity', 0),
        'pricing': MemberSpec_('pricing', 'InstrumentTradePricing', 0),
        'principal': MemberSpec_('principal', 'InstrumentTradePrincipal', 0),
    }
    subclass = None
    superclass = Product
    def __init__(self, id=None, primaryAssetClass=None, secondaryAssetClass=None, productType=None, productId=None, assetClass=None, embeddedOptionType=None, buyerPartyReference=None, buyerAccountReference=None, sellerPartyReference=None, sellerAccountReference=None, underlyingAsset=None, quantity=None, pricing=None, principal=None):
        self.original_tagname_ = None
        super(InstrumentTradeDetails, self).__init__(id, primaryAssetClass, secondaryAssetClass, productType, productId, assetClass, embeddedOptionType, )
        self.buyerPartyReference = buyerPartyReference
        self.buyerAccountReference = buyerAccountReference
        self.sellerPartyReference = sellerPartyReference
        self.sellerAccountReference = sellerAccountReference
        self.underlyingAsset = underlyingAsset
        self.quantity = quantity
        self.pricing = pricing
        self.principal = principal
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InstrumentTradeDetails)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InstrumentTradeDetails.subclass:
            return InstrumentTradeDetails.subclass(*args_, **kwargs_)
        else:
            return InstrumentTradeDetails(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_buyerPartyReference(self): return self.buyerPartyReference
    def set_buyerPartyReference(self, buyerPartyReference): self.buyerPartyReference = buyerPartyReference
    def get_buyerAccountReference(self): return self.buyerAccountReference
    def set_buyerAccountReference(self, buyerAccountReference): self.buyerAccountReference = buyerAccountReference
    def get_sellerPartyReference(self): return self.sellerPartyReference
    def set_sellerPartyReference(self, sellerPartyReference): self.sellerPartyReference = sellerPartyReference
    def get_sellerAccountReference(self): return self.sellerAccountReference
    def set_sellerAccountReference(self, sellerAccountReference): self.sellerAccountReference = sellerAccountReference
    def get_underlyingAsset(self): return self.underlyingAsset
    def set_underlyingAsset(self, underlyingAsset): self.underlyingAsset = underlyingAsset
    def get_quantity(self): return self.quantity
    def set_quantity(self, quantity): self.quantity = quantity
    def get_pricing(self): return self.pricing
    def set_pricing(self, pricing): self.pricing = pricing
    def get_principal(self): return self.principal
    def set_principal(self, principal): self.principal = principal
    def hasContent_(self):
        if (
            self.buyerPartyReference is not None or
            self.buyerAccountReference is not None or
            self.sellerPartyReference is not None or
            self.sellerAccountReference is not None or
            self.underlyingAsset is not None or
            self.quantity is not None or
            self.pricing is not None or
            self.principal is not None or
            super(InstrumentTradeDetails, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InstrumentTradeDetails', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InstrumentTradeDetails')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InstrumentTradeDetails', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InstrumentTradeDetails'):
        super(InstrumentTradeDetails, self).exportAttributes(outfile, level, already_processed, namespace_, name_='InstrumentTradeDetails')
    def exportChildren(self, outfile, level, namespace_='', name_='InstrumentTradeDetails', fromsubclass_=False, pretty_print=True):
        super(InstrumentTradeDetails, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.buyerPartyReference is not None:
            self.buyerPartyReference.export(outfile, level, namespace_, name_='buyerPartyReference', pretty_print=pretty_print)
        if self.buyerAccountReference is not None:
            self.buyerAccountReference.export(outfile, level, namespace_, name_='buyerAccountReference', pretty_print=pretty_print)
        if self.sellerPartyReference is not None:
            self.sellerPartyReference.export(outfile, level, namespace_, name_='sellerPartyReference', pretty_print=pretty_print)
        if self.sellerAccountReference is not None:
            self.sellerAccountReference.export(outfile, level, namespace_, name_='sellerAccountReference', pretty_print=pretty_print)
        if self.underlyingAsset is not None:
            self.underlyingAsset.export(outfile, level, namespace_, name_='underlyingAsset', pretty_print=pretty_print)
        if self.quantity is not None:
            self.quantity.export(outfile, level, namespace_, name_='quantity', pretty_print=pretty_print)
        if self.pricing is not None:
            self.pricing.export(outfile, level, namespace_, name_='pricing', pretty_print=pretty_print)
        if self.principal is not None:
            self.principal.export(outfile, level, namespace_, name_='principal', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(InstrumentTradeDetails, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'buyerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.buyerPartyReference = obj_
            obj_.original_tagname_ = 'buyerPartyReference'
        elif nodeName_ == 'buyerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.buyerAccountReference = obj_
            obj_.original_tagname_ = 'buyerAccountReference'
        elif nodeName_ == 'sellerPartyReference':
            obj_ = PartyReference.factory()
            obj_.build(child_)
            self.sellerPartyReference = obj_
            obj_.original_tagname_ = 'sellerPartyReference'
        elif nodeName_ == 'sellerAccountReference':
            obj_ = AccountReference.factory()
            obj_.build(child_)
            self.sellerAccountReference = obj_
            obj_.original_tagname_ = 'sellerAccountReference'
        elif nodeName_ == 'underlyingAsset':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <underlyingAsset> element')
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'underlyingAsset'
        elif nodeName_ == 'basket':
            obj_ = Basket.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'basket'
        elif nodeName_ == 'bond':
            class_obj_ = self.get_class_obj_(child_, Bond)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'bond'
        elif nodeName_ == 'cash':
            obj_ = Cash.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'cash'
        elif nodeName_ == 'commodity':
            obj_ = Commodity.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'commodity'
        elif nodeName_ == 'convertibleBond':
            obj_ = ConvertibleBond.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'convertibleBond'
        elif nodeName_ == 'equity':
            obj_ = EquityAsset.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'equity'
        elif nodeName_ == 'exchangeTradedFund':
            obj_ = ExchangeTradedFund.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'exchangeTradedFund'
        elif nodeName_ == 'future':
            obj_ = Future.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'future'
        elif nodeName_ == 'index':
            obj_ = Index.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'index'
        elif nodeName_ == 'loan':
            obj_ = Loan.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'loan'
        elif nodeName_ == 'mortgage':
            obj_ = Mortgage.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'mortgage'
        elif nodeName_ == 'mutualFund':
            obj_ = MutualFund.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'mutualFund'
        elif nodeName_ == 'option':
            obj_ = ExchangeTradedOption.factory()
            obj_.build(child_)
            self.underlyingAsset = obj_
            obj_.original_tagname_ = 'option'
        elif nodeName_ == 'quantity':
            obj_ = InstrumentTradeQuantity.factory()
            obj_.build(child_)
            self.quantity = obj_
            obj_.original_tagname_ = 'quantity'
        elif nodeName_ == 'pricing':
            obj_ = InstrumentTradePricing.factory()
            obj_.build(child_)
            self.pricing = obj_
            obj_.original_tagname_ = 'pricing'
        elif nodeName_ == 'principal':
            obj_ = InstrumentTradePrincipal.factory()
            obj_.build(child_)
            self.principal = obj_
            obj_.original_tagname_ = 'principal'
        super(InstrumentTradeDetails, self).buildChildren(child_, node, nodeName_, True)
# end class InstrumentTradeDetails


class DataDocument(Document):
    """A type defining a content model that is backwards compatible with
    older FpML releases and which can be used to contain sets of
    data without expressing any processing intention."""
    member_data_items_ = {
        'validation': MemberSpec_('validation', 'Validation', 1),
        'onBehalfOf': MemberSpec_('onBehalfOf', 'OnBehalfOf', 0),
        'originatingEvent': MemberSpec_('originatingEvent', 'OriginatingEvent', 0),
        'trade': MemberSpec_('trade', 'Trade', 1),
        'portfolio': MemberSpec_('portfolio', 'Portfolio', 1),
        'party': MemberSpec_('party', 'Party', 1),
        'account': MemberSpec_('account', 'Account', 1),
    }
    subclass = None
    superclass = Document
    def __init__(self, fpmlVersion=None, expectedBuild=None, actualBuild=None, validation=None, onBehalfOf=None, originatingEvent=None, trade=None, portfolio=None, party=None, account=None):
        self.original_tagname_ = None
        super(DataDocument, self).__init__(fpmlVersion, expectedBuild, actualBuild, )
        if validation is None:
            self.validation = []
        else:
            self.validation = validation
        self.onBehalfOf = onBehalfOf
        self.originatingEvent = originatingEvent
        if trade is None:
            self.trade = []
        else:
            self.trade = trade
        if portfolio is None:
            self.portfolio = []
        else:
            self.portfolio = portfolio
        if party is None:
            self.party = []
        else:
            self.party = party
        if account is None:
            self.account = []
        else:
            self.account = account
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataDocument)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataDocument.subclass:
            return DataDocument.subclass(*args_, **kwargs_)
        else:
            return DataDocument(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_validation(self): return self.validation
    def set_validation(self, validation): self.validation = validation
    def add_validation(self, value): self.validation.append(value)
    def insert_validation_at(self, index, value): self.validation.insert(index, value)
    def replace_validation_at(self, index, value): self.validation[index] = value
    def get_onBehalfOf(self): return self.onBehalfOf
    def set_onBehalfOf(self, onBehalfOf): self.onBehalfOf = onBehalfOf
    def get_originatingEvent(self): return self.originatingEvent
    def set_originatingEvent(self, originatingEvent): self.originatingEvent = originatingEvent
    def get_trade(self): return self.trade
    def set_trade(self, trade): self.trade = trade
    def add_trade(self, value): self.trade.append(value)
    def insert_trade_at(self, index, value): self.trade.insert(index, value)
    def replace_trade_at(self, index, value): self.trade[index] = value
    def get_portfolio(self): return self.portfolio
    def set_portfolio(self, portfolio): self.portfolio = portfolio
    def add_portfolio(self, value): self.portfolio.append(value)
    def insert_portfolio_at(self, index, value): self.portfolio.insert(index, value)
    def replace_portfolio_at(self, index, value): self.portfolio[index] = value
    def get_party(self): return self.party
    def set_party(self, party): self.party = party
    def add_party(self, value): self.party.append(value)
    def insert_party_at(self, index, value): self.party.insert(index, value)
    def replace_party_at(self, index, value): self.party[index] = value
    def get_account(self): return self.account
    def set_account(self, account): self.account = account
    def add_account(self, value): self.account.append(value)
    def insert_account_at(self, index, value): self.account.insert(index, value)
    def replace_account_at(self, index, value): self.account[index] = value
    def hasContent_(self):
        if (
            self.validation or
            self.onBehalfOf is not None or
            self.originatingEvent is not None or
            self.trade or
            self.portfolio or
            self.party or
            self.account or
            super(DataDocument, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DataDocument', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataDocument')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DataDocument', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DataDocument'):
        super(DataDocument, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DataDocument')
    def exportChildren(self, outfile, level, namespace_='', name_='DataDocument', fromsubclass_=False, pretty_print=True):
        super(DataDocument, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for validation_ in self.validation:
            validation_.export(outfile, level, namespace_, name_='validation', pretty_print=pretty_print)
        if self.onBehalfOf is not None:
            self.onBehalfOf.export(outfile, level, namespace_, name_='onBehalfOf', pretty_print=pretty_print)
        if self.originatingEvent is not None:
            self.originatingEvent.export(outfile, level, namespace_, name_='originatingEvent', pretty_print=pretty_print)
        for trade_ in self.trade:
            trade_.export(outfile, level, namespace_, name_='trade', pretty_print=pretty_print)
        for portfolio_ in self.portfolio:
            portfolio_.export(outfile, level, namespace_, name_='portfolio', pretty_print=pretty_print)
        for party_ in self.party:
            party_.export(outfile, level, namespace_, name_='party', pretty_print=pretty_print)
        for account_ in self.account:
            account_.export(outfile, level, namespace_, name_='account', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DataDocument, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'validation':
            obj_ = Validation.factory()
            obj_.build(child_)
            self.validation.append(obj_)
            obj_.original_tagname_ = 'validation'
        elif nodeName_ == 'onBehalfOf':
            obj_ = OnBehalfOf.factory()
            obj_.build(child_)
            self.onBehalfOf = obj_
            obj_.original_tagname_ = 'onBehalfOf'
        elif nodeName_ == 'originatingEvent':
            obj_ = OriginatingEvent.factory()
            obj_.build(child_)
            self.originatingEvent = obj_
            obj_.original_tagname_ = 'originatingEvent'
        elif nodeName_ == 'trade':
            obj_ = Trade.factory()
            obj_.build(child_)
            self.trade.append(obj_)
            obj_.original_tagname_ = 'trade'
        elif nodeName_ == 'portfolio':
            class_obj_ = self.get_class_obj_(child_, Portfolio)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.portfolio.append(obj_)
            obj_.original_tagname_ = 'portfolio'
        elif nodeName_ == 'party':
            obj_ = Party.factory()
            obj_.build(child_)
            self.party.append(obj_)
            obj_.original_tagname_ = 'party'
        elif nodeName_ == 'account':
            obj_ = Account.factory()
            obj_.build(child_)
            self.account.append(obj_)
            obj_.original_tagname_ = 'account'
        super(DataDocument, self).buildChildren(child_, node, nodeName_, True)
# end class DataDocument


class ReportIdentification(ReportSectionIdentification):
    """A type that allows the specific report and section to be identified."""
    member_data_items_ = {
        'numberOfSections': MemberSpec_('numberOfSections', 'xsd:positiveInteger', 0),
        'submissionsComplete': MemberSpec_('submissionsComplete', 'xsd:boolean', 0),
    }
    subclass = None
    superclass = ReportSectionIdentification
    def __init__(self, reportId=None, sectionNumber=None, numberOfSections=None, submissionsComplete=None):
        self.original_tagname_ = None
        super(ReportIdentification, self).__init__(reportId, sectionNumber, )
        self.numberOfSections = numberOfSections
        self.submissionsComplete = submissionsComplete
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReportIdentification)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReportIdentification.subclass:
            return ReportIdentification.subclass(*args_, **kwargs_)
        else:
            return ReportIdentification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_numberOfSections(self): return self.numberOfSections
    def set_numberOfSections(self, numberOfSections): self.numberOfSections = numberOfSections
    def get_submissionsComplete(self): return self.submissionsComplete
    def set_submissionsComplete(self, submissionsComplete): self.submissionsComplete = submissionsComplete
    def hasContent_(self):
        if (
            self.numberOfSections is not None or
            self.submissionsComplete is not None or
            super(ReportIdentification, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReportIdentification', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReportIdentification')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReportIdentification', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReportIdentification'):
        super(ReportIdentification, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ReportIdentification')
    def exportChildren(self, outfile, level, namespace_='', name_='ReportIdentification', fromsubclass_=False, pretty_print=True):
        super(ReportIdentification, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.numberOfSections is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumberOfSections>%s</%snumberOfSections>%s' % (namespace_, self.gds_format_integer(self.numberOfSections, input_name='numberOfSections'), namespace_, eol_))
        if self.submissionsComplete is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssubmissionsComplete>%s</%ssubmissionsComplete>%s' % (namespace_, self.gds_format_boolean(self.submissionsComplete, input_name='submissionsComplete'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ReportIdentification, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'numberOfSections':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'numberOfSections')
            self.numberOfSections = ival_
        elif nodeName_ == 'submissionsComplete':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'submissionsComplete')
            self.submissionsComplete = ival_
        super(ReportIdentification, self).buildChildren(child_, node, nodeName_, True)
# end class ReportIdentification


class PortfolioConstituentReference(PortfolioReferenceBase):
    """A structure used to group together individual messages that can be
    acted on at a group level."""
    member_data_items_ = {
        'sequenceNumber': MemberSpec_('sequenceNumber', 'xsd:positiveInteger', 0),
    }
    subclass = None
    superclass = PortfolioReferenceBase
    def __init__(self, portfolioName=None, sequenceNumber=None):
        self.original_tagname_ = None
        super(PortfolioConstituentReference, self).__init__(portfolioName, )
        self.sequenceNumber = sequenceNumber
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PortfolioConstituentReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PortfolioConstituentReference.subclass:
            return PortfolioConstituentReference.subclass(*args_, **kwargs_)
        else:
            return PortfolioConstituentReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def hasContent_(self):
        if (
            self.sequenceNumber is not None or
            super(PortfolioConstituentReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PortfolioConstituentReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PortfolioConstituentReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PortfolioConstituentReference', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PortfolioConstituentReference'):
        super(PortfolioConstituentReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PortfolioConstituentReference')
    def exportChildren(self, outfile, level, namespace_='', name_='PortfolioConstituentReference', fromsubclass_=False, pretty_print=True):
        super(PortfolioConstituentReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.sequenceNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssequenceNumber>%s</%ssequenceNumber>%s' % (namespace_, self.gds_format_integer(self.sequenceNumber, input_name='sequenceNumber'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PortfolioConstituentReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'sequenceNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'sequenceNumber')
            self.sequenceNumber = ival_
        super(PortfolioConstituentReference, self).buildChildren(child_, node, nodeName_, True)
# end class PortfolioConstituentReference


class PortfolioReference(PortfolioReferenceBase):
    """A structure used to group together individual messages that can be
    acted on at a group level."""
    member_data_items_ = {
        'sequenceNumber': MemberSpec_('sequenceNumber', 'xsd:positiveInteger', 0),
        'submissionsComplete': MemberSpec_('submissionsComplete', 'xsd:boolean', 0),
    }
    subclass = None
    superclass = PortfolioReferenceBase
    def __init__(self, portfolioName=None, sequenceNumber=None, submissionsComplete=None):
        self.original_tagname_ = None
        super(PortfolioReference, self).__init__(portfolioName, )
        self.sequenceNumber = sequenceNumber
        self.submissionsComplete = submissionsComplete
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PortfolioReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PortfolioReference.subclass:
            return PortfolioReference.subclass(*args_, **kwargs_)
        else:
            return PortfolioReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def get_submissionsComplete(self): return self.submissionsComplete
    def set_submissionsComplete(self, submissionsComplete): self.submissionsComplete = submissionsComplete
    def hasContent_(self):
        if (
            self.sequenceNumber is not None or
            self.submissionsComplete is not None or
            super(PortfolioReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PortfolioReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PortfolioReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PortfolioReference', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PortfolioReference'):
        super(PortfolioReference, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PortfolioReference')
    def exportChildren(self, outfile, level, namespace_='', name_='PortfolioReference', fromsubclass_=False, pretty_print=True):
        super(PortfolioReference, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.sequenceNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssequenceNumber>%s</%ssequenceNumber>%s' % (namespace_, self.gds_format_integer(self.sequenceNumber, input_name='sequenceNumber'), namespace_, eol_))
        if self.submissionsComplete is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssubmissionsComplete>%s</%ssubmissionsComplete>%s' % (namespace_, self.gds_format_boolean(self.submissionsComplete, input_name='submissionsComplete'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PortfolioReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'sequenceNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'sequenceNumber')
            self.sequenceNumber = ival_
        elif nodeName_ == 'submissionsComplete':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'submissionsComplete')
            self.submissionsComplete = ival_
        super(PortfolioReference, self).buildChildren(child_, node, nodeName_, True)
# end class PortfolioReference


class Message(Document):
    """A type defining the basic structure of all FpML messages which is
    refined by its derived types."""
    member_data_items_ = {
    }
    subclass = None
    superclass = Document
    def __init__(self, fpmlVersion=None, expectedBuild=None, actualBuild=None, extensiontype_=None):
        self.original_tagname_ = None
        super(Message, self).__init__(fpmlVersion, expectedBuild, actualBuild, extensiontype_, )
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Message)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Message.subclass:
            return Message.subclass(*args_, **kwargs_)
        else:
            return Message(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(Message, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Message', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Message')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Message', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Message'):
        super(Message, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Message')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Message', fromsubclass_=False, pretty_print=True):
        super(Message, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(Message, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Message, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Message


class ExceptionMessageHeader(MessageHeader):
    """A type defining the content model for an exception message header."""
    member_data_items_ = {
        'inReplyTo': MemberSpec_('inReplyTo', 'MessageId', 0),
        'sentBy': MemberSpec_('sentBy', 'MessageAddress', 0),
        'sendTo': MemberSpec_('sendTo', 'MessageAddress', 1),
        'copyTo': MemberSpec_('copyTo', 'MessageAddress', 1),
        'creationTimestamp': MemberSpec_('creationTimestamp', 'xsd:dateTime', 0),
        'expiryTimestamp': MemberSpec_('expiryTimestamp', 'xsd:dateTime', 0),
        'implementationSpecification': MemberSpec_('implementationSpecification', 'ImplementationSpecification', 0),
        'partyMessageInformation': MemberSpec_('partyMessageInformation', 'PartyMessageInformation', 1),
        'Signature': MemberSpec_('Signature', 'SignatureType', 1),
    }
    subclass = None
    superclass = MessageHeader
    def __init__(self, messageId=None, inReplyTo=None, sentBy=None, sendTo=None, copyTo=None, creationTimestamp=None, expiryTimestamp=None, implementationSpecification=None, partyMessageInformation=None, Signature=None):
        self.original_tagname_ = None
        super(ExceptionMessageHeader, self).__init__(messageId, )
        self.inReplyTo = inReplyTo
        self.sentBy = sentBy
        if sendTo is None:
            self.sendTo = []
        else:
            self.sendTo = sendTo
        if copyTo is None:
            self.copyTo = []
        else:
            self.copyTo = copyTo
        if isinstance(creationTimestamp, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(creationTimestamp, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = creationTimestamp
        self.creationTimestamp = initvalue_
        if isinstance(expiryTimestamp, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(expiryTimestamp, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = expiryTimestamp
        self.expiryTimestamp = initvalue_
        self.implementationSpecification = implementationSpecification
        if partyMessageInformation is None:
            self.partyMessageInformation = []
        else:
            self.partyMessageInformation = partyMessageInformation
        if Signature is None:
            self.Signature = []
        else:
            self.Signature = Signature
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExceptionMessageHeader)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExceptionMessageHeader.subclass:
            return ExceptionMessageHeader.subclass(*args_, **kwargs_)
        else:
            return ExceptionMessageHeader(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_inReplyTo(self): return self.inReplyTo
    def set_inReplyTo(self, inReplyTo): self.inReplyTo = inReplyTo
    def get_sentBy(self): return self.sentBy
    def set_sentBy(self, sentBy): self.sentBy = sentBy
    def get_sendTo(self): return self.sendTo
    def set_sendTo(self, sendTo): self.sendTo = sendTo
    def add_sendTo(self, value): self.sendTo.append(value)
    def insert_sendTo_at(self, index, value): self.sendTo.insert(index, value)
    def replace_sendTo_at(self, index, value): self.sendTo[index] = value
    def get_copyTo(self): return self.copyTo
    def set_copyTo(self, copyTo): self.copyTo = copyTo
    def add_copyTo(self, value): self.copyTo.append(value)
    def insert_copyTo_at(self, index, value): self.copyTo.insert(index, value)
    def replace_copyTo_at(self, index, value): self.copyTo[index] = value
    def get_creationTimestamp(self): return self.creationTimestamp
    def set_creationTimestamp(self, creationTimestamp): self.creationTimestamp = creationTimestamp
    def get_expiryTimestamp(self): return self.expiryTimestamp
    def set_expiryTimestamp(self, expiryTimestamp): self.expiryTimestamp = expiryTimestamp
    def get_implementationSpecification(self): return self.implementationSpecification
    def set_implementationSpecification(self, implementationSpecification): self.implementationSpecification = implementationSpecification
    def get_partyMessageInformation(self): return self.partyMessageInformation
    def set_partyMessageInformation(self, partyMessageInformation): self.partyMessageInformation = partyMessageInformation
    def add_partyMessageInformation(self, value): self.partyMessageInformation.append(value)
    def insert_partyMessageInformation_at(self, index, value): self.partyMessageInformation.insert(index, value)
    def replace_partyMessageInformation_at(self, index, value): self.partyMessageInformation[index] = value
    def get_Signature(self): return self.Signature
    def set_Signature(self, Signature): self.Signature = Signature
    def add_Signature(self, value): self.Signature.append(value)
    def insert_Signature_at(self, index, value): self.Signature.insert(index, value)
    def replace_Signature_at(self, index, value): self.Signature[index] = value
    def hasContent_(self):
        if (
            self.inReplyTo is not None or
            self.sentBy is not None or
            self.sendTo or
            self.copyTo or
            self.creationTimestamp is not None or
            self.expiryTimestamp is not None or
            self.implementationSpecification is not None or
            self.partyMessageInformation or
            self.Signature or
            super(ExceptionMessageHeader, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExceptionMessageHeader', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExceptionMessageHeader')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExceptionMessageHeader', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExceptionMessageHeader'):
        super(ExceptionMessageHeader, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ExceptionMessageHeader')
    def exportChildren(self, outfile, level, namespace_='', name_='ExceptionMessageHeader', fromsubclass_=False, pretty_print=True):
        super(ExceptionMessageHeader, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.inReplyTo is not None:
            self.inReplyTo.export(outfile, level, namespace_, name_='inReplyTo', pretty_print=pretty_print)
        if self.sentBy is not None:
            self.sentBy.export(outfile, level, namespace_, name_='sentBy', pretty_print=pretty_print)
        for sendTo_ in self.sendTo:
            sendTo_.export(outfile, level, namespace_, name_='sendTo', pretty_print=pretty_print)
        for copyTo_ in self.copyTo:
            copyTo_.export(outfile, level, namespace_, name_='copyTo', pretty_print=pretty_print)
        if self.creationTimestamp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%screationTimestamp>%s</%screationTimestamp>%s' % (namespace_, self.gds_format_datetime(self.creationTimestamp, input_name='creationTimestamp'), namespace_, eol_))
        if self.expiryTimestamp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexpiryTimestamp>%s</%sexpiryTimestamp>%s' % (namespace_, self.gds_format_datetime(self.expiryTimestamp, input_name='expiryTimestamp'), namespace_, eol_))
        if self.implementationSpecification is not None:
            self.implementationSpecification.export(outfile, level, namespace_, name_='implementationSpecification', pretty_print=pretty_print)
        for partyMessageInformation_ in self.partyMessageInformation:
            partyMessageInformation_.export(outfile, level, namespace_, name_='partyMessageInformation', pretty_print=pretty_print)
        for Signature_ in self.Signature:
            Signature_.export(outfile, level, namespace_='dsig:', name_='Signature', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ExceptionMessageHeader, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'inReplyTo':
            obj_ = MessageId.factory()
            obj_.build(child_)
            self.inReplyTo = obj_
            obj_.original_tagname_ = 'inReplyTo'
        elif nodeName_ == 'sentBy':
            obj_ = MessageAddress.factory()
            obj_.build(child_)
            self.sentBy = obj_
            obj_.original_tagname_ = 'sentBy'
        elif nodeName_ == 'sendTo':
            obj_ = MessageAddress.factory()
            obj_.build(child_)
            self.sendTo.append(obj_)
            obj_.original_tagname_ = 'sendTo'
        elif nodeName_ == 'copyTo':
            obj_ = MessageAddress.factory()
            obj_.build(child_)
            self.copyTo.append(obj_)
            obj_.original_tagname_ = 'copyTo'
        elif nodeName_ == 'creationTimestamp':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.creationTimestamp = dval_
        elif nodeName_ == 'expiryTimestamp':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.expiryTimestamp = dval_
        elif nodeName_ == 'implementationSpecification':
            obj_ = ImplementationSpecification.factory()
            obj_.build(child_)
            self.implementationSpecification = obj_
            obj_.original_tagname_ = 'implementationSpecification'
        elif nodeName_ == 'partyMessageInformation':
            obj_ = PartyMessageInformation.factory()
            obj_.build(child_)
            self.partyMessageInformation.append(obj_)
            obj_.original_tagname_ = 'partyMessageInformation'
        elif nodeName_ == 'Signature':
            obj_ = SignatureType.factory()
            obj_.build(child_)
            self.Signature.append(obj_)
            obj_.original_tagname_ = 'Signature'
        super(ExceptionMessageHeader, self).buildChildren(child_, node, nodeName_, True)
# end class ExceptionMessageHeader


class Exception(Message):
    """A type defining the basic content for a message sent to inform
    another system that some exception has been detected."""
    member_data_items_ = {
        'header': MemberSpec_('header', 'ExceptionMessageHeader', 0),
        'validation': MemberSpec_('validation', 'Validation', 1),
        'parentCorrelationId': MemberSpec_('parentCorrelationId', 'CorrelationId', 0),
        'correlationId': MemberSpec_('correlationId', 'CorrelationId', 0),
        'sequenceNumber': MemberSpec_('sequenceNumber', 'xsd:positiveInteger', 0),
        'reason': MemberSpec_('reason', 'Reason', 1),
        'additionalData': MemberSpec_('additionalData', 'AdditionalData', 0),
    }
    subclass = None
    superclass = Message
    def __init__(self, fpmlVersion=None, expectedBuild=None, actualBuild=None, header=None, validation=None, parentCorrelationId=None, correlationId=None, sequenceNumber=None, reason=None, additionalData=None):
        self.original_tagname_ = None
        super(Exception, self).__init__(fpmlVersion, expectedBuild, actualBuild, )
        self.header = header
        if validation is None:
            self.validation = []
        else:
            self.validation = validation
        self.parentCorrelationId = parentCorrelationId
        self.correlationId = correlationId
        self.sequenceNumber = sequenceNumber
        if reason is None:
            self.reason = []
        else:
            self.reason = reason
        self.additionalData = additionalData
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Exception)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Exception.subclass:
            return Exception.subclass(*args_, **kwargs_)
        else:
            return Exception(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_header(self): return self.header
    def set_header(self, header): self.header = header
    def get_validation(self): return self.validation
    def set_validation(self, validation): self.validation = validation
    def add_validation(self, value): self.validation.append(value)
    def insert_validation_at(self, index, value): self.validation.insert(index, value)
    def replace_validation_at(self, index, value): self.validation[index] = value
    def get_parentCorrelationId(self): return self.parentCorrelationId
    def set_parentCorrelationId(self, parentCorrelationId): self.parentCorrelationId = parentCorrelationId
    def get_correlationId(self): return self.correlationId
    def set_correlationId(self, correlationId): self.correlationId = correlationId
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def get_reason(self): return self.reason
    def set_reason(self, reason): self.reason = reason
    def add_reason(self, value): self.reason.append(value)
    def insert_reason_at(self, index, value): self.reason.insert(index, value)
    def replace_reason_at(self, index, value): self.reason[index] = value
    def get_additionalData(self): return self.additionalData
    def set_additionalData(self, additionalData): self.additionalData = additionalData
    def hasContent_(self):
        if (
            self.header is not None or
            self.validation or
            self.parentCorrelationId is not None or
            self.correlationId is not None or
            self.sequenceNumber is not None or
            self.reason or
            self.additionalData is not None or
            super(Exception, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Exception', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Exception')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Exception', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Exception'):
        super(Exception, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Exception')
    def exportChildren(self, outfile, level, namespace_='', name_='Exception', fromsubclass_=False, pretty_print=True):
        super(Exception, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.header is not None:
            self.header.export(outfile, level, namespace_, name_='header', pretty_print=pretty_print)
        for validation_ in self.validation:
            validation_.export(outfile, level, namespace_, name_='validation', pretty_print=pretty_print)
        if self.parentCorrelationId is not None:
            self.parentCorrelationId.export(outfile, level, namespace_, name_='parentCorrelationId', pretty_print=pretty_print)
        if self.correlationId is not None:
            self.correlationId.export(outfile, level, namespace_, name_='correlationId', pretty_print=pretty_print)
        if self.sequenceNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssequenceNumber>%s</%ssequenceNumber>%s' % (namespace_, self.gds_format_integer(self.sequenceNumber, input_name='sequenceNumber'), namespace_, eol_))
        for reason_ in self.reason:
            reason_.export(outfile, level, namespace_, name_='reason', pretty_print=pretty_print)
        if self.additionalData is not None:
            self.additionalData.export(outfile, level, namespace_, name_='additionalData', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Exception, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'header':
            obj_ = ExceptionMessageHeader.factory()
            obj_.build(child_)
            self.header = obj_
            obj_.original_tagname_ = 'header'
        elif nodeName_ == 'validation':
            obj_ = Validation.factory()
            obj_.build(child_)
            self.validation.append(obj_)
            obj_.original_tagname_ = 'validation'
        elif nodeName_ == 'parentCorrelationId':
            obj_ = CorrelationId.factory()
            obj_.build(child_)
            self.parentCorrelationId = obj_
            obj_.original_tagname_ = 'parentCorrelationId'
        elif nodeName_ == 'correlationId':
            obj_ = CorrelationId.factory()
            obj_.build(child_)
            self.correlationId = obj_
            obj_.original_tagname_ = 'correlationId'
        elif nodeName_ == 'sequenceNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'sequenceNumber')
            self.sequenceNumber = ival_
        elif nodeName_ == 'reason':
            obj_ = Reason.factory()
            obj_.build(child_)
            self.reason.append(obj_)
            obj_.original_tagname_ = 'reason'
        elif nodeName_ == 'additionalData':
            obj_ = AdditionalData.factory()
            obj_.build(child_)
            self.additionalData = obj_
            obj_.original_tagname_ = 'additionalData'
        super(Exception, self).buildChildren(child_, node, nodeName_, True)
# end class Exception


class TouchRateObservation(TriggerRateObservation):
    """Cloned from exercise but looks like some bits are extraneous like
    payment"""
    member_data_items_ = {
        'exerciseSide': MemberSpec_('exerciseSide', ['ExerciseSideEnum', 'Token', 'xsd:token'], 0),
        'settlementType': MemberSpec_('settlementType', ['SettlementTypeEnum', 'Token', 'xsd:token'], 0),
        'cashSettlement': MemberSpec_('cashSettlement', 'SimplePayment', 0),
        'physicalSettlement': MemberSpec_('physicalSettlement', 'PhysicalSettlement', 0),
        'payment': MemberSpec_('payment', 'NonNegativePayment', 0),
        'clearingInstructions': MemberSpec_('clearingInstructions', 'ClearingInstructions', 0),
        'isExercisable': MemberSpec_('isExercisable', 'xsd:boolean', 0),
    }
    subclass = None
    superclass = TriggerRateObservation
    def __init__(self, observationDate=None, observationTime=None, informationSource=None, triggerRate=None, quotedCurrencyPair=None, observedRate=None, triggerPrice=None, observedPrice=None, triggerCondition=None, exerciseSide=None, settlementType=None, cashSettlement=None, physicalSettlement=None, payment=None, clearingInstructions=None, isExercisable=None):
        self.original_tagname_ = None
        super(TouchRateObservation, self).__init__(observationDate, observationTime, informationSource, triggerRate, quotedCurrencyPair, observedRate, triggerPrice, observedPrice, triggerCondition, )
        self.exerciseSide = exerciseSide
        self.validate_ExerciseSideEnum(self.exerciseSide)
        self.settlementType = settlementType
        self.validate_SettlementTypeEnum(self.settlementType)
        self.cashSettlement = cashSettlement
        self.physicalSettlement = physicalSettlement
        self.payment = payment
        self.clearingInstructions = clearingInstructions
        self.isExercisable = isExercisable
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TouchRateObservation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TouchRateObservation.subclass:
            return TouchRateObservation.subclass(*args_, **kwargs_)
        else:
            return TouchRateObservation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_exerciseSide(self): return self.exerciseSide
    def set_exerciseSide(self, exerciseSide): self.exerciseSide = exerciseSide
    def get_settlementType(self): return self.settlementType
    def set_settlementType(self, settlementType): self.settlementType = settlementType
    def get_cashSettlement(self): return self.cashSettlement
    def set_cashSettlement(self, cashSettlement): self.cashSettlement = cashSettlement
    def get_physicalSettlement(self): return self.physicalSettlement
    def set_physicalSettlement(self, physicalSettlement): self.physicalSettlement = physicalSettlement
    def get_payment(self): return self.payment
    def set_payment(self, payment): self.payment = payment
    def get_clearingInstructions(self): return self.clearingInstructions
    def set_clearingInstructions(self, clearingInstructions): self.clearingInstructions = clearingInstructions
    def get_isExercisable(self): return self.isExercisable
    def set_isExercisable(self, isExercisable): self.isExercisable = isExercisable
    def validate_ExerciseSideEnum(self, value):
        # Validate type ExerciseSideEnum, a restriction on Token.
        pass
    def validate_SettlementTypeEnum(self, value):
        # Validate type SettlementTypeEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Cash', 'Physical', 'Election', 'CashOrPhysical']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SettlementTypeEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on SettlementTypeEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.exerciseSide is not None or
            self.settlementType is not None or
            self.cashSettlement is not None or
            self.physicalSettlement is not None or
            self.payment is not None or
            self.clearingInstructions is not None or
            self.isExercisable is not None or
            super(TouchRateObservation, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TouchRateObservation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TouchRateObservation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TouchRateObservation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TouchRateObservation'):
        super(TouchRateObservation, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TouchRateObservation')
    def exportChildren(self, outfile, level, namespace_='', name_='TouchRateObservation', fromsubclass_=False, pretty_print=True):
        super(TouchRateObservation, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.exerciseSide is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexerciseSide>%s</%sexerciseSide>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.exerciseSide), input_name='exerciseSide')), namespace_, eol_))
        if self.settlementType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssettlementType>%s</%ssettlementType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.settlementType), input_name='settlementType')), namespace_, eol_))
        if self.cashSettlement is not None:
            self.cashSettlement.export(outfile, level, namespace_, name_='cashSettlement', pretty_print=pretty_print)
        if self.physicalSettlement is not None:
            self.physicalSettlement.export(outfile, level, namespace_, name_='physicalSettlement', pretty_print=pretty_print)
        if self.payment is not None:
            self.payment.export(outfile, level, namespace_, name_='payment', pretty_print=pretty_print)
        if self.clearingInstructions is not None:
            self.clearingInstructions.export(outfile, level, namespace_, name_='clearingInstructions', pretty_print=pretty_print)
        if self.isExercisable is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sisExercisable>%s</%sisExercisable>%s' % (namespace_, self.gds_format_boolean(self.isExercisable, input_name='isExercisable'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TouchRateObservation, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'exerciseSide':
            exerciseSide_ = child_.text
            exerciseSide_ = re_.sub(String_cleanup_pat_, " ", exerciseSide_).strip()
            exerciseSide_ = self.gds_validate_string(exerciseSide_, node, 'exerciseSide')
            self.exerciseSide = exerciseSide_
            # validate type ExerciseSideEnum
            self.validate_ExerciseSideEnum(self.exerciseSide)
        elif nodeName_ == 'settlementType':
            settlementType_ = child_.text
            settlementType_ = re_.sub(String_cleanup_pat_, " ", settlementType_).strip()
            settlementType_ = self.gds_validate_string(settlementType_, node, 'settlementType')
            self.settlementType = settlementType_
            # validate type SettlementTypeEnum
            self.validate_SettlementTypeEnum(self.settlementType)
        elif nodeName_ == 'cashSettlement':
            obj_ = SimplePayment.factory()
            obj_.build(child_)
            self.cashSettlement = obj_
            obj_.original_tagname_ = 'cashSettlement'
        elif nodeName_ == 'physicalSettlement':
            obj_ = PhysicalSettlement.factory()
            obj_.build(child_)
            self.physicalSettlement = obj_
            obj_.original_tagname_ = 'physicalSettlement'
        elif nodeName_ == 'payment':
            obj_ = NonNegativePayment.factory()
            obj_.build(child_)
            self.payment = obj_
            obj_.original_tagname_ = 'payment'
        elif nodeName_ == 'clearingInstructions':
            obj_ = ClearingInstructions.factory()
            obj_.build(child_)
            self.clearingInstructions = obj_
            obj_.original_tagname_ = 'clearingInstructions'
        elif nodeName_ == 'isExercisable':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'isExercisable')
            self.isExercisable = ival_
        super(TouchRateObservation, self).buildChildren(child_, node, nodeName_, True)
# end class TouchRateObservation


class KnockOutRateObservation(TriggerRateObservation):
    """Describes an observation that caused a barrier knock out to trigger"""
    member_data_items_ = {
        'rebatePayment': MemberSpec_('rebatePayment', 'NonNegativePayment', 0),
    }
    subclass = None
    superclass = TriggerRateObservation
    def __init__(self, observationDate=None, observationTime=None, informationSource=None, triggerRate=None, quotedCurrencyPair=None, observedRate=None, triggerPrice=None, observedPrice=None, triggerCondition=None, rebatePayment=None):
        self.original_tagname_ = None
        super(KnockOutRateObservation, self).__init__(observationDate, observationTime, informationSource, triggerRate, quotedCurrencyPair, observedRate, triggerPrice, observedPrice, triggerCondition, )
        self.rebatePayment = rebatePayment
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KnockOutRateObservation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KnockOutRateObservation.subclass:
            return KnockOutRateObservation.subclass(*args_, **kwargs_)
        else:
            return KnockOutRateObservation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rebatePayment(self): return self.rebatePayment
    def set_rebatePayment(self, rebatePayment): self.rebatePayment = rebatePayment
    def hasContent_(self):
        if (
            self.rebatePayment is not None or
            super(KnockOutRateObservation, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='KnockOutRateObservation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KnockOutRateObservation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='KnockOutRateObservation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='KnockOutRateObservation'):
        super(KnockOutRateObservation, self).exportAttributes(outfile, level, already_processed, namespace_, name_='KnockOutRateObservation')
    def exportChildren(self, outfile, level, namespace_='', name_='KnockOutRateObservation', fromsubclass_=False, pretty_print=True):
        super(KnockOutRateObservation, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.rebatePayment is not None:
            self.rebatePayment.export(outfile, level, namespace_, name_='rebatePayment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(KnockOutRateObservation, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'rebatePayment':
            obj_ = NonNegativePayment.factory()
            obj_.build(child_)
            self.rebatePayment = obj_
            obj_.original_tagname_ = 'rebatePayment'
        super(KnockOutRateObservation, self).buildChildren(child_, node, nodeName_, True)
# end class KnockOutRateObservation


class BasketChangeEvent(ChangeEvent):
    """A structure indicating that the basket underlyer of the trade has
    changed due to client trading activity"""
    member_data_items_ = {
    }
    subclass = None
    superclass = ChangeEvent
    def __init__(self, eventIdentifier=None):
        self.original_tagname_ = None
        super(BasketChangeEvent, self).__init__(eventIdentifier, )
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BasketChangeEvent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BasketChangeEvent.subclass:
            return BasketChangeEvent.subclass(*args_, **kwargs_)
        else:
            return BasketChangeEvent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(BasketChangeEvent, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BasketChangeEvent', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BasketChangeEvent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BasketChangeEvent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BasketChangeEvent'):
        super(BasketChangeEvent, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BasketChangeEvent')
    def exportChildren(self, outfile, level, namespace_='', name_='BasketChangeEvent', fromsubclass_=False, pretty_print=True):
        super(BasketChangeEvent, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(BasketChangeEvent, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(BasketChangeEvent, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BasketChangeEvent


class UnderlyerInterestLeg(DirectionalLeg):
    """A type describing interest payments associated with and underlyer,
    such as financing"""
    member_data_items_ = {
        'fixedRate': MemberSpec_('fixedRate', 'xsd:decimal', 0),
        'spreadSchedule': MemberSpec_('spreadSchedule', 'SpreadSchedule', 1),
    }
    subclass = None
    superclass = DirectionalLeg
    def __init__(self, id=None, legIdentifier=None, payerPartyReference=None, payerAccountReference=None, receiverPartyReference=None, receiverAccountReference=None, effectiveDate=None, terminationDate=None, fixedRate=None, spreadSchedule=None):
        self.original_tagname_ = None
        super(UnderlyerInterestLeg, self).__init__(id, legIdentifier, payerPartyReference, payerAccountReference, receiverPartyReference, receiverAccountReference, effectiveDate, terminationDate, )
        self.fixedRate = fixedRate
        if spreadSchedule is None:
            self.spreadSchedule = []
        else:
            self.spreadSchedule = spreadSchedule
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UnderlyerInterestLeg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UnderlyerInterestLeg.subclass:
            return UnderlyerInterestLeg.subclass(*args_, **kwargs_)
        else:
            return UnderlyerInterestLeg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fixedRate(self): return self.fixedRate
    def set_fixedRate(self, fixedRate): self.fixedRate = fixedRate
    def get_spreadSchedule(self): return self.spreadSchedule
    def set_spreadSchedule(self, spreadSchedule): self.spreadSchedule = spreadSchedule
    def add_spreadSchedule(self, value): self.spreadSchedule.append(value)
    def insert_spreadSchedule_at(self, index, value): self.spreadSchedule.insert(index, value)
    def replace_spreadSchedule_at(self, index, value): self.spreadSchedule[index] = value
    def hasContent_(self):
        if (
            self.fixedRate is not None or
            self.spreadSchedule or
            super(UnderlyerInterestLeg, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='UnderlyerInterestLeg', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UnderlyerInterestLeg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='UnderlyerInterestLeg', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UnderlyerInterestLeg'):
        super(UnderlyerInterestLeg, self).exportAttributes(outfile, level, already_processed, namespace_, name_='UnderlyerInterestLeg')
    def exportChildren(self, outfile, level, namespace_='', name_='UnderlyerInterestLeg', fromsubclass_=False, pretty_print=True):
        super(UnderlyerInterestLeg, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.fixedRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfixedRate>%s</%sfixedRate>%s' % (namespace_, self.gds_format_float(self.fixedRate, input_name='fixedRate'), namespace_, eol_))
        for spreadSchedule_ in self.spreadSchedule:
            spreadSchedule_.export(outfile, level, namespace_, name_='spreadSchedule', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(UnderlyerInterestLeg, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fixedRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'fixedRate')
            self.fixedRate = fval_
        elif nodeName_ == 'spreadSchedule':
            obj_ = SpreadSchedule.factory()
            obj_.build(child_)
            self.spreadSchedule.append(obj_)
            obj_.original_tagname_ = 'spreadSchedule'
        super(UnderlyerInterestLeg, self).buildChildren(child_, node, nodeName_, True)
# end class UnderlyerInterestLeg


class RelativeDateOffset(Offset):
    """A type defining a date (referred to as the derived date) as a
    relative offset from another date (referred to as the anchor
    date). If the anchor date is itself an adjustable date then the
    offset is assumed to be calculated from the adjusted anchor
    date. A number of different scenarios can be supported, namely;
    1) the derived date may simply be a number of calendar periods
    (days, weeks, months or years) preceding or following the anchor
    date; 2) the unadjusted derived date may be a number of calendar
    periods (days, weeks, months or years) preceding or following
    the anchor date with the resulting unadjusted derived date
    subject to adjustment in accordance with a specified business
    day convention, i.e. the derived date must fall on a good
    business day; 3) the derived date may be a number of business
    days preceding or following the anchor date. Note that the
    businessDayConvention specifies any required adjustment to the
    unadjusted derived date. A negative or positive value in the
    periodMultiplier indicates whether the unadjusted derived
    precedes or follows the anchor date. The businessDayConvention
    should contain a value NONE if the day type element contains a
    value of Business (since specifying a negative or positive
    business days offset would already guarantee that the derived
    date would fall on a good business day in the specified business
    centers)."""
    member_data_items_ = {
        'businessDayConvention': MemberSpec_('businessDayConvention', ['BusinessDayConventionEnum', 'Token', 'xsd:token'], 0),
        'businessCentersReference': MemberSpec_('businessCentersReference', 'BusinessCentersReference', 0),
        'businessCenters': MemberSpec_('businessCenters', 'BusinessCenters', 0),
        'dateRelativeTo': MemberSpec_('dateRelativeTo', 'DateReference', 0),
        'adjustedDate': MemberSpec_('adjustedDate', 'IdentifiedDate', 0),
    }
    subclass = None
    superclass = Offset
    def __init__(self, id=None, periodMultiplier=None, period=None, dayType=None, businessDayConvention=None, businessCentersReference=None, businessCenters=None, dateRelativeTo=None, adjustedDate=None, extensiontype_=None):
        self.original_tagname_ = None
        super(RelativeDateOffset, self).__init__(id, periodMultiplier, period, dayType, extensiontype_, )
        self.businessDayConvention = businessDayConvention
        self.validate_BusinessDayConventionEnum(self.businessDayConvention)
        self.businessCentersReference = businessCentersReference
        self.businessCenters = businessCenters
        self.dateRelativeTo = dateRelativeTo
        self.adjustedDate = adjustedDate
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RelativeDateOffset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RelativeDateOffset.subclass:
            return RelativeDateOffset.subclass(*args_, **kwargs_)
        else:
            return RelativeDateOffset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_businessDayConvention(self): return self.businessDayConvention
    def set_businessDayConvention(self, businessDayConvention): self.businessDayConvention = businessDayConvention
    def get_businessCentersReference(self): return self.businessCentersReference
    def set_businessCentersReference(self, businessCentersReference): self.businessCentersReference = businessCentersReference
    def get_businessCenters(self): return self.businessCenters
    def set_businessCenters(self, businessCenters): self.businessCenters = businessCenters
    def get_dateRelativeTo(self): return self.dateRelativeTo
    def set_dateRelativeTo(self, dateRelativeTo): self.dateRelativeTo = dateRelativeTo
    def get_adjustedDate(self): return self.adjustedDate
    def set_adjustedDate(self, adjustedDate): self.adjustedDate = adjustedDate
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_BusinessDayConventionEnum(self, value):
        # Validate type BusinessDayConventionEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FOLLOWING', 'FRN', 'MODFOLLOWING', 'PRECEDING', 'MODPRECEDING', 'NEAREST', 'NONE', 'NotApplicable']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on BusinessDayConventionEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on BusinessDayConventionEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.businessDayConvention is not None or
            self.businessCentersReference is not None or
            self.businessCenters is not None or
            self.dateRelativeTo is not None or
            self.adjustedDate is not None or
            super(RelativeDateOffset, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RelativeDateOffset', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RelativeDateOffset')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RelativeDateOffset', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RelativeDateOffset'):
        super(RelativeDateOffset, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RelativeDateOffset')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='RelativeDateOffset', fromsubclass_=False, pretty_print=True):
        super(RelativeDateOffset, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.businessDayConvention is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbusinessDayConvention>%s</%sbusinessDayConvention>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.businessDayConvention), input_name='businessDayConvention')), namespace_, eol_))
        if self.businessCentersReference is not None:
            self.businessCentersReference.export(outfile, level, namespace_, name_='businessCentersReference', pretty_print=pretty_print)
        if self.businessCenters is not None:
            self.businessCenters.export(outfile, level, namespace_, name_='businessCenters', pretty_print=pretty_print)
        if self.dateRelativeTo is not None:
            self.dateRelativeTo.export(outfile, level, namespace_, name_='dateRelativeTo', pretty_print=pretty_print)
        if self.adjustedDate is not None:
            self.adjustedDate.export(outfile, level, namespace_, name_='adjustedDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(RelativeDateOffset, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'businessDayConvention':
            businessDayConvention_ = child_.text
            businessDayConvention_ = re_.sub(String_cleanup_pat_, " ", businessDayConvention_).strip()
            businessDayConvention_ = self.gds_validate_string(businessDayConvention_, node, 'businessDayConvention')
            self.businessDayConvention = businessDayConvention_
            # validate type BusinessDayConventionEnum
            self.validate_BusinessDayConventionEnum(self.businessDayConvention)
        elif nodeName_ == 'businessCentersReference':
            obj_ = BusinessCentersReference.factory()
            obj_.build(child_)
            self.businessCentersReference = obj_
            obj_.original_tagname_ = 'businessCentersReference'
        elif nodeName_ == 'businessCenters':
            obj_ = BusinessCenters.factory()
            obj_.build(child_)
            self.businessCenters = obj_
            obj_.original_tagname_ = 'businessCenters'
        elif nodeName_ == 'dateRelativeTo':
            obj_ = DateReference.factory()
            obj_.build(child_)
            self.dateRelativeTo = obj_
            obj_.original_tagname_ = 'dateRelativeTo'
        elif nodeName_ == 'adjustedDate':
            obj_ = IdentifiedDate.factory()
            obj_.build(child_)
            self.adjustedDate = obj_
            obj_.original_tagname_ = 'adjustedDate'
        super(RelativeDateOffset, self).buildChildren(child_, node, nodeName_, True)
# end class RelativeDateOffset


class FloatingRateCalculation(FloatingRate):
    """A type defining the floating rate and definitions relating to the
    calculation of floating rate amounts."""
    member_data_items_ = {
        'initialRate': MemberSpec_('initialRate', 'xsd:decimal', 0),
        'finalRateRounding': MemberSpec_('finalRateRounding', 'Rounding', 0),
        'averagingMethod': MemberSpec_('averagingMethod', ['AveragingMethodEnum', 'Token', 'xsd:token'], 0),
        'negativeInterestRateTreatment': MemberSpec_('negativeInterestRateTreatment', ['NegativeInterestRateTreatmentEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = FloatingRate
    def __init__(self, id=None, floatingRateIndex=None, indexTenor=None, floatingRateMultiplierSchedule=None, spreadSchedule=None, rateTreatment=None, capRateSchedule=None, floorRateSchedule=None, capFloorStraddle=None, initialRate=None, finalRateRounding=None, averagingMethod=None, negativeInterestRateTreatment=None):
        self.original_tagname_ = None
        super(FloatingRateCalculation, self).__init__(id, floatingRateIndex, indexTenor, floatingRateMultiplierSchedule, spreadSchedule, rateTreatment, capRateSchedule, floorRateSchedule, capFloorStraddle, )
        self.initialRate = initialRate
        self.finalRateRounding = finalRateRounding
        self.averagingMethod = averagingMethod
        self.validate_AveragingMethodEnum(self.averagingMethod)
        self.negativeInterestRateTreatment = negativeInterestRateTreatment
        self.validate_NegativeInterestRateTreatmentEnum(self.negativeInterestRateTreatment)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FloatingRateCalculation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FloatingRateCalculation.subclass:
            return FloatingRateCalculation.subclass(*args_, **kwargs_)
        else:
            return FloatingRateCalculation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_initialRate(self): return self.initialRate
    def set_initialRate(self, initialRate): self.initialRate = initialRate
    def get_finalRateRounding(self): return self.finalRateRounding
    def set_finalRateRounding(self, finalRateRounding): self.finalRateRounding = finalRateRounding
    def get_averagingMethod(self): return self.averagingMethod
    def set_averagingMethod(self, averagingMethod): self.averagingMethod = averagingMethod
    def get_negativeInterestRateTreatment(self): return self.negativeInterestRateTreatment
    def set_negativeInterestRateTreatment(self, negativeInterestRateTreatment): self.negativeInterestRateTreatment = negativeInterestRateTreatment
    def validate_AveragingMethodEnum(self, value):
        # Validate type AveragingMethodEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Unweighted', 'Weighted']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AveragingMethodEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on AveragingMethodEnum' % {"value" : value} )
    def validate_NegativeInterestRateTreatmentEnum(self, value):
        # Validate type NegativeInterestRateTreatmentEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NegativeInterestRateMethod', 'ZeroInterestRateMethod']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on NegativeInterestRateTreatmentEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NegativeInterestRateTreatmentEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.initialRate is not None or
            self.finalRateRounding is not None or
            self.averagingMethod is not None or
            self.negativeInterestRateTreatment is not None or
            super(FloatingRateCalculation, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FloatingRateCalculation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FloatingRateCalculation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FloatingRateCalculation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FloatingRateCalculation'):
        super(FloatingRateCalculation, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FloatingRateCalculation')
    def exportChildren(self, outfile, level, namespace_='', name_='FloatingRateCalculation', fromsubclass_=False, pretty_print=True):
        super(FloatingRateCalculation, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.initialRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinitialRate>%s</%sinitialRate>%s' % (namespace_, self.gds_format_float(self.initialRate, input_name='initialRate'), namespace_, eol_))
        if self.finalRateRounding is not None:
            self.finalRateRounding.export(outfile, level, namespace_, name_='finalRateRounding', pretty_print=pretty_print)
        if self.averagingMethod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saveragingMethod>%s</%saveragingMethod>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.averagingMethod), input_name='averagingMethod')), namespace_, eol_))
        if self.negativeInterestRateTreatment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snegativeInterestRateTreatment>%s</%snegativeInterestRateTreatment>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.negativeInterestRateTreatment), input_name='negativeInterestRateTreatment')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FloatingRateCalculation, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'initialRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'initialRate')
            self.initialRate = fval_
        elif nodeName_ == 'finalRateRounding':
            obj_ = Rounding.factory()
            obj_.build(child_)
            self.finalRateRounding = obj_
            obj_.original_tagname_ = 'finalRateRounding'
        elif nodeName_ == 'averagingMethod':
            averagingMethod_ = child_.text
            averagingMethod_ = re_.sub(String_cleanup_pat_, " ", averagingMethod_).strip()
            averagingMethod_ = self.gds_validate_string(averagingMethod_, node, 'averagingMethod')
            self.averagingMethod = averagingMethod_
            # validate type AveragingMethodEnum
            self.validate_AveragingMethodEnum(self.averagingMethod)
        elif nodeName_ == 'negativeInterestRateTreatment':
            negativeInterestRateTreatment_ = child_.text
            negativeInterestRateTreatment_ = re_.sub(String_cleanup_pat_, " ", negativeInterestRateTreatment_).strip()
            negativeInterestRateTreatment_ = self.gds_validate_string(negativeInterestRateTreatment_, node, 'negativeInterestRateTreatment')
            self.negativeInterestRateTreatment = negativeInterestRateTreatment_
            # validate type NegativeInterestRateTreatmentEnum
            self.validate_NegativeInterestRateTreatmentEnum(self.negativeInterestRateTreatment)
        super(FloatingRateCalculation, self).buildChildren(child_, node, nodeName_, True)
# end class FloatingRateCalculation


class AdjustedRelativeDateOffset(RelativeDateOffset):
    """A type defining a date (referred to as the derived date) as a
    relative offset from another date (referred to as the anchor
    date) plus optional date adjustments."""
    member_data_items_ = {
        'relativeDateAdjustments': MemberSpec_('relativeDateAdjustments', 'BusinessDayAdjustments', 0),
    }
    subclass = None
    superclass = RelativeDateOffset
    def __init__(self, id=None, periodMultiplier=None, period=None, dayType=None, businessDayConvention=None, businessCentersReference=None, businessCenters=None, dateRelativeTo=None, adjustedDate=None, relativeDateAdjustments=None):
        self.original_tagname_ = None
        super(AdjustedRelativeDateOffset, self).__init__(id, periodMultiplier, period, dayType, businessDayConvention, businessCentersReference, businessCenters, dateRelativeTo, adjustedDate, )
        self.relativeDateAdjustments = relativeDateAdjustments
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdjustedRelativeDateOffset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdjustedRelativeDateOffset.subclass:
            return AdjustedRelativeDateOffset.subclass(*args_, **kwargs_)
        else:
            return AdjustedRelativeDateOffset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_relativeDateAdjustments(self): return self.relativeDateAdjustments
    def set_relativeDateAdjustments(self, relativeDateAdjustments): self.relativeDateAdjustments = relativeDateAdjustments
    def hasContent_(self):
        if (
            self.relativeDateAdjustments is not None or
            super(AdjustedRelativeDateOffset, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AdjustedRelativeDateOffset', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdjustedRelativeDateOffset')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AdjustedRelativeDateOffset', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AdjustedRelativeDateOffset'):
        super(AdjustedRelativeDateOffset, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AdjustedRelativeDateOffset')
    def exportChildren(self, outfile, level, namespace_='', name_='AdjustedRelativeDateOffset', fromsubclass_=False, pretty_print=True):
        super(AdjustedRelativeDateOffset, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.relativeDateAdjustments is not None:
            self.relativeDateAdjustments.export(outfile, level, namespace_, name_='relativeDateAdjustments', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AdjustedRelativeDateOffset, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'relativeDateAdjustments':
            obj_ = BusinessDayAdjustments.factory()
            obj_.build(child_)
            self.relativeDateAdjustments = obj_
            obj_.original_tagname_ = 'relativeDateAdjustments'
        super(AdjustedRelativeDateOffset, self).buildChildren(child_, node, nodeName_, True)
# end class AdjustedRelativeDateOffset


class Future(ExchangeTraded):
    """An exchange traded future contract."""
    member_data_items_ = {
        'multiplier': MemberSpec_('multiplier', 'xsd:positiveInteger', 0),
        'futureContractReference': MemberSpec_('futureContractReference', ['String', 'xsd:string'], 0),
        'maturity': MemberSpec_('maturity', 'xsd:date', 0),
        'contractYearMonth': MemberSpec_('contractYearMonth', 'xsd:gYearMonth', 0),
    }
    subclass = None
    superclass = ExchangeTraded
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, relatedExchangeId=None, optionsExchangeId=None, specifiedExchangeId=None, multiplier=None, futureContractReference=None, maturity=None, contractYearMonth=None):
        self.original_tagname_ = None
        super(Future, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, relatedExchangeId, optionsExchangeId, specifiedExchangeId, )
        self.multiplier = multiplier
        self.futureContractReference = futureContractReference
        self.validate_String(self.futureContractReference)
        if isinstance(maturity, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(maturity, '%Y-%m-%d').date()
        else:
            initvalue_ = maturity
        self.maturity = initvalue_
        self.contractYearMonth = contractYearMonth
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Future)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Future.subclass:
            return Future.subclass(*args_, **kwargs_)
        else:
            return Future(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_multiplier(self): return self.multiplier
    def set_multiplier(self, multiplier): self.multiplier = multiplier
    def get_futureContractReference(self): return self.futureContractReference
    def set_futureContractReference(self, futureContractReference): self.futureContractReference = futureContractReference
    def get_maturity(self): return self.maturity
    def set_maturity(self, maturity): self.maturity = maturity
    def get_contractYearMonth(self): return self.contractYearMonth
    def set_contractYearMonth(self, contractYearMonth): self.contractYearMonth = contractYearMonth
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.multiplier is not None or
            self.futureContractReference is not None or
            self.maturity is not None or
            self.contractYearMonth is not None or
            super(Future, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Future', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Future')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Future', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Future'):
        super(Future, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Future')
    def exportChildren(self, outfile, level, namespace_='', name_='Future', fromsubclass_=False, pretty_print=True):
        super(Future, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.multiplier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smultiplier>%s</%smultiplier>%s' % (namespace_, self.gds_format_integer(self.multiplier, input_name='multiplier'), namespace_, eol_))
        if self.futureContractReference is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfutureContractReference>%s</%sfutureContractReference>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.futureContractReference), input_name='futureContractReference')), namespace_, eol_))
        if self.maturity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaturity>%s</%smaturity>%s' % (namespace_, self.gds_format_date(self.maturity, input_name='maturity'), namespace_, eol_))
        if self.contractYearMonth is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scontractYearMonth>%s</%scontractYearMonth>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.contractYearMonth), input_name='contractYearMonth')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Future, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'multiplier':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'multiplier')
            self.multiplier = ival_
        elif nodeName_ == 'futureContractReference':
            futureContractReference_ = child_.text
            futureContractReference_ = self.gds_validate_string(futureContractReference_, node, 'futureContractReference')
            self.futureContractReference = futureContractReference_
            # validate type String
            self.validate_String(self.futureContractReference)
        elif nodeName_ == 'maturity':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.maturity = dval_
        elif nodeName_ == 'contractYearMonth':
            contractYearMonth_ = child_.text
            contractYearMonth_ = self.gds_validate_string(contractYearMonth_, node, 'contractYearMonth')
            self.contractYearMonth = contractYearMonth_
        super(Future, self).buildChildren(child_, node, nodeName_, True)
# end class Future


class ExchangeTradedContract(ExchangeTraded):
    """An exchange traded derivative contract."""
    member_data_items_ = {
        'multiplier': MemberSpec_('multiplier', 'xsd:positiveInteger', 0),
        'contractReference': MemberSpec_('contractReference', ['String', 'xsd:string'], 0),
        'expirationDate': MemberSpec_('expirationDate', 'AdjustableOrRelativeDate', 0),
    }
    subclass = None
    superclass = ExchangeTraded
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, relatedExchangeId=None, optionsExchangeId=None, specifiedExchangeId=None, multiplier=None, contractReference=None, expirationDate=None, extensiontype_=None):
        self.original_tagname_ = None
        super(ExchangeTradedContract, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, relatedExchangeId, optionsExchangeId, specifiedExchangeId, extensiontype_, )
        self.multiplier = multiplier
        self.contractReference = contractReference
        self.validate_String(self.contractReference)
        self.expirationDate = expirationDate
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExchangeTradedContract)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExchangeTradedContract.subclass:
            return ExchangeTradedContract.subclass(*args_, **kwargs_)
        else:
            return ExchangeTradedContract(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_multiplier(self): return self.multiplier
    def set_multiplier(self, multiplier): self.multiplier = multiplier
    def get_contractReference(self): return self.contractReference
    def set_contractReference(self, contractReference): self.contractReference = contractReference
    def get_expirationDate(self): return self.expirationDate
    def set_expirationDate(self, expirationDate): self.expirationDate = expirationDate
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.multiplier is not None or
            self.contractReference is not None or
            self.expirationDate is not None or
            super(ExchangeTradedContract, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExchangeTradedContract', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExchangeTradedContract')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExchangeTradedContract', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExchangeTradedContract'):
        super(ExchangeTradedContract, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ExchangeTradedContract')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='ExchangeTradedContract', fromsubclass_=False, pretty_print=True):
        super(ExchangeTradedContract, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.multiplier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smultiplier>%s</%smultiplier>%s' % (namespace_, self.gds_format_integer(self.multiplier, input_name='multiplier'), namespace_, eol_))
        if self.contractReference is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scontractReference>%s</%scontractReference>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.contractReference), input_name='contractReference')), namespace_, eol_))
        if self.expirationDate is not None:
            self.expirationDate.export(outfile, level, namespace_, name_='expirationDate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ExchangeTradedContract, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'multiplier':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'multiplier')
            self.multiplier = ival_
        elif nodeName_ == 'contractReference':
            contractReference_ = child_.text
            contractReference_ = self.gds_validate_string(contractReference_, node, 'contractReference')
            self.contractReference = contractReference_
            # validate type String
            self.validate_String(self.contractReference)
        elif nodeName_ == 'expirationDate':
            obj_ = AdjustableOrRelativeDate.factory()
            obj_.build(child_)
            self.expirationDate = obj_
            obj_.original_tagname_ = 'expirationDate'
        super(ExchangeTradedContract, self).buildChildren(child_, node, nodeName_, True)
# end class ExchangeTradedContract


class ExchangeTradedCalculatedPrice(ExchangeTraded):
    """Abstract base class for all exchange traded financial products with
    a price which is calculated from exchange traded constituents."""
    member_data_items_ = {
        'constituentExchangeId': MemberSpec_('constituentExchangeId', 'ExchangeId', 1),
    }
    subclass = None
    superclass = ExchangeTraded
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, relatedExchangeId=None, optionsExchangeId=None, specifiedExchangeId=None, constituentExchangeId=None, extensiontype_=None):
        self.original_tagname_ = None
        super(ExchangeTradedCalculatedPrice, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, relatedExchangeId, optionsExchangeId, specifiedExchangeId, extensiontype_, )
        if constituentExchangeId is None:
            self.constituentExchangeId = []
        else:
            self.constituentExchangeId = constituentExchangeId
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExchangeTradedCalculatedPrice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExchangeTradedCalculatedPrice.subclass:
            return ExchangeTradedCalculatedPrice.subclass(*args_, **kwargs_)
        else:
            return ExchangeTradedCalculatedPrice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_constituentExchangeId(self): return self.constituentExchangeId
    def set_constituentExchangeId(self, constituentExchangeId): self.constituentExchangeId = constituentExchangeId
    def add_constituentExchangeId(self, value): self.constituentExchangeId.append(value)
    def insert_constituentExchangeId_at(self, index, value): self.constituentExchangeId.insert(index, value)
    def replace_constituentExchangeId_at(self, index, value): self.constituentExchangeId[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.constituentExchangeId or
            super(ExchangeTradedCalculatedPrice, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExchangeTradedCalculatedPrice', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExchangeTradedCalculatedPrice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExchangeTradedCalculatedPrice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExchangeTradedCalculatedPrice'):
        super(ExchangeTradedCalculatedPrice, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ExchangeTradedCalculatedPrice')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='ExchangeTradedCalculatedPrice', fromsubclass_=False, pretty_print=True):
        super(ExchangeTradedCalculatedPrice, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for constituentExchangeId_ in self.constituentExchangeId:
            constituentExchangeId_.export(outfile, level, namespace_, name_='constituentExchangeId', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ExchangeTradedCalculatedPrice, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'constituentExchangeId':
            obj_ = ExchangeId.factory()
            obj_.build(child_)
            self.constituentExchangeId.append(obj_)
            obj_.original_tagname_ = 'constituentExchangeId'
        super(ExchangeTradedCalculatedPrice, self).buildChildren(child_, node, nodeName_, True)
# end class ExchangeTradedCalculatedPrice


class ConvertibleBond(Bond):
    member_data_items_ = {
        'underlyingEquity': MemberSpec_('underlyingEquity', 'EquityAsset', 0),
        'redemptionDate': MemberSpec_('redemptionDate', 'xsd:date', 0),
    }
    subclass = None
    superclass = Bond
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, issuerName=None, issuerPartyReference=None, seniority=None, couponType=None, couponRate=None, maturity=None, parValue=None, faceAmount=None, paymentFrequency=None, dayCountFraction=None, underlyingEquity=None, redemptionDate=None):
        self.original_tagname_ = None
        super(ConvertibleBond, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, issuerName, issuerPartyReference, seniority, couponType, couponRate, maturity, parValue, faceAmount, paymentFrequency, dayCountFraction, )
        self.underlyingEquity = underlyingEquity
        if isinstance(redemptionDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(redemptionDate, '%Y-%m-%d').date()
        else:
            initvalue_ = redemptionDate
        self.redemptionDate = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConvertibleBond)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConvertibleBond.subclass:
            return ConvertibleBond.subclass(*args_, **kwargs_)
        else:
            return ConvertibleBond(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_underlyingEquity(self): return self.underlyingEquity
    def set_underlyingEquity(self, underlyingEquity): self.underlyingEquity = underlyingEquity
    def get_redemptionDate(self): return self.redemptionDate
    def set_redemptionDate(self, redemptionDate): self.redemptionDate = redemptionDate
    def hasContent_(self):
        if (
            self.underlyingEquity is not None or
            self.redemptionDate is not None or
            super(ConvertibleBond, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ConvertibleBond', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConvertibleBond')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ConvertibleBond', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConvertibleBond'):
        super(ConvertibleBond, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ConvertibleBond')
    def exportChildren(self, outfile, level, namespace_='', name_='ConvertibleBond', fromsubclass_=False, pretty_print=True):
        super(ConvertibleBond, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.underlyingEquity is not None:
            self.underlyingEquity.export(outfile, level, namespace_, name_='underlyingEquity', pretty_print=pretty_print)
        if self.redemptionDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sredemptionDate>%s</%sredemptionDate>%s' % (namespace_, self.gds_format_date(self.redemptionDate, input_name='redemptionDate'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ConvertibleBond, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'underlyingEquity':
            obj_ = EquityAsset.factory()
            obj_.build(child_)
            self.underlyingEquity = obj_
            obj_.original_tagname_ = 'underlyingEquity'
        elif nodeName_ == 'redemptionDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.redemptionDate = dval_
        super(ConvertibleBond, self).buildChildren(child_, node, nodeName_, True)
# end class ConvertibleBond


class ResponseMessage(Message):
    """A type refining the generic message content model to make it
    specific to response messages."""
    member_data_items_ = {
        'header': MemberSpec_('header', 'ResponseMessageHeader', 0),
        'validation': MemberSpec_('validation', 'Validation', 1),
        'parentCorrelationId': MemberSpec_('parentCorrelationId', 'CorrelationId', 0),
        'correlationId': MemberSpec_('correlationId', 'CorrelationId', 0),
        'sequenceNumber': MemberSpec_('sequenceNumber', 'xsd:positiveInteger', 0),
        'onBehalfOf': MemberSpec_('onBehalfOf', 'OnBehalfOf', 1),
    }
    subclass = None
    superclass = Message
    def __init__(self, fpmlVersion=None, expectedBuild=None, actualBuild=None, header=None, validation=None, parentCorrelationId=None, correlationId=None, sequenceNumber=None, onBehalfOf=None, extensiontype_=None):
        self.original_tagname_ = None
        super(ResponseMessage, self).__init__(fpmlVersion, expectedBuild, actualBuild, extensiontype_, )
        self.header = header
        if validation is None:
            self.validation = []
        else:
            self.validation = validation
        self.parentCorrelationId = parentCorrelationId
        self.correlationId = correlationId
        self.sequenceNumber = sequenceNumber
        if onBehalfOf is None:
            self.onBehalfOf = []
        else:
            self.onBehalfOf = onBehalfOf
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResponseMessage)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResponseMessage.subclass:
            return ResponseMessage.subclass(*args_, **kwargs_)
        else:
            return ResponseMessage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_header(self): return self.header
    def set_header(self, header): self.header = header
    def get_validation(self): return self.validation
    def set_validation(self, validation): self.validation = validation
    def add_validation(self, value): self.validation.append(value)
    def insert_validation_at(self, index, value): self.validation.insert(index, value)
    def replace_validation_at(self, index, value): self.validation[index] = value
    def get_parentCorrelationId(self): return self.parentCorrelationId
    def set_parentCorrelationId(self, parentCorrelationId): self.parentCorrelationId = parentCorrelationId
    def get_correlationId(self): return self.correlationId
    def set_correlationId(self, correlationId): self.correlationId = correlationId
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def get_onBehalfOf(self): return self.onBehalfOf
    def set_onBehalfOf(self, onBehalfOf): self.onBehalfOf = onBehalfOf
    def add_onBehalfOf(self, value): self.onBehalfOf.append(value)
    def insert_onBehalfOf_at(self, index, value): self.onBehalfOf.insert(index, value)
    def replace_onBehalfOf_at(self, index, value): self.onBehalfOf[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.header is not None or
            self.validation or
            self.parentCorrelationId is not None or
            self.correlationId is not None or
            self.sequenceNumber is not None or
            self.onBehalfOf or
            super(ResponseMessage, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ResponseMessage', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResponseMessage')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ResponseMessage', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ResponseMessage'):
        super(ResponseMessage, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ResponseMessage')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='ResponseMessage', fromsubclass_=False, pretty_print=True):
        super(ResponseMessage, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.header is not None:
            self.header.export(outfile, level, namespace_, name_='header', pretty_print=pretty_print)
        for validation_ in self.validation:
            validation_.export(outfile, level, namespace_, name_='validation', pretty_print=pretty_print)
        if self.parentCorrelationId is not None:
            self.parentCorrelationId.export(outfile, level, namespace_, name_='parentCorrelationId', pretty_print=pretty_print)
        if self.correlationId is not None:
            self.correlationId.export(outfile, level, namespace_, name_='correlationId', pretty_print=pretty_print)
        if self.sequenceNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssequenceNumber>%s</%ssequenceNumber>%s' % (namespace_, self.gds_format_integer(self.sequenceNumber, input_name='sequenceNumber'), namespace_, eol_))
        for onBehalfOf_ in self.onBehalfOf:
            onBehalfOf_.export(outfile, level, namespace_, name_='onBehalfOf', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ResponseMessage, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'header':
            obj_ = ResponseMessageHeader.factory()
            obj_.build(child_)
            self.header = obj_
            obj_.original_tagname_ = 'header'
        elif nodeName_ == 'validation':
            obj_ = Validation.factory()
            obj_.build(child_)
            self.validation.append(obj_)
            obj_.original_tagname_ = 'validation'
        elif nodeName_ == 'parentCorrelationId':
            obj_ = CorrelationId.factory()
            obj_.build(child_)
            self.parentCorrelationId = obj_
            obj_.original_tagname_ = 'parentCorrelationId'
        elif nodeName_ == 'correlationId':
            obj_ = CorrelationId.factory()
            obj_.build(child_)
            self.correlationId = obj_
            obj_.original_tagname_ = 'correlationId'
        elif nodeName_ == 'sequenceNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'sequenceNumber')
            self.sequenceNumber = ival_
        elif nodeName_ == 'onBehalfOf':
            obj_ = OnBehalfOf.factory()
            obj_.build(child_)
            self.onBehalfOf.append(obj_)
            obj_.original_tagname_ = 'onBehalfOf'
        super(ResponseMessage, self).buildChildren(child_, node, nodeName_, True)
# end class ResponseMessage


class RequestMessage(Message):
    """A type defining the basic content of a message that requests the
    receiver to perform some business operation determined by the
    message type and its content."""
    member_data_items_ = {
        'header': MemberSpec_('header', 'RequestMessageHeader', 0),
        'validation': MemberSpec_('validation', 'Validation', 1),
    }
    subclass = None
    superclass = Message
    def __init__(self, fpmlVersion=None, expectedBuild=None, actualBuild=None, header=None, validation=None, extensiontype_=None):
        self.original_tagname_ = None
        super(RequestMessage, self).__init__(fpmlVersion, expectedBuild, actualBuild, extensiontype_, )
        self.header = header
        if validation is None:
            self.validation = []
        else:
            self.validation = validation
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RequestMessage)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RequestMessage.subclass:
            return RequestMessage.subclass(*args_, **kwargs_)
        else:
            return RequestMessage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_header(self): return self.header
    def set_header(self, header): self.header = header
    def get_validation(self): return self.validation
    def set_validation(self, validation): self.validation = validation
    def add_validation(self, value): self.validation.append(value)
    def insert_validation_at(self, index, value): self.validation.insert(index, value)
    def replace_validation_at(self, index, value): self.validation[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.header is not None or
            self.validation or
            super(RequestMessage, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RequestMessage', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RequestMessage')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RequestMessage', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RequestMessage'):
        super(RequestMessage, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RequestMessage')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='RequestMessage', fromsubclass_=False, pretty_print=True):
        super(RequestMessage, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.header is not None:
            self.header.export(outfile, level, namespace_, name_='header', pretty_print=pretty_print)
        for validation_ in self.validation:
            validation_.export(outfile, level, namespace_, name_='validation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(RequestMessage, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'header':
            obj_ = RequestMessageHeader.factory()
            obj_.build(child_)
            self.header = obj_
            obj_.original_tagname_ = 'header'
        elif nodeName_ == 'validation':
            obj_ = Validation.factory()
            obj_.build(child_)
            self.validation.append(obj_)
            obj_.original_tagname_ = 'validation'
        super(RequestMessage, self).buildChildren(child_, node, nodeName_, True)
# end class RequestMessage


class NotificationMessage(Message):
    """A type defining the basic content for a message sent to inform
    another system that some 'business event' has occured.
    Notifications are not expected to be replied to."""
    member_data_items_ = {
        'header': MemberSpec_('header', 'NotificationMessageHeader', 0),
        'validation': MemberSpec_('validation', 'Validation', 1),
        'parentCorrelationId': MemberSpec_('parentCorrelationId', 'CorrelationId', 0),
        'correlationId': MemberSpec_('correlationId', 'CorrelationId', 0),
        'sequenceNumber': MemberSpec_('sequenceNumber', 'xsd:positiveInteger', 0),
        'onBehalfOf': MemberSpec_('onBehalfOf', 'OnBehalfOf', 1),
    }
    subclass = None
    superclass = Message
    def __init__(self, fpmlVersion=None, expectedBuild=None, actualBuild=None, header=None, validation=None, parentCorrelationId=None, correlationId=None, sequenceNumber=None, onBehalfOf=None, extensiontype_=None):
        self.original_tagname_ = None
        super(NotificationMessage, self).__init__(fpmlVersion, expectedBuild, actualBuild, extensiontype_, )
        self.header = header
        if validation is None:
            self.validation = []
        else:
            self.validation = validation
        self.parentCorrelationId = parentCorrelationId
        self.correlationId = correlationId
        self.sequenceNumber = sequenceNumber
        if onBehalfOf is None:
            self.onBehalfOf = []
        else:
            self.onBehalfOf = onBehalfOf
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NotificationMessage)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NotificationMessage.subclass:
            return NotificationMessage.subclass(*args_, **kwargs_)
        else:
            return NotificationMessage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_header(self): return self.header
    def set_header(self, header): self.header = header
    def get_validation(self): return self.validation
    def set_validation(self, validation): self.validation = validation
    def add_validation(self, value): self.validation.append(value)
    def insert_validation_at(self, index, value): self.validation.insert(index, value)
    def replace_validation_at(self, index, value): self.validation[index] = value
    def get_parentCorrelationId(self): return self.parentCorrelationId
    def set_parentCorrelationId(self, parentCorrelationId): self.parentCorrelationId = parentCorrelationId
    def get_correlationId(self): return self.correlationId
    def set_correlationId(self, correlationId): self.correlationId = correlationId
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def get_onBehalfOf(self): return self.onBehalfOf
    def set_onBehalfOf(self, onBehalfOf): self.onBehalfOf = onBehalfOf
    def add_onBehalfOf(self, value): self.onBehalfOf.append(value)
    def insert_onBehalfOf_at(self, index, value): self.onBehalfOf.insert(index, value)
    def replace_onBehalfOf_at(self, index, value): self.onBehalfOf[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.header is not None or
            self.validation or
            self.parentCorrelationId is not None or
            self.correlationId is not None or
            self.sequenceNumber is not None or
            self.onBehalfOf or
            super(NotificationMessage, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NotificationMessage', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NotificationMessage')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NotificationMessage', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NotificationMessage'):
        super(NotificationMessage, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NotificationMessage')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='NotificationMessage', fromsubclass_=False, pretty_print=True):
        super(NotificationMessage, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.header is not None:
            self.header.export(outfile, level, namespace_, name_='header', pretty_print=pretty_print)
        for validation_ in self.validation:
            validation_.export(outfile, level, namespace_, name_='validation', pretty_print=pretty_print)
        if self.parentCorrelationId is not None:
            self.parentCorrelationId.export(outfile, level, namespace_, name_='parentCorrelationId', pretty_print=pretty_print)
        if self.correlationId is not None:
            self.correlationId.export(outfile, level, namespace_, name_='correlationId', pretty_print=pretty_print)
        if self.sequenceNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssequenceNumber>%s</%ssequenceNumber>%s' % (namespace_, self.gds_format_integer(self.sequenceNumber, input_name='sequenceNumber'), namespace_, eol_))
        for onBehalfOf_ in self.onBehalfOf:
            onBehalfOf_.export(outfile, level, namespace_, name_='onBehalfOf', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(NotificationMessage, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'header':
            obj_ = NotificationMessageHeader.factory()
            obj_.build(child_)
            self.header = obj_
            obj_.original_tagname_ = 'header'
        elif nodeName_ == 'validation':
            obj_ = Validation.factory()
            obj_.build(child_)
            self.validation.append(obj_)
            obj_.original_tagname_ = 'validation'
        elif nodeName_ == 'parentCorrelationId':
            obj_ = CorrelationId.factory()
            obj_.build(child_)
            self.parentCorrelationId = obj_
            obj_.original_tagname_ = 'parentCorrelationId'
        elif nodeName_ == 'correlationId':
            obj_ = CorrelationId.factory()
            obj_.build(child_)
            self.correlationId = obj_
            obj_.original_tagname_ = 'correlationId'
        elif nodeName_ == 'sequenceNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'sequenceNumber')
            self.sequenceNumber = ival_
        elif nodeName_ == 'onBehalfOf':
            obj_ = OnBehalfOf.factory()
            obj_.build(child_)
            self.onBehalfOf.append(obj_)
            obj_.original_tagname_ = 'onBehalfOf'
        super(NotificationMessage, self).buildChildren(child_, node, nodeName_, True)
# end class NotificationMessage


class NonCorrectableRequestMessage(RequestMessage):
    """A type defining the content model for a request message that cannot
    be subsequently corrected or retracted."""
    member_data_items_ = {
        'parentCorrelationId': MemberSpec_('parentCorrelationId', 'CorrelationId', 0),
        'correlationId': MemberSpec_('correlationId', 'CorrelationId', 0),
        'sequenceNumber': MemberSpec_('sequenceNumber', 'xsd:positiveInteger', 0),
        'onBehalfOf': MemberSpec_('onBehalfOf', 'OnBehalfOf', 1),
    }
    subclass = None
    superclass = RequestMessage
    def __init__(self, fpmlVersion=None, expectedBuild=None, actualBuild=None, header=None, validation=None, parentCorrelationId=None, correlationId=None, sequenceNumber=None, onBehalfOf=None, extensiontype_=None):
        self.original_tagname_ = None
        super(NonCorrectableRequestMessage, self).__init__(fpmlVersion, expectedBuild, actualBuild, header, validation, extensiontype_, )
        self.parentCorrelationId = parentCorrelationId
        self.correlationId = correlationId
        self.sequenceNumber = sequenceNumber
        if onBehalfOf is None:
            self.onBehalfOf = []
        else:
            self.onBehalfOf = onBehalfOf
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NonCorrectableRequestMessage)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NonCorrectableRequestMessage.subclass:
            return NonCorrectableRequestMessage.subclass(*args_, **kwargs_)
        else:
            return NonCorrectableRequestMessage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_parentCorrelationId(self): return self.parentCorrelationId
    def set_parentCorrelationId(self, parentCorrelationId): self.parentCorrelationId = parentCorrelationId
    def get_correlationId(self): return self.correlationId
    def set_correlationId(self, correlationId): self.correlationId = correlationId
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def get_onBehalfOf(self): return self.onBehalfOf
    def set_onBehalfOf(self, onBehalfOf): self.onBehalfOf = onBehalfOf
    def add_onBehalfOf(self, value): self.onBehalfOf.append(value)
    def insert_onBehalfOf_at(self, index, value): self.onBehalfOf.insert(index, value)
    def replace_onBehalfOf_at(self, index, value): self.onBehalfOf[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.parentCorrelationId is not None or
            self.correlationId is not None or
            self.sequenceNumber is not None or
            self.onBehalfOf or
            super(NonCorrectableRequestMessage, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NonCorrectableRequestMessage', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NonCorrectableRequestMessage')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NonCorrectableRequestMessage', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NonCorrectableRequestMessage'):
        super(NonCorrectableRequestMessage, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NonCorrectableRequestMessage')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='NonCorrectableRequestMessage', fromsubclass_=False, pretty_print=True):
        super(NonCorrectableRequestMessage, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.parentCorrelationId is not None:
            self.parentCorrelationId.export(outfile, level, namespace_, name_='parentCorrelationId', pretty_print=pretty_print)
        if self.correlationId is not None:
            self.correlationId.export(outfile, level, namespace_, name_='correlationId', pretty_print=pretty_print)
        if self.sequenceNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssequenceNumber>%s</%ssequenceNumber>%s' % (namespace_, self.gds_format_integer(self.sequenceNumber, input_name='sequenceNumber'), namespace_, eol_))
        for onBehalfOf_ in self.onBehalfOf:
            onBehalfOf_.export(outfile, level, namespace_, name_='onBehalfOf', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(NonCorrectableRequestMessage, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'parentCorrelationId':
            obj_ = CorrelationId.factory()
            obj_.build(child_)
            self.parentCorrelationId = obj_
            obj_.original_tagname_ = 'parentCorrelationId'
        elif nodeName_ == 'correlationId':
            obj_ = CorrelationId.factory()
            obj_.build(child_)
            self.correlationId = obj_
            obj_.original_tagname_ = 'correlationId'
        elif nodeName_ == 'sequenceNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'sequenceNumber')
            self.sequenceNumber = ival_
        elif nodeName_ == 'onBehalfOf':
            obj_ = OnBehalfOf.factory()
            obj_.build(child_)
            self.onBehalfOf.append(obj_)
            obj_.original_tagname_ = 'onBehalfOf'
        super(NonCorrectableRequestMessage, self).buildChildren(child_, node, nodeName_, True)
# end class NonCorrectableRequestMessage


class EventStatusResponse(ResponseMessage):
    """A type defining the content model for a message normally generated
    in response to a requestEventStatus request."""
    member_data_items_ = {
        'statusItem': MemberSpec_('statusItem', 'EventStatusItem', 1),
        'party': MemberSpec_('party', 'Party', 1),
        'account': MemberSpec_('account', 'Account', 1),
    }
    subclass = None
    superclass = ResponseMessage
    def __init__(self, fpmlVersion=None, expectedBuild=None, actualBuild=None, header=None, validation=None, parentCorrelationId=None, correlationId=None, sequenceNumber=None, onBehalfOf=None, statusItem=None, party=None, account=None):
        self.original_tagname_ = None
        super(EventStatusResponse, self).__init__(fpmlVersion, expectedBuild, actualBuild, header, validation, parentCorrelationId, correlationId, sequenceNumber, onBehalfOf, )
        if statusItem is None:
            self.statusItem = []
        else:
            self.statusItem = statusItem
        if party is None:
            self.party = []
        else:
            self.party = party
        if account is None:
            self.account = []
        else:
            self.account = account
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EventStatusResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EventStatusResponse.subclass:
            return EventStatusResponse.subclass(*args_, **kwargs_)
        else:
            return EventStatusResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_statusItem(self): return self.statusItem
    def set_statusItem(self, statusItem): self.statusItem = statusItem
    def add_statusItem(self, value): self.statusItem.append(value)
    def insert_statusItem_at(self, index, value): self.statusItem.insert(index, value)
    def replace_statusItem_at(self, index, value): self.statusItem[index] = value
    def get_party(self): return self.party
    def set_party(self, party): self.party = party
    def add_party(self, value): self.party.append(value)
    def insert_party_at(self, index, value): self.party.insert(index, value)
    def replace_party_at(self, index, value): self.party[index] = value
    def get_account(self): return self.account
    def set_account(self, account): self.account = account
    def add_account(self, value): self.account.append(value)
    def insert_account_at(self, index, value): self.account.insert(index, value)
    def replace_account_at(self, index, value): self.account[index] = value
    def hasContent_(self):
        if (
            self.statusItem or
            self.party or
            self.account or
            super(EventStatusResponse, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EventStatusResponse', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EventStatusResponse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EventStatusResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EventStatusResponse'):
        super(EventStatusResponse, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EventStatusResponse')
    def exportChildren(self, outfile, level, namespace_='', name_='EventStatusResponse', fromsubclass_=False, pretty_print=True):
        super(EventStatusResponse, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for statusItem_ in self.statusItem:
            statusItem_.export(outfile, level, namespace_, name_='statusItem', pretty_print=pretty_print)
        for party_ in self.party:
            party_.export(outfile, level, namespace_, name_='party', pretty_print=pretty_print)
        for account_ in self.account:
            account_.export(outfile, level, namespace_, name_='account', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EventStatusResponse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'statusItem':
            obj_ = EventStatusItem.factory()
            obj_.build(child_)
            self.statusItem.append(obj_)
            obj_.original_tagname_ = 'statusItem'
        elif nodeName_ == 'party':
            obj_ = Party.factory()
            obj_.build(child_)
            self.party.append(obj_)
            obj_.original_tagname_ = 'party'
        elif nodeName_ == 'account':
            obj_ = Account.factory()
            obj_.build(child_)
            self.account.append(obj_)
            obj_.original_tagname_ = 'account'
        super(EventStatusResponse, self).buildChildren(child_, node, nodeName_, True)
# end class EventStatusResponse


class CorrectableRequestMessage2(RequestMessage):
    """A type defining the content model for a request message that can be
    subsequently corrected or retracted."""
    member_data_items_ = {
        'isCorrection': MemberSpec_('isCorrection', 'xsd:boolean', 0),
        'parentCorrelationId': MemberSpec_('parentCorrelationId', 'CorrelationId', 0),
        'correlationId': MemberSpec_('correlationId', 'CorrelationId', 0),
        'sequenceNumber': MemberSpec_('sequenceNumber', 'xsd:positiveInteger', 0),
        'onBehalfOf': MemberSpec_('onBehalfOf', 'OnBehalfOf', 1),
    }
    subclass = None
    superclass = RequestMessage
    def __init__(self, fpmlVersion=None, expectedBuild=None, actualBuild=None, header=None, validation=None, isCorrection=None, parentCorrelationId=None, correlationId=None, sequenceNumber=None, onBehalfOf=None):
        self.original_tagname_ = None
        super(CorrectableRequestMessage2, self).__init__(fpmlVersion, expectedBuild, actualBuild, header, validation, )
        self.isCorrection = isCorrection
        self.parentCorrelationId = parentCorrelationId
        self.correlationId = correlationId
        self.sequenceNumber = sequenceNumber
        if onBehalfOf is None:
            self.onBehalfOf = []
        else:
            self.onBehalfOf = onBehalfOf
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CorrectableRequestMessage2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CorrectableRequestMessage2.subclass:
            return CorrectableRequestMessage2.subclass(*args_, **kwargs_)
        else:
            return CorrectableRequestMessage2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_isCorrection(self): return self.isCorrection
    def set_isCorrection(self, isCorrection): self.isCorrection = isCorrection
    def get_parentCorrelationId(self): return self.parentCorrelationId
    def set_parentCorrelationId(self, parentCorrelationId): self.parentCorrelationId = parentCorrelationId
    def get_correlationId(self): return self.correlationId
    def set_correlationId(self, correlationId): self.correlationId = correlationId
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def get_onBehalfOf(self): return self.onBehalfOf
    def set_onBehalfOf(self, onBehalfOf): self.onBehalfOf = onBehalfOf
    def add_onBehalfOf(self, value): self.onBehalfOf.append(value)
    def insert_onBehalfOf_at(self, index, value): self.onBehalfOf.insert(index, value)
    def replace_onBehalfOf_at(self, index, value): self.onBehalfOf[index] = value
    def hasContent_(self):
        if (
            self.isCorrection is not None or
            self.parentCorrelationId is not None or
            self.correlationId is not None or
            self.sequenceNumber is not None or
            self.onBehalfOf or
            super(CorrectableRequestMessage2, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CorrectableRequestMessage2', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CorrectableRequestMessage2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CorrectableRequestMessage2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CorrectableRequestMessage2'):
        super(CorrectableRequestMessage2, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CorrectableRequestMessage2')
    def exportChildren(self, outfile, level, namespace_='', name_='CorrectableRequestMessage2', fromsubclass_=False, pretty_print=True):
        super(CorrectableRequestMessage2, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.isCorrection is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sisCorrection>%s</%sisCorrection>%s' % (namespace_, self.gds_format_boolean(self.isCorrection, input_name='isCorrection'), namespace_, eol_))
        if self.parentCorrelationId is not None:
            self.parentCorrelationId.export(outfile, level, namespace_, name_='parentCorrelationId', pretty_print=pretty_print)
        if self.correlationId is not None:
            self.correlationId.export(outfile, level, namespace_, name_='correlationId', pretty_print=pretty_print)
        if self.sequenceNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssequenceNumber>%s</%ssequenceNumber>%s' % (namespace_, self.gds_format_integer(self.sequenceNumber, input_name='sequenceNumber'), namespace_, eol_))
        for onBehalfOf_ in self.onBehalfOf:
            onBehalfOf_.export(outfile, level, namespace_, name_='onBehalfOf', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CorrectableRequestMessage2, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'isCorrection':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'isCorrection')
            self.isCorrection = ival_
        elif nodeName_ == 'parentCorrelationId':
            obj_ = CorrelationId.factory()
            obj_.build(child_)
            self.parentCorrelationId = obj_
            obj_.original_tagname_ = 'parentCorrelationId'
        elif nodeName_ == 'correlationId':
            obj_ = CorrelationId.factory()
            obj_.build(child_)
            self.correlationId = obj_
            obj_.original_tagname_ = 'correlationId'
        elif nodeName_ == 'sequenceNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'sequenceNumber')
            self.sequenceNumber = ival_
        elif nodeName_ == 'onBehalfOf':
            obj_ = OnBehalfOf.factory()
            obj_.build(child_)
            self.onBehalfOf.append(obj_)
            obj_.original_tagname_ = 'onBehalfOf'
        super(CorrectableRequestMessage2, self).buildChildren(child_, node, nodeName_, True)
# end class CorrectableRequestMessage2


class CorrectableRequestMessage(RequestMessage):
    """A type defining the content model for a request message that can be
    subsequently corrected or retracted."""
    member_data_items_ = {
        'isCorrection': MemberSpec_('isCorrection', 'xsd:boolean', 0),
        'parentCorrelationId': MemberSpec_('parentCorrelationId', 'CorrelationId', 0),
        'correlationId': MemberSpec_('correlationId', 'CorrelationId', 0),
        'sequenceNumber': MemberSpec_('sequenceNumber', 'xsd:positiveInteger', 0),
        'onBehalfOf': MemberSpec_('onBehalfOf', 'OnBehalfOf', 1),
    }
    subclass = None
    superclass = RequestMessage
    def __init__(self, fpmlVersion=None, expectedBuild=None, actualBuild=None, header=None, validation=None, isCorrection=None, parentCorrelationId=None, correlationId=None, sequenceNumber=None, onBehalfOf=None, extensiontype_=None):
        self.original_tagname_ = None
        super(CorrectableRequestMessage, self).__init__(fpmlVersion, expectedBuild, actualBuild, header, validation, extensiontype_, )
        self.isCorrection = isCorrection
        self.parentCorrelationId = parentCorrelationId
        self.correlationId = correlationId
        self.sequenceNumber = sequenceNumber
        if onBehalfOf is None:
            self.onBehalfOf = []
        else:
            self.onBehalfOf = onBehalfOf
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CorrectableRequestMessage)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CorrectableRequestMessage.subclass:
            return CorrectableRequestMessage.subclass(*args_, **kwargs_)
        else:
            return CorrectableRequestMessage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_isCorrection(self): return self.isCorrection
    def set_isCorrection(self, isCorrection): self.isCorrection = isCorrection
    def get_parentCorrelationId(self): return self.parentCorrelationId
    def set_parentCorrelationId(self, parentCorrelationId): self.parentCorrelationId = parentCorrelationId
    def get_correlationId(self): return self.correlationId
    def set_correlationId(self, correlationId): self.correlationId = correlationId
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def get_onBehalfOf(self): return self.onBehalfOf
    def set_onBehalfOf(self, onBehalfOf): self.onBehalfOf = onBehalfOf
    def add_onBehalfOf(self, value): self.onBehalfOf.append(value)
    def insert_onBehalfOf_at(self, index, value): self.onBehalfOf.insert(index, value)
    def replace_onBehalfOf_at(self, index, value): self.onBehalfOf[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.isCorrection is not None or
            self.parentCorrelationId is not None or
            self.correlationId is not None or
            self.sequenceNumber is not None or
            self.onBehalfOf or
            super(CorrectableRequestMessage, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CorrectableRequestMessage', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CorrectableRequestMessage')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CorrectableRequestMessage', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CorrectableRequestMessage'):
        super(CorrectableRequestMessage, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CorrectableRequestMessage')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='CorrectableRequestMessage', fromsubclass_=False, pretty_print=True):
        super(CorrectableRequestMessage, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.isCorrection is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sisCorrection>%s</%sisCorrection>%s' % (namespace_, self.gds_format_boolean(self.isCorrection, input_name='isCorrection'), namespace_, eol_))
        if self.parentCorrelationId is not None:
            self.parentCorrelationId.export(outfile, level, namespace_, name_='parentCorrelationId', pretty_print=pretty_print)
        if self.correlationId is not None:
            self.correlationId.export(outfile, level, namespace_, name_='correlationId', pretty_print=pretty_print)
        if self.sequenceNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssequenceNumber>%s</%ssequenceNumber>%s' % (namespace_, self.gds_format_integer(self.sequenceNumber, input_name='sequenceNumber'), namespace_, eol_))
        for onBehalfOf_ in self.onBehalfOf:
            onBehalfOf_.export(outfile, level, namespace_, name_='onBehalfOf', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(CorrectableRequestMessage, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'isCorrection':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'isCorrection')
            self.isCorrection = ival_
        elif nodeName_ == 'parentCorrelationId':
            obj_ = CorrelationId.factory()
            obj_.build(child_)
            self.parentCorrelationId = obj_
            obj_.original_tagname_ = 'parentCorrelationId'
        elif nodeName_ == 'correlationId':
            obj_ = CorrelationId.factory()
            obj_.build(child_)
            self.correlationId = obj_
            obj_.original_tagname_ = 'correlationId'
        elif nodeName_ == 'sequenceNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'sequenceNumber')
            self.sequenceNumber = ival_
        elif nodeName_ == 'onBehalfOf':
            obj_ = OnBehalfOf.factory()
            obj_.build(child_)
            self.onBehalfOf.append(obj_)
            obj_.original_tagname_ = 'onBehalfOf'
        super(CorrectableRequestMessage, self).buildChildren(child_, node, nodeName_, True)
# end class CorrectableRequestMessage


class Acknowledgement(ResponseMessage):
    member_data_items_ = {
        'originalMessage': MemberSpec_('originalMessage', 'UnprocessedElementWrapper', 0),
        'party': MemberSpec_('party', 'Party', 1),
        'account': MemberSpec_('account', 'Account', 1),
    }
    subclass = None
    superclass = ResponseMessage
    def __init__(self, fpmlVersion=None, expectedBuild=None, actualBuild=None, header=None, validation=None, parentCorrelationId=None, correlationId=None, sequenceNumber=None, onBehalfOf=None, originalMessage=None, party=None, account=None):
        self.original_tagname_ = None
        super(Acknowledgement, self).__init__(fpmlVersion, expectedBuild, actualBuild, header, validation, parentCorrelationId, correlationId, sequenceNumber, onBehalfOf, )
        self.originalMessage = originalMessage
        if party is None:
            self.party = []
        else:
            self.party = party
        if account is None:
            self.account = []
        else:
            self.account = account
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Acknowledgement)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Acknowledgement.subclass:
            return Acknowledgement.subclass(*args_, **kwargs_)
        else:
            return Acknowledgement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_originalMessage(self): return self.originalMessage
    def set_originalMessage(self, originalMessage): self.originalMessage = originalMessage
    def get_party(self): return self.party
    def set_party(self, party): self.party = party
    def add_party(self, value): self.party.append(value)
    def insert_party_at(self, index, value): self.party.insert(index, value)
    def replace_party_at(self, index, value): self.party[index] = value
    def get_account(self): return self.account
    def set_account(self, account): self.account = account
    def add_account(self, value): self.account.append(value)
    def insert_account_at(self, index, value): self.account.insert(index, value)
    def replace_account_at(self, index, value): self.account[index] = value
    def hasContent_(self):
        if (
            self.originalMessage is not None or
            self.party or
            self.account or
            super(Acknowledgement, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Acknowledgement', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Acknowledgement')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Acknowledgement', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Acknowledgement'):
        super(Acknowledgement, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Acknowledgement')
    def exportChildren(self, outfile, level, namespace_='', name_='Acknowledgement', fromsubclass_=False, pretty_print=True):
        super(Acknowledgement, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.originalMessage is not None:
            self.originalMessage.export(outfile, level, namespace_, name_='originalMessage', pretty_print=pretty_print)
        for party_ in self.party:
            party_.export(outfile, level, namespace_, name_='party', pretty_print=pretty_print)
        for account_ in self.account:
            account_.export(outfile, level, namespace_, name_='account', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Acknowledgement, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'originalMessage':
            obj_ = UnprocessedElementWrapper.factory()
            obj_.build(child_)
            self.originalMessage = obj_
            obj_.original_tagname_ = 'originalMessage'
        elif nodeName_ == 'party':
            obj_ = Party.factory()
            obj_.build(child_)
            self.party.append(obj_)
            obj_.original_tagname_ = 'party'
        elif nodeName_ == 'account':
            obj_ = Account.factory()
            obj_.build(child_)
            self.account.append(obj_)
            obj_.original_tagname_ = 'account'
        super(Acknowledgement, self).buildChildren(child_, node, nodeName_, True)
# end class Acknowledgement


class PublicExecutionReportRetracted(NonCorrectableRequestMessage):
    member_data_items_ = {
        'tradePackage': MemberSpec_('tradePackage', 'TradePackage', 0),
        'originatingEvent': MemberSpec_('originatingEvent', 'OriginatingEvent', 0),
        'trade': MemberSpec_('trade', 'Trade', 0),
        'tradingEvent': MemberSpec_('tradingEvent', 'TradingEventSummary', 1),
        'amendment': MemberSpec_('amendment', 'TradeAmendmentContent', 0),
        'increase': MemberSpec_('increase', 'TradeNotionalChange', 0),
        'terminatingEvent': MemberSpec_('terminatingEvent', 'TerminatingEvent', 0),
        'termination': MemberSpec_('termination', 'TradeNotionalChange', 0),
        'novation': MemberSpec_('novation', 'TradeNovationContent', 0),
        'withdrawal': MemberSpec_('withdrawal', 'Withdrawal', 0),
        'primaryAssetClass': MemberSpec_('primaryAssetClass', 'AssetClass', 0),
        'tradeIdentifier': MemberSpec_('tradeIdentifier', 'PartyTradeIdentifier', 0),
        'eventIdentifier': MemberSpec_('eventIdentifier', 'BusinessEventIdentifier', 0),
        'party': MemberSpec_('party', 'Party', 1),
        'account': MemberSpec_('account', 'Account', 1),
    }
    subclass = None
    superclass = NonCorrectableRequestMessage
    def __init__(self, fpmlVersion=None, expectedBuild=None, actualBuild=None, header=None, validation=None, parentCorrelationId=None, correlationId=None, sequenceNumber=None, onBehalfOf=None, tradePackage=None, originatingEvent=None, trade=None, tradingEvent=None, amendment=None, increase=None, terminatingEvent=None, termination=None, novation=None, withdrawal=None, primaryAssetClass=None, tradeIdentifier=None, eventIdentifier=None, party=None, account=None):
        self.original_tagname_ = None
        super(PublicExecutionReportRetracted, self).__init__(fpmlVersion, expectedBuild, actualBuild, header, validation, parentCorrelationId, correlationId, sequenceNumber, onBehalfOf, )
        self.tradePackage = tradePackage
        self.originatingEvent = originatingEvent
        self.trade = trade
        if tradingEvent is None:
            self.tradingEvent = []
        else:
            self.tradingEvent = tradingEvent
        self.amendment = amendment
        self.increase = increase
        self.terminatingEvent = terminatingEvent
        self.termination = termination
        self.novation = novation
        self.withdrawal = withdrawal
        self.primaryAssetClass = primaryAssetClass
        self.tradeIdentifier = tradeIdentifier
        self.eventIdentifier = eventIdentifier
        if party is None:
            self.party = []
        else:
            self.party = party
        if account is None:
            self.account = []
        else:
            self.account = account
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PublicExecutionReportRetracted)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PublicExecutionReportRetracted.subclass:
            return PublicExecutionReportRetracted.subclass(*args_, **kwargs_)
        else:
            return PublicExecutionReportRetracted(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tradePackage(self): return self.tradePackage
    def set_tradePackage(self, tradePackage): self.tradePackage = tradePackage
    def get_originatingEvent(self): return self.originatingEvent
    def set_originatingEvent(self, originatingEvent): self.originatingEvent = originatingEvent
    def get_trade(self): return self.trade
    def set_trade(self, trade): self.trade = trade
    def get_tradingEvent(self): return self.tradingEvent
    def set_tradingEvent(self, tradingEvent): self.tradingEvent = tradingEvent
    def add_tradingEvent(self, value): self.tradingEvent.append(value)
    def insert_tradingEvent_at(self, index, value): self.tradingEvent.insert(index, value)
    def replace_tradingEvent_at(self, index, value): self.tradingEvent[index] = value
    def get_amendment(self): return self.amendment
    def set_amendment(self, amendment): self.amendment = amendment
    def get_increase(self): return self.increase
    def set_increase(self, increase): self.increase = increase
    def get_terminatingEvent(self): return self.terminatingEvent
    def set_terminatingEvent(self, terminatingEvent): self.terminatingEvent = terminatingEvent
    def get_termination(self): return self.termination
    def set_termination(self, termination): self.termination = termination
    def get_novation(self): return self.novation
    def set_novation(self, novation): self.novation = novation
    def get_withdrawal(self): return self.withdrawal
    def set_withdrawal(self, withdrawal): self.withdrawal = withdrawal
    def get_primaryAssetClass(self): return self.primaryAssetClass
    def set_primaryAssetClass(self, primaryAssetClass): self.primaryAssetClass = primaryAssetClass
    def get_tradeIdentifier(self): return self.tradeIdentifier
    def set_tradeIdentifier(self, tradeIdentifier): self.tradeIdentifier = tradeIdentifier
    def get_eventIdentifier(self): return self.eventIdentifier
    def set_eventIdentifier(self, eventIdentifier): self.eventIdentifier = eventIdentifier
    def get_party(self): return self.party
    def set_party(self, party): self.party = party
    def add_party(self, value): self.party.append(value)
    def insert_party_at(self, index, value): self.party.insert(index, value)
    def replace_party_at(self, index, value): self.party[index] = value
    def get_account(self): return self.account
    def set_account(self, account): self.account = account
    def add_account(self, value): self.account.append(value)
    def insert_account_at(self, index, value): self.account.insert(index, value)
    def replace_account_at(self, index, value): self.account[index] = value
    def hasContent_(self):
        if (
            self.tradePackage is not None or
            self.originatingEvent is not None or
            self.trade is not None or
            self.tradingEvent or
            self.amendment is not None or
            self.increase is not None or
            self.terminatingEvent is not None or
            self.termination is not None or
            self.novation is not None or
            self.withdrawal is not None or
            self.primaryAssetClass is not None or
            self.tradeIdentifier is not None or
            self.eventIdentifier is not None or
            self.party or
            self.account or
            super(PublicExecutionReportRetracted, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PublicExecutionReportRetracted', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PublicExecutionReportRetracted')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PublicExecutionReportRetracted', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PublicExecutionReportRetracted'):
        super(PublicExecutionReportRetracted, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PublicExecutionReportRetracted')
    def exportChildren(self, outfile, level, namespace_='', name_='PublicExecutionReportRetracted', fromsubclass_=False, pretty_print=True):
        super(PublicExecutionReportRetracted, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tradePackage is not None:
            self.tradePackage.export(outfile, level, namespace_, name_='tradePackage', pretty_print=pretty_print)
        if self.originatingEvent is not None:
            self.originatingEvent.export(outfile, level, namespace_, name_='originatingEvent', pretty_print=pretty_print)
        if self.trade is not None:
            self.trade.export(outfile, level, namespace_, name_='trade', pretty_print=pretty_print)
        for tradingEvent_ in self.tradingEvent:
            tradingEvent_.export(outfile, level, namespace_, name_='tradingEvent', pretty_print=pretty_print)
        if self.amendment is not None:
            self.amendment.export(outfile, level, namespace_, name_='amendment', pretty_print=pretty_print)
        if self.increase is not None:
            self.increase.export(outfile, level, namespace_, name_='increase', pretty_print=pretty_print)
        if self.terminatingEvent is not None:
            self.terminatingEvent.export(outfile, level, namespace_, name_='terminatingEvent', pretty_print=pretty_print)
        if self.termination is not None:
            self.termination.export(outfile, level, namespace_, name_='termination', pretty_print=pretty_print)
        if self.novation is not None:
            self.novation.export(outfile, level, namespace_, name_='novation', pretty_print=pretty_print)
        if self.withdrawal is not None:
            self.withdrawal.export(outfile, level, namespace_, name_='withdrawal', pretty_print=pretty_print)
        if self.primaryAssetClass is not None:
            self.primaryAssetClass.export(outfile, level, namespace_, name_='primaryAssetClass', pretty_print=pretty_print)
        if self.tradeIdentifier is not None:
            self.tradeIdentifier.export(outfile, level, namespace_, name_='tradeIdentifier', pretty_print=pretty_print)
        if self.eventIdentifier is not None:
            self.eventIdentifier.export(outfile, level, namespace_, name_='eventIdentifier', pretty_print=pretty_print)
        for party_ in self.party:
            party_.export(outfile, level, namespace_, name_='party', pretty_print=pretty_print)
        for account_ in self.account:
            account_.export(outfile, level, namespace_, name_='account', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PublicExecutionReportRetracted, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tradePackage':
            obj_ = TradePackage.factory()
            obj_.build(child_)
            self.tradePackage = obj_
            obj_.original_tagname_ = 'tradePackage'
        elif nodeName_ == 'originatingEvent':
            obj_ = OriginatingEvent.factory()
            obj_.build(child_)
            self.originatingEvent = obj_
            obj_.original_tagname_ = 'originatingEvent'
        elif nodeName_ == 'trade':
            obj_ = Trade.factory()
            obj_.build(child_)
            self.trade = obj_
            obj_.original_tagname_ = 'trade'
        elif nodeName_ == 'tradingEvent':
            obj_ = TradingEventSummary.factory()
            obj_.build(child_)
            self.tradingEvent.append(obj_)
            obj_.original_tagname_ = 'tradingEvent'
        elif nodeName_ == 'amendment':
            obj_ = TradeAmendmentContent.factory()
            obj_.build(child_)
            self.amendment = obj_
            obj_.original_tagname_ = 'amendment'
        elif nodeName_ == 'increase':
            obj_ = TradeNotionalChange.factory()
            obj_.build(child_)
            self.increase = obj_
            obj_.original_tagname_ = 'increase'
        elif nodeName_ == 'terminatingEvent':
            obj_ = TerminatingEvent.factory()
            obj_.build(child_)
            self.terminatingEvent = obj_
            obj_.original_tagname_ = 'terminatingEvent'
        elif nodeName_ == 'termination':
            obj_ = TradeNotionalChange.factory()
            obj_.build(child_)
            self.termination = obj_
            obj_.original_tagname_ = 'termination'
        elif nodeName_ == 'novation':
            obj_ = TradeNovationContent.factory()
            obj_.build(child_)
            self.novation = obj_
            obj_.original_tagname_ = 'novation'
        elif nodeName_ == 'withdrawal':
            obj_ = Withdrawal.factory()
            obj_.build(child_)
            self.withdrawal = obj_
            obj_.original_tagname_ = 'withdrawal'
        elif nodeName_ == 'primaryAssetClass':
            obj_ = AssetClass.factory()
            obj_.build(child_)
            self.primaryAssetClass = obj_
            obj_.original_tagname_ = 'primaryAssetClass'
        elif nodeName_ == 'tradeIdentifier':
            obj_ = PartyTradeIdentifier.factory()
            obj_.build(child_)
            self.tradeIdentifier = obj_
            obj_.original_tagname_ = 'tradeIdentifier'
        elif nodeName_ == 'eventIdentifier':
            obj_ = BusinessEventIdentifier.factory()
            obj_.build(child_)
            self.eventIdentifier = obj_
            obj_.original_tagname_ = 'eventIdentifier'
        elif nodeName_ == 'party':
            obj_ = Party.factory()
            obj_.build(child_)
            self.party.append(obj_)
            obj_.original_tagname_ = 'party'
        elif nodeName_ == 'account':
            obj_ = Account.factory()
            obj_.build(child_)
            self.account.append(obj_)
            obj_.original_tagname_ = 'account'
        super(PublicExecutionReportRetracted, self).buildChildren(child_, node, nodeName_, True)
# end class PublicExecutionReportRetracted


class PublicExecutionReport(CorrectableRequestMessage):
    member_data_items_ = {
        'tradePackage': MemberSpec_('tradePackage', 'TradePackage', 0),
        'originatingEvent': MemberSpec_('originatingEvent', 'OriginatingEvent', 0),
        'trade': MemberSpec_('trade', 'Trade', 0),
        'tradingEvent': MemberSpec_('tradingEvent', 'TradingEventSummary', 1),
        'amendment': MemberSpec_('amendment', 'TradeAmendmentContent', 0),
        'increase': MemberSpec_('increase', 'TradeNotionalChange', 0),
        'terminatingEvent': MemberSpec_('terminatingEvent', 'TerminatingEvent', 0),
        'termination': MemberSpec_('termination', 'TradeNotionalChange', 0),
        'novation': MemberSpec_('novation', 'TradeNovationContent', 0),
        'withdrawal': MemberSpec_('withdrawal', 'Withdrawal', 0),
        'quote': MemberSpec_('quote', 'BasicQuotation', 1),
        'party': MemberSpec_('party', 'Party', 1),
        'account': MemberSpec_('account', 'Account', 1),
    }
    subclass = None
    superclass = CorrectableRequestMessage
    def __init__(self, fpmlVersion=None, expectedBuild=None, actualBuild=None, header=None, validation=None, isCorrection=None, parentCorrelationId=None, correlationId=None, sequenceNumber=None, onBehalfOf=None, tradePackage=None, originatingEvent=None, trade=None, tradingEvent=None, amendment=None, increase=None, terminatingEvent=None, termination=None, novation=None, withdrawal=None, quote=None, party=None, account=None):
        self.original_tagname_ = None
        super(PublicExecutionReport, self).__init__(fpmlVersion, expectedBuild, actualBuild, header, validation, isCorrection, parentCorrelationId, correlationId, sequenceNumber, onBehalfOf, )
        self.tradePackage = tradePackage
        self.originatingEvent = originatingEvent
        self.trade = trade
        if tradingEvent is None:
            self.tradingEvent = []
        else:
            self.tradingEvent = tradingEvent
        self.amendment = amendment
        self.increase = increase
        self.terminatingEvent = terminatingEvent
        self.termination = termination
        self.novation = novation
        self.withdrawal = withdrawal
        if quote is None:
            self.quote = []
        else:
            self.quote = quote
        if party is None:
            self.party = []
        else:
            self.party = party
        if account is None:
            self.account = []
        else:
            self.account = account
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PublicExecutionReport)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PublicExecutionReport.subclass:
            return PublicExecutionReport.subclass(*args_, **kwargs_)
        else:
            return PublicExecutionReport(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tradePackage(self): return self.tradePackage
    def set_tradePackage(self, tradePackage): self.tradePackage = tradePackage
    def get_originatingEvent(self): return self.originatingEvent
    def set_originatingEvent(self, originatingEvent): self.originatingEvent = originatingEvent
    def get_trade(self): return self.trade
    def set_trade(self, trade): self.trade = trade
    def get_tradingEvent(self): return self.tradingEvent
    def set_tradingEvent(self, tradingEvent): self.tradingEvent = tradingEvent
    def add_tradingEvent(self, value): self.tradingEvent.append(value)
    def insert_tradingEvent_at(self, index, value): self.tradingEvent.insert(index, value)
    def replace_tradingEvent_at(self, index, value): self.tradingEvent[index] = value
    def get_amendment(self): return self.amendment
    def set_amendment(self, amendment): self.amendment = amendment
    def get_increase(self): return self.increase
    def set_increase(self, increase): self.increase = increase
    def get_terminatingEvent(self): return self.terminatingEvent
    def set_terminatingEvent(self, terminatingEvent): self.terminatingEvent = terminatingEvent
    def get_termination(self): return self.termination
    def set_termination(self, termination): self.termination = termination
    def get_novation(self): return self.novation
    def set_novation(self, novation): self.novation = novation
    def get_withdrawal(self): return self.withdrawal
    def set_withdrawal(self, withdrawal): self.withdrawal = withdrawal
    def get_quote(self): return self.quote
    def set_quote(self, quote): self.quote = quote
    def add_quote(self, value): self.quote.append(value)
    def insert_quote_at(self, index, value): self.quote.insert(index, value)
    def replace_quote_at(self, index, value): self.quote[index] = value
    def get_party(self): return self.party
    def set_party(self, party): self.party = party
    def add_party(self, value): self.party.append(value)
    def insert_party_at(self, index, value): self.party.insert(index, value)
    def replace_party_at(self, index, value): self.party[index] = value
    def get_account(self): return self.account
    def set_account(self, account): self.account = account
    def add_account(self, value): self.account.append(value)
    def insert_account_at(self, index, value): self.account.insert(index, value)
    def replace_account_at(self, index, value): self.account[index] = value
    def hasContent_(self):
        if (
            self.tradePackage is not None or
            self.originatingEvent is not None or
            self.trade is not None or
            self.tradingEvent or
            self.amendment is not None or
            self.increase is not None or
            self.terminatingEvent is not None or
            self.termination is not None or
            self.novation is not None or
            self.withdrawal is not None or
            self.quote or
            self.party or
            self.account or
            super(PublicExecutionReport, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PublicExecutionReport', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PublicExecutionReport')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PublicExecutionReport', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PublicExecutionReport'):
        super(PublicExecutionReport, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PublicExecutionReport')
    def exportChildren(self, outfile, level, namespace_='', name_='PublicExecutionReport', fromsubclass_=False, pretty_print=True):
        super(PublicExecutionReport, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tradePackage is not None:
            self.tradePackage.export(outfile, level, namespace_, name_='tradePackage', pretty_print=pretty_print)
        if self.originatingEvent is not None:
            self.originatingEvent.export(outfile, level, namespace_, name_='originatingEvent', pretty_print=pretty_print)
        if self.trade is not None:
            self.trade.export(outfile, level, namespace_, name_='trade', pretty_print=pretty_print)
        for tradingEvent_ in self.tradingEvent:
            tradingEvent_.export(outfile, level, namespace_, name_='tradingEvent', pretty_print=pretty_print)
        if self.amendment is not None:
            self.amendment.export(outfile, level, namespace_, name_='amendment', pretty_print=pretty_print)
        if self.increase is not None:
            self.increase.export(outfile, level, namespace_, name_='increase', pretty_print=pretty_print)
        if self.terminatingEvent is not None:
            self.terminatingEvent.export(outfile, level, namespace_, name_='terminatingEvent', pretty_print=pretty_print)
        if self.termination is not None:
            self.termination.export(outfile, level, namespace_, name_='termination', pretty_print=pretty_print)
        if self.novation is not None:
            self.novation.export(outfile, level, namespace_, name_='novation', pretty_print=pretty_print)
        if self.withdrawal is not None:
            self.withdrawal.export(outfile, level, namespace_, name_='withdrawal', pretty_print=pretty_print)
        for quote_ in self.quote:
            quote_.export(outfile, level, namespace_, name_='quote', pretty_print=pretty_print)
        for party_ in self.party:
            party_.export(outfile, level, namespace_, name_='party', pretty_print=pretty_print)
        for account_ in self.account:
            account_.export(outfile, level, namespace_, name_='account', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PublicExecutionReport, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tradePackage':
            obj_ = TradePackage.factory()
            obj_.build(child_)
            self.tradePackage = obj_
            obj_.original_tagname_ = 'tradePackage'
        elif nodeName_ == 'originatingEvent':
            obj_ = OriginatingEvent.factory()
            obj_.build(child_)
            self.originatingEvent = obj_
            obj_.original_tagname_ = 'originatingEvent'
        elif nodeName_ == 'trade':
            obj_ = Trade.factory()
            obj_.build(child_)
            self.trade = obj_
            obj_.original_tagname_ = 'trade'
        elif nodeName_ == 'tradingEvent':
            obj_ = TradingEventSummary.factory()
            obj_.build(child_)
            self.tradingEvent.append(obj_)
            obj_.original_tagname_ = 'tradingEvent'
        elif nodeName_ == 'amendment':
            obj_ = TradeAmendmentContent.factory()
            obj_.build(child_)
            self.amendment = obj_
            obj_.original_tagname_ = 'amendment'
        elif nodeName_ == 'increase':
            obj_ = TradeNotionalChange.factory()
            obj_.build(child_)
            self.increase = obj_
            obj_.original_tagname_ = 'increase'
        elif nodeName_ == 'terminatingEvent':
            obj_ = TerminatingEvent.factory()
            obj_.build(child_)
            self.terminatingEvent = obj_
            obj_.original_tagname_ = 'terminatingEvent'
        elif nodeName_ == 'termination':
            obj_ = TradeNotionalChange.factory()
            obj_.build(child_)
            self.termination = obj_
            obj_.original_tagname_ = 'termination'
        elif nodeName_ == 'novation':
            obj_ = TradeNovationContent.factory()
            obj_.build(child_)
            self.novation = obj_
            obj_.original_tagname_ = 'novation'
        elif nodeName_ == 'withdrawal':
            obj_ = Withdrawal.factory()
            obj_.build(child_)
            self.withdrawal = obj_
            obj_.original_tagname_ = 'withdrawal'
        elif nodeName_ == 'quote':
            obj_ = BasicQuotation.factory()
            obj_.build(child_)
            self.quote.append(obj_)
            obj_.original_tagname_ = 'quote'
        elif nodeName_ == 'party':
            obj_ = Party.factory()
            obj_.build(child_)
            self.party.append(obj_)
            obj_.original_tagname_ = 'party'
        elif nodeName_ == 'account':
            obj_ = Account.factory()
            obj_.build(child_)
            self.account.append(obj_)
            obj_.original_tagname_ = 'account'
        super(PublicExecutionReport, self).buildChildren(child_, node, nodeName_, True)
# end class PublicExecutionReport


class RelativeDates(RelativeDateOffset):
    """A type describing a set of dates defined as relative to another set
    of dates."""
    member_data_items_ = {
        'periodSkip': MemberSpec_('periodSkip', 'xsd:positiveInteger', 0),
        'scheduleBounds': MemberSpec_('scheduleBounds', 'DateRange', 0),
    }
    subclass = None
    superclass = RelativeDateOffset
    def __init__(self, id=None, periodMultiplier=None, period=None, dayType=None, businessDayConvention=None, businessCentersReference=None, businessCenters=None, dateRelativeTo=None, adjustedDate=None, periodSkip=None, scheduleBounds=None):
        self.original_tagname_ = None
        super(RelativeDates, self).__init__(id, periodMultiplier, period, dayType, businessDayConvention, businessCentersReference, businessCenters, dateRelativeTo, adjustedDate, )
        self.periodSkip = periodSkip
        self.scheduleBounds = scheduleBounds
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RelativeDates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RelativeDates.subclass:
            return RelativeDates.subclass(*args_, **kwargs_)
        else:
            return RelativeDates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_periodSkip(self): return self.periodSkip
    def set_periodSkip(self, periodSkip): self.periodSkip = periodSkip
    def get_scheduleBounds(self): return self.scheduleBounds
    def set_scheduleBounds(self, scheduleBounds): self.scheduleBounds = scheduleBounds
    def hasContent_(self):
        if (
            self.periodSkip is not None or
            self.scheduleBounds is not None or
            super(RelativeDates, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RelativeDates', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RelativeDates')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RelativeDates', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RelativeDates'):
        super(RelativeDates, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RelativeDates')
    def exportChildren(self, outfile, level, namespace_='', name_='RelativeDates', fromsubclass_=False, pretty_print=True):
        super(RelativeDates, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.periodSkip is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%speriodSkip>%s</%speriodSkip>%s' % (namespace_, self.gds_format_integer(self.periodSkip, input_name='periodSkip'), namespace_, eol_))
        if self.scheduleBounds is not None:
            self.scheduleBounds.export(outfile, level, namespace_, name_='scheduleBounds', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RelativeDates, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'periodSkip':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'periodSkip')
            self.periodSkip = ival_
        elif nodeName_ == 'scheduleBounds':
            class_obj_ = self.get_class_obj_(child_, DateRange)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.scheduleBounds = obj_
            obj_.original_tagname_ = 'scheduleBounds'
        super(RelativeDates, self).buildChildren(child_, node, nodeName_, True)
# end class RelativeDates


class Index(ExchangeTradedCalculatedPrice):
    """A published index whose price depends on exchange traded
    constituents."""
    member_data_items_ = {
        'futureId': MemberSpec_('futureId', 'FutureId', 0),
    }
    subclass = None
    superclass = ExchangeTradedCalculatedPrice
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, relatedExchangeId=None, optionsExchangeId=None, specifiedExchangeId=None, constituentExchangeId=None, futureId=None):
        self.original_tagname_ = None
        super(Index, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, relatedExchangeId, optionsExchangeId, specifiedExchangeId, constituentExchangeId, )
        self.futureId = futureId
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Index)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Index.subclass:
            return Index.subclass(*args_, **kwargs_)
        else:
            return Index(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_futureId(self): return self.futureId
    def set_futureId(self, futureId): self.futureId = futureId
    def hasContent_(self):
        if (
            self.futureId is not None or
            super(Index, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Index', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Index')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Index', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Index'):
        super(Index, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Index')
    def exportChildren(self, outfile, level, namespace_='', name_='Index', fromsubclass_=False, pretty_print=True):
        super(Index, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.futureId is not None:
            self.futureId.export(outfile, level, namespace_, name_='futureId', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Index, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'futureId':
            obj_ = FutureId.factory()
            obj_.build(child_)
            self.futureId = obj_
            obj_.original_tagname_ = 'futureId'
        super(Index, self).buildChildren(child_, node, nodeName_, True)
# end class Index


class ExchangeTradedOption(ExchangeTradedContract):
    """An exchange traded option."""
    member_data_items_ = {
        'strike': MemberSpec_('strike', 'xsd:decimal', 0),
        'optionType': MemberSpec_('optionType', ['PutCallEnum', 'Token', 'xsd:token'], 0),
    }
    subclass = None
    superclass = ExchangeTradedContract
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, relatedExchangeId=None, optionsExchangeId=None, specifiedExchangeId=None, multiplier=None, contractReference=None, expirationDate=None, strike=None, optionType=None):
        self.original_tagname_ = None
        super(ExchangeTradedOption, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, relatedExchangeId, optionsExchangeId, specifiedExchangeId, multiplier, contractReference, expirationDate, )
        self.strike = strike
        self.optionType = optionType
        self.validate_PutCallEnum(self.optionType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExchangeTradedOption)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExchangeTradedOption.subclass:
            return ExchangeTradedOption.subclass(*args_, **kwargs_)
        else:
            return ExchangeTradedOption(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_strike(self): return self.strike
    def set_strike(self, strike): self.strike = strike
    def get_optionType(self): return self.optionType
    def set_optionType(self, optionType): self.optionType = optionType
    def validate_PutCallEnum(self, value):
        # Validate type PutCallEnum, a restriction on Token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Put', 'Call']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PutCallEnum' % {"value" : value.encode("utf-8")} )
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on PutCallEnum' % {"value" : value} )
    def hasContent_(self):
        if (
            self.strike is not None or
            self.optionType is not None or
            super(ExchangeTradedOption, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExchangeTradedOption', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExchangeTradedOption')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExchangeTradedOption', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExchangeTradedOption'):
        super(ExchangeTradedOption, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ExchangeTradedOption')
    def exportChildren(self, outfile, level, namespace_='', name_='ExchangeTradedOption', fromsubclass_=False, pretty_print=True):
        super(ExchangeTradedOption, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.strike is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstrike>%s</%sstrike>%s' % (namespace_, self.gds_format_float(self.strike, input_name='strike'), namespace_, eol_))
        if self.optionType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soptionType>%s</%soptionType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.optionType), input_name='optionType')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ExchangeTradedOption, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'strike':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'strike')
            self.strike = fval_
        elif nodeName_ == 'optionType':
            optionType_ = child_.text
            optionType_ = re_.sub(String_cleanup_pat_, " ", optionType_).strip()
            optionType_ = self.gds_validate_string(optionType_, node, 'optionType')
            self.optionType = optionType_
            # validate type PutCallEnum
            self.validate_PutCallEnum(self.optionType)
        super(ExchangeTradedOption, self).buildChildren(child_, node, nodeName_, True)
# end class ExchangeTradedOption


class ExchangeTradedFund(ExchangeTradedCalculatedPrice):
    """An exchange traded fund whose price depends on exchange traded
    constituents."""
    member_data_items_ = {
        'fundManager': MemberSpec_('fundManager', ['String', 'xsd:string'], 0),
    }
    subclass = None
    superclass = ExchangeTradedCalculatedPrice
    def __init__(self, id=None, instrumentId=None, description=None, currency=None, exchangeId=None, clearanceSystem=None, definition=None, relatedExchangeId=None, optionsExchangeId=None, specifiedExchangeId=None, constituentExchangeId=None, fundManager=None):
        self.original_tagname_ = None
        super(ExchangeTradedFund, self).__init__(id, instrumentId, description, currency, exchangeId, clearanceSystem, definition, relatedExchangeId, optionsExchangeId, specifiedExchangeId, constituentExchangeId, )
        self.fundManager = fundManager
        self.validate_String(self.fundManager)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExchangeTradedFund)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExchangeTradedFund.subclass:
            return ExchangeTradedFund.subclass(*args_, **kwargs_)
        else:
            return ExchangeTradedFund(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fundManager(self): return self.fundManager
    def set_fundManager(self, fundManager): self.fundManager = fundManager
    def validate_String(self, value):
        # Validate type String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on String' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.fundManager is not None or
            super(ExchangeTradedFund, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExchangeTradedFund', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExchangeTradedFund')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExchangeTradedFund', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExchangeTradedFund'):
        super(ExchangeTradedFund, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ExchangeTradedFund')
    def exportChildren(self, outfile, level, namespace_='', name_='ExchangeTradedFund', fromsubclass_=False, pretty_print=True):
        super(ExchangeTradedFund, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.fundManager is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfundManager>%s</%sfundManager>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.fundManager), input_name='fundManager')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ExchangeTradedFund, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fundManager':
            fundManager_ = child_.text
            fundManager_ = self.gds_validate_string(fundManager_, node, 'fundManager')
            self.fundManager = fundManager_
            # validate type String
            self.validate_String(self.fundManager)
        super(ExchangeTradedFund, self).buildChildren(child_, node, nodeName_, True)
# end class ExchangeTradedFund


class VerificationStatusNotification(NonCorrectableRequestMessage):
    member_data_items_ = {
        'status': MemberSpec_('status', 'VerificationStatus', 0),
        'reason': MemberSpec_('reason', 'Reason', 1),
        'partyTradeIdentifier': MemberSpec_('partyTradeIdentifier', 'PartyTradeIdentifier', 0),
        'party': MemberSpec_('party', 'Party', 1),
        'account': MemberSpec_('account', 'Account', 1),
    }
    subclass = None
    superclass = NonCorrectableRequestMessage
    def __init__(self, fpmlVersion=None, expectedBuild=None, actualBuild=None, header=None, validation=None, parentCorrelationId=None, correlationId=None, sequenceNumber=None, onBehalfOf=None, status=None, reason=None, partyTradeIdentifier=None, party=None, account=None):
        self.original_tagname_ = None
        super(VerificationStatusNotification, self).__init__(fpmlVersion, expectedBuild, actualBuild, header, validation, parentCorrelationId, correlationId, sequenceNumber, onBehalfOf, )
        self.status = status
        if reason is None:
            self.reason = []
        else:
            self.reason = reason
        self.partyTradeIdentifier = partyTradeIdentifier
        if party is None:
            self.party = []
        else:
            self.party = party
        if account is None:
            self.account = []
        else:
            self.account = account
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VerificationStatusNotification)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VerificationStatusNotification.subclass:
            return VerificationStatusNotification.subclass(*args_, **kwargs_)
        else:
            return VerificationStatusNotification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_reason(self): return self.reason
    def set_reason(self, reason): self.reason = reason
    def add_reason(self, value): self.reason.append(value)
    def insert_reason_at(self, index, value): self.reason.insert(index, value)
    def replace_reason_at(self, index, value): self.reason[index] = value
    def get_partyTradeIdentifier(self): return self.partyTradeIdentifier
    def set_partyTradeIdentifier(self, partyTradeIdentifier): self.partyTradeIdentifier = partyTradeIdentifier
    def get_party(self): return self.party
    def set_party(self, party): self.party = party
    def add_party(self, value): self.party.append(value)
    def insert_party_at(self, index, value): self.party.insert(index, value)
    def replace_party_at(self, index, value): self.party[index] = value
    def get_account(self): return self.account
    def set_account(self, account): self.account = account
    def add_account(self, value): self.account.append(value)
    def insert_account_at(self, index, value): self.account.insert(index, value)
    def replace_account_at(self, index, value): self.account[index] = value
    def hasContent_(self):
        if (
            self.status is not None or
            self.reason or
            self.partyTradeIdentifier is not None or
            self.party or
            self.account or
            super(VerificationStatusNotification, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VerificationStatusNotification', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VerificationStatusNotification')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VerificationStatusNotification', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VerificationStatusNotification'):
        super(VerificationStatusNotification, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VerificationStatusNotification')
    def exportChildren(self, outfile, level, namespace_='', name_='VerificationStatusNotification', fromsubclass_=False, pretty_print=True):
        super(VerificationStatusNotification, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.status is not None:
            self.status.export(outfile, level, namespace_, name_='status', pretty_print=pretty_print)
        for reason_ in self.reason:
            reason_.export(outfile, level, namespace_, name_='reason', pretty_print=pretty_print)
        if self.partyTradeIdentifier is not None:
            self.partyTradeIdentifier.export(outfile, level, namespace_, name_='partyTradeIdentifier', pretty_print=pretty_print)
        for party_ in self.party:
            party_.export(outfile, level, namespace_, name_='party', pretty_print=pretty_print)
        for account_ in self.account:
            account_.export(outfile, level, namespace_, name_='account', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VerificationStatusNotification, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'status':
            obj_ = VerificationStatus.factory()
            obj_.build(child_)
            self.status = obj_
            obj_.original_tagname_ = 'status'
        elif nodeName_ == 'reason':
            obj_ = Reason.factory()
            obj_.build(child_)
            self.reason.append(obj_)
            obj_.original_tagname_ = 'reason'
        elif nodeName_ == 'partyTradeIdentifier':
            obj_ = PartyTradeIdentifier.factory()
            obj_.build(child_)
            self.partyTradeIdentifier = obj_
            obj_.original_tagname_ = 'partyTradeIdentifier'
        elif nodeName_ == 'party':
            obj_ = Party.factory()
            obj_.build(child_)
            self.party.append(obj_)
            obj_.original_tagname_ = 'party'
        elif nodeName_ == 'account':
            obj_ = Account.factory()
            obj_.build(child_)
            self.account.append(obj_)
            obj_.original_tagname_ = 'account'
        super(VerificationStatusNotification, self).buildChildren(child_, node, nodeName_, True)
# end class VerificationStatusNotification


class ServiceNotification(NotificationMessage):
    """A type defining the content model for a message that allows a
    service to send a notification message to a user of the service."""
    member_data_items_ = {
        'serviceName': MemberSpec_('serviceName', ['NormalizedString', 'xsd:normalizedString'], 0),
        'status': MemberSpec_('status', 'ServiceStatus', 0),
        'processingStatus': MemberSpec_('processingStatus', 'ServiceProcessingStatus', 0),
        'advisory': MemberSpec_('advisory', 'ServiceAdvisory', 0),
    }
    subclass = None
    superclass = NotificationMessage
    def __init__(self, fpmlVersion=None, expectedBuild=None, actualBuild=None, header=None, validation=None, parentCorrelationId=None, correlationId=None, sequenceNumber=None, onBehalfOf=None, serviceName=None, status=None, processingStatus=None, advisory=None):
        self.original_tagname_ = None
        super(ServiceNotification, self).__init__(fpmlVersion, expectedBuild, actualBuild, header, validation, parentCorrelationId, correlationId, sequenceNumber, onBehalfOf, )
        self.serviceName = serviceName
        self.validate_NormalizedString(self.serviceName)
        self.status = status
        self.processingStatus = processingStatus
        self.advisory = advisory
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceNotification)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceNotification.subclass:
            return ServiceNotification.subclass(*args_, **kwargs_)
        else:
            return ServiceNotification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_serviceName(self): return self.serviceName
    def set_serviceName(self, serviceName): self.serviceName = serviceName
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_processingStatus(self): return self.processingStatus
    def set_processingStatus(self, processingStatus): self.processingStatus = processingStatus
    def get_advisory(self): return self.advisory
    def set_advisory(self, advisory): self.advisory = advisory
    def validate_NormalizedString(self, value):
        # Validate type NormalizedString, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NormalizedString' % {"value" : value} )
    def hasContent_(self):
        if (
            self.serviceName is not None or
            self.status is not None or
            self.processingStatus is not None or
            self.advisory is not None or
            super(ServiceNotification, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ServiceNotification', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceNotification')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ServiceNotification', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ServiceNotification'):
        super(ServiceNotification, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceNotification')
    def exportChildren(self, outfile, level, namespace_='', name_='ServiceNotification', fromsubclass_=False, pretty_print=True):
        super(ServiceNotification, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.serviceName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sserviceName>%s</%sserviceName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.serviceName), input_name='serviceName')), namespace_, eol_))
        if self.status is not None:
            self.status.export(outfile, level, namespace_, name_='status', pretty_print=pretty_print)
        if self.processingStatus is not None:
            self.processingStatus.export(outfile, level, namespace_, name_='processingStatus', pretty_print=pretty_print)
        if self.advisory is not None:
            self.advisory.export(outfile, level, namespace_, name_='advisory', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ServiceNotification, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'serviceName':
            serviceName_ = child_.text
            serviceName_ = self.gds_validate_string(serviceName_, node, 'serviceName')
            self.serviceName = serviceName_
            # validate type NormalizedString
            self.validate_NormalizedString(self.serviceName)
        elif nodeName_ == 'status':
            obj_ = ServiceStatus.factory()
            obj_.build(child_)
            self.status = obj_
            obj_.original_tagname_ = 'status'
        elif nodeName_ == 'processingStatus':
            obj_ = ServiceProcessingStatus.factory()
            obj_.build(child_)
            self.processingStatus = obj_
            obj_.original_tagname_ = 'processingStatus'
        elif nodeName_ == 'advisory':
            obj_ = ServiceAdvisory.factory()
            obj_.build(child_)
            self.advisory = obj_
            obj_.original_tagname_ = 'advisory'
        super(ServiceNotification, self).buildChildren(child_, node, nodeName_, True)
# end class ServiceNotification


class RequestRetransmission(NonCorrectableRequestMessage):
    """A message to request that a message be retransmitted. The original
    message will typically be a component of a group of messages,
    such as a portfolio or a report in multiple parts."""
    member_data_items_ = {
        'portfolioReference': MemberSpec_('portfolioReference', 'PortfolioConstituentReference', 0),
        'reportIdentification': MemberSpec_('reportIdentification', 'ReportSectionIdentification', 0),
        'party': MemberSpec_('party', 'Party', 1),
        'account': MemberSpec_('account', 'Account', 1),
    }
    subclass = None
    superclass = NonCorrectableRequestMessage
    def __init__(self, fpmlVersion=None, expectedBuild=None, actualBuild=None, header=None, validation=None, parentCorrelationId=None, correlationId=None, sequenceNumber=None, onBehalfOf=None, portfolioReference=None, reportIdentification=None, party=None, account=None):
        self.original_tagname_ = None
        super(RequestRetransmission, self).__init__(fpmlVersion, expectedBuild, actualBuild, header, validation, parentCorrelationId, correlationId, sequenceNumber, onBehalfOf, )
        self.portfolioReference = portfolioReference
        self.reportIdentification = reportIdentification
        if party is None:
            self.party = []
        else:
            self.party = party
        if account is None:
            self.account = []
        else:
            self.account = account
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RequestRetransmission)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RequestRetransmission.subclass:
            return RequestRetransmission.subclass(*args_, **kwargs_)
        else:
            return RequestRetransmission(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_portfolioReference(self): return self.portfolioReference
    def set_portfolioReference(self, portfolioReference): self.portfolioReference = portfolioReference
    def get_reportIdentification(self): return self.reportIdentification
    def set_reportIdentification(self, reportIdentification): self.reportIdentification = reportIdentification
    def get_party(self): return self.party
    def set_party(self, party): self.party = party
    def add_party(self, value): self.party.append(value)
    def insert_party_at(self, index, value): self.party.insert(index, value)
    def replace_party_at(self, index, value): self.party[index] = value
    def get_account(self): return self.account
    def set_account(self, account): self.account = account
    def add_account(self, value): self.account.append(value)
    def insert_account_at(self, index, value): self.account.insert(index, value)
    def replace_account_at(self, index, value): self.account[index] = value
    def hasContent_(self):
        if (
            self.portfolioReference is not None or
            self.reportIdentification is not None or
            self.party or
            self.account or
            super(RequestRetransmission, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RequestRetransmission', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RequestRetransmission')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RequestRetransmission', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RequestRetransmission'):
        super(RequestRetransmission, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RequestRetransmission')
    def exportChildren(self, outfile, level, namespace_='', name_='RequestRetransmission', fromsubclass_=False, pretty_print=True):
        super(RequestRetransmission, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.portfolioReference is not None:
            self.portfolioReference.export(outfile, level, namespace_, name_='portfolioReference', pretty_print=pretty_print)
        if self.reportIdentification is not None:
            self.reportIdentification.export(outfile, level, namespace_, name_='reportIdentification', pretty_print=pretty_print)
        for party_ in self.party:
            party_.export(outfile, level, namespace_, name_='party', pretty_print=pretty_print)
        for account_ in self.account:
            account_.export(outfile, level, namespace_, name_='account', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RequestRetransmission, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'portfolioReference':
            obj_ = PortfolioConstituentReference.factory()
            obj_.build(child_)
            self.portfolioReference = obj_
            obj_.original_tagname_ = 'portfolioReference'
        elif nodeName_ == 'reportIdentification':
            class_obj_ = self.get_class_obj_(child_, ReportSectionIdentification)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.reportIdentification = obj_
            obj_.original_tagname_ = 'reportIdentification'
        elif nodeName_ == 'party':
            obj_ = Party.factory()
            obj_.build(child_)
            self.party.append(obj_)
            obj_.original_tagname_ = 'party'
        elif nodeName_ == 'account':
            obj_ = Account.factory()
            obj_.build(child_)
            self.account.append(obj_)
            obj_.original_tagname_ = 'account'
        super(RequestRetransmission, self).buildChildren(child_, node, nodeName_, True)
# end class RequestRetransmission


class RequestEventStatus(NonCorrectableRequestMessage):
    """A type defining the content model for a message allowing one party
    to query the status of one event (trade or post-trade event)
    previously sent to another party."""
    member_data_items_ = {
        'businessProcess': MemberSpec_('businessProcess', 'BusinessProcess', 0),
        'eventIdentifier': MemberSpec_('eventIdentifier', 'EventIdentifier', 0),
        'party': MemberSpec_('party', 'Party', 1),
        'account': MemberSpec_('account', 'Account', 1),
    }
    subclass = None
    superclass = NonCorrectableRequestMessage
    def __init__(self, fpmlVersion=None, expectedBuild=None, actualBuild=None, header=None, validation=None, parentCorrelationId=None, correlationId=None, sequenceNumber=None, onBehalfOf=None, businessProcess=None, eventIdentifier=None, party=None, account=None):
        self.original_tagname_ = None
        super(RequestEventStatus, self).__init__(fpmlVersion, expectedBuild, actualBuild, header, validation, parentCorrelationId, correlationId, sequenceNumber, onBehalfOf, )
        self.businessProcess = businessProcess
        self.eventIdentifier = eventIdentifier
        if party is None:
            self.party = []
        else:
            self.party = party
        if account is None:
            self.account = []
        else:
            self.account = account
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RequestEventStatus)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RequestEventStatus.subclass:
            return RequestEventStatus.subclass(*args_, **kwargs_)
        else:
            return RequestEventStatus(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_businessProcess(self): return self.businessProcess
    def set_businessProcess(self, businessProcess): self.businessProcess = businessProcess
    def get_eventIdentifier(self): return self.eventIdentifier
    def set_eventIdentifier(self, eventIdentifier): self.eventIdentifier = eventIdentifier
    def get_party(self): return self.party
    def set_party(self, party): self.party = party
    def add_party(self, value): self.party.append(value)
    def insert_party_at(self, index, value): self.party.insert(index, value)
    def replace_party_at(self, index, value): self.party[index] = value
    def get_account(self): return self.account
    def set_account(self, account): self.account = account
    def add_account(self, value): self.account.append(value)
    def insert_account_at(self, index, value): self.account.insert(index, value)
    def replace_account_at(self, index, value): self.account[index] = value
    def hasContent_(self):
        if (
            self.businessProcess is not None or
            self.eventIdentifier is not None or
            self.party or
            self.account or
            super(RequestEventStatus, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RequestEventStatus', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RequestEventStatus')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RequestEventStatus', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RequestEventStatus'):
        super(RequestEventStatus, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RequestEventStatus')
    def exportChildren(self, outfile, level, namespace_='', name_='RequestEventStatus', fromsubclass_=False, pretty_print=True):
        super(RequestEventStatus, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.businessProcess is not None:
            self.businessProcess.export(outfile, level, namespace_, name_='businessProcess', pretty_print=pretty_print)
        if self.eventIdentifier is not None:
            self.eventIdentifier.export(outfile, level, namespace_, name_='eventIdentifier', pretty_print=pretty_print)
        for party_ in self.party:
            party_.export(outfile, level, namespace_, name_='party', pretty_print=pretty_print)
        for account_ in self.account:
            account_.export(outfile, level, namespace_, name_='account', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RequestEventStatus, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'businessProcess':
            obj_ = BusinessProcess.factory()
            obj_.build(child_)
            self.businessProcess = obj_
            obj_.original_tagname_ = 'businessProcess'
        elif nodeName_ == 'eventIdentifier':
            obj_ = EventIdentifier.factory()
            obj_.build(child_)
            self.eventIdentifier = obj_
            obj_.original_tagname_ = 'eventIdentifier'
        elif nodeName_ == 'party':
            obj_ = Party.factory()
            obj_.build(child_)
            self.party.append(obj_)
            obj_.original_tagname_ = 'party'
        elif nodeName_ == 'account':
            obj_ = Account.factory()
            obj_.build(child_)
            self.account.append(obj_)
            obj_.original_tagname_ = 'account'
        super(RequestEventStatus, self).buildChildren(child_, node, nodeName_, True)
# end class RequestEventStatus


GDSClassesMapping = {
    'CanonicalizationMethod': CanonicalizationMethodType,
    'DSAKeyValue': DSAKeyValueType,
    'DigestMethod': DigestMethodType,
    'KeyInfo': KeyInfoType,
    'KeyValue': KeyValueType,
    'Manifest': ManifestType,
    'Object': ObjectType,
    'PGPData': PGPDataType,
    'RSAKeyValue': RSAKeyValueType,
    'Reference': ReferenceType,
    'RetrievalMethod': RetrievalMethodType,
    'SPKIData': SPKIDataType,
    'Signature': SignatureType,
    'SignatureMethod': SignatureMethodType,
    'SignatureProperties': SignaturePropertiesType,
    'SignatureProperty': SignaturePropertyType,
    'SignatureValue': SignatureValueType,
    'SignedInfo': SignedInfoType,
    'Transform': TransformType,
    'Transforms': TransformsType,
    'X509Data': X509DataType,
    'X509IssuerSerial': X509IssuerSerialType,
    'account': Account,
    'accountBeneficiary': PartyReference,
    'accountId': AccountId,
    'accountName': AccountName,
    'accountReference': AccountReference,
    'accountType': AccountType,
    'accruedInterest': Money,
    'actionOnExpiration': ActionOnExpiration,
    'actionType': ActionType,
    'additionalData': AdditionalData,
    'additionalEvent': AdditionalEvent,
    'address': Address,
    'adjustableDate': AdjustableDate,
    'adjustableDates': AdjustableDates,
    'adjustedDate': IdentifiedDate,
    'advisory': ServiceAdvisory,
    'agency': CreditRatingAgency,
    'agreement': GenericAgreement,
    'algorithm': Algorithm,
    'allocatedNotional': Money,
    'allocatingPartyReference': PartyReference,
    'allocation': Allocation,
    'allocationAccountReference': AccountReference,
    'allocationPartyReference': PartyReference,
    'allocationStatus': AllocationReportingStatus,
    'allocationTradeId': TradeIdentifier,
    'allocations': Allocations,
    'amendedDocument': DocumentReference,
    'amendment': TradeAmendmentContent,
    'americanExercise': AmericanExercise,
    'amount': Money,
    'amountRelativeTo': AmountReference,
    'approval': Approval,
    'approvalId': ApprovalId,
    'approvals': Approvals,
    'approvedPartyReference': PartyReference,
    'approver': PersonId,
    'approvingPartyReference': PartyReference,
    'assetClass': AssetClass,
    'attachment': Resource,
    'automaticExercise': Empty,
    'averageDailyTradingVolume': AverageDailyTradingVolumeLimit,
    'barrierDeterminationAgent': PartyReference,
    'baseCurrency': Currency,
    'basket': Basket,
    'basketAmount': Money,
    'basketChange': BasketChangeEvent,
    'basketConstituent': BasketConstituent,
    'basketCurrency': Currency,
    'basketId': BasketId,
    'basketName': BasketName,
    'beneficiary': Routing,
    'beneficiaryBank': Routing,
    'beneficiaryPartyReference': PartyReference,
    'bermudaExercise': BermudaExercise,
    'bermudaExerciseDates': AdjustableOrRelativeDates,
    'blockTradeId': TradeIdentifier,
    'bond': Bond,
    'borrower': LegalEntity,
    'borrowerReference': LegalEntityReference,
    'brokerConfirmation': BrokerConfirmation,
    'brokerConfirmationType': BrokerConfirmationType,
    'brokerPartyReference': PartyReference,
    'businessCenter': BusinessCenter,
    'businessCenters': BusinessCenters,
    'businessCentersReference': BusinessCentersReference,
    'businessProcess': BusinessProcess,
    'businessUnit': BusinessUnit,
    'businessUnitId': Unit,
    'businessUnitReference': BusinessUnitReference,
    'buyer': IdentifiedPayerReceiver,
    'buyerAccountReference': AccountReference,
    'buyerPartyReference': PartyReference,
    'calculationAgent': CalculationAgent,
    'calculationAgentBusinessCenter': BusinessCenter,
    'calculationAgentPartyReference': PartyReference,
    'calculationEndDate': AdjustableOrRelativeDate,
    'calculationPeriodDatesAdjustments': BusinessDayAdjustments,
    'calculationPeriodFrequency': CalculationPeriodFrequency,
    'calculationStartDate': AdjustableOrRelativeDate,
    'capRateSchedule': StrikeSchedule,
    'cash': Cash,
    'cashSettlement': SimplePayment,
    'cashSettlementReferenceBanks': CashSettlementReferenceBanks,
    'cashflowAmount': Money,
    'cashflowId': CashflowId,
    'cashflowType': CashflowType,
    'category': TradeCategory,
    'change': TradeChangeContent,
    'changeEvent': ChangeEvent,
    'changeInKnownAmount': NonNegativeMoney,
    'changeInNotionalAmount': NonNegativeMoney,
    'changeInNotionalSchedule': NonNegativeAmountSchedule,
    'classification': IndustryClassification,
    'clearanceSystem': ClearanceSystem,
    'clearedDate': IdentifiedDate,
    'clearingInstructions': ClearingInstructions,
    'clearingStatus': ClearingStatusValue,
    'clearingStatusValue': ClearingStatusValue,
    'collateral': Collateral,
    'collateralPortfolio': PortfolioName,
    'collateralValueAllocation': CollateralValueAllocation,
    'collateralizationType': CollateralizationType,
    'commencementDate': AdjustableOrRelativeDate,
    'commission': Commission,
    'commodity': Commodity,
    'commodityBase': CommodityBase,
    'commodityDetails': CommodityDetails,
    'componentReference': ProductReference,
    'compressionType': CompressionType,
    'confirmationMethod': ConfirmationMethod,
    'constituentExchangeId': ExchangeId,
    'constituentWeight': ConstituentWeight,
    'contactInfo': ContactInformation,
    'contractId': ContractId,
    'contractualDefinitions': ContractualDefinitions,
    'contractualDocument': ContractualDocument,
    'contractualMatrix': ContractualMatrix,
    'contractualTermsSupplement': ContractualTermsSupplement,
    'convertibleBond': ConvertibleBond,
    'copyTo': MessageAddress,
    'corporateAction': CorporateActionEvent,
    'correlationId': CorrelationId,
    'correspondentInformation': CorrespondentInformation,
    'correspondentPartyReference': PartyReference,
    'country': CountryCode,
    'couponPayment': PendingPayment,
    'couponType': CouponType,
    'creditChargeAmount': Money,
    'creditDerivativesNotices': CreditDerivativesNotices,
    'creditDocument': CreditDocument,
    'creditEntityReference': LegalEntityReference,
    'creditLimit': CreditLimit,
    'creditNotation': CreditNotation,
    'creditRating': CreditRating,
    'creditSupportAgreement': CreditSupportAgreement,
    'currency': Currency,
    'currency1': Currency,
    'currency2': Currency,
    'currencySpecificDayCount': currencySpecificDayCountType,
    'currencyType': ReportingCurrencyType,
    'curveInstrument': Asset,
    'custodianTerms': CustodianTerms,
    'cycle': ServiceProcessingCycle,
    'dateAdjustments': BusinessDayAdjustments,
    'dateAdjustmentsReference': BusinessDayAdjustmentsReference,
    'dateOffset': DateOffset,
    'dateRelativeTo': DateReference,
    'dayCount': DayCount,
    'dayCountFraction': DayCountFraction,
    'dayCountValue': DayCountDenominator,
    'debt': CreditRatingDebt,
    'debtType': DebtType,
    'defaultDayCount': DayCountDenominator,
    'definition': ProductReference,
    'deliveryDate': AdjustableDate,
    'deliveryDateExpirationConvention': Offset,
    'deliveryDateRollConvention': Offset,
    'deliveryNearby': DeliveryNearby,
    'demandsAndNotices': PartyContactInformation,
    'deposit': Deposit,
    'depositoryPartyReference': PartyReference,
    'determinationMethod': DeterminationMethod,
    'determiningParty': PartyReference,
    'difference': TradeDifference,
    'disputeResolution': DisputeResolution,
    'dividendPayment': PendingPayment,
    'dividendPayout': DividendPayout,
    'documentAmendment': LegalDocumentAdmendment,
    'documentHeader': LegalDocumentHeader,
    'documentHistory': LegalDocumentHistory,
    'documentId': LegalDocumentId,
    'documentIdentity': DocumentIdentity,
    'documentType': LegalDocumentType,
    'documentation': PartyRelationshipDocumentation,
    'earliestExerciseTime': BusinessCenterTime,
    'effectiveDate': IdentifiedDate,
    'electedTransportCurrency': ElectedTransportCurrency,
    'eligibilityToHoldCollateral': EligibilityToHoldCollateral,
    'eligibleAsset': EligibleAsset,
    'eligibleCollateral': EligibleCollateral,
    'eligibleCountry': Country,
    'embeddedOptionType': EmbeddedOptionType,
    'endTerm': Period,
    'endUserExceptionDeclaration': EndUserExceptionDeclaration,
    'endUserExceptionReason': ClearingExceptionReason,
    'entityClassification': EntityClassification,
    'entityId': EntityId,
    'entityName': EntityName,
    'equity': EquityAsset,
    'europeanExercise': EuropeanExercise,
    'event': ServiceProcessingEvent,
    'eventId': EventId,
    'eventIdentifier': EventIdentifier,
    'eventStatusException': Exception,
    'eventStatusResponse': EventStatusResponse,
    'eventType': EventType,
    'exchangeDate': ExchangeDate,
    'exchangeId': ExchangeId,
    'exchangeTradedFund': ExchangeTradedFund,
    'executed': CreditLimitUtilizationPosition,
    'executionDateTime': ExecutionDateTime,
    'executionType': ExecutionType,
    'executionVenueType': ExecutionVenueType,
    'exercise': Exercise,
    'exerciseFee': ExerciseFee,
    'exerciseFeeSchedule': ExerciseFeeSchedule,
    'exerciseInNotionalAmount': Money,
    'exerciseInNotionalSchedule': NonNegativeAmountSchedule,
    'exerciseNotice': ExerciseNotice,
    'exerciseNoticePartyReference': PartyReference,
    'exerciseProcedure': ExerciseProcedureOption,
    'existingCreditSupportAnnex': ExistingCreditSupportAnnex,
    'expirationDate': AdjustableOrRelativeDate,
    'expirationTime': BusinessCenterTime,
    'facilityType': FacilityType,
    'factoredCalculationAmount': Money,
    'feeAmountSchedule': AmountSchedule,
    'feePaymentDate': RelativeDateOffset,
    'feeRateSchedule': Schedule,
    'feeTrade': Trade,
    'feeTradeIdentifier': PartyTradeIdentifier,
    'finalRateRounding': Rounding,
    'firstPeriodStartDate': FirstPeriodStartDate,
    'fixing': FxFixing,
    'fixingDate': AdjustableDate,
    'fixingTime': BusinessCenterTime,
    'floatingRate': FloatingRateIndex,
    'floatingRateCalculation': FloatingRateCalculation,
    'floatingRateIndex': FloatingRateIndex,
    'floatingRateMultiplierSchedule': Schedule,
    'floorRateSchedule': StrikeSchedule,
    'formula': Formula,
    'formulaComponent': FormulaComponent,
    'future': Future,
    'futureId': FutureId,
    'fx': FxRateAsset,
    'fxConversion': FxConversion,
    'fxRate': FxRate,
    'fxSpotRateSource': FxSpotRateSource,
    'governingLaw': GoverningLaw,
    'grossCashflow': GrossCashflow,
    'grossPrice': ActualPrice,
    'groupType': PartyGroupType,
    'header': ResponseMessageHeader,
    'hedgingParty': PartyReference,
    'higherMaturity': Period,
    'holdingAndUsingPostedCollateral': HoldingAndUsingPostedCollateral,
    'holdingPostedCollateral': HoldingPostedCollateral,
    'identifier': CreditSupportAgreementIdentifier,
    'implementationSpecification': ImplementationSpecification,
    'inReplyTo': MessageId,
    'increase': TradeNotionalChange,
    'independentAmount': IndependentAmount,
    'independentAmountDetermination': IndependentAmountDetermination,
    'independentAmountEligibility': IndependentAmountEligibility,
    'independentAmountEligibleCollateral': IndependentAmountEligibleCollateral,
    'independentAmountEligibleCreditSupport': IndependentAmountEligibleCollateral,
    'independentAmountInterestRate': IndependentAmountInterestRate,
    'independentAmounts': IndependentAmounts,
    'index': Index,
    'indexChange': IndexChange,
    'indexTenor': Period,
    'informationSource': InformationSource,
    'initialMarginInterestRateTerms': InitialMarginInterestRateTerms,
    'instrumentId': InstrumentId,
    'instrumentTradeDetails': InstrumentTradeDetails,
    'insurer': LegalEntity,
    'insurerReference': LegalEntityReference,
    'intermediaryInformation': IntermediaryInformation,
    'intermediaryPartyReference': PartyReference,
    'issuer': IssuerId,
    'issuerPartyReference': PartyReference,
    'jurisdiction': GoverningLaw,
    'knockIn': TriggerRateObservation,
    'knockOut': KnockOutRateObservation,
    'knownAmountReference': AmountReference,
    'language': Language,
    'latestExerciseTime': BusinessCenterTime,
    'latestExerciseTimeDetermination': DeterminationMethod,
    'legId': LegId,
    'legIdentifier': LegIdentifier,
    'length': ResourceLength,
    'lien': Lien,
    'limitApplicable': LimitApplicable,
    'limitId': LimitId,
    'limitType': LimitType,
    'linkId': LinkId,
    'loan': Loan,
    'location': TimezoneLocation,
    'lowerBarrier': NoTouchLowerBarrierObservation,
    'lowerMaturity': Period,
    'mandatoryFacilityExecutionExceptionDeclaration': FacilityExecutionExceptionDeclaration,
    'manualExercise': Empty,
    'masterAgreement': MasterAgreement,
    'masterAgreementId': MasterAgreementId,
    'masterAgreementType': MasterAgreementType,
    'masterAgreementVersion': MasterAgreementVersion,
    'masterConfirmation': MasterConfirmation,
    'masterConfirmationAnnexType': MasterConfirmationAnnexType,
    'masterConfirmationType': MasterConfirmationType,
    'matchId': MatchId,
    'math': Math,
    'matrixTerm': MatrixTerm,
    'matrixType': MatrixType,
    'maximumObservedPrice': ObservedPrice,
    'maximumObservedRate': ObservedRate,
    'measureType': AssetMeasureType,
    'messageId': MessageId,
    'messageRejected': Exception,
    'mimeType': MimeType,
    'minimumAssets': Money,
    'minimumObservedPrice': ObservedPrice,
    'minimumObservedRate': ObservedRate,
    'minimumRating': CreditNotations,
    'mortgage': Mortgage,
    'multipleExercise': MultipleExercise,
    'mutualFund': MutualFund,
    'name': LegalDocumentName,
    'netPrice': ActualPrice,
    'newTrade': Trade,
    'newTradeIdentifier': PartyTradeIdentifier,
    'noTouch': NoTouchRateObservation,
    'nominal': Money,
    'nonReliance': Empty,
    'nonstandardSettlementRate': FxInformationSource,
    'notation': CreditRatingNotation,
    'notificationTimeCity': BusinessCenter,
    'notionalAmount': PositiveMoney,
    'notionalAmountReference': NotionalAmountReference,
    'notionalReference': NotionalReference,
    'notionalScheduleReference': NotionalReference,
    'novatedAmount': Money,
    'novation': TradeNovationContent,
    'novationAmount': TradeLegSizeChange,
    'numberOfOptionsReference': NumberOfOptionsReference,
    'numberOfUnitsReference': NumberOfUnitsReference,
    'observationTime': BusinessCenterTime,
    'observedPrice': PositiveMoney,
    'offset': Offset,
    'oldTrade': Trade,
    'oldTradeIdentifier': PartyTradeIdentifier,
    'onBehalfOf': OnBehalfOf,
    'option': ExchangeTradedOption,
    'optionBuyer': PartyReference,
    'optionEvent': OptionEvent,
    'optionExercise': OptionExercise,
    'optionExpiry': OptionExpiry,
    'optionSeller': PartyReference,
    'optionsExchangeId': ExchangeId,
    'orderId': OrderId,
    'orderIdentifier': OrderIdentifier,
    'organizationCharacteristic': OrganizationCharacteristic,
    'organizationType': OrganizationType,
    'originalMessage': UnprocessedElementWrapper,
    'originalTrade': Trade,
    'originatingEvent': OriginatingEvent,
    'originatingPackage': PackageSummary,
    'originatingTradeId': TradeIdentifier,
    'originatingTradeIdentifier': TradeIdentifier,
    'otcClassification': OtcClassification,
    'otherPartyPayment': Payment,
    'otherProvisions': OtherProvisions,
    'otherRemainingParty': PartyReference,
    'otherRemainingPartyAccount': AccountReference,
    'otherTransferee': PartyReference,
    'otherTransfereeAccount': AccountReference,
    'outstandingKnownAmount': NonNegativeMoney,
    'outstandingNotionalAmount': NonNegativeMoney,
    'outstandingNotionalSchedule': NonNegativeAmountSchedule,
    'packageHeader': PackageHeader,
    'packageIdentifier': IssuerTradeId,
    'packageInformation': PackageInformation,
    'packageType': PackageType,
    'parentCorrelationId': CorrelationId,
    'partialExercise': PartialExercise,
    'party': Party,
    'partyDocumentIdentifier': PartyDocumentIdentifier,
    'partyEntityClassification': PartyEntityClassification,
    'partyId': PartyId,
    'partyInformation': PartyTradeInformation,
    'partyMessageInformation': PartyMessageInformation,
    'partyName': PartyName,
    'partyPortfolioName': PartyPortfolioName,
    'partyReference': PartyReference,
    'partyRoles': PartyRoles,
    'partyTradeIdentifier': PartyTradeIdentifier,
    'partyTradeIdentifierReference': PartyTradeIdentifierReference,
    'partyTradeInformation': PartyTradeInformation,
    'payerAccountReference': AccountReference,
    'payerPartyReference': PartyReference,
    'payment': NonNegativePayment,
    'paymentAmount': NonNegativeMoney,
    'paymentDate': AdjustableOrRelativeDate,
    'paymentDetail': PaymentDetail,
    'paymentFrequency': Period,
    'paymentReference': PaymentReference,
    'paymentRule': PaymentRule,
    'paymentType': PaymentType,
    'pending': CreditLimitUtilizationPosition,
    'periodicDates': PeriodicDates,
    'person': Person,
    'personId': PersonId,
    'personReference': PersonReference,
    'physicalSettlement': PhysicalSettlement,
    'pool': AssetPool,
    'portfolio': Portfolio,
    'portfolioName': PortfolioName,
    'portfolioReference': PortfolioConstituentReference,
    'predeterminedClearingOrganizationPartyReference': PartyReference,
    'premiumProductReference': ProductReference,
    'presentValueAmount': Money,
    'price': NonNegativeMoney,
    'priceChange': TradeLegPriceChange,
    'priceReference': Reference,
    'pricing': InstrumentTradePricing,
    'pricingContext': PricingContext,
    'pricingModel': PricingModel,
    'primaryAssetClass': AssetClass,
    'primaryRateSource': InformationSource,
    'principal': InstrumentTradePrincipal,
    'principalAmount': NetAndGross,
    'processingStatus': ServiceProcessingStatus,
    'product': Product,
    'productComponentIdentifier': ProductComponentIdentifier,
    'productId': ProductId,
    'productType': ProductType,
    'publicExecutionReport': PublicExecutionReport,
    'publicExecutionReportAcknowledgement': Acknowledgement,
    'publicExecutionReportException': Exception,
    'publicExecutionReportRetracted': PublicExecutionReportRetracted,
    'publication': CommodityInformationSource,
    'publisher': LegalDocumentPublisher,
    'quantity': InstrumentTradeQuantity,
    'queryParameter': QueryParameter,
    'queryParameterId': QueryParameterId,
    'queryParameterOperator': QueryParameterOperator,
    'quotationCharacteristics': QuotationCharacteristics,
    'quote': BasicQuotation,
    'quoteUnits': PriceQuoteUnits,
    'quotedCurrencyPair': QuotedCurrencyPair,
    'rateIndex': RateIndex,
    'rateReference': RateReference,
    'rateSource': InformationProvider,
    'rateSourceFixing': FxRateSourceFixing,
    'rateSourcePage': RateSourcePage,
    'reason': Reason,
    'reasonCode': ReasonCode,
    'rebatePayment': NonNegativePayment,
    'receiverAccountReference': AccountReference,
    'receiverPartyReference': PartyReference,
    'referenceBank': ReferenceBank,
    'referenceBankId': ReferenceBankId,
    'referenceCurrency': Currency,
    'referenceEntity': LegalEntity,
    'region': Region,
    'registrationNumber': RegulatorId,
    'relatedBusinessUnit': RelatedBusinessUnit,
    'relatedExchangeId': ExchangeId,
    'relatedParty': RelatedParty,
    'relatedPerson': RelatedPerson,
    'relativeDate': RelativeDateOffset,
    'relativeDateAdjustments': BusinessDayAdjustments,
    'relativeDateSequence': RelativeDateSequence,
    'relativeDates': RelativeDates,
    'relevantUnderlyingDate': AdjustableOrRelativeDates,
    'remainingAmount': Money,
    'remainingParty': PartyReference,
    'remainingPartyAccount': AccountReference,
    'replacementTradeId': TradeId,
    'replacementTradeIdentifier': TradeIdentifier,
    'reportId': ReportId,
    'reportIdentification': ReportSectionIdentification,
    'reportingPurpose': ReportingPurpose,
    'reportingRegime': ReportingRegime,
    'reportingRole': ReportingRole,
    'requestEventStatus': RequestEventStatus,
    'requestRetransmission': RequestRetransmission,
    'requestedAction': RequestedWithdrawalAction,
    'requestedClearingAction': RequestedClearingAction,
    'requestedClearingOrganizationPartyReference': PartyReference,
    'resolutionTime': BusinessCenterTime,
    'resourceId': ResourceId,
    'resourceType': ResourceType,
    'resultingTrade': Trade,
    'resultingTradeIdentifier': PartyTradeIdentifier,
    'role': PersonRole,
    'routingAddress': Address,
    'routingExplicitDetails': RoutingExplicitDetails,
    'routingId': RoutingId,
    'routingIds': RoutingIds,
    'routingIdsAndExplicitDetails': RoutingIdsAndExplicitDetails,
    'scale': CreditRatingScale,
    'scheduleBounds': DateRange,
    'secondaryAssetClass': AssetClass,
    'secondaryRateSource': InformationSource,
    'sector': MortgageSector,
    'seller': IdentifiedPayerReceiver,
    'sellerAccountReference': AccountReference,
    'sellerPartyReference': PartyReference,
    'sendTo': MessageAddress,
    'seniority': CreditSeniority,
    'sentBy': MessageAddress,
    'serviceNotification': ServiceNotification,
    'serviceNotificationException': Exception,
    'servicingParty': PartyReference,
    'settlementCurrency': Currency,
    'settlementDate': AdjustableDate,
    'settlementDay': SettlementDay,
    'settlementInformation': SettlementInformation,
    'settlementInstruction': SettlementInstruction,
    'settlementMethod': SettlementMethod,
    'settlementRateOption': SettlementRateOption,
    'settlementRateSource': FxSettlementRateSource,
    'shortSale': ShortSale,
    'simpleCreditDefaultSwap': SimpleCreditDefaultSwap,
    'simpleFra': SimpleFra,
    'simpleIrSwap': SimpleIRSwap,
    'singleUnderlyer': SingleUnderlyer,
    'sizeChange': TradeLegSizeChange,
    'specifiedExchangeId': ExchangeId,
    'specifiedExercise': OptionExerciseAmounts,
    'specifiedRate': SpecifiedRate,
    'splitSettlement': SplitSettlement,
    'splitSettlementAmount': Money,
    'spreadSchedule': SpreadSchedule,
    'standardCsa': StandardCreditSupportAnnexBase,
    'standardCsa2013EnglishLaw': StandardCreditSupportAnnex2013EnglishLaw,
    'standardCsa2013NewYorkLaw': StandardCreditSupportAnnex2013NewYorkLaw,
    'standardCsa2014EnglishLaw': StandardCreditSupportAnnex2014EnglishLaw,
    'standardCsa2014NewYorkLaw': StandardCreditSupportAnnex2014NewYorkLaw,
    'startTerm': Period,
    'status': VerificationStatus,
    'statusAppliesTo': PartyReference,
    'statusItem': EventStatusItem,
    'step': Step,
    'strategy': Strategy,
    'strategyComponentIdentifier': StrategyComponentIdentification,
    'streetAddress': StreetAddress,
    'stubAmount': Money,
    'stubEndDate': AdjustableOrRelativeDate,
    'stubStartDate': AdjustableOrRelativeDate,
    'style': LegalDocumentStyle,
    'supervisorRegistration': SupervisorRegistration,
    'supervisoryBody': SupervisoryBody,
    'telephone': TelephoneNumber,
    'tenor': Period,
    'term': Period,
    'terminatingEvent': TerminatingEvent,
    'termination': TradeNotionalChange,
    'terminationDate': AdjustableOrRelativeDate,
    'time': PrevailingTime,
    'timestamp': TradeTimestamp,
    'timestamps': TradeProcessingTimestamps,
    'timing': QuoteTiming,
    'touch': TouchRateObservation,
    'trade': Trade,
    'tradeDate': IdentifiedDate,
    'tradeHeader': TradeHeader,
    'tradeId': TradeId,
    'tradeIdentifier': TradeIdentifier,
    'tradeIdentifierReference': PartyTradeIdentifierReference,
    'tradeInformation': TradeInformation,
    'tradePackage': TradePackage,
    'tradePartyRelationshipType': PartyRelationshipType,
    'tradeReferenceInformation': TradeReferenceInformation,
    'trader': Trader,
    'tradingEvent': TradingEventSummary,
    'tradingWaiver': TradingWaiver,
    'tranche': UnderlyingAssetTranche,
    'transactionCharacteristic': TransactionCharacteristic,
    'transferee': PartyReference,
    'transfereeAccount': AccountReference,
    'transferor': PartyReference,
    'transferorAccount': AccountReference,
    'transportCurrency': TransportCurrency,
    'triggerPrice': PositiveMoney,
    'type': SpreadScheduleType,
    'unadjustedDate': IdentifiedDate,
    'underlyerCollateral': Collateral,
    'underlyerFinancing': UnderlyerInterestLeg,
    'underlyerLoanRate': UnderlyerLoanRate,
    'underlyerNotional': Money,
    'underlyerPrice': Price,
    'underlyerSpread': SpreadScheduleReference,
    'underlyingAsset': Asset,
    'underlyingEquity': EquityAsset,
    'unit': QuantityUnit,
    'upperBarrier': NoTouchUpperBarrierObservation,
    'useOfPostedCreditSupport': UseOfPostedCreditSupport,
    'utilization': CreditLimitUtilization,
    'validation': Validation,
    'validationRuleId': Validation,
    'valuationDateCity': BusinessCenters,
    'value': Money,
    'velocity': Velocity,
    'verificationMethod': VerificationMethod,
    'verificationStatusAcknowledgement': Acknowledgement,
    'verificationStatusException': Exception,
    'verificationStatusNotification': VerificationStatusNotification,
    'version': AgreementVersion,
    'versionedContractId': VersionedContractId,
    'versionedTradeId': VersionedTradeId,
    'withdrawal': Withdrawal,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'PublicExecutionReport'
        rootClass = PublicExecutionReport
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'PublicExecutionReport'
        rootClass = PublicExecutionReport
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from StringIO import StringIO
    parser = None
    doc = parsexml_(StringIO(inString), parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'PublicExecutionReport'
        rootClass = PublicExecutionReport
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'PublicExecutionReport'
        rootClass = PublicExecutionReport
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from fpml_transparency_processeslib import *\n\n')
        sys.stdout.write('import fpml_transparency_processeslib as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "AbstractEvent",
    "Account",
    "AccountId",
    "AccountName",
    "AccountReference",
    "AccountType",
    "Acknowledgement",
    "ActionOnExpiration",
    "ActionType",
    "ActualPrice",
    "AdditionalData",
    "AdditionalEvent",
    "Address",
    "AdjustableDate",
    "AdjustableDate2",
    "AdjustableDates",
    "AdjustableDatesOrRelativeDateOffset",
    "AdjustableOrAdjustedDate",
    "AdjustableOrRelativeDate",
    "AdjustableOrRelativeDates",
    "AdjustableRelativeOrPeriodicDates",
    "AdjustableRelativeOrPeriodicDates2",
    "AdjustedRelativeDateOffset",
    "AgreementType",
    "AgreementVersion",
    "Algorithm",
    "AlgorithmRole",
    "Allocation",
    "AllocationReportingStatus",
    "Allocations",
    "AmericanExercise",
    "AmountReference",
    "AmountSchedule",
    "AnyAssetReference",
    "Approval",
    "ApprovalId",
    "ApprovalType",
    "Approvals",
    "Asset",
    "AssetClass",
    "AssetMeasureType",
    "AssetPool",
    "AssetReference",
    "AutomaticExercise",
    "AverageDailyTradingVolumeLimit",
    "BasicQuotation",
    "Basket",
    "BasketChangeEvent",
    "BasketConstituent",
    "BasketId",
    "BasketName",
    "Beneficiary",
    "BermudaExercise",
    "Bond",
    "BrokerConfirmation",
    "BrokerConfirmationType",
    "BusinessCenter",
    "BusinessCenterTime",
    "BusinessCenters",
    "BusinessCentersReference",
    "BusinessDateRange",
    "BusinessDayAdjustments",
    "BusinessDayAdjustmentsReference",
    "BusinessEventIdentifier",
    "BusinessProcess",
    "BusinessUnit",
    "BusinessUnitReference",
    "BusinessUnitRole",
    "CalculationAgent",
    "CalculationPeriodFrequency",
    "CanonicalizationMethodType",
    "Cash",
    "CashSettlementReferenceBanks",
    "CashflowId",
    "CashflowNotional",
    "CashflowType",
    "ChangeEvent",
    "ClearanceSystem",
    "ClearingExceptionReason",
    "ClearingInstructions",
    "ClearingStatusItem",
    "ClearingStatusValue",
    "Collateral",
    "CollateralValueAllocation",
    "CollateralizationType",
    "Commission",
    "Commodity",
    "CommodityBase",
    "CommodityBusinessCalendar",
    "CommodityDetails",
    "CommodityInformationProvider",
    "CommodityInformationSource",
    "CompressionActivity",
    "CompressionType",
    "ConfirmationMethod",
    "ConstituentWeight",
    "ContactInformation",
    "ContractId",
    "ContractIdentifier",
    "ContractualDefinitions",
    "ContractualDocument",
    "ContractualMatrix",
    "ContractualSupplement",
    "ContractualTermsSupplement",
    "ConvertibleBond",
    "CorporateActionEvent",
    "CorporateActionType",
    "CorrectableRequestMessage",
    "CorrectableRequestMessage2",
    "CorrelationId",
    "CorrespondentInformation",
    "Country",
    "CountryCode",
    "CouponType",
    "CreditDerivativesNotices",
    "CreditDocument",
    "CreditLimit",
    "CreditLimitBase",
    "CreditLimitInformation",
    "CreditLimitReference",
    "CreditLimitUtilization",
    "CreditLimitUtilizationPosition",
    "CreditNotation",
    "CreditNotations",
    "CreditRating",
    "CreditRatingAgency",
    "CreditRatingDebt",
    "CreditRatingNotation",
    "CreditRatingScale",
    "CreditSeniority",
    "CreditSupportAgreement",
    "CreditSupportAgreementIdentifier",
    "CreditSupportAgreementType",
    "Currency",
    "CustodianTerms",
    "DSAKeyValueType",
    "DataDocument",
    "DateList",
    "DateOffset",
    "DateRange",
    "DateReference",
    "DateTimeList",
    "DayCount",
    "DayCountDenominator",
    "DayCountFraction",
    "DeClear",
    "DebtType",
    "DeclearReason",
    "DeliveryNearby",
    "Deposit",
    "DeterminationMethod",
    "DeterminationMethodReference",
    "DigestMethodType",
    "DirectionalLeg",
    "DisputeResolution",
    "DividendPayout",
    "Document",
    "DocumentIdentity",
    "DocumentReference",
    "Documentation",
    "ElectedTransportCurrency",
    "EligibilityToHoldCollateral",
    "EligibleAsset",
    "EligibleCollateral",
    "EmbeddedOptionType",
    "Empty",
    "EndUserExceptionDeclaration",
    "EntityClassification",
    "EntityId",
    "EntityName",
    "EquityAsset",
    "EuropeanExercise",
    "EventId",
    "EventIdentifier",
    "EventProposedMatch",
    "EventStatus",
    "EventStatusItem",
    "EventStatusResponse",
    "EventType",
    "EventsChoice",
    "Exception",
    "ExceptionMessageHeader",
    "ExchangeDate",
    "ExchangeId",
    "ExchangeTraded",
    "ExchangeTradedCalculatedPrice",
    "ExchangeTradedContract",
    "ExchangeTradedFund",
    "ExchangeTradedOption",
    "ExecutionDateTime",
    "ExecutionType",
    "ExecutionVenueType",
    "Exercise",
    "ExerciseFee",
    "ExerciseFeeSchedule",
    "ExerciseNotice",
    "ExerciseProcedure",
    "ExerciseProcedureOption",
    "ExistingCreditSupportAnnex",
    "FacilityExecutionExceptionDeclaration",
    "FacilityType",
    "FirstPeriodStartDate",
    "FloatingRate",
    "FloatingRateCalculation",
    "FloatingRateIndex",
    "ForecastRateIndex",
    "Formula",
    "FormulaComponent",
    "Frequency",
    "Future",
    "FutureId",
    "FutureValueAmount",
    "FxCashSettlement",
    "FxCashSettlementSimple",
    "FxConversion",
    "FxFixing",
    "FxInformationSource",
    "FxRate",
    "FxRateAsset",
    "FxRateSourceFixing",
    "FxSettlementRateSource",
    "FxSpotRateSource",
    "GenericAgreement",
    "GoverningLaw",
    "GrossCashflow",
    "HoldingAndUsingPostedCollateral",
    "HoldingPostedCollateral",
    "IdentifiedAsset",
    "IdentifiedCurrency",
    "IdentifiedCurrencyReference",
    "IdentifiedDate",
    "IdentifiedPayerReceiver",
    "IdentifiedRate",
    "ImplementationSpecification",
    "ImplementationSpecificationVersion",
    "IndependentAmount",
    "IndependentAmountDetermination",
    "IndependentAmountEligibility",
    "IndependentAmountEligibleCollateral",
    "IndependentAmountInterestRate",
    "IndependentAmounts",
    "Index",
    "IndexChange",
    "IndustryClassification",
    "InformationProvider",
    "InformationSource",
    "InitialMarginInterestRateTerms",
    "InstrumentId",
    "InstrumentTradeDetails",
    "InstrumentTradePricing",
    "InstrumentTradePrincipal",
    "InstrumentTradeQuantity",
    "InterestAccrualsCompoundingMethod",
    "InterestAccrualsMethod",
    "IntermediaryInformation",
    "InterpolationMethod",
    "IssuerId",
    "IssuerTradeId",
    "KeyInfoType",
    "KeyValueType",
    "KnockOutRateObservation",
    "Language",
    "Leg",
    "LegId",
    "LegIdentifier",
    "LegalDocument",
    "LegalDocumentAdmendment",
    "LegalDocumentHeader",
    "LegalDocumentHistory",
    "LegalDocumentId",
    "LegalDocumentIdentity",
    "LegalDocumentName",
    "LegalDocumentPublisher",
    "LegalDocumentStyle",
    "LegalDocumentType",
    "LegalEntity",
    "LegalEntityReference",
    "Lien",
    "LimitApplicable",
    "LimitId",
    "LimitType",
    "LinkId",
    "Loan",
    "MainPublication",
    "ManifestType",
    "ManualExercise",
    "MasterAgreement",
    "MasterAgreementId",
    "MasterAgreementType",
    "MasterAgreementVersion",
    "MasterConfirmation",
    "MasterConfirmationAnnexType",
    "MasterConfirmationType",
    "MatchId",
    "Math",
    "MatrixTerm",
    "MatrixType",
    "Message",
    "MessageAddress",
    "MessageHeader",
    "MessageId",
    "MimeType",
    "Money",
    "MoneyBase",
    "Mortgage",
    "MortgageSector",
    "MultipleExercise",
    "MutualFund",
    "NetAndGross",
    "NoTouchLowerBarrierObservation",
    "NoTouchRateObservation",
    "NoTouchUpperBarrierObservation",
    "NonCorrectableRequestMessage",
    "NonNegativeAmountSchedule",
    "NonNegativeMoney",
    "NonNegativePayment",
    "NonNegativeSchedule",
    "NonNegativeStep",
    "NotificationMessage",
    "NotificationMessageHeader",
    "NotionalAmount",
    "NotionalAmountReference",
    "NotionalReference",
    "NumberOfOptionsReference",
    "NumberOfUnitsReference",
    "ObjectType",
    "ObservationFrequency",
    "ObservedPrice",
    "ObservedRate",
    "Offset",
    "OffsetPrevailingTime",
    "OnBehalfOf",
    "OptionEvent",
    "OptionExercise",
    "OptionExerciseAmounts",
    "OptionExpiry",
    "OptionExpiryBase",
    "OrderId",
    "OrderIdentifier",
    "OrganizationCharacteristic",
    "OrganizationType",
    "OriginatingEvent",
    "OtcClassification",
    "OtherProvisions",
    "PGPDataType",
    "PackageHeader",
    "PackageInformation",
    "PackageSummary",
    "PackageType",
    "PartialExercise",
    "Party",
    "PartyContactInformation",
    "PartyDocumentIdentifier",
    "PartyEntityClassification",
    "PartyGroupType",
    "PartyId",
    "PartyMessageInformation",
    "PartyName",
    "PartyPortfolioName",
    "PartyReference",
    "PartyRelationship",
    "PartyRelationshipDocumentation",
    "PartyRelationshipType",
    "PartyRole",
    "PartyRoleType",
    "PartyRoles",
    "PartyTradeIdentifier",
    "PartyTradeIdentifierReference",
    "PartyTradeIdentifiers",
    "PartyTradeInformation",
    "Payment",
    "PaymentBase",
    "PaymentBaseExtended",
    "PaymentDetail",
    "PaymentDetails",
    "PaymentId",
    "PaymentReference",
    "PaymentRule",
    "PaymentType",
    "PendingPayment",
    "PercentageRule",
    "Period",
    "PeriodicDates",
    "Person",
    "PersonId",
    "PersonReference",
    "PersonRole",
    "PhysicalSettlement",
    "Portfolio",
    "PortfolioConstituentReference",
    "PortfolioName",
    "PortfolioReference",
    "PortfolioReferenceBase",
    "PositiveMoney",
    "PrevailingTime",
    "Price",
    "PriceQuoteUnits",
    "PricingContext",
    "PricingModel",
    "PricingStructure",
    "PricingStructureReference",
    "PrincipalExchanges",
    "ProblemLocation",
    "Product",
    "ProductComponentIdentifier",
    "ProductId",
    "ProductReference",
    "ProductType",
    "ProposedCollateralAllocation",
    "PublicExecutionReport",
    "PublicExecutionReportRetracted",
    "QuantityUnit",
    "QueryParameter",
    "QueryParameterId",
    "QueryParameterOperator",
    "QueryPortfolio",
    "QuotationCharacteristics",
    "QuoteTiming",
    "QuotedCurrencyPair",
    "RSAKeyValueType",
    "Rate",
    "RateIndex",
    "RateObservation",
    "RateReference",
    "RateSourcePage",
    "Reason",
    "ReasonCode",
    "Reference",
    "ReferenceAmount",
    "ReferenceBank",
    "ReferenceBankId",
    "ReferenceType",
    "Region",
    "RegulatorId",
    "RelatedBusinessUnit",
    "RelatedParty",
    "RelatedPerson",
    "RelativeDateOffset",
    "RelativeDateSequence",
    "RelativeDates",
    "ReportId",
    "ReportIdentification",
    "ReportSectionIdentification",
    "ReportingCurrencyType",
    "ReportingPurpose",
    "ReportingRegime",
    "ReportingRegimeIdentifier",
    "ReportingRegimeName",
    "ReportingRole",
    "RequestEventStatus",
    "RequestMessage",
    "RequestMessageHeader",
    "RequestRetransmission",
    "RequestedAction",
    "RequestedClearingAction",
    "RequestedWithdrawalAction",
    "RequiredIdentifierDate",
    "ResetFrequency",
    "Resource",
    "ResourceId",
    "ResourceLength",
    "ResourceType",
    "ResponseMessage",
    "ResponseMessageHeader",
    "RetrievalMethodType",
    "ReturnSwapNotionalAmountReference",
    "Rounding",
    "Routing",
    "RoutingExplicitDetails",
    "RoutingId",
    "RoutingIds",
    "RoutingIdsAndExplicitDetails",
    "SPKIDataType",
    "Schedule",
    "ScheduleReference",
    "ServiceAdvisory",
    "ServiceAdvisoryCategory",
    "ServiceNotification",
    "ServiceProcessingCycle",
    "ServiceProcessingEvent",
    "ServiceProcessingStatus",
    "ServiceProcessingStep",
    "ServiceStatus",
    "SettlementDay",
    "SettlementInformation",
    "SettlementInstruction",
    "SettlementMethod",
    "SettlementPriceDefaultElection",
    "SettlementPriceSource",
    "SettlementRateOption",
    "SettlementRateSource",
    "SharedAmericanExercise",
    "ShortSale",
    "SignatureMethodType",
    "SignaturePropertiesType",
    "SignaturePropertyType",
    "SignatureType",
    "SignatureValueType",
    "SignedInfoType",
    "SimpleCreditDefaultSwap",
    "SimpleFra",
    "SimpleIRSwap",
    "SimplePayment",
    "SingleUnderlyer",
    "SpecifiedRate",
    "SplitSettlement",
    "SpreadSchedule",
    "SpreadScheduleReference",
    "SpreadScheduleType",
    "StandardCreditSupportAnnex2013EnglishLaw",
    "StandardCreditSupportAnnex2013NewYorkLaw",
    "StandardCreditSupportAnnex2014EnglishLaw",
    "StandardCreditSupportAnnex2014NewYorkLaw",
    "StandardCreditSupportAnnexBase",
    "Step",
    "StepBase",
    "Strategy",
    "StrategyComponentIdentification",
    "StreetAddress",
    "Strike",
    "StrikeSchedule",
    "Stub",
    "StubFloatingRate",
    "StubValue",
    "SupervisorRegistration",
    "SupervisoryBody",
    "SwaptionPhysicalSettlement",
    "TelephoneNumber",
    "TerminatingEvent",
    "TimestampTypeScheme",
    "TimezoneLocation",
    "TouchRateObservation",
    "Trade",
    "TradeAmendmentContent",
    "TradeCategory",
    "TradeChangeBase",
    "TradeChangeContent",
    "TradeDifference",
    "TradeHeader",
    "TradeId",
    "TradeIdentifier",
    "TradeInformation",
    "TradeLegPriceChange",
    "TradeLegSizeChange",
    "TradeMaturity",
    "TradeNotionalChange",
    "TradeNovationContent",
    "TradePackage",
    "TradeProcessingTimestamps",
    "TradeReferenceInformation",
    "TradeTimestamp",
    "Trader",
    "TradingEventSummary",
    "TradingWaiver",
    "TransactionCharacteristic",
    "TransformType",
    "TransformsType",
    "TransportCurrency",
    "TriggerRateObservation",
    "Underlyer",
    "UnderlyerInterestLeg",
    "UnderlyerLoanRate",
    "UnderlyingAsset",
    "UnderlyingAssetTranche",
    "Unit",
    "UnprocessedElementWrapper",
    "UseOfPostedCreditSupport",
    "Validation",
    "Velocity",
    "VerificationMethod",
    "VerificationStatus",
    "VerificationStatusNotification",
    "VersionedContractId",
    "VersionedTradeId",
    "Withdrawal",
    "WithdrawalPartyTradeInformation",
    "WithdrawalReason",
    "X509DataType",
    "X509IssuerSerialType",
    "currencySpecificDayCountType",
    "originalMessageType"
]
